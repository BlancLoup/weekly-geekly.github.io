<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreading in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Found somehow on stack overflow the question ( link ). 
 Need to create java CLI programm that searchs for specific files matched some pattern. Need t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreading in practice</h1><div class="post__text post__text-html js-mediator-article"> Found somehow on stack overflow the question ( <a href="http://stackoverflow.com/questions/7499203/java-multithreaded-file-system-tree-traversal">link</a> ). <br> <code>Need to create java CLI programm that searchs for specific files matched some pattern. Need to use multi-threading approach without using util.concurrent package and to provide good performance on parallel controllers.</code> <br>  Transfer <br> <code>   ,     - .    ,     util.concurrent.    . <br></code> <br><br>  In general, the idea was not difficult in principle.  Because  By the condition, you cannot use util.concurrent, then you need to implement your thread pool, plus write some tasks that will spin in this thread pool. <br>  Also, I was not sure that with multi-threaded IO usage there will be an increase in performance. <br><a name="habracut"></a><br>  At once I will say that the goal was not the fulfillment of the task, but the investigation of the problem, therefore not all the code will be beautiful. <br><br>  In principle, the algorithm is similar to a recursive tree traversal, for example, its simple implementation <a href="http://rosettacode.org/wiki/Walk_a_directory/Recursively">link</a> <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainEntry</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ walkin(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"/home/user"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//Replace this with a suitable directory } /** * Recursive function to descend into the directory tree and find all the files * that end with ".mp3" * @param dir A file object defining the top directory **/ public static void walkin(File dir) { String pattern = ".mp3"; File listFile[] = dir.listFiles(); if(listFile != null) { for(int i=0; i&lt;listFile.length; i++) { if(listFile[i].isDirectory()) { walkin(listFile[i]); } else { if(listFile[i].getName().endsWith(pattern)) { System.out.println(listFile[i].getPath()); } } } } } }</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a start, let's check how fast a single-threaded implementation works, I‚Äôll not give a single-threaded implementation code, it is in the archive. <br>  The results are as follows: <br>  154531 ms <br><br>  Now we will try to do the same, but we will use a multi-threaded implementation of the algorithm. <br><br>  To do this, instead of a recursive call, we will create some Task, which we will give to the execution of a thread pool.  It is also necessary, so that by the result of the task, there was an opportunity to somehow report the results.  Plus, you need to add a new task to the thread pool (instead of recursion). <br>  Here we must immediately stop, why I chose precisely small tasks and a pool of threads, instead of creating new threads.  Imagine that we have a lot of directories, and for each directory we will create a new thread?  we can just fall by OOM (OutOfMemory) or just everything will start to slow down a lot because of switching between OS threads (especially if a single-core system).  We will also spend time starting a new thread each time it is created. <br><br>  First you need to create a class that will perform some action in the future thread pool. <br>  Basic requirements for the class: <br>  - the class should be inherited from Thread (in principle, you can only runnable interface, but it's easier) <br>  - class must accept runnable objects for execution <br>  - the class should not fall when any exceptions occur as a result of the task execution. <br>  - if there are no tasks, Thread should not work in empty, but should go on waiting <br>  - the procedure for adding new Runnable objects must be very fast, otherwise with a large number of small tasks, someone will either block the work of the thread, or wait for the opportunity to add a new task to the thread <br>  - well, it should be ThreadSafe <br><br>  Here is the code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BacklogWorker</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LinkedList&lt;Runnable&gt; backlog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;Runnable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INITIAL_CAPACITY = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Runnable&gt; workQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Runnable&gt;(INITIAL_CAPACITY); BacklogWorker(String name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enque</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable work)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (work != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { backlog.add(work); } notify(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isInterrupted()) { <span class="hljs-comment"><span class="hljs-comment">/*      ,   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (backlog.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { wait(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { interrupt(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = backlog.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; INITIAL_CAPACITY &amp;&amp; i &lt; size; i++) { workQueue.add(backlog.poll()); } backlog.clear(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Runnable task : workQueue) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { task.run(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { e.printStackTrace(); } } workQueue.clear(); } } }</code> </pre> <br><br>  Now you need to create a ThreadPool that will distribute the work between its threads. <br>  The requirements for the class are: <br>  - ThreadSafe <br>  - scalable <br>  - uniform distribution between worker threads <br>  - not blockable <br><br>  The code is: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BacklogThreadPool</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Executor</span></span></span><span class="hljs-class">/*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">don</span></span></span><span class="hljs-class">'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">use</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anything</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">concurrent</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">just</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">only</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">one</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">*/ </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BacklogWorker workers[]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BacklogThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadCount, String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tc; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (tc = <span class="hljs-number"><span class="hljs-number">1</span></span>; tc &lt; threadCount; tc &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) ; mask = tc - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { id = Integer.toString(getSequence()); } workers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BacklogWorker[tc]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; tc; i++) { workers[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BacklogWorker((<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder()).append(<span class="hljs-string"><span class="hljs-string">"thead-pool-worker-"</span></span>).append(id).append(<span class="hljs-string"><span class="hljs-string">":"</span></span>).append(i).toString()); workers[i].start(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sequence++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workers.length; i++) workers[i].interrupt(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable command)</span></span></span><span class="hljs-function"> </span></span>{ workers[command.hashCode() &amp; mask].enque(command); } }</code> </pre><br>  In principle, everything is clear, and probably nothing to comment on. <br><br>  Now we need to write a task that will be executed in ThreadPool. <br>  Unfortunately, the first version was lost for me, so I bring a quickly re-written version. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Matcher; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Pattern; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WalkinTask1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BacklogTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;File&gt; dirs; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ParseHandler parseHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WalkinTask1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;File&gt; dirs, ParseHandler parseHandler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseHandler = parseHandler; <span class="hljs-comment"><span class="hljs-comment">//this.parseHandler.taskStart(); this.parseHandler.taskStartUnblock(); this.dirs = dirs; } @Override public void run() { try { List&lt;String&gt; filePaths = new ArrayList&lt;String&gt;(); List&lt;File&gt; dirPaths = new ArrayList&lt;File&gt;(); for (File dir : dirs) { if (!dirPaths.isEmpty()) { dirPaths = new ArrayList&lt;File&gt;(); } if (!filePaths.isEmpty()) { filePaths = new ArrayList&lt;String&gt;(); } File listFile[] = dir.listFiles(); if (listFile != null) { for (File file : listFile) { if (file.isDirectory()) { dirPaths.add(file); } else { filePaths.add(file.getPath()); } } } if (!dirPaths.isEmpty()) { parseHandler.schedule(TaskFactory.createWalking1Task(parseHandler, dirPaths)); } if (!filePaths.isEmpty()) { Pattern pattern = parseHandler.getPattern(); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); for (String path : filePaths) { Matcher matcher = pattern.matcher(path); while (matcher.find()) { String str = matcher.group(); if (!"".equals(str)) { result.add(str); } } } parseHandler.taskComplete(result); } } } finally { //parseHandler.taskFinish(); parseHandler.taskFinishUnblock(); } } @Override public int getTaskType() { return 1; //TODO } }</span></span></code> </pre> <br><br>  Now let's talk a little about profiler.  What it is for, I will not describe, you can search yourself if you have not heard anything about such a little animal yet.  When profiling multithreaded applications, the most attention should be paid to Monitor Usage (each profiler has such an opportunity).  Usually this type of profiling should be started manually.  It is of interest how much time certain threads hang in anticipation of locks.  For example, you can create a bunch of threads, but they will all rest on some kind of lock, and the system performance will drop dramatically.  It is also worth paying attention to using the CPU, for example, if the CPU uses 10-20%, this can also mean that threads expect more locks than perform any calculations (although this is not always the case). <br><br>  Now let's see the result in the profiler: <br>  program execution time: <br>  total task: 78687 <br>  55188ms <br><br>  As a result, the speed of work increased by about 3 times. <br><br><img src="http://habrastorage.org/storage2/c6b/12d/102/c6b12d102e6a0d64dd55adb1f00931b8.jpg"><br>  Here we see that all the threads in the trappool were busy working almost the entire time.  Locking threads is almost not observed. <br><img src="http://habrastorage.org/storage2/dfd/74e/5f7/dfd74e5f79324013db13234bdce0c1aa.jpg"><br>  In the second picture, we see that the main CPU time is spent on IO. <br><img src="http://habrastorage.org/storage2/55e/731/43e/55e73143e492670f3dff19bb36d9def7.jpg"><br>  Here we see that CPU usage is&gt; 80%. <br><img src="http://habrastorage.org/storage2/68a/5aa/5c9/68a5aa5c9279a050d319532f5851ade1.jpg"><br>  Here we see only one thread lock, which took less than 1 ms, with 78 thousand tasks a very good result. <br><br>  As we see, in principle, we load the CPU, and we have no idle time, since all threads are almost fully loaded with work.  There are no locks on the locks. <br><br>  It will be interesting to look at the picture number 2. As we can see, the most ‚Äúexpensive‚Äù operation is java.io.File.isDirectory (), it takes about 46% of the total time.  Googling about this problem, I did not find anything except the ability to use Java7, well, or dependency OS features.  Therefore, the possibility of optimizing this part as I see no more.  Next comes the parser - java.util.regex.Matcher.find (), but here you can speed it up.  You can create another task, which will only deal with parsing.  Those.  we will separate the two most difficult operations: <br>  1) work with the file system <br>  2) name parsing <br>  The third operation is again IO, and this is also difficult to speed up. <br><br>  So we modify the first task a bit, and add a new one: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WalkinTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BacklogTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;File&gt; dirs; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ParseHandler parseHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WalkinTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;File&gt; dirs, ParseHandler parseHandler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseHandler = parseHandler; <span class="hljs-comment"><span class="hljs-comment">//this.parseHandler.taskStart(); this.parseHandler.taskStartUnblock(); this.dirs = dirs; } @Override public void run() { try { List&lt;String&gt; filePaths = new ArrayList&lt;String&gt;(); List&lt;File&gt; dirPaths = new ArrayList&lt;File&gt;(); for (File dir : dirs) { if (!dirPaths.isEmpty()) { dirPaths = new ArrayList&lt;File&gt;(); } if (!filePaths.isEmpty()) { filePaths = new ArrayList&lt;String&gt;(); } File listFile[] = dir.listFiles(); if (listFile != null) { for (File file : listFile) { if (file.isDirectory()) { dirPaths.add(file); } else { filePaths.add(file.getPath()); } } } if (!dirPaths.isEmpty()) { parseHandler.schedule(TaskFactory.createWalkingTask(parseHandler, dirPaths)); } if (!filePaths.isEmpty()) { parseHandler.schedule(TaskFactory.createParseTask(parseHandler, filePaths)); } } } finally { //parseHandler.taskFinish(); parseHandler.taskFinishUnblock(); } } @Override public int getTaskType() { return 1; //TODO } }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Matcher; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Pattern; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BacklogTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ParseHandler handler; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt; paths; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ParseHandler hander, List&lt;String&gt; paths)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handler = hander; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.paths = paths; handler.taskStartUnblock(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Pattern pattern = handler.getPattern(); List&lt;String&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String path : paths) { Matcher matcher = pattern.matcher(path); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (matcher.find()) { String str = matcher.group(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(str)) { result.add(str); } } } handler.taskComplete(result); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { handler.taskFinishUnblock(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTaskType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><br>  And run again: <br>  total task: 221560 <br>  52328 <br><img src="http://habrastorage.org/storage2/29e/d3b/923/29ed3b923e5379246c5a6e18f0bcc4aa.jpg"><br><br>  As we can see, the result is not very different from the first run, but still a little faster, especially the gain will increase if there are directories with a large number of files.  But with this approach, we have increased the number of tasks almost 3 times, which, for example, may affect the Garbage Collector.  So here we must already choose what we want - maximum performance or savings in memory and resources. <br><br>  Now we need to think about how to exit the program, and how to return the result.  We have produced a bunch of tasks, and we do not know when they will all be fulfilled.  I did not think of anything better, how easy it would be to count the total number of tasks, and wait until the counter reaches zero.  To do this, we need a variable in which we will accumulate values.  But here, too, things are not so simple.  For example, if we take an ordinary variable, and we increment it when the task has been created, and decrement it when the task has ended.  But with this approach, the result will be deplorable, because  in java, the i ++ operation is not atomic, even if we deliver the coveted volatile modifier.  It would be ideal to take AtomicIteger, but we cannot use the util.concurrent package by condition.  Therefore, we will have to make our Atomic.  If you delve into how Atomic works in java, then we stumble upon a native method.  The atomic nature of a variable change itself is implemented as a processor command, so java invokes the native OS command, which already calls the processor command. <br>  In principle, we can use normal synchronized.  But with a large number of tasks, the Lock race will begin, and the performance will decrease (although of course it is not critical).  Here is an example of code implementing the CAS algorithm (the code was found on the ibm website): <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimulatedCAS</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareAndSwap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expectedValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldValue = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == expectedValue) value = newValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oldValue; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CasCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SimulatedCAS value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulatedCAS(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.getValue(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldValue = value.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (value.compareAndSwap(oldValue, oldValue + <span class="hljs-number"><span class="hljs-number">1</span></span>) != oldValue) oldValue = value.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oldValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldValue = value.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (value.compareAndSwap(oldValue, oldValue - <span class="hljs-number"><span class="hljs-number">1</span></span>) != oldValue) oldValue = value.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oldValue - <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br><br>  Here in the evening, that's all. <br>  Source archive: <a href="http://narod.ru/disk/38849544001/home.zip.html">link</a> <br><br>  PS I tested it on Linux, and on Windows on a 4-core processor.  The optimal number of threads in the pool was calculated experimentally - 16, i.e.  the number of cores * 4, once found on the Internet already such a formula, but I do not remember where.  In Windows, there is a feature when you start it for the first time, it works for a very long time, and often everything hangs on IO, but already at the second start, everything works much faster, I think this is a feature of the OS to cache the file system.  I tested everything with the second launch and further, then I looked at the CPU utilization in the profiler, if there was a failure in using the CPU somewhere, I considered this test to be inaccurate and did not use this test in statistics.  I tested everything on the project folder (many large projects with CVS files). <br><br>  PSS This is my first big topic on Habr√©, so please do not criticize too much in terms of design, I will fix it if possible. </div><p>Source: <a href="https://habr.com/ru/post/137065/">https://habr.com/ru/post/137065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137059/index.html">Maven: Answers to Questions</a></li>
<li><a href="../137060/index.html">Meet Goliath</a></li>
<li><a href="../137061/index.html">How to transcode latin1 to cyrillic</a></li>
<li><a href="../137062/index.html">Secure Payments with ActivateTo Codes (Part I)</a></li>
<li><a href="../137063/index.html">Two rules for a good iPhone app icon</a></li>
<li><a href="../137066/index.html">Memory capture / release speed in C #</a></li>
<li><a href="../137067/index.html">116 sites for promoting iPhone / iPad applications</a></li>
<li><a href="../137068/index.html">If there is no money left for marketing, or is there life in the valley of death?</a></li>
<li><a href="../137069/index.html">Practical bioinformatics</a></li>
<li><a href="../137070/index.html">Novice Project Manager - Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>