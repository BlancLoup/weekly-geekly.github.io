<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Correct insertion of C ++ preprocessor definitions in CMake</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preprocessor definitions (preprocessor definitions) are often used in C ++ projects for conditional compilation of selected sections of code, for exam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Correct insertion of C ++ preprocessor definitions in CMake</h1><div class="post__text post__text-html js-mediator-article">  Preprocessor definitions (preprocessor definitions) are often used in C ++ projects for conditional compilation of selected sections of code, for example, platform-specific, etc.  This article will consider, apparently, the only (but extremely difficult to debug) rake, which can be stepped on by defining # define through compiler flags. <br><br>  As an example, take the <a href="http://www.cmake.org/">CMake</a> build system, although the same actions can be performed in any of its other popular counterparts. <br><a name="habracut"></a><br><h4>  Introduction and description of the problem </h4><br>  Some platform-specific definitions, such as testing on Windows / Linux, are put down by the compiler, so they can be used without additional help from build systems.  However, many other checks, such as the presence of #include files, the presence of primitive types, the presence of required libraries in the system, or even a simple definition of the system‚Äôs bitness, are much easier to do outside, passing the required definitions through the compiler flags.  In addition, you can simply pass additional definitions: <br><br><div class="spoiler">  <b class="spoiler_title">An example of passing # define through compiler flags</b> <div class="spoiler_text"><pre><code class="bash hljs">g++ myfile.cpp -D MYLIB_FOUND -D IOS_MIN_VERSION=6.1</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> MYLIB_FOUND #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mylib/mylib.h&gt; void DoStuff() { mylib::DoStuff(); } #else void DoStuff() { // own implementation } #endif</span></span></span></span></code> </pre><br></div></div><br>  In CMake, setting # define through the compiler is done using <a href="http://www.cmake.org/cmake/help/v3.0/command/add_definitions.html">add_definitions</a> , which adds compiler flags to the entire current project and its subprojects, like almost all CMake commands: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">add_definitions</span></span>(-DMYLIB_FOUND -DIOS_MIN_VERSION=<span class="hljs-number"><span class="hljs-number">6.1</span></span>)</code> </pre><br>  It would seem that there can be no problems here.  However, with carelessness, you can make a serious mistake: <br><br>  If some #define supplied by the compiler for project A is checked in the header file of the same project A, then if #include this header file from another project B, which is not a subproject A, this #define will <b>not</b> be affixed. <br><br><h5>  Example 1 (simple) </h5><br>  A working example of the error described can be viewed at <a href="https://github.com/dreamzor/cmake-nuances/tree/master/add_definitions/wrong">github / add_definitions / wrong</a> .  Under the spoiler, just in case, significant pieces of code are duplicated: <br><br><div class="spoiler">  <b class="spoiler_title">add_definitions / wrong</b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(wrong) <span class="hljs-keyword"><span class="hljs-keyword">add_subdirectory</span></span>(lib) <span class="hljs-keyword"><span class="hljs-keyword">add_subdirectory</span></span>(exe)</code> </pre><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(lib) <span class="hljs-keyword"><span class="hljs-keyword">add_definitions</span></span>(-DMYFLAG=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">add_library</span></span>(lib lib.h lib.cpp)</code> </pre><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(exe) <span class="hljs-keyword"><span class="hljs-keyword">add_executable</span></span>(exe exe.cpp) <span class="hljs-keyword"><span class="hljs-keyword">target_link_libraries</span></span>(exe lib)</code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// lib.h static void foo() { #ifdef MYFLAG std::cout &lt;&lt; "foo: all good!" &lt;&lt; std::endl; #else std::cout &lt;&lt; "foo: you're screwed :(" &lt;&lt; std::endl; #endif } void bar(); // implementation in lib.cpp</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// lib.cpp #include "lib.h" void bar() { #ifdef MYFLAG std::cout &lt;&lt; "bar: all good!" &lt;&lt; std::endl; #else std::cout &lt;&lt; "bar: you're screwed :(" &lt;&lt; std::endl; #endif }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// exe.cpp #include "lib/lib.h" int main() { foo(); bar(); }</span></span></code> </pre><br></div></div><br>  Running `exe` will output: <br><br><pre> <code class="markdown hljs">foo: you're screwed :( bar: all good!</code> </pre><br>  This example is very simple: it even has some kind of output to the console.  In reality, such an error can occur when connecting sufficiently sophisticated libraries like <a href="https://www.threadingbuildingblocks.org/">Intel Threading Building Blocks</a> , where part of the low-level parameters can actually be passed through preprocessor definitions, and they are also used in header files.  The search for amazing mistakes in such conditions is extremely painful and long, especially when this nuance of add_definitions has not been encountered before. <br><br><h5>  Example 2 </h5><br>  For clarity, instead of two projects we will use one, instead of add_definitions, there will be an ordinary #define inside the code, and we will refuse from CMake.  This example is another greatly simplified, but real situation that presents interest, including from the point of view of general knowledge of C ++. <br><br>  The running code can be viewed on <a href="https://github.com/dreamzor/cmake-nuances/tree/master/add_definitions/cpphell">github / add_definitions / cpphell</a> .  As in the previous example, significant parts of the code under the spoiler: <br><br><div class="spoiler">  <b class="spoiler_title">add_definitions / cpphell</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ah class A { public: A(); // implementation in a.cpp with DANGER defined ~A(); // for illustrational purposes #ifdef DANGER std::vector&lt;int&gt; just_a_vector_; std::string just_a_string_; #endif // DANGER };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #define DANGER // let's have a situation #include "ah" A::A() { std::cout &lt;&lt; "sizeof(A) in A constructor = " &lt;&lt; sizeof(A) &lt;&lt; std::endl; } A::~A() { std::cout &lt;&lt; "sizeof(A) in A destructor = " &lt;&lt; sizeof(A) &lt;&lt; std::endl; std::cout &lt;&lt; "Segmentation fault incoming..." &lt;&lt; std::endl; }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "ah" // DANGER will not be defined from here void just_segfault() { A a; // segmentation fault on 'a' destructor } void verbose_segfault() { A *a = new A(); delete a; } int main(int argc, char **argv) { std::cout &lt;&lt; "sizeof(A) in main.cpp = " &lt;&lt; sizeof(A) &lt;&lt; std::endl; // verbose_segfault(); // uncomment this just_segfault(); std::cout &lt;&lt; "This line won't be printed" &lt;&lt; std::endl; }</span></span></code> </pre><br></div></div><br>  The mistake is beautiful.  One file (a.cpp) sees the class members hidden under # ifdef-ohm, and the other (main.cpp) does not.  For them, classes become of different sizes, which causes problems with memory management, in particular, Segmentation Fault: <br><br><pre> <code class="bash hljs">g++ main.cpp a.cpp -o main.out &amp;&amp; ./main.out</code> </pre><br><pre> <code class="markdown hljs">sizeof(A) in main.cpp = 1 sizeof(A) in A constructor = 32 sizeof(A) in A destructor = 32 Segmentation fault incoming... Segmentation fault (core dumped)</code> </pre><br>  If you uncomment verbose_segfault () in main.cpp, you will see at the end: <br><br><pre> <code class="markdown hljs"><span class="hljs-strong"><span class="hljs-strong">*** Error in `./main.out': free(): invalid next size (fast): 0x000000000149f010 **</span></span>* ======= Backtrace: ========= ... ======= Memory map: ======== ...</code> </pre><br>  After a number of experiments, it turned out that if instead of the STL classes we used any number of primitive types in the fields of class A, then there were no drops, since destructors are not called for them.  In addition, if you insert a single std :: string (on 64-bit Arch Linux and GCC 4.9.2 sizeof (std :: string) == 8), then there is no fall, and if you have two, you already have it.  I think the point is alignment, but I hope that in the comments they will be able to explain in detail what is actually happening. <br><br><h4>  Possible solutions </h4><br><h5>  Do not use "external" definitions in header files. </h5><br>  If this is possible, then this is the easiest option.  Unfortunately, sometimes under # ifdefs there are various platform and compiler-dependent function signatures, and some <a href="https://bitbucket.org/eigen/eigen/src">libraries</a> generally consist only of header files. <br><br><h5>  Use add_definitions in the root CMakeLists.txt </h5><br>  This, of course, solves the problem of ‚Äúforgotten‚Äù flags for a specific project, but the consequences are as follows: <br><br><ul><li>  The command line parameters of the compiler will include all flags for all projects, including those projects that do not need these flags - difficulty in debugging, for example, through make VERBOSE = 1, when you want to understand what this compiler causes on a particular file. </li><li>  This project cannot be ‚Äúembedded‚Äù as a subproject in another project, because then exactly the same problem will be observed.  It is worth noting that in CMake the process of embedding a project, most often, is completely painless, and this possibility is often not worth neglecting. <br></li></ul><br><h5>  Use configuration header files and configure_file </h5><br>  CMake provides the ability to create configuration headers with <a href="http://www.cmake.org/cmake/help/v3.0/command/configure_file.html">configure_file</a> .  Pre-prepared templates are stored in the repository, from which, at the time of building the CMake project, the configuration files themselves are generated.  Generated # files are included in the required project header files. <br><br>  When using configure_file, it should be remembered that now putting the preprocessor definitions ‚Äúoutside‚Äù of a specific project via add_definitions will not work.  Of course, you can make a special configuration file, which puts down flags only if they have not yet been affixed (#ifndef), but this will make even more confusion. <br><br><h4>  Conclusion </h4><br>  The errors and solutions shown are, of course, suitable not only for CMake projects, but also for projects with other build systems. <br>  I hope this article will save someone a lot of time once when debugging completely magical errors in C ++ projects that contain pre-processor definitions in header files. </div><p>Source: <a href="https://habr.com/ru/post/254365/">https://habr.com/ru/post/254365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254353/index.html">Optimization Planning with Unity</a></li>
<li><a href="../254355/index.html">All about collections in Oracle</a></li>
<li><a href="../254357/index.html">Basket for product catalog (minibasket.js)</a></li>
<li><a href="../254361/index.html">Indoor "GPS" with an accuracy of -2 cm</a></li>
<li><a href="../254363/index.html">Analysis of the tasks of the first qualifying round of the Russian Code Cup 2015</a></li>
<li><a href="../254367/index.html">See you at EMC Technology Day # 3</a></li>
<li><a href="../254369/index.html">Savings on printing documents: turnkey solutions</a></li>
<li><a href="../254373/index.html">Xaml context injectors</a></li>
<li><a href="../254379/index.html">Audio watermark for Second Screen applications</a></li>
<li><a href="../254381/index.html">IO Ninja - programmable terminal emulator / sniffer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>