<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android VIPER on jet propulsion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The more lines of code written, the less often you want to duplicate the code, and the more projects are implemented, the more often you get around th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android VIPER on jet propulsion</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c6e/5b9/8b4/c6e5b98b49164b1c9d1a779cda07833a.jpg" width="600"><br><br>  The more lines of code written, the less often you want to duplicate the code, and the more projects are implemented, the more often you get around the old, though often favorite, rakes, and you become more and more interested in architectural solutions. <br><a name="habracut"></a><br>  I think it‚Äôs not unusual for Android to meet an architectural template <a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a> , beloved by iOS developers, we also missed the conversation from a neighboring department about it at first, until we suddenly found that we could not help using such a template in our Android applications. <br><br>  How could this happen?  Yes, very simple.  The search for elegant architectural solutions began long before Android applications, and one of my favorite and irreplaceable rules has always been - the division of the project into three loosely coupled layers: Data, Domain, Presentation.  And now, once again studying the Internet for new trends in architectural templates for Android applications, I came across a great solution: <a href="https://github.com/android10/Android-CleanArchitecture">Android Clean Architecture</a> , here, in my humble opinion, everything was fine: splitting into favorite layers, Dependency Injection, implementation The presentation layer is like MVP, a familiar and frequently used Repository template for the data layer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But besides the long-time favorite and familiar techniques in the design was a place and discoveries.  It was this project that introduced me to the concept of Interactor (an object containing business logic for working with one or several entities), and it was here that the power of reactive programming opened up to me. <br><br>  Reactive programming, and <a href="http://reactivex.io/">rxJava</a> in particular, <a href="http://reactivex.io/">is</a> quite a popular topic of reports and articles over the past year, so you can easily get acquainted with this technology (if of course you are not familiar with it), and we will continue the story about VIPER. <br><br>  Familiarity with <a href="https://github.com/android10/Android-CleanArchitecture">Android Clean Architecture</a> led to the fact that any new project, as well as refactoring of existing ones, was reduced to three-layer, rxJava and <a href="https://ru.wikipedia.org/wiki/Model-View-Presenter">MVP</a> , and Interactors were used as the domain layer.  There was an open question about the correct implementation of the transitions between the screens and here the notion of Router began to sound more and more often.  At first, Router was single and lived in the main Activity, but then new screens appeared in the application and Router became very cumbersome, and then another Activity appeared with its Fragments and then I had to think seriously about navigation.  All the main logic, including switching between the screens, is contained in the Presenter, respectively, the Presenter needs to know about the Router, which in turn must have access to the Activity to switch between the screens, so the Router must have its own for each Activity and be transmitted to Presenter at creation. <br><br>  And somehow, once again looking at the project, it was understood that we had VIPER - View, Interactor, Presenter, Entity and Router. <br><img src="https://habrastorage.org/files/b32/c3b/c22/b32c3bc22ccd4c12b8f3b6dc89de81a7.png"><br>  I think you noticed on the Observable scheme - this is where all the power of jet thrust is hidden.  The data layer does not simply retrieve data from the remote or local storage in the necessary representation for us; it sends the entire sequence of actions to the Interactor wrapped in Observable, which in turn can continue this sequence at its discretion based on the task being implemented. <br><br>  And now let's analyze a small example of the VIPER implementation for Android ( <a href="https://github.com/VictoriaSlmn/Android-VIPER">source code</a> ): <br>  Suppose that we are faced with the task of developing an application that once every three seconds requests a list of messages from a ‚Äúnot very flexible‚Äù server and displays the latest for each sender, and also notifies the user about new ones.  By tapu on the last message, a list of all messages for the selected sender appears, but the messages still continue to synchronize with the server once every 3 seconds.  Also from the main screen we can get to the contact list, and view all the messages for one of them. <br><br>  And so, let's start, we have three screens: chats (latest messages from each contact), a list of messages from a particular contact and a list of contacts.  Throw a class diagram: <br><br><img src="https://habrastorage.org/files/b3e/b5f/1e9/b3eb5f1e9968448fbfdacd4ce0ec4b3f.png"><br><br>  The screens are fragments, the transitions between which are regulated by the Activity, which implements the Router interface.  Each fragment has its own Presenter and implements the interface necessary for interacting with it.  To facilitate the creation of a new Presenter and a fragment, the base abstract classes were created: BasePresenter and BaseFragment. <br><br>  BasePresenter - contains links to the View and Router interface, and also has two abstract methods onStart and onStop, which repeat the fragment life cycle. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePresenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> View view; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Router router; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> View </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = view; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Router </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Router router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router = router; } }</code> </pre> <br><br>  BaseFragment - performs the main work with BasePresenter: initializes and transfers the interaction interface to onActivityCreated, calls onStart and onStop in the corresponding methods. <br><br>  Any Android application starts with Activity, we will have only one MainAcivity in which the fragments are switched. <br><br><img src="https://habrastorage.org/files/ca8/e0d/d99/ca8e0dd9961c458d8fc34e45fef8a1b7.png"><br><br>  As mentioned above, Router lives in an Activity, in a particular example, the MainActivity simply implements its interface, respectively, for each Activity its own Router, which controls the navigation between the fragments inside it, therefore each fragment in such an Activity should have a Presenter using the same Router : And so appeared BaseMainPresenter, which must be inherited by every Presenter working in MainActivity. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMainPresenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMainView</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePresenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainRouter</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre><br><br>  When changing fragments in the MainActivity, the Toolbar and FloatingActionButton's state changes, so each fragment should be able to communicate the necessary state parameters to the Activity.  To implement this interaction interface, BaseMainFragment is used: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMainFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMainView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Toolbar @DrawableRes public abstract int getFabButtonIcon(); // FloatingActionButton //    FloatingActionButton public abstract View.OnClickListener getFabButtonAction(); @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); MainActivity mainActivity = (MainActivity) getActivity(); //   getPresenter().setRouter(mainActivity); // MainActivity    Toolbar  FloatingActionButton mainActivity.resolveToolbar(this); mainActivity.resolveFab(this); } @Override public void onDestroyView() { super.onDestroyView(); //    getPresenter().setRouter(null); } ‚Ä¶. }</span></span></code> </pre><br><br>  BaseMainView is another basic entity for creating fragments in MainActivity, this is an interaction interface that every Presenter in MainActivity knows about.  BaseMainView allows you to display an error message and display alerts; this interface implements BaseMainFragment: <br><br><pre> <code class="java hljs">... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@StringRes </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message)</span></span></span><span class="hljs-function"> </span></span>{ Toast.makeText(getContext(), getString(message), Toast.LENGTH_LONG).show(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewMessagesNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Snackbar.make(getView(), R.string.new_message_comming, Snackbar.LENGTH_LONG).show(); } ...</code> </pre><br><br>  Having blanks in the form of such base classes significantly accelerates the process of creating new fragments for the MainActivity. <br><br>  <b>Router</b> <br>  But what turned out MainRouter: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showMessages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  <b>Interactor</b> <br>  Each Presenter uses one or more Interactor to work with data.  Interactor has only two public methods execute and unsubscribe, that is, Interactor can be launched for execution and unsubscribe from the running process: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterType</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CompositeSubscription subscription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeSubscription(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Scheduler jobScheduler; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Scheduler uiScheduler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Interactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scheduler jobScheduler, Scheduler uiScheduler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobScheduler = jobScheduler; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uiScheduler = uiScheduler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Observable&lt;ResultType&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ParameterType parameter)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ParameterType parameter, Subscriber&lt;ResultType&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ subscription.add(buildObservable(parameter) .subscribeOn(jobScheduler) .observeOn(uiScheduler) .subscribe(subscriber)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ subscription.clear(); } }</code> </pre><br><br>  <b>Entity</b> <br>  For access to data, Interactor uses one or several DataProvider and forms rx.Observable for subsequent execution. <br><br>  Task setting for the considered example included the need to make a periodic request to the server, which was easily implemented with the help of RX: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PERIOD_UPDATE_IN_SECOND = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Observable&lt;List&lt;Message&gt;&gt; getAllMessages(Scheduler scheduler) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable .interval(<span class="hljs-number"><span class="hljs-number">0</span></span>, PERIOD_UPDATE_IN_SECOND, TimeUnit.SECONDS, scheduler) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::getMessages); }</code> </pre><br><br>  The above code example every three seconds makes a request to receive a list of messages and sends an alert to the subscriber. <br><br>  <b>Conclusion</b> <br>  Architecture is the skeleton of the application, and if you forget about it, you can end up with a freak.  A clear division of responsibility between layers and class types makes it easier to support, test, introduce a new person to a project, takes less time and adjusts to a uniform programming style.  Base classes help avoid code duplication, and rx does not think about asynchrony.  An ideal architecture, like an ideal code, is practically unattainable, but to strive for it means to grow professionally. <br><br>  PS There are ideas to continue the cycle of articles, having told more about interesting cases in the implementation: <br>  presentation layer - saving state in the fragment, composite view; <br>  domain layer - Interactor for multiple subscribers; <br>  data layer - caching organization. <br>  If interested, put a plus :) </div><p>Source: <a href="https://habr.com/ru/post/277003/">https://habr.com/ru/post/277003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276989/index.html">Checking WPF source code for examples from Infragistics</a></li>
<li><a href="../276991/index.html">List of technical and IT conferences 2016. Part # 2</a></li>
<li><a href="../276995/index.html">Technologies: death and rebirth</a></li>
<li><a href="../276997/index.html">Creating your own theme for Visual Studio Code</a></li>
<li><a href="../277001/index.html">AngularJS adaptation of ui-select under x-editable with the additional ability to add objects on the fly</a></li>
<li><a href="../277005/index.html">Amazon has introduced a new free game engine Lumberyard</a></li>
<li><a href="../277009/index.html">How Google "cleans" its network from malicious publications</a></li>
<li><a href="../277011/index.html">CEPH Cluster: Chronology of work on the upgrade of our file storage to a new architecture (56Gb / s IB)</a></li>
<li><a href="../277013/index.html">Video conferencing Mind - the best choice for business</a></li>
<li><a href="../277015/index.html">Device Usage: Opportunities for Developers in 2016 and Beyond</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>