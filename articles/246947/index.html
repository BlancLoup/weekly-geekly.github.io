<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a synchronization barrier using C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Comparing two different parallel programming technologies: POSIX streams and C ++ 11 streams, you can see that the latter lacks an ana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a synchronization barrier using C ++ 11</h1><div class="post__text post__text-html js-mediator-article">  <b>Introduction</b> <br><br>  Comparing two different parallel programming technologies: POSIX streams and C ++ 11 streams, you can see that the latter lacks an analogue of the type barrier_t from the pthread library. <br><br>  It is rather strange that such an important synchronization primitive is missing in the standard library.  This article will discuss how to make a barrier using only the libraries included in the C ++ 11 standard set. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Definition</b> <br>  Barrier is one of the synchronization primitives.  It is created on a number of threads.  When the first thread finishes its work, it remains to wait at the barrier and waits until the other threads are completed. <br>  As soon as the barrier accumulates exactly as many streams as the barrier was created, all the flows that are expected at the barrier continue their work. <br><br>  <b>Let's start creating your own barrier, with blackjack and ...</b> <br><a name="habracut"></a><br>  First of all, we need to connect the following libraries included in the C ++ 11 standard: <br><pre><code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;thread&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;atomic&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;condition_variable&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt;</span></span></span></span></code> </pre> <br><br>  Now you probably ask, why do we need all these libraries?  Well, the first for the barrier is not needed, but I do not think that you can check your code without connecting this library. <br><br>  But first things first! <br><br>  What is the most important field for the barrier?  Obviously, the number of threads. <br>  What else do you need to know the barrier?  The number of threads that is currently waiting for it. <br><br>  The hand and stretches to write <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre><br><br>  However, let's think a bit.  The barrier is already slowing down the application, since synchronization takes time.  Thus, we would like to reduce the cost of creating and processing the barrier itself. <br>  Therefore, atomic operations are more suitable for changing the number of flows that are expected at the barrier. <br><br>  So, our class now looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre><br><br>  Well, the skeleton class we wrote.  We can create an object of this class, there is a constructor, there is a copy constructor ... <br>  I'm sorry, what did I say?  In general, when combining object-oriented and parallel programming, it is better to get rid of copy constructors in order to protect themselves from unpleasant consequences. <br><br>  Well, C ++ 11 allows you to explicitly disable this constructor. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; } barrier(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> barrier &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre><br><br>  So, we figured it out.  It remains only to write the method for which we all started it.  Waiting at the barrier. <br><br>  The following idea comes to mind: let's make a logical variable that will be responsible for waiting at the barrier or passing it, and implement the behavior with the help of a conditional variable according to this very condition. <br><br>  So let's fix our class with new fields: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNotWaiting; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable waitVariable; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; } barrier(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> barrier &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre><br><br>  Now let's deal with the method.  If not all the threads have passed yet, then the flows that reached the barrier should sleep on this conditional variable, i.e. the following code should be executed <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); waitVariable.wait(lock, [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noWait; });</code> </pre><br><br>  If all the flows have passed, then we must notify the remaining flows that there is no need to wait any longer on the barrier.  This will make the following code: <br><pre> <code class="hljs objectivec">isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; waitVariable.notify_all(); threadsWaiting.store(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  The latter method atomic writes the number 0 to the threadsWaiting variable. <br><br>  Now it remains to solve one simple question: how to combine these two cases.  How do we know how many streams are waiting on the barrier? <br><br>  Now we remember how the barrier is arranged.  To wait for a flow at a barrier, <b>all</b> flows must call a barrier function.  Thus, as soon as the wait method is called, we must immediately increase our threadsWaiting variable by 1. <br>  For this we use a function like fetch_add.  This is one of the so-called RMW operations (read-modify-write).  It reads the value of an atomic variable, adds it atomic to the argument, and writes a new value to it, while returning the old one. <br><br>  Thus, the two cases described above are combined by a conditional operator, and our class looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNotWaiting; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable waitVariable; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; } barrier(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> barrier &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadsWaiting.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= threadCount - <span class="hljs-number"><span class="hljs-number">1</span></span>) { isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; waitVariable.notify_all(); threadCount.store(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); waitVariable.wait(lock,[&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isNoWaiting;}); } };</code> </pre><br><br>  Now it only remains to set the initial value of the isNotWaiting variable, which is obviously false. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">barrier</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; threadsWaiting; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNotWaiting; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable waitVariable; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: barrier(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } barrier(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> barrier &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadsWaiting.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= threadCount - <span class="hljs-number"><span class="hljs-number">1</span></span>) { isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; waitVariable.notify_all(); threadCount.store(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); waitVariable.wait(lock,[&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isNotWaiting;}); } };</code> </pre><br><br>  So, we wrote a class for a barrier using standard C ++ 11 without connecting third-party libraries. <br><br>  Now you can argue to me: well, I wrote some code?  And where is the proof that it works? <br><br>  So the most important part: demonstrating the barrier <br><br><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;atomic&gt; #include &lt;condition_variable&gt; #include &lt;mutex&gt; class barrier { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsigned int threadCount; std::atomic&lt;unsigned int&gt;threadsWaiting; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> isNotWaiting; std::condition_variable waitVariable; std::mutex mutex; public: barrier(unsigned int n) : threadCount(n) { threadsWaiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } barrier(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> barrier &amp;) = delete; void wait() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadsWaiting.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= threadCount - <span class="hljs-number"><span class="hljs-number">1</span></span>) { isNotWaiting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; waitVariable.notify_all(); threadsWaiting.store(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::unique_lock&lt;std::mutex&gt; lock(mutex); waitVariable.wait(lock,[&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isNotWaiting;}); } } }; barrier *myBarrier; class Thread { private: std::thread* cppthread; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void threadFunction(Thread* arg) { arg-&gt;run(); } public: Thread() {} Thread(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Thread&amp;) = delete; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Thread() {delete cppthread;} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void run() = <span class="hljs-number"><span class="hljs-number">0</span></span>; void start() { cppthread = new std::thread(Thread::threadFunction, this); } void wait() { cppthread-&gt;join(); } }; class BarrierDemo: public Thread { int id; public: BarrierDemo(int i) { id = i; } void run() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Thread "</span></span> &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">"runs before barrier"</span></span> &lt;&lt; std::endl; myBarrier-&gt;wait(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Thread "</span></span> &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">"runs after barrier"</span></span> &lt;&lt; std::endl; } }; int main() { <span class="hljs-comment"><span class="hljs-comment">// your code goes here int threads; std::cin &gt;&gt; threads; myBarrier = new barrier(threads); BarrierDemo* bardemos = static_cast&lt;BarrierDemo*&gt;(::operator new(sizeof(BarrierDemo)*threads)); for (int i = 0; i &lt; threads; i++) { new (&amp;bardemos[i])BarrierDemo(i); bardemos[i].start(); } for (int i = 0; i &lt; threads; i++) { bardemos[i].wait(); } ::operator delete(bardemos); delete myBarrier; return 0; }</span></span></code> </pre><br><br>  You can copy the above code to a compiler with C ++ 11 support to test its functionality.  This article ends here. <br><br>  PS It is easy to guess from the above code that this is a ‚Äúone-time‚Äù barrier: as soon as all threads pass through it, you cannot reuse the same instance of the class as a barrier. </div><p>Source: <a href="https://habr.com/ru/post/246947/">https://habr.com/ru/post/246947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246937/index.html">Thermal barriers, tombstones and other delights of printed circuit boards</a></li>
<li><a href="../246939/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ28 (December 22 - 28, 2014)</a></li>
<li><a href="../246941/index.html">Vkontakte analysis on the example of the book preferences of participants of cultural communities</a></li>
<li><a href="../246943/index.html">A simple typing tutor for programmers</a></li>
<li><a href="../246945/index.html">TorrentLocker - a new modification of the FileCoder encryption Trojan, part 1</a></li>
<li><a href="../246951/index.html">Playing with genetic algorithms</a></li>
<li><a href="../246953/index.html">Why does OpenVPN slow down?</a></li>
<li><a href="../246955/index.html">FLProg and penguins</a></li>
<li><a href="../246957/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ140 (December 22 - 28, 2014)</a></li>
<li><a href="../246959/index.html">Understanding Flux, reactive architecture from facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>