<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous programming - graph editor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes in the process of describing business logic, it is necessary to compile a graph of asynchronous operations with internal dependencies, i.e. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous programming - graph editor</h1><div class="post__text post__text-html js-mediator-article"><img src="http://nesteruk.org/pix/0/85702fef-9deb-4ea9-90ff-8b5062398ef7.jpg" align="right">  Sometimes in the process of describing business logic, it is necessary to compile a graph of asynchronous operations with internal dependencies, i.e.  when tasks are performed asynchronously, but some tasks depend on others and thus have to ‚Äúwait‚Äù until it can be started.  In this post, I want to show how this problem can be solved by creating a <strong>graphical DSL</strong> that allows the developer to visually determine the dependency graph. <br><br><a name="habracut"></a><br>  <strong>Nb:</strong> English article and source code are <a href="http://www.codeproject.com/KB/architecture/asyncdsl.aspx">here.</a> <br><br><br><h3>  Introduction </h3><br>  Generally speaking, domain-specific languages ‚Äã‚Äã(domain-specific languages, DSL for short) come in three forms.  The first type is text DSL, which is defined solely through text and structure, and is associated with a specific process of converting this text into code.  The second type is structural DSL, where content is defined using a tree or graph-like editor.  I want to discuss the third type - this is a graphical DSL, where the developer works with a graphical editor to create a visual structure, which can later be turned into code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, we will create a simple graphical DSL, which allows the end user to define asynchronous operations that will be organized using Pulse &amp; Wait.  To build the attached example, you need Visual Studio 2008 with the Visual Studio SDK.  We will use Microsoft DSL Tools (included in the SDK) to create our DSL. <br><br><h3>  Description of the problem </h3><br>  Since working with Pulse &amp; Wait is difficult, I want to make a graphical DSL that would allow me to determine the sequence of operations that can be organized using the Pulse &amp; Wait mechanism.  In particular, I want to be able to drag and drop asynchronous blocks in the editor, as well as the ability to define links between them to form rules for asynchronous, dependent execution. <br><br><h3>  Create DSL </h3><br>  Before we begin, let me explain the most important points when working with DSL Tools: <br><br><ul><li>  In DSL Tools, graphic DSLs themselves are made using graphic DSL.  At first glance this may seem confusing, but, in principle, you should understand that most of our asynchronous DSLs (which I call here AsyncDsl) will be developed using visual elements ‚Äî not with a programming language.  Of course, there will be a lot of code behind the scenes, but we will not encounter it often. <br></li><li>  DSL tools widely use T4 technology.  Our graphical DSL is actually only a visual representation of XML, and T4 turns this XML into code.  That way, when you edit visuals with DSL Tools, you are really editing XML. <br></li><li>  Your DSL is still created using C #, and it is compiled.  You can extend it with partial classes, etc., which allow your DSL to behave in a certain way.  We will not do anything like this in this article. <br></li><li>  Creating a DSL using the tools of DSL Tools applies only to the visual part - the part that allows the user to <em>visually</em> create XML models.  The part that turns it into plain text code is a separate problem, which we will meet later. <br></li></ul><br>  To create a DSL project in Visual Studio, select New Project, and then Other Project Types ‚Üí Extensibility ‚Üí Domain-Specific Language Designer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/eee/821/a3feee82110fd651ccd83b6483b07601.jpg"><br><br><br>  After clicking the OK button, you will be shown a wizard where you can identify some of the features of the DSL you are creating. <br><br><ul><li>  On the first page, in addition to determining the name of your language, you can also select the initial template.  This pattern defines what DSL has the initial capabilities ‚Äî for example, by choosing Task Flow, you determine that the initial DSL elements will relate to flowchart structures.  Regardless of which template you choose at this stage, you can always redefine the behavior of your DSL by deleting the initially generated elements. <br></li><li>  The second page allows you to choose a file extension for your DSL.  This extension will appear in places where you will insert your DSL into your own project.  In addition to the extension, the wizard generates an icon. <br></li><li>  The third page allows you to set some lines that define your DSL, such as the name of the product to which your DSL belongs. <br></li><li>  The fourth page actually forces you to sign your build ‚Äî either already existing or a new key. <br></li></ul><br>  When done with the wizard, you get a DSL definition framework.  If you have never worked with DSL functionality in Visual Studio, then the screenshot may shock you a bit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a7/c21/8b6/3a7c218b6d5614956be54f29875f28e2.jpg"><br><br><br>  The following elements take part in the DSL editing process: <br><br><ul><li>  Dsl Designer Toolbox.  This panel contains all the elements that you will work with when designing your DSL.  These elements are used in the same way as in WinForms - take an element and drag it into the editor window (the central window with strange boxes). <br></li><li> The DSL designer himself.  Actually, this is a file with the <code>.dsl</code> extension, but as you can see, the mega-visual editor is, as I said, DSLs themselves are built using other DSLs.  This DSL has two parts - on the left side there are classes and relations between them, and on the right side there are visual elements, i.e.  visual reflections of DSL concepts with which the end user will work.  Thus, you can imagine DSL like this: on the right is the visualization, on the left - the logic. <br></li><li>  Solution Explorer.  When creating a DSL, you will get <em>two</em> projects ‚Äî one defining the DSL you are doing and the other defining the editor for components related to DSL.  We will talk about this later - all that is important now is to mark one single button that transforms all the patterns: <br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/0f1/580/5b00f1580ce137d27aefa24d4a4183be.jpg"><br><br>  This is a <strong>very important</strong> button.  As I said before, DSLs are XML specifications that translate into code.  This means that in order to update our DSL definition (and definition is also DSL), you need to transform all the templates in C #.  The button above does just that.  Therefore, if you suddenly in the final DSL does not reflect any changes that you are sure that you have done - then you forgot to press this button. <br></li><li>  The DSL explorer.  This is a completely new panel in the studio, which presents your DSL in the form of a tree, and looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/92e/e71/985/92ee71985f74bb18460d09bfe4d6f026.jpg"><br><br><br>  This tree encapsulates many structural aspects of DSL.  It is important to note that some tree nodes have their own set of properties, which can be seen by pressing F4. <br><br></li><li>  Pages for editing property pages exist for both elements of the DSL Explorer tree and visual elements in the DSL editor.  Some DSL elements can be edited directly ‚Äúin the editor‚Äù ‚Äîfor example, you can define the shape of a relationship (one-to-many, many-to-many, etc.) between two elements without opening the properties panel.  How is it easier to do - you decide. <br></li></ul><br>  Let's now delve into the process of creating our DSL. <br><br><h3>  Arranging Visuals </h3><br>  As I already wrote, the toolbox contains all the elements with which you have to work.  These elements are divided into two groups - ‚Äúlogical‚Äù and ‚Äúvisual‚Äù.  The gates are those that define the structure (i.e., domain) in your DSL.  Visual elements reflect those rectangles, lines, and similar elements that the user operates on when working with DSL. <br><br>  The core concept of the DSL logical structure is the domain class.  This class can represent <em>anything</em> , depending on what subject area you are working with.  As we work with asynchronous operations, one of our domain classes will be called <code>Operation</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/363/0fa/890/3630fa890301410948c27f7083eb7626.jpg"><br><br><br>  A domain class may have <em>properties</em> , i.e.  values ‚Äã‚Äãthat the user can set.  Our <code>Operation</code> class has <code>Timeout</code> , <code>Name</code> and <code>Description</code> properties that the end user can determine after dragging the instance of the <code>Operation</code> object to his model. <br><br>  There is a small problem here - in fact, the user is not dragging the domain class directly into its model.  Instead, it drags itself into the <code>OperationShape</code> model, which is a visual reflection of <code>Operation</code> .  This class is formed from <code>GeometryShape</code> (taken from the same toolbox): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a4/1da/59b/7a41da59bc0f558250357f0ad00313b5.jpg"><br><br><br>  Having defined the domain class <code>Operation</code> as well as its visual representation of the <code>OperationShape</code> , they need to be linked together (if run as it is, nothing will work).  For this, the Diagram Element Map element is used.  In fact, this thing is the line that connects the two elements, defining the association between them.  But even if you add it, still nothing will work. <br><br><h3>  Relationship between elements </h3><br>  Before we start working with creating toolbox controls for our DSL (which is fun), we need to talk about the relationships between the elements.  There are two types of relationships - Embedding Relationship and Reference Relationship.  If you use an embedding relationship, element A will be completely enclosed in element B. For example, if I have a swimlane (a large horizontal piece of visual space) and need to embed whole classes in it, then it makes sense to use an embedding relationship.  If I just have blocks to attach comments to, the reference relationship will also go. <br><br>  Let's look at how we will use the elements for our specific task.  In the ‚Äúroot‚Äù of our mozheli we have an element <code>ExampleModel</code> .  I will not even change the name of this element, since  he will not be featured in the ultimate DSL.  In order to determine if my model contains processes and comments, I draw the embedding relationship lines between the respective classes and get the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5b/d67/a23/c5bd67a23beb6a4d88c57255f52c0ed4.jpg"><br><br><br>  Orange boxes symbolize the relationship, with the names and cardinality of the relationship on both sides.  Cardinality is later regulated by the DSL designer, so that the end user cannot break it.  As for the relationship, the meaning of these orange boxes is that they allow you to link together different domain classes when editing an already finished DSL. <br><br>  <strong>Note: The</strong> DSL designer applies a set of rules to your language, one of which requires that all elements are part of something.  This means that all elements must be reduced to a single, ‚Äúprimary‚Äù container.  (If you recall that DSL == XML, the reason for this requirement should be obvious.) <br><br>  We used the embedding relationship to tell our DSL that both processes and comments are part of a general model.  We can now use the reference relationship to determine that processes can have comments, and that these two elements can be linked. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8a/b37/7d9/c8ab377d9860cf49ce37a4615fdc8792.jpg"><br><br><br>  The dotted line above indicates a reference relationship, i.e.  in our case, the operation can simply <em>refer</em> to the comment - and not contain it.  Of course, this relationship has its own visual element (the line that connects the operation and comment), which we now talk about. <br><br><h3>  Toolboxes, finally </h3><br>  Having obtained the logical and visual part of your DSL, you need to give users the ability to drag and drop items from this DSL onto their designer.  This is where to start - from the Editor node in DSL Explorer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/624/95b/9a9/62495b9a9c39b68654be8606aaae0f7a.jpg"><br><br>  To create a new item for the toolbox, right-click on the entire DSL.  You will get the following menu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/738/d93/52d/738d9352d7bcf007dc300e8df4d0bb75.jpg"><br><br><br>  There are two options - connectors and elements.  Connectors are the lines (even perhaps with arrows) that connect elements together.  And the elements are block-like structures. <br><br>  After creating a new item, press F4 and you will see the properties of this item: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d6/9e2/5cc/0d69e25cc13d1ed21a6fc4dc85209dc9.jpg"><br><br><br>  What is important here is that several of these properties must be filled in, otherwise DSL will not start.  From those that obviously need to be defined - the definition of a domain class that reflects the element, as well as the definition of the icon.  (A couple of default icons have already been provided, so if you are too lazy to create your own, you can use ready-made ones.) <br><br><h3>  Run! </h3><br>  Summarize the DSL creation process: <br><br><ol><li>  Made a base DSL using a wizard <br></li><li>  Added domain classes representing the concepts we need, such as a <em>process</em> . <br></li><li>  The relationships between the doom classes have been added - in our case, they determined that the operations belong to the general model and that they have comments.  Also added operations transition between operations, as well as elements of the beginning and end. <br></li><li>  Identified the visual elements that our DSL will use. <br></li><li>  Associated visual elements with domain classes. <br></li><li>  Created toolbox controls and associated them with the corresponding classes. <br></li></ol><br>  Our DSL is half ready: we have defined only the visual part.  After we have transformed all the templates and launched our language, we can finally start playing with our DSL: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eee/f8e/7b7/eeef8e7b7eb6413340992c3f236f0aa4.jpg"><br><br><br><h3>  Concepts </h3><br>  For our asynchronous DSL, we defined the following idioms: <br><br><ul><li>  <strong>Operation</strong> <br>  This is our unit of work, for example, to make tea.  We mean that the operation can take place without any failures. <br></li><li>  <strong>Process</strong> <br>  A process is a sequence of operations in a graph.  The only reason we added this element is to be able to keep several operation graphs in the same class. <br></li><li>  <strong>Start</strong> and <strong>Finish</strong> <br>  The process must begin and end somewhere, so we created two elements to label the beginning and end states. <br></li><li>  <strong>Finish-to-start transition</strong> <br>  This transition determines that the operation can only be started after another operation is completed. <br></li><li>  <strong>Start-to-start transition</strong> <br>  This transition determines that the operation can begin only when another operation has been started, and not earlier. <br></li></ul><br>  Let's look at a real example: the process of eating breakfast (I know, not very clever).  To make breakfast, you need to put the kettle, as well as put the bread in the toaster - in any order.  While everything is being prepared, I want to get some jam, but only if I have already turned on the toaster.  When I got the finished bread and got the jam, I can make a sandwich.  And only when both the sandwich and the tea are ready, can I start absorbing the breakfast. <br><br>  Using our DSL, the whole process can be defined like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/2fe/d00/e552fed00aaa7f39f1a7e0491819e67f.jpg"><br><br><br>  As you probably already guessed, the bold lines symbolize finish-to-start, and the dotted line, start-to-start. <br><br><h3>  Transform the model with T4 </h3><br>  The visual model of breakfast exists only as DSL, so we need T4 to turn it into a complete code.  Fortunately, by the time we have to do the conversion, the model has already been converted to XML format, and all that remains is to go around it and generate what we need. <br><br>  The production of the final result in T4 moves by several methods, such as <code>WriteLine()</code> (writes a line to the final file) and <code>Push/PopIndent()</code> (keep the number of indents on the stack). <br><br>  I will not present here the T4 transformation code - it can be downloaded from the link above.  Instead, I will show what our DSL will produce from the breakfast definition. <br><br><blockquote> <code><font color="black"><font color="#0000FF">namespace</font> Debugging&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">using</font> System.Threading;&lt;br/&gt; <br> <font color="#0000FF">partial</font> <font color="#0000FF">class</font> Breakfast&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">readonly</font> <font color="#0000FF">object</font> MakeSandwichLock = <font color="#0000FF">new</font> <font color="#0000FF">object</font> ();&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">readonly</font> <font color="#0000FF">object</font> EatBreakfastLock = <font color="#0000FF">new</font> <font color="#0000FF">object</font> ();&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">readonly</font> <font color="#0000FF">object</font> GetJamLock = <font color="#0000FF">new</font> <font color="#0000FF">object</font> ();&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> MakeTeaIsDone;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> ToastBreadIsDone;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> GetJamIsDone;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> MakeSandwichIsDone;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> MakeTeaStarted;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> ToastBreadStarted;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> GetJamStarted;&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> MakeSandwichStarted;&lt;br/&gt; <br> <font color="#0000FF">protected</font> <font color="#0000FF">internal</font> <font color="#0000FF">void</font> MakeTea()&lt;br/&gt; <br> {&lt;br/&gt; <br> MakeTeaImpl();&lt;br/&gt; <br> <font color="#0000FF">lock</font> (EatBreakfastLock)&lt;br/&gt; <br> {&lt;br/&gt; <br> MakeTeaIsDone = <font color="#0000FF">true</font> ;&lt;br/&gt; <br> Monitor.PulseAll(EatBreakfastLock);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">protected</font> <font color="#0000FF">internal</font> <font color="#0000FF">void</font> ToastBread()&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">lock</font> (GetJamLock)&lt;br/&gt; <br> {&lt;br/&gt; <br> ToastBreadIsDone = <font color="#0000FF">true</font> ;&lt;br/&gt; <br> Monitor.PulseAll(GetJamLock);&lt;br/&gt; <br> }&lt;br/&gt; <br> ToastBreadImpl();&lt;br/&gt; <br> <font color="#0000FF">lock</font> (MakeSandwichLock)&lt;br/&gt; <br> {&lt;br/&gt; <br> ToastBreadIsDone = <font color="#0000FF">true</font> ;&lt;br/&gt; <br> Monitor.PulseAll(MakeSandwichLock);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">protected</font> <font color="#0000FF">internal</font> <font color="#0000FF">void</font> GetJam()&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">lock</font> (GetJamLock)&lt;br/&gt; <br> <font color="#0000FF">if</font> (!(ToastBreadStarted))&lt;br/&gt; <br> Monitor.Wait(GetJamLock);&lt;br/&gt; <br> GetJamImpl();&lt;br/&gt; <br> <font color="#0000FF">lock</font> (MakeSandwichLock)&lt;br/&gt; <br> {&lt;br/&gt; <br> GetJamIsDone = <font color="#0000FF">true</font> ;&lt;br/&gt; <br> Monitor.PulseAll(MakeSandwichLock);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">protected</font> <font color="#0000FF">internal</font> <font color="#0000FF">void</font> MakeSandwich()&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">lock</font> (MakeSandwichLock)&lt;br/&gt; <br> <font color="#0000FF">if</font> (!(ToastBreadIsDone &amp;&amp; GetJamIsDone))&lt;br/&gt; <br> Monitor.Wait(MakeSandwichLock);&lt;br/&gt; <br> MakeSandwichImpl();&lt;br/&gt; <br> <font color="#0000FF">lock</font> (EatBreakfastLock)&lt;br/&gt; <br> {&lt;br/&gt; <br> MakeSandwichIsDone = <font color="#0000FF">true</font> ;&lt;br/&gt; <br> Monitor.PulseAll(EatBreakfastLock);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">protected</font> <font color="#0000FF">internal</font> <font color="#0000FF">void</font> EatBreakfast()&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">lock</font> (EatBreakfastLock)&lt;br/&gt; <br> <font color="#0000FF">if</font> (!(MakeTeaIsDone &amp;&amp; MakeSandwichIsDone))&lt;br/&gt; <br> Monitor.Wait(EatBreakfastLock);&lt;br/&gt; <br> EatBreakfastImpl();&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  A lot of code!  But this code reflects the structure that we defined.  Now it only remains to use the generated structure: <br><br><blockquote> <code><font color="black"><font color="#0000FF">namespace</font> Debugging&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">partial</font> <font color="#0000FF">class</font> Breakfast&lt;br/&gt; <br> {&lt;br/&gt; <br> AutoResetEvent eatHandle = <font color="#0000FF">new</font> AutoResetEvent( <font color="#0000FF">false</font> );&lt;br/&gt; <br> Random rand = <font color="#0000FF">new</font> Random();&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> Prepare()&lt;br/&gt; <br> {&lt;br/&gt; <br> ThreadStart[] ops = <font color="#0000FF">new</font> ThreadStart[] {&lt;br/&gt; <br> MakeTea,&lt;br/&gt; <br> GetJam,&lt;br/&gt; <br> ToastBread,&lt;br/&gt; <br> MakeSandwich,&lt;br/&gt; <br> EatBreakfast };&lt;br/&gt; <br> <font color="#0000FF">foreach</font> (ThreadStart op <font color="#0000FF">in</font> ops)&lt;br/&gt; <br> op.BeginInvoke( <font color="#0000FF">null</font> , <font color="#0000FF">null</font> );&lt;br/&gt; <br> eatHandle.WaitOne();&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">private</font> <font color="#0000FF">int</font> RandomInterval&lt;br/&gt; <br> {&lt;br/&gt; <br> get&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0000FF">return</font> (1 + rand.Next() % 10) * 100;&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> MakeTeaImpl()&lt;br/&gt; <br> {&lt;br/&gt; <br> Thread.Sleep(RandomInterval);&lt;br/&gt; <br> Console.WriteLine( <font color="#570000">"Make tea"</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> ToastBreadImpl()&lt;br/&gt; <br> {&lt;br/&gt; <br> Thread.Sleep(RandomInterval);&lt;br/&gt; <br> Console.WriteLine( <font color="#570000">"Toast bread"</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> GetJamImpl()&lt;br/&gt; <br> {&lt;br/&gt; <br> Thread.Sleep(RandomInterval);&lt;br/&gt; <br> Console.WriteLine( <font color="#570000">"Get jam"</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> MakeSandwichImpl()&lt;br/&gt; <br> {&lt;br/&gt; <br> Thread.Sleep(RandomInterval);&lt;br/&gt; <br> Console.WriteLine( <font color="#570000">"Make sandwich"</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> EatBreakfastImpl()&lt;br/&gt; <br> {&lt;br/&gt; <br> Thread.Sleep(RandomInterval);&lt;br/&gt; <br> Console.WriteLine( <font color="#570000">"Eat breakfast"</font> );&lt;br/&gt; <br> eatHandle.Set();&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  The result of calling this code is something like this: <br><br><blockquote>  Make tea <br>  Toast bread <br>  Get jam <br>  Make sandwich <br>  Eat breakfast <br>  All done </blockquote><br>  Although of course <code>Make tea</code> and <code>Toast bread</code> can appear in a different order. <br><br><h3>  Conclusion </h3><br>  DSL Tools is a sophisticated but powerful tool.  The key feature of this package is the ease of working with the language after it has been defined.  Here I could only superficially describe working with DSL Tools, since  opportunities and nuances a lot.  I hope that this post motivates someone to conduct their own research.  ‚ñ† <img src="http://nesteruk.org/projects/vc/default.aspx"></div><p>Source: <a href="https://habr.com/ru/post/74367/">https://habr.com/ru/post/74367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../74360/index.html">Kaspersky began to consider jQuery.ThickBox virus</a></li>
<li><a href="../74362/index.html">USB flash drive 3.0</a></li>
<li><a href="../74363/index.html">placeholder.js</a></li>
<li><a href="../74365/index.html">Popular sites Runet received special versions of Opera 10</a></li>
<li><a href="../74366/index.html">Which city likes Call of Duty the most?</a></li>
<li><a href="../74368/index.html">Search for remote administration tool</a></li>
<li><a href="../74369/index.html">Open safe</a></li>
<li><a href="../74370/index.html">The first international forum of investors and Internet projects "Elba"</a></li>
<li><a href="../74371/index.html">Does RCC need for Habr's sandbox?</a></li>
<li><a href="../74372/index.html">Onkyo p305 Review (or OEM-nettop on ION-e)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>