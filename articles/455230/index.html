<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nullable Reference types in C # 8.0 and static analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that Microsoft has been working on the release of the eighth version of C # for a long time. In the recent release of Visual Studio 201...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nullable Reference types in C # 8.0 and static analysis</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Picture 9"></p><br>  It's no secret that Microsoft has been working on the release of the eighth version of C # for a long time.  In the recent release of Visual Studio 2019, a new version of the language (C # 8.0) is already available, but only as a beta release.  There are several possibilities in the plans of this new version, the implementation of which may not seem quite obvious, or more precisely, not quite expected.  One of these innovations was the ability to use Nullable Reference types.  The stated meaning of this innovation is the fight against Null Reference Exceptions (NRE). <br><a name="habracut"></a><br>  We are pleased that the language is developing and new features should help developers.  Coincidentally, in our analyzer, PVS-Studio for C #, relatively recently, the possibilities for detecting exactly the same NRE in the code have been significantly expanded.  And we wondered whether there is now any sense for static analyzers in general, and for PVS-Studio in particular, to try to look for potential dereferencing of zero references if, at least in the new code using the Nullable Reference, such dereferencies become ‚Äúimpossible‚Äù ?  Let's try to answer this question. <br><br><h2>  Pros and cons of innovation </h2><br>  To begin with, it is worth recalling that in the latest beta version of C # 8.0, available at the time of this writing, the Nullable Reference is disabled by default, i.e.  the behavior of reference types will not change. <br><br>  What are the nullable reference types in C # 8.0 if you include them?  This is the same good old reference type with the difference that variables of this type should now be marked with the help of '?'  (for example, <i>string?</i> ), by analogy with how it is already done for <i>Nullable &lt;T&gt;</i> , i.e.  nullable meaningful types (for example, <i>int?</i> ).  However, now the same <i>string</i> without '?'  is already beginning to be interpreted as a non-nullable reference, i.e.  This is a reference type, whose variable cannot contain <i>null</i> values. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Null Reference Exception is one of the most embarrassing exceptions, since it says little about the source of problems, especially if there are several dereferences in a row in the method that threw the exception.  The ability to prohibit the transfer of <i>null</i> to the type reference variable looks great, but if <i>null was</i> previously passed to the method, and some further execution logic was tied to this, what should we do now?  Of course, instead of <i>null</i> , you can pass a literal, a constant, or simply an ‚Äúimpossible‚Äù value, which, according to the logic of the program, cannot be assigned anywhere else to this variable.  However, the fall of the entire program can be replaced by a further "quiet" incorrect execution.  Not always it will be better than to see the error immediately. <br><br>  And if instead throw an exception?  A meaningful exception in a place where something went wrong is always better than a <i>NRE</i> somewhere higher or lower in the stack.  But it's good if we are talking about our own project, where we can fix consumers and insert a <i>try-catch block,</i> and when developing a library using the (non) Nullable Reference, we take responsibility that some method always returns a value.  And not always, even in your own code, it will turn out (at least simply) to replace the <i>null</i> return by throwing an exception (too much code can be hurt). <br><br>  Nullable Reference can be enabled at the entire project level by adding the <i>NullableContextOptions</i> property with the value <i>enable</i> , or at the file level, using the preprocessor directive: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Types will now be more visible.  According to the signature of the method, it is possible to determine its behavior, whether there is a check for <i>null</i> in it or not, whether it can return <i>null</i> or not.  Now, if you try to access the nullable reference variable without checking, the compiler will issue a warning. <br><br>  It is quite convenient when using third-party libraries, but a situation arises with possible misinformation.  The fact is that the transfer of <i>null</i> is still possible, for example, when using the new null-forgiving operator (!).  Those.  just with a single exclamation mark you can break all further assumptions that will be made about the interface using these variables: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Yes, it can be said that it is wrong to write this way, and no one will ever do that, but as long as such an opportunity remains, to rely solely on the contract imposed by the interface of this method (that it cannot return null), it is no longer possible. <br><br>  And, by the way, you can write the same thing with the help of several operators!, Because C # now allows you to write like this (and this code is completely compiled): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Those.  we would like to further emphasize: pay attention - it can be <i>null</i> !!!  (we in the team call it ‚Äúemotional‚Äù programming).  In fact, the compiler (from Roslyn), when building a syntax tree of code, interprets the operator!  similar to simple brackets, so their number, as in the case of brackets, is not limited.  Although, if you write enough of them, the compiler can also be ‚Äúdumped‚Äù.  Perhaps this will change in the final version of C # 8.0. <br><br>  Similarly, the compiler's warning compiler can be circumvented by referring to the nullable reference variable without checking: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  You can write more emotionally: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  This syntax is actually difficult to imagine in a real project, putting the <i>null-forgiving</i> operator <i>says to</i> the compiler: everything is fine, the check is not needed.  Adding an operator to Elvis, we say: but in general it may not be normal, let's check. <br><br>  And now the legitimate question arises - why, if the concept of a non-nullable reference type implies that a variable of this type cannot contain <i>null</i> , can we still write it so easily there?  The fact is that ‚Äúunder the hood‚Äù, at the level of the IL code, our non-nullable reference type remains ... all the same ‚Äúnormal‚Äù reference type.  And all the nullability syntax is actually only an annotation for the static analyzer built into the compiler (and, in our opinion, not the most convenient analyzer, but more on that later).  In our opinion, to include in the language a new syntax only as an annotation for a third-party tool (even if it is embedded in the compiler) is not the most ‚Äúbeautiful‚Äù solution, since  For a programmer using this language, the fact that this is only a summary may not be completely obvious - after all, the very similar syntax for nullable structures works quite differently. <br><br>  Returning to how you can still break the Nullable Reference types.  At the time of writing, if there are several projects in the solution, when transferring from a method declared in one project a reference variable, for example, of type <i>String,</i> to a method from another project where <i>NullableContextOptions is</i> included <i>, the</i> compiler will decide that this is already a non-nullable String, and will not issue a warning.  And this is despite a lot of <i>[Nullable (1)]</i> attributes added to each field and class method in the IL code when Nullable Reference is enabled <i>.</i>  These attributes, by the way, should be taken into account if you work with the list of attributes through reflection, counting on the existence of only those attributes that you added yourself. <br><br>  This situation may create additional problems when translating a large code base to the Nullable Reference.  Most likely this process will be gradual, project by project.  Of course, with a competent approach to change, you can gradually move to a new functionality, but if you already have a working draft, any changes in it are dangerous and undesirable (it works - do not touch!).  That is why, when using the PVS-Studio analyzer, there is no need to edit the source code or somehow mark it up to detect potential <i>NREs</i> .  To check the places where <i>NullReferenceException</i> can occur <i>,</i> you just need to run the analyzer and look at the warnings V3080.  No need to change project properties or source code.  No need to add directives, attributes or operators.  No need to change the code. <br><br>  With the support of the Nullable Reference types in the PVS-Studio analyzer, we faced a choice - should the analyzer interpret non-nullable reference variables as having always non-zero values?  After studying the question of the possibilities to ‚Äúbreak‚Äù this guarantee, we came to the conclusion that there is no - the analyzer should not make such an assumption.  After all, even if non-nullable reference types are used everywhere in the project, the analyzer can complement their use by detecting situations in which the value may contain <i>null</i> . <br><br><h2>  How PVS-Studio searches for Null Reference Exceptions </h2><br>  Dataflow mechanisms in the C # PVS-Studio analyzer track possible values ‚Äã‚Äãof variables as they are analyzed.  Including, PVS-Studio carries out interprocedural analysis, i.e.  tries to determine the possible value returned by the method, as well as the methods called in this method, etc.  Among other things, the analyzer remembers variables that can potentially take the value <i>null</i> .  If the analyzer sees further dereference without checking such a variable, again, either in the current code being checked, or within the method called in this code, a warning V3080 about the potential Null Reference Exception will be issued. <br><br>  At the same time, the main idea underlying this diagnostic is that the analyzer will swear only if you have seen the assignment of <i>null</i> to a variable somewhere.  This is the main difference between the behavior of this diagnostic and the analyzer built into the compiler, which works with the Nullable Reference types.  The analyzer built into the compiler will complain about any dereference of an unchecked nullable reference type variable, unless, of course, this analyzer is ‚Äúdeceived‚Äù by the operator!, Or just to write a rather convoluted verification code (here, however, it‚Äôs worth noting that In any other way, absolutely any analyzer is possible, especially there is a goal to set yourself, and PVS-Studio is no exception here). <br><br>  PVS-Studio curses only if it sees <i>null</i> (in a local context, or coming from a method).  At the same time, even if the variable is a non-nullable reference variable, the behavior of the analyzer will not change - it will still swear if it sees that null was written to it.  This approach seems to us more correct (or, at least, convenient for the user of the analyzer), since  it does not require to ‚Äúdaub‚Äù the entire code with <i>null</i> checks to find potential dereferencing - this could have been done before, without the Nullable Reference, for example, with the same contracts.  In addition, the analyzer can now be used to further control the same non-nullable reference variables.  If they are used ‚Äúhonestly‚Äù and they are never assigned null, the analyzer will keep silent.  If null is assigned and the variable is dereferenced without checking, the analyzer will warn you about this with the message V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Consider further some examples of such V3080 diagnostics triggers in the code of Roslyn himself.  We <a href="https://www.viva64.com/ru/b/0622/">checked this project</a> not so long ago, but this time we will consider only potential Null Reference Exception triggers that weren't in previous articles.  Let's see how the PVS-Studio analyzer can find potential null reference dereferencing, and how to fix these places using the new Nullable Reference syntax. <br><br>  <i>V3080 [CWE-476] Possible null dereference inside method.</i>  <i>Consider inspecting the 2nd argument: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  As you can see, the variable <i>chainedTupleType</i> can be null in one of the code execution branches.  Then <i>chainedTupleType is</i> passed inside the <i>ConstructTupleUnderlyingType</i> method <i>,</i> and is used there with a check through <i>Debug.Assert</i> .  This situation is very common in Roslyn, but it is worth remembering that <i>Debug.Assert</i> is removed in the release version of the assembly.  Therefore, the analyzer still considers dereference within the <i>ConstructTupleUnderlyingType</i> method dangerous.  The following is the body of this method, where dereference takes place: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Whether the analyzer has to take into account such Asserts is a question that is in fact controversial (some of our users want it to do this), because the contracts from System.Diagnostics.Contracts, for example, the analyzer is now taking into account.  I'll tell you just a small example from the real use of the same Roslyn in our analyzer.  Recently, <a href="https://www.viva64.com/ru/b/0630/">we supported the new version of Visual Studio</a> , and at the same time updated the 3rd version in the Roslyn analyzer.  After that, the analyzer began to fall when checking a certain code, on which it had not previously crashed.  At the same time, the analyzer did not fall inside our code, but inside the Roslyn code itself - fall from the Null Reference Exception.  And further debugging showed that in the place where Roslyn now falls, exactly a couple of lines up, there is the same <i>null</i> check through <i>Debug.Assert</i> .  And she, as we see, did not save. <br><br>  This is a very good example of problems with the Nullable Reference <i>,</i> because the compiler considers <i>Debug.Assert as a</i> valid test in any configuration.  That is, if you simply include <i>#nullable enable</i> and mark the <i>chainedTupleTypeOpt</i> argument as nullable reference <i>,</i> there will be no compiler warnings at the dereferencing point in the <i>ConstructTupleUnderlyingType</i> method. <br><br>  Consider the following example of triggering PVS-Studio. <br><br>  <i>V3080 Possible null dereference.</i>  <i>Consider inspecting 'effectiveRuleset'.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  This warning notes that calling the <i>WithEffectiveAction</i> method may return <i>null</i> , but the result is used without checking ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  The body of the <i>WithEffectiveAction</i> method, which can return null, is written to the variable <i>effectiveRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  If we enable the Nullable Reference mode for the <i>GetEffectiveRuleSet</i> method, we will have two places in which we need to change our behavior.  Since there is an exception throw in the method above - it is logical to assume that the method call is wrapped in a <i>try-catch block</i> and will correctly rewrite the method, throwing the exception instead of returning null.  But as we rise above the challenges, we see that the interception is high and the consequences can be quite unpredictable.  Let's look at the consumer variable of <i>effectiveRuleset</i> - the <i>IsStricterThan</i> method <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  As you can see, this is a simple switch on two enumerations with a possible <i>ReportDiagnostic.Default</i> enumeration <i>value</i> .  So it is best to rewrite the call as follows: <br><br>  The signature <i>WithEffectiveAction</i> will change: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  The call will look like this: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  knowing that <i>IsStricterThan</i> only performs a comparison - the condition can be rewritten, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  We now turn to the next post analyzer. <br><br>  <i>V3080 Possible null dereference.</i>  <i>Consider inspecting 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Further use of the <i>propertySymbol</i> variable should be taken into account when correcting the analyzer warning. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  The <i>GetMemberSymbol</i> method can also return <i>null</i> in some cases. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  With the use of the nullable reference type, the call will change like this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Pretty simple when you know where to fix it.  Static analysis easily finds this potential error by obtaining all possible field values ‚Äã‚Äãacross all the chains of procedure calls. <br><br>  <i>V3080 Possible null dereference.</i>  <i>Consider inspecting 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  Problem in line with <i>simpleName.Length</i> check <i>.</i>  <i>simpleName</i> is the result of executing a whole chain of methods and can be <i>null</i> .  By the way, you can curiosity see the <i>RemoveExtension</i> method and find differences from <i>Path.GetFileNameWithoutExtension.</i>  Here we could restrict ourselves to checking <i>simpleName! = Null</i> , but in the context of non-zero references the code will look something like this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  The call will look like this: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusion </h2><br>  Nullable Reference types can help a lot when planning an architecture created from scratch, but reworking existing code can potentially take a lot of time and care, as it can cause a lot of subtle errors.  In this article, we did not set ourselves the goal of discouraging someone from using Nullable Reference types in their projects.  We consider this innovation to be generally useful for the language, although the way it was implemented may raise questions. <br><br>  You should always remember the limitations inherent in this approach, and that the included Nullable Reference mode does not protect against errors with dereferencing null links, and if used incorrectly, it can even lead to them.  It is worth considering the use of a modern static analyzer, for example, PVS-Studio, which supports interprocedural analysis, as an additional tool that can, together with the Nullable Reference, protect you from dereference of zero references.  Each of these approaches, both in-depth interprocedural analysis and annotation of method signatures (which in essence makes the Nullable Reference), has its advantages and disadvantages.  The analyzer will allow you to get a list of potentially dangerous places, as well as changing the existing code to see all the consequences of such changes.  If you assign <i>null</i> in some case, the analyzer should immediately indicate all consumers to the variable where it is not checked before dereference. <br><br>  You can search for any other errors yourself, either in the considered project or in your own.  To do this, you just need to <a href="https://www.viva64.com/ru/pvs-studio-download/">download</a> and try the PVS-Studio analyzer. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/455234/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Paul Eremeev, Alexander Senichkin.  <a href="https://habr.com/en/company/pvs-studio/blog/455234/">Nullable Reference types in C # 8 and static analysis</a> </div><p>Source: <a href="https://habr.com/ru/post/455230/">https://habr.com/ru/post/455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455218/index.html">Ecosystem Approach to Business Technologies</a></li>
<li><a href="../455224/index.html">Finger Music: Play Anything With Sphero SpecDrums</a></li>
<li><a href="../455226/index.html">Why attach an applied linguist?</a></li>
<li><a href="../455228/index.html">The One Who Resurrected Duke Nukem: Interview With Randy Pitchford, Gearbox Wizard</a></li>
<li><a href="../45523/index.html">Basics of browser interface: address bar above tabs or below?</a></li>
<li><a href="../455236/index.html">Comodo withdraws certificates for no reason.</a></li>
<li><a href="../45524/index.html">Announced the release of Linux distribution Fedora 10</a></li>
<li><a href="../455240/index.html">Using the rejected defect rate to improve the error report</a></li>
<li><a href="../455242/index.html">Minus ears or how not to spoil the sound in the game from the very beginning</a></li>
<li><a href="../455244/index.html">Comics "easy soldering" in the updated version (2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>