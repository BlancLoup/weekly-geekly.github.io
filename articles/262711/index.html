<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast and convenient IL generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many times I came across the task of dynamically generating code (for example, when writing an effective serializer or DSL compiler). This can be done...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast and convenient IL generation</h1><div class="post__text post__text-html js-mediator-article">  Many times I came across the task of dynamically generating code (for example, when writing an effective serializer or <a href="https://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">DSL</a> compiler).  This can be done in different ways, which one is the best - a discussion for a separate article.  For a number of reasons, I prefer <font color="00008b">Reflection.Emit</font> and CIL (Common Intermediate Language) and tell you what problems I had to face on this path, as well as about their solution: the smart wrapper over <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.ilgenerator.aspx" title="ILGenerator">ILGenerator</a> - <font color="00008b">GroboIL</font> from <a href="https://github.com/homuroll/gremit" title="Graceful emit">Graceful Emit</a> library. <br><br>  I want to note at the same time that sometimes there are situations when we do not have much choice: for example, when writing a serializer, you must have access to private fields, and you have to use IL.  By the way, the famous <a href="https://code.google.com/p/protobuf-net/" title="protobuf-net">protobuf-net</a> serializer contains several hundreds of IL instructions. <br><br>  If you have never encountered the use of IL-code, then the article may seem difficult to understand, because it contains many examples of code using IL.  For basic knowledge, I recommend reading the article <a href="http://www.codeproject.com/Articles/3778/Introduction-to-IL-Assembly-Language" title="Introduction to IL Assembly Language">Introduction to IL Assembly Language</a> . <br><a name="habracut"></a><br>  <font color="00008b">Reflection.Emit</font> provides two methods for generating code - <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod.aspx" title="DynamicMethod">DynamicMethod</a> and <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.typebuilder.aspx" title="Typebuilder">TypeBuilder</a> / <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.methodbuilder.aspx" title="MethodBuilder">MethodBuilder</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <font color="00008b">DynamicMethod</font> is a ‚Äúlightweight‚Äù static method that will compile a delegate.  Their main advantage is that <font color="00008b">DynamicMethod</font> 's are allowed to ignore the visibility of types and type members.  They are collected by the garbage collector when all references to them are dropped, but with .NET Framework 4.0, <font color="00008b">DynamicAssembly has the</font> same opportunity, so this is no longer an advantage. <br><br>  With <font color="00008b">DynamicAssembly</font> / <font color="00008b">ModuleBuilder</font> / <font color="00008b">TypeBuilder</font> / <font color="00008b">MethodBuilder,</font> you can dynamically generate the entire .NET type space: interfaces, classes, redefine virtual methods, declare fields, properties, implement constructors, etc. disk. <br><br>  In practice, <font color="00008b">DynamicMethod's</font> are more commonly used, since they are somewhat simpler in the announcement and have access to private members.  <font color="00008b">MethodBuilders</font> are usually used if, in addition to the code, there is a need to generate some data: then they are conveniently placed in <font color="00008b">TypeBuilders</font> , and the code is in their methods. <br><br><h2>  Example </h2><br>  Task: print all fields of the object. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Action&lt;T&gt; BuildFieldsPrinter&lt;T&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod(Guid.NewGuid().ToString(), <span class="hljs-comment"><span class="hljs-comment">//   typeof(void), //   new[] {type}, //   typeof(string), //     ,  , , string true); //      var il = method.GetILGenerator(); var fieldValue = il.DeclareLocal(typeof(object)); var toStringMethod = typeof(object).GetMethod("ToString"); var fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); foreach(var field in fields) { il.Emit(OpCodes.Ldstr, field.Name + ": {0}"); // stack: [format] il.Emit(OpCodes.Ldarg_0); // stack: [format, obj] il.Emit(OpCodes.Ldfld, field); // stack: [format, obj.field] if(field.FieldType.IsValueType) il.Emit(OpCodes.Box, field.FieldType); // stack: [format, (object)obj.field] il.Emit(OpCodes.Dup); // stack: [format, obj.field, obj.field] il.Emit(OpCodes.Stloc, fieldValue); // fieldValue = obj.field; stack: [format, obj.field] var notNullLabel = il.DefineLabel(); il.Emit(OpCodes.Brtrue, notNullLabel); // if(obj.field != null) goto notNull; stack: [format] il.Emit(OpCodes.Ldstr, "null"); // stack: [format, "null"] var printedLabel = il.DefineLabel(); il.Emit(OpCodes.Br, printedLabel); // goto printed il.MarkLabel(notNullLabel); il.Emit(OpCodes.Ldloc, fieldValue); // stack: [format, obj.field] il.EmitCall(OpCodes.Callvirt, toStringMethod, null); // stack: [format, obj.field.ToString()] il.MarkLabel(printedLabel); var writeLineMethod = typeof(Console).GetMethod("WriteLine", new[] { typeof(string), typeof(object) }); il.EmitCall(OpCodes.Call, writeLineMethod, null); // Console.WriteLine(format, obj.field.ToString()); stack: [] } il.Emit(OpCodes.Ret); return (Action&lt;T&gt;)method.CreateDelegate(typeof(Action&lt;T&gt;)); }</span></span></code> </pre> <br><br><h2>  <font color="00008b">ILGenerator</font> problems </h2><br>  To begin with, <font color="00008b">ILGenerator has</font> a bad syntax: there is one <font color="008b8b">Emit</font> method with a bunch of overloads, so it's easy to mistakenly cause an incorrect overload. <br><br>  It is also inconvenient that one logical IL-instruction may have several options, for example, the <font color="0000ff">ldelem</font> instruction has 11 options - <font color="0000ff">ldelem.i1</font> (sbyte), <font color="0000ff">ldelem.i2</font> (short), <font color="0000ff">ldelem.i4</font> (int), <font color="0000ff">ldelem.i8</font> (long ), <font color="0000ff">ldelem.u1</font> (byte), <font color="0000ff">ldelem.u2</font> (ushort), <font color="0000ff">ldelem.u4</font> (uint), <font color="0000ff">ldelem.r4</font> (float), <font color="0000ff">ldelem.r8</font> (double), <font color="0000ff">ldelem.i</font> (native int), <font color="0000ff">ldelem.ref</font> (reference type). <br><br>  But these are all seeds compared to how badly the error messages are generated. <br><br>  First, the exception only crashes at the very end, when the JIT compiler tries to compile the method (that is, not even on the <font color="00008b">DynamicMethod</font> . <font color="008b8b">CreateDelegate</font> () or <font color="00008b">TypeBuilder</font> . <font color="008b8b">CreateType</font> () <font color="008b8b">call</font> , but when you first try to actually run this code), it‚Äôs not clear which instruction caused the error. <br><br>  Secondly, the error messages themselves, as a rule, do not speak about anything, for example, the most frequent error is ‚ÄúCommon language runtime detected an invalid program‚Äù. <br><br><h3>  Examples of errors / typos </h3><br><ol><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Emit(OpCodes.Ldfld); //   ,    FieldInfo {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  InvalidProgramException: "Common language runtime detected an invalid program". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Emit(OpCodes.Box); //   value type  object,     {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  InvalidProgramException: "Common language runtime detected an invalid program". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var code = GetCode(..); //   byte il.Emit(OpCodes.Ldc_I4, code); //     int,   byte {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  InvalidProgramException: "Common language runtime detected an invalid program". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Emit(OpCodes.Call, abstractMethod); //    ,    Callvirt  Call {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  BadImageFormatException: "Invalid il format". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var keyGetter = typeof(KeyValuePair&lt;int, int&gt;).GetProperty("Key").GetGetMethod(); il.Emit(OpCodes.Ldarg_1); //  1 ‚Äì KeyValuePair&lt;int, int&gt; il.Emit(OpCodes.Call, keyGetter); //    Key  KeyValuePair&lt;int, int&gt;,   value type, //      ,    {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  InvalidProgramException: "Common language runtime detected an invalid program". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var toStringMethod = typeof(object).GetMethod("ToString"); il.Emit(OpCodes.Ldarga, 1); //  1 ‚Äì int,    il.Emit(OpCodes.Callvirt, toStringMethod); //   int.ToString(),      //  value type     constrained {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  NullReferenceException: "Object reference not set to instance of an object". <br>  Or <br>  AccessViolationException: ‚ÄúAttempted to read or write protected memory.  This is often an indication that other memory is corrupt. ‚Äù <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic; //     value var valueField = typeof(KeyValuePair&lt;int, string&gt;).GetField("value", bindingFlags); il.Emit(OpCodes.Ldarga, 1); //  1 ‚Äì KeyValuePair&lt;string, int&gt; il.Emit(OpCodes.Ldfld, valueField); //    value  KeyValuePair&lt;string, int&gt;,    // KeyValuePair&lt;string, int&gt;  KeyValuePair&lt;int, string&gt;,   //   key  int     string {..} //  -  var compiledMethod = dynamicMethod.CreateDelegate(..); var result = compiledMethod(..); // ‚Üê     {..} // -   result ‚Üê  </span></span></code> </pre><br>  Undefined behavior is most likely an AccessViolationException or NullReferenceException. <br><br></li><li>  Forgot at the end of the code call the <font color="00008b">OpCodes</font> instruction.  <font color="9600ab">Ret</font> - we get an undefined behavior: maybe an exception will be thrown when trying to compile, everything may just break already during the work, or it may get lucky and everything will work correctly. <br><br></li><li>  Implement the function <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)y; }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); il.Emit(OpCodes.Ldarg_0); <span class="hljs-comment"><span class="hljs-comment">//  0 -  int il.Emit(OpCodes.Ldarg_1); //  1 -  double il.Emit(OpCodes.Add); //   double  int.    il.Emit(OpCodes.Ret); var compiledMethod = dynamicMethod.CreateDelegate(..); var result = compiledMethod(..); // ‚Üê     </span></span></code> </pre><br>  The CIL specification states that the instruction is <font color="00008b">OpCodes</font> .  <font color="9600ab">Add</font> cannot accept arguments of types <font color="0000ff">int</font> and <font color="0000ff">double</font> , but there may be no exception, there will just be undefined behavior depending on the JIT compiler. <br><br>  Startup example: <br><ul><li>  x64: compiledMethod (10, 3.14) = 13 <br>  ASM code (x lies in <font color="9600ab">ecx</font> , y - in <font color="008b8b">xmm1</font> ): <br>  <font color="0000ff">cvtsi2sd</font> <font color="008b8b">xmm0</font> , <font color="9600ab">ecx</font> <br>  <font color="0000ff">addsd</font> <font color="008b8b">xmm0</font> , <font color="008b8b">xmm1</font> <br>  <font color="0000ff">cvttsd2si</font> <font color="9600ab">eax</font> , <font color="008b8b">xmm0</font> <br></li><li>  x86: compiledMethod (10, 3.14) = 20 <br>  ASM code (x is in <font color="9600ab">ecx</font> , y is on the stack): <br>  <font color="0000ff">mov</font> <font color="9600ab">eax</font> , <font color="9600ab">ecx</font> <br>  <font color="0000ff">fld</font> <font color="0000ff">qword</font> [ <font color="9600ab">esp</font> + 4] <br>  <font color="0000ff">add</font> <font color="9600ab">eax</font> , <font color="9600ab">ecx</font> <br>  <font color="0000ff">fstp</font> <font color="008b8b">st</font> (0) <br></li></ul><br>  That is, under x64, the most logical interpretation was generated ( <font color="0000ff">int is</font> converted to <font color="0000ff">double</font> , then two <font color="0000ff">doubles are</font> added and the result is truncated to <font color="0000ff">int</font> ), but under x86, an attempt to mix integer and real operands results in 2 * x instead of x + y (readers I propose to see what happens if instead of <font color="0000ff">int</font> + <font color="0000ff">double</font> write <font color="0000ff">double</font> + <font color="0000ff">int</font> ). <br><br></li><li>  Implement the function <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Coalesce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str ?? <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = dynamicMethod.GetILGenerator(); il.Emit(OpCodes.Ldarg_0); <span class="hljs-comment"><span class="hljs-comment">// stack: [str] il.Emit(OpCodes.Dup); // stack: [str, str] var notNullLabel = il.DefineLabel(); il.Emit(OpCodes.Brtrue, notNullLabel); // if(str != null) goto notNull; stack: [str] il.Emit(OpCodes.Ldstr, ""); // Oops, ,       str il.MarkLabel(notNullLabel); //       :     ,   il.Emit(OpCodes.Ret); var compiledMethod = dynamicMethod.CreateDelegate(..); compiledMethod(..); // ‚Üê   </span></span></code> </pre><br>  InvalidProgramException: "JIT compiler encountered an internal limitation." <br><br>  A large number of similar errors fall into <font color="0000ff">this</font> : forgot to put <font color="0000ff">this</font> to invoke the instance method, forget to put the method argument, put the wrong value of the method argument, and so on. <br></li></ol><br>  If the text of the function consists of a dozen instructions, then you can somehow, having re-read the code several times, understand what the error is, but if the code consists of hundreds of commands, the development of such a code becomes a very dreary and lengthy exercise. <br>  If, however, it is possible to force such code to compile, then it cannot be debugged.  The only thing that can be done is to generate symbolic information in addition to the code, but it is long, inconvenient and difficult to keep up to date. <br><br>  Therefore, having quite a lot of experience writing IL-code with the help of the <font color="00008b">ILGenerator</font> and being <font color="00008b">exhausted by</font> order, I decided to write my own, taking into account all the problems I had encountered. <br>  The task was to write such an IL-generator so that an InvalidProgramException exception would never crash at all, but be picked up somewhere before with clear error text. <br><br><h2>  <font color="00008b">GroboIL</font> </h2><br>  The result was <font color="00008b">GroboIL</font> - a smart wrapper over the <font color="00008b">ILGenerator</font> . <br><br>  <font color="00008b">GroboIL</font> Features: <br><ul><li>  More convenient syntax: for each instruction on one function, all similar instructions are combined together, for example, instead of 11 <font color="00008b">OpCodes</font> instructions.  <font color="9600ab">Ldelem_ *</font> there is one method of <font color="00008b">GroboIL</font> .  <font color="008b8b">Ldelem</font> ( <font color="00008b">Type</font> type). <br></li><li>  During code generation, <font color="00008b">GroboIL</font> generates the contents of the calculation stack and validates the arguments of the instructions, and if something goes wrong, it immediately throws an exception. <br></li><li>  There is a debug output of the generated code. <br></li><li>  There is a possibility debug <font color="00008b">MethodBuilder</font> 's. <br></li><li>  Acceptable performance.  For example, somehow I had to deal with the function of 500,000 instructions, and the processing took 3 seconds (while compiling the method with the JIT compiler took 84 seconds and ate 4GB of memory). <br></li></ul><br><br>  The previous example rewritten using <font color="00008b">GroboIL</font> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Action&lt;T&gt; BuildFieldsPrinter&lt;T&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicMethod(Guid.NewGuid().ToString(), <span class="hljs-comment"><span class="hljs-comment">//   typeof(void), //   new[] { type }, //   typeof(string), //     ,  , , string true); //      using(var il = new GroboIL(method)) { var fieldValue = il.DeclareLocal(typeof(object), "fieldValue"); var toStringMethod = typeof(object).GetMethod("ToString"); var fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); foreach(var field in fields) { il.Ldstr(field.Name + ": {0}"); // stack: [format] il.Ldarg(0); // stack: [format, obj] il.Ldfld(field); // stack: [format, obj.field] if(field.FieldType.IsValueType) il.Box(field.FieldType); // stack: [format, (object)obj.field] il.Dup(); // stack: [format, obj.field, obj.field] il.Stloc(fieldValue); // fieldValue = obj.field; stack: [format, obj.field] var notNullLabel = il.DefineLabel("notNull"); il.Brtrue(notNullLabel); // if(obj.field != null) goto notNull; stack: [format] il.Ldstr("null"); // stack: [format, "null"] var printedLabel = il.DefineLabel("printed"); il.Br(printedLabel); // goto printed il.MarkLabel(notNullLabel); il.Ldloc(fieldValue); // stack: [format, obj.field] il.Call(toStringMethod); // stack: [format, obj.field.ToString()] il.MarkLabel(printedLabel); var writeLineMethod = typeof(Console).GetMethod("WriteLine", new[] { typeof(string), typeof(object) }); il.Call(writeLineMethod); // Console.WriteLine(format, obj.field.ToString()); stack: [] } il.Ret(); } return (Action&lt;T&gt;)method.CreateDelegate(typeof(Action&lt;T&gt;)); }</span></span></code> </pre><br><br>  Let's go over all the previous errors and see how it will look like with <font color="00008b">GroboIL</font> . <br><br><ol><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Ldfld(); // ‚Üê     {..} //  -  }</span></span></code> </pre><br>  There will be a compilation error, as there is no overload of the <font color="00008b">GroboIL</font> method.  <font color="008b8b">Ldfld</font> () without parameters. <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Box(); // ‚Üê     {..} //  -  }</span></span></code> </pre><br>  There will be a compilation error, as there is no overload of the <font color="00008b">GroboIL</font> method.  <font color="008b8b">Box</font> () without parameters. <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var code = GetCode(..); //   byte il.Ldc_I4(code); // ‚Üê   ,   int {..} //  -  }</span></span></code> </pre><br>  <font color="00008b">GroboIL</font> method.  <font color="008b8b">Ldc_I4</font> () accepts an <font color="0000ff">int</font> , so <font color="0000ff">byte</font> refers to an <font color="0000ff">int</font> and everything will be correct. <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  il.Call(abstractMethod); // ‚Üê   ,    Callvirt {..} //  -  }</span></span></code> </pre><br>  <font color="00008b">GroboIL</font> function.  <font color="008b8b">Call</font> () emits <font color="00008b">OpCodes</font> .  <font color="9600ab">Call</font> for non-virtual methods and <font color="00008b">OpCodes</font> .  <font color="9600ab">Callvirt</font> for virtual (if you need to call a virtual method non-virtual, for example, call the base implementation, you need to use the <font color="00008b">GroboIL</font> method. <font color="008b8b">Callnonvirt</font> ()) <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var keyGetter = typeof(KeyValuePair&lt;int, int&gt;).GetProperty("Key").GetGetMethod(); il.Ldarg(1); //  1 ‚Äì KeyValuePair&lt;int, int&gt; il.Call(keyGetter); // ‚Üê    {..} //  -  }</span></span></code> </pre><br>  The stack validator will generate an error that you cannot call a method on the value type: <br>  InvalidOperationException: "In order to call the method 'String KeyValuePair &lt;Int32, String&gt; .get_Value ()' on a value type 'KeyValuePair &lt;Int32, String&gt;' load an instance by ref or box it". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var toStringMethod = typeof(object).GetMethod("ToString"); il.Ldarga(1); //  1 ‚Äì int,    il.Call(toStringMethod); // ‚Üê    {..} //  -  }</span></span></code> </pre><br>  The stack validator will generate an error that to call a virtual method on the value type, the 'constrained' parameter must be passed (which will substitute the <font color="00008b">OpCodes</font> . <font color="9600ab">Constrained</font> prefix): <br>  InvalidOperationException: "In order to call a virtual method 'String Object.ToString ()' on a value type 'KeyValuePair &lt;Int32, String&gt;' specify the 'constrained' parameter". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { {..} <span class="hljs-comment"><span class="hljs-comment">//  -  var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic; //     value var valueField = typeof(KeyValuePair&lt;int, string&gt;).GetField("value", bindingFlags); il.Ldarga(1); //  1 ‚Äì KeyValuePair&lt;string, int&gt; il.Ldfld(valueField); // ‚Üê    {..} //  -  }</span></span></code> </pre><br>  The stack validator will generate an error that cannot load the field: <br>  InvalidOperationException: "Cannot load the field 'KeyValuePair &lt;Int32, String&gt; .value' of an instance of type 'KeyValuePair &lt;String, Int32&gt;'". <br><br></li><li>  There is a check that any program ends with one of several valid instructions, in particular, on <font color="00008b">OpCodes</font> .  <font color="9600ab">Ret</font> . <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { il.Ldarg(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  0 -  int il.Ldarg(1); //  1 -  double il.Add(); // ‚Üê    il.Ret(); }</span></span></code> </pre><br>  The stack validator will issue an error that the instruction is <font color="00008b">OpCodes</font> .  <font color="9600ab">Add</font> invalid in current context: <br>  InvalidOperationException: "Cannot perform the instruction 'add' on types 'Int32' and 'Double'". <br><br></li><li><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> il = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroboIL(dynamicMethod)) { il.Ldarg(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// stack: [str] il.Dup(); // stack: [str, str] var notNullLabel = il.DefineLabel("notNull"); il.Brtrue(notNullLabel); // if(str != null) goto notNull; stack: [str] il.Ldstr(""); // Oops, ,       str il.MarkLabel(notNullLabel); // ‚Üê    il.Ret(); }</span></span></code> </pre><br>  The stack validator will generate an error that the two ways of executing the code form a different calculation stack, and will show the contents of the stack in both cases: <br>  InvalidOperationException: ‚ÄúInconsistent stack for the label 'notNull' <br>  Stack # 1: [null, String] <br>  Stack # 2: [String] ¬ª <br></li></ol><br><br><h2>  Debugging </h2><br>  Among other things, <font color="00008b">GroboIL</font> generates a <font color="00008b">debug</font> text of the generated IL code, where the contents of the stack are written to the right of each instruction, which can be obtained by calling <font color="00008b">GroboIL</font> .  <font color="008b8b">GetILCode</font> (), for example: <br><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-comment"><span class="hljs-comment">// [List&lt;T&gt;] dup // [List&lt;T&gt;, List&lt;T&gt;] brtrue notNull_0 // [null] pop // [] ldc.i4.0 // [Int32] newarr T // [T[]] notNull_0: // [{Object: IList, IList&lt;T&gt;, IReadOnlyList&lt;T&gt;}] ldarg.1 // [{Object: IList, IList&lt;T&gt;, IReadOnlyList&lt;T&gt;}, Func&lt;T, Int32&gt;] call Int32 Enumerable.Sum&lt;T&gt;(IEnumerable&lt;T&gt;, Func&lt;T, Int32&gt;) // [Int32] ret // []</span></span></code> </pre><br><br>  And finally, there is the opportunity to debug <font color="00008b">MethodBuillder</font> 's.  In this case, <font color="00008b">GroboIL</font> automatically builds symbolic information, where the source text is the above debug text. <br><br>  Example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bazzze</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = AppDomain.CurrentDomain.DefineDynamicAssembly( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(<span class="hljs-string"><span class="hljs-string">"DynAssembly"</span></span>), AssemblyBuilderAccess.RunAndCollect); <span class="hljs-comment"><span class="hljs-comment">// ,    Assembly,      var module = assembly.DefineDynamicModule("zzz", "zzz.dll", true); // true -     var symWriter = module.GetSymWriter(); var typeBuilder = module.DefineType("Zzz", TypeAttributes.Public | TypeAttributes.Class, typeof(Bazzze)); var method = typeBuilder.DefineMethod( "Sum", MethodAttributes.Public | MethodAttributes.Virtual, //      typeof(int), //   new[] { typeof(int), typeof(double) }); //   method.DefineParameter(1, ParameterAttributes.None, "x"); //     method.DefineParameter(2, ParameterAttributes.None, "y"); //      watch var documentName = typeBuilder.Name + "." + method.Name + ".cil"; var documentWriter = symWriter.DefineDocument(documentName, SymDocumentType.Text, SymLanguageType.ILAssembly, Guid.Empty); //      using(var il = new GroboIL(method, documentWriter)) //    documentWriter { il.Ldarg(1); // stack: [x] il.Ldarg(2); // stack: [x, y] il.Conv&lt;int&gt;(); // stack: [x, (int)y] il.Dup(); // stack: [x, (int)y, (int)y] var temp = il.DeclareLocal(typeof(int), "temp"); il.Stloc(temp); // temp = (int)y; stack: [x, (int)y] il.Add(); // stack: [x + (int)y] il.Ret(); File.WriteAllText(Path.Combine(DebugOutputDirectory, documentName), il.GetILCode()); } typeBuilder.DefineMethodOverride(method, typeof(Bazzze).GetMethod("Sum")); //   var type = typeBuilder.CreateType(); var inst = (Bazzze)Activator.CreateInstance(type, new object[0]); inst.Sum(10, 3.14); }</span></span></code> </pre><br><br>  Now we set breakpoint on the line inst.Sum (10, 3.14);  and press F11 (step into), the dialog box will appear: <br><br><img src="https://habrastorage.org/files/5bc/b73/3e1/5bcb733e1ab445dc9f5c1c20ac969bc1.jpg"><br><br>  In the window that opens, select the folder where the debag file was placed, and see something like this: <br><br><img src="https://habrastorage.org/files/058/909/7c9/0589097c9ab54f88a8a97ae5ae5c58fa.jpg"><br><br>  This Visual Studio file is perceived as a normal source, you can debug through F10 / F11, set breakpoints, you can enter the parameters of the function, <font color="0000ff">this</font> , local variables in watch. <br><br>  Unfortunately, DynamicMethod's <font color="00008b">debugging is</font> just as awesome, because they don‚Äôt have a built-in mechanism for constructing symbolic information (if someone from the readers knows this method, I would be happy to hear).  But, since the IL-commands are the same for both <font color="00008b">DynamicMethod</font> 'and <font color="00008b">MethodBuilder</font> ', you can design the code so that it will be easy to replace <font color="00008b">DynamicMethod</font> with <font color="00008b">MethodBuilder</font> for debug and disable it in the release version. <br><br><h2>  Conclusion </h2><br>  From the height of my five-year experience in generating IL-code, I can draw the following conclusion: the difference in the development of the <font color="00008b">ILGenerator</font> and <font color="00008b">GroboIL code</font> is comparable to the difference in C # development in VisualStudio with a resampler and notebook development with a compiler, which says the answer is Accepted / Rejected without a number lines with an error.  The difference in development speed is an order of magnitude.  In my opinion, <font color="00008b">GroboIL</font> allows <font color="00008b">you</font> to generate IL-code with almost the same speed as generate, for example, C # -code, while retaining all the advantages of a low-level language. </div><p>Source: <a href="https://habr.com/ru/post/262711/">https://habr.com/ru/post/262711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262701/index.html">Creating CloudFoundry / IBM Bluemix buildpack or Awk web service (gawk)</a></li>
<li><a href="../262703/index.html">The distance spectra of simple sets and their associations (part 2)</a></li>
<li><a href="../262705/index.html">Multiplication of Karatsuba and C ++ 11</a></li>
<li><a href="../262707/index.html">Obtaining international IT certificates</a></li>
<li><a href="../262709/index.html">We build a performance bench on the example of the server Set Retail 10</a></li>
<li><a href="../262713/index.html">The story of one fakapa or why iteration is a necessary, but not sufficient condition for Agile</a></li>
<li><a href="../262715/index.html">OpenAdAdapter - Simple Mobile Advertising Management</a></li>
<li><a href="../262717/index.html">New build browser Vivaldi 1.0.219.51</a></li>
<li><a href="../262719/index.html">Proceedings of the Third Conference "Wolfram Technologies" (SPbESU, 2015)</a></li>
<li><a href="../262721/index.html">Law enforcement agencies shut down the famous cybercriminal forum Darkode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>