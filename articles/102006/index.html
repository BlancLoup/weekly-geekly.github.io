<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cartesian tree: Part 2. Valuable information in the tree and multiple operations with it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (for now) 
 Part 1. Description, operation, application. 
 Part 2. Valuable information in the tree and multiple operations with it....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cartesian tree: Part 2. Valuable information in the tree and multiple operations with it</h1><div class="post__text post__text-html js-mediator-article"><h4>  Table of Contents (for now) </h4><br>  <a href="http://habrahabr.ru/blogs/algorithm/101818/">Part 1. Description, operation, application.</a> <br>  <strong>Part 2. Valuable information in the tree and multiple operations with it.</strong> <br>  <a href="http://habrahabr.ru/blogs/algorithm/102364/">Part 3. The Cartesian tree by implicit key.</a> <br>  <em>To be continued ...</em> <br><br><h4>  Theme of today's lecture </h4><br>  Last time we met - let's say frankly, very extensively acquainted with - the concept of a Cartesian tree and its basic functionality.  Only up to now we have used it in one and only way: as a ‚Äúquasi-balanced‚Äù search tree.  That is, let us be given an array of keys, add randomly generated priorities to them, and get a tree in which each key can be searched for, added, and deleted in logarithmic time and a minimum of effort.  It sounds good, but not enough. <br><br>  Fortunately (or unfortunately?), Real life is not limited to such trifling tasks.  What is today and will be discussed.  The first question on the agenda is the so-called K-th ordinal statistics, or an index in the tree, which will smoothly lead us to store user information at the vertices, and finally - to the countless manipulations with this information that may be required.  Go. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Looking for an index </h4><br>  In mathematics, the <i>K-th order statistic</i> is a random variable that corresponds to the K-th largest element of a random sample from a probability space.  Too clever.  Let's return to the tree: at each moment of time we have a Cartesian tree, which could have changed significantly since its initial construction.  We are required to very quickly find the Kth key in this tree in ascending order ‚Äî in fact, if we represent our tree as a constantly maintained sorted array, then it is just access to the element under the K index. At first glance, it is not very clear how to organize it: we have keys in the N tree, and they are scattered across the structure at random. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/d3/f9/d3f9076dbe0cdfaae3f3b26f57fb2010.png"></div><br><a name="habracut"></a><br>  Although, frankly, not as horrible.  We know the property of the search tree ‚Äî for each vertex, its key is more than all the keys of its left subtree, and less than all the keys of the right subtree.  Therefore, to arrange the keys of a tree in a sorted order, it is enough to conduct a so-called In-Order walk around it, that is, to walk through the whole tree, following the principle ‚Äúfirst recursively bypass the left subtree, then the key of the root itself, and then the recursively right subtree‚Äù.  If every key we encounter in this way is written to a list, then in the end we will get a completely sorted list of all the nodes of the tree.  Whoever does not believe, can carry out the above procedure on the deramid from the picture just above - will receive an array from the same picture. <br><blockquote> The above reasoning allows us to write for the Cartesian tree an iterator in order to use the standard language tools ( <code>foreach</code> , etc.) to walk through its elements in ascending order.  In C #, to do this, you can simply write an in-order bypass function and use the <code>yield return</code> , and in those where there is no such powerful functionality, you will have to go one of two ways.  Or store at each vertex a link to the ‚Äúnext‚Äù element in the tree, which gives an additional expense of valuable memory.  Or, to write a non-recursive tree traversing through your own stack, which is somewhat more complicated, but it will improve both the speed of the program and the cost of memory. <br></blockquote><br>  Of course, this approach should not be regarded as a complete solution of the problem, because it requires O (N) time, and this is unacceptable.  But you can try to improve it if we knew immediately which parts of the tree we should not go in, because there are guaranteed larger or smaller elements in order.  And this is quite realistic to realize, if we remember for each vertex of the tree, how many elements we will have to go around during a recursive entry into it.  That is, we will store at each vertex its <em>subtree size</em> . <br><br>  The figure shows the same tree with the sizes of subtrees affixed at each vertex. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/a8/c3/a8c3e13b491502518ddcadd25d5d22d4.png"></div><br>  Then suppose that we honestly calculated the number of vertices in each subtree.  We now find the Kth element in the indexing starting from zero (!). <br><br>  The algorithm is clear: we look at the root of the tree and the size of its left subtree <strong>S <sub>L</sub></strong> , the size of the right one is not even needed. <br>  If S <sub>L</sub> = K, then we have found the required element, and this is the root. <br>  If S <sub>L</sub> &gt; K, then the desired element is somewhere in the left subtree, descend there and repeat the process. <br>  If S <sub>L</sub> &lt;K, then the desired element is somewhere in the right subtree.  Reduce K by the number S <sub>L</sub> +1 in order to correctly respond to the sizes of the subtrees on the right, and repeat the process for the right subtree. <br><br>  I will model this search for K = 6 on the same tree: <br>  Vertex (10; 8), S <sub>L</sub> = 4, K = 6. Go to the right, decreasing K by 4 + 1 = 5. <br>  Vertex (14; 6), S <sub>L</sub> = 2, K = 1. Go left, without changing K. <br>  Vertex (11; 4), S <sub>L</sub> = 0 (no left son), K = 1. Go right, decreasing K by 0 + 1 = 1. <br>  Vertex (13; 1), S <sub>L</sub> = 0 (no left son), K = 0. The key is found. <br>  Answer: the key under the index 6 in the Cartesian tree is equal to 13. <br><br>  In principle, this entire passage resembles a simple key search in a binary search tree - it‚Äôs still just going down the tree comparing the parameter you are looking for with the parameter in the current vertex, and depending on the situation we turn left or right.  I will say in advance - we will meet more than once with a similar situation in different algorithms, it is quite typical for various binary trees.  The traversal algorithm is so typical that it is easy to template.  As you can see, recursion is not even needed here, we can do with a simple cycle with a couple of variables that change with each iteration. <blockquote>  In a functional language, you can write a solution through recursion, and it will look and be read much more beautifully, without losing a bit of performance: a tail recursion, and the compiler immediately optimizes it in the same ordinary cycle.  For those who know functional programming, but doubt in my words - Haskell code: <br> <code><font color="black"><font color="#06c"><b>data</b></font> <font color="#cccc00"><b>Ord</b></font> a <font color="#339933"><b>=&gt;</b></font> Treap a <font color="#339933"><b>=</b></font> Null <br> <font color="#339933"><b>|</b></font> Node { key <font color="#339933"><b>::</b></font> a <font color="#339933"><b>,</b></font> priority <font color="#339933"><b>::</b></font> <font color="#cccc00"><b>Int</b></font> <font color="#339933"><b>,</b></font> size <font color="#339933"><b>::</b></font> <font color="#cccc00"><b>Int</b></font> <font color="#339933"><b>,</b></font> left <font color="#339933"><b>::</b></font> (Treap a) <font color="#339933"><b>,</b></font> right <font color="#339933"><b>::</b></font> (Treap a) } <br> <br> sizeOf <font color="#339933"><b>::</b></font> ( <font color="#cccc00"><b>Ord</b></font> a) <font color="#339933"><b>=&gt;</b></font> Treap a <font color="#339933"><b>-&gt;</b></font> <font color="#cccc00"><b>Int</b></font> <br> sizeOf Null <font color="#339933"><b>=</b></font> 0 <br> sizeOf Node {size <font color="#339933"><b>=</b></font> s} <font color="#339933"><b>=</b></font> s <br> <br> kthElement <font color="#339933"><b>::</b></font> ( <font color="#cccc00"><b>Ord</b></font> a) <font color="#339933"><b>=&gt;</b></font> (Treap a) <font color="#339933"><b>-&gt;</b></font> <font color="#cccc00"><b>Int</b></font> <font color="#339933"><b>-&gt;</b></font> <font color="#cccc00"><b>Maybe</b></font> a <br> kthElement  Null <font color="#339933"><b>_</b></font> <font color="#339933"><b>=</b></font> Nothing <br> kthElement (Node key <font color="#339933"><b>_</b></font> <font color="#339933"><b>_</b></font> left right) k <br> <font color="#339933"><b>|</b></font> sizeLeft <font color="#339933"><b>==</b></font> k <font color="#339933"><b>=</b></font> Just key <br> <font color="#339933"><b>|</b></font> sizeLeft <font color="#339933"><b>&lt;</b></font> k <font color="#339933"><b>=</b></font> kthElement left k <br> <font color="#339933"><b>|</b></font> sizeLeft <font color="#339933"><b>&gt;</b></font> k <font color="#339933"><b>=</b></font> kthElement right (k <font color="#339933"><b>-</b></font> sizeLeft <font color="#339933"><b>-</b></font> 1) <br> <font color="#06c"><b>where</b></font> sizeLeft <font color="#339933"><b>=</b></font> sizeOf left <br></font></code> <br></blockquote>  Speaking of performance.  The search time for the Kth element is obviously O (log <sub>2</sub> N), we just went down from the top to the depth of the tree. <br><br>  In order not to offend readers, in addition to the functional, I will also give the traditional source code in C #.  In it, in the standard workpiece of the <code>Treap</code> class, given in the first part, one more integer field <code>Size</code> is added - the size of the subtree, as well as the useful <code>SizeOf</code> function for its reception. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SizeOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Treap treap</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : treap.Size; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? KthElement(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K) { Treap cur = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cur != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sizeLeft = SizeOf(cur.Left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sizeLeft == K) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur.x; cur = sizeLeft &gt; K ? cur.Left : cur.Right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sizeLeft &lt; K) K -= sizeLeft + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br>  The key issue is still the fact that we still do not know how to maintain the correct <code>size</code> values ‚Äã‚Äãin the tree.  After all, after the first addition to the tree of a new key, all these numbers will go to ashes, and recalculate them each time again - O (N)!  But no.  O (N) it would take after some operation that completely re-arranged the tree into an incomprehensible structure.  And here is the addition of a key that acts more carefully and does not touch the whole tree, but only its small part.  So you can do with less blood. <br><br>  As you remember, with us everything is done, so to speak, through Split and Merge.  If we adapt these two main functions to support additional information in the tree - in this case, the sizes of the subtrees - then all other operations will automatically be performed correctly, because they do not make any changes to the tree (except for creating elementary trees from one vertex where <code>Size</code> needed Do not forget to set the default to 1!). <br>  I will start by modifying the operation Merge. <br><img src="http://habrastorage.org/storage/habraeffect/a9/8f/a98f52fd388745ea9be4b4681f780880.png"><br>  Recall the procedure for performing Merge.  She first chose the root for a new tree, and then recursively merged one of its subtrees with another tree and wrote down the result in place of the harvested subtree.  I will deal with the case when it was necessary to merge the right subtree, the second is symmetrical.  Like last time, recursion will help us a lot. <br><br>  Let's make the induction hypothesis: let after the execution of the Merge on subtrees, everything is already calculated correctly in them.  Then we have the following state of affairs: in the left subtree the dimensions are calculated correctly, since  nobody touched him;  right is also calculated correctly, because  This is the result of Merge.  Restore justice remains only at the root of the new tree!  Well, just recalculate it before completion <nobr>( <code>size = left.size + right.size + 1</code> )</nobr> , and now Merge has completely created an entire new tree, at each vertex of which is the correct size of the subtree. <br><br>  The source code of the Merge will change slightly: to the recalculation line before returning the answer.  It is marked with a comment. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recalc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Size = SizeOf(Left) + SizeOf(Right) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Merge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Treap L, Treap R</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; Treap answer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ly &gt; Ry) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newR = Merge(L.Right, R); answer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Lx, Ly, L.Left, newR); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newL = Merge(L, R.Left); answer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Rx, Ry, newL, R.Right); } answer.Recalc(); <span class="hljs-comment"><span class="hljs-comment">// ! return answer; }</span></span></code> </pre><br>  Exactly the same situation awaits us with the operation Split, which is also based on a recursive call.  Let me remind you: here, depending on the key value in the root of the tree, we recursively divided according to the specified key either the left or right subtree of the original, and one of the results was hung back, and the second was returned separately.  Again, let for the sake of uniqueness, we recursively divide T.Right. <br><img src="http://habrastorage.org/storage/habraeffect/35/27/35277f3277ac1bf837b7735f18066f58.png"><br>  The familiar induction hypothesis - let the recursive calls Split calculate everything correctly - it will help us this time too.  Then the dimensions in T.Left are correct - nobody touched them;  dimensions in L 'are correct - this is the left result Split;  dimensions in R 'are correct - this is the right result of the split.  Before completion, justice must be restored at the root <nobr>(x; y) of the</nobr> future L tree - and the answer is ready. <br><br>  The source code of the new Split, in which the two added lines recalculate the <code>Size</code> value in the root L or R, depending on the variant. <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { Size = SizeOf(Left) + SizeOf(Right) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Split(<span class="hljs-type"><span class="hljs-type">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Treap L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Treap R) { Treap newTree = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.x &lt;= x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) R = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Right.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> R); L = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Treap(this.x, y, Left, newTree); L.Recalc(); //   L! } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) L = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Left.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree); R = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Treap(this.x, y, newTree, Right); R.Recalc(); //   R! } }</code> </pre><br>  The ‚Äúrestoration of justice‚Äù under discussion - recalculation of the value at the top ‚Äî I singled out into a separate function.  This is the base line, which holds the functionality of the entire Cartesian tree.  And when in the second half of the article we will have multiple multiple operations, each with its own ‚Äúrecovery‚Äù, it will be much more convenient to change it in one single place than throughout the entire class code.  Such a function has one common property: it assumes that everything is valid in the left son, everything is valid in the right son, and on the basis of these data recalculates the parameter in the root.  Thus, it is possible to support any additional parameters that are calculated from the descendants, the sizes of the subtrees are just a particular example. <br><br><h4>  Welcome to the real world </h4><br>  Let's go back to the real life.  In it, the data that you have to store in the tree is not limited to the key alone.  And with this data constantly have to make some kind of manipulation.  For example, in this article I will call such a new field Duchi <code>Cost</code> . <br><br>  So, let us at the entrance constantly receive (and sometimes delete) the keys <code>x</code> , and each of them is associated with the corresponding price - <code>Cost</code> .  And you need to support in all this porridge quick requests for <em>maximum</em> prices.  You can ask the maximum in the whole structure, but you can only on some subsegment of it: for example, the user may be interested in the maximum price for 2007 (if the keys are related to time, this can be interpreted as a maximum price request on a set of such elements, where <nobr><b>A</b> ‚â§ x &lt; <b>b</b></nobr> ). <br><br>  This is not a problem, because the maximum is also an excellent candidate for the function of ‚Äújustice restoration‚Äù.  Enough to write like this: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>; //  <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> MaxTreeCost; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> CostOf(Treap treap) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-type"><span class="hljs-type">double</span></span>.NegativeInfinity : treap.MaxTreeCost; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { MaxTreeCost = Math.Max(<span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, Math.Max(CostOf(Left), CostOf(Right))); }</code> </pre><br>  The same situation with the minimum, and with the sum, and with some Boolean characteristics of the element (the so-called "coloring" or "marked").  For example: <br><pre> <code class="hljs pgsql">//  <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> SumTreeCost; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> CostOf(Treap treap) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : treap.SumTreeCost; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { SumTreeCost = <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> + CostOf(Left) + CostOf(Right); }</code> </pre><br>  Or: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> Marked; //  <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> TreeHasMarked; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">bool</span></span> MarkedOf(Treap treap) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> : treap.TreeHasMarked; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { TreeHasMarked = Marked || MarkedOf(Left) || MarkedOf(Right); }</code> </pre><br>  The only thing to remember in such cases is to initialize these parameters in the constructor when creating new individual vertices. <br><blockquote>  As they would say in the functional world, we are performing to some extent the <em>convolution of a</em> tree. <br></blockquote><br>  Thus, we are able to query the value of the parameter for the entire tree - it is stored in the root.  Inquiries on podotrezkakh also not difficult, if again recall the property of the binary search tree.  The key of each vertex is greater than all the keys of the left subtree and less than all the keys of the right subtree.  Therefore, we can virtually assume that there is an associated key interval associated with each vertex, which, in theory, can be found in it and in its subtree.  So, at the root it is an interval <nobr>(-‚àû; + ‚àû)</nobr> , at its left son <nobr>(-‚àû; x)</nobr> , right - <nobr>(x; + ‚àû)</nobr> , where x is the key value in the root.  All intervals open on both sides, X among the keys of the right subtree can not meet.  If we allow the same keys in the tree and, as in the first part, force the comparator to throw them all into the same subtree ‚Äî say, to the left, then the interval for the left son will be <nobr>(-‚àû; x]</nobr> . <br><br>  For clarity, I will show in the figure the corresponding interval for each vertex of the Cartesian tree already investigated. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage/habraeffect/01/3e/013e94bf791902cfb622b93f01c137e3.png"></div><br>  It is now clear that the parameter stored at the vertex is responsible for the value of the corresponding characteristic (maximum, sum, etc.) for all keys on the interval of this vertex. <br><br>  And we can respond to requests at intervals <nobr><b>[A;</b></nobr>  <nobr><b>B)</b></nobr> (in C ++ and similar languages ‚Äã‚Äãit is generally more convenient to operate with half-open intervals that include the left end and do not include the right end; in the future I will do so). <br>  Someone familiar with the segment tree may think that it is worthwhile to use the same recursive descent, gradually localizing the current vertex to one that fully corresponds to the desired interval or a piece of it.  But we will do it easier and faster, reducing the task to the previous one. <br><br>  Masterfully possessing scissors, we divide the tree first, using the key A-1.  The right-hand result Split, which stores all keys greater than or equal to A, is divided again - this time by key B. In the middle we will get a tree with all the elements for which the keys belong to the desired interval.  To find out the parameter, it‚Äôs enough to look at its value in the root - after all, Split has already done all the hard work of restoring justice for each tree for us :) <br><br>  The query time is obviously O (log <sub>2</sub> N): two executions of Split.  Source code for maximum: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxCostOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B</span></span></span><span class="hljs-function">)</span></span> { Treap l, m, r; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Split(A - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(B, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CostOf(m); }</code> </pre><br><br><h4>  The power of deferred computing </h4><br>  Today's aerobatics is the ability to change user information in the course of a tree‚Äôs life.  It is clear that after changing the value of <code>Cost</code> at some vertex, all of our previous parameters, which have accumulated answers for the values ‚Äã‚Äãin their subtrees, are no longer valid.  You can, of course, walk around the whole tree and recount them again, but this is O (N) again, and will not go into any gate.  What to do? <br><br>  If we are talking about a simple change in <code>Cost</code> in a single vertex, then this is not such a problem.  At first, moving from top to bottom, we find the necessary element.  We change the information in it.  And then, moving back upwards to the root, we simply recalculate the values ‚Äã‚Äãof the parameters by the standard function - after all, this change will not affect any other subtrees, except for those that we visited on the way from root to top.  The source code, I believe, does not make much sense; the task is trivial: solve it with at least recursion, at least in two cycles, the runtime is still O (log <sub>2</sub> N). <br><br>  Life becomes much more fun if you need to support <em>multiple operations</em> .  Let us have a Cartesian tree, in each of its peaks stored user information <code>Cost</code> .  And we want to add the same number A to each value of <code>Cost</code> in the tree (or subtree - see the reasoning about the intervals). This is an example of a multiple operation, in this case adding a constant on the segment.  And here you will not get by with a simple passage to the root. <br><br>  Let's get in each vertex an additional parameter, let's call it <code>Add</code> .  Its essence is as follows: it will signal that the entire subtree growing from a given vertex is <em>supposed to</em> add a constant to <code>Add</code> .  It turns out to be such a late addition: if you need to change the values ‚Äã‚Äãto A, in some subtree we change only the root <code>Add</code> in this subtree, as if giving a promise to descendants that ‚Äúsometime in the future you all will be additionally added, but we‚Äôll will not be until it is required. " <br><br>  Then the <code>Cost</code> request from the root of the tree should perform one more additional action, adding the root <code>Add</code> to <code>Cost</code> , and regard the received sum as the actual <code>Cost</code> , as if lying in the root of the tree.  The same with requests for additional parameters, for example, the sum of prices in the tree: we have the correct (!) <code>SumTreeCost</code> value in the root, which stores the sum of all the elements of the tree, but not taking into account that we must add to all these elements <code>Add</code> .  To obtain a truly correct value of the sum with all pending operations, it suffices to add the <code>SumTreeCost</code> value to <code>SumTreeCost</code> multiplied by <code>Size</code> ‚Äî the number of elements in the subtree. <br><br>  So far, it is not very clear what to do with the standard operations of the Cartesian tree - Split and Merge - and when we need to still fulfill the promise and add to the descendants the promised them <code>Add</code> .  Now consider these issues. <br><br>  Take up the Split operation again.  Since the original tree is divided into two new ones, and we lose the original one, the pending addition will have to be partially completed.  Namely: let the recursive call Split divides our right subtree T.Right.  Then we will carry out such manipulations: <br><br>  ‚Ä¢ Fulfill the promise in the root, add to the root <code>Cost</code> value of the root <code>Add</code> . <br><pre>  T.Cost + = T.Add; </pre>  ‚Ä¢ ‚ÄúLet‚Äôs pull down‚Äù the promise to the left: <code>Add</code> also required for the entire left subtree.  But since the recursion to the left does not go, we don‚Äôt need to actively touch this subtree.  Just write the promise. <br><pre>  T.Left.Add + = T.Add; </pre>  ‚Ä¢ ‚ÄúLet's make a promise‚Äù to the right: the <code>Add</code> right is also required for the entire right subtree.  This must be done before the recursive call so that the Split operation manipulates the correct Cartesian tree.  The recursion will do the next update itself. <br><pre>  T.Right.Add + = T.Add; </pre>  ‚Ä¢ Make a recursive call.  Split returned us two valid Cartesian trees. <br>  ‚Ä¢ Since we honestly fulfilled the promise in the root, and honestly recorded promises for our descendants in memory, the root <code>Add</code> should be reset. <br><pre>  T.Add = 0; </pre>  ‚Ä¢ Further subtree attachments in Split are performed as usual.  As a result - two correct Cartesian trees with actual information on promises: somewhere fulfilled, somewhere only deferred, but actual. <br><br>  All operations are indicated on the new Split chart. <br><img src="http://habrastorage.org/storage/habraeffect/34/0d/340d2f6b9c7fe51183ee5e481593c6a3.png"><br>  Note that the <em>actual</em> updates are carried out only in those vertices that the Split operation will follow recursively, for the rest, we will at best lower the promise a bit lower.  The same situation will be with Merge. <br><br>  The new Merge basically does the same.  Let him need to recursively merge the right L.Tight subtree with the right input tree R. Then do the following: <br><br>  ‚Ä¢ Fulfill the promise in the root L. <br><pre>  L.Cost + = L.Add; </pre>  ‚Ä¢ ‚ÄúLet's unleash‚Äù the promise to the descendants of L - for the future. <br><pre>  L.Left.Add + = L.Add;
   L.Right.Add + = L.Add; </pre>  ‚Ä¢ The promise is completely fulfilled - you can forget about it. <br><pre>  L.Add = 0; </pre>  ‚Ä¢ Making the necessary recursive call <nobr>Merge (L.Right, R)</nobr> , because now both its arguments are valid Cartesian trees.  And she will return us the correct tree too. <br>  ‚Ä¢ Suspend the returned tree with the right son, as before.  In the end - again Cartesian tree with relevant information on the promises. <br><br><img src="http://habrastorage.org/storage/habraeffect/97/a5/97a5a0285b885313661bc412c034a99c.png"><br><br>  Now, when we are able to make inquiries in the root and change on the whole tree, it is not difficult to scale this solution for sub-splices, simply applying the same principle as several paragraphs above. <br>  We make two Split calls, selecting the subtree corresponding to the required key interval in a separate tree. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us increase the root promise of this tree </font></font><code>Add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for a given A. We obtain a valid tree with a pending addition. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us merge again all three trees together with two calls </font></font><code>Merge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and write in the place of the original one. </font><font style="vertical-align: inherit;">Now, keys at a given interval honestly live with the promise that all of them sometime in the future are supposed to add A. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of this manipulation can be left as an exercise for the reader :)</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to restore justice in the roots after all operations by calling a new version of the function </font></font><code>Recalc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This new version should take into account deferred additions, as already described in the story of requests.</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, I note that multiple operations, of course, are not limited to only one addition on the segment. You can also ‚Äúpaint‚Äù on the segment ‚Äî set the Boolean parameter to all elements, change it ‚Äî set all values </font></font><code>Cost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the segment to one value, and so on, which only the imagination of the programmer comes up with. The main condition for the operation is that it can be </font><font style="vertical-align: inherit;">pushed down from the root to the descendants by </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (1)</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , transferring the delayed promise just below the tree, as we did with Merge and Split. And, of course, information should be easily restored from the promise at the time of the request, otherwise there is no point in making a garden.</font></font><br><br><h4>  Summary </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have learned to support various user additional information in a Cartesian tree, and to carry out with it a huge number of multiple manipulations, with each request or change, whether at a single vertex or in a segment, is performed in logarithmic time. </font><font style="vertical-align: inherit;">Coupled with the elementary properties of the Cartesian tree, described in the first part, this already represents a huge scope for its practical use in any system where it is necessary to store significant amounts of data, and periodically request any statistics from these data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in the next part I will make a Cartesian tree a small modification that will turn it into a tool of truly enormous power for everyday needs. </font><font style="vertical-align: inherit;">This miracle will be called a "Cartesian tree with an implicit key."</font></font><br><br>  Thank you all for your attention. </div><p>Source: <a href="https://habr.com/ru/post/102006/">https://habr.com/ru/post/102006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../101995/index.html">Contest osbygoogle.ru: Author of the month - 1000 rub!</a></li>
<li><a href="../101997/index.html">Newspaper ¬´FOSS News¬ª ‚Ññ8 (20) 2010</a></li>
<li><a href="../101999/index.html">How do people log in to Bynet</a></li>
<li><a href="../102000/index.html">Electric bike do it yourself</a></li>
<li><a href="../102001/index.html">The official name of Ubuntu 11.04 - Natty Narwhal</a></li>
<li><a href="../102007/index.html">GPT and WD Advanced format</a></li>
<li><a href="../102008/index.html">WiMax 2 standard should be adopted in November</a></li>
<li><a href="../102010/index.html">Creating a Javascript Canvas Game</a></li>
<li><a href="../102011/index.html">Whyday 2010 - Why the Lucky Stiff Memorial Day</a></li>
<li><a href="../102012/index.html">Java / Python SDKs 1.3.6 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>