<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unification of associative STL-containers by a template parameter - comparator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consider the code: 


std::multiset<int> set0, set1; for (auto it = set0.begin(); it != set0.end(); ++it) { // // // *it } for (auto it = set1.rbegin(...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unification of associative STL-containers by a template parameter - comparator</h1><div class="post__text post__text-html js-mediator-article">  Consider the code: <br><pre><code class="hljs ruby">std::multiset&lt;int&gt; set<span class="hljs-number"><span class="hljs-number">0</span></span>, set1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto it = set<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(); it != set<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++it) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ *it } for (auto it = set1.rbegin(); it != set1.rend(); ++it) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ *it }</span></span></code> </pre> <br>  The processing in the cycle bodies is the same, in other words, the elements of two multisets are required to be processed in the same way: the first in the direct order, the second in the reverse. <br><a name="habracut"></a><br>  The task is to combine these two cycles approximately as follows: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> N = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; sets[N] = {<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; val: sets[i]) { <span class="hljs-comment"><span class="hljs-comment">//  //  // val } }</span></span></code> </pre><br>  It is clear that since the set1 elements are iterated in the reverse order for the processing cycle and the forward in sets [1], in order to preserve the processing order, the sets [1] need to store the elements in the reverse order with respect to set1.  The STL associative containers have a generic parameter ‚Äî a comparator, which by default has a value of std :: less.  So in a first approximation, in order to make the code work, you need to initialize sets approximately as follows: <br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; sets[N] = {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::greater&gt;()};</code> </pre><br>  The classes std :: multiset &lt;int, std :: less&gt; and std :: multiset &lt;int, std :: greater&gt; are different and do not have a common ancestor, therefore they cannot be stored in the same array and the above code simply cannot be compiled.  (By the way, the iterators std :: multiset :: const_iterator and std :: multiset :: const_reverse_iterator are also different classes without a common ancestor, so an array of iterators instead of an array of containers will also not solve the problem).  The task is reduced to the unification of containers in order to store them in a common array. <br><br>  In associative STL containers, a comparator is a parameter not only of the type, but also of each instance of the container.  For trivial cases like std :: less by default, the comparator class does not contain any data and, therefore, all containers perform the same comparison operation, in particular, they store elements in the same order.  For a more complex case, you can store data in the comparator, for example, about the sort order.  In this case, different instances of containers of the same class will sort the elements differently depending on the value of the field in the comparator instance, which in turn is the field of the container instance.  So, the class of the comparator allows you to compare in different ways: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ASC == order_ ? (l &lt; r) : (l &gt; r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Comparator </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asc_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Comparator </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Desc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desc_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Order_ {ASC, DESC} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> order_; Comparator(Order_ order) : order_(order) {}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Comparator asc_; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Comparator desc_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Comparator&lt;T&gt; Comparator&lt;T&gt;::asc_(Comparator&lt;T&gt;::ASC); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Comparator&lt;T&gt; Comparator&lt;T&gt;::desc_(Comparator&lt;T&gt;::DESC);</code> </pre><br>  In fact, only 2 instances of this class are required for each type of element T, therefore these 2 instances are created statically, and the interface of the Comparator class is such that no instances except these two can be obtained (not counting copying). <br><br>  So, we initialize sets as follows: <br><pre> <code class="hljs pgsql">typedef std::multiset&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>, Comparator&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; &gt; <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> sets[N] = { <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(Comparator&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;::<span class="hljs-keyword"><span class="hljs-keyword">Asc</span></span>()), <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(Comparator&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;::<span class="hljs-keyword"><span class="hljs-keyword">Desc</span></span>()) };</code> </pre><br>  Thus, the resulting workable solution was reduced to the correct initialization of associative containers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Interestingly, since the comparator instance is stored in the container by value, not by pointer or reference, the solution is fundamentally non-polymorphic.  However, you can offer a solution similar to dynamic polymorphism from the point of view that is based on an indirect call of functions.  Consider the functions: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareGreater</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &gt; r; }</code> </pre><br>  They have the same signature, therefore, the same type, which may be the type of comparator in an associative container.  The solution comes down to the following array initialization: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*compareFn)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, compareFn&gt; Set2; Set2 sets2[N] = { Set2(compareLess&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;), Set2(compareGreater&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;) };</code> </pre><br>  <strong>UPD:</strong> Thanks to the <a href="http://habrahabr.ru/users/unrul/" class="user_link">Unrul</a> idea of ‚Äã‚Äãusing std :: function, 4 more were added to the two options: <br>  Option 3: Lyabda functions <br>  Option 4: std :: less, wrapped in std :: function, for reverse sorting, the parameters std :: less are rearranged with std :: bind <br>  Option 5: std :: less and std :: greater wrapped in std :: function <br>  Option 6: combines options 2 and 3: std :: function reduced to a function pointer <br><br>  I give a complete example that demonstrates the performance of all solutions (processing of multisets is reduced to the conclusion of their elements, which demonstrates the correct sorting order): <br><pre> <code class="hljs lua">#include &lt;iostream&gt; #include &lt;set&gt; #include &lt;functional&gt; using namespace std::placeholders; template &lt;typename T&gt; class Comparator { public: bool operator()(const T&amp; l, const T&amp; r) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ASC == order_ ? (l &lt; r) : (l &gt; r); } static Comparator const&amp; Asc() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asc_; } static Comparator const&amp; Desc() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desc_; } private: enum Order_ {ASC, DESC} const order_; Comparator(Order_ order) : order_(order) {}; static Comparator asc_; static Comparator desc_; }; template&lt;typename T&gt; Comparator&lt;T&gt; Comparator&lt;T&gt;::asc_(Comparator&lt;T&gt;::ASC); template&lt;typename T&gt; Comparator&lt;T&gt; Comparator&lt;T&gt;::desc_(Comparator&lt;T&gt;::DESC); template&lt;typename T&gt; bool compareLess(const T&amp; l, const T&amp; r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r; } template&lt;typename T&gt; bool compareGreater(const T&amp; l, const T&amp; r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &gt; r; } int main() { static size_t const N = <span class="hljs-number"><span class="hljs-number">2</span></span>; int unsorted[] = {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; //<span class="hljs-number"><span class="hljs-number">1</span></span> { typedef std::multiset&lt;int, Comparator&lt;int&gt; &gt; Set; Set sets[N] = { Set(Comparator&lt;int&gt;::Asc()), Set(Comparator&lt;int&gt;::Desc()) }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } //<span class="hljs-number"><span class="hljs-number">2</span></span> { typedef bool (*compareFn)(int const&amp;, int const&amp;); typedef std::multiset&lt;int, compareFn&gt; Set2; Set2 sets2[N] = { Set2(compareLess&lt;int&gt;), Set2(compareGreater&lt;int&gt;) }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets2[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets2[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } //<span class="hljs-number"><span class="hljs-number">3</span></span> { typedef std::multiset&lt;int, std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int,int)</span></span></span></span>&gt;&gt; Set3; Set3 sets3[N] = {Set3([](int a, int b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }), Set3([](int a, int b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &gt; b; })}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets3[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets3[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } //<span class="hljs-number"><span class="hljs-number">4</span></span> { typedef std::multiset&lt;int, std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int,int)</span></span></span></span>&gt;&gt; Set4; Set4 sets4[N] = {Set4(std::less&lt;int&gt;()), Set4(std::bind(std::less&lt;int&gt;(), _2, _1))}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets4[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets4[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } //<span class="hljs-number"><span class="hljs-number">5</span></span> { typedef std::multiset&lt;int, std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int,int)</span></span></span></span>&gt;&gt; Set5; Set5 sets5[N] = {Set5(std::less&lt;int&gt;()), Set5(std::greater&lt;int&gt;())}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets5[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets5[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } //<span class="hljs-number"><span class="hljs-number">6</span></span>:   <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span> { typedef bool (*compareFn)(int const&amp;, int const&amp;); typedef std::multiset&lt;int, compareFn&gt; Set6; Set6 sets6[N] = {Set6([](int const&amp; a, int const&amp; b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }), Set6([](int const&amp; a, int const&amp; b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &gt; b; })}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { sets6[i].<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(std::begin(unsorted), std::<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(unsorted)); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto const&amp; it : sets6[i]) { std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/210746/">https://habr.com/ru/post/210746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210736/index.html">HID USB Device Management on Windows 7</a></li>
<li><a href="../210738/index.html">Facebook will create an energy-efficient data storage of 10,000 Blu-ray discs</a></li>
<li><a href="../210740/index.html">Analysis of popular game addiction theories</a></li>
<li><a href="../210742/index.html">How does chromecast work?</a></li>
<li><a href="../210744/index.html">Secure backup using public services</a></li>
<li><a href="../210748/index.html">User Timing API</a></li>
<li><a href="../210750/index.html">2.4GHz USB "whistle" with your own hands</a></li>
<li><a href="../210754/index.html">We pump Google Tasks using a third-party service: repetitive tasks, sharing, notifications about deadlines and other features</a></li>
<li><a href="../210760/index.html">How to hash passwords and how not to</a></li>
<li><a href="../210762/index.html">As we were in Canadian accelerators filed and interviews were held</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>