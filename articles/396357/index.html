<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering laser scanner Leuze RS4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier, I already talked about reverse engineering of a laser distance sensor . This time we will talk about a more complex device - laser scanner Le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering laser scanner Leuze RS4</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/09a/d9e/f75/09ad9ef7519d415f9d003991043d22b1.jpg" align="right"><br>  Earlier, I already talked about reverse engineering of a <a href="https://habrahabr.ru/post/274879/">laser distance sensor</a> .  This time we will talk about a more complex device - laser scanner Leuze RS4.  Like the sensor, this scanner came to me in a broken condition, so I had to rebuild its work, and in the process improve some of its characteristics, and, in fact, redo it into another device. <br><a name="habracut"></a><br><h4>  What is this laser scanner? </h4><br>  <a href="http://www.leuze.com/en/deutschland/produkte/produkte_fuer_die_arbeitssicherheit/optoelektronische_sicherheits_sensoren/sicherheits_laserscanner/rs4_11/sicherheits_laserscanner_funktionspaket_basis_/selector.php%3Fsupplier_aid%3D50034195%26grp_id%3DA1-3-1-4-1%26lang%3Deng">Leuze RS4</a> is a laser safety scanner, that is, it is designed to prevent people from entering dangerous areas in production, to prevent collisions of production vehicles, etc. It has quite decent characteristics - maximum range: 15 / 50m (depending on the operation mode ), the distance measurement accuracy in the whole measurement range is 5 mm, the angular resolution is 0.36 degrees, the scanning speed is 25 rev / sec (25000 measurements / sec). <br><br>  It should be noted that this scanner is positioned precisely as a security device - that is, it stores in memory the location of alarm and warning zones, and if an object hits these zones, one of the keys opens in the scanner.  To adjust the location of zones, the scanner can be connected to a computer and observe the location of obstacles on the screen.  There is even a package for ROS that allows you to receive data from this scanner. <br>  I got a scanner without a case, disassembled into its component parts.  The scanner has failed due to a strong blow to the body;  what exactly stopped working in it, I didn‚Äôt understand - perhaps the optics got misaligned, the contact went off in one of the connectors, or the encoder sensor moved, or something else.  I tried to put all the parts together, I saw the scanner in the native software, but the scan did not start.  So I only have one way to start it - to restore the scanner circuit as completely as possible, and to write my own microcontroller firmware. <br><br>  Here are the parts that I had: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/52c/f37/092/52cf370928ab5d8ee92ff63432d49fbb.jpg" alt="image"></a> <br><br>  This is how they should be located in the case (a photo from the documentation, it is clear that the design and electronics are slightly different): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/77f/2b8/395/77f2b839587cb43a293ea58c34270b1c.jpg" alt="image"><br><br>  Also an important part of the scanner is the scanning mirror (highlighted in blue in the photo above), installed in its center: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/16d/5db/5c6/16d5db5c60f0e710e0485fab2236e510.jpg" alt="image"><br><br>  Scanner block diagram: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/74e/9e5/8bd/74e9e58bdd529e60b5a823df47fdc6db.png" alt="image"><br><br>  As can be seen from the diagram, the entire scanner electronics consists of separate modules (cards) connected by connectors and loops. <br><br>  There are a lot of modules - power supply module (DC-DC), interface module, processor module, photodetector module (APD), laser module.  In addition, there is also an encoder module and two horseshoe-shaped boards, which at first seemed strange. <br><br>  First of all, it is worth paying attention to them: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/957/fd1/ab6/957fd1ab64924ab5285c3442bae9e0fe.jpg" alt="image"><br><br>  Obviously, one of the boards contains LEDs, and the second - photodiodes.  Initially, I thought it was some kind of encoder, or some kind of mechanism for checking laser radiation.  However, later, after reading the documentation on the scanner, and having examined the photos in detail, I realized that this is a system for monitoring the condition of the protective glass surface of the scanner. <br><br>  The photo shows the holes for the LEDs: <br><br><img src="https://habrastorage.org/files/d08/12c/0e5/d0812c0e54544f7d9d6439be016575c7.jpg"><br><br>  By measuring the level of the signal from the photodiodes, you can estimate the transmittance of the protective glass.  Obviously, this system is not critical for the operation of the scanner, so I did not use these boards in the future. <br><br>  <b>The processor module</b> is the most difficult part of the scanner.  It looks like the electronics of the module from two sides: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/170/eb3/716/170eb3716ee18ad64d9e8ea5abf453d6.jpg" alt="image"><br><br>  When I looked at the board for the first time, I immediately realized that the scanner uses the time-of-flight distance measurement (TOF) method - the chip with the largest marking turned out to be " <a href="http://www.acam.de/products/time-to-digital-converters/tdc-gpx/">ACAM TDC-GPX</a> ", about which I had already heard before.  TDC - ‚ÄúTime-to-Digital Converter‚Äù, that is, a specialized chip designed to measure time intervals with very high accuracy, and that is what they are used to measure the ‚Äúflight‚Äù time of a laser pulse. <br>  Also on the board was an Infineon C167 microcontroller with an external FLASH memory chip (which pleased us) and an ASIC (which was very distressing).  In more detail about this module I will tell below. <br><br>  <b>The power module</b> contains some custom galvanically isolated DC-DC converter with several voltages at the output and several capacitors: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/7c9/30a/1f5/7c930a1f510a7df150eb89654c4c82dd.jpg" alt="image"><br><br>  Converter supply voltage - 24V.  Its main feature is that it outputs a high voltage (~ 230V) to a separate small connector, which is necessary for the operation of a laser and a photodetector. <br><br>  It also outputs the following voltages to the main connector: + 5V, -5V, ~ 15V, galvanically isolated from the rest + 5V for the RS232 interface. <br><br>  <b>Optical part of the scanner</b> <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/b2c/f7d/4af/b2cf7d4af2cf9f75fe2659845d9887fb.jpg" alt="image"></a> <br><br>  At first glance, the scanner optics is not very clear where that.  In this case, a small window with a mirror in the center of the photo serves to output the laser beam, and the large shiny surface around it is the surface of the interference light filter installed in front of the lens of the photodetector.  This light filter transmits only the radiation, the wavelength of which is close to the laser wavelength. <br><br>  This is how it is shown in the scanner documentation: <br><br><img src="https://habrastorage.org/files/a6a/58d/c01/a6a58dc01c2a434398d2e8e4b35ccd3b.png"><br><br>  The lens itself is installed inside a black plastic casing, so it‚Äôs problematic to see it.  At the end of this casing, opposite to what is seen in the photo above, the <u>laser</u> and <u>photodetector</u> <u>module is</u> fixed: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/17a/c09/dcf/17ac09dcf9e6e59b2383d155d932e7a3.jpg" alt="image"></a> <br><br>  <b>Laser module</b> <br>  Type of laser module (some parts are marked by me in the process of drawing a scheme): <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/c28/71a/a61/c2871aa619e574fe9cb8f01b7c3e21db.jpg" alt="image"></a> <br><br>  As you can see, the circuitry of this module is quite simple, so I was able to completely restore its circuit: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/2d7/2c5/176/2d72c51767c4c239419dbcf2d35ff249.png" alt="image"></a> <br><br>  A large round detail on the board is a specialized laser emitter.  Unfortunately, there were no markings on it, so no documentation was found for it. <br>  From the description on the scanner you can find out - ‚ÄúLaser light wavelength - 905 nm‚Äù, ‚ÄúLaser class - 1‚Äù, ‚ÄúPulse duration - 0.003 ¬µs‚Äù, ‚ÄúRepetition frequency - 25 kHz‚Äù. <br><br>  What was possible to understand by restoring the module circuit, and analyzing its work: <br><br><ul><li>  The laser emitter is constantly supplied with a supply voltage of 143 V, limited by zener diodes. </li><li>  The emitter starts on the leading edge of the pulse supplied to the input "3" of the module.  As I understand it, the pulse length can be arbitrary, the module itself will form a short pulse. </li><li>  The emitter contains a photo sensor, at the output of which a pulse appears at the moment when the laser actually turns on.  The signal from it is used as a reference (starting pulse) when measuring the time of ‚Äúflight‚Äù. </li></ul><br>  All control of the laser is carried out on one line - ‚ÄúLASER_PULSE‚Äù.  Most of the time on the line should be "high" level.  When a negative pulse is applied along its leading edge, the DD1 trigger is reset to 0, and on the rear pulse, the trigger begins to ‚Äúwait‚Äù for the signal from the photodiode and the laser starts.  When a signal from the photodiode appears, the trigger switches to 1. <br>  You can see two coaxial wires, using connectors connected to the module.  They are used to transmit the differential signal from the trigger to the TDC chip. <br><br>  Also on this module are installed five LEDs.  They are controlled by a processor module. <br><br>  <b>Photo receiver module</b> <br>  The module itself looks like this: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/a91/704/ae2/a91704ae269a7ce0761135bf935d1de8.jpg" alt="image"></a> <br><br>  Photo of the photodetector near: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/444/bb5/671/444bb5671b8daa4ba612f2e35b331ada.jpg" alt="image"></a> <br><br>  The sign of high voltage in the corner of the board clearly shows that an <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25BE%25D1%2582%25D0%25BE%25D0%25B4%25D0%25B8%25D0%25BE%25D0%25B4">avalanche photodiode (APD)</a> is used here - they need quite a high voltage to operate. <br><br>  Unfortunately, there were no visible markings on the photodetector housing.  By the emblem on the photodiode itself (in the center), it was only possible to determine that it was manufactured by <i>Pacific Silicon Sensor (First Sensor)</i> , but there was no further information about it, perhaps it is custom.  It can be seen from the photo that this photodetector is a hybrid one, i.e.  contains a built-in amplifier - it can be clearly seen above the photodiode.  Obviously, the amplifier and the photodiode need power - it is supplied through the lower terminals (capacitors are soldered to them).  The big mystery was the fine detail to the left of the photodiode, to which three conductors go.  Further research has shown that this is an analog thermal sensor. <br><br>  This module is much more complicated than the previous one. It uses a multilayer printed circuit board - at least 4 layers, with the majority of the signal lines located on the outer layer of the board, which greatly facilitates its analysis.  In this module, I restored about 80% of the scheme, the rest I was not really needed. <br><br>  The resulting circuit of the photodetector module: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/5d6/508/5ea/5d65085eade00ed5135fbf19a85bb783.png" alt="image"></a> <br><br>  At the top of the circuit is an adjustable linear high voltage source for an avalanche photodiode.  It can generate a stable voltage of at least 150 V. This source is controlled by the DAC DA1 (LTC1451). <br><br>  Since the scanner base is a pulse rangefinder, the main task of the photodetector module is to quickly detect a rather weak laser signal reflected from an obstacle.  Since the level of the light signal is very small, it can only be detected using an avalanche photodiode, which has its own amplification.  In this case, the signal from the photodiode is additionally amplified by an integrated amplifier integrated in the photodetector.  Due to the fact that the amplifier is built into the body of the photodetector, the effect of interference on the useful signal is reduced.  The signal generated by the photoreceiver (OUT_B) is transmitted to a certain DA4 chip, which, apparently, is another high-frequency amplifier.  After it, the signal is transmitted to the direct input of the high-speed comparator D1 (MAX9601).  A reference signal from a resistor divider (about 50 mV) is fed to the inverted input of this comparator. <br><br>  The signal at the comparator output is differential, it is transmitted by coaxial wire directly to the processor module board. <br><br>  In addition, the signal from the output of the amplifier DA4 is transmitted to some kind of peak detector, which "remembers" the maximum level of the received pulse.  I did not restore the circuit of this node, and I drew on the diagram only its output stage (U1 chip), the signal from which is also transmitted to the processor module. <br><br>  One of the least understandable parts of the scanner for me is the Q3 transistor mounted at the output of the RF amplifier.  Judging by the circuit design, it is needed to enable the attenuation of the signal at the amplifier output.  This transistor can be controlled by a signal from the processor board (line10 - ‚Äúdigi‚Äù). <br><br>  You may notice that the board has an EEPROM chip.  All signal outputs of this microcircuit are connected to the processor board.  Apparently, in this microcircuit were stored some parameters, unique for each photodetector board, and recorded in it when testing the board.  In particular, this may be the dependence of the APD amplification on the supply voltage, the dependence of the voltage at the output of the thermal sensor on its temperature, and other similar characteristics. <br><br>  You can see that the power of the photodetector can be controlled by setting certain levels on the CLK, CS, CS2 lines associated with the DAC and EEPROM. <br><br>  The board contains several circuits designed to monitor its condition.  You can control the voltage level of the APD, its temperature (line7) and the threshold of the comparator.  These voltages are converted by the operational amplifiers DA3-DA5 and transmitted to the processor module board. <br><br>  <b>Returning to the processor module</b> <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/170/eb3/716/170eb3716ee18ad64d9e8ea5abf453d6.jpg" alt="image"></a> <br><br>  This module is the most complex of all, it contains a large number of multi-output chips, the printed circuit board is also four-layer, and most of the signal lines are divorced in the inner layers, which significantly complicates the restoration of the circuit. <br><br>  Very often it turned out that the tracks switched to the other side of the board.  In order to quickly look for where a specific track is connected, I had to use just such a brush connected to a multimeter (which is in the dial mode): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/281/d5d/e1c/281d5de1cb6b8e4c16daf6d4f1690f99.jpg" alt="image"><br><br>  I restored about 70% of the scheme - the rest I did not really need.  Block diagram of the processor module: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/08d/3f6/60f/08d3f660f31927fd38ae94b82a953714.png" alt="image"><br><br>  The resulting processor module circuit: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/f5d/fef/0a7/f5dfef0a7e036ce6af8872997538b420.png" alt="image"></a> <br><br>  Despite the fact that I call this module ‚Äúprocessor module‚Äù everywhere, in reality, its basis is the <a href="http://www.infineon.com/cms/en/product/microcontroller/legacy-products-c500-c166-xc166-audo1-family/c166-registered-family/c167cr%25E2%2581%2584sr/SAK-C167CR-LM%2BHA%252B/productType.html%3FproductType%3Dff80808112ab681d0112ab6fbf9d277c">Infineon</a> microcontroller <a href="http://www.infineon.com/cms/en/product/microcontroller/legacy-products-c500-c166-xc166-audo1-family/c166-registered-family/c167cr%25E2%2581%2584sr/SAK-C167CR-LM%2BHA%252B/productType.html%3FproductType%3Dff80808112ab681d0112ab6fbf9d277c">SAK-C167CR-L33M</a> .  It has 144 outputs, and is built according to the rather old architecture of the C166.  This microcontroller does not have its own non-volatile memory - it is necessary to connect external memory to it via a parallel bus.  In the scanner for this purpose, the flash memory chip M29F400B (512K x 8 / 256K x 16) is installed.  Also, two microcircuits of RAM are connected to the microcontroller - IS61C6416AL-12 (64K x 16) and K6R4016C1D (256K x 16). <br><br>  You can see that the address bus is connected to all memory chips with a shift in one bit - the memory A0 lines are connected to the A1 line of the microcontroller.  This is due to the fact that addresses are set up on the address bus in bytes, but the controller and memory are 16-bit.  In order for the controller to write single bytes into RAM without affecting the neighboring bytes in a 16-bit word, the memory chips have special lines UBn, LBn.  Such a solution is very often found in devices with parallel buses and is described in detail in the documentation for the controller. <br><br>  But the other solution in the processor module did not become completely clear to me.  If you look at the flash memory chip U1, you will notice that the A14 line of the chip is connected to ground.  The corresponding bus line address of the controller A15 is not connected to the microchip at all.  The result is that the controller has access to only half of the flash memory.  The situation with the RAM2 (DD3) microcircuit is completely the same. <br><br>  The situation with the RAM1 (DD2) microcircuit is somewhat different - the controller A15 line is not connected to it either, but all the address inputs of this microcircuit are connected to the address bus, so the controller has access to the entire memory of the microcircuit. <br><br>  And now you should pay attention to the node on the logical elements DX1, DX2, DD4.  It is these chips that determine which memory chip is selected by the microcontroller.  It can be seen that they are controlled by the following signals: <br><br><ul><li>  WRn is the recording signal, the active level is low.  On this line, the microcontroller sets a low level when you need to write some data to external RAM memory. </li><li>  A15 is the same data bus line that is not connected directly to any of the memory chips. </li><li>  CSn0 is a dedicated chip select signal, the active level is low.  This line is connected to the address decoder built into the controller.  After reset the controller is at a low level. </li><li>  RAM2_CE - connected to the GPIO controller with a pull to the ground. </li></ul><br>  The logic of this node is well described by the table: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f49/171/c32/f49171c3210acdcfbac396e81b568a46.png" alt="image"><br><br>  As can be seen, depending on the state of the RAM2_CE line, the microcontroller will work either with Flash memory or with RAM2 (DD3) microcircuit, and their address spaces will coincide.  It is worth noting that the memory capacity of these microcircuits is the same.  Perhaps this is done to simplify the firmware update of the device.  There is another option - the installed RAM works 3 times faster than the Flash memory, so after the start the controller can copy the contents of FLASH to RAM2, after which the program is executed from it. <br><br>  But the high level on the A15 line clearly defines that the controller will work with a RAM (DD2) chip. <br><br>  The result is that FLASH and RAM1 memory alternate in the address space of the controller: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/130/d7a/ee6/130d7aee659a1839be0296586fe25024.png" alt="image"><br><br>  Red indicates the area of ‚Äã‚ÄãRAM that has already been encountered - when accessing it, the controller will in reality get access to data located at addresses (0x8000-0xFFFF). <br>  The compiler setting is not trivial, and, as I mentioned above, half of the Flash / RAM2 volume is lost.  Why the developers of the scanner did not switch between FLASH and RAM chips using the dedicated CSnX controller line is not clear. <br><br>  As I already mentioned, there is no flash memory in the controller used, which means there are no fuse bits.  In order to adjust some parameters of the controller: the data bus width and addresses, the PLL parameters use pull-down resistors connected to the data bus.  The controller itself has built-in pull-up resistors of high resistance (&gt; 100 kŒ©) connected to the entire bus.  Thus, due to the external resistors on the bus, a certain combination of signals is established, which the controller reads when turned on.  That it determines the desired settings of the controller. <br><br>  In this case, we are talking about resistors R3-R6.  The selected configuration of the resistors is consistent with the resulting bus signal connection circuit and provides the controller clock frequency of 33 MHz. <br><br>  The pulse signal from the mirror encoder is fed to the input of the microcontroller timer ‚ÄúT2IN‚Äù through the logical element OR D6.  The second input of this microcircuit is connected to the GPIO controller, which allows you to disable the supply of pulses to the timer input.  Why do you need such a solution, and why you can not programmatically turn off the timer - I did not understand. <br><br>  Now you should pay attention to the TDC chip (DD1). <br><br>  The scanner is equipped with a TDC-GPX chip - the most ‚Äúadvanced‚Äù of all that is in the assortment of the company ACAM.  The claimed measurement accuracy of time intervals is up to 10 ps RMS.  The chip has 8 input channels of LVTTL lines and 2 channels of LVECL (differential). <br>  In this scanner, in order to obtain the maximum time measurement accuracy, the LVECL inputs are used, to which signals from the laser module and the photodetector module are supplied using four coaxial cables.  The signals from the laser module are fed to the DStart / DStartN inputs, and start the counting time.  The signals from the photodetector module are fed to the inputs DStop1 / DStop1N, DStop2 / DStop2N, and stop the counting time.  As can be seen from the diagram, stop signals are fed directly to two TDC channels, and with inverse polarity.  Due to this, it is possible to measure not only the duration of the ‚Äúflight‚Äù of a light pulse, but also the width of the received pulse. <br><br>  TDC-GPX has a 28-bit data bus, but it can be switched to 16-bit mode, which is what is used in the scanner.  The address bus is 4-bit, it is also shifted by 1 bit, like with memory chips.  The microcircuits DD8, DD9, U2 are used to form the control signals of the microcircuit and the level matching - the microcontroller operates from 5V, and the TDC from 3.3V.  In general, the TDC power system is quite complex, there is even an automatic adjustment of the supply voltage.  Due to its complexity, I did not draw its scheme - I suspect that it is not much different from datasheet. <br><br>  About programming the microcontroller and TDC, I will discuss further. <br><br>  As I mentioned earlier, the board has a customized ASIC chip with the words "LEUZE98" and "WATCHDOG".  What it is like is unknown.  It is seen that a 20 MHz crystal oscillator is connected to this microcircuit.  After I was able to program the microcontroller, I was convinced that the ASIC does not interfere with its operation, and did not restore the ASIC connection scheme.  As far as I understand, this chip communicates with the controller via a parallel bus.  It is possible that it is the ASIC that forms the RESETn reset signal, which resets the controller and the TDC. <br><br>  However, with some chains had to deal more. <br><br>  As it turned out, the laser control signal ‚ÄúLASER_PULSE‚Äù can be formed by both a microcontroller and an ASIC - using a node on transistors T1, T2.  In this case, when turning on the ASIC opens the transistor T1, so that the controller is not able to control the laser.  Because of this, I had to remove the resistor R24 ‚Äã‚Äã- and the laser began to be controlled normally by the controller. <br><br>  The mirror motor control signal ‚Äúline_motor1‚Äù also came from the ASIC (via diode D2).  Because of this, I had to cut the track and on the board and connect this signal directly to the free GPIO output of the controller - P3.15. <br><br>  The strangest thing is that the ‚ÄúCS2‚Äù line connected to the DAC installed on the photodetector module board also turned out to be connected to the ASIC.  Because of this, the controller could not independently set the APD supply voltage, and turn on the APD amplifier.  Perhaps this is done to improve the reliability of the scanner - incorrectly adjusting the DAC can lead to failure of the APD.  I also had to connect this line to the free GPIO output of the P3.4 controller. <br><br>  It is precisely known that the three LEDs installed on the laser module are controlled by the ASIC.  Two more LEDs that display the status of the scanner (the presence of an obstacle in the working area) are controlled from the controller by the LN1, LN2 lines.  These lines also go to the interface module board. <br><br>  Since the scanner can work in security systems, the processor board has a large number of nodes for diagnosing its state.  The processor (and possibly the ASIC) can detect when the laser is turned on (using the U3 chip), monitor the level of several supply voltages, the APD supply voltage, the APD temperature, the comparator threshold on the photodetector board. <br><br>  Due to the fact that the reference voltage of the ADC of the controller is 4.1V, part of the measured voltages is reduced with the help of resistor dividers - they can be seen in the diagram on the right. <br><br>  And now it is worthwhile to examine in greater detail the method of generating <i>an unusual</i> ‚Äúdigi‚Äù signal, which I mentioned earlier when describing a photodetector module. <br><br>  The diagram below shows the nodes simultaneously processor module (bottom) and the photodetector module (top): <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/44d/9b6/e35/44d9b6e356033cbfe9f892c5b9838622.png" alt="image"></a> <br><br>  The arrows show the connection of the modules with the help of wires.  Below I will describe the work of these nodes, as I understood it.  In the photodetector module, the signal from the APD output is amplified by a DA4 chip, and then goes to the D1 comparator.  If the signal level at the comparator input is greater than 50 mV, then the high level is set at the comparator output.  The signal from the comparator output is transmitted to the processor module.  First of all, it enters the TDC input, which counts the time from the start of the laser pulse.  But in addition, this signal is fed to the clocking input of the D-flip-flop DD1.  A logical unit is always supplied to the signal input of the trigger, and the trigger itself can be reset to the zero state using the GPIO line of the BASE5 controller.  Thus, the triggering of the comparator triggers the trigger ‚Äú1‚Äù.  This trigger has a differential output, the signal from which is fed to the input of the D3 chip, which converts it to the LVTTL format.  This signal is fed to the input ¬´digi¬ª of the photodetector module.  As I mentioned earlier, in my opinion, the appearance of this signal leads to a weakening of the signal level at the input of the comparator. <br><br>  The main question is why is it necessary and why is it so difficult to implement?  Why it was impossible to make both nodes on the photodetector module board? <br><br>  I can only express my assumptions.  The signal may need to be attenuated in order to avoid the comparator or amplitude detector switching to saturation mode.  Perhaps - to reduce the length of the received pulse.  For both nodes simply could not find space on the photodetector board.  Another option is possible - the signal needs to be attenuated only after it has time to reach the TDC via coaxial wires, which justifies such a complex structure. <br>  The study showed that before starting a new laser pulse, it is necessary to reset the trigger, otherwise the pulses are not accepted. <br><br>  <b>Interface Module</b> <br>  Unfortunately, I did not have a good photo of this module.  There is only this: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/394/165/79a/39416579aee7e4e226a1dbc9225386f0.jpg" alt="image"><br><br>  It is on this module that the only two connectors are installed to which you can connect outside the scanner.  One of them is RS-232 / RS-422, the second is powered by the scanner, control signals are sent, and the safety circuit is connected here. <br><br>  This module contains UART-RS232 / RS485 converters and optocouplers of optocouplers (they are installed on a separate small board shown on the right), safety circuit power switches, input circuits of the control lines for the rangefinder modes, an engine control circuit, an encoder signal converter. <br><br>  This module connects the power module and the processor module, as well as the encoder module and the motor of the mirror (using the connectors on the bottom of the module, they are not visible in the photo). <br><br>  Partial diagram of the interface module: <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/6cb/b3b/711/6cbb3b71160b4d70462c898dac6263a5.png" alt="image"></a> <br><br>  I recovered only a part of the scheme of this module (about 20%), since I was not interested in the keys and input lines needed for security.  And there are quite a lot of them, the documentation mentions current limiting along the safety circuit, short-circuit control, and other functionality. <br><br>  Somewhat strangely done control the speed of rotation of the motor of the mirror.  Speed ‚Äã‚Äãadjustment is implemented by changing the voltage of the motor power - with this all is clear.  But the very adjustment of this voltage goes with the help of some kind of integrating chain on the operational amplifier.  In order to increase the voltage, the controller sets 0 on the line ‚Äúline_mot1‚Äù to lower it - 1. Obviously, without constant feedback from the encoder through the controller, the motor either stops or accelerates to maximum speed. <br><br>  As it turned out, the UART-RS232 LTC1387 IC converter is rather slow - at a speed of 500 kbit / s, the data was distorted.  Because of this, I had to remove a small board with this microcircuit, and connect the USB-UART converter directly to the interface module board. <br><br>  <b>Now, when I talked about the device of all modules, it is worthwhile to tell in more detail about the process of reverse engineering itself.</b> <br><br>  When I started to deal with the scanner electronics, most of all I was afraid that the impact could damage the laser or the photodetector.  At the same time, I was not sure that I would be able to launch the processor module - they were confused by an unfamiliar microcontroller and ASIC.  Therefore, the first thing I did was restore the circuit of the laser module and then the photodetector module.  After I was able to figure out the circuitry of these modules and determine the purpose of all the contacts on their connectors, it was possible to proceed to the processor module.  In the extreme case, if I could not start it, I had the idea to make an analog of this module on STM32 + TDC-GP2 microcircuits. <br><br>  Obviously, to check the module, you need to run your own program on the Infineon SAK-C167CR microcontroller installed on it.  Again, it is worth remembering that this controller does not have built-in flash memory.  Moreover, as it turned out, the controller does not have any specialized debugging interfaces (including JTAG).  With a high degree of probability, the firmware is recorded in an external Flash in the programmer in production.  However, as it turned out, everything is not so bad - the controller has a bootloader (‚ÄúBootstrap Loader‚Äù), working on the UART.  This bootloader is stored in the built-in Boot-ROM controller, so it definitely had to be in my controller.  And it works in a rather peculiar way - to activate it at startup, you need to set the P0L.4 data bus line to a low level, after which the controller begins to wait for the 0x00 byte from the host to appear.  Having received this byte, the loader automatically determines the transfer rate, and begins to wait for 32 bytes of data, which are copied into the controller's built-in RAM.  After the data is received, the controller starts the execution of the received program (16 words of the controller). <br><br>  In fact, one more boot loader (‚Äúpreloader‚Äù) needs to be pushed into these 32 bytes, which the main loader ‚ÄúExternal loader‚Äù will receive from the host and will start its execution. <br><br>  Then I was lucky - for this processor there is already a ready program FLASHit, which is able to do all the mentioned operations automatically.  The loader built into it has quite a lot of functionality - with its help you can automatically determine the model of the installed Flash memory, edit and watch the contents of the controller registers, you can see the status of the ADC channels. <br><br>  I did not manage to find on the board any test pads connected to the P0L.4 line of the controller, so in order to run the bootloader, I had to solder a special pin to this line.  I stuck the pin itself to the case of one of the RAM microcircuits.  To run the loader, you need to connect this pin through an 8 kŒ© resistor to ground. <br><br>  After I connected the board to the computer, and energized the processor module, the microcontroller actually showed up in FLASHit.  After that, I wrote a small program in Keil that switches one of the controller's outputs, and wrote it in Flash.  The program worked fine, ASIC did not interfere in any way (I was afraid of the work of some watchdog mechanism built into it, or conflicts on the tires), so that it was possible to move on. <br>  After that, I restored the processor module circuit, which allowed to check the operation of all the modules in the collection. <br><br>  First, I checked the operation of the laser module - as I wrote earlier, to launch a laser pulse, it was necessary to send only one signal to this module.  The laser has earned - its flashes could be seen with the help of a mobile phone camera.  Also, using an oscilloscope, I checked that the module normally generates starting (reference) pulses. <br><br>  Next was the verification of the photodetector module.  Then I had to check the operation of the DAC, the voltage shaping unit of the avalanche photodiode and the power control unit of the photodetector amplifier.  They all earned, allowing you to check the work of the most rangefinder.  To do this, I assembled its modules in the form as it was intended by the developers: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/462/307/8fe/4623078fe14cf75b455d285680f2ece8.jpg" alt="image"><br><br>  In the photo, all five main modules are assembled together around the optical system.  Here, instead of a native rotating mirror, I installed an ordinary mirror. <br><br>  After that, I filed wrote a laser control program for UART, set up the operation of the photodiode.  As a result, when I started the laser at the input of the comparator, I was really able to detect pulses with an oscilloscope, the amplitude of which obviously depended on the type of obstacle in front of the mirror!  The comparator also worked fine.  There remained the last important part of testing - testing TDC. <br><br>  The TDC-GPX chip installed in the scanner has a rather complicated construction and can operate in a large number of modes. <br><br>  The figure below shows its structural diagram: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/ab4/c21/6f6/ab4c216f68fe6e7785f763fd7619dc67.png" alt="image"><br><br>  As you can see, the chip contains 8 separate channels, that is, it can receive up to 8 stop signals.  If the channels are differential, then only two stop signals plus one start signal can be analyzed.  In this case, the chip allows you to combine the measuring channels, thereby increasing the accuracy of measuring time intervals: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/a22/968/689/a22968689e8450060a016c0db84b9bad.png" alt="image"><br><br>  Honestly, I did not like the documentation for this microcircuit.  Many things in it are described rather superficially, code examples are incomprehensible.  The part of the datasheet dedicated to setting the time resolution is full of some kind of "magic numbers."  There is also no normal ‚ÄúApplication Note‚Äù on the microcircuit.  In addition, in the scanner itself I was unable to detect the connections of the ‚ÄúEF1 / EF1‚Äù lines with the controller.  As it is on these lines, one can determine that the microcircuit has finished measuring time.  Because of all this, launching the TDC took me quite a lot of time, but as a result, everything worked as it should - when the laser was started, the TDC worked, and the results of the TDC operation clearly depended on the distance to the obstacle.  Thus, the pulse laser rangefinder earned.  It remains to turn the entire structure into a workable laser scanner. <br><br>  The first step I needed was to make the adjustment - the assembled rangefinder stopped ‚Äúseeing‚Äù the obstacles after a few meters.  The optical system looked intact, but I had to remove the boards from the optical system, so the reflected light was not focused by the lens on the photodetector. <br><br>  Before adjustment, I wrote a program for the controller, which not only determined the distances, but also measured using the ADC the signal amplitude generated by the peak detector. <br><br>  The whole process of adjustment was reduced to smooth movements of the photodetector and laser boards, and the search for such a position at which the signal amplitude is maximum.  As a result of the adjustment, the amplitude of the received signal was significantly improved. <br><br>  Further, attention should be paid to a certain data processing feature inherent in pulse rangefinders. <br><br>  The signal generated by the photodetector has an analog form.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To convert it to digital form, which is further processed by the TDC, a comparator is used, which is configured to switch if the input signal exceeds a certain set threshold. As a result, due to the complex shape of the input signal, when changing the amplitude of the signal, an error occurs when determining the time intervals:</font></font><br><br><img src="https://img-fotki.yandex.ru/get/198361/14557097.6/0_10da03_2cd9184c_orig.bmp" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the graph, a signal with a smaller amplitude will be detected with a delay. To solve this problem, there are several methods, both hardware and software. I decided to use the simplest option - correction of measurement results depending on the amplitude of the signal. At the same time, I had to collect statistics on the change in the measurement results of time from the signal amplitude change. In order to change the amplitude of the signal without changing the rest of its parameters, I used paper lining on the lens, which reduced the luminous flux falling on the photodiode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result was the following dependence: </font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/0db/eee/642/0dbeee642afc3de178445fe45d3e2044.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the basis of this dependence, I formed a table of corrections, the data from which are used by the controller program when determining the distance to the object.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next stage is the start of the engine mirror and encoder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have already quoted a photograph of a mirror: </font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/16d/5db/5c6/16d5db5c60f0e710e0485fab2236e510.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mirror motor is brushless, very similar to those used in cooler fans. Three wires go out of it - 2 of them are powered, another one is a pulse signal of speed. All these wires are connected to the interface module, while the speed signal generated by the engine is not used - control is based on data from the encoder. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the photo, a transparent disk with labels for the encoder is attached to the motor axis. You may notice that the disk has a zero mark.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The encoder was installed on a small board and completely covered by a metal screen, so its marking could not be determined. However, based on its size and pinout, I decided that it was a HEDS-9040 quadrature encoder: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e13/b8a/134/e13b8a134252c787ef4fee9ae23161ae.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Four wires went from the encoder board to the interface module, but as it turned out, only three of them were used - two power supplies and a signal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I understand it, the Schmitt triggers and some logic combining data from channels A, B, and index (zero mark signal) were installed on the board. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how the signal from the encoder board and the index signal taken directly from the encoder look like.</font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/fef/43c/dd1/fef43cdd10c0302e460b266ba4a5124b.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, during the index signal, encoder pulses are suppressed. As it turned out, the encoder board generated 500 pulses per revolution, but the timer of the T2 controller, to which the encoder line is connected, can be triggered simultaneously on both fronts of the pulses, which gives 1000 interrupts per mirror revolution. This value corresponds to the declared angular resolution of the scanner at 0.36 degrees. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I set up the T2 timer in the ‚ÄúCapture mode‚Äù mode, which allows me to measure the time between interrupts from the encoder. The resulting time is used to detect the "zero" position of the mirror, and stabilize the speed of rotation of the motor. At the same time, the number of interruptions is counted, which makes it possible to determine the position of the mirror.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the encoder started working and I managed to start the engine speed control, I could fully assemble the scanner. Due to the complex shape of the boards and the optics, the design turned out to be rather arrogant: </font><font style="vertical-align: inherit;">It was not easy to assemble such a design - the accuracy of the location of the individual parts is very important for the scanner. If the axis of the mirror would not coincide with the optical axis of the rangefinder part, this could lead to the fact that the scanning plane would turn out to be strongly curved or inclined.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/16f/05e/cdd/16f05ecddefcb0016348678d7f587d8b.jpg" alt="image"></a> <br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/2e6/71b/812/2e671b81234a099cbbe91cd55f9060c7.jpg" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When measuring the exact distance to objects, it is important to have a certain ‚Äúreference‚Äù object, the distance to which is precisely known. Knowing the "flight time" to him, you can accurately determine the time corresponding to the zero distance. Due to the change in temperature of the scanner components, this time may vary, so this time must be monitored continuously. To solve this problem, I installed a special blackened plate in the scanner: </font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/fcd/d14/a3b/fcdd14a3bbc74d42b8e75a734530e66d.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The plate is blackened so that the light reflected from it does not ‚Äúblinded‚Äù the photodetector. Judging by the instructions, dark and light reflecting elements were also installed in the original design of the scanner. They were used to control the operation of the distance measuring part of the scanner, and most likely, they were also used for calibration.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the photo above, the encoder mounted on the board is also clearly visible. As it turned out, the encoder must be very accurately set relative to the disk, and there were many problems with this - even a small offset of the encoder led to the loss of pulses, especially index ones. It is possible that the scanner stopped working after hitting the body because of problems with the encoder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, managed to get a scan speed of up to 20 revolutions per second. With an APD supply voltage of 135 V, distances up to 10‚Äì15 m normally go. At a voltage of 145 V and with additional filtering of the signal, distances can be measured up to 30 m (although I am not sure that it is safe for a photodetector).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that the maximum transmission speed in the original scanner is 115200 bit / s, which allows you to transfer all data only at a speed of about 11 revolutions per second. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned, in my firmware I transmit data at a speed of 500 kbit / s, which allows us to significantly increase the number of scans transmitted per second. It is because of the UART speed limit that I did not increase the scan speed to the original 25 revolutions per second. I note that in the original design of the scanner, the data is processed in the scanner itself, so that the low data transfer rate does not really affect anything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the scanner is now working without a case, it was possible to increase the scanning area to 208 degrees against 190 in the original design. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualization of data received from the scanner:</font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/ac1/8ae/f90/ac18aef90d3f6f6b083e373c0c80e144.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, the scanner should perform some useful function, so I decided to test its operation in ROS in SLAM, and compare the results with the results of a </font></font><a href="https://geektimes.ru/post/275442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">homemade laser scanner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For this, I installed it on Roomba, on which a homemade scanner was previously installed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View of the Leuze scanner installed on Roomba (the mirror rotates so that it came out blurry): </font><font style="vertical-align: inherit;">As a result of hector_slam, we managed to get such an apartment map (the walls are yellow): </font><font style="vertical-align: inherit;">Since the vacuum cleaner travels at the floor level, it ‚Äúsees‚Äù mostly furniture. </font><font style="vertical-align: inherit;">But such a card is obtained if the vacuum cleaner is simply carried in the hands at the belt level: </font><font style="vertical-align: inherit;">In this case, the apartment walls are ‚Äúseen‚Äù more often.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/dc1/c58/f5a/dc1c58f5a2ecf6eba47a9f880d3aefbc.jpg" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/4fd/a8e/83d/4fda8e83dee18c10bfbd178f39a8b8e6.png" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/4f4/3d8/ec3/4f43d8ec31a8f1a0a546f9d85c76cee7.png" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you compare the quality of the cards, you can see that the homemade scanner has more ‚Äúnoisy‚Äù lines. This is due to the fact that the homemade scanner that uses the triangulation principle of operation, with increasing distance greatly decreases the accuracy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, despite the very good quality of scanning, this scanner is poorly suited for an autonomous robot - it has too large dimensions and power consumption (about 7.2 W).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where else can you apply such a scanner? Earlier, when discussing a homemade scanner, I was often asked about the possibility of making a 3D scanner, and it‚Äôs time to make it! There is a rather high scanning speed. Of course, by resolution such a scanner cannot be compared with scanners that use the triangulation principle of distance measurement (with a laser line or a projector (SLS)), but they can scan large spaces - rooms, street sections. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to remake a 2D scanner in 3D, you need to ensure that it can rotate along one more axis. I decided to make my scanner using the same beam sweep principle as in the scanner of </font></font><a href="https://geektimes.ru/company/neuronspace/blog/260372/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles. For this purpose, I placed the Leuze scanner ‚Äúlying down‚Äù, so that its scanning plane is perpendicular to the floor. Next, it was necessary to implement a smooth slow rotation of the entire scanner around the axis. The main difficulty - the scanner must rotate without beats and distortions, which will lead to the distortion of scans. As it turned out, at home it is difficult to make a bearing unit capable of providing such an exact rotation. Therefore, I decided to use the head of a VHS tape recorder as a bearing unit - it contains two bearings, is made with very high accuracy and is able to withstand the weight of the scanner. The resulting design is driven by a stepper motor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The assembled 3D scanner looks like this: </font><font style="vertical-align: inherit;">Type of scanner mounted on a tripod:</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/60d/967/07c/60d96707cb26b50daca5c06bcbee64e5.jpg" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/167/77d/118/16777d118478b27a1b5ae56d449304d3.jpg" alt="image"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the left there is a 12 V battery, which is also a counterweight. Since the Leuze scanner requires 24 V to work, I had to install on the scanner a step-up DC / DC converter assembled on the basis of the XL6009 chip. Stepper motor scanner is controlled by the module on the A4988 and Arduino, which provides rotation at a given speed. Both the Leuze scanner (via the USB-UART adapter) and the Arduino are connected via a USB hub with a wire to a computer that captures data. In the current view, the rotation of the scanner mirror and the rotation of the entire scanner are not synchronized - the scanner rotation speed is chosen such that when it is rotated by 0.36 degrees, the mirror has time to make at least three turns. Since there is no synchronization in speed, I had to transmit the positional sync information from the Arduino to the Leuze scanner.It is implemented quite simply - when turning the scanner for every 0.36 degrees, the Arduino changes the signal level at one of the conclusions. This signal is transmitted to the scanner processor module (to the unused connector of the protective glass status sensor). Information about the state of this signal is transmitted at the beginning of each scanner parcel - in this way, a self-written PC program controlling the scanner receives information about the movement of the scanner and determines the angle to which it is rotated.obtains information about the movement of the scanner and determines the angle to which it is rotated.obtains information about the movement of the scanner and determines the angle to which it is rotated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A single 3D scan formed by the scanner contains about 350'000 points. </font><font style="vertical-align: inherit;">Of course, this is significantly less than that of professional scanners, but still pretty good, especially if you glue together a few scans together. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example - single scan of a room: </font><font style="vertical-align: inherit;">Example - scan of a room glued together from several: </font><font style="vertical-align: inherit;">Scanned part of the entrance: </font><font style="vertical-align: inherit;">Video, which shows the results of the resulting scanner:</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/152/e40/f46/152e40f4695ab5321aa7de9f0bf00f45.png" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/37c/376/a36/37c376a366c09c7b5c94cca47992d5f1.png" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/geektimes/post_images/592/ebd/33d/592ebd33da93487d27e38a2ca030025e.png" alt="image"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3SnqrfDCc70" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://github.com/iliasam/Leuze_RS4_reverse_engineering"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code of the controller program on Github</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/396357/">https://habr.com/ru/post/396357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../396343/index.html">Do stars explode in the end?</a></li>
<li><a href="../396345/index.html">Corporate printing: much more problems than it seems</a></li>
<li><a href="../396347/index.html">Air conditioning control via Wi-Fi</a></li>
<li><a href="../396349/index.html">"A friend of my friend said ...". Expose the gossip and myths about SSD</a></li>
<li><a href="../396353/index.html">Touch Button Illuminated from China for DIY crafts</a></li>
<li><a href="../396359/index.html">SoftBank buys ARM Holdings for 24 billion pounds</a></li>
<li><a href="../396361/index.html">The owner of the Tesla Model S claims that the autopilot of his electric car saved a pedestrian from death</a></li>
<li><a href="../396363/index.html">Windows 10 is exactly one year old</a></li>
<li><a href="../396365/index.html">HyperX Alloy FPS - Reliability Above All</a></li>
<li><a href="../396367/index.html">Telegram authorization SMS codes continue to intercept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>