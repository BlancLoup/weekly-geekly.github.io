<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development for embedded systems based on Quantum Leaps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quantum Leaps or QP is an open source framework for embedded systems development. QP can work with the main OS (Linux, Windows, FreeRTOS, etc.) or wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development for embedded systems based on Quantum Leaps</h1><div class="post__text post__text-html js-mediator-article">  Quantum Leaps or QP is an open source framework for embedded systems development.  QP can work with the main OS (Linux, Windows, FreeRTOS, etc.) or without it.  QP is ported to a huge number of different <a href="http://www.state-machine.com/downloads/index.php">processor families</a> . <br>  A QP application is designed as several state machines based on UML statecharts (Statecharts). <br>  The following is an example of designing a very simple finite state machine based application. <br><a name="habracut"></a><br><br>  <b>1. Get the framework</b> <br>  To start, go to the project site and download the <a href="http://www.state-machine.com/downloads/index.php">source library</a> .  Next, download the <a href="http://www.state-machine.com/win32/index.php">SDK</a> with examples for Win32.  The example shows the solution of the <a href="http://alice.pnzgu.ru/~dvn/prolog/articls/9.htm">dining philosophers</a> problem in the console, on the Win32 API and MFC.  The document folder also contains a complete description of the console application design process. <br>  An example is quite complicated, therefore, to start with something very simple, I decided to invent and solve my own problem. <br><br>  <b>2. Statement of the problem</b> <br>  Loader Bob works on a conveyor belt that delivers boxes to the warehouse.  If there is a box on the conveyor, that Bob takes it and puts it in a pile.  If there is no box, then Bob is standing and waiting.  When a box appears on the conveyor, the bell rings to catch Bob‚Äôs attention.  When the bob picks up the box, he presses a button and shows that the next box can be passed through the pipeline. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>3. State diagram</b> <br>  We describe the problem in the form of a state diagram.  There are two automata (active objects) in the task. <br><br><img src="https://habrastorage.org/storage/habraeffect/f9/c7/f9c7db0d3585ba296675c6a16cd26f11.png" alt="image"><br><br>  The first BOB machine starts its life in the FREE state (the loader is not busy with work and is ready to take the box).  BOB periodically generates a timeout_sig signal.  At the same time, it must transmit a Timeout signal to the CONVEYOR machine.  CONVEYOR when receiving a signal Timeout should go to the FULL state (a box appeared on the conveyor) and send a BOB notification as a Ready signal.  BOB receiving the signal Ready should go to the WORK state (took the box) and send the Get signal back.  Upon receiving Get, the CONVEYOR object enters the EMPTY state.  BOB returns to the FREE state when generating Timeout_sig. <br><br>  <b>4. Application development</b> <br>  The main task of a QP developer is to write the classes of active objects according to the state diagram.  Objects must process received signals and send the necessary signals under certain conditions. <br><br>  <b>Project Content</b> <br>  A QP project is usually divided into the following parts: <br>  1) Global variables and constants - qpbob.h <br>  2) Hardware-dependent code - bsp.h, bsp.cpp <br>  3) Active objects - bob.cpp, conveyor.cpp <br>  4) Entry point - main.cpp <br><br>  <b>Determine the signals</b> <br>  According to the state diagram, we determine the signals that are in the system and determine their type of enumeration in the file qpbob.h. <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#ifndef qpbob_h <br> <font color="#0000ff">#define</font> qpbob_h <br> <font color="#008000">//(1) </font> <br> <font color="#0000ff">enum</font> DPPSignals { <br> READY = Q_USER_SIG, <br> GET, <br> TIMEOUT, <br> TERMINATE_SIG, <br> MAX_PUB_SIG, <br> MAX_SIG <br> }; <br> <br> <font color="#008000">//(2)     </font> <br> <font color="#0000ff">extern</font> QActive * <font color="#0000ff">const</font> AO_BOB; <br> <font color="#0000ff">extern</font> QActive * <font color="#0000ff">const</font> AO_CONVEYOR; <br> <br> <font color="#0000ff">#endif</font> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Explanations: <br>  1) The first user signal must start with the constant Q_USER_SIG.  The enumeration contains a number of service signals: TERMINATE_SIG - an application termination signal; upon receipt, active objects must correctly stop their work;  MAX_PUB_SIG - the signals declared after this can be transmitted only directly from the object to the object, and the remaining signals are available to all objects of the system;  MAX_SIG - the maximum signal number in the system.  There is no TIMEOUT_SIG signal as it is used only inside the active Bob object. <br>  2) Global pointers to active system objects.  Initialized when creating objects. <br><br>  <b>We write a hardware-dependent code</b> <br>  QP can be used with a large number of hardware platforms.  The description of active objects and their interaction does not depend on a specific platform.  The code that depends on the hardware is better to write separately from the active objects.  In our example, active objects use functions opened in bsp.h <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#ifndef bsp_h <br> <font color="#0000ff">#define</font> bsp_h <br> <font color="#008000">//(1)    </font> <br> <font color="#0000ff">#define</font> BSP_TICKS_PER_SEC  1 <br> <font color="#008000">//(2)      </font> <br> <font color="#0000ff">void</font> BSP_init( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> *argv[]); <br> <font color="#0000ff">void</font> BSP_print( <font color="#0000ff">char</font> <font color="#0000ff">const</font> *str); <br> <font color="#0000ff">#endif</font> <font color="#008000">// bsp_h</font> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Explanations: <br>  1) Set the frequency of the internal timer of the system. <br>  2) The BSP_init function initializes the hardware.  The BSP_print function displays the text in the console by stamping a time stamp in the form of the number of tenths of a second. <br>  The implementation of the functions is in the bsp.cpp file. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#include <font color="#A31515">"qp_port.h"</font> <br> #include <font color="#A31515">"qpbob.h"</font> <br> #include <font color="#A31515">"bsp.h"</font> <br> <br> #include &lt;conio.h&gt; <br> #include &lt;stdlib.h&gt; <br> #include &lt;stdio.h&gt; <br> #include &lt;time.h&gt; <br> <br> Q_DEFINE_THIS_FILE <br> <br> <font color="#008000">//(1) </font> <br> unsigned <font color="#0000ff">int</font> TimeCounter; <br> <font color="#008000">//(2)   </font> <br> <font color="#0000ff">void</font> BSP_timeStamp() <br> { <br> printf( <font color="#A31515">"%d - "</font> ,TimeCounter); <br> } <br> <br> <font color="#008000">//(3)   idle-</font> <br> <font color="#0000ff">static</font> uint8_t l_running; <br> <font color="#008000">//(4)   idle-</font> <br> <font color="#0000ff">static</font> DWORD WINAPI idleThread(LPVOID par) { <br> TimeCounter=0; <br> ( <font color="#0000ff">void</font> )par; <br> l_running = (uint8_t)1; <br> <font color="#0000ff">while</font> (l_running) { <br> Sleep(100); <br> TimeCounter++; <br> <font color="#008000">//(5)  Esc     </font> <br> <font color="#0000ff">if</font> (_kbhit()) { <br> <font color="#0000ff">if</font> (_getch() == <font color="#A31515">'\33'</font> ) { <br> QF::publish(Q_NEW(QEvent, TERMINATE_SIG)); <br> BSP_print( <font color="#A31515">"Esc exit"</font> ); <br> } <br> } <br> <br> } <br> <font color="#0000ff">return</font> 0; <br> } <br> <font color="#008000">//(6)  </font> <br> <font color="#0000ff">void</font> BSP_init( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> *argv[]) { <br> HANDLE hIdle; <br> <font color="#008000">//(7)   </font> <br> QF_setTickRate(BSP_TICKS_PER_SEC); <br> <font color="#008000">//(8)  idle </font> <br> hIdle = CreateThread(NULL, 1024, &amp;idleThread, ( <font color="#0000ff">void</font> *)0, 0, NULL); <br> Q_ASSERT(hIdle != (HANDLE)0); <br> SetThreadPriority(hIdle, THREAD_PRIORITY_IDLE); <br> <br> printf( <font color="#A31515">"QP example"</font> <br> <font color="#A31515">"\nQEP %s\nQF %s\n"</font> <br> <font color="#A31515">"Press ESC to quit...\n"</font> , <br> QEP::getVersion(), <br> QF::getVersion()); <br> } <br> <font color="#008000">//............................................................................</font> <br> <font color="#0000ff">void</font> QF::onStartup( <font color="#0000ff">void</font> ) { <br> } <br> <font color="#008000">//(9)..........................................................................</font> <br> <font color="#0000ff">void</font> QF::onCleanup( <font color="#0000ff">void</font> ) { <br> l_running = (uint8_t)0; <br> } <br> <br> <font color="#008000">//............................................................................</font> <br> <font color="#0000ff">void</font> BSP_print( <font color="#0000ff">char</font> <font color="#0000ff">const</font> *str) <br> { <br> BSP_timeStamp(); <br> printf( <font color="#A31515">"%s\n"</font> , str); <br> } <br> <font color="#008000">//(10)</font> <br> <font color="#0000ff">void</font> Q_onAssert( <font color="#0000ff">char</font> <font color="#0000ff">const</font> Q_ROM * <font color="#0000ff">const</font> Q_ROM_VAR file, <font color="#0000ff">int</font> line) { <br> fprintf(stderr, <font color="#A31515">"Assertion failed in %s, line %d"</font> , file, line); <br> exit(0); <br> } <br> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Explanations: <br>  1) Variable for counting the running time from system startup. <br>  2) Displays the time counter value. <br>  3) While the value of the variable is not 0, the idle thread is running. <br>  4) The idle-stream is launched in the system to monitor the keyboard. <br>  5) When you press Esc, a message is sent to the system to complete the work TERMINATE_SIG. <br>  6) The function initializes the application. <br>  7) The frequency of the system timer. <br>  8) Run idle stream. <br>  9) After the system stops, the idle stream closes. <br>  10) The implementation of the function to display debug information. <br><br>  <b>System startup</b> <br>  The system runs in the main function of the main.cpp file.  You need to create all the necessary objects and transfer control to active objects. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#include <font color="#A31515">"qp_port.h"</font> <br> #include <font color="#A31515">"qpbob.h"</font> <br> #include <font color="#A31515">"bsp.h"</font> <br> <br> <font color="#008000">//(1)  </font> <br> <font color="#0000ff">static</font> QEvent <font color="#0000ff">const</font> *l_bobQueueSto[10]; <br> <font color="#0000ff">static</font> QEvent <font color="#0000ff">const</font> *l_conQueueSto[10]; <br> <font color="#008000">//(2)    </font> <br> <font color="#0000ff">static</font> QSubscrList  l_subscrSto[MAX_PUB_SIG]; <br> <font color="#008000">//(3)  ,   </font> <br> <font color="#0000ff">static</font> union SmallEvents { <br> <font color="#0000ff">void</font> *min_size; <br> <br> } l_smlPoolSto[10]; <br> <br> <font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> *argv[]) { <br> <br> <font color="#008000">//(4)  BSP</font> <br> BSP_init(argc, argv); <br> <br> <font color="#008000">//(5)  </font> <br> QF::init(); <br> <br> <font color="#008000">//(6) </font> <br> QS_FILTER_ON(QS_ALL_RECORDS); <br> QS_FILTER_OFF(QS_QF_INT_LOCK); <br> QS_FILTER_OFF(QS_QF_INT_UNLOCK); <br> QS_FILTER_OFF(QS_QF_ISR_ENTRY); <br> QS_FILTER_OFF(QS_QF_ISR_EXIT); <br> QS_FILTER_OFF(QS_QF_TICK); <br> QS_FILTER_OFF(QS_QK_SCHEDULE); <br> <br> <font color="#008000">//(7)   </font> <br> QS_OBJ_DICTIONARY(l_smlPoolSto); <br> <br> <font color="#008000">//(8)   </font> <br> QF::psInit(l_subscrSto, Q_DIM(l_subscrSto)); <br> <br> <font color="#008000">//(9)   </font> <br> QF::poolInit(l_smlPoolSto, <font color="#0000ff">sizeof</font> (l_smlPoolSto), <font color="#0000ff">sizeof</font> (l_smlPoolSto[0])); <br> <br> <font color="#008000">//(10)   </font> <br> AO_CONVEYOR-&gt;start(2, <br> l_conQueueSto, Q_DIM(l_conQueueSto), <br> ( <font color="#0000ff">void</font> *)0, 1024, (QEvent *)0); <br> AO_BOB-&gt;start(3, <br> l_bobQueueSto, Q_DIM(l_bobQueueSto), <br> ( <font color="#0000ff">void</font> *)0, 1024, (QEvent *)0); <br> <br> <br> <font color="#008000">//(11) </font> <br> QF::run(); <br> <br> <font color="#0000ff">return</font> 0; <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Explanations: <br>  1) Each active object needs an array for storing signals. <br>  2) You need an array to store subscriptions of objects to signals.  If an object wants to receive a public signal, it must be subscribed to it. <br>  3) Signals with additional data need a special pool (not used here). <br>  4) Initialize the hardware. <br>  5) Initialize the system. <br>  6) System configuration. <br>  7) Register the event pool. <br>  8) Initialize the list of subscribers. <br>  9) Initialize the event pool. <br>  10) We start active objects. <br>  11) Start the system.  Now the active objects interact with each other and the application is running. <br><br>  <b>Active Objects</b> <br>  Active objects of the system are written on the basis of a state diagram.  Consider in detail the implementation of the Bob object file bob.cpp.  Active objects are inherited from the QActive class. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#include <font color="#A31515">"qp_port.h"</font> <br> #include <font color="#A31515">"qpbob.h"</font> <br> #include <font color="#A31515">"bsp.h"</font> <br> <br> Q_DEFINE_THIS_FILE <br> <br> <font color="#0000ff">class</font> Bob : <font color="#0000ff">public</font> QActive { <br> <br> <font color="#0000ff">private</font> : <br> <font color="#008000">//(1)   </font> <br> QTimeEvt m_timeEvt; <br> <font color="#0000ff">public</font> : <br> Bob(); <br> <br> <font color="#0000ff">private</font> : <br> <font color="#008000">//(2) </font> <br> <font color="#008000">//       </font> <br> <font color="#0000ff">static</font> QState initial(Bob *me, QEvent <font color="#0000ff">const</font> *e); <br> <font color="#0000ff">static</font> QState free(Bob *me, QEvent <font color="#0000ff">const</font> *e); <br> <font color="#0000ff">static</font> QState work(Bob *me, QEvent <font color="#0000ff">const</font> *e); <br> }; <br> <br> <font color="#0000ff">static</font> Bob l_Bob; <br> <br> <font color="#0000ff">#define</font> TIMEOUT_TIME 1 <br> <br> <font color="#008000">//(3)      </font> <br> <font color="#0000ff">enum</font> InternalSignals { <br> TIMEOUT_SIG = MAX_SIG <br> }; <br> <br> QActive * <font color="#0000ff">const</font> AO_BOB = &amp;l_Bob; <br> <br> <font color="#008000">//............................................................................</font> <br> Bob::Bob() : QActive((QStateHandler)&amp;Bob::initial), <br> m_timeEvt(TIMEOUT_SIG){ <font color="#008000">//(4)      </font> <br> <br> <br> <br> } <br> <font color="#008000">//............................................................................</font> <br> QState Bob::initial(Bob *me, QEvent <font color="#0000ff">const</font> *) { <br> <br> BSP_print( <font color="#A31515">"Bob initial"</font> ); <br> <font color="#008000">// </font> <br> QS_OBJ_DICTIONARY(&amp;l_Bob); <br> QS_OBJ_DICTIONARY(&amp;l_Bob.m_timeEvt); <br> <font color="#008000">// </font> <br> QS_FUN_DICTIONARY(&amp;QHsm::top); <br> QS_FUN_DICTIONARY(&amp;Bob::initial); <br> QS_FUN_DICTIONARY(&amp;Bob::free); <br> QS_FUN_DICTIONARY(&amp;Bob::work); <br> <font color="#008000">// </font> <br> <br> QS_SIG_DICTIONARY(READY,  me); <br> QS_SIG_DICTIONARY(TIMEOUT_SIG, me); <br> <font color="#008000">//(5)  </font> <br> <br> me-&gt;subscribe(READY); <br> me-&gt;subscribe(TERMINATE_SIG); <br> <br> <font color="#008000">//(6)      </font> <br> me-&gt;m_timeEvt.postIn(me, TIMEOUT_TIME); <br> <br> <font color="#008000">//(7)     </font> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Bob::free); <br> } <br> <font color="#008000">//............................................................................</font> <br> QState Bob::free(Bob *me, QEvent <font color="#0000ff">const</font> *e) { <br> <br> BSP_print( <font color="#A31515">"Bob free"</font> ); <br> <font color="#008000">//(8)  </font> <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#008000">//(9)    </font> <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#008000">//(10)  </font> <br> <br> <font color="#0000ff">case</font> READY: <br> { <br> BSP_print( <font color="#A31515">"O my box READY. Going work"</font> ); <br> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Bob::work); <br> } <br> <font color="#0000ff">case</font> TIMEOUT_SIG: <br> { <br> BSP_print( <font color="#A31515">"Tick Free - Bob"</font> ); <br> <font color="#008000">//(11)   </font> <br> me-&gt;m_timeEvt.postIn(me, TIMEOUT_TIME); <br> <font color="#008000">//(12)   </font> <br> QEvent* be=Q_NEW(QEvent,TIMEOUT); <br> QF::publish(be); <br> <br> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#008000">//(13)  </font> <br> <font color="#0000ff">case</font> TERMINATE_SIG: { <br> BSP_print( <font color="#A31515">"Bob terminate.----------------------------------------------"</font> ); <br> QF::stop(); <font color="#008000">//(14)  </font> <br> <font color="#008000">//(15)    </font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br> <br> QState Bob::work(Bob *me, QEvent <font color="#0000ff">const</font> *e) { <br> <br> BSP_print( <font color="#A31515">"Bob work"</font> ); <br> <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> QEvent* be=Q_NEW(QEvent,GET); <br> QF::publish(be); <br> BSP_print( <font color="#A31515">"Bob public GET"</font> ); <br> <br> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <br> <font color="#0000ff">case</font> TIMEOUT_SIG: <br> { <br> BSP_print( <font color="#A31515">"Tick Work - Bob"</font> ); <br> BSP_print( <font color="#A31515">"I am going to free."</font> ); <br> me-&gt;m_timeEvt.postIn(me, TIMEOUT_TIME); <br> QEvent* be=Q_NEW(QEvent,TIMEOUT); <br> QF::publish(be); <br> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Bob::free); <br> } <br> <br> <font color="#0000ff">case</font> TERMINATE_SIG: { <br> BSP_print( <font color="#A31515">"Bob terminate.----------------------------------------------"</font> ); <br> QF::stop(); <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Explanations <br>  1) Bob must periodically generate a TIMEOUT_SIG message for this we use our own timer. <br>  2) The active object is always in one of its states.  When a signal is received, it is passed to the function to be called in this state.  State functions have their own special signature.  The Bob object has two states, FREE and WORK, but you also need to describe the initial state of the INITIAL to run the object. <br>  3) For the internal timer, you need to create an internal signal. <br>  4) The object constructor must call the timer constructor. <br>  5) The facility must subscribe to public signals that it wants to receive. <br>  6) The timer starts and at a specified interval will send a signal TIMEOUT_SIG. <br>  7) From the state INITIAL translate the object into the state FREE. <br>  8) In the FREE state, when the signal is received, the free function is called in which you need to process the signal. <br>  9) In addition to custom signals, there are standard signals for entering the state and for exiting the state. <br>  10) An example of custom signal processing.  After processing the signal, go to the WORK state. <br>  11) when receiving a TIMEOUT_SIG signal, you need to recharge the timer, so that it sends TIMEOUT_SIG at a specified interval. <br>  12) An open signal is also sent to the system.  This signal waits for a Conveyor object. <br>  13) If an object takes up some resources, then it must process the system stop signal and correctly release resources.  The active object that was last launched (in our case, Bob) should process the termination signal and stop the system. <br>  14) Stop the system. <br>  15) If the signal is processed but does not change the state of the object, then you need to return the sign of processing. <br><br>  The Conveyor object from the conveyor.cpp file is simpler and you can figure it out yourself. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#include <font color="#A31515">"qp_port.h"</font> <br> #include <font color="#A31515">"qpbob.h"</font> <br> #include <font color="#A31515">"bsp.h"</font> <br> <br> Q_DEFINE_THIS_FILE <br> <br> <font color="#0000ff">class</font> Conveyor : <font color="#0000ff">public</font> QActive { <br> <br> <font color="#0000ff">private</font> : <br> <br> <font color="#0000ff">public</font> : <br> Conveyor(); <br> <br> <font color="#0000ff">private</font> : <br> <font color="#008000">//</font> <br> <font color="#0000ff">static</font> QState initial(Conveyor *me, QEvent <font color="#0000ff">const</font> *e); <br> <font color="#0000ff">static</font> QState empty(Conveyor *me, QEvent <font color="#0000ff">const</font> *e); <br> <font color="#0000ff">static</font> QState full(Conveyor *me, QEvent <font color="#0000ff">const</font> *e); <br> }; <br> <br> <font color="#0000ff">static</font> Conveyor l_Conveyor; <br> <br> QActive * <font color="#0000ff">const</font> AO_CONVEYOR = &amp;l_Conveyor; <br> <br> <font color="#008000">//............................................................................</font> <br> Conveyor::Conveyor() : QActive((QStateHandler)&amp;Conveyor::initial) <br> { <br> <br> } <br> <font color="#008000">//............................................................................</font> <br> QState Conveyor::initial(Conveyor *me, QEvent <font color="#0000ff">const</font> *) { <br> <br> BSP_print( <font color="#A31515">"Conveyor initial"</font> ); <br> <br> QS_OBJ_DICTIONARY(&amp;l_Conveyor); <br> <br> <br> QS_FUN_DICTIONARY(&amp;QHsm::top); <br> QS_FUN_DICTIONARY(&amp;Conveyor::initial); <br> QS_FUN_DICTIONARY(&amp;Conveyor::empty); <br> QS_FUN_DICTIONARY(&amp;Conveyor::full); <br> <br> QS_SIG_DICTIONARY(GET,  me); <br> QS_SIG_DICTIONARY(TIMEOUT, me); <br> <br> me-&gt;subscribe(GET); <br> me-&gt;subscribe(TIMEOUT); <br> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Conveyor::empty); <br> } <br> <font color="#008000">//............................................................................</font> <br> QState Conveyor::empty(Conveyor *me, QEvent <font color="#0000ff">const</font> *e) { <br> <br> BSP_print( <font color="#A31515">"Conveyor empty"</font> ); <br> <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <br> <br> <font color="#0000ff">case</font> TIMEOUT: <br> { <br> BSP_print( <font color="#A31515">"Tick Empty - Conveyor"</font> ); <br> BSP_print( <font color="#A31515">"Conveyor going to full."</font> ); <br> <br> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Conveyor::full); <br> } <br> <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br> <br> QState Conveyor::full(Conveyor *me, QEvent <font color="#0000ff">const</font> *e) { <br> <br> BSP_print( <font color="#A31515">"Conveyor full"</font> ); <br> <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#008000">//(1)     </font> <br> <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> QEvent* be=Q_NEW(QEvent,READY); <br> QF::publish(be); <br> BSP_print( <font color="#A31515">"Conveyor READY."</font> ); <br> } <br> <br> <font color="#0000ff">case</font> GET: <br> { <br> BSP_print( <font color="#A31515">"Bob GET box."</font> ); <br> <font color="#0000ff">return</font> Q_TRAN(&amp;Conveyor::empty); <br> } <br> <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  This example of developing an application based on finite automata for embedded systems using QP does not pretend to realism and complete correctness.  But I think it will help those who wish to master QP.  Further study of QP can be continued on the basis of materials from the <a href="http://www.state-machine.com/">official site</a> . <br><br>  Sources: <br>  <a href="http://2file.net/get/13957/">code only;</a> <br>  <a href="http://2file.net/get/13958/">project in VS.</a> </div><p>Source: <a href="https://habr.com/ru/post/102024/">https://habr.com/ru/post/102024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102010/index.html">Creating a Javascript Canvas Game</a></li>
<li><a href="../102011/index.html">Whyday 2010 - Why the Lucky Stiff Memorial Day</a></li>
<li><a href="../102012/index.html">Java / Python SDKs 1.3.6 released</a></li>
<li><a href="../102019/index.html">We are building an internal portal in the university</a></li>
<li><a href="../102023/index.html">Gadgets and their impact on the industry</a></li>
<li><a href="../102027/index.html">Google, Apple and Facebook</a></li>
<li><a href="../102028/index.html">Free Windows Phone 7 Jump Start Course</a></li>
<li><a href="../102029/index.html">Groupon bought his Russian clone (Darberry.ru)</a></li>
<li><a href="../102030/index.html">Qualcomm - ‚ÄúGigahertz something superfluous‚Äù</a></li>
<li><a href="../102031/index.html">Evernote population: already 4 million and growing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>