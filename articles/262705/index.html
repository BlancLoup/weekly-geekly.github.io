<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiplication of Karatsuba and C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to once again touch on the method of implementing Karatsuba multiplication using the capabilities of the C ++ standard 11. This algorithm was r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiplication of Karatsuba and C ++ 11</h1><div class="post__text post__text-html js-mediator-article">  I want to once again touch on the method of implementing Karatsuba multiplication using the capabilities of the C ++ standard 11.  This algorithm was repeatedly considered here ( <a href="http://habrahabr.ru/post/124258/">‚ÄúMultiplication of long numbers using the Karatsuba method‚Äù</a> , <a href="http://habrahabr.ru/post/121950/">‚ÄúKaratsuba algorithm for multiplying two numbers‚Äù</a> ), but apparently due to the fact that I cannot prepare them, the first version did not work with numbers of different lengths, and the second does not exactly what was needed. <br><br>  For those who are not tired of this hackneyed topic, as well as all those who have difficulties with the implementation of this simple but very effective algorithm, please read further. <br><a name="habracut"></a><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habr.com/ru/post/262705/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/262705/">Implementation</a> </li><li>  <a href="https://habr.com/ru/post/262705/">Comparison of the speed of the naive algorithm and the Karatsuba algorithm</a> </li><li>  <a href="https://habr.com/ru/post/262705/">findings</a> </li></ul><br><h1>  Introduction </h1><a name="Intro"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/files/443/5cf/279/4435cf27992240d4909dff6ac617e1f6.png" width="300"></div><br><br>  All of us were taught to multiply in a column at school.  This is the simplest algorithm that has been known for thousands of years: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/768/55f/4f7/76855f4f7f7846a09a7426541ef63944.png" width="300"></div><br><br>  Even Andrei Nikolaevich Kolmogorov in 1956 formulated a hypothesis <img src="https://habrastorage.org/getpro/habr/post_images/584/bb8/7b6/584bb87b6a71cd85058c4ee59f8d1b56.png" height="18">  (which was the lower estimate of the multiplication of the order of <img src="https://habrastorage.org/getpro/habr/post_images/2f3/841/9ea/2f38419ea05f559a09ebc1de7b32c4e3.gif" title="M (n) = O (n ^ 2)">  ), since if there were any other faster algorithm, then in such a huge period of time it would have been found. <br><br>  The pseudocode of naive multiplication is as simple as the method itself: <br><br><pre><code class="hljs django"><span class="xml"><span class="xml">multiply(x[0 ... l], y[0 ... r]): res = [0 ... r+l] for (i = 0, i </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">r</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">carry</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">l</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] += </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">carry</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">] * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">carry</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">res[i</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] / </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">base</span></span></span></span><span class="xml"><span class="hljs-tag"> // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">base</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] %= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">base</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">res</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">l</span></span></span></span><span class="xml"><span class="hljs-tag">] += </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">carry</span></span></span></span></span></span></code> </pre> <br>  For simplicity, sometimes you have to pay performance, but you can optimize this algorithm and not calculate the remainder at each step. <br><br>  A few years after the formulation of the Kolmogorov hypothesis, <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D0%25B0%25D1%2586%25D1%2583%25D0%25B1%25D0%25B0,_%25D0%2590%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BB%25D0%25B8%25D0%25B9_%25D0%2590%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B5%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">Anatoly Alekseevich Karatsuba</a> found a faster method.  His approach was generalized to the divide-and-conquer paradigm.  To understand how this works, consider two numbers of length. <img src="https://latex.codecogs.com/gif.latex?n" title="n">  which we break into two lengths <img src="http://1450830487278441548395" title="\ frac {n} {2}">  : <br><img src="https://latex.codecogs.com/gif.latex?\\X&amp;space;=&amp;space;\left&amp;space;[&amp;space;X_l&amp;space;\right&amp;space;]\left&amp;space;[&amp;space;X_r&amp;space;\right&amp;space;]=10^{\frac{n}{2}}\cdot&amp;space;X_l&amp;space;&amp;plus;&amp;space;X_r&amp;space;\\Y&amp;space;=&amp;space;\left&amp;space;[&amp;space;Y_l&amp;space;\right&amp;space;]\left&amp;space;[&amp;space;Y_r&amp;space;\right&amp;space;]=10^{\frac{n}{2}}\cdot&amp;space;Y_l&amp;space;&amp;plus;&amp;space;Y_r" title="\\ X = \ left [X_l \ right] \ left [X_r \ right] = 10 ^ {\ frac {n} {2}} \ cdot X_l + X_r \\ Y = \ left [Y_l \ right] \ left [ Y_r \ right] = 10 ^ {\ frac {n} {2}} \ cdot Y_l + Y_r"><br>  Now note that [1]: <br> <a href="https://www.codecogs.com/eqnedit.php%3Flatex%3DX%5Ccdot%26space%3BY%3D%5Cleft(10%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot%26space%3BX_l%26plus%3BX_r%5Cright)%5Ccdot%5Cleft(10%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot%26space%3BY_l%26plus%3BY_r%5Cright)%3D%5Cnewline%3D10%5En%26space%3BX_l%5Ccdot%26space%3BY_l%26plus%3B10%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Cleft(X_l%5Ccdot%26space%3BY_r%26plus%3BX_r%5Ccdot%26space%3BY_l%5Cright)%26plus%3BX_r%5Ccdot%26space%3BY_r"><img src="https://latex.codecogs.com/gif.latex?X\cdot&amp;space;Y=\left(10^{\frac{n}{2}}\cdot&amp;space;X_l&amp;plus;X_r\right)\cdot\left(10^{\frac{n}{2}}\cdot&amp;space;Y_l&amp;plus;Y_r\right)=\newline=10^n&amp;space;X_l\cdot&amp;space;Y_l&amp;plus;10^{\frac{n}{2}}\left(X_l\cdot&amp;space;Y_r&amp;plus;X_r\cdot&amp;space;Y_l\right)&amp;plus;X_r\cdot&amp;space;Y_r" title="X \ cdot Y = \ left (10 ^ {\ frac {n} {2}} \ cdot X_l + X_r \ right) \ cdot \ left (10 ^ {\ frac {n} {2}} \ cdot Y_l + Y_r \ right) = \ newline = 10 ^ n X_l \ cdot Y_l + 10 ^ {\ frac {n} {2}} \ left (X_l \ cdot Y_r + X_r \ cdot Y_l \ right) + X_r \ cdot Y_r"></a> <br><br>  It is seen that it is necessary to make 4 multiplications and then the complexity is no different from the naive algorithm.  But Anatoly Alekseevich Karatsuba noticed that you can get by with 3 multiplications of numbers of length <img src="http://1450830487278441548395" title="\ frac {n} {2}">  - <img src="http://1450830487840127259860" title="X_l \ cdot Y_l">  , <img src="http://1450830487840127259860" title="X_r \ cdot Y_r">  , <img src="https://latex.codecogs.com/gif.latex?\left(&amp;space;X_l&amp;space;&amp;plus;&amp;space;X_r&amp;space;\right&amp;space;)\cdot&amp;space;\left(&amp;space;Y_l&amp;space;&amp;plus;&amp;space;Y_r&amp;space;\right&amp;space;)" title="\ left (X_l + X_r \ right) \ cdot \ left (Y_l + Y_r \ right)">  .  Really: <br><img src="https://latex.codecogs.com/gif.latex?X_l\cdot&amp;space;Y_r&amp;space;&amp;plus;&amp;space;X_r&amp;space;\cdot&amp;space;Y_l&amp;space;=&amp;space;\left&amp;space;(X_l&amp;space;&amp;plus;&amp;space;X_r&amp;space;\right&amp;space;)\cdot\left(Y_l&amp;space;&amp;plus;&amp;space;Y_r&amp;space;\right&amp;space;)&amp;space;-&amp;space;X_l\cdot&amp;space;Y_l&amp;space;-&amp;space;X_r\cdot&amp;space;Y_r" title="X_l \ cdot Y_r + X_r \ cdot Y_l = \ left (X_l + X_r \ right) \ cdot \ left (Y_l + Y_r \ right) - X_l \ cdot Y_l - X_r \ cdot Y_r"><br><br>  We managed three multiplications instead of four, and therefore the operation time of the Karatsuba algorithm satisfies the relation [2]: <br><img src="https://latex.codecogs.com/gif.latex?T(n)=3T\left(\frac{n}{2}\right)&amp;plus;O(n)" title="T (n) = 3T \ left (\ frac {n} {2} \ right) + O (n)">  , <br>  which ultimately gives the overall complexity of the algorithm <img src="https://latex.codecogs.com/gif.latex?O(n^{log_23})" title="O (n ^ {log_23})">  . <br>  Karatsuba multiplication code pseudodode: <br><pre> <code class="cpp hljs">Karatsuba_mul(X, Y): <span class="hljs-comment"><span class="hljs-comment">// X, Y -    n n = max( X,  Y)  n = 1:  X * Y X_l =  n/2  X X_r =  n/2  X Y_l =  n/2  Y Y_r =  n/2  Y Prod1 = Karatsuba_mul(X_l, Y_l) Prod2 = Karatsuba_mul(X_r, Y_r) Prod3 = Karatsuba_mul(X_l + X_r, Y_l + Y_r)  Prod1 * 10 ^ n + (Prod3 - Prod1 - Prod2) * 10 ^ (n / 2) + Prod2</span></span></code> </pre><br><br>  And an example on small numbers to fix the mechanism of work: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">12</span></span> b = <span class="hljs-number"><span class="hljs-number">81</span></span> res = Karatsuba_mul(a, b): <span class="hljs-comment"><span class="hljs-comment">//  a =  b = 2 n = max(  a,  b) // n = 2 X_l = 1, X_r = 2 // 1 | 2 Y_l = 8, Y_r = 1 // 8 | 1 Prod1 = Karatsuba_mul(1, 8) // Prod1 = 8 Prod2 = Karatsuba_mul(2, 1) // Prod2 = 2 Prod3 = Karatsuba_mul(3, 9) // Prod3 = 27  8 * 10 ^ 2 + (27 - 2 - 8) * 10 + 2 ----------------------------------------------- res = 972</span></span></code> </pre><br><h1><anchor>  Implementation </anchor></h1><a name="Impl"></a><br>  So we are ready to start implementing the algorithm in C ++.  On the Internet, I found several implementations that use the C-style of writing code, which makes it somewhat difficult to read for beginners.  Therefore, I decided to use as much as possible the improvements available in the C ++ 11 standard.  Yes, it will slow down the code, but here we are primarily interested in ease of understanding and readability. <br><br><ol><li>  <strong>Storage number.</strong>  We use the standard vector of integers with which everyone studying C ++ is familiar.  We will read a long number in a line and from the end be divided into digits corresponding to the selected base (10 at the beginning). <br>  For example, the input received a number: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">123456789000000000</span></span></code> </pre><br>  In our container it will be stored as: <br><br><pre> <code class="cpp hljs">|<span class="hljs-number"><span class="hljs-number">0</span></span>|<span class="hljs-number"><span class="hljs-number">1</span></span>|<span class="hljs-number"><span class="hljs-number">2</span></span>|<span class="hljs-number"><span class="hljs-number">3</span></span>|<span class="hljs-number"><span class="hljs-number">4</span></span>|<span class="hljs-number"><span class="hljs-number">5</span></span>|...|n| <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Function code get_number ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_number(istream&amp; is) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> snum; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vnum; <span class="hljs-comment"><span class="hljs-comment">//   unsigned int dig = 1; int n = 0; is &gt;&gt; snum; for (auto it = snum.crbegin(); it != snum.crend(); ++it) { n += (*it - '0') * dig; dig *= dig_size; //    ,      if (dig == base) { vnum.push_back(n); n = 0; dig = 1; } } if (n != 0) { vnum.push_back(n); } return vnum; }</span></span></code> </pre><br></div></div><br></li><li>  <strong>Getting the number.</strong>  At the entrance, we can receive numbers of different lengths and for the successful operation of the algorithm, it is desirable for us to reduce to the same length, a multiple of 2 (since we constantly divide our ‚Äúlong‚Äù numbers in half).  Let's write the <strong>extend_vec ()</strong> function that would take our vector and extend it somehow like this: <br><br><pre> <code class="cpp hljs">first = {<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// 4; size = 1 second = {3, 2, 1} // 123; size = 3 auto n = max(first.size(), second.size()); extend_vec(first, n); //  3  extend_vec(second, n); //  1 </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Extend_vec () function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend_vec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (len &amp; (len - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ++len; } v.resize(len); }</code> </pre><br></div></div><br></li><li>  <strong>Multiplication.</strong>  Here it is worth talking about several optimizations that are worth doing.  We will not count the residuals and transfer them to the higher digits on each recursive call, but at the end.  And for multiplying two numbers with a length less than, say, 128, we will use a naive algorithm, since it is a smaller constant than the Karatsuba algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Function code naive_mul ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; naive_mul(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; y) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = x.size(); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; res(<span class="hljs-number"><span class="hljs-number">2</span></span> * len); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; len; ++j) { res[i + j] += x[i] * y[j]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Karatsuba_mul () function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; karatsuba_mul(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; y) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = x.size(); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; res(<span class="hljs-number"><span class="hljs-number">2</span></span> * len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt;= len_f_naive) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> naive_mul(x, y); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> k = len / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Xr {x.begin(), x.begin() + k}; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Xl {x.begin() + k, x.end()}; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Yr {y.begin(), y.begin() + k}; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Yl {y.begin() + k, y.end()}; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; P1 = karatsuba_mul(Xl, Yl); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; P2 = karatsuba_mul(Xr, Yr); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Xlr(k); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Ylr(k); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k; ++i) { Xlr[i] = Xl[i] + Xr[i]; Ylr[i] = Yl[i] + Yr[i]; } <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; P3 = karatsuba_mul(Xlr, Ylr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { P3[i] -= P2[i] + P1[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { res[i] = P2[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = len; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * len; ++i) { res[i] = P1[i - len]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = k; i &lt; len + k; ++i) { res[i] += P3[i - k]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br></div></div><br></li><li>  <strong>Normalization.</strong>  It remains to make all transfers and you can display the result (or use for further calculations). <br><br><div class="spoiler">  <b class="spoiler_title">Function code finalize ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; res)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; res.size(); ++i) { res[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] += res[i] / base; res[i] %= base; } }</code> </pre><br></div></div><br>  And display the result, complementing with zeros when using a base greater than 10. <br><br><div class="spoiler">  <b class="spoiler_title">Function code print_res ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_res</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v, ostream&amp; os)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = v.crbegin(); <span class="hljs-comment"><span class="hljs-comment">// Passing leading zeroes while (!*it) { ++it; } while (it != v.crend()) { int z = -1; int num = *it; if (num == 0) { num += 1; } if (num &lt; add_zero) { z = 1; while ((num *= dig_size) &lt; add_zero) { ++z; } } if (z &gt; 0) { while (z--) { os &lt;&lt; '0'; } } os &lt;&lt; *it++; } os &lt;&lt; endl; }</span></span></code> </pre><br></div></div><br></li></ol><br><h1>  Comparison of the speed of the naive algorithm and the Karatsuba algorithm </h1><a name="Compare"></a><br>  To build the test program, Clang ++ with the -O3 key was used.  The test results for the representation of numbers with a base of 10 are shown in Figure 1. <br><br><div class="spoiler">  <b class="spoiler_title">Calculation time of the work (base 10)</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/364/ef4/456/364ef44568524553b225b1aea2a500fa.jpg"><br>  <i>Figure 1. Calculation time for the product of two numbers using the base 10 representation</i> <br></div></div><br>  It can be seen that the naive algorithm significantly slows down when input numbers are longer <img src="https://latex.codecogs.com/gif.latex?2\cdot&amp;space;10^5" title="2 \ cdot 10 ^ 5">  . <br>  Figure 2 shows the result of the work of the same algorithms, but with a small optimization.  Now the long number is placed in the vector using base 100, which gives a significant increase in performance. <br><br><div class="spoiler">  <b class="spoiler_title">Calculation time of the work (base 100)</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/518/432/ece/518432ecea224e3183784c6270a33e88.jpg"><br>  <i>Figure 2. Calculation time for the product of two numbers, using the base 100 representation</i> <br></div></div><br><h1>  findings </h1><a name="Summary"></a><br>  That's all, we have disassembled with you this simple and effective way of multiplying.  I hope this material will be useful and many newbies who are just starting to learn the algorithms will no longer fall into a stupor (well, he did not come to me the first time in his time). <br><br>  There is still much to optimize this implementation: <br><ul><li>  increase the base in which the numbers are stored in the vector.  Now the normalization of the number is done at the very end, which causes an overflow of standard types in C ++.  It may be worth storing numbers in an array / vector of <i>unsigned long long type</i> and calculate the residuals with hyphenation at each stage of multiplication.  Or use the "long" representation of the remainder. </li><li>  abandon vectors in favor of arrays and not use the selection of the left and right side of the number using iterators. </li></ul><br>  That's all, thank you all for your attention. <br>  The original project that was used when writing the article is <a href="https://github.com/vpetrigo/multiplication">here</a> . <br><br><h3>  Bibliography </h3><br><ol><li>  S. Dasgupta Algorithms: Translated from English by A. S. Kulikov, edited by A. Shen [Text] / S. Dasgupta, H. Papadimitriou, U. Vazirani.  -Moscow: ICNMO, 2014 - 320 p. </li><li>  Karatsuba algorithm [Electronic resource] / Wikipedia - URL: <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">en.wikipedia.org/wiki/Karatsuba_algorithm</a> </li><li>  A. S. Kulikov Algorithms and data structures [Electronic resource] / A. S. Kulikov - URL: <a href="https://stepic.org/course/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B-%25D0%25B8-%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D1%258B-%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585-63/syllabus">https://stepic.org/course/Algorithms-</a> and structures- data-63/ <a href="https://stepic.org/course/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B-%25D0%25B8-%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D1%258B-%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585-63/syllabus">syllabus</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/262705/">https://habr.com/ru/post/262705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262695/index.html">YandexBot follows the links that the user follows.</a></li>
<li><a href="../262697/index.html">Automatic migrations to Peewee</a></li>
<li><a href="../262699/index.html">Remote enable by Mac address C # (Wake On Lan)</a></li>
<li><a href="../262701/index.html">Creating CloudFoundry / IBM Bluemix buildpack or Awk web service (gawk)</a></li>
<li><a href="../262703/index.html">The distance spectra of simple sets and their associations (part 2)</a></li>
<li><a href="../262707/index.html">Obtaining international IT certificates</a></li>
<li><a href="../262709/index.html">We build a performance bench on the example of the server Set Retail 10</a></li>
<li><a href="../262711/index.html">Fast and convenient IL generation</a></li>
<li><a href="../262713/index.html">The story of one fakapa or why iteration is a necessary, but not sufficient condition for Agile</a></li>
<li><a href="../262715/index.html">OpenAdAdapter - Simple Mobile Advertising Management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>