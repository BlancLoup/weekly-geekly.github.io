<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>man! (Go => D) .concurrency</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multitasking is what Go is really good for, though not perfect. Nice syntax with a tart finish, simple and powerful abstractions, captivate with their...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>man! (Go => D) .concurrency</h1><div class="post__text post__text-html js-mediator-article"><p>  Multitasking is what Go is really good for, though not perfect.  Nice syntax with a tart finish, simple and powerful abstractions, captivate with their elegance compared to other imperative languages.  And having tasted the best, you don‚Äôt want to go so far as to mediocrity.  Therefore, if you switch to another language, it should be even more expressive and with a no less sensible implementation of multitasking. <br><br>  If you have already played enough with Go, are tired of copy-paste, manual juggling with mutexes and are seriously considering acquiring <a href="https://blog.golang.org/generate">hand prostheses</a> , then let me offer you the <a href="https://tour.golang.org/list">Tour of the Go</a> translation with the equivalent <a href="http://dlang.org/">D</a> code and brief explanations. <br></p><br><p>  <a href="https://habrahabr.ru/post/279657/">Part one.</a>  <a href="https://habrahabr.ru/post/279657/">The basics.</a> <br></p><br><h1 id="chast-pyataya-soprogrammy">  Part Five.  Coroutines. </h1><a name="habracut"></a><br><h2 id="coroutines">  Coroutines </h2><br><h3 id="gohttpstourgolangorgconcurrency1">  <a href="https://tour.golang.org/concurrency/1">Go</a> </h3><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) fmt.Println(s) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> say(<span class="hljs-string"><span class="hljs-string">"world"</span></span>) say(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) }</code> </pre> <br><p>  Go allows you to easily and easily start any function in a parallel thread and continue working without waiting for it to complete.  All the streams (fibers, fibers, coroutines, coroutines, greenlets) are done cooperatively on a limited number of native streams (threads, threads), thereby maximizing the utilization of the processor cores.  Standard library D <a href="http://dlang.org/phobos/core_thread.html">supports fibers</a> , but only within one thread and does not know how to balance the fibers into several threads.  But <a href="http://vibed.org/api/vibe.core.core/runWorkerTaskH">such a scheduler is implemented in the vibe.d project</a> , although the syntax for launching a parallel stream is still not as concise as in Go.  Therefore, we will use <a href="">the go.d library</a> providing the "go!" Template.  for parallel start of functions.  In addition, following the best practices, the code of examples we will draw up in the form of tests. </p><br><br><h3 id="d">  D </h3><br><pre> <code class="plaintext hljs">unittest { import core.time; import std.range; import jin.go; __gshared static string[] log; static void saying( string message ) { foreach( _ ; 3.iota ) { sleep( 100.msecs ); log ~= message; } } go!saying( "hello" ); sleep( 50.msecs ); saying( "world" ); log.assertEq([ "hello" , "world" , "hello" , "world" , "hello" , "world" ]); }</code> </pre> <br><p>  In D, it is not customary to cycle unnecessarily, so we implemented the cycle through iteration over a sequence of natural numbers.  We had to declare the function ‚Äúsaying‚Äù static so that it does not have access to local variables, which is unsafe when it is executed in parallel in different threads.  If you make this function a closure by removing "static", then this code will not compile - thanks to the template magic, the compiler will not allow us to send the gun to our own limbs.  In Go, the issue of competitive access remains on the conscience of the programmer, who, in most cases, does not have it. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1 id="buffered-channels">  Buffered channels </h1><br><h3 id="gohttpstourgolangorgconcurrency3">  <a href="https://tour.golang.org/concurrency/3">Go</a> </h3><br><pre> <code class="plaintext hljs">package main import "fmt" func main() { ch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) }</code> </pre> <br><p>  Running parallel threads would not be so useful if it were not possible to synchronize them.  Go uses a rather elegant abstraction for this ‚Äî channels.  Channels are typed message queues.  If a stream tries to read something from an empty channel, then it is blocked waiting for another stream, which this data will write there.  Conversely, if it tries to write to an overcrowded channel, it will block until another thread subtracts at least one message from the channel.  Channels easily replace such abstractions as lazy generators, events and promises, bringing with them much more usage scenarios. </p><br><p>  In the standard library D for communication between threads is used to <a href="https://dlang.org/library/std/concurrency/receive.html">receive / transmit abstract messages</a> .  That is, knowing the stream id, you can send an arbitrary message to it, but it must unpack it and somehow process it.  Pretty uncomfortable mechanism.  Vibe.d introduces an abstraction of a <a href="http://vibed.org/api/vibe.core.stream/">stream of bytes</a> with behavior similar to the gochanals.  But often it is required not just bytes to transfer, but some structures.  In addition, in Go, and in D, inter-thread communication is implemented through the capture of a mutex, which <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D1%2583%25D1%258E%25D1%2589%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">has notorious problems</a> .  Therefore, we will again use the go.d library, which provides us with typed wait-free channels. </p><br><br><h3 id="d-1">  D </h3><br><pre> <code class="plaintext hljs">unittest { import jin.go; auto numbers = new Channel!int(2); numbers.next = 1; numbers.next = 2; numbers.next.assertEq( 1 ); numbers.next.assertEq( 2 ); }</code> </pre> <br><p>  The virtual property "next", of course, is not as clear as the arrow in Go, but the compiler keeps a close eye on the position of our gun, and does not allow to transfer types not safe for parallel use from different threads through the channel.  However, there is one thing - these channels require that they have no more than one reader and no more than one writer.  Unfortunately, for the time being, this has to be monitored manually, but in the future, the compiler will probably also be transferred to our allies. </p><br><p>  It is also worth noting that the size of the channel in Go is equal to one element by default, and about 512 bytes in go.d. </p><br><br><h1 id="channels">  Channels </h1><br><h3 id="gohttpstourgolangorgconcurrency2">  <a href="https://tour.golang.org/concurrency/2">Go</a> </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sum := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> s { sum += v } c &lt;- sum <span class="hljs-comment"><span class="hljs-comment">// send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y) // -5 17 12 }</span></span></code> </pre> <br><p>  In Go, working with a channel is protected by a mutex, so you can use it to communicate with several streams at once, when it doesn't matter to you in what order they provide the data.  Channels from the go.d library, on the contrary, are non-blocking, so they cannot be used in such a scenario ‚Äî you need to create your own communication channel for each stream.  To simplify the work with channel lists, the library provides Inputs and Outputs balancer structures.  In this case, we need Inputs, which in turn reads from each non-empty channel registered in it. </p><br><br><h3 id="d-2">  D </h3><br><pre> <code class="plaintext hljs">unittest { import std.algorithm; import std.range; import jin.go; static auto summing( Channel!int sums , const int[] numbers ) { sums.next = numbers.sum; } immutable int[] numbers = [ 7 , 2 , 8 , -9 , 4 , 0 ]; Inputs!int sums; go!summing( sums.make(1) , numbers[ 0 .. $/2 ] ); go!summing( sums.make(1) , numbers[ $/2 .. $ ] ); auto res = sums.take(2).array; ( res ~ res.sum ).assertEq([ 17 , -5 , 12 ]); }</code> </pre> <br><p>  As usual, we do not write with our hands summation of the range, but use the standard generalized "sum" algorithm for this.  In order for such algorithms to work with your data type, you only need to implement one of <a href="http://dlang.org/phobos/std_range_interfaces.html">the range interfaces</a> , which, of course, are implemented in both the Channel and Inputs, and Outputs.  The "take" algorithm produces a lazy range, which returns the specified number of first elements of the source range.  And the "array" algorithm removes all elements from the range and returns the native array with them.  Please note that we pass to each stream a separate channel of unit length and a section of an immutable array (hello, parallelism!). </p><br><br><h1 id="range-and-close">  Range and Close </h1><br><h3 id="gohttpstourgolangorgconcurrency4">  <a href="https://tour.golang.org/concurrency/4">Go</a> </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, y := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++ { c &lt;- x x, y = y, x+y } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(c) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> fibonacci(<span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(c), c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> c { fmt.Println(i) } }</code> </pre> <br><p>  As you can see, in Go we can also be iterated through the channel, successively deriving from it successive elements.  In order not to hang in an infinite loop, such channels must be closed by the transmitting side so that the host can understand that there will be no more data and it‚Äôs time to end the cycle.  In D, we would write almost the same thing, except that we would declare a Fibonacci series in the form of a mathematical recurrent formula. </p><br><br><h3 id="d-3">  D </h3><br><pre> <code class="plaintext hljs">unittest { import std.range; import jin.go; static auto fibonacci( Channel!int numbers , int count ) { auto range = recurrence!q{ a[n-1] + a[n-2] }( 0 , 1 ).take( count ); foreach( x ; range ) numbers.next = x; numbers.close(); } auto numbers = new Channel!int(10); go!fibonacci( numbers , numbers.size ); numbers.array.assertEq([ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ]); }</code> </pre> <br><p>  But you can further simplify the code, knowing that the template "go!"  he is able to shift values ‚Äã‚Äãfrom range to channel. </p><br><br><h3 id="d-4">  D </h3><br><pre> <code class="plaintext hljs">unittest { import std.range; import jin.go; static auto fibonacci( int limit ) { return recurrence!q{ a[n-1] + a[n-2] }( 0 , 1 ).take( limit ); } fibonacci( 10 ).array.assertEq([ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ]); go!fibonacci( 10 ).array.assertEq([ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ]); }</code> </pre> <br><p>  Thus, the function does not necessarily know anything about the channels to be able to run it in a parallel thread, and then wait for the result from it. </p><br><br><h1 id="select">  Select </h1><br><h3 id="gohttpstourgolangorgconcurrency5">  <a href="https://tour.golang.org/concurrency/5">Go</a> </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c, quit </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, y := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> c &lt;- x: x, y = y, x+y <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-quit: fmt.Println(<span class="hljs-string"><span class="hljs-string">"quit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) quit := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++ { fmt.Println(&lt;-c) } quit &lt;- <span class="hljs-number"><span class="hljs-number">0</span></span> }() fibonacci(c, quit) }</code> </pre> <br><p>  Go has a special concise syntax for simultaneous work with multiple channels.  D, of course, has nothing.  However, the equivalent functionality is not very difficult to implement by manually implementing the observation cycle. </p><br><br><h3 id="d-5">  D </h3><br><pre> <code class="plaintext hljs">unittest { import std.range; import jin.go; __gshared int[] log; static auto fibonacci( Channel!int numbers , Channel!bool control ) { auto range = recurrence!q{ a[n-1] + a[n-2] }( 0 , 1 ); while( !control.closed ) { if( numbers.needed ) numbers.next = range.next; yield; } log ~= -1; numbers.close(); } static void print( Channel!bool control , Channel!int numbers ) { foreach( i ; 10.iota ) log ~= numbers.next; control.close(); } auto numbers = new Channel!int(1); auto control = new Channel!bool(1); go!print( control , numbers ); go!fibonacci( numbers , control ); while( !control.empty || !numbers.empty ) yield; log.assertEq([ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , -1 ]); }</code> </pre> <br><p>  As you can see, we had to get rid of the closure, and add "yield" in cycles so that competing fibers could do something as well, while the current hangs waiting. </p><br><br><h1 id="default-selection">  Default selection </h1><br><h3 id="gohttpstourgolangorgconcurrency6">  <a href="https://tour.golang.org/concurrency/6">Go</a> </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { tick := time.Tick(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) boom := time.After(<span class="hljs-number"><span class="hljs-number">500</span></span> * time.Millisecond) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-tick: fmt.Println(<span class="hljs-string"><span class="hljs-string">"tick."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-boom: fmt.Println(<span class="hljs-string"><span class="hljs-string">"BOOM!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(<span class="hljs-string"><span class="hljs-string">" ."</span></span>) time.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span> * time.Millisecond) } } }</code> </pre> <br><p>  Go's special syntax allows you to do something if there is no activity in any of the channels.  In D, however, you have more control over the flow of execution. </p><br><br><h3 id="d-6">  D </h3><br><pre> <code class="plaintext hljs">unittest { import core.time; import jin.go; static auto after( Channel!bool channel , Duration dur ) { sleep( dur ); if( !channel.closed ) channel.next = true; } static auto tick( Channel!bool channel , Duration dur ) { while( !channel.closed ) after( channel , dur ); } auto ticks = go!tick( 101.msecs ); auto booms = go!after( 501.msecs ); string log; while( booms.clear ) { while( !ticks.clear ) { log ~= "tick"; ticks.popFront; } log ~= "."; sleep( 51.msecs ); } log ~= "BOOM!"; log.assertEq( "..tick..tick..tick..tick..BOOM!" ); }</code> </pre> <br><p>  A remarkable feature is that we did not need to manually create the channel.  If the function accepts the channel as the first argument and we did not pass it, it will be created automatically and returned as the result of the "go!" Pattern, which is very convenient.  The "after" and "tick" functions are too specific to be included in the common library, but they have very simple implementations. </p><br><br><h1 id="mutex">  Mutex </h1><br><p>  In some cases, we still cannot do without a shared changeable state, and locks come to our aid. </p><br><br><h3 id="gohttpstourgolangorgconcurrency9">  <a href="https://tour.golang.org/concurrency/9">Go</a> </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// SafeCounter is safe to use concurrently. type SafeCounter struct { v map[string]int mux sync.Mutex } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mux.Lock() // Lock so only one goroutine at a time can access the map cvcv[key]++ c.mux.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mux.Lock() // Lock so only one goroutine at a time can access the map cv defer c.mux.Unlock() return cv[key] } func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i &lt; 1000; i++ { go c.Inc("somekey") } time.Sleep(time.Second) fmt.Println(c.Value("somekey")) }</span></span></code> </pre> <br><p>  Yes, exactly, the implementation of a shared changeable state in Go is pain and suffering.  One wrong move when working with mutexes and you suddenly find yourself in <a href="http://vocabulary.ru/dictionary/978/word/fantomnaja-konechnost">phantom limbs</a> .  Not to mention the fact that the compiler does not even hint to you where mutexes are needed.  But the D compiler strongly curses you for trying to work with an unprotected changeable state from different threads.  And the easiest way to protect the state when multithreaded execution is to implement a synchronized class. </p><br><br><h3 id="d-7">  D </h3><br><pre> <code class="plaintext hljs">unittest { import core.atomic; import core.time; import std.range; import std.typecons; import jin.go; synchronized class SafeCounter { private int[string] store; void inc( string key ) { ++ store[key]; } auto opIndex( string key ) { return store[ key ]; } void opIndexUnary( string op = "++" )( string key ) { this.inc( key ); } } static counter = new shared SafeCounter; static void working( int i ) { ++ counter["somekey"]; } foreach( i ; 1000.iota ) { go!working( i ); } sleep( 1.seconds ); counter["somekey"].assertEq( 1000 ); }</code> </pre> <br><p>  The feature of the synchronized class is that a mutex is automatically created for it and when any public method is called, this mutex is captured, released only when the method leaves.  In this case, all internal state must be private.  But there is one unpleasant feature (and in fact a very dangerous and annoying compiler bug): sample methods, such as, for example, "opIndexUnary!", Do not turn into a mutex capture.  Therefore, we have created a separate public method "inc", which we call from the template method.  The internal implementation turned out not so beautiful, but the external interface turned out as native.  The resulting "shared SafeCounter" we can already safely pass through the channel and use directly from different streams. </p></div><p>Source: <a href="https://habr.com/ru/post/280378/">https://habr.com/ru/post/280378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280364/index.html">An exploit for vulnerabilities in Cisco UCS Manager: is the devil so scary?</a></li>
<li><a href="../280370/index.html">Tips, libraries and additional materials on CSS-animation</a></li>
<li><a href="../280372/index.html">Interactive video and what it eats</a></li>
<li><a href="../280374/index.html">Measuring code coverage tests on Android using JaCoCo</a></li>
<li><a href="../280376/index.html">In simple words: We deal with "cloud" services.</a></li>
<li><a href="../280380/index.html">We solve the problem of interception and substitution of DNS queries. DNSCrypt in Yandex Browser</a></li>
<li><a href="../280382/index.html">Yii framework code parsing</a></li>
<li><a href="../280384/index.html">Million files and one laptop</a></li>
<li><a href="../280386/index.html">Flume - manage data streams. Part 1</a></li>
<li><a href="../280388/index.html">Understanding multithreading in RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>