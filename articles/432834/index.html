<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Internal and external linking in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone! 

 We present to you a translation of an interesting article that was prepared for you as part of the C ++ Developer Course. We hop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Internal and external linking in C ++</h1><div class="post__text post__text-html js-mediator-article">  Good day everyone! <br><br>  We present to you a translation of an interesting article that was prepared for you as part of <a href="https://otus.pw/42eZ/">the C ++ Developer</a> Course.  We hope that it will be useful and interesting for you, as well as our listeners. <br><br>  Go. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Have you ever come across the terms internal and external communication?  Want to know what the extern keyword is used for, or how does declaring something static affect the global scope?  Then this article is for you. <br><br>  <b>In a nutshell</b> <br><br>  The translation unit includes the implementation file (.c / .cpp) and all its header files (.h / .hpp).  If an object or function has an internal binding within a translation unit, then this symbol is visible to the linker only within that translation unit.  If an object or function has an external binding, then the linker will be able to see it when processing other translation units.  Using the static keyword in the global namespace gives the symbol internal binding.  The keyword extern gives external linking. <br>  The default compiler gives the characters the following bindings: <br><br><ul><li>  Non-const global variables - external binding; </li><li>  Const global variables - internal binding; </li><li>  Functions - external binding. </li></ul><br><img src="https://habrastorage.org/webt/m5/bl/8d/m5bl8d7e6yb-7qlgsoqf8duzuku.png"><br><a name="habracut"></a><br>  <b>The basics</b> <br><br>  We first talk about two simple concepts needed to discuss binding. <br><br><ul><li>  The difference between a declaration and a definition; </li><li>  Units broadcast. </li></ul><br>  Also note the names: we will use the concept of ‚Äúsymbol‚Äù when it comes to any ‚Äúcode entity‚Äù that the linker works with, for example, with a variable or function (or with classes / structures, but we will not focus on them). <br><br>  <b>Ad VS.</b>  <b>Definition</b> <br><br>  We briefly discuss the difference between the declaration and the definition of a symbol: the declaration (or declaration) tells the compiler about the existence of a particular symbol, and allows access to this symbol in cases that do not require an exact memory address or symbol storage.  The definition tells the compiler what the function body contains or how much memory to allocate to the variable. <br><br>  In some situations, the compiler does not have enough declarations, for example, when a data element of a class has a reference type or value (that is, not a reference, and not a pointer).  At the same time, a pointer to a declared (but undefined) type is allowed, since it needs a fixed amount of memory (for example, 8 bytes on 64-bit systems), independent of the type pointed to.  To get a value on this pointer, a definition is needed.  Also, to declare a function, you need to declare (but not define) all parameters (no matter whether they are taken by value, reference, or pointer) and the return type.  Determining the type of return value and parameters is only necessary to define a function. <br><br>  <b>Functions</b> <br><br>  The difference between a definition and a function declaration is quite obvious. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  int f() { return 42; } // </span></span></code> </pre> <br>  <b>Variables</b> <br><br>  With variables, it's a little different.  The declaration and definition are usually not separated.  The main thing is that: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x;</code> </pre> <br>  Not only declares <code>x</code> , but also defines it.  This happens due to the default constructor call int.  (In C ++, unlike Java, the constructor of simple types (such as int) does not by default initialize the value to 0. In the example above, x will be equal to any garbage lying in the memory address allocated by the compiler). <br><br>  But you can explicitly separate the declaration of a variable and its definition using the <code>extern</code> keyword. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  int x = 42; // </span></span></code> </pre> <br>  However, when initializing and adding <code>extern</code> to the declaration, the expression becomes a definition and the keyword <code>extern</code> becomes useless. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,   int x = 5;</span></span></code> </pre> <br>  <b>Preliminary Announcement</b> <br><br>  In C ++, there is the concept of pre-declaring a character.  This means that we declare the type and name of the symbol for use in situations that do not require its definition.  So we will not need to include a full definition of a character (usually a header file) unless explicitly necessary.  Thus, we reduce the dependence on the file containing the definition.  The main advantage is that when a file is modified with a definition, the file where we previously declare this symbol will not require recompilation (and, therefore, all other files including it). <br><br>  <i>Example</i> <br><br>  Suppose we have a function declaration (called a prototype) for f, which accepts an object of type <code>Class</code> by value: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp void f(Class object);</span></span></code> </pre> <br>  Immediately include the definition of <code>Class</code> - naive.  But since we have just declared <code>f</code> , it suffices to provide the compiler with the declaration <code>Class</code> .  Thus, the compiler will be able to recognize the function from its prototype, and we will be able to get rid of the file.hpp dependency on the file containing the definition of <code>Class</code> , say class.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp class Class; void f(Class object);</span></span></code> </pre> <br>  Suppose file.hpp is contained in 100 other files.  And let's say we change the definition of Class in class.hpp.  If you add class.hpp to file.hpp, file.hpp and all 100 files containing it will need to be recompiled.  Due to the preliminary declaration of Class, the only files that need to be recompiled are class.hpp and file.hpp (assuming that f is defined there). <br><br>  <b>Frequency of use</b> <br><br>  An important difference between a declaration and a definition is that a symbol can be declared many times, but is defined only once.  So you can pre-declare a function or class as many times as you like, but there can be only one definition.  This is called the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">Rule of One Definition</a> .  In C ++, the following works: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  And it does not work: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre><br>  <b>Broadcast units</b> <br><br>  Programmers typically work with header files and implementation files.  But not compilers - they work with translation units (translation units, TU for short), which are sometimes called compilation units.  The definition of such a unit is quite simple - any file passed to the compiler after it has been pre-processed.  To be precise, this is a file resulting from the work of a preprocessor extending a macro, including source code, which depends on <code>#ifdef</code> and <code>#ifndef</code> expressions, and copy-paste of all <code>#include</code> files. <br><br>  There are the following files: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> VALUE struct Foo { private: int ryan; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int strlen(const char* string); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* HEADER_HPP */</span></span></span></span></code> </pre> <br>  program.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> int strlen(const char* string) { int length = 0; while(string[length]) ++length; return length + VALUE; }</span></span></code> </pre> <br>  The preprocessor will issue the following translation unit, which is then passed to the compiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[length]) ++length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length + <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  <b>Connections</b> <br><br>  After discussing the basics, you can proceed to relationships.  In general, communication is the visibility of symbols for the linker when processing files.  Communication can be either external or internal. <br><br>  <b>External communication</b> <br><br>  When a symbol (variable or function) has an external link, it becomes visible to linkers from other files, that is, ‚Äúglobally‚Äù visible, accessible to all translation units.  This means that you must define such a symbol in a specific location of one translation unit, usually in the implementation file (.c / .cpp), so that it has only one visible definition.  If you try simultaneously with the declaration of the symbol to perform its definition, or place the definition in the file to the declaration, then you risk annoying the linker.  Attempting to add a file to more than one implementation file leads to the addition of definition to more than one translation unit ‚Äî your linker will cry. <br><br>  The extern keyword in C and C ++ (explicitly) declares that the symbol has an external link. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; argument)</span></span></span></span>;</code> </pre><br>  Both symbols have an external connection.  As noted above, const global variables have intrinsic binding by default, non-const global variables are extrinsic.  This means that int x;  - the same as extern int x ;, right?  Not really.  int x;  is actually analogous to extern int x {};  (using the syntax universal / bracket initialization, to avoid the most unpleasant syntax analysis (the most vexing parse)), since int x;  not only declares, but also defines x.  Therefore, do not add extern to int x;  Globally as bad as defining a variable when declaring its extern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//   ,   extern int x{}; //      . extern int x; //      ,  </span></span></code> </pre> <br>  <i>Bad example</i> <br><br>  Let's declare a function <code>f</code> with an external link in file.hpp and define it there: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP extern int f(int x); /* ... */ int f(int) { return x + 1; } /* ... */ #endif /* FILE_HPP */</span></span></code> </pre> <br>  Please note that you do not need to add extern here, since all functions are explicitly extern.  Separation of ads and definitions is also not required.  So let's just rewrite it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP int f(int) { return x + 1; } #endif /* FILE_HPP */</span></span></code> </pre> <br>  Such a code could be written before reading this article, or after reading it under the influence of alcohol or heavy substances (for example, cinnamon buns). <br><br>  Let's see why this is not worth doing.  Now we have two implementation files: a.cpp and b.cpp, both included in file.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// b.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br>  Now let the compiler work and generate two translation units for the two implementation files above (remember that <code>#include</code> literally means copy / paste): <br><br><pre> <code class="plaintext hljs">// TU A, from a.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br><pre> <code class="plaintext hljs">// TU B, from b.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br>  The linker intervenes at this stage (binding occurs after compilation).  The linker takes the character <code>f</code> and looks for a definition.  Today he was lucky, he finds as many as two!  One in the broadcast unit A, the other in B. The linker freezes with happiness and tells you something like this: <br><br><pre> <code class="cpp hljs">duplicate symbol __Z1fv in: /path/to/ao /path/to/bo</code> </pre> <br>  The linker finds two definitions for one character <code>f</code> .  Since <code>f</code> has external binding, it is visible to the linker when processing both A and B. Obviously, this violates the Rule of One Definition and causes an error.  More precisely, this causes a duplicate symbol error, which you will receive no less than the undefined symbol error that occurs when you declare a symbol, but forgot to define it. <br><br>  <b>Using</b> <br><br>  A standard example of declaring extern variables is global variables.  Suppose you are working on a self-baking cake.  Surely there are global variables associated with the cake that should be available in different parts of your program.  Let's say the clock frequency of the edible scheme is inside your cake.  This value is naturally required in different parts for the synchronous operation of all chocolate electronics.  The (evil) C-way to declare such a global variable has the form of a macro: <br><br><pre> <code class="plaintext hljs">#define CLK 1000000</code> </pre><br>  A C ++ programmer who is disgusted with macros will better write real code.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// global.hpp namespace Global { extern unsigned int clock_rate; } // global.cpp namespace Global { unsigned int clock_rate = 1000000; }</span></span></code> </pre> <br>  (A modern C ++ programmer will want to use delimiting literals: unsigned int clock_rate = 1'000'000;) <br><br>  <b>Intercom</b> <br><br>  If the symbol has an internal link, then it will be visible only within the current translation unit.  Do not confuse visibility with access rights, such as private.  Visibility means that the linker can use this symbol only when processing a translation unit in which the symbol was declared, and not later (as in the case of symbols with an external link).  In practice, this means that when declaring a symbol with an internal link in a header file, each translation unit that includes this file will receive a unique copy of this symbol.  As if you predetermined each such character in each translation unit.  For objects, this means that the compiler will literally allocate a completely new, unique copy for each translation unit, which obviously can lead to high memory consumption. <br><br>  To declare a symbol with an internal link, in C and C ++ there is a static keyword.  This use differs from the use of static in classes and functions (or, in general, in any blocks). <br><br>  <i>Example</i> <br><br>  Let's give an example: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  file1.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file2.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file1.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function1() { variable = 10; }</span></span></code> </pre> <br><br>  file2.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function2() { variable = 123; }</span></span></code> </pre> <br>  main.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file2.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; auto main() -&gt; int { function1(); function2(); std::cout &lt;&lt; variable &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Each translation unit that includes header.hpp receives a unique copy of a variable, due to its internal connection.  There are three translation units: <br><br><ol><li>  file1.cpp </li><li>  file2.cpp </li><li>  main.cpp </li></ol><br>  When calling function1, the copy of the file1.cpp variable is set to 10. When calling function2, the copy of the variable file2.cpp is set to 123. However, the value that is displayed in main.cpp does not change and remains equal to 42. <br><br>  <b>Anonymous Namespaces</b> <br><br>  In C ++, there is another way to declare one or more symbols with an internal link: anonymous namespaces.  This space ensures that the characters declared inside it are visible only in the current translation unit.  In essence, this is just a way to declare a few static characters.  For a while, the use of the static keyword to declare a symbol with an internal link was abandoned in favor of anonymous namespaces.  However, they were again used because of the convenience of declaring a single variable or function with an internal link.  There are a few minor differences that I will not dwell on. <br><br>  In any case, it is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Does (almost) the same thing as: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <b>Using</b> <br><br>  So in what cases to use internal communications?  Using them for objects is a bad idea.  Memory consumption of large objects can be very high due to copying for each translation unit.  But basically, it just causes weird, unpredictable behavior.  Imagine that you have a singleton (a class in which you create an instance of only one instance) and suddenly several instances of your singleton appear (one for each translation unit). <br><br>  However, internal communication can be used to hide local translation helper functions from the global scope.  Suppose there is a helper function foo in file1.hpp that you use in file1.cpp.  At the same time, you have a function foo in file2.hpp, used in file2.cpp.  The first and second foo are different, but you cannot think of other names.  Therefore you can declare them static.  If you do not add both file1.hpp and file2.hpp to the same translation unit, this will hide foo from each other.  If this is not done, they will implicitly have an external connection and the definition of the first foo will interfere with the definition of the second, causing a linker error to violate the rule of one definition. <br><br>  THE END <br><br>  You can always leave your comments and / or questions here or visit us for an <a href="https://otus.pw/RNbq/">open day.</a> </div><p>Source: <a href="https://habr.com/ru/post/432834/">https://habr.com/ru/post/432834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432824/index.html">Accelerating the creation of ConcurrentReferenceHashMap</a></li>
<li><a href="../432826/index.html">Modern Android development on Kotlin. Part 2</a></li>
<li><a href="../432828/index.html">Testing and debugging MapReduce</a></li>
<li><a href="../432830/index.html">Automated imposition of fines for abandoned garbage</a></li>
<li><a href="../432832/index.html">How to "glue" Intel-based server and overcome the scale-up ceiling in 8 processors</a></li>
<li><a href="../432836/index.html">The first good light with Aliexpress</a></li>
<li><a href="../432838/index.html">Software development through the prism of Milgram's experiment ‚ÄúSubmission to authority‚Äù</a></li>
<li><a href="../432840/index.html">How to improve the efficiency of learning English and start writing better: choose an online assistant</a></li>
<li><a href="../432842/index.html">Some notes on the design of information systems</a></li>
<li><a href="../432844/index.html">Pre-project survey in the development of an information system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>