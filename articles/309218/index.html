<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 USB Mass Storage Bootloader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is known that the software can be added forever, and all sorts of shortcomings on the board are completely corrected revisions so to the third. And...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 USB Mass Storage Bootloader</h1><div class="post__text post__text-html js-mediator-article">  It is known that the software can be added forever, and all sorts of shortcomings on the board are completely corrected revisions so to the third.  And if you can‚Äôt do anything with iron, then you have come up with a good way to bypass the space and time restrictions to update the firmware - <i>Bootloader</i> . <br><br>  The loader is convenient and useful, isn't it?  And if the loader is its own implementation, then it is even more convenient, useful and flexible <s>and not stable</s> .  And of course, very cool! <br><br>  It is also a great opportunity to go deep and study the features of the used computer - in our case, an STM32 microcontroller with an ARM Cortex-M3 core. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, the bootloader is simpler than it seems at first glance.  As proof, under the cut we'll build our own USB Mass Storage Bootloader! <br><br><img src="https://habrastorage.org/files/cf8/56c/76a/cf856c76a8e5427fb353114dd2a01566.jpg" alt="image"><a name="habracut"></a><img src="https://habrastorage.org/files/036/7a6/450/0367a64508864233bf9ae76621cdb43f.jpg" alt="image"><br><br>  We will work with a homemade board on a microcontroller (hereinafter <b>referred to as</b> MK) <b>STM32F103RET</b> .  In order not to overflow the publication with unnecessary pictures, I will give a truncated scheme of this piece of iron: <br><br><img src="https://habrastorage.org/files/0a3/dae/bce/0a3daebcef9440b38aaaefdca828d606.png" alt="image"><br><br>  When writing a bootloader, I was guided by the following principles: <br><br><ol><li>  Your bootloader is very necessary and enough to put it off in the TODO list, it's time to sit down and do it; </li><li>  Bootloader should have a user-friendly program download interface.  No drivers, third-party programs, adapter boards and MGTF wiring harnesses to the target device.  What could be simpler than an automatically detected USB flash drive? </li><li>  To work in bootloader mode, the microcontroller needs minimal hardware binding (in fact, only USB, quartz and a button); </li><li>  The size of the boot is not important.  It is important, of course, but we will not pursue the goal of squeezing it into a couple of kilobytes.  Without a pang of conscience, we will raise the USB stack, work with the file system, push <i>printf ()</i> through the line and generally deny ourselves nothing (hello, <i>Standard Peripheral Libraries</i> !); </li></ol><br>  Drove off <br><br><h3>  <font color="#cc0000">Little FLASH</font> </h3><br>  Since we will work with our own FLASH-memory STM32 constantly and often, it is worth explaining at once some key points related to this fact. <br><br>  Used MK contains 512 Kbyte FLASH memory.  It is paginated by 2048 bytes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea9/539/301/ea9539301dc4469db5b9ad7d78127e25.PNG" alt="image"></div><br>  For us, this means that writing a few bytes to an arbitrary address just won't work.  When writing to FLASH, it is only possible to reset the desired cells, but setting units is performed using the erase operation, the minimum possible amount for which is one page.  To do this, use the <b>FLASH_AR</b> register, in which it is enough to write down any address within the page we need - and it will be filled with 0xFF bytes.  And still you need to remember to unblock FLASH before erasing / writing operations. <br><br>  Virtually split FLASH into several areas, each of which will have its own, special purpose: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dd7/7f0/b51/dd77f0b51dde4a5caa9bd1f5039df7f4.PNG" alt="image"></div><br><ul><li>  <font color="#99d2f2"><b>BOOT_MEM</b></font> - the memory area allocated for the bootloader; </li><li>  <font color="#ff8f80"><b>USER_MEM</b></font> - here we will store (and execute from here the same) user firmware.  Obviously, it now has a limit of 200 Kbyte; </li><li>  <font color="#a3d977"><b>MSD_MEM</b></font> - and there will be a MASS STORAGE disk, where you can throw the firmware using the computer and your favorite OS; </li><li>  <font color="#ffdf71"><b>OTHER_MEM</b></font> - well, let's leave some more space just in case; </li></ul><br>  <font color="#ff8f80"><b>USER_MEM</b></font> will match <font color="#a3d977"><b>MSD_MEM</b></font> in size.  This is logical, because  two opposite cases will give either a lack of memory in <font color="#ff8f80"><b>USER_MEM</b></font> , or an excess. <br><br>  And now everything is the same, only for the machine (and the convenience of the programmer): <br><pre><code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_PAGE_SIZE 2048 //2 Kbyte per page #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_START_ADDR 0x08000000 //Origin #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_MAX_SIZE 0x00080000 //Max FLASH size - 512 Kbyte #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_END_ADDR (FLASH_START_ADDR + FLASH_MAX_SIZE) //FLASH end address #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BOOT_START_ADDR (FLASH_START_ADDR) //Bootloader start address #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BOOT_SIZE 0x00010000 //64 Kbyte for bootloader #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_USER_START_ADDR (FLASH_BOOT_START_ADDR + FLASH_BOOT_SIZE) //User application start address #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_USER_SIZE 0x00032000 //200 Kbyte for user application #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_MSD_START_ADDR (FLASH_USER_START_ADDR + FLASH_USER_SIZE) //USB MSD start address #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_MSD_SIZE 0x00032000 //200 Kbyte for USB MASS Storage #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_OTHER_START_ADDR (FLASH_MSD_START_ADDR + FLASH_MSD_SIZE) //Other free memory start address #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_OTHER_SIZE (FLASH_END_ADDR - FLASH_OTHER_START_ADDR) //Free memory size</span></span></code> </pre> <br>  Having agreed on the division of memory into areas, it's time to figure out how it all will interact.  Draw a flowchart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ae3/dae/39f/ae3dae39ffa146ae91a9cac4a9b185c6.png" alt="image"></div><br>  According to this algorithm, the bootloader has two main modes, working independently of each other, but having a common resource - a piece of <font color="#a3d977"><b>MSD_MEM</b></font> memory.  However, even its use occurs at different points in time, which positively affects the stability of the bootloader and simplifies the programming and debugging process. <br><br><ol><li>  The first mode is responsible for receiving and storing user software in the <font color="#a3d977"><b>MSD_MEM area</b></font> , which is available as an external drive. <br><br></li><li>  The second mode checks <font color="#a3d977"><b>MSD_MEM</b></font> for the presence of a file named <b>‚ÄúAPP.BIN‚Äù</b> , checks its integrity, authenticity, and also moves to <font color="#ff8f80"><b>USER_MEM</b></font> if it is empty or if the firmware <b>‚ÄúAPP.BIN‚Äù is</b> more recent. </li></ol><br>  Consider each of the modes in more detail: <br><br><h3>  <font color="#cc0000">USB Mass Storage Device</font> </h3><br>  It starts immediately after entering <i>main ()</i> , if the corresponding launch condition is met, the button is pressed.  On my board, this is the upper slider of the on-off switch (which, by the way, is wound up on the legs of the MK <b>BOOT0</b> and <b>BOOT1 (PB2)</b> - this allows you to use the hardware UART loader MK if necessary). <br><br><div class="spoiler">  <b class="spoiler_title">int main (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Button_Config(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GPIO_ReadInputDataBit(BUTTON_PORT, BUTTON_PIN) == SET) <span class="hljs-comment"><span class="hljs-comment">//Bootloader or Mass Storage? { LED_RGB_Config(); USB_Config(); Interrupts_Config(); USB_Init(); while(TRUE); } //Bootloader mode }</span></span></code> </pre></div></div><br>  Work in the Mass Storage mode is taken from examples from STMicroelectronics ( <a href="http://www.st.com/en/embedded-software/stsw-stm32121.html">STM32_USB-FS-Device_Lib_V4.0.0</a> ), which can be downloaded from their website.  There we are shown how it is necessary (or vice versa, it is not necessary - the attitude to the libraries from ST among people is not always positive) to work with a microcontroller and a memory card connected via SDIO interface in USB MSD mode.  The example implements two Bulk In / Out Endpoint'a with a packet length of 64 bytes, as well as a set of necessary for the operation of SCSI commands.  We throw out functions related to SD cards or NAND memory (mass_mal.c / .h) from there and replace them with work from internal FLASH: <br><br><div class="spoiler">  <b class="spoiler_title">u16 MAL_Init (u8 lun)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAL_Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 lun)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lun) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: FLASH_Unlock(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_FAIL; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_OK; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">u16 MAL_Read (u8 lun, u32 memOffset, u32 * readBuff)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAL_Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 lun, u32 memOffset, u32 *readBuff)</span></span></span><span class="hljs-function"> </span></span>{ u32 i; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lun) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: LED_RGB_EnableOne(LED_GREEN); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MassBlockSize[<span class="hljs-number"><span class="hljs-number">0</span></span>]; i += SIZE_OF_U32) { readBuff[i / SIZE_OF_U32] = *((<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32*)(FLASH_MSD_START_ADDR + memOffset + i)); } LED_RGB_DisableOne(LED_GREEN); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_FAIL; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_OK; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">u16 MAL_Write (u8 lun, u32 memOffset, u32 * writeBuff)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAL_Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 lun, u32 memOffset, u32 *writeBuff)</span></span></span><span class="hljs-function"> </span></span>{ u32 i; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lun) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: LED_RGB_EnableOne(LED_RED); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(FLASH_GetStatus() != FLASH_COMPLETE); FLASH_ErasePage(FLASH_MSD_START_ADDR + memOffset); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MassBlockSize[<span class="hljs-number"><span class="hljs-number">0</span></span>]; i += SIZE_OF_U32) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(FLASH_GetStatus() != FLASH_COMPLETE); FLASH_ProgramWord(FLASH_MSD_START_ADDR + memOffset + i, writeBuff[i / SIZE_OF_U32]); } LED_RGB_DisableOne(LED_RED); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_FAIL; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAL_OK; }</code> </pre></div></div><br>  If everything is done correctly, when connected, the computer will identify our product as a USB Mass Storage Device and will offer to format it, because  In the area of <font color="#a3d977"><b>MSD_MEM there</b></font> is garbage.  It is worth noting that in this mode of operation, the MC is simply an intermediary between the host and FLASH memory, and the operating system independently decides what data and at what addresses will be stored on our drive. <br><br>  Let's format the disk and see how it affected the <font color="#a3d977"><b>MSD_MEM area</b></font> : <br><br><img src="https://habrastorage.org/files/10f/d0f/a4b/10fd0fa4b9bb4a07a8a5044214a58ab1.PNG" alt="image"><br><br>  The volume is the same, the size of the Windows sector has determined the correct, the zero sector is bootable, the location in memory corresponds to what was intended.  Files are written, read, do not disappear after turning off the power - a full-fledged flash drive with 200 Kbyte! <br><br><h3>  <font color="#cc0000">Bootloader</font> </h3><br>  Run if firmware update is not required.  That is, the normal operation of the device.  In it, we have to perform several basic actions necessary for the successful launch of user software.  Basic - because if necessary, you can supplement the work of the bootloader with all sorts of features, such as encryption, integrity checking, debugging messages, etc. <br><br>  Suppose we have already created using Windows a file system on a USB drive and loaded the necessary software.  Now it would be nice to see the contents of the carrier with the ‚Äúeyes‚Äù of the MK, which means we are going to visit fellow ChaN for <a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS</a> (a module of a simple FAT file system designed for small embedded systems on microcontrollers).  Download, throw in the project, register the function of reading the necessary data from the disk: <br><br><div class="spoiler">  <b class="spoiler_title">DRESULT disk_read (BYTE pdrv, BYTE * buff, DWORD sector, UINT count)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disk_read</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BYTE pdrv, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE *buff, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Data buffer to store read data */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DWORD sector, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Sector address in LBA */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UINT count </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Number of sectors to read */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ u32 i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count * SECTOR_SIZE; i++) { buff[i] = *((<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u8*)(FLASH_MSD_START_ADDR + sector * SECTOR_SIZE + i)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RES_OK; }</code> </pre></div></div><br>  <i>disk_write () is</i> not needed and is left blank, because the mounted file system is Read Only.  This can also be set in the <i>ffconf.h</i> configuration file, additionally disabling all unnecessary and unused functions. <br><br>  Then everything is more or less obvious: we mount the file system, open the firmware file, and start reading.  Initially, it was implemented in such a way that the main storage location of the firmware is <font color="#a3d977"><b>MSD_MEM</b></font> , and the microcontroller overwrites its FLASH memory each time it is turned on.  No firmware - debug message of the absence and <i>while (TRUE)</i> .  There is a firmware - we throw it in <font color="#ff8f80"><b>USER_MEM</b></font> .  However, the obvious disadvantage of this solution is that the resource of erasing / writing FLASH memory has a limit and it would be foolish to gradually and consciously kill the product. <br><br>  Therefore, we compare <b>"APP.BIN"</b> and <font color="#ff8f80"><b>USER_MEM</b></font> , stupidly, byte by byte.  Perhaps a comparison of the hash sums of the two arrays would look more elegant solution, but certainly not the fastest.  Let's look again at <i>main ()</i> : <br><br><div class="spoiler">  <b class="spoiler_title">int main (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Button_Config(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GPIO_ReadInputDataBit(BUTTON_PORT, BUTTON_PIN) == SET) <span class="hljs-comment"><span class="hljs-comment">//Bootloader or Mass Storage? { //USB MSD mode } FATFS_Status = f_mount(&amp;FATFS_Obj, "0", 1); if(FATFS_Status == FR_OK) { FILE_Status = f_open(&amp;appFile, "/APP.BIN", FA_READ); if(FILE_Status == FR_OK) { appSize = f_size(&amp;appFile); for(i = 0; i &lt; appSize; i++) //Byte-to-byte compare files in MSD_MEM and USER_MEM { f_read(&amp;appFile, &amp;appBuffer, 1, &amp;readBytes); if(*((volatile u8*)(FLASH_USER_START_ADDR + i)) != appBuffer[0]) { //if byte of USER_MEM != byte of MSD_MEM break; } } if(i != appSize)//=&gt; was done "break" instruction in for(;;) cycle =&gt; new firmware in MSD_FLASH { CopyAppToUserMemory(); } FILE_Status = f_close(&amp;appFile); FATFS_Status = f_mount(NULL, "0", 1); PeriphDeInit(); GoToUserApp(); } else //if FILE_Status != FR_OK { if(FILE_Status == FR_NO_FILE) { //No file error } else //if FILE_Status != FR_NO_FILE { //Other error } FATFS_Status = f_mount(NULL, "0", 1); while(TRUE); } } else //FATFS_Status != FR_OK { //FatFS mount error while(TRUE); } }</span></span></code> </pre></div></div><br>  If during the comparison process we did not reach the end of the cycle, then the firmware is different and it's time to update <font color="#ff8f80"><b>USER_MEM</b></font> with <i>CopyAppToUserMemory ()</i> .  Well, and then it would be nice to destroy the traces of the bootloader by calling <i>PeriphDeInit ()</i> and then <i>GoToUserApp ()</i> .  But this is a bit later, but for now - the copying process: <br><br><div class="spoiler">  <b class="spoiler_title">void CopyAppToUserMemory (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyAppToUserMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ f_lseek(&amp;appFile, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Go to the fist position of file appTailSize = appSize % APP_BLOCK_TRANSFER_SIZE; appBodySize = appSize - appTailSize; appAddrPointer = 0; for(i = 0; i &lt; ((appSize / FLASH_PAGE_SIZE) + 1); i++) //Erase n + 1 pages for new application { while(FLASH_GetStatus() != FLASH_COMPLETE); FLASH_ErasePage(FLASH_USER_START_ADDR + i * FLASH_PAGE_SIZE); } for(i = 0; i &lt; appBodySize; i += APP_BLOCK_TRANSFER_SIZE) { /* * For example, size of File1 = 1030 bytes * File1 = 2 * 512 bytes + 6 bytes * "body" = 2 * 512, "tail" = 6 * Let's write "body" and "tail" to MCU FLASH byte after byte with 512-byte blocks */ f_read(&amp;appFile, appBuffer, APP_BLOCK_TRANSFER_SIZE, &amp;readBytes); //Read 512 byte from file for(j = 0; j &lt; APP_BLOCK_TRANSFER_SIZE; j += SIZE_OF_U32) //write 512 byte to FLASH { while(FLASH_GetStatus() != FLASH_COMPLETE); FLASH_ProgramWord(FLASH_USER_START_ADDR + i + j, *((volatile u32*)(appBuffer + j))); } appAddrPointer += APP_BLOCK_TRANSFER_SIZE; //pointer to current position in FLASH for write } f_read(&amp;appFile, appBuffer, appTailSize, &amp;readBytes); //Read "tail" that &lt; 512 bytes from file while((appTailSize % SIZE_OF_U32) != 0) //if appTailSize MOD 4 != 0 (seems not possible, but still...) { appTailSize++; //increase the tail to a multiple of 4 appBuffer[appTailSize - 1] = 0xFF; //and put 0xFF in this tail place } for(i = 0; i &lt; appTailSize; i += SIZE_OF_U32) //write "tail" to FLASH { while(FLASH_GetStatus() != FLASH_COMPLETE); FLASH_ProgramWord(FLASH_USER_START_ADDR + appAddrPointer + i, *((volatile u32*)(appBuffer + i))); } }</span></span></code> </pre></div></div><br>  Copy will be in blocks of 512 bytes.  512 - because I saw somewhere that when the buffer size is larger than this value, <i>f_read ()</i> can mess up.  I checked this moment - everything worked for me and with a larger buffer.  But just in case, left 512 - why not?  We save RAM, and it does not affect the speed, moreover, it is performed once - at the moment the device is turned on and only under the condition that it is time to update the firmware. <br><br>  Pre-erase in FLASH memory place under the file.  The size of the erased area is equal to the number of pages in memory, which will be fully occupied by <b>‚ÄúAPP.BIN‚Äù</b> + one more (which is not completely).  And also, virtually we beat the firmware file on ‚Äúbody‚Äù and ‚Äútail‚Äù, where ‚Äúbody‚Äù is the maximum possible piece of the file, which includes an integer number of blocks of 512 bytes, and ‚Äútail‚Äù is everything else. <br><br>  It seems that all binary firmware files are multiples of 4th bytes.  I wasn‚Äôt sure about that (and still), so just in case - if the firmware is not a multiple of <i>sizeof (u32)</i> - we supplement it with 0xFF bytes.  I repeat: it seems that this does not need to be done - but the operation is harmless for multiple <i>sizeof (u32)</i> binaries, so let's leave it. <br><br><h3>  <font color="#cc0000">Hello, User Application!</font> </h3><br>  Getting close.  We deinitialize all the used peripherals with the <i>PeriphDeInit ()</i> function (and there is almost nothing at all - GPIO for the mode select button and, if desired, the UART for outputting debug messages; no interrupts are used). <br><br>  The final life stage of the bootloader is the beginning of the user firmware: <br><br><div class="spoiler">  <b class="spoiler_title">void GoToUserApp (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToUserApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ u32 appJumpAddress; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*GoToApp)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); appJumpAddress = *((<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32*)(FLASH_USER_START_ADDR + <span class="hljs-number"><span class="hljs-number">4</span></span>)); GoToApp = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>))appJumpAddress; SCB-&gt;VTOR = FLASH_USER_START_ADDR; __set_MSP(*((<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32*) FLASH_USER_START_ADDR)); <span class="hljs-comment"><span class="hljs-comment">//stack pointer (to RAM) for USER app in this address GoToApp(); }</span></span></code> </pre></div></div><br>  Only 5 lines, but how much is happening! <br><br>  In the ARM Cortex M3 core, when an exception occurs, the corresponding handler is called for it.  To determine the starting address of the exception handler, a vector table mechanism is used.  <b>The vector table</b> is an array of data words within system memory, each of which is the starting address of one type of exception.  The table is moved and the movement is controlled by a special VTOR register in SCB (System Control Block) (In the manual, it sounds cooler, but I broke down: <i>The vector table is relocatable, and the relocation is controlled by the NVIC</i> ).  After RESET, the value of this register is 0, that is, the vector table lies at the address 0x0 (for the STM32F103 in the startup file, we independently move it to 0x08000000).  And what is very important for us, the order is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d70/9a1/22f/d709a122faaf4dc599af1d88bd2a3341.JPG" alt="image"></div><br><ul><li>  The value lying at 0x04 is the place in the program where we get after the <b>reset-</b> exception </li><li>  The value at 0x00 is the initial value of the <b>Main Stack Pointer</b> for the user application. </li></ul><br>  All this together, plus a bit of magic with a pointer to the function, and Alice jumps after the rabbit. <br><br>  Now check if it works at all.  Let's write a simple LED blinking program with cycles in <i>main ()</i> and a couple of interrupts (SysTick and TIM4): <br><br><div class="spoiler">  <b class="spoiler_title">Test programm for MSD bootloader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_gpio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_rcc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_tim.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"misc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYSCLK_FREQ 72000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_1_KHz ((SYSCLK_FREQ / 1000) - 1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_1_MHz ((SYSCLK_FREQ / 1000000) - 1) volatile u32 i, j; int main(void) { GPIO_InitTypeDef GPIO_Options; NVIC_InitTypeDef NVIC_Options; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); GPIO_Options.GPIO_Pin = GPIO_Pin_7; GPIO_Options.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Options.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOA, &amp;GPIO_Options); GPIO_Options.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1; GPIO_Options.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Options.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB, &amp;GPIO_Options); GPIOB-&gt;BSRR = GPIO_Pin_0 | GPIO_Pin_1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//LEDs off GPIOA-&gt;BSRR = GPIO_Pin_7 TIM4-&gt;PSC = 720 - 1; //clock prescaller TIM4-&gt;ARR = 60000 - 1; //auto-reload value TIM4-&gt;CR1 |= TIM_CounterMode_Up;//upcounter TIM4-&gt;DIER |= TIM_IT_Update; //update interrupt enable TIM4-&gt;CR1 |= TIM_CR1_CEN; //timer start NVIC_Options.NVIC_IRQChannel = TIM4_IRQn; NVIC_Options.NVIC_IRQChannelPreemptionPriority = 0; NVIC_Options.NVIC_IRQChannelSubPriority = 0; NVIC_Options.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_Options); SysTick_Config(TICK_1_KHz); while(1) { __disable_irq(); GPIOB-&gt;BSRR = GPIO_Pin_0 | GPIO_Pin_1; //Off for(i = 0; i &lt; 10; i++) { for(j = 0; j &lt; 500000; j++); //Pause GPIOA-&gt;ODR ^= GPIO_Pin_7; //Reverse } GPIOA-&gt;BSRR = GPIO_Pin_7; //Off __enable_irq(); for(i = 0; i &lt; 5000000; i++); //Pause } } void SysTick_Handler(void) { volatile static u32 LED_Counter = 0; if(LED_Counter &gt;= 40) { GPIOB-&gt;ODR ^= GPIO_Pin_1; //Reverse LED_Counter = 0; } LED_Counter++; } void TIM4_IRQHandler() { TIM4-&gt;SR = ~TIM_SR_UIF; GPIOB-&gt;ODR ^= GPIO_Pin_0; //Reverse }</span></span></span></span></code> </pre></div></div><br>  By the way, you need to remember to fix a couple of things in the project, without which nothing will work: <br><br><ol><li>  Remove from <i>SystemInit () the</i> operation of moving the vector table by some value ( <b>// SCB-&gt; VTOR = FLASH_BASE</b> ).  Bootloader moves it yourself before moving to the user program! <br><br></li><li>  In the <i>Linker script,</i> change the beginning of our program from the address 0x08000000 to the address of the beginning <font color="#ff8f80"><b>USER_MEM</b></font> ( <b>FLASH (rx): ORIGIN = 0x08010000, LENGTH = 200K</b> ); </li></ol><br>  And this is how this code is executed (well, maybe not everyone has seen the LEDs blink ...): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jStylXAuE-E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  And this is how the download log of this firmware in the MK via the bootloader looks like: <br><br><div class="spoiler">  <b class="spoiler_title">UART log message</b> <div class="spoiler_text">  --------------- START LOG --------------- <br><br>  BOOT_MEM start addr: 0x08000000 <br>  BOOT_MEM size: 64K <br>  USER_MEM start addr: 0x08010000 <br>  USER_MEM size: 200K <br>  MSD_MEM start addr: 0x08042000 <br>  MSD_MEM size: 200K <br>  OTHER_MEM start addr: 0x08074000 <br>  OTHER_MEM size: 48K <br><br>  Total memory size: 512K <br><br>  BOOTLOADER Mode ... <br>  FAT FS mount status = 0 <br>  Application file open status = 0 <br>  Difference between MSD_MEM and USER_MEM: 4 byte from 2212 byte <br>  Start copy MSD_MEM to USER_MEM: <br><br>  File size = 2212 byte <br>  Body size = 2048 byte <br>  Tail size = 164 byte <br><br>  Sector 0 (0x08010000 - 0x08010800) erased <br>  Sector 1 (0x08010800 - 0x08011000) erased <br><br>  0 cycle, read status = 0, 512 byte read <br>  512 byte programmed: 0x08010000 - 0x08010200 <br>  1 cycle, read status = 0, 512 byte read <br>  512 byte programmed: 0x08010200 - 0x08010400 <br>  2 cycle, read status = 0, 512 byte read <br>  512 byte programmed: 0x08010400 - 0x08010600 <br>  3 cycle, read status = 0, 512 byte read <br>  512 byte programmed: 0x08010600 - 0x08010800 <br>  Tail read: read status = 0, 164 byte read, size of tail = 164 <br>  New size of tail = 164 <br>  164 byte programmed: 0x08010800 - 0x080108A4 <br><br>  File close status = 0 <br>  FAT FS unmount status = 0 <br>  DeInit peripheral and jump to 0x08010561 ... <br></div></div><br>  Let's sum up.  The bootloader turned out!  And even works.  With the output of debug messages in the UART, it occupies 31,684 bytes of FLASH memory, without - 25,608 bytes.  Not so little, if you also consider how much memory you need to give for Mass Storage disk.  Sources and working draft (Atollic TrueSTUDIO) can be viewed on <a href="https://bitbucket.org/Katbert/stm32-usb-msd-bootloader">Bitbucket</a> . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/309218/">https://habr.com/ru/post/309218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309208/index.html">Chimeras of office telephony: talking about FMC</a></li>
<li><a href="../309210/index.html">Interpolation of closed curves</a></li>
<li><a href="../309212/index.html">Frontend: Development and Support (+ vote)</a></li>
<li><a href="../309214/index.html">Magic build project on WordPress using package managers and a file</a></li>
<li><a href="../309216/index.html">Huawei KunLun server - our testing</a></li>
<li><a href="../309220/index.html">Blind programmer and forged chains</a></li>
<li><a href="../309222/index.html">How to build a simple Java program using Maven</a></li>
<li><a href="../309224/index.html">And a little more about the Fujitsu World Tour</a></li>
<li><a href="../309226/index.html">RxConnect - when React meets RxJS</a></li>
<li><a href="../309228/index.html">Asynchronous (and not so) data loading in Unreal Engine 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>