<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic do-it-yourself java code compilation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about our implementation of hot deploy - fast delivery of Java code changes to a running application. 

 First, a little h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic do-it-yourself java code compilation</h1><div class="post__text post__text-html js-mediator-article">  In this article I will talk about our implementation of hot deploy - fast delivery of Java code changes to a running application. <br><br>  First, a little history.  We have been doing corporate applications on the <a href="https://www.cuba-platform.com/">CUBA</a> platform for several years.  They are very different in size and functionality, but they all look alike in one - they have a lot of user interface. <br><br>  At some point, we realized that developing the user interface by constantly rebooting the server is extremely tiring.  Using Hot Swap severely restricts (you cannot add or rename fields, class methods).  Each server reboot took at least 10 seconds of time, plus the need to re-login and go to the screen that you are developing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I had to think about the full hot deploy.  Under the cut - our solution to the problem with the code and demo application. <br><a name="habracut"></a><br><h2>  Prerequisites </h2><br>  Designing screens in the CUBA platform involves creating a declarative screen XML descriptor that specifies the name of the controller class.  Thus, the screen controller class is always obtained by the full name. <br><br>  It should also be noted that in most cases the screen controller is a thing in itself, that is, it is not used by other controllers or simply by classes (this happens, but not often). <br><br>  At first we tried to use Groovy to solve the problem of hot deploy.  We started uploading the source Groovy code to the server and getting the classes of screen controllers via GroovyClassLoader.  This solved the problem with the speed of delivering changes to the server, but created many new problems: at that time Groovy was relatively poorly supported by IDE, dynamic typing allowed you to write non-compiled code imperceptibly, inexperienced developers regularly tried to write the code as ugly as possible, simply because Groovy allows you to do so. <br><br>  Given that there were hundreds of screens in the projects, each of which could potentially break at any time, we had to abandon the use of Groovy in screen controllers. <br><br>  Then we thought hard.  We wanted to get the benefits of instant delivery of the code to the server (without rebooting) and at the same time not to risk much the quality of the code.  A feature appeared in Java 1.6 - ToolProvider.getSystemJavaCompiler () ( <a href="http://www.ibm.com/developerworks/java/library/j-jcomp/index.html">described on IBM.com</a> ).  This object allows you to get objects of type java.lang.Class from source code.  We decided to try. <br><br><h2>  Implementation </h2><br>  We decided to make our classifier look like GroovyClassLoader.  It caches the compiled classes, and each time the class is accessed it checks whether the source code of the class has been updated in the file system.  If updated, the compilation starts and the results are cached. <br><br>  You can see the detailed implementation of the classifier by clicking on the <a href="https://github.com/Haulmont/mvcclassloader/tree/master/src/main/java/com/haulmont/javacl">link</a> . <br><br>  I will focus on the key points of implementation in the article. <br><br>  Let's start with the main class - JavaClassLoader. <br><br><div class="spoiler">  <b class="spoiler_title">Abbreviated JavaClassLoader Code</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaClassLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLClassLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextAware</span></span></span><span class="hljs-class"> </span></span>{ ..... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, TimestampClass&gt; compiled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConcurrentHashMap&lt;String, Lock&gt; locks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProxyClassLoader proxyClassLoader; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SourceProvider sourceProvider; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> XmlWebApplicationContext applicationContext; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> refreshing = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ..... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BeansException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.applicationContext = (XmlWebApplicationContext) applicationContext; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.applicationContext.setClassLoader(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String fullClassName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ClassNotFoundException </span></span>{ String containerClassName = StringUtils.substringBefore(fullClassName, <span class="hljs-string"><span class="hljs-string">"$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { lock(containerClassName); Class clazz; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sourceProvider.getSourceFile(containerClassName).exists()) { clazz = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.loadClass(fullClassName, resolve); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } CompilationScope compilationScope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilationScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, containerClassName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!compilationScope.compilationNeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getTimestampClass(fullClassName).clazz; } String src; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { src = sourceProvider.getSourceString(containerClassName); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassNotFoundException(<span class="hljs-string"><span class="hljs-string">"Could not load java sources for class "</span></span> + containerClassName); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { log.debug(<span class="hljs-string"><span class="hljs-string">"Compiling "</span></span> + containerClassName); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DiagnosticCollector&lt;JavaFileObject&gt; errs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticCollector&lt;&gt;(); SourcesAndDependencies sourcesAndDependencies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SourcesAndDependencies(rootDir, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); sourcesAndDependencies.putSource(containerClassName, src); sourcesAndDependencies.collectDependencies(containerClassName); Map&lt;String, CharSequence&gt; sourcesForCompilation = sourcesAndDependencies.collectSourcesForCompilation(containerClassName); <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Map&lt;String, Class&gt; compiledClasses = createCompiler().compile(sourcesForCompilation, errs); Map&lt;String, TimestampClass&gt; compiledTimestampClasses = wrapCompiledClasses(compiledClasses); compiled.putAll(compiledTimestampClasses); linkDependencies(compiledTimestampClasses, sourcesAndDependencies.dependencies); clazz = compiledClasses.get(fullClassName); updateSpringContext(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { proxyClassLoader.restoreRemoved(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { proxyClassLoader.cleanupRemoved(); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { unlock(containerClassName); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateSpringContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!refreshing) { refreshing = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; applicationContext.refresh(); refreshing = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } ..... <span class="hljs-comment"><span class="hljs-comment">/** * Add dependencies for each class and ALSO add each class to dependent for each dependency */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkDependencies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, TimestampClass&gt; compiledTimestampClasses, Multimap&lt;String, String&gt; dependecies)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;String, TimestampClass&gt; entry : compiledTimestampClasses.entrySet()) { String className = entry.getKey(); TimestampClass timestampClass = entry.getValue(); Collection&lt;String&gt; dependencyClasses = dependecies.get(className); timestampClass.dependencies.addAll(dependencyClasses); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String dependencyClassName : timestampClass.dependencies) { TimestampClass dependencyClass = compiled.get(dependencyClassName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependencyClass != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { dependencyClass.dependent.add(className); } } } } ..... }</code> </pre> <br></div></div><br>  When calling loadClass, we perform the following actions: <br><ul><li>  Check if the source code of this class is in the file system, if not, call the inherited loadClass </li><li>  We check if compilation is needed - for example, the file with the source code of the class has been changed.  Here you need to remember that we are watching not only the change in 1 file with the class, but also for all dependencies </li><li>  We collect dependencies - everything that depends on the class that we are going to compile, as well as everything that it depends on </li><li>  We check every dependency for the need to compile, throw away those that do not need to compile </li><li>  Compile the source </li><li>  We put results in a cache </li><li>  Update the Spring context if necessary. </li><li>  We return the requested class </li></ul><br>  If you pay attention to the <i>updateSpringContext ()</i> method, you will notice that we update the Spring context after each load of classes.  This was done for the demo application; in a real project, this frequent context update is usually not required. <br><br>  Someone may have a question - how do we determine what the class depends on?  The answer is simple - we parse the import section.  The following is the code that does this. <br><br><div class="spoiler">  <b class="spoiler_title">Code collection of dependencies.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourcesAndDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String IMPORT_PATTERN = <span class="hljs-string"><span class="hljs-string">"import (.+?);"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String IMPORT_STATIC_PATTERN = <span class="hljs-string"><span class="hljs-string">"import static (.+)\\..+?;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHOLE_PACKAGE_PLACEHOLDER = <span class="hljs-string"><span class="hljs-string">".*"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, CharSequence&gt; sources = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Multimap&lt;String, String&gt; dependencies = HashMultimap.create(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SourceProvider sourceProvider; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JavaClassLoader javaClassLoader; SourcesAndDependencies(String rootDir, JavaClassLoader javaClassLoader) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sourceProvider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SourceProvider(rootDir); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.javaClassLoader = javaClassLoader; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, CharSequence sourceCode)</span></span></span><span class="hljs-function"> </span></span>{ sources.put(name, sourceCode); } <span class="hljs-comment"><span class="hljs-comment">/** * Recursively collects all dependencies for class using imports * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> java.io.IOException */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collectDependencies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String className)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ CharSequence src = sources.get(className); List&lt;String&gt; importedClassesNames = getDynamicallyLoadedImports(src); String currentPackageName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, className.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)); importedClassesNames.addAll(sourceProvider.getAllClassesFromPackage(currentPackageName));<span class="hljs-comment"><span class="hljs-comment">//all src from current package for (String importedClassName : importedClassesNames) { if (!sources.containsKey(importedClassName)) { addSource(importedClassName); addDependency(className, importedClassName); collectDependencies(importedClassName); } else { addDependency(className, importedClassName); } } } /** * Decides what to compile using CompilationScope (hierarchical search) * Find all classes dependent from those we are going to compile and add them to compilation as well */ public Map&lt;String, CharSequence&gt; collectSourcesForCompilation(String rootClassName) throws ClassNotFoundException, IOException { Map&lt;String, CharSequence&gt; dependentSources = new HashMap&lt;&gt;(); collectDependent(rootClassName, dependentSources); for (String dependencyClassName : sources.keySet()) { CompilationScope dependencyCompilationScope = new CompilationScope(javaClassLoader, dependencyClassName); if (dependencyCompilationScope.compilationNeeded()) { collectDependent(dependencyClassName, dependentSources); } } sources.putAll(dependentSources); return sources; } /** * Find all dependent classes (hierarchical search) */ private void collectDependent(String dependencyClassName, Map&lt;String, CharSequence&gt; dependentSources) throws IOException { TimestampClass removedClass = javaClassLoader.proxyClassLoader.removeFromCache(dependencyClassName); if (removedClass != null) { for (String dependentName : removedClass.dependent) { dependentSources.put(dependentName, sourceProvider.getSourceString(dependentName)); addDependency(dependentName, dependencyClassName); collectDependent(dependentName, dependentSources); } } } private void addDependency(String dependent, String dependency) { if (!dependent.equals(dependency)) { dependencies.put(dependent, dependency); } } private void addSource(String importedClassName) throws IOException { sources.put(importedClassName, sourceProvider.getSourceString(importedClassName)); } private List&lt;String&gt; unwrapImportValue(String importValue) { if (importValue.endsWith(WHOLE_PACKAGE_PLACEHOLDER)) { String packageName = importValue.replace(WHOLE_PACKAGE_PLACEHOLDER, ""); if (sourceProvider.directoryExistsInFileSystem(packageName)) { return sourceProvider.getAllClassesFromPackage(packageName); } } else if (sourceProvider.sourceExistsInFileSystem(importValue)) { return Collections.singletonList(importValue); } return Collections.emptyList(); } private List&lt;String&gt; getDynamicallyLoadedImports(CharSequence src) { List&lt;String&gt; importedClassNames = new ArrayList&lt;&gt;(); List&lt;String&gt; importValues = getMatchedStrings(src, IMPORT_PATTERN, 1); for (String importValue : importValues) { importedClassNames.addAll(unwrapImportValue(importValue)); } importValues = getMatchedStrings(src, IMPORT_STATIC_PATTERN, 1); for (String importValue : importValues) { importedClassNames.addAll(unwrapImportValue(importValue)); } return importedClassNames; } private List&lt;String&gt; getMatchedStrings(CharSequence source, String pattern, int groupNumber) { ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); Pattern importPattern = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE); Matcher matcher = importPattern.matcher(source); while (matcher.find()) { result.add(matcher.group(groupNumber)); } return result; } }</span></span></code> </pre><br></div></div><br>  The attentive reader will ask - where is the compilation itself?  Below is its code. <br><br><div class="spoiler">  <b class="spoiler_title">Abbreviated Code CharSequenceCompiler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequenceCompiler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ ..... <span class="hljs-comment"><span class="hljs-comment">// The compiler instance that this facade uses. private final JavaCompiler compiler; public CharSequenceCompiler(ProxyClassLoader loader, Iterable&lt;String&gt; options) { compiler = ToolProvider.getSystemJavaCompiler(); if (compiler == null) { throw new IllegalStateException("Cannot find the system Java compiler. " + "Check that your class path includes tools.jar"); } ..... } ..... public synchronized Map&lt;String, Class&lt;T&gt;&gt; compile( final Map&lt;String, CharSequence&gt; classes, final DiagnosticCollector&lt;JavaFileObject&gt; diagnosticsList) throws CharSequenceCompilerException { List&lt;JavaFileObject&gt; sources = new ArrayList&lt;JavaFileObject&gt;(); for (Map.Entry&lt;String, CharSequence&gt; entry : classes.entrySet()) { String qualifiedClassName = entry.getKey(); CharSequence javaSource = entry.getValue(); if (javaSource != null) { final int dotPos = qualifiedClassName.lastIndexOf('.'); final String className = dotPos == -1 ? qualifiedClassName : qualifiedClassName.substring(dotPos + 1); final String packageName = dotPos == -1 ? "" : qualifiedClassName .substring(0, dotPos); final JavaFileObjectImpl source = new JavaFileObjectImpl(className, javaSource); sources.add(source); // Store the source file in the FileManager via package/class // name. // For source files, we add a .java extension javaFileManager.putFileForInput(StandardLocation.SOURCE_PATH, packageName, className + JAVA_EXTENSION, source); } } // Get a CompliationTask from the compiler and compile the sources final JavaCompiler.CompilationTask task = compiler.getTask(null, javaFileManager, diagnostics, options, null, sources); final Boolean result = task.call(); if (result == null || !result) { StringBuilder cause = new StringBuilder("\n"); for (Diagnostic d : diagnostics.getDiagnostics()) { cause.append(d).append(" "); } throw new CharSequenceCompilerException("Compilation failed. Causes: " + cause, classes .keySet(), diagnostics); } try { // For each class name in the input map, get its compiled // class and put it in the output map Map&lt;String, Class&lt;T&gt;&gt; compiled = new HashMap&lt;String, Class&lt;T&gt;&gt;(); for (String qualifiedClassName : classLoader.classNames()) { final Class&lt;T&gt; newClass = loadClass(qualifiedClassName); compiled.put(qualifiedClassName, newClass); } return compiled; } catch (ClassNotFoundException e) { throw new CharSequenceCompilerException(classes.keySet(), e, diagnostics); } catch (IllegalArgumentException e) { throw new CharSequenceCompilerException(classes.keySet(), e, diagnostics); } catch (SecurityException e) { throw new CharSequenceCompilerException(classes.keySet(), e, diagnostics); } } ...... }</span></span></code> </pre><br></div></div><br><h2>  How can this be useful? </h2><br>  For this article, I wrote a small <a href="https://github.com/Haulmont/mvcclassloader">application on Spring MVC</a> , in which I used our classifier. <br>  This application demonstrates how you can benefit from dynamic compilation. <br><br>  The application declared controller WelcomeController and Spring-bean SomeBean.  The controller uses the SomeBean.get () method and delivers the result to the presentation level, where it is displayed. <br><br>  Now I will demonstrate how with our classifier we can change the implementation of SomeBeanImpl and WelcomeController without stopping the application.  First, let's deploy the application (you will need <a href="https://gradle.org/">gradle</a> for the build) and go to <a href="http://localhost/">localhost</a> : 8080 / mvcclassloader / hello. <br><br>  The answer is: <i><b>Hello from WelcomeController.</b></i>  <i><b>Version: not reloaded.</b></i> <br><br>  Now let's slightly change the implementation of SomeBeanImpl. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(<span class="hljs-string"><span class="hljs-string">"someBean"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeBeanImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeBean</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"reloaded"</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  not reloaded } }</span></span></code> </pre><br><br>  Put the file on the server in the folder tomcat / conf / com / haulmont / mvcclassloader (the folder in which the classifier looks for source code is configured in the file mvc-dispatcher-servlet.xml).  Now you need to call the loading classes.  For this, I created a separate controller - ReloadController.  In reality, it is possible to detect changes in different ways, but for demonstration this will do.  ReloadController reloads 2 classes in our application.  You can call the controller by clicking on the link <a href="http://localhost/">localhost</a> : 8080 / mvcclassloader / reload. <br><br>  After that, going back to <a href="http://localhost/">localhost</a> : 8080 / mvcclassloader / hello, we will see: <br>  <b><i>Hello from WelcomeController.</i></b>  <b><i>Version: reloaded.</i></b> <b><br></b> <br>  But that is not all.  We can also change the WebController code.  Let's do that. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span>(<span class="hljs-string"><span class="hljs-string">"welcomeController"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WelcomeController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> SomeBean someBean; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/hello"</span></span>, method = RequestMethod.GET) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ModelAndView </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">welcome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelAndView(); model.setViewName(<span class="hljs-string"><span class="hljs-string">"index"</span></span>); model.addObject(<span class="hljs-string"><span class="hljs-string">"version"</span></span>, someBean.get() + <span class="hljs-string"><span class="hljs-string">" a bit more"</span></span>);<span class="hljs-comment"><span class="hljs-comment">// a bit more return model; } }</span></span></code> </pre><br><br>  By calling the reload classes and going to the main controller, we will see: <br>  <b><i>Hello from WelcomeController.</i></b>  <b><i>Version: reloaded a bit more.</i></b> <b><i><br></i></b> <br>  In this application, the classloader completely reloads the context after each class compilation.  For large applications, this may take significant time, so there is another way - you can change in the context only those classes that have been compiled.  Such an opportunity gives us DefaultListableBeanFactory.  For example, in our CUBA platform, the replacement of classes in Spring-context is implemented as follows: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateSpringContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Class&gt; classes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (beanFactory != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Class clazz : classes) { Service serviceAnnotation = (Service) clazz.getAnnotation(Service.class); ManagedBean managedBeanAnnotation = (ManagedBean) clazz.getAnnotation(ManagedBean.class); Component componentAnnotation = (Component) clazz.getAnnotation(Component.class); Controller controllerAnnotation = (Controller) clazz.getAnnotation(Controller.class); String beanName = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceAnnotation != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { beanName = serviceAnnotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (managedBeanAnnotation != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { beanName = managedBeanAnnotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (componentAnnotation != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { beanName = componentAnnotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controllerAnnotation != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { beanName = controllerAnnotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringUtils.isNotBlank(beanName)) { GenericBeanDefinition beanDefinition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericBeanDefinition(); beanDefinition.setBeanClass(clazz); beanFactory.registerBeanDefinition(beanName, beanDefinition); } } } }</code> </pre><br>  The key here is the string <i>beanFactory.registerBeanDefinition (beanName, beanDefinition);</i> <br>  There is one subtlety here ‚Äî DefaultListableBeanFactory does not overload dependent bins by default, so we had to slightly refine it. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CubaDefaultListableBeanFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultListableBeanFactory</span></span></span><span class="hljs-class"> </span></span>{ ..... <span class="hljs-comment"><span class="hljs-comment">/** * Reset all bean definition caches for the given bean, * including the caches of beans that depends on it. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> beanName the name of the bean to reset */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetBeanDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span><span class="hljs-function"> </span></span>{ String[] dependentBeans = getDependentBeans(beanName); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.resetBeanDefinition(beanName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependentBeans != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String dependentBean : dependentBeans) { resetBeanDefinition(dependentBean); registerDependentBean(beanName, dependentBean); } } } }</code> </pre><br><br><h2>  How else can you quickly deliver changes to the server </h2><br>  There are several ways to deliver changes to a Java server application without restarting the server. <br><br>  The first way is of course the Hot Swap provided by the standard Java debugger.  It has obvious drawbacks - you cannot change the class structure (add, change methods and fields), it is very problematic to use it on ‚Äúcombat‚Äù servers. <br><br>  The second method is Hot Deploy provided by servlet containers.  You simply upload the war file to the server and the application starts again.  This method also has disadvantages.  First, you stop the application entirely, which means it will be unavailable for a while (the time it takes to deploy an application depends on its content and can take significant time).  Second, the entire project build may take significant time by itself.  Thirdly, you do not have the opportunity to control the point changes, if you make a mistake somewhere - you have to deploy the application again. <br><br>  The third method can be considered a variation of the second.  You can put class files in the web-inf / classes folder (for web applications) and they will override the classes available on the server.  This approach is fraught with the fact that it is possible to create a binary incompatibility with existing classes, and then part of the application may stop working. <br><br>  The fourth method is JRebel.  I heard that some use it even on the customer‚Äôs servers, but I myself would not do that.  At the same time, it is great for development.  He has the only negative - it costs quite a lot of money. <br><br>  The fifth way is Spring Loaded.  It works through javaagent.  It is free.  But it works only with Spring, and besides it does not allow changing class hierarchies, constructors, etc. <br><br>  And of course, there are still dynamically compiled languages ‚Äã‚Äã(for example, Groovy).  I wrote about them at the very beginning. <br><br><h2>  What are the strengths of our approach </h2><br><ul><li>  Delivery of changes is very fast, there is no reboot, no application unavailability </li><li>  You can arbitrarily change the structure of dynamically compiled classes (change class hierarchies, interfaces, etc.) </li><li>  You can always see what was changed (for example, using diff), since the source code lies on the server in open form. </li><li>  We have full control over the class replacement process, and if a new source code, for example, is not compiled, we can return the old version of the class. </li><li>  You can easily fix the bug right on the server (there are also such cases) </li><li>  It is very easy to implement in IDE the ability to deliver changes to the developer server (just by copying the source code) </li><li>  You do not spend a penny of money </li></ul><br><br>  Of course, there are drawbacks.  Complicated installation mechanism changes.  In the general case, it is necessary to build the application architecture in such a way that it allows changing the implementation on the fly (for example, not using constructors, but getting classes by name and creating objects using reflection).  The time taken to get classes from the classifier is slightly increased (due to the file system check). <br><br>  However, with the right approach, the advantages more than cover the disadvantages. <br><br>  In conclusion, I want to say that we have been using this approach in our applications for about 5 years.  It saved us a lot of time in development and a lot of nerves in correcting errors on combat servers. </div><p>Source: <a href="https://habr.com/ru/post/248981/">https://habr.com/ru/post/248981/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248971/index.html">Static analysis of PHP code on the example of symfony2</a></li>
<li><a href="../248973/index.html">27 years of Arctic ice in one minute</a></li>
<li><a href="../248975/index.html">Interval repetition on LinguaLeo</a></li>
<li><a href="../248977/index.html">Results of 2014: Windows threats and exploitation</a></li>
<li><a href="../248979/index.html">OpenMP Regions Analysis with Intel¬Æ VTune ‚Ñ¢ Amplifier XE</a></li>
<li><a href="../248983/index.html">How-to: Automate accounting tasks hosting provider</a></li>
<li><a href="../248985/index.html">CSS Auditing: Style Sheets Shouldn't Be Horrible</a></li>
<li><a href="../248987/index.html">CTB-Locker - a new modification of the FileCoder cryptographer</a></li>
<li><a href="../248991/index.html">Automatic Age Assessment System for Face Images</a></li>
<li><a href="../248993/index.html">Map of the latest photos of all people from these cities VK using VKScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>