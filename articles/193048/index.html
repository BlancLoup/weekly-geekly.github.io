<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unicode and .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator. On Habr√©, articles have been repeatedly published both on Unicode and on lines in .NET. However, there was no article about Unico...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unicode and .NET</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator.</i>  <i>On Habr√©, articles have been repeatedly published both on Unicode and on lines in .NET.</i>  <i>However, there was no article about Unicode in relation to .NET yet, so I decided to translate the article by the generally recognized .NET guru John Skit.</i>  <i>It closes the cycle I had promised from three articles by J. Skeet translations devoted to strings in .NET.</i>  <i>As always, I will be happy with comments and corrections.</i> <br><img src="https://habrastorage.org/storage3/c7e/a4e/87d/c7ea4e87d73a63f1822981de7ee001f4.png" align="right" alt="Unicode logo"><br><h3>  Introduction </h3><br>  The topic of this article is quite extensive, and do not expect from it a detailed and deep analysis of all the nuances.  If you think that you are well-versed in Unicode, encodings, etc., this article may be almost or even completely useless for you.  However, quite a few people do not understand the difference between binary and textual data ( <i>binary</i> and <i>text</i> ), or what character encoding is.  This article was written for such people.  Despite, in general, a superficial description, it touches upon some difficult points, however, this is done more so that the reader has an idea of ‚Äã‚Äãtheir existence, rather than to give detailed explanations and guidelines for action. <br><a name="habracut"></a><br><h3>  Resources </h3><br>  The links below are at least as useful as this article, and maybe more useful.  I myself used them when writing this article.  There are a lot of useful and high-quality materials in them, and if in this article you notice any inaccuracies, then these resources should be more accurate. <br><br><ul><li>  <a href="http://www.unicode.org/">The official website of the Unicode Consortium</a> .  The most complete and accurate source of information on Unicode, which contains answers to all your questions (although you should carefully search for useful information on the site).  Some of the links below lead to this site. </li><li>  <a href="http://www.unicode.org/glossary">Unicode Glossary</a> .  A dictionary with brief interpretations of many terms used in the discussion of character encoding, etc. </li><li>  <a href="http://www.unicode.org/faq">Unicode FAQ</a>  Answers to hundreds of common questions, divided into groups. </li><li>  <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">Unicode / Unix / Linux UTF-8 FAQ</a> .  Do not neglect this link, judging by its name - even if you are not on friendly terms with Unix / Linux, most of the information is very relevant to .NET. </li><li>  <a href="http://www.unicode.org/unicode/reports/tr17/">Unicode character encoding model</a> .  Provides more information about the exact interpretation of terms like "character encoding scheme", etc. </li><li>  <a href="http://www.joelonsoftware.com/articles/Unicode.html">Joel Spolsky.</a>  <a href="http://www.joelonsoftware.com/articles/Unicode.html">Mandatory minimum that every software developer should know about Unicode and character sets (No excuses are allowed)</a> .  An article that is somewhat similar to this one, but without an accent on .NET.  ( <a href="http://local.joelonsoftware.com/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D0%25BE%25D0%25BB%25D1%258E%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D1%2583%25D0%25BC,_%25D0%25BA%25D0%25BE%25D1%2582%25D0%25BE%25D1%2580%25D1%258B%25D0%25B9_%25D0%259A%25D0%25B0%25D0%25B6%25D0%25B4%25D1%258B%25D0%25B9_%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA_%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%259E%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%259E%25D0%25B1%25D1%258F%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE_%25D0%2594%25D0%25BE%25D0%25BB%25D0%25B6%25D0%25B5%25D0%25BD_%25D0%2597%25D0%25BD%25D0%25B0%25D1%2582%25D1%258C_%25D0%25BE_Unicode_%25D0%25B8_%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0%25D1%2585_%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B2">translation into Russian</a> , transfer to Habr√© <a href="http://habrahabr.ru/post/158639/">part 1</a> , <a href="http://habrahabr.ru/post/158895/">part 2</a> ) </li><li>  <a href="http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode">About the kindness of Unicode</a> .  Another introductory article worth reading. </li></ul><br><br><h3>  Binary and textual data are two different things. </h3><br>  Most modern programming languages ‚Äã‚Äã(like some old ones) draw a clear line between binary (binary) content and symbolic (or textual) content.  Although this difference is understood at the instinctive level, I still make the definition. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Binary (binary) data is a sequence of <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2582%25D0%25B5%25D1%2582_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">octets</a> (an octet consists of 8 bits) without any natural meaning or interpretation attached to it.  And even if there is an external ‚Äúinterpretation‚Äù of one or another set of octets as, say, an executable file or graphic image, the data itself is just a set of octets.  Further, instead of the term ‚Äúoctet,‚Äù I will use ‚Äúbyte,‚Äù although, to be precise, not every byte is an octet.  For example, there were computer architectures with 9-bit bytes.  However, in this context, such details are not very necessary, so that further by the term "byte" I will mean exactly 8-bit byte. <br><br>  Character (text) data is a sequence of characters. <br><br>  <a href="http://www.unicode.org/glossary/">The Unicode Glossary</a> defines a character as: <br><ol><li>  The smallest component of the written language containing semantic meaning;  indicates an abstract meaning and / or form, as opposed to special forms (such as <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D0%25B8%25D1%2584">glyphs</a> );  in code tables, some forms of visual presentation of symbols are of great importance for the reader to understand them. </li><li>  A synonym for an abstract symbol (see Definition D3 in Section 3.3, Characters and Coded Representations). </li><li>  The basic coding unit in a Unicode encoding system. </li><li>  English name for ideographic writing elements of Chinese origin. </li></ol><br>  This definition may or may not be useful for you, but in most cases you can use an intuitive understanding of a symbol, as something like some element denoting a large letter "A" or the number "1", etc.  However, there are other characters that are far from being so intuitively obvious.  These include modifying characters, which are intended to change other characters (for example, acute stress, it is <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BA%25D1%2583%25D1%2582">acute</a> ), <a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258B">control characters</a> (for example, a newline character), formatting characters (invisible, but affect other characters).  Text data - this is a set of characters, and this is important. <br><br>  Unfortunately, in the recent past, the distinction between binary and textual data was very vague, fuzzy.  For example, for programmers in C language, the terms "byte" and "character" in most cases meant the same thing.  In modern platforms such as .NET and Java, where the distinction between characters and bytes is clear and fixed in the I / O libraries, old habits can have negative consequences (for example, people can try to copy the contents of a binary file by reading character strings from it will distort the contents of this file). <br><br><h3>  So what's Unicode for? </h3><br>  The Unicode Consortium is trying to standardize the processing of character data, including conversions from binary to text and vice versa (what is called <i>decoding</i> and <i>encoding,</i> respectively).  In addition, there is a set of ISO standards (10646 in various versions) that do the same;  Unicode and ISO 10646 can be considered one and the same, since they are almost completely compatible.  (In theory, ISO 10646 defines a wider potential character set, but this is unlikely to ever become a problem.) Most modern programming languages ‚Äã‚Äãand platforms, including .NET and Java, use Unicode to represent characters. <br><br>  Unicode defines, among other things: <br><ul><li>  <i>abstract character repertoire</i> ( <i>abstract character repertoire</i> ) - a set of all characters that are supported by Unicode; </li><li>  set of character codes ( <i>coded character set</i> ) - contains a binding of each character from the repertoire to a nonnegative integer number, called a code point; </li><li>  some forms of character encoding ( <i>character encoding forms</i> ) - define correspondences between code points and sequences of "code units" (simply speaking, correspondences between a code point expressed as a single integer of any length and a group of bytes encoding this number); </li><li>  some <i>character encoding schemes</i> ( <i>character encoding schemes</i> ) - define correspondences between sets of code units and serialized byte sequences. </li></ul><br>  The difference between the form of character encoding and the character encoding scheme is quite subtle, however, it takes into account the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">byte order</a> ( <i>endianness</i> ).  (For example, in the UCS-2 encoding, the sequence of code units 0xC2 0xA9 can be serialized as 0xC2 0xA9 or as 0xA9 0xC2 - this is what the character encoding scheme decides.) <br><br>  The repertoire of abstract Unicode characters may contain, in theory, up to 1,114,112 characters, although many are already reserved as unsuitable, and the rest will most likely never be assigned.  Each character is encoded with a nonnegative integer from 0 to 1114111 (0x10FFFF).  For example, the capital A is encoded with a decimal number 65. A few years ago it was believed that all the characters "fit" in the range between 0 and 2 <sup>16</sup> -1, which meant that any character can be represented using two bytes.  Unfortunately, over time, it took more characters, which led to the emergence of the so-called.  ‚ÄúSurrogate pair‚Äù.  Everything became much more difficult with them (at least for me), and therefore most of this article will not touch them - I will briefly describe them in the <a href="https://habr.com/ru/post/193048/">‚ÄúDifficult moments‚Äù section</a> . <br><br><h3>  So what provides .NET? </h3><br>  Do not worry if all of the above looks weird.  You should be aware of the differences described above, but in fact they do not often come to the fore.  Most of your tasks will most likely ‚Äúspin‚Äù around converting a certain set of bytes into some text and vice versa.  In such situations, you will work with the <a href="http://msdn.microsoft.com/en-us/library/system.char.aspx">System.Char</a> structure (known in C # as the <code>char</code> alias), the <a href="http://msdn.microsoft.com/en-us/library/system.string.aspx">System.String</a> class ( <code>string</code> in C #), and the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">System.Text.Encoding</a> class. <br><br>  The <code>Char</code> structure is the most basic character type in C #, one instance of <code>Char</code> represents one Unicode character and takes 2 bytes of memory, which means it can take any value from the range 0-65535.  Keep in mind that not all numbers in this range are valid Unicode characters. <br><br>  The <code>String</code> class is basically a sequence of characters.  It is immutable, which means that after creating an instance of a string, you can no longer change it (an instance) - the various methods of the <code>String</code> class, although they look as if they change its contents, actually create and return a new string. <br><br>  The <code>System.Text.Encoding</code> class provides a means of converting an array of bytes into a character array or string, and vice versa.  This class is abstract;  its various implementations are both represented in .NET and can be written by the users themselves.  (The task of creating <code>System.Text.Encoding</code> implementation occurs quite rarely - in most cases, the classes that come with .NET are enough for you.) <code>Encoding</code> allows you to separately specify the encoders and decoders that handle the state between calls.  This is necessary for multibyte character encoding schemes, when it is impossible to correctly decode all the bytes received from the stream into characters.  For example, if a UTF-8 decoder receives two bytes of 0x41 0xC2 as input, it can return only the first character (the capital letter "A"), however, it needs the third byte to determine the second character. <br><br><h3>  Embedded encoding schemes </h3><br>  The .NET class library contains various encoding schemes.  Below is a description of these schemes and how to use them. <br><br><h5>  ASCII </h5><br>  ASCII is one of the most common and at the same time one of the most misunderstood character encodings.  Contrary to popular misconception, ASCII is a 7-bit encoding, not an 8-bit one: there are no characters with codes (code points) greater than 127.  If someone declares that he uses, for example, the code "ASCII 154", then we can assume that this someone does not understand what he does and says.  However, as an excuse, he may declare something about "extended ASCII" ( <i>extended ASCII</i> ).  So - there is no scheme called "extended ASCII".  There are many 8-bit encoding schemes that are a superset for ASCII, and the term ‚Äúextended ASCII‚Äù is sometimes used to designate them, which is not entirely correct.  The code point of each ASCII character coincides with the code point of a similar character in Unicode: in other words, the lower case ASCII character of the Latin letter ‚Äúx‚Äù and the Unicode character of the same character are denoted by the same number - 120 (0x78 in hexadecimal).  The .NET class <a href="http://msdn.microsoft.com/en-us/library/system.text.asciiencoding.aspx">ASCIIEncoding</a> (an instance of which can be easily obtained via the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.ascii.aspx">Encoding.ASCII</a> property), in my opinion, is a bit strange, since it seems that it performs encoding by simply discarding all bits after the base 7.  This means that, for example, a Unicode character 0xB5 (the sign ‚Äúmicro‚Äù - <i>¬µ</i> ), after encoding into ASCII and decoding back into Unicode, will turn into the character 0x35 (digit ‚Äú5‚Äù).  (Instead, I would prefer that some special character be output, indicating that the original character was missing in ASCII and was lost.) <br><br><h5>  UTF-8 </h5><br>  UTF-8 is a good and common way to represent Unicode characters.  Each character is encoded by a sequence of bytes in the number from one to four inclusive.  (All characters with code points less than 65536 are encoded with one, two or three bytes; I did not check how .NET encodes surrogate pairs: with two sequences of 1-3 bytes or one sequence of 4 bytes.) UTF-8 can display all Unicode characters are compatible with ASCII so that any sequence of ASCII characters will be converted into UTF-8 without changes (i.e. a sequence of bytes representing the characters in ASCII and a sequence of bytes representing the same characters in UTF-8 are the same).  Moreover, the first byte encoding a character is enough to determine how many more bytes encode the same character, if any.  UTF-8 itself does not require <a href="http://ru.wikipedia.org/wiki/Byte_order_mark">a</a> Byte order mark (BOM), although it can be used as a way of indicating that the text is in UTF-8 format.  UTF-8 text containing a BOM always starts with a sequence of three bytes 0xEF 0xBB 0xBF.  To encode a string in UTF-8 in .NET, simply use the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.utf8.aspx">Encoding.UTF8</a> property.  In fact, in most cases you don‚Äôt even have to do this ‚Äî many classes (including <a href="http://msdn.microsoft.com/en-us/library/system.io.streamwriter.aspx">StreamWriter</a> ) use UTF-8 by default, when no other encoding is explicitly specified.  (Don't be mistaken, <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.default.aspx">Encoding.Default</a> does not apply here, it is completely different.) Nevertheless, I advise you to always explicitly specify the encoding in your code, if only for readability and understanding. <br><br><h5>  UTF-16 and UCS-2 </h5><br>  UTF-16 is just the encoding in which .NET works with characters.  Each character is represented by a sequence of two bytes;  accordingly, the surrogate pair takes 4 bytes.  The ability to use surrogate pairs is the only difference between UTF-16 and UCS-2: UCS-2 (also known simply as Unicode) does not allow surrogate pairs and can represent characters in the range 0-65535 (0-0xFFFF).  UTF-16 can have a different byte order (Endianness): it can be from high to low ( <i>big-endian</i> ), from low to high ( <i>little-endian</i> ), or be machine-dependent with an optional BOM (0xFF 0xFE for <i>little</i> ). endian, 0xFE 0xFF for big-endian).  In .NET itself, as far as I know, the problem of surrogate pairs was ‚Äúhammered‚Äù, and each character in a surrogate pair is considered as an independent symbol, which results in a kind of ‚Äúleveling‚Äù between UCS-2 and UTF-16.  (The exact difference between UCS-2 and UTF-16 is a much deeper understanding of surrogate pairs, and I am not competent in this aspect.) UTF-16 in big-endian representation can be obtained using the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.bigendianunicode.aspx">Encoding.BigEndianUnicode</a> property, and little endian - using <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.unicode.aspx">Encoding.Unicode</a> .  Both properties return an instance of the <a href="http://msdn.microsoft.com/en-us/library/system.text.unicodeencoding.aspx">System.Text.UnicodeEncoding</a> class, which can also be created using various constructor overloads: here you can specify whether or not to use the BOM and what byte order to set.  I suppose (although I did not test this) that when decoding binary content, the BOM present in the content overrides the byte order settings set in the encoder, so the programmer should not make any extra gestures if he decodes any content, even if the byte order and / or the presence of BOM in this content are unknown to him. <br><br><h5>  UTF-7 </h5><br>  UTF-7, judging by my experience, is rarely used, but it allows you to transcode Unicode (probably only the first 65535 characters) into ASCII characters (not bytes!).  This can be useful when working with e-mail in situations where mail gateways support only ASCII characters, or even just a subset of ASCII (for example, <a href="http://ru.wikipedia.org/wiki/EBCDIC">EBCDIC</a> encoding).  My description looks slurred because I have never climbed into the details of UTF-7 and am not going to do that in the future.  If you need to use UTF-7, then you probably already know enough, and if you don‚Äôt have the absolute need to use UTF-7, then I advise you not to.  An instance of a class for encoding in UTF-7 can be obtained using the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.utf7.aspx">Encoding.UTF7</a> property. <br><br><h5>  Windows / ANSI code pages </h5><br>  Windows Code Pages are typically single- or double-byte character sets, encoding up to 256 or 65,536 characters, respectively.  Each code page has its own number, and the encoder for the code page with a known number can be obtained using the static method <a href="http://msdn.microsoft.com/en-us/library/wzsz3bk3.aspx">Encoding.GetEncoding (Int32)</a> .  In most cases, code pages are useful for working with old data, which is often stored in the <i>default code page</i> .  The encoder for the default code page can be obtained using the <a href="http://msdn.microsoft.com/en-us/library/system.text.encoding.default.aspx">Encoding.Default</a> property.  Again, avoid using code pages whenever possible.  For more information, contact MSDN. <br><br><h5>  ISO-8859-1 (Latin-1) </h5><br>  As in ASCII, each character in the Latin-1 code page has the same code as the code for the same character in Unicode.  I did not bother to find out whether Latin-1 has a ‚Äúhole‚Äù of unrecorded characters with codes from 128 to 159, or whether Latin-1 contains the same control characters as Unicode.  (I was beginning to lean towards the idea of ‚Äã‚Äãa ‚Äúhole‚Äù, but Wikipedia does not agree with me, so I am still in thought. (The <i>author‚Äôs</i> thoughts are <i>incomprehensible, since the <a href="http://en.wikipedia.org/wiki/ISO-8859-1">Wikipedia article clearly shows the presence of a space</a> ; probably, at the time of writing Skit the original article, Wikipedia articles were different. - approx. transl.</i> )) Latin-1 has a code page number of 28591, so use the <code>Encoding.GetEncoding(28591)</code> method to get an encoder. <br><br><h3>  Streams, readers and writers </h3><br>  Binary streams are by nature, they read and write bytes.  Everything that accepts a string should convert it to bytes in a certain way, and this conversion can be either successful for you or not.  The equivalent threads for reading and writing text are the abstract classes <a href="http://msdn.microsoft.com/en-us/library/system.io.textreader.aspx">System.IO.TextReader</a> and <a href="http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx">System.IO.TextWriter,</a> respectively.  If you already have a stream ready, you can use the <a href="http://msdn.microsoft.com/en-us/library/system.io.streamreader.aspx">System.IO.StreamReader</a> classes (which directly inherit <code>TextReader</code> ) for reading and <a href="http://msdn.microsoft.com/en-us/library/system.io.streamwriter.aspx">System.IO.StreamWriter</a> (which directly inherits <code>TextWriter</code> ) for writing, passing the stream to the constructor of these classes and encoding as you need.  Unless you explicitly specify the encoding, UTF-8 will be applied by default.  Below is a sample code that converts a file from UTF-8 to UCS-2: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileConverter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BufferSize = <span class="hljs-number"><span class="hljs-number">8096</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length != <span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.WriteLine (<span class="hljs-string"><span class="hljs-string">"Usage: FileConverter &lt;input file&gt; &lt;output file&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } String inputFile = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; String outputFile = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  TextReader      using (TextReader input = new StreamReader (new FileStream (inputFile, FileMode.Open), Encoding.UTF8)) { //  TextWriter         using (TextWriter output = new StreamWriter (new FileStream (outputFile, FileMode.Create), Encoding.Unicode)) { //   char[] buffer = new char[BufferSize]; int len; //       while ( (len = input.Read (buffer, 0, BufferSize)) &gt; 0) { output.Write (buffer, 0, len); } } } } }</span></span></code> </pre><br>  Note that this code uses <code>TextReader</code> and <code>TextWriter</code> that accept streams.  There are other constructor overloads that take file paths as input, so you don't need to manually open the <code>FileStream</code> ;  I did this only as an example.  There are other constructor overloads that also take the size of the buffer and the need to determine the BOM, in general, look at the documentation.  And finally, if you are using .NET 2.0 and higher, it doesn‚Äôt hurt to take a look at the static class <a href="http://msdn.microsoft.com/en-us/library/system.io.file.aspx">System.IO.File</a> , which also contains many convenient methods that allow you to work with encodings. <br><a name="nasty"></a><br><h3>  Difficult moments </h3><br>  Well, those were just the basics of Unicode.  There are many other nuances, some of which I have already hinted at, and I believe that people should be aware of them, even if they believe that this will never happen to them.  I do not propose any general methodologies or guidelines ‚Äî I‚Äôm just trying to raise your awareness of potential problems.  Below is a list, and it is in no way exhaustive.  It is important that you understand that most of the problems and difficulties described are in no way the fault or error of the Unicode Consortium;  just as in the case of date, time, and any of the problems of internationalization, this is the ‚Äúmerit‚Äù of mankind, which itself has created many fundamentally complex problems over time. <br><br><h5>  Culture-dependent search, sorting and so on. </h5><br>  These problems are described in my article devoted to .NET strings ( <a href="http://csharpindepth.com/Articles/General/Strings.aspx">original</a> , <a href="http://habrahabr.ru/post/165597/">translation</a> ). <br><br><h5>  Surrogate pairs </h5><br>  Now that Unicode contains more than 65,536 characters, it cannot contain them all in 2 bytes.  This means that a single instance of the <code>Char</code> structure cannot accept all possible characters.  UTF-16 (and .NET) solves this problem by using surrogate pairs - these are two 16-bit values, where each value lies in the range from 0xD800 to 0xDFFF.  In other words, two ‚Äúcharacter types‚Äù form one ‚Äúreal‚Äù character.  (UCS-4 and UTF-32 completely solve this problem by the fact that they have a wider range of values ‚Äã‚Äãavailable: each character takes 4 bytes, and this is enough for everyone.) Surrogate pairs are a headache, because it means that the string , which consists of 10 characters, in fact, can contain from 10 to 5 inclusive of "real" Unicode characters.  Fortunately, most applications do not use scientific or mathematical notations and Han characters, and therefore you don‚Äôt need to worry about it. <br><br><h5>  Modifying characters </h5><br><img src="https://habrastorage.org/storage3/745/d14/326/745d143266c494c05edf2f3c039a8e17.png" align="right" alt="Symbol modification example"><br>  Not all characters from Unicode are displayed as an icon / picture as a result of output to the screen or paper.  An underlined (accented) character can be represented as two other characters: a regular, unstretched character and the next underscore character, which is called a <i>modifying (or combinable) character</i> ( <a href="http://en.wikipedia.org/wiki/Combining_character">Combining character</a> ).  Some GUIs support modifying symbols, some are not, and the performance of your application will depend on what assumption you make. <br><br><h5>  Normalization </h5><br>  Partly due to such things as modifying symbols, there may be several ways of representing what is in one sense one symbol.  The letter "√°" with stress, for example, can be represented by one character "a" without the stress and the modifying stress symbol following it, or it can be represented only by one character representing the finished letter "a" with stress.  Sequences of symbols can be normalized in such a way as to use modifying symbols wherever possible, or vice versa - not to use them wherever they can be replaced with a single symbol.  Should your application treat two lines containing the letter ‚Äú√°‚Äù with the stress, but in one represented by two characters, and in the second one as equal, or as different?  What about sorting?  Do third-party components and libraries that you use normalize strings, and in general, do such nuances take into account?  These questions answer you. <br><br><h3>  Debugging Unicode Issues </h3><br>  This section ( <i>in the original is a <a href="http://csharpindepth.com/Articles/General/DebuggingUnicode.aspx">separate article</a> - note of the translator</i> ) describes what to do in very specific situations.  Namely, you have some character data (simply text) in one place (usually in a database), which go through different steps / layers / components and then are displayed to the user (usually on a web page).  And unfortunately for you, some characters are displayed incorrectly ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B7%25D1%258F%25D0%25B1%25D1%2580%25D1%258B">kryakozyabry</a> ).  Based on the many steps involved in your text data, a problem can arise in many places.  This page will help you easily and reliably find out what and where is ‚Äúbroken‚Äù. <br><br><h5>  Step 1: Understand the Basics of Unicode </h5><br>  And simply speaking - read the main text of the article.  You can also pay attention to the links that are given at the beginning of the article.  The fact is that without basic knowledge you will be tight. <br><br><h5>  Step 2: Try to determine which conversions could occur. </h5><br>  If you can understand where, perhaps, everything breaks, then this section / stage will be much easier to isolate.  However, keep in mind that the problem may not be in the process of extracting and transforming text from the repository, but in the fact that already ‚Äúspoiled‚Äù text was entered into the repository earlier.  (I had problems with similar problems in the past, when, for example, one old application distorted the text when writing and reading it to / from the database. The joke was that the conversion errors overlapped and mutually compensated, so that the correct text was obtained. In general, the application worked fine, but it was enough to touch it - and everything fell apart.) Actions that can ‚Äúspoil‚Äù the text should include selection from the database, reading from the file, transfer via a web connection and displaying text on the screen. <br><br><h5>  Step 3: Check the data at each stage. </h5><br>  The first rule is: do not trust anything that logs character data as a sequence of glyphs (i.e. standard character icons).  Instead, you must log the data as a set of byte character codes.  For example, if I have a string containing the word "hello", then I will display it as "0068 0065 006C 006C 006F".  (Using hexadecimal codes will allow you to easily check a symbol by code tables.) To do this, you need to go through all the characters in a line and output its code for each character, which is done in the method below, which displays the result in the console: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DumpString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { Console.Write(<span class="hljs-string"><span class="hljs-string">"{0:x4} "</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)c); } Console.WriteLine(); }</code> </pre><br>  Your own logging method will be different depending on your environment, but its basis should be exactly the same as I quoted.  I cited a more advanced way of debugging and logging character data in my article on strings. <br><br>  The essence of my idea is to get rid of all sorts of problems with encodings, fonts, etc.  This technique can be useful when working with specific Unicode characters.  If you cannot correctly log hexadecimal codes of even simple ASCII text, you have big problems. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to make sure you have a test case that you can use. It is desirable to find a small set of source data on which your application is guaranteed to ‚Äúfail‚Äù, make sure that you know exactly what the correct result should be, and pledge the resulting result in all problem areas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the problem string is logged, you need to make sure whether it is what it should be or not. This is where the </font><a href="http://www.unicode.org/charts/"><font style="vertical-align: inherit;">Unicode code charts</font></a><font style="vertical-align: inherit;"> webpage helps you.</font></font><a href="http://www.unicode.org/charts/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can choose as a set of characters, which are sure, and search for characters in alphabetical order. Make sure every character in the string has the correct value. As soon as you find the place in your application where the stream of character data is damaged, examine this place, find out the cause of the error and correct it. Having corrected all errors, make sure that the application is working correctly.</font></font><br><br><h5>  Conclusion </h5><br>        ,    ,         ¬´  ¬ª.        ,      .               ,           -;     , ,   ,     . <br><br> <b></b> <br><ul><li> Jon Skeet. <a href="http://csharpindepth.com/Articles/General/Unicode.aspx">Unicode and .NET</a> </li><li> Jon Skeet. <a href="http://csharpindepth.com/Articles/General/DebuggingUnicode.aspx">Debugging Unicode Problems</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/193048/">https://habr.com/ru/post/193048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193038/index.html">"Boost.Asio C ++ Network Programming". Chapter 2: Boost.Asio Basics Part 1</a></li>
<li><a href="../193040/index.html">Big update Ruward</a></li>
<li><a href="../193042/index.html">Electronic car numbers will appear in California</a></li>
<li><a href="../193044/index.html">Search for deleted files in NTFS</a></li>
<li><a href="../193046/index.html">LEC-2126 Network Platform Overview</a></li>
<li><a href="../193064/index.html">Microsoft and Adobe have released updates for their products, September 2013</a></li>
<li><a href="../193066/index.html">Emotional loyalty in the retail and service industries. Monitoring, diagnostics, management</a></li>
<li><a href="../193068/index.html">According to Spiegel, the NSA can get data from almost any smartphone.</a></li>
<li><a href="../193070/index.html">Play video service - new and best movies, legally and without ads</a></li>
<li><a href="../193072/index.html">Overview of the auto.ru mobile application for the Android platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>