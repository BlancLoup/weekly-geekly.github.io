<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fourier computations for image comparison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The traditional ‚Äúentry-level‚Äù technique of comparing the current image with the standard is based on considering the images as two-dimensional brightn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fourier computations for image comparison</h1><div class="post__text post__text-html js-mediator-article">  The traditional ‚Äúentry-level‚Äù technique of comparing the current image with the standard is based on considering the images as two-dimensional brightness functions (discrete two-dimensional intensity matrices).  In this case, either the distance between the images or the measure of their proximity is measured. <br><br>  As a rule, to calculate the distances between images, a formula is used which is the sum of the modules or squares of the intensity differences: <br><blockquote>  d (X, Y) = SUM (X [i, j] - Y [i, j]) ^ 2 </blockquote><br>  If, in addition to simply comparing two images, it is required to solve the problem of finding the position of a fragment of one image in another, then the classical ‚Äúinitial level‚Äù method, which consists in enumerating all coordinates and calculating the distance using the specified formula, usually fails due to practical use due to the large number of calculations <br><br>  One of the methods that can significantly reduce the number of calculations is the use of Fourier transforms and discrete Fourier transforms to calculate the measure of coincidence of two images at different displacements between them.  The calculations are performed simultaneously for different combinations of image shifts relative to each other. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The presence of a large number of libraries that implement Fourier transforms (in all sorts of variants of the fast versions) makes the implementation of image comparison algorithms not a very difficult task for programming. <br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br><ul><li>  Let two images X and Y be given - an image and a sample, of sizes (N1, N2) and (M1, M2), respectively, and Ni&gt; Mi </li><li>  It is required to find the coordinates of the sample Y in the full image X and calculate the estimated value - the measure of proximity. </li></ul><br>  For example, find: <br><br><h3>  sample </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/89a/b30/1ca/89ab301ca563a0548685b09a4d7584e2.jpg" alt="sample"><br><br><h3>  in the image </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/340/13d/911/34013d9110a205309ae2fbfa92f27a2c.jpg" alt="Cheshire Cat"><br><br><h2>  Correlation as a measure between images </h2><br>  According to the definition, the correlation &lt;F, G&gt; of two functions F and G is the value: <br><blockquote>  &lt;F, G&gt; = SUM F (i) * G (i) </blockquote><br>  This value is well known from the course of mathematics and geometry, devoted to linear spaces, where it is called the scalar product.  We will use the formula between the images: <br><blockquote>  m (X, Y) = SUM (X [i, j] * Y [i, j]) / (SQRT (SUM X [i, j] ^ 2) * SQRT (SUM Y [i, j] ^ 2) ) </blockquote><br>  or <blockquote>  m (X, Y) = &lt;X, Y&gt; / (SQRT (&lt;X, X&gt;) * SQRT (&lt;Y, Y&gt;)) </blockquote><br>  This value was obtained from the scalar product operation of vectors (considering images as vectors in multidimensional space).  And even more - the same formula is also a standard statistical formula of the criterion for the hypothesis of the coincidence of two probability distributions. <br><br>  <b>Note:</b> <br>  When calculating the correlation between fragments of images, if one image is smaller than another, we will only divide by the value of the norms of the intersecting parts. <br><br><h2>  Convolution of two functions </h2><br>  According to the definition, the convolution of two functions F and G is the function FG: <br><blockquote>  FxG (t) = SUM F (i) * G (j) | i + j = t </blockquote><br>  Let G '(t) = G (-t) and F' (t) = F (-t), then, the following equality is obvious: <br><ul><li>  FF '(0) = SUM F (i) ^ 2 - scalar product of vector F on itself </li><li>  GxG '(0) = SUM G (j) ^ 2‚Äì scalar product of vector G on itself </li><li>  FxG '(0) = SUM F (i) * G (i) is the scalar product of two vectors F and G </li></ul><br>  It is also obvious that FxG '(t) is equal to the correlation of one vector resulting from the shift, relative to the other by step t (this is easy to check by explicit substitution of values ‚Äã‚Äãin the correlation formula). <br><br><h2>  Fourier transform </h2><br>  The Fourier transform (‚Ñ±) is an operation that associates one function of a real variable with another function, also a real variable.  This new function describes the coefficients (‚Äúamplitudes‚Äù) when decomposing the original function into elementary components ‚Äî harmonic oscillations with different frequencies. <br><br>  The Fourier transform of the function f by a real variable is integral and is given by the following formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a78/401/195/a784011956b6daeb35c695fc5036eb50.png" alt="Fourier transform"><br><br>  Different sources may give definitions that differ from the above given by choosing the coefficient before the integral, as well as the sign "-" in the exponent.  But all the properties will be the same, although the form of some formulas may change. <br><br>  In addition, there are various generalizations of this concept. <br><br><h2>  Multidimensional Fourier Transform </h2><br>  The Fourier transform of functions defined on the space ‚Ñù ^ n is defined by the formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0de/01b/d67/0de01bd6753565c9957bf5ca4275f71c.png" alt="image"><br><br>  The inverse transformation in this case is given by the formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bd/c22/748/9bdc227489f391a75eafe6b1a883d903.png" alt="image"><br><br>  As before, in different sources the definition of a multidimensional Fourier transform may differ by the choice of a constant in front of the integral. <br><br><h2>  Discrete Fourier Transform </h2><br>  Discrete Fourier transform (in the English-language DFT literature, Discrete Fourier Transform) is one of the Fourier transforms that are widely used in digital signal processing algorithms (its modifications are used in audio compression in MP3, image compression in JPEG, etc.), as well as in other areas associated with the analysis of frequencies in a discrete (for example, digitized analog) signal.  The discrete Fourier transform requires a discrete function as an input.  Such functions are often created by sampling (sampling values ‚Äã‚Äãfrom continuous functions).  Discrete Fourier transforms help solve partial differential equations and perform operations such as convolutions.  Discrete Fourier transforms are also actively used in statistics when analyzing time series.  There are multidimensional discrete Fourier transforms. <br><br><h2>  Discrete Transform Formulas </h2><br>  Direct conversion: <br><br><img src="https://habrastorage.org/getpro/habr/comment_images/0fe/66e/fd0/0fe66efd0c6151565e3a6a3bc3c5a888.png" alt="image"><br><br>  Inverse transform: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de5/663/408/de56634082741492c8b949377fc3288c.png" alt="image"><br><br>  The discrete Fourier transform is a linear transform that translates a vector of time samples into a vector of spectral samples of the same length.  Thus, the transformation can be implemented as a multiplication of a symmetric square matrix by a vector: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/125/fae/c7d125fae17a50b837e5e3e382d230fe.png" alt="image"><br><br><h2>  Fourier Transforms for Convolution Calculation </h2><br>  One of the remarkable properties of Fourier transforms is the ability to quickly calculate the correlation of two functions defined, either on a real argument (using the classical formula) or on a finite ring (using discrete transformations). <br><br>  And although such properties are inherent in many linear transformations, for practical use, to calculate the operation of convolution, according to our definition, the formula is used <br><blockquote>  FxG = BFT (FFT (F) * FFT (G)) </blockquote><br>  Where <br><ul><li>  FFT - direct Fourier transform operation </li><li>  BFT is the operation of the inverse Fourier transform </li></ul><br>  It is rather easy to verify the equality of equality by explicitly substituting into formulas of Fourier transforms and reducing the resulting formulas. <br><br><h2>  Fourier Transforms for Correlation Calculation </h2><br><br>  Let &lt;F, G&gt; (t) be equal to the correlation of the resulting vector as a result of the shift, relative to the other by step t <br>  Then, as shown earlier, <br><blockquote>  &lt;F, G&gt; (t) = FxG '(t) = BFT (FFT (F) * FFT (G')) </blockquote><br>  If implementations of the Fourier transform algorithm through complex numbers are used, such transformations have another remarkable property: <br><blockquote>  FFT (G ') = CONJUGATE (FFT (G)) </blockquote><br>  Where CONJUGATE (FFT (G)) is a matrix composed of conjugate elements of the FFT (G) matrix <br>  So we get <br><blockquote>  &lt;F, G&gt; (t) = BFT (FFT (F) * CONJUGATE (FFT (G))) </blockquote><br><br><h2>  Fourier transforms for solving the problem </h2><br>  When using a formula to estimate the distance between images when shifting (i, j) relative to each other <br><blockquote>  m (X, Y) (i, j) = &lt;X, Y&gt; (i, j) / (| X | (i, j)) * | Y | (i, j)), </blockquote><br>  we get that <br><ul><li>  &lt;X, Y&gt; = XxY '= BFT (FFT (X) * CONJUGATE (FFT (Y))) </li><li>  | X | ^ 2 = &lt;X, X&gt; = XxX'xE '= BFT (FFT (X) * CONJUGATE (FFT (X)) * CONJUGATE (FFT (E)) = BFT (SQUAREMAGNITUDE (FFT (X)) * CONJUGATE (FFT (E))) </li><li>  | Y | ^ 2 = &lt;Y, Y&gt; = YxY'xE '= BFT (FFT (Y) * CONJUGATE (FFT (Y)) * CONJUGATE (FFT (E))) </li></ul><br>  Where <br><ul><li>  &lt;X, Y&gt; (i, j) is the scalar product of two images obtained by shifting (i, j) relative to each other of images X and Y </li><li>  E - image of size equal to the minimum size of X and Y, and filled with single values ‚Äã‚Äã(that is, the ‚Äúframe‚Äù in which X and Y are compared) </li><li>  | X | (i, j) - the norm of the common part of the image X when shifting (i, j) </li><li>  | Y | (i, j) - the norm of the common part of the image Y in the shift (i, j) </li><li>  FFT is an operation of direct two-dimensional discrete Fourier transform </li><li>  BFT is the operation of the inverse two-dimensional discrete Fourier transform </li><li>  CONJUGATE - the operation of calculating the matrix of conjugate elements </li><li>  SQUAREMAGNITUDE - the operation of calculating the matrix of squares of the amplitudes of the elements </li></ul><br><h2>  Simplification of formulas for solving the problem </h2><br>  When solving a problem for searching for a single sample, the additional rationing of the sample is redundant, and the calculation of the norm for the common part can be replaced by the sum of the pixel brightness in this common part or by the sum of the squares of brightness in this common part <br>  When using a formula to estimate the distance between images when shifting (i, j) relative to each other <br><blockquote>  m (X, Y) (i, j) = &lt;X, Y&gt; (i, j) / | X | ^ 2 (i, j), </blockquote><br>  we get that <br><ul><li>  &lt;X, Y&gt; = BFT (FFT (X) * CONJUGATE (FFT (Y))) </li><li>  &lt;X, X&gt; = BFT (SQUAREMAGNITUDE (FFT (X)) * CONJUGATE (FFT (E))) </li></ul><br>  Where <br><ul><li>  &lt;X, Y&gt; (i, j) is the scalar product of two images obtained by shifting (i, j) relative to each other of images X and Y </li><li>  E - image of size equal to the minimum size of X and Y, and filled with single values ‚Äã‚Äã(that is, the ‚Äúframe‚Äù in which X and Y are compared) </li><li>  &lt;X, X&gt; (i, j) - the norm (the sum of the brightness of the pixels) of the common part of the image X when shifting (i, j) </li><li>  FFT is an operation of direct two-dimensional discrete Fourier transform </li><li>  BFT is the operation of the inverse two-dimensional discrete Fourier transform </li><li>  CONJUGATE - the operation of calculating the matrix of conjugate elements </li><li>  SQUAREMAGNITUDE - the operation of calculating the matrix of squares of the amplitudes of the elements </li></ul><br><br><h2>  Algorithm for searching a fragment in the full image </h2><br><ul><li>  Let two images X and Y be given - an image and a sample, of sizes (N1, N2) and (M1, M2), respectively, and Ni&gt; Mi </li><li>  It is required to find the coordinates of the sample Y in the full image X and calculate the estimated value - the measure of proximity. </li></ul><br><ol><li>  Expand the Y image to the size (N1, N2), adding it with zeros </li><li>  To form an image E from units of size (M1, M2) and expand to size (N1, N2), adding zeros </li><li>  Calculate &lt;X, Y&gt; = BFT (FFT (X) * CONJUGATE (FFT (Y))) </li><li>  Calculate &lt;X, X&gt; = BFT (SQUAREMAGNITUDE (FFT (X)) * CONJUGATE (FFT (E))) </li><li>  Calculate M [i, j] = (f + &lt;X, Y&gt; [i, j]) / (f + &lt;X, X&gt; [i, j]) </li><li>  In the matrix M to find the element with the maximum value - the coordinates of this element are the desired position of the sample in the full image, and the value is equal to the evaluation of the measure of comparison. </li></ol><br>  <b>Note:</b> <br>  When using the discrete Fourier transform, the matrix M also contains elements from the cyclic shift of the images between themselves.  Therefore, if it is not necessary to analyze the cyclic shift of frames, then the search for the maximum element in the matrix M should be limited to the area (0,0) - (N1-M1, N2-M2). <br><br><h2>  Implementation examples </h2><br>  The implemented algorithms are part of the open source FFTTools library.  Internet address: <a href="https://github.com/dprotopopov/FFTTools">github.com/dprotopopov/FFTTools</a> <br><br>  <b>Used software</b> <br><ul><li>  Microsoft Visual Studio 2013 C # - environment and programming language </li><li> EmguCV / OpenCV - C ++ library of structures and algorithms for image processing </li><li>  FFTWSharp / FFTW - C ++ library that implements fast discrete Fourier transform algorithms </li></ul><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Catch pattern bitmap with the Fastest Fourier Transform </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Matrix of values</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private Matrix</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment"> Catch(Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Gray, double&gt;</span></span></span><span class="hljs-comment"> image) { const double f = 1.0; int length = image.Data.Length; int n0 = image.Data.GetLength(0); int n1 = image.Data.GetLength(1); int n2 = image.Data.GetLength(2); Debug.Assert(n2 == 1); // Allocate FFTW structures var input = new fftw_complexarray(length); var output = new fftw_complexarray(length); fftw_plan forward = fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Forward, fftw_flags.Estimate); fftw_plan backward = fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Backward, fftw_flags.Estimate); var matrix = new Matrix</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment">(n0, n1); double[,,] patternData = _patternImage.Data; double[,,] imageData = image.Data; double[,] data = matrix.Data; var doubles = new double[length]; // Calculate Divisor Copy(patternData, data); Buffer.BlockCopy(data, 0, doubles, 0, length*sizeof (double)); input.SetData(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); forward.Execute(); Complex[] complex = output.GetData_Complex(); Buffer.BlockCopy(imageData, 0, doubles, 0, length*sizeof (double)); input.SetData(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); forward.Execute(); input.SetData(output.GetData_Complex().Zip(complex, (x, y) =&gt; x*Complex.Conjugate(y)).ToArray()); backward.Execute(); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment"> doubles1 = output.GetData_Complex().Select(x =&gt; x.Magnitude); if (_fastMode) { // Fast Result Buffer.BlockCopy(doubles1.ToArray(), 0, data, 0, length*sizeof (double)); return matrix; } // Calculate Divider (aka Power) input.SetData(doubles.Select(x =&gt; new Complex(x*x, 0)).ToArray()); forward.Execute(); complex = output.GetData_Complex(); CopyAndReplace(_patternImage.Data, data); Buffer.BlockCopy(data, 0, doubles, 0, length*sizeof (double)); input.SetData(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); forward.Execute(); input.SetData(complex.Zip(output.GetData_Complex(), (x, y) =&gt; x*Complex.Conjugate(y)).ToArray()); backward.Execute(); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment"> doubles2 = output.GetData_Complex().Select(x =&gt; x.Magnitude); // Result Buffer.BlockCopy(doubles1.Zip(doubles2, (x, y) =&gt; (f + x*x)/(f + y)).ToArray(), 0, data, 0, length*sizeof (double)); return matrix; }</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Copy 3D array to 2D array (sizes can be different) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Flip copied data </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reduce last dimension </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="input"&gt;</span></span></span><span class="hljs-comment">Input array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="output"&gt;</span></span></span><span class="hljs-comment">Output array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Copy(double[,,] input, double[,] output) { int n0 = output.GetLength(0); int n1 = output.GetLength(1); int m0 = Math.Min(n0, input.GetLength(0)); int m1 = Math.Min(n1, input.GetLength(1)); int m2 = input.GetLength(2); for (int i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; m0; i++) for (int j = 0; j &lt; m1; j++) output[i, j] = input[i, j, 0]; for (int k = 1; k &lt; m2; k++) for (int i = 0; i &lt; m0; i++) for (int j = 0; j &lt; m1; j++) output[i, j] += input[i, j, k]; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Copy 3D array to 2D array (sizes can be different) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Replace items copied by value </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Flip copied data </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reduce last dimension </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="input"&gt;</span></span></span><span class="hljs-comment">Input array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="output"&gt;</span></span></span><span class="hljs-comment">Output array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="value"&gt;</span></span></span><span class="hljs-comment">Value to replace copied data</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void CopyAndReplace(double[,,] input, double[,] output, double value = 1.0) { int n0 = output.GetLength(0); int n1 = output.GetLength(1); int m0 = Math.Min(n0, input.GetLength(0)); int m1 = Math.Min(n1, input.GetLength(1)); int m2 = input.GetLength(2); for (int i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; m0; i++) for (int j = 0; j &lt; m1; j++) output[i, j] = value; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Find a maximum element in the matrix </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="matrix"&gt;</span></span></span><span class="hljs-comment">Matrix of values</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="x"&gt;</span></span></span><span class="hljs-comment">Index of maximum element</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="y"&gt;</span></span></span><span class="hljs-comment">Index of maximum element</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="value"&gt;</span></span></span><span class="hljs-comment">Value of maximum element</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public void Max(Matrix</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment"> matrix, out int x, out int y, out double value) { double[,] data = matrix.Data; int n0 = data.GetLength(0); int n1 = data.GetLength(1); value = data[0, 0]; x = y = 0; for (int i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; n0; i++) { for (int j = 0; j &lt; n1; j++) { if (data[i, j] &lt; value) continue; value = data[i, j]; x = j; y = i; } } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Catch pattern bitmap with the Fastest Fourier Transform </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Array of values</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public Matrix</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double&gt;</span></span></span><span class="hljs-comment"> Catch(Bitmap bitmap) { using (var image = new Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Gray, Byte&gt;</span></span></span><span class="hljs-comment">(bitmap)) return Catch(image); }</span></span></code> </pre><br><h1>  Got that bit </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/001/c07/2c5/001c072c572e133666c19cf25689a9b9.jpg" alt="image"><br><br><h2>  Literature </h2><br><ol><li>  A.L.  Dmitriev.  Optical methods of information processing.  Tutorial.  SPb.  SPUGUITMO 2005. 46 p. </li><li>  A.A. Akaev, S..Mayorov ‚ÄúOptical methods of information processing‚Äù M.: 1988 </li><li>  J. Goodman "Introduction to Fourier Optics" M .: Mir 1970 </li></ol></div><p>Source: <a href="https://habr.com/ru/post/266129/">https://habr.com/ru/post/266129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266117/index.html">Playing pure Java from beginner, for beginners</a></li>
<li><a href="../266119/index.html">Security Week 36: jailbreak-robbery, farewell to RC4, porosity of routers</a></li>
<li><a href="../266121/index.html">Setting the overall balance of games three in a row</a></li>
<li><a href="../266125/index.html">New HP Hyper Convergence Systems</a></li>
<li><a href="../266127/index.html">Multiplatform audio player in C ++ and OpenAL</a></li>
<li><a href="../266131/index.html">Watch the broadcast of Windows Camp today at 10:00 (MSK)</a></li>
<li><a href="../266133/index.html">How good are the new Intel Skylake processors</a></li>
<li><a href="../266135/index.html">Carsten Zero: corporations against people, USB threats and biometrics flaws</a></li>
<li><a href="../266137/index.html">Technical support of computer forensics</a></li>
<li><a href="../266139/index.html">Consul: Service Discovery is easy, or say goodbye to config files</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>