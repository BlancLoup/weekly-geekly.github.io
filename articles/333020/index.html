<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a blog engine with Phoenix and Elixir / Part 10. Channel testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: ‚ÄúElixir and Phoenix are a great example of where modern web development is heading. Already, these tools provide high-quality acc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a blog engine with Phoenix and Elixir / Part 10. Channel testing</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/23b/7e2/c1e/23b7e2c1e0c241d7b9738ca92d764acc.png"></p><br><p>  From the translator: <em>‚ÄúElixir and Phoenix are a great example of where modern web development is heading.</em>  <em>Already, these tools provide high-quality access to real-time technologies for web applications.</em>  <em>Sites with increased interactivity, multiplayer browser games, microservices - those areas in which these technologies will serve a good service.</em>  <em>The following is a translation of a series of 11 articles that describe in detail the aspects of development on the Phoenix framework that would seem such a trivial thing as a blog engine.</em>  <em>But do not hurry to sulk, it will be really interesting, especially if the articles encourage you to pay attention to the Elixir or become its followers. ‚Äù</em> </p><br><p>  In this part we will learn how to test channels. </p><a name="habracut"></a><br><h2 id="na-chyom-my-ostanovilis">  Where did we leave off </h2><br><p>  At the end of the last part, we completed a cool system of ‚Äúlive‚Äù comments for the blog.  But to the horror, there was not enough time for the tests!  Let's do them today.  This post will be clear and short, in contrast to the overly long previous one. </p><br><h2 id="pribiraem-hlam">  Tidying up trash </h2><br><p> Before moving on to the tests, we need to pull up a few places.  First let's turn on <br>  <code>approved</code> flag in <code>broadcast</code> call.  This way we will be able to check in the tests the change in the status of confirmation of comments. </p><br><pre> <code class="hljs pgsql">new_payload = payload |&gt; Map.merge(%{ insertedAt: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.inserted_at, commentId: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, approved: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved }) broadcast socket, "APPROVED_COMMENT", new_payload</code> </pre> <br><p>  You also need to modify the <code>web/channels/comment_helper.ex</code> file so that it reacts to empty data sent to the socket by requests for approval / deletion of comments.  After the <code>approve</code> function <code>approve</code> add: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">approve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_params, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span>, <span class="hljs-string"><span class="hljs-string">"User is not authorized"</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">approve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_params, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span>, <span class="hljs-string"><span class="hljs-string">"User is not authorized"</span></span>}</code> </pre> <br><p>  And after the <code>delete</code> function: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_params, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span>, <span class="hljs-string"><span class="hljs-string">"User is not authorized"</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_params, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span>, <span class="hljs-string"><span class="hljs-string">"User is not authorized"</span></span>}</code> </pre> <br><p>  This will make the code simpler, error handling better, and testing easier. </p><br><h2 id="testiruem-helper-kommentariev">  Testing comments helper </h2><br><p>  We will use the factories that we wrote with <code>ExMachina</code> earlier.  We need to test the creation of a comment, as well as approval / rejection / deletion of a comment based on user authorization.  Create a file <code>test/channels/comment_helper_test.exs</code> , and then add the preparatory code to the beginning: </p><br><pre> <code class="hljs pgsql">defmodule Pxblog.CommentHelperTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Pxblog.ModelCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.CommentHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) post = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:post, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, post: post, approved: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) fake_socket = %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id}} {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: fake_socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> our tests <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> this <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here, the <code>ModelCase</code> module is <code>ModelCase</code> to add the ability to use the <code>setup</code> block.  Below are aliases for the <code>Comment</code> , <code>Factory</code> and <code>CommentHelper</code> , so that their functions can be called more easily. </p><br><p>  Then comes the setup of some basic data that can be used in each test.  As before, a user, post and comment are created here.  But pay attention to the creation of a "fake socket", which includes only the <code>assigns</code> key.  We can pass it to <code>CommentHelper</code> so that it <code>CommentHelper</code> of it as a real socket. </p><br><p>  Then the atom tuple is returned <code>:ok</code> and the dictionary list (as well as in other tests).  Let's write the tests themselves! </p><br><p>  Let's start with the simplest test to create a comment.  Since any user can write a comment, no special logic is required here.  We check that the comment was actually created and ... everything! </p><br><pre> <code class="hljs pgsql">test "creates a comment for a post", %{post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(%{ "postId" =&gt; post.id, "author" =&gt; "Some Person", "body" =&gt; "Some Post" }, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  To do this, we call the <code>create</code> function from the <code>CommentHelper</code> module and pass information to it as if this information was received from a channel. </p><br><p>  We proceed to the approval of comments.  Since a bit more authorization-related logic is used here, the test will be a bit more complicated: </p><br><pre> <code class="hljs pgsql">test "approves a comment when an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.approve(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, socket) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "does not approve a comment when not an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:error, message} = CommentHelper.approve(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> message == "User is not authorized" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Similar to creating a comment, we call the <code>CommentHelper.approve</code> function and pass the information from the channel to it.  We pass the "fake socket" to the function and it accesses the <code>assign</code> value.  We test both of them using a valid socket (with the logged on user) and an invalid socket (with an empty <code>assign</code> ).  Then just check that we get a comment in a positive outcome and an error message in a negative one. </p><br><p>  Now about the tests for deletion (which are essentially identical): </p><br><pre> <code class="hljs pgsql">test "deletes a comment when an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, socket) refute Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "does not delete a comment when not an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:error, message} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> message == "User is not authorized" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  As I mentioned earlier, our tests are almost identical, with the exception of a positive outcome, in which we see that the comment has been deleted and is no longer represented in the database. </p><br><p>  Let's check that we cover the code with tests properly.  To do this, run the following command: </p><br><pre> <code class="hljs bash">$ mix <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/channels/comment_helper_test.exs --cover</code> </pre> <br><p>  It will create a report in the <code>[project root]/cover</code> directory, which will tell us which code is not covered by the tests.  If all tests are green, open the file in the browser <code>./cover/Elixir.Pxblog.CommentHelper.html</code> .  If you see red, then this code is not covered by tests.  No red means 100% coverage. </p><br><p>  The complete file with the comments helper tests is as follows: </p><br><pre> <code class="hljs pgsql">defmodule Pxblog.CommentHelperTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Pxblog.ModelCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.CommentHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) post = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:post, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, post: post, approved: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) fake_socket = %{assigns: %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id}} {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: fake_socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> our tests <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> this <span class="hljs-type"><span class="hljs-type">line</span></span> test "creates a comment for a post", %{post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(%{ "postId" =&gt; post.id, "author" =&gt; "Some Person", "body" =&gt; "Some Post" }, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "approves a comment when an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.approve(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, socket) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.approved <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "does not approve a comment when not an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:error, message} = CommentHelper.approve(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> message == "User is not authorized" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "deletes a comment when an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, socket) refute Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "does not delete a comment when not an authorized user", %{post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:error, message} = CommentHelper.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(%{"postId" =&gt; post.id, "commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id}, %{}) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> message == "User is not authorized" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2 id="testiruem-kanal-kommentariev">  Testing the comment channel </h2><br><p>  The generator has already created for us the basis of channel tests, it remains to fill them with meat.  Let's start by adding the <code>Pxblog.Factory</code> alias to use the factories in the <code>setup</code> block.  Actually, everything is as before.  Then you need to set up a socket, namely, introduce yourself as a created user and connect to the comments channel of the created post.  Leave the <code>ping</code> and <code>broadcast</code> tests in place, but remove the <code>shout</code> tests, since we no longer have this handler.  In the file <code>test/channels/comment_channel_test.exs</code> : </p><br><pre> <code class="hljs pgsql">defmodule Pxblog.CommentChannelTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Pxblog.ChannelCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.CommentChannel <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Factory setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = Factory.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) post = Factory.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(:post, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = Factory.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, post: post, approved: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {:ok, _, socket} = socket("user_id", %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id}) |&gt; subscribe_and_join(CommentChannel, "comments:#{post.id}") {:ok, socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "ping replies with status ok", %{socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> = push socket, "ping", %{"hello" =&gt; "there"} assert_reply <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>, :ok, %{"hello" =&gt; "there"} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "broadcasts are pushed to the client", %{socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast_from! socket, "broadcast", %{"some" =&gt; "data"} assert_push "broadcast", %{"some" =&gt; "data"} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We have written quite complete tests for the <code>CommentHelper</code> module, so here we‚Äôll leave the tests directly related to the functionality of the channels.  Let's create a test for three messages: <code>CREATED_COMMENT</code> , <code>APPROVED_COMMENT</code> and <code>DELETED_COMMENT</code> . </p><br><pre> <code class="hljs php">test <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT broadcasts to comments:*"</span></span>, %{socket: socket, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> push socket, <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post.id} expected = %{<span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Author"</span></span>} assert_broadcast <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, expected end</code> </pre> <br><p>  If you have never seen channel tests before, then everything seems new.  Let's understand the steps. </p><br><p>  We start by passing to the test socket and the post created in the <code>setup</code> block.  In the next line, we send a <code>CREATED_COMMENT</code> event to the socket along with an associative array, similar to what the client actually sends to the socket. </p><br><p>  The following describes our "expectations".  <strong>For now, you cannot define a list that refers to any other variables inside the <code>assert_broadcast</code> function</strong> , so you should develop a habit of defining the expected values ‚Äã‚Äãseparately and passing the <code>expected</code> variable to the <code>assert_broadcast</code> call.  Here we expect the values ‚Äã‚Äãof <code>body</code> and <code>author</code> match what we passed inside. </p><br><p>  Finally, we check that the <code>CREATED_COMMENT</code> message was translated along with the expected associative array. </p><br><p>  Now go to the <code>APPROVED_COMMENT</code> event: </p><br><pre> <code class="hljs pgsql">test "APPROVED_COMMENT broadcasts to comments:*", %{socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> push socket, "APPROVED_COMMENT", %{"commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, "postId" =&gt; post.id, approved: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>} expected = %{"commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, "postId" =&gt; post.id, approved: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} assert_broadcast "APPROVED_COMMENT", expected <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  This test is largely similar to the previous one, except that we pass the <code>approved</code> value of <code>false</code> to the socket and expect to see the value of <code>approved</code> equal to <code>true</code> after execution.  Notice that in the variable <code>expected</code> we use <code>commentId</code> and <code>postId</code> as pointers to <code>comment.id</code> and <code>post.id</code>  These expressions will cause an error, so you need to use the separation of the expected variable in the <code>assert_broadcast</code> function. </p><br><p>  Finally, take a look at the test for the <code>DELETED_COMMENT</code> message: </p><br><pre> <code class="hljs pgsql">test "DELETED_COMMENT broadcasts to comments:*", %{socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> payload = %{"commentId" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.id, "postId" =&gt; post.id} push socket, "DELETED_COMMENT", payload assert_broadcast "DELETED_COMMENT", payload <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Nothing particularly interesting.  We transfer the standard data to the socket and check that we are broadcasting the event about deleting the comment. </p><br><p>  Just as we did with <code>CommentHelper</code> , <code>CommentHelper</code> 's run tests specifically for this file with the <code>--cover</code> option: </p><br><pre> <code class="hljs bash">$ mix <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/channels/comment_channel_test.exs --cover</code> </pre> <br><p>  You will receive warnings that the <strong><code>expected</code> variable is not used</strong> , which can be safely ignored. </p><br><pre> <code class="hljs vhdl">test/channels/comment_channel_test.exs:<span class="hljs-number"><span class="hljs-number">31</span></span>: <span class="hljs-literal"><span class="hljs-literal">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> unused test/channels/comment_channel_test.exs:<span class="hljs-number"><span class="hljs-number">37</span></span>: <span class="hljs-literal"><span class="hljs-literal">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> unused</code> </pre> <br><p>  If you have opened the <code>./cover/Elixir.Pxblog.CommentChannel.html</code> file and do not see anything red, then you can shout "Hurray!".  Full coverage! </p><br><p>  The final version of the <code>CommentChannel</code> test should look like this: </p><br><pre> <code class="hljs sql">defmodule Pxblog.CommentChannelTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pxblog.ChannelCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.CommentChannel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) post = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:post, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, post: post, approved: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) {:ok, _, socket} = socket(<span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: user.id}) |&gt; subscribe_and_join(CommentChannel, <span class="hljs-string"><span class="hljs-string">"comments:#{post.id}"</span></span>) {:ok, socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"ping replies with status ok"</span></span>, %{socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> = push socket, <span class="hljs-string"><span class="hljs-string">"ping"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"hello"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"there"</span></span>} assert_reply <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>, :ok, %{<span class="hljs-string"><span class="hljs-string">"hello"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"there"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"broadcasts are pushed to the client"</span></span>, %{socket: socket} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> broadcast_from! socket, <span class="hljs-string"><span class="hljs-string">"broadcast"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"some"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"data"</span></span>} assert_push <span class="hljs-string"><span class="hljs-string">"broadcast"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"some"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"data"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT broadcasts to comments:*"</span></span>, %{socket: socket, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> push socket, <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post.id} expected = %{<span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test Author"</span></span>} assert_broadcast <span class="hljs-string"><span class="hljs-string">"CREATED_COMMENT"</span></span>, expected <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"APPROVED_COMMENT broadcasts to comments:*"</span></span>, %{socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> push socket, <span class="hljs-string"><span class="hljs-string">"APPROVED_COMMENT"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"commentId"</span></span> =&gt; comment.id, <span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post.id, approved: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} expected = %{<span class="hljs-string"><span class="hljs-string">"commentId"</span></span> =&gt; comment.id, <span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post.id, approved: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} assert_broadcast <span class="hljs-string"><span class="hljs-string">"APPROVED_COMMENT"</span></span>, expected <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"DELETED_COMMENT broadcasts to comments:*"</span></span>, %{socket: socket, post: post, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> payload = %{<span class="hljs-string"><span class="hljs-string">"commentId"</span></span> =&gt; comment.id, <span class="hljs-string"><span class="hljs-string">"postId"</span></span> =&gt; post.id} push socket, <span class="hljs-string"><span class="hljs-string">"DELETED_COMMENT"</span></span>, payload assert_broadcast <span class="hljs-string"><span class="hljs-string">"DELETED_COMMENT"</span></span>, payload <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2 id="finalnye-shtrihi">  Final touches </h2><br><p>  Since the test coverage report can be easily created using Mix, it doesn't make sense to include it in Git history, so open the <code>.gitignore</code> file and add the following line to it: </p><br><pre> <code class="hljs vhdl">/<span class="hljs-keyword"><span class="hljs-keyword">cover</span></span></code> </pre> <br><p>  That's all!  Now we have a completely test-covered channel code (with the exception of the Javascript tests, which are a separate world that does not fit into this series of lessons).  In the next part, we will move on to work on the UI, make it a little nicer and more functional, and also replace the standard styles, logos, etc., to make the project look more professional.  In addition, the ease of use of our site is now absolutely no.  We will fix this too, so that people would like to use our blogging platform! </p><br><h2 id="drugie-stati-serii">  Other series articles </h2><br><ol><li>  <a href="https://habrahabr.ru/post/311088/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/313482/">Authorization</a> </li><li>  <a href="https://habrahabr.ru/post/315252/">Adding Roles</a> </li><li>  <a href="https://habrahabr.ru/post/316368/">Process roles in controllers</a> </li><li>  <a href="https://habrahabr.ru/post/316996/">We connect ExMachina</a> </li><li>  <a href="https://habrahabr.ru/post/317550/">Markdown support</a> </li><li>  <a href="https://habrahabr.ru/post/318790/">Add comments</a> </li><li>  <a href="https://habrahabr.ru/post/323462/">We finish with comments</a> </li><li>  <a href="https://habrahabr.ru/post/332094/">Channels</a> </li><li>  Channel testing </li><li>  <a href="https://habrahabr.ru/post/335048/">Conclusion</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333020/">https://habr.com/ru/post/333020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333008/index.html">Doctor Web: gosuslugi.ru portal has been compromised and may begin to infect visitors or steal information</a></li>
<li><a href="../333012/index.html">Testing in Openshift: Internal cluster structure</a></li>
<li><a href="../333014/index.html">Testing in Openshift: Automated Testing</a></li>
<li><a href="../333016/index.html">Delhi - cut, or as we did mobile 2GIS Online</a></li>
<li><a href="../333018/index.html">What is ERP system</a></li>
<li><a href="../333024/index.html">Top Achievement Code</a></li>
<li><a href="../333026/index.html">Capture all .io domains with targeted registration</a></li>
<li><a href="../333028/index.html">Whats going on with HEVC (h265)</a></li>
<li><a href="../333030/index.html">Bare words in javascript</a></li>
<li><a href="../333032/index.html">Why the guide does not accept agile and what can you do about it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>