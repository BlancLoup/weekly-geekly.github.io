<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The method of recursive coordinate bisection for decomposition of computational grids</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Computational grids are widely used in solving numerical problems using finite difference methods. The quality of the construction of s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The method of recursive coordinate bisection for decomposition of computational grids</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0a6/8e3/7b9/0a68e37b99d849bd92f7539d5818d3fe.png"><br><br><h2>  Introduction </h2><br>  Computational grids are widely used in solving numerical problems using finite difference methods.  The quality of the construction of such a grid largely determines the success in solving, therefore sometimes the grids reach huge sizes.  In this case, multiprocessor systems come to the rescue, because they allow to solve 2 problems at once: <br><br><ol><li>  Increase the speed of the program. </li><li>  Work with grids of a size that does not fit in the RAM of one processor. </li></ol><br>  With this approach, the grid covering the computational domain is divided into a number of domains, each of which is processed by a separate processor.  The main problem here is the ‚Äúfairness‚Äù of the split: you need to choose such a decomposition, in which the computational load is distributed evenly between the processors, and the overhead costs caused by duplication of calculations and the need to transfer data between processors are small. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A typical example of a two-dimensional computational grid is shown in the first picture.  It describes the space around the wing and the flap of the aircraft, the grid nodes are condensing to fine details.  Despite the visual difference in the sizes of the multi-colored zones, each of them contains approximately the same number of nodes, i.e.  You can talk about good decomposition.  This is the task we will solve. <br><a name="habracut"></a><br>  <i>Note: since parallel sorting is actively used in the algorithm, to understand the article it is strongly recommended to know what a " <a href="https://habrahabr.ru/post/275889/">Exchange exchange network with Batcher merge</a> " is.</i> <br><br><h2>  Formulation of the problem </h2><br>  For simplicity, we assume that we have single-core processors.  Once again, to avoid confusion: <br>  <b>1 processor = 1 core</b> .  Computing system with distributed memory, so we will use the technology MPI.  In practice, in such systems, multi-core processors, and thus for the most efficient use of computing resources, threads should also be used. <br><br>  We will restrict grids to regular two-dimensional ones, i.e.  such that a node with indices <i>(i, j) is</i> connected to adjacent nodes existing in i, j: <i>(i-1, j), (i + 1, j), (i, j-1), (i, j +1)</i> .  As it is easy to see, the grid in the upper picture is not regular, examples of regular grids are shown below: <br><br><img src="https://habrastorage.org/files/28b/684/12e/28b68412e23747f0978ae7be0115b825.jpg"><img src="https://habrastorage.org/files/fb2/c6f/e1d/fb2c6fe1d4ed48f787c61fe366da3a75.jpg"><br>  Thanks to this, it is possible to store the grid topology in a very compact way, which can significantly reduce both memory consumption and program operation time (after all, much less data needs to be sent over the network between processors). <br><br>  The program receives 3 arguments at the entrance: <br><br><ul><li>  <i>n1, n2</i> - dimensions of a two-dimensional grid. </li><li>  <i>k</i> is the number of domains (parts) into which the grid is to be split. </li></ul><br>  The initialization of coordinates takes place inside the program and, generally speaking, it does not matter how it happens (you can see how it is done in the source code, the link to which is at the end of the article, but I will not dwell on this in detail). <br><br>  We will store one mesh node in the following structure: <br><br><pre><code class="hljs pgsql">struct <span class="hljs-type"><span class="hljs-type">Point</span></span>{ <span class="hljs-type"><span class="hljs-type">float</span></span> coord[<span class="hljs-number"><span class="hljs-number">2</span></span>]; // <span class="hljs-number"><span class="hljs-number">0</span></span> - x, <span class="hljs-number"><span class="hljs-number">1</span></span> - y <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; };</code> </pre> <br>  In addition to the coordinates of a point, there is also a node index, which has 2 assignments.  First, it‚Äôs enough to restore the mesh topology.  Secondly, it can be used to distinguish fictitious elements from normal ones (for example, for fictitious elements, the value of this field is set to -1).  About what these fictitious elements are and why they are needed will be described in detail below. <br><br>  The grid itself is stored in the array <i>Point P [n1 * n2]</i> , where the node with indices <i>(i, j)</i> is in <i>P [i * n2 + j]</i> .  As a result of the program, the number of vertices in the domains must be equal to one vertex in the value <i>(n1 * n2 / k)</i> . <br><br><h2>  Algorithm of the decision </h2><br>  The procedure of recursive coordinate bisection consists of 3 steps: <br><br><ol><li>  Sorting an array of nodes along one of the coordinate axes (in the two-dimensional case along x or y). </li><li>  Splitting a sorted array into 2 parts. </li><li>  Recursive procedure start for received subarrays. </li></ol><br>  The basis of the recursion here is the case k = 1 (there is 1 domain left).  Something like this happens: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/f39/5b9/cdd/f395b9cdd9de476eb56e818bdd8e9431.png"></div><br>  And maybe so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a8b/932/c8f/a8b932c8facb40478c32f20ee0da9277.png"></div><br>  Where did the ambiguity come from?  It is easy to see that I did not specify the criterion for choosing the axis, it was from here that various options appeared (at the first step, in the first case, the sorting goes along the x axis, and in the second, y).  So how to choose an axis? <br><br><ol><li>  Randomly. <br><br>  Cheap and angry, but takes only 1 line of code and requires a minimum of time.  For simplicity, the demonstration program uses a similar method (in fact, there the axis is simply reversed at each step, but from the conceptual point of view it is the same).  If you want to write well - do not do so. <br><br></li><li>  For geometrical reasons. <br><br>  The length of the cut is minimized (in the general case, the cut is a hyperplane, therefore in the multidimensional case it is more correct to speak about the area).  To do this, select points with minimum and maximum coordinate values ‚Äã‚Äãand then measure the length based on some metric.  Then it suffices to compare the obtained lengths and select the corresponding axis.  Of course, it is easy to find a counterexample here: <br><br><img src="https://habrastorage.org/files/910/8b8/648/9108b864812142ba941fef4fe27d1a0d.png"><br><br>  The vertical section is shorter, but intersects 9 edges, while the longer horizontal section intersects only 4 edges.  Moreover, such grids are not a degenerate case, but are used in problems.  However, this option represents a balance between the speed and quality of the partition: it does not require as many calculations as in the third variant, but the quality of the partition is usually better than in the first case. <br><br></li><li>  Minimize the number of ribs cut. <br><br>  A cut edge is an edge connecting vertices from different domains.  Thus, if this number is minimized, then the domains are obtained as more ‚Äúautonomous‚Äù as possible, so we can speak of a high quality partitioning.  So, in the picture above, this algorithm will select the horizontal axis.  You have to pay for this speed, because you need to sort the array one by one along each of the axes, and then count the number of cut edges. </li></ol><br>  Still it is necessary to stipulate how to break an array.  Let <i>m = n1 * n2</i> (the total number of nodes and the length of the array <i>P</i> ), and <i>k the</i> number of domains (as before).  Then we try to divide the number of domains in half, and then divide the array in the same ratio.  In the form of formulas: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k1 = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k2 = k - k1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = m * (k1 / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)k); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m2 = m - m1;</code> </pre> <br>  In the example: split 9 elements into 3 domains ( <i>m = 9, k = 3</i> ).  Then, first, the array will be divided in the ratio of 6 to 3, and then the array of 6 elements will be split in half.  As a result, we get 3 domains with 3 elements each.  What you need. <br><br>  <i>Note: some may ask, why in the expression for m1 you need real arithmetic, because without using it you get the same result?</i>  <i>The whole thing is overflow, for example, when the grid of 10000x10000 is divided into 100 domains with m * k1 = 10 <sup>10</sup> , which goes beyond the boundaries of the int range.</i>  <i>Be careful!</i> <br><br><h2>  Sequential algorithm </h2><br>  Having dealt with the theory, you can proceed to the implementation.  For sorting, we will use the <i>qsort ()</i> function from the C standard library.  Our function will take 6 arguments: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_decompose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *domains, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> domain_start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array_start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Here: <br><br><ul><li>  <i>a</i> is the original mesh. </li><li>  <i>domains</i> is the output array in which the domain numbers for grid nodes are stored (has the same length as array <i>a</i> ). </li><li>  <i>domain_start</i> - starting index of available domain numbers. </li><li>  <i>k</i> is the number of elements available. </li><li>  <i>array_start</i> - the initial element in the array. </li><li>  <i>n</i> is the number of elements in the array. </li></ul><br>  First we write the basis of the recursion: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_decompose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *domains, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> domain_start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array_start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(k == <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) domains[array_start + i] = domain_start; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  If we have only 1 domain left, then we put all available grid nodes into it.  Then we select the axis and sort the grid along it: <br><br><pre> <code class="hljs objectivec"> axis = !axis; qsort(a + array_start, n, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Point), compare_points);</code> </pre> <br>  The axis can be selected in one of the ways suggested above.  In this example, as mentioned earlier, it simply changes to the opposite.  Here, <i>axis</i> is a global variable that is used in the <i>compare_points ()</i> element comparison function: <br><br><pre> <code class="hljs coffeescript">int compare_points(const void *a, const void *b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point*)</span></span></span><span class="hljs-function">a)-&gt;</span></span>coord[axis] &lt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point*)</span></span></span><span class="hljs-function">b)-&gt;</span></span>coord[axis]){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point*)</span></span></span><span class="hljs-function">a)-&gt;</span></span>coord[axis] &gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point*)</span></span></span><span class="hljs-function">b)-&gt;</span></span>coord[axis]){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br>  Now it remains for us to split the domains and grid nodes available to us using the appropriate formulas: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k1 = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k2 = k - k1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = n * (k1 / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)k); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 = n - n1;</code> </pre> <br>  And write a recursive call: <br><br><pre> <code class="hljs lisp"> local_decompose(<span class="hljs-name"><span class="hljs-name">a</span></span>, domains, domain_start, k1, array_start, n1)<span class="hljs-comment"><span class="hljs-comment">; local_decompose(a, domains, domain_start + k1, k2, array_start + n1, n2); }</span></span></code> </pre> <br>  That's all.  The full source code for the <i>local_decompose ()</i> function is available on the github. <br><br><h2>  Parallel algorithm </h2><br>  Although the algorithm is the same, its parallel implementation is much more complicated.  I associate this with two main reasons: <br><br>  1) The system uses distributed memory, so each processor stores only its part of the data without seeing the entire grid.  Because of this, when dividing an array, it is necessary to redistribute elements. <br><br>  2) As a sorting algorithm, Betcher's parallel sorting is used, for its operation it is necessary that each processor have the same number of elements. <br><br>  First, let's deal with the second problem.  The solution is trivial - you need to enter the fictitious elements, which were mentioned in passing earlier.  This is where the <i>index</i> field in the <i>Point</i> structure comes in handy.  We make it equal to -1 - and we have a dummy element!  It seems everything is fine, but with this decision we have significantly aggravated the first problem.  In general, at the stage of dividing an array into 2 parts, it becomes impossible to determine not only the dividing element itself, but even the processor on which it is located.  Let me explain this with an example: suppose we have 9 elements (a 3x3 grid) that need to be divided into 3 domains on 4 processors, i.e.  n = 9, k = 3, p = 4. Then, after sorting, the dummy elements can appear anywhere (in the picture green grid nodes are marked, and red dummy elements): <br><br><img src="https://habrastorage.org/files/fc1/a95/292/fc1a9529226c430a92af11ca81ff2b88.png"><br><br>  In this case, the first element of the second array will be in the middle of a 2 processor.  But if the dummy elements are arranged differently, then everything will change: <br><br><img src="https://habrastorage.org/files/134/9e7/c93/1349e7c937dd45d3b739b4c0662c1f7e.png"><br><br>  Here, the breaking element was already on the last processor.  To avoid this ambiguity, apply a small hack: let's make the coordinates of the dummy elements as possible as possible (since they are stored in variables of type <i>float</i> in the program, the value will be <i>FLT_MAX</i> ).  As a result, dummy elements will always be at the end: <br><br><img src="https://habrastorage.org/files/03c/c64/1f8/03cc641f892c49e3b14d406b665bf2e4.png"><br><br>  The picture clearly shows that with this approach dummy elements will prevail on the latest processors.  These processors will do useless work, sorting dummy items at each recursion step.  However, now the definition of the splitting element becomes a trivial task, it will be located on the processor with the number: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = n1 / elem_per_proc;</code> </pre> <br>  And have the following index in the local array: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = n1 % elem_per_proc;</code> </pre> <br>  When a dividing element is defined, the processor containing it starts the procedure of redistributing elements: it distributes all elements to the dividing processor to the ‚Äúbefore‚Äù processors (i.e., with numbers smaller than it), adding dummy ones if necessary.  He replaces sent items with fictitious ones.  In the pictures for n = 15, k = 5, p = 4: <br><br><img src="https://habrastorage.org/files/742/090/c39/742090c395cd43c18665f545246e7c66.png"><br><img src="https://habrastorage.org/files/45f/0f0/595/45f0f0595a8b4c2fba4441b1b14dfaf7.png"><br><br>  Now processors with numbers less than <i>pc</i> will continue to work with the first part of the original array, and the rest, in parallel, with the second part.  At the same time, within the same group, the number of elements on all processors is the same (although in the second group it may be different), which allows further use of Betcher sorting.  Do not forget that the case <i>pc = 0</i> is possible - then it is enough to send items to the ‚Äúother side‚Äù, i.e.  on processors with large numbers. <br><br>  The basis of the recursion in the parallel algorithm first of all should be considered the situation when we run out of processors: the case with <i>k = 1</i> remains, but rather is degenerate, since in practice the number of domains is usually larger than the number of processors. <br><br>  In view of the foregoing, the general scheme of the function will look like this: <br><br><div class="spoiler">  <b class="spoiler_title">General scheme of the decompose function</b> <div class="spoiler_text"><pre> <code class="hljs perl">void decompose(Point **array, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **domains, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> domain_start, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *elem_per_proc, MPI_Comm communicator) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rank, proc_count; MPI_Comm_rank(communicator, &amp;rank); MPI_Comm_size(communicator, &amp;proc_count); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(proc_count == <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     local_decompose(...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(k == <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //    <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k1 = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k2 = k - k1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n1 = n * (k1 / (double)k); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n2 = n - n1; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = n1 / (*elem_per_proc); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = n1 % (*elem_per_proc); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">2</span></span> ,    //     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pc == <span class="hljs-number"><span class="hljs-number">0</span></span>) color = rank &gt; pc ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = rank &gt;= pc ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; MPI_Comm new_comm; MPI_Comm_split(communicator, color, rank, &amp;new_comm); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         axis = ... sort_array(*array, *elem_per_proc, communicator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pc == <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        //     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //        //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rank &lt; pc) decompose(array, domains, domain_start, k1, n1, elem_per_proc, new_comm); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> decompose(array, domains, domain_start + k1, k2, n2, elem_per_proc, new_comm); }</code> </pre><br></div></div><br><h2>  Conclusion </h2><br>  The considered implementation of the algorithm has a number of drawbacks, but at the same time it has an undeniable advantage - it works!  The source code of the program can be found on <a href="https://github.com/PodnimatelPingvinov/CoordBisect">github</a> .  There is also an auxiliary utility for viewing the results.  In preparing this article, we used materials from the book by M. V. Yakobovsky ‚ÄúIntroduction to parallel methods for solving problems‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/321456/">https://habr.com/ru/post/321456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321444/index.html">We read Google tables from the web application</a></li>
<li><a href="../321446/index.html">How does it feel to be a developer in Russia when you're forty</a></li>
<li><a href="../321448/index.html">Load balancing and fault tolerance in Odnoklassniki</a></li>
<li><a href="../321452/index.html">CEF, Angular 2 using .Net Core class events</a></li>
<li><a href="../321454/index.html">Connecting Facebook SDK for Xamarin.Forms</a></li>
<li><a href="../321458/index.html">How we made the application of the international loyalty program PINS: case</a></li>
<li><a href="../321460/index.html">Games do not have to entertain</a></li>
<li><a href="../321462/index.html">Changes in the procedure for issuing a certificate for signing the code for Certum</a></li>
<li><a href="../321464/index.html">Stack Overflow told what languages ‚Äã‚Äãand programming technologies are popular as a hobby</a></li>
<li><a href="../321466/index.html">Telerik UI for UWP has become Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>