<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protection against DoS / DDoS attacks using autonomous system number (ASN) filtering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the light of the New Year holidays with their essential attribute - increased DoS / DDoS attack activity, I would like to raise one ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protection against DoS / DDoS attacks using autonomous system number (ASN) filtering</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In the light of the New Year holidays with their essential attribute - increased DoS / DDoS attack activity, I would like to raise one rather rarely used (but quite effective) way of repelling attacks - blocking based on the ownership of IP address blocks to a specific provider / Data Center. <br><img src="https://habrastorage.org/getpro/habr/post_images/6ba/0f2/4d4/6ba0f24d4f923d2a1d2425a092765fb7.jpg"><br><a name="habracut"></a><br>  On the Internet and on Habr√© there were a lot of publications on the subject of protection, but basically they boil down to the following approaches based on IP grouping on various grounds: <br><ul><li>  Block individual IP attacking bots </li><li>  Block whole subnets to which the bots belong </li><li>  Blocking entire countries / cities to which the attacking bots belong </li><li>  Blocking all IP addresses except those explicitly allowed </li><li>  Block IP addresses based on a specific algorithm (including the use of specialized hardware) </li></ul><br>  But at the same time, another way of grouping (and, therefore, blocking) IP addresses is completely unfairly missed - their membership in autonomous systems (ASN).  What is ASN?  This is a group of IP addresses that are served by one provider or Data Center.  Conventionally, this is a higher level of hierarchy, immediately following the concept of a network / subnet, but having an organizational origin.  Let us take Yandex as an example, their autonomous system number is 13238 and it owns the following blocks of IP addresses: as you can see, <a href="http://bgp.he.net/AS13238">bgp.he.net/AS13238#_prefixes</a> , there is no regularity other than belonging to the same ASN.  Another thing to note is that ASNs are of two types - 16 bit (up to 65635) and 32 bit (up to 2 ^ 32-1). <br><br>  But how does this technical excursion help protect against intruders?  The fact is that there is a rather wide list of providers (both ISP and Data Centers), which, to put it mildly, do not care about the security of their networks (do not block outgoing DDoS attacks, do not respond to complaints, etc.) and, as a result , quite often are sources of DDoS attacks.  Blocking such autonomous systems (temporary, of course) can greatly help in defending against attacks.  With detailed statistics of autonomous systems, which are most often the sources of attacks, you can find on the website: <a href="http://stopddos.ru/current/">stopddos.ru/current</a> (statistics almost in real time) <br><img src="https://habrastorage.org/getpro/habr/post_images/0c4/a41/15e/0c4a4115ebf1e4534d116c85789781a2.png"><br><br><h4>  Determining the number of autonomous system to which the IP address belongs </h4><br>  How to determine the autonomous system to which the IP address / network belongs?  It is quite simple.  If the IP address is in Europe (and therefore - in the RIPE jurisdiction), then you can use the command: whois ip_address / network.  Let's try on Yandex: <br><pre><code class="bash hljs">whois 93.158.146.0</code> </pre> <br>  Pay attention to the field ORIGIN, it just shows the autonomous system number. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/003/18b/d5d/00318bd5df8bed19b3bddccaebb925f6.png"><br><br>  If the IP addresses belong to another RIR (AFRINIC, LACNIC, etc.), then they do not have the concept of a route object and here the most universal advice I can give is to use a special service that allows you to convert an IP address to an ASN number: <a href="https://www.team-cymru.org/Services/ip-to-asn.html">www. team-cymru.org/Services/ip-to-asn.html</a> <br><br>  What else is remarkable service from CymRu, is the ability to automate and call from the console of this operation, which will be very appropriate if you use (when protecting against real attacks without it) automated traffic analyzers, log files to search for patterns and anomalies in context defined ASN. <br><br>  Well, for example, at this stage, we found the ASN (usually, of course, from several pieces to several dozen), from which the attack is coming, the next step is to check who owns it and for what purpose it serves so as not to accidentally cut off its own customers, this can be done through a service from Hurricane Electric, <a href="http://bgp.he.net/ASXXXX">bgp.he.net/ASXXXX</a> , where instead of XXXX you need to put the detected autonomous system number. <br><br><h4>  Blocking traffic from / to a specific ASN </h4><br>  But how do we block the traffic that comes to us from a certain ASN?  Any trunk provider has this function, the data center or carrier (and it is implemented via BGP), but it‚Äôs almost impossible for the end user to get this function.  Therefore, we will use Debian Wheezy and the iptables packet filter to cut off traffic from spurious ASNs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29a/859/18b/29a85918b9599642cfc7963291e11247.jpg"><br><br>  Of course, a standard solution that allows you to do something in style: <br><br><pre> <code class="bash hljs">iptables -I INPUT -p tcp --dport 80 -m asn --asn-number 11222 -j DROP</code> </pre><br>  It does not exist yet, so we have to improvise! <br><br>  Two different approaches immediately come to mind - ipset and geoip (yes, you have a question - what relation does it have to the question, but more on that later).  ipset allows you to block traffic belonging to a set of IP addresses or a set of IP networks, which basically suits us.  But this is not particularly flexible and I'm not sure that the Linux kernel will be enough if we create, say, 120 hashes for the autonomous systems we need and the management of such a set of hashes will be very, very problematic. <br><br>  Quite by chance, in the process of studying the xtables GeoIP module, it occurred to me that it uses approximately the same algorithm for determining whether a network belongs to a specific country, which we need to determine membership in a particular autonomous system.  In addition, there is a number of compelling comments from the author xtables GeoIP, judging by which approach is used by them is more optimal: <a href="http://xtables-addons.sourceforge.net/geoip.php">xtables-addons.sourceforge.net/geoip.php</a> <br><br>  So, let's first assemble and install the xtables geoip module and then we will unify it to solve the initial task - blocking by ASN. <br><br><h4>  Installing the xtables GeoIP Module </h4><br>  There were many such instructions, they are rather brief, so let me give here the full instructions. <br>  Install the required packages: <br><br><pre> <code class="bash hljs">apt-get install xtables-addons-common xtables-addons-source</code> </pre><br>  In Debian Wheezy, a lot of work has been done with the Xtables and now there is no need for additional gestures to get working modules from the Xtables package.  Also, due to the use of the DKMS framework, it is not necessary to re-compile the modules manually when updating / replacing the kernel - the system will automatically solve all this. <br><br>  Now a few words about how GeoIP works.  It uses a rather clever (in my opinion) approach, when lists of IP networks belonging to a particular country are given in binary format, stored in the server‚Äôs file system and loaded into memory when the iptables command affecting the country is called.  This allows you to provide high speed and save memory, as the full set of IP addresses of all networks in the world takes almost 500 megabytes in uncompressed form. <br><br>  For xtables, GeoIP uses network-to-country mapping bases taken from the MaxMind company site, but it is required to manually load and convert to the format that the xtables kernel module accepts. <br>  Go: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /tmp /usr/lib/xtables-addons/xt_geoip_dl</code> </pre><br>  After this operation, two files with the CSV extension will be found in the current folder, in which respectively there are lists of IP networks for the IPv6 and IPv4 protocols with an indication to which countries they belong. <br>  Now we need to convert these files to binary format: <br><br><pre> <code class="bash hljs">mkdir -p /usr/share/xt_geoip /usr/lib/xtables-addons/xt_geoip_build -D /usr/share/xt_geoip *.csv</code> </pre><br>  In the process of conversion, we will see many interesting informational messages, for example, the number of IP v4 / v6 ranges for each country: <br><pre> <code class="bash hljs">759 IPv6 ranges <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> RU Russian Federation 5401 IPv4 ranges <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> RU Russian Federation</code> </pre><br>  Everything, we are ready to work, we will try to cut off the traffic that comes, for example, from Zimbabwe: <br><br><pre> <code class="bash hljs">iptables -I INPUT -p tcp --dport 80 -m geoip --src-cc ZW -j DROP</code> </pre> <br>  The moment we give this command, the file /usr/share/xt_geoip/LE/ZW.iv4 will be taken from the file system and loaded into the kernel, which contains the list of IP countries. <br><br>  Pay attention, friends!  In no case do not use similar in the production of NO-WHERE-YES.  This is the best practice, as it is impossible to do on the Internet.  This can be done only temporarily, for example, in the case of active resistance to DDoS / DoS attacks, or just to calculate how much traffic comes from each country.  Always keep in mind that the relevance of GeoIP bases leaves much to be desired, and your key clients from New York may turn out to be in Zimbabwe banned by you (of course, deprived of access to your resource). <br><br><h4>  Creation of base on networks belonging to ASN in the MaxMind format. </h4><br>  To make your life as simple as possible, let's try to create a network-ASN mapping database in the same format that MaxMind stores network-country mapping data.  With this approach, we will be able to use the xt_geoip_build script without any changes. <br><br>  How to create a similar database?  First, we will need the current imprint of the Internet routing table, since the information on the network ownership of a particular ASN changes every minute and therefore it is not possible to always have a current base.  Where to take this print?  It is always up-to-date in the format MRT TABLE DUMP V2 on the website Routevievs.org: <a href="http://archive.routeviews.org/bgpdata/">archive.routeviews.org/bgpdata</a> . <br><br>  But there is a small problem with this format - it is very difficult to analyze and therefore we need a converter that is developed by RIPE and is called BgpDump: <a href="https://bitbucket.org/ripencc/bgpdump/wiki/Home">bitbucket.org/ripencc/bgpdump/wiki/Home</a> <br>  Unfortunately, there is no such converter in the Debian repository and we will have to compile it from the source code, this is rather trivial, I provide the instructions below: <br><br><pre> <code class="bash hljs">apt-get install -y libbz2-dev <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /usr/src wget http://www.ris.ripe.net/<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>/bgpdump/libbgpdump-1.4.99.13.tgz tar -xf libbgpdump-1.4.99.13.tgz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> libbgpdump-1.4.99.13 ./configure --prefix=/opt/libbgpdump mkdir /opt/libbgpdump make mv bgpdump /opt/libbgpdump</code> </pre><br>  But the format of the data that BgpDump generates does not match the MaxMind format and we need another converter (fortunately a lot simpler) that we implemented in Perl, you can take it to the address: <a href="https://raw.github.com/FastVPSEestiOu/xt_asn/master/bgp_table_to_text.pl">raw.github.com/FastVPSEestiOu/xt_asn/ master / bgp_table_to_text.pl</a> , then put it at /opt/bgp_table_to_text.pl and set the exec flag (chmod + x). <br><br>  Now we have a complete set of software for generating the ASN network in the MaxMind format.  To implement the entire task, you need to run a series of bash commands: <br><br><pre> <code class="bash hljs">rm -f /opt/bgp/asn.csv mkdir /opt/bgp <span class="hljs-comment"><span class="hljs-comment"># http://phpsuxx.blogspot.com/2011/12/full-bgp.html yesterday_date=$(date --date='1 days ago' '+%Y.%m') yesterday_date_with_day=$(date --date='1 days ago' '+%Y%m%d') # get routing data for yesterday at 5 o'clock wget http://archive.routeviews.org/bgpdata/${yesterday_date}/RIBS/rib.${yesterday_date_with_day}.0600.bz2 -O /opt/bgp/rib.bz2 #  ,       "" (25   i7 2600) /opt/libbgpdump/bgpdump /opt/bgp/rib.bz2 | /opt/bgp_table_to_text.pl &gt; /opt/bgp/asn.csv</span></span></code> </pre><br>  After that we convert in the same way as the data of Max Mind GeoIP: <br><br><pre> <code class="bash hljs">/usr/lib/xtables-addons/xt_geoip_build -D /usr/share/xt_geoip /opt/bgp/asn.csv</code> </pre><br>  As a result of the work of the command, almost 100 thousand files (2 for each ASN) will be created in the / usr / share / xt_geoip / LE / folder / and they will be used to load into the kernel filtering module. <br><br><h4>  Modifying xtables geoip to use it to determine if an IP belongs to a specific ASN </h4><br>  If we try to replace the ZW country name in the iptables command with an ASN number, for example, 11222, we will get an error: <br><br><pre> <code class="bash hljs">geoip: invalid country code <span class="hljs-string"><span class="hljs-string">'11222'</span></span></code> </pre><br><br>  What to do?  Look inside xt_geoip.  Here are a few words about how GeoIP works - it consists of a plugin for iptables (userspace), which loads the rules into the kernel and the kernel module (kernel space, respectively).  After a quick search through the code, we find that the Country Code in ISO3166 format is stored in an unsigned 16 bit number format that can hold numbers up to 65535. <br><br>  As we mentioned earlier, the ASN format is currently adopted 32-bit, so in order to filter traffic from / to 32-bit ASN (for example, 190111), a little improvisation will be required - you will need to find a free ASN number in the first 65 thousand (for example, free ASN 170) and transfer the list of networks in binary format to it (mv /usr/share/xt_geoip/LE/190111.iv4 /usr/share/xt_geoip/LE/170.iv4), but not forgetting that the ASN number is used "replaced". <br><br>  Such a hack will work fine even if you need to operate with all the ASN of the world!  Their total number today is ~ 46000 and is easily placed, taking into account permutations in a 16-bit unsigned number.  If at the time of reading the article, the ASN will become more than 65 thousand, then you will have to put a patch on the nuclear component of the GeoIP module, but it will be quite simple - will you need to replace the short int with a full int or even long (what if 64 bit ASNs appear?). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/4bb/fcf/ae84bbfcf01cc30bf3fb66c46f1c69b2.jpg"><br><br>  To achieve the possibility of using ASN numbers instead of two-letter country codes, we will patch the code a bit.  Namely, we will comment out the block in which there is a check that the specified iptables ‚Äúcountry‚Äù argument is exactly the two-letter ISO country code: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//if (strlen(cc) != 2) /* Country must be 2 chars long according // to the ISO3166 standard */ // xtables_error(PARAMETER_PROBLEM, // "geoip: invalid country code '%s'", cc); // Verification will fail if chars aren't uppercased. // Make sure they are.. //for (i = 0; i &lt; 2; i++) // if (isalnum(cc[i]) != 0) // cc[i] = toupper(cc[i]); // else // xtables_error(PARAMETER_PROBLEM, // "geoip: invalid country code '%s'", cc);</span></span></code> </pre><br>  And after that, we replace the packing code of two 8-bit characters into a 16-bit number with a code that simply reads a 16-bit number from the string and saves it: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//cc_int16 = (cc[0] &lt;&lt; 8) | cc[1]; // Convert 16 bit unsinged integer (up to 65535) sscanf(cc, "%d", &amp;cc_int16);</span></span></code> </pre><br>  You also need to change the code that displays the country code using the internal numeric representation of the country (16 bit number), now we simply display the number without conversions: <br><br><pre> <code class="cpp hljs">-<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s%c%c"</span></span>, i ? <span class="hljs-string"><span class="hljs-string">","</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, COUNTRY(info-&gt;cc[i])); +<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%sxas%d"</span></span>, i ? <span class="hljs-string"><span class="hljs-string">","</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, info-&gt;cc[i]);</code> </pre><br><br>  In this case, I allowed myself to replace asn with xas, since in some cases (32-bit ASN) this is not a real ASN number (but a wildcard number) and I would like to emphasize this. <br><br>  The final patch overlay file can be found here in our GitHub repository: <a href="">raw.github.com/FastVPSEestiOu/xt_asn/3e3eebe8b2136d148fe71adc1218a656c363ada2/libxt_geoip_patched.c</a> <br><br>  Now it's small, we need to compile the xtables-addons-common package (just in it is placed the module-extension for iptables, working in user space) by putting this patch on it: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /usr/src apt-get install -y dpkg-dev devscripts build-essential fakeroot apt-get <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> xtables-addons-common apt-get build-dep -y xtables-addons-common <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> xtables-addons-1.42 <span class="hljs-comment"><span class="hljs-comment">#     wget https://raw.github.com/FastVPSEestiOu/xt_asn/3e3eebe8b2136d148fe71adc1218a656c363ada2/libxt_geoip_patched.c -Oextensions/libxt_geoip.c dpkg-source --commit  "Patch for xtables geoip - ASN resolver" debuild -us -uc</span></span></code> </pre><br>  Now install the patched package: <br><br><pre> <code class="bash hljs">dpkg -i /usr/src/xtables-addons-common_1.42-2_amd64.deb</code> </pre><br>  And after that you can use 16-bit ASN numbers in the ipables rules: <br><br><pre> <code class="bash hljs">iptables -I INPUT -p tcp --dport 80 -m geoip --dst-cc 11222 -j DROP</code> </pre><br>  Now you are ready to repel another type of attack!  In addition, similar methods can be used to analyze the legitimate traffic that goes to your server :) <br><br>  Friends!  Good luck to you in the coming year and fewer DDoS attacks, your <a href="http://fastvps.ru/">FastVPS!</a> <br><img src="http://habrastorage.org/storage3/b4d/5d7/f45/b4d5d7f45379799520676fe183253c11.jpg"></div><p>Source: <a href="https://habr.com/ru/post/207628/">https://habr.com/ru/post/207628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207614/index.html">Data transfer in the vehicle monitoring system - DDF technology</a></li>
<li><a href="../207616/index.html">Python-digest # 8. News, interesting projects, articles and interviews [December 20, 2013 - December 27, 2013]</a></li>
<li><a href="../207620/index.html">Porting contrib themes to Drupal 8: Getting Twig themes</a></li>
<li><a href="../207622/index.html">SIP / SIMPLE text messages in Asterisk</a></li>
<li><a href="../207624/index.html">White and black</a></li>
<li><a href="../207636/index.html">We start the mobile direction in the company: what to prepare for and how to live</a></li>
<li><a href="../207638/index.html">Hints: API for entering email addresses and full name in one line</a></li>
<li><a href="../207640/index.html">Cost of servicing the regional component of EGISZ from Rostelecom</a></li>
<li><a href="../207644/index.html">10 facts about Python Meetup</a></li>
<li><a href="../207646/index.html">WDS and unattended installation of Windows 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>