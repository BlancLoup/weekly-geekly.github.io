<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deep learning with R and Keras on the example of the Carvana Image Masking Challenge</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 For a long time, users of R have been deprived of the opportunity to join deep learning, remaining within the framework of one programmin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deep learning with R and Keras on the example of the Carvana Image Masking Challenge</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/2c/mi/bx/2cmibxx-glgoxdmrznidpusrt5o.jpeg"><br><br>  Hi, Habr! <br><br>  For a long time, users of R have been deprived of the opportunity to join deep learning, remaining within the framework of one programming language.  With the release of <b><a href="https://github.com/apache/incubator-mxnet">MXNet, the</a></b> situation began to change, but the kind of documentation and frequent changes that break backward compatibility still limit the popularity of this library. <br><p>  Much more attractive is the use of R-interfaces to <b><a href="https://tensorflow.rstudio.com/">TensorFlow</a></b> and <b><a href="https://keras.rstudio.com/">Keras</a></b> with backends to choose from (TensorFlow, Theano, CNTK), detailed documentation and many examples.  In this message, the solution of the problem of image segmentation will be analyzed on the example of the <a href="https://www.kaggle.com/c/carvana-image-masking-challenge">Carvana Image Masking Challenge competition</a> ( <a href="https://www.linkedin.com/feed/update/urn:li:activity:6320656461345226752/">winners</a> ), in which you want to learn how to separate cars photographed from 16 different angles from the background.  The "neural network" part is fully implemented on <b>Keras</b> , <b><a href="https://github.com/ropensci/magick">magick</a></b> is responsible for image processing (interface to <b>ImageMagick</b> ), parallel processing is provided by <b>parallel</b> + <b>doParallel</b> + <b>foreach</b> (Windows) or <b>parallel</b> + <b>doMC</b> + <b>foreach</b> (Linux). </p><a name="habracut"></a><br><h3>  Content: </h3><br><ol><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">Installation of all necessary</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">Imaging: <b>magick</b> as an alternative to <b>OpenCV</b></a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">Parallel code execution on R in Windows and Linux</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/"><b>reticulate</b> and iterators</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">The segmentation task and loss function for it</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">U-Net architecture</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">Model training</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/340212/">Model based predictions</a> </li></ol><br><h4 id="section1">  1. Install all the necessary </h4><br><p>  We assume that the reader already has a Nvidia GPU with ‚â•4 GB of memory (less possible, but not so interesting), and the CUDA and cuDNN libraries are installed.  For Linux, the installation of the latter is simple ( <a href="http://guanghan.info/blog/en/my-works/building-our-personal-deep-learning-rig-gtx-1080-ubuntu-16-04-cuda-8-0rc-cudnn-7-tensorflowmxnetcaffedarknet/">one of numerous manuals</a> ), and for Windows it is even easier (see the section "CUDA &amp; cuDNN" in the <a href="https://mpopov.com/blog/r-win-gpu-tensorflow">manual</a> ). </p><br><p> Next, it is desirable to install the <a href="https://www.continuum.io/downloads">Anaconda</a> distribution with Python 3;  To save space, you can choose the minimum option Miniconda.  If suddenly the Python version in the distribution kit is ahead of the latest version supported by Tensorflow, you can replace it with a command like <code>conda install python=3.6</code> .  Also, everything will work with regular Python and virtual environments. </p><br><p>  The list of used R-packages is as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Package List for Windows</b> <div class="spoiler_text"><pre> <code class="hljs lisp">library(<span class="hljs-name"><span class="hljs-name">keras</span></span>) library(<span class="hljs-name"><span class="hljs-name">magick</span></span>) library(<span class="hljs-name"><span class="hljs-name">abind</span></span>) library(<span class="hljs-name"><span class="hljs-name">reticulate</span></span>) library(<span class="hljs-name"><span class="hljs-name">parallel</span></span>) library(<span class="hljs-name"><span class="hljs-name">doParallel</span></span>) library(<span class="hljs-name"><span class="hljs-name">foreach</span></span>)</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Package List for Linux</b> <div class="spoiler_text"><pre> <code class="hljs lisp">library(<span class="hljs-name"><span class="hljs-name">keras</span></span>) library(<span class="hljs-name"><span class="hljs-name">magick</span></span>) library(<span class="hljs-name"><span class="hljs-name">abind</span></span>) library(<span class="hljs-name"><span class="hljs-name">reticulate</span></span>) library(<span class="hljs-name"><span class="hljs-name">parallel</span></span>) library(<span class="hljs-name"><span class="hljs-name">doMC</span></span>) library(<span class="hljs-name"><span class="hljs-name">foreach</span></span>)</code> </pre> </div></div><br><p>  All of them are installed with CRAN, but <strong>Keras is</strong> better to take from Github: <code>devtools::install_github("rstudio/keras")</code> .  The subsequent launch of the <code>install_keras()</code> command will create a conda environment and install the correct versions of Python's <strong>Tensorflow</strong> and <strong>Keras in it</strong> .  If for some reason this command refused to work correctly (for example, it could not find the desired Python distribution), or specific versions of the used libraries are required, you should <a href="https://conda.io/docs/user-guide/tasks/manage-environments.html">create a</a> conda-environment yourself, install the necessary packages in it, and then in R <a href="https://rstudio.github.io/reticulate/articles/versions.html">specify the</a> package to <strong>reticulate</strong> This is the environment with the <code>use_condaenv()</code> command. </p><br><p>  The list of parameters used further: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">input_size</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">128</span></span> #    ,     epochs &lt;- <span class="hljs-number"><span class="hljs-number">30</span></span> #   batch_size &lt;- <span class="hljs-number"><span class="hljs-number">16</span></span> #   orig_width &lt;- <span class="hljs-number"><span class="hljs-number">1918</span></span> #    orig_height &lt;- <span class="hljs-number"><span class="hljs-number">1280</span></span> #    train_samples &lt;- <span class="hljs-number"><span class="hljs-number">5088</span></span> #    train_index &lt;- sample(<span class="hljs-number"><span class="hljs-number">1</span></span>:train_samples, round(train_samples * <span class="hljs-number"><span class="hljs-number">0.8</span></span>)) # <span class="hljs-number"><span class="hljs-number">80</span></span>% val_index &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>:train_samples)[-train_index] #    images_dir &lt;- <span class="hljs-string"><span class="hljs-string">"input/train/"</span></span> masks_dir &lt;- <span class="hljs-string"><span class="hljs-string">"input/train_masks/"</span></span></code> </pre> <br><h4 id="section2">  2. Working with images: <b>magick</b> as an alternative to <b>OpenCV</b> </h4><br><p>  When solving machine learning tasks on graphic data, one should be able to, at a minimum, read images from a disk and transfer them to the neural network in the form of arrays.  Usually it is also required to be able to perform various image transformations in order to implement the so-called augmentation - the addition of a training sample with artificial examples created from the samples actually present in the training sample itself.  Augmentation is (almost) always capable of increasing the quality of a model: basic understanding can be obtained, for example, from <a href="https://habrahabr.ru/company/smartengines/blog/264677/">this message</a> .  Looking ahead, we note that all this needs to be done quickly and multi-threaded: even on a relatively fast CPU and a relatively slow video card, the preparatory stage may be more resource-intensive than the actual training of the neural network. </p><br><p>  In Python, <b>OpenCV</b> is traditionally used to work with images.  Versions of this megablibrary for R have not yet been created, calling its functions through <strong>reticulate</strong> looks like an unsportsmanlike decision, so we will choose from the available alternatives. <br>  The top 3 most powerful graphics packages are as follows: </p><br><ul><li><p>  <strong><a href="https://www.bioconductor.org/packages/devel/bioc/vignettes/EBImage/inst/doc/EBImage-introduction.html">EBImage</a></strong> - a package created using S4-classes and placed in the Bioconductora repository, which implies the highest quality requirements for both the package itself and its documentation.  Unfortunately, to enjoy the extensive capabilities of this software product is hampered by its extremely low speed of work. </p><br></li><li><p>  <strong><a href="https://cran.r-project.org/web/packages/imager/vignettes/gettingstarted.html">imager</a></strong> - this package looks more interesting in terms of performance, since the main work in it is performed by compiled code in the person of the CImg sishnoy library.  Among the advantages can be noted the support of the "conveyor" operator <code>%&gt;%</code> (and other operators from <strong>magrittr</strong> ), tight integration with packages from the so-called.  <strong><a href="https://www.tidyverse.org/">tidyverse</a></strong> , including <strong>ggplot2</strong> , as well as support for the split-apply-combine ideology.  And only an incomprehensible bug that makes the functions for reading pictures on some PCs inoperable prevented the author of this message from choosing this package. </p><br></li><li>  <strong><a href="https://cran.r-project.org/web/packages/magick/vignettes/intro.html">magick</a></strong> is a wrapper for <strong><a href="https://www.imagemagick.org/Magick%2B%2B/STL.html">ImageMagick</a></strong> , developed and actively developed by members of the <a href="https://github.com/ropensci">rOpenSci</a> community.  Combines all the advantages of the previous package, stability, glitch-free and killer feature (useless as part of our task) in the form of integration with the <strong><a href="https://ropensci.org/technotes/2017/08/17/tesseract-16/">Tesseract</a></strong> OCR library.  Measurements of speed when performing reading and transformation of pictures on a different number of cores are given below.  Of the minuses, the esoteric syntax can be noted in places: for example, for trimming or resizing, you need to pass a <code>"100x150+50"</code> string to the function instead of the usual arguments like <code>height</code> and <code>width</code> .  And since our auxiliary functions for preprocessing will be parameterized just by these values, we will have to use ugly <code>paste0(...)</code> or <code>sprintf(...)</code> constructions. </li></ul><br><p>  Hereinafter, we will generally reproduce the <a href="https://github.com/petrosgk/Kaggle-Carvana-Image-Masking-Challenge">Kaggle Carvana Image Masking Challenge solution with Keras</a> from Peter and Giannakopoulos. </p><br><p>  You need to read the files in pairs - the image and the corresponding mask; you should also apply the same transformations to the image and the mask (turns, shifts, reflections, zoom) when using augmentation.  We implement reading in the form of a single function, which will immediately reduce the image to the desired size: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">imagesRead</span></span> &lt;- function(image_file, mask_file, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { img &lt;- image_read(image_file) img &lt;- image_scale(img, paste0(target_width, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) mask &lt;- image_read(mask_file) mask &lt;- image_scale(mask, paste0(target_width, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) list(img = img, mask = mask) }</code> </pre> <br><p>  The result of the function with the imposition of a mask on the image: </p><br><pre> <code class="hljs mel">img &lt;- <span class="hljs-string"><span class="hljs-string">"input/train/0cdf5b5d0ce1_01.jpg"</span></span> mask &lt;- <span class="hljs-string"><span class="hljs-string">"input/train_masks/0cdf5b5d0ce1_01_mask.png"</span></span> x_y_imgs &lt;- imagesRead(img, mask, target_width = <span class="hljs-number"><span class="hljs-number">400</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">400</span></span>) image_composite(x_y_imgs$img, x_y_imgs$mask, operator = <span class="hljs-string"><span class="hljs-string">"blend"</span></span>, compose_args = <span class="hljs-string"><span class="hljs-string">"60"</span></span>) %&gt;% image_write(path = <span class="hljs-string"><span class="hljs-string">"pics/pic1.jpg"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> = <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/my/tv/n_/mytvn_7e7-naoahaj_jmyxmkcgc.jpeg"><br><p><br>  The first type of augmentation will be a change in brightness (brightness), saturation and hue.  For obvious reasons, it applies to a color image, but not to a black and white mask: </p><br><pre> <code class="hljs matlab">randomBSH &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img, u = 0, brightness_shift_lim = c(90, 110)</span></span></span><span class="hljs-function">, # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">percentage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saturation_shift_lim</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(95, 105)</span></span></span><span class="hljs-function">, # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">current</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hue_shift_lim</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(80, 120)</span></span></span><span class="hljs-function">) { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rnorm(1)</span></span></span><span class="hljs-function"> &lt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightness_shift</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1, brightness_shift_lim[1], brightness_shift_lim[2])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saturation_shift</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1, saturation_shift_lim[1], saturation_shift_lim[2])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hue_shift</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1, hue_shift_lim[1], hue_shift_lim[2])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">img</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_modulate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img, brightness = brightness_shift, saturation = saturation_shift, hue = hue_shift)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">img</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><p>  This conversion is applied with a 50% probability (in half of the cases the original image will be returned: <code>if (rnorm(1) &lt; u) return(img)</code> ), the amount of change for each of the three parameters is randomly selected within the range of values ‚Äã‚Äãspecified as a percentage of the original magnitude. </p><br><p>  Also, with a probability of 50%, we will use horizontal reflections of the image and masks: </p><br><pre> <code class="hljs matlab">randomHorizontalFlip &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img, mask, u = 0)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rnorm(1)</span></span></span><span class="hljs-function"> &lt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list(img = img, mask = mask)</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img = image_flop(img)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mask</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_flop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mask)</span></span></span><span class="hljs-function">) }</span></span></code> </pre> <br><p>  Result: </p><br><pre> <code class="hljs mel">img &lt;- <span class="hljs-string"><span class="hljs-string">"input/train/0cdf5b5d0ce1_01.jpg"</span></span> mask &lt;- <span class="hljs-string"><span class="hljs-string">"input/train_masks/0cdf5b5d0ce1_01_mask.png"</span></span> x_y_imgs &lt;- imagesRead(img, mask, target_width = <span class="hljs-number"><span class="hljs-number">400</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">400</span></span>) x_y_imgs$img &lt;- randomBSH(x_y_imgs$img) x_y_imgs &lt;- randomHorizontalFlip(x_y_imgs$img, x_y_imgs$mask) image_composite(x_y_imgs$img, x_y_imgs$mask, operator = <span class="hljs-string"><span class="hljs-string">"blend"</span></span>, compose_args = <span class="hljs-string"><span class="hljs-string">"60"</span></span>) %&gt;% image_write(path = <span class="hljs-string"><span class="hljs-string">"pics/pic2.jpg"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> = <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/zo/9m/h1/zo9mh1beacgmmv3xf6-h8dbcuh8.jpeg"><br><p><br>  The remaining transformations for the further presentation are not fundamental, therefore we will not dwell on them. </p><br><p>  The last stage is the transformation of images into arrays: </p><br><pre> <code class="hljs lua">img2arr &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, target_width = 128, target_height = 128)</span></span></span></span> { result &lt;- aperm(as.numeric(image<span class="hljs-string"><span class="hljs-string">[[1]]</span></span>)[, , <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>], c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) # transpose dim(result) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(result) } mask2arr &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mask, target_width = 128, target_height = 128)</span></span></span></span> { result &lt;- t(as.numeric(mask<span class="hljs-string"><span class="hljs-string">[[1]]</span></span>)[, , <span class="hljs-number"><span class="hljs-number">1</span></span>]) # transpose dim(result) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(result) }</code> </pre> <br><p>  Transposing is necessary so that the image lines remain rows in the matrix: the image is formed line by line (as the scanning beam moves in the kinescope), while the matrices in R are filled in columns (column-major, or Fortran-style; for comparison, in <strong>numpy</strong> you can switch between column-major and row-major formats).  You can do without him, but it is more understandable. </p><br><h4 id="section3">  3. Parallel code execution on R in Windows and Linux </h4><br><p>  An overview of parallel computing in R can be obtained from the <a href="https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf">Package 'parallel'</a> manuals, <a href="https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf">Getting Started with doParallel and foreach</a> and <a href="https://cran.r-project.org/web/packages/doMC/vignettes/gettingstartedMC.pdf">Getting Started with doMC and foreach</a> .  The algorithm works as follows: </p><br><p>  Start the cluster with the required number of cores: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">cl</span></span> &lt;- makePSOCKcluster(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment"># doParallel</span></span></code> </pre> <br><p>  SOCK clusters are a universal solution that allows, among other things, the use of CPUs of several PCs.  Unfortunately, our example with iterators and neural network training works under Windows, but refuses to work under Linux.  In Linux, you can use the alternative <strong>doMC</strong> package, which creates clusters using forks of the original process.  The remaining steps are not necessary: </p><br><pre> <code class="hljs objectivec">registerDoMC(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-meta"><span class="hljs-meta"># doMC</span></span></code> </pre> <br><p>  Both <strong>doParallel</strong> and <strong>doMC</strong> serve as intermediaries between <strong>parallel</strong> and <strong>foreach</strong> functionality. </p><br><p>  When using <code>makePSOCKcluster()</code> you need to load the necessary packages and functions inside the cluster: </p><br><div class="spoiler">  <b class="spoiler_title">Download packages and features</b> <div class="spoiler_text"><pre> <code class="hljs lisp">clusterEvalQ(<span class="hljs-name"><span class="hljs-name">cl</span></span>, { library(<span class="hljs-name"><span class="hljs-name">magick</span></span>) library(<span class="hljs-name"><span class="hljs-name">abind</span></span>) library(<span class="hljs-name"><span class="hljs-name">reticulate</span></span>) imagesRead &lt;- function(<span class="hljs-name"><span class="hljs-name">image_file</span></span>, mask_file, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { img &lt;- image_read(<span class="hljs-name"><span class="hljs-name">image_file</span></span>) img &lt;- image_scale(<span class="hljs-name"><span class="hljs-name">img</span></span>, paste0(<span class="hljs-name"><span class="hljs-name">target_width</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) mask &lt;- image_read(<span class="hljs-name"><span class="hljs-name">mask_file</span></span>) mask &lt;- image_scale(<span class="hljs-name"><span class="hljs-name">mask</span></span>, paste0(<span class="hljs-name"><span class="hljs-name">target_width</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) return(<span class="hljs-name"><span class="hljs-name">list</span></span>(<span class="hljs-name"><span class="hljs-name">img</span></span> = img, mask = mask)) } randomBSH &lt;- function(<span class="hljs-name"><span class="hljs-name">img</span></span>, u = <span class="hljs-number"><span class="hljs-number">0</span></span>, brightness_shift_lim = c(<span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>), # percentage saturation_shift_lim = c(<span class="hljs-number"><span class="hljs-number">95</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span>), # of current value hue_shift_lim = c(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>)) { if (<span class="hljs-name"><span class="hljs-name">rnorm</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; u) return(<span class="hljs-name"><span class="hljs-name">img</span></span>) brightness_shift &lt;- runif(<span class="hljs-number"><span class="hljs-number">1</span></span>, brightness_shift_lim[<span class="hljs-number"><span class="hljs-number">1</span></span>], brightness_shift_lim[<span class="hljs-number"><span class="hljs-number">2</span></span>]) saturation_shift &lt;- runif(<span class="hljs-number"><span class="hljs-number">1</span></span>, saturation_shift_lim[<span class="hljs-number"><span class="hljs-number">1</span></span>], saturation_shift_lim[<span class="hljs-number"><span class="hljs-number">2</span></span>]) hue_shift &lt;- runif(<span class="hljs-number"><span class="hljs-number">1</span></span>, hue_shift_lim[<span class="hljs-number"><span class="hljs-number">1</span></span>], hue_shift_lim[<span class="hljs-number"><span class="hljs-number">2</span></span>]) img &lt;- image_modulate(<span class="hljs-name"><span class="hljs-name">img</span></span>, brightness = brightness_shift, saturation = saturation_shift, hue = hue_shift) img } randomHorizontalFlip &lt;- function(<span class="hljs-name"><span class="hljs-name">img</span></span>, mask, u = <span class="hljs-number"><span class="hljs-number">0</span></span>) { if (<span class="hljs-name"><span class="hljs-name">rnorm</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; u) return(<span class="hljs-name"><span class="hljs-name">list</span></span>(<span class="hljs-name"><span class="hljs-name">img</span></span> = img, mask = mask)) list(<span class="hljs-name"><span class="hljs-name">img</span></span> = image_flop(<span class="hljs-name"><span class="hljs-name">img</span></span>), mask = image_flop(<span class="hljs-name"><span class="hljs-name">mask</span></span>)) } img2arr &lt;- function(<span class="hljs-name"><span class="hljs-name">image</span></span>, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { result &lt;- aperm(<span class="hljs-name"><span class="hljs-name">as</span></span>.numeric(<span class="hljs-name"><span class="hljs-name">image</span></span>[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>], c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) # transpose dim(<span class="hljs-name"><span class="hljs-name">result</span></span>) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">3</span></span>) return(<span class="hljs-name"><span class="hljs-name">result</span></span>) } mask2arr &lt;- function(<span class="hljs-name"><span class="hljs-name">mask</span></span>, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { result &lt;- <span class="hljs-literal"><span class="hljs-literal">t</span></span>(<span class="hljs-name"><span class="hljs-name">as</span></span>.numeric(<span class="hljs-name"><span class="hljs-name">mask</span></span>[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">1</span></span>]) # transpose dim(<span class="hljs-name"><span class="hljs-name">result</span></span>) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">1</span></span>) return(<span class="hljs-name"><span class="hljs-name">result</span></span>) } })</code> </pre> </div></div><br><p>  Register the cluster as a parallel backend for <strong>foreach</strong> : </p><br><pre> <code class="hljs lisp">registerDoParallel(<span class="hljs-name"><span class="hljs-name">cl</span></span>)</code> </pre> <br><p>  After that, you can run the code in parallel mode: </p><br><pre> <code class="hljs smalltalk">imgs &lt;- list.files(<span class="hljs-comment"><span class="hljs-comment">"input/train/"</span></span>, pattern = <span class="hljs-comment"><span class="hljs-comment">".jpg"</span></span>, full.names = <span class="hljs-type"><span class="hljs-type">TRUE</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>] masks &lt;- list.files(<span class="hljs-comment"><span class="hljs-comment">"input/train_masks/"</span></span>, pattern = <span class="hljs-comment"><span class="hljs-comment">".png"</span></span>, full.names = <span class="hljs-type"><span class="hljs-type">TRUE</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>] x_y_batch &lt;- foreach(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>) %dopar% { x_y_imgs &lt;- imagesRead(image_file = batch_images_list[i], mask_file = batch_masks_list[i]) # augmentation x_y_imgs<span class="hljs-string"><span class="hljs-string">$i</span></span>mg &lt;- randomBSH(x_y_imgs<span class="hljs-string"><span class="hljs-string">$i</span></span>mg) x_y_imgs &lt;- randomHorizontalFlip(x_y_imgs<span class="hljs-string"><span class="hljs-string">$i</span></span>mg, x_y_imgs<span class="hljs-string"><span class="hljs-string">$m</span></span>ask) # return as arrays x_y_arr &lt;- list(x = img2arr(x_y_imgs<span class="hljs-string"><span class="hljs-string">$i</span></span>mg), y = mask2arr(x_y_imgs<span class="hljs-string"><span class="hljs-string">$m</span></span>ask)) } str(x_y_batch) # <span class="hljs-type"><span class="hljs-type">List</span></span> of <span class="hljs-number"><span class="hljs-number">16</span></span> # <span class="hljs-string"><span class="hljs-string">$ </span></span>:<span class="hljs-type"><span class="hljs-type">List</span></span> of <span class="hljs-number"><span class="hljs-number">2</span></span> # ..<span class="hljs-string"><span class="hljs-string">$ </span></span>x: num [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-number"><span class="hljs-number">0.953</span></span> <span class="hljs-number"><span class="hljs-number">0.957</span></span> <span class="hljs-number"><span class="hljs-number">0.953</span></span> <span class="hljs-number"><span class="hljs-number">0.949</span></span> <span class="hljs-number"><span class="hljs-number">0.949</span></span> ... # ..<span class="hljs-string"><span class="hljs-string">$ </span></span>y: num [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ... # <span class="hljs-string"><span class="hljs-string">$ </span></span>:<span class="hljs-type"><span class="hljs-type">List</span></span> of <span class="hljs-number"><span class="hljs-number">2</span></span> # ..<span class="hljs-string"><span class="hljs-string">$ </span></span>x: num [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-number"><span class="hljs-number">0.949</span></span> <span class="hljs-number"><span class="hljs-number">0.957</span></span> <span class="hljs-number"><span class="hljs-number">0.953</span></span> <span class="hljs-number"><span class="hljs-number">0.949</span></span> <span class="hljs-number"><span class="hljs-number">0.949</span></span> ... # ..<span class="hljs-string"><span class="hljs-string">$ </span></span>y: num [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ... # ....</code> </pre> <br><p>  In the end, do not forget to stop the cluster: </p><br><pre> <code class="hljs lisp">stopCluster(<span class="hljs-name"><span class="hljs-name">cl</span></span>)</code> </pre> <br><p>  With the help of the <strong>microbenchmark</strong> package, <strong>we will</strong> check what the benefits of using multiple cores / threads are.  On a GPU with 4 GB of memory, you can work with batch files of 16 pairs of images, which means that it is advisable to use 2, 4, 8 or 16 threads (the time is specified in seconds): </p><br><img src="https://habrastorage.org/webt/fn/bh/lm/fnbhlmflqid76smbezysmdte8wk.jpeg"><br><p>  It was not possible to check on 16 streams, but it is clear that when going from 1 to 4 streams, the speed increases about three times, which is very pleasing. </p><br><h4 id="section4">  4. <b>reticulate</b> and iterators </h4><br><p>  To work with data that does not fit in memory, we use iterators from the <strong>reticulate</strong> package.  The basis is a normal closure function (ie, a function that, when called, returns another function along with the call environment: </p><br><div class="spoiler">  <b class="spoiler_title">train_generator</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">train_generator &lt;- <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(images_dir, samples_index, masks_dir, batch_size) { images_iter &lt;- list.files(images_dir, pattern = ".jpg", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> epoch images_all &lt;- list.files(images_dir, pattern = ".jpg", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next epoch masks_iter &lt;- list.files(masks_dir, pattern = ".gif", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> epoch masks_all &lt;- list.files(masks_dir, pattern = ".gif", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next epoch <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length(images_iter) &lt; batch_size) { images_iter &lt;&lt;- images_all masks_iter &lt;&lt;- masks_all } batch_ind &lt;- sample(<span class="hljs-number"><span class="hljs-number">1</span></span>:length(images_iter), batch_size) batch_images_list &lt;- images_iter[batch_ind] images_iter &lt;&lt;- images_iter[-batch_ind] batch_masks_list &lt;- masks_iter[batch_ind] masks_iter &lt;&lt;- masks_iter[-batch_ind] x_y_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:batch_size) %dopar% { x_y_imgs &lt;- imagesRead(image_file = batch_images_list[i], mask_file = batch_masks_list[i]) # augmentation x_y_imgs$img &lt;- randomBSH(x_y_imgs$img) x_y_imgs &lt;- randomHorizontalFlip(x_y_imgs$img, x_y_imgs$mask) # <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> arrays x_y_arr &lt;- list(x = img2arr(x_y_imgs$img), y = mask2arr(x_y_imgs$mask)) } x_y_batch &lt;- purrr::transpose(x_y_batch) x_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(abind, c(x_y_batch$x, list(along = <span class="hljs-number"><span class="hljs-number">1</span></span>))) y_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(abind, c(x_y_batch$y, list(along = <span class="hljs-number"><span class="hljs-number">1</span></span>))) result &lt;- list(keras_array(x_batch), keras_array(y_batch)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(result) } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">val_generator</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">val_generator &lt;- <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(images_dir, samples_index, masks_dir, batch_size) { images_iter &lt;- list.files(images_dir, pattern = ".jpg", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> epoch images_all &lt;- list.files(images_dir, pattern = ".jpg", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next epoch masks_iter &lt;- list.files(masks_dir, pattern = ".gif", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> epoch masks_all &lt;- list.files(masks_dir, pattern = "gif", <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>.names = <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>)[samples_index] # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next epoch <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length(images_iter) &lt; batch_size) { images_iter &lt;&lt;- images_all masks_iter &lt;&lt;- masks_all } batch_ind &lt;- sample(<span class="hljs-number"><span class="hljs-number">1</span></span>:length(images_iter), batch_size) batch_images_list &lt;- images_iter[batch_ind] images_iter &lt;&lt;- images_iter[-batch_ind] batch_masks_list &lt;- masks_iter[batch_ind] masks_iter &lt;&lt;- masks_iter[-batch_ind] x_y_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:batch_size) %dopar% { x_y_imgs &lt;- imagesRead(image_file = batch_images_list[i], mask_file = batch_masks_list[i]) # <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> augmentation # <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> arrays x_y_arr &lt;- list(x = img2arr(x_y_imgs$img), y = mask2arr(x_y_imgs$mask)) } x_y_batch &lt;- purrr::transpose(x_y_batch) x_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(abind, c(x_y_batch$x, list(along = <span class="hljs-number"><span class="hljs-number">1</span></span>))) y_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(abind, c(x_y_batch$y, list(along = <span class="hljs-number"><span class="hljs-number">1</span></span>))) result &lt;- list(keras_array(x_batch), keras_array(y_batch)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(result) } }</code> </pre> </div></div><br><p>  Here, in the call environment, lists of processed files are decreasing during each epoch, as well as copies of complete lists that are used at the beginning of each next epoch.  In this implementation, there is no need to worry about randomly mixing files - each batch is obtained by random sampling. </p><br><p>  As shown above, <code>x_y_batch</code> is a list of 16 lists, each of which is a list of 2 arrays.  The function <code>purrr::transpose()</code> turns the nested lists inside out, and we get a list of 2 lists, each of which is a list of 16 arrays.  <code>abind()</code> joins arrays along the specified dimension, <code>do.call()</code> passes an arbitrary number of arguments to the internal function.  Additional arguments ( <code>along = 1</code> ) are specified in a rather bizarre way: <code>do.call(abind, c(x_y_batch$x, list(along = 1)))</code> . </p><br><p>  It remains to turn these functions into objects that are understandable for <strong>Keras</strong> , using <code>py_iterator()</code> : </p><br><pre> <code class="hljs lisp">train_iterator &lt;- py_iterator(<span class="hljs-name"><span class="hljs-name">train_generator</span></span>(<span class="hljs-name"><span class="hljs-name">images_dir</span></span> = images_dir, masks_dir = masks_dir, samples_index = train_index, batch_size = batch_size)) val_iterator &lt;- py_iterator(<span class="hljs-name"><span class="hljs-name">val_generator</span></span>(<span class="hljs-name"><span class="hljs-name">images_dir</span></span> = images_dir, masks_dir = masks_dir, samples_index = val_index, batch_size = batch_size))</code> </pre> <br><p>  Calling <code>iter_next(train_iterator)</code> will return the result of performing one iteration, which is useful at the debugging stage. </p><br><h4 id="section5">  5. The segmentation task and the loss function for it </h4><br><p>  The segmentation task can be considered as pixel-by-pixel classification: each pixel is predicted to belong to a particular class.  For the case of two classes, the result will be a mask;  if there are more than two classes, the number of masks will be equal to the number of classes minus 1 (analogous to one-hot encodind).  There are only two classes in our competition (the machine and the background), the quality metric is the <a href="https://en.wikipedia.org/wiki/S%25C3%25B8rensen%25E2%2580%2593Dice_coefficient">dice-factor</a> .  He calculates as follows: </p><br><pre> <code class="hljs matlab">K &lt;- backend() dice_coef &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_true, y_pred, smooth = 1.0)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y_true_f</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">K</span></span></span><span class="hljs-function">$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_true)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y_pred_f</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">K</span></span></span><span class="hljs-function">$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatten</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_pred)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersection</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">K</span></span></span><span class="hljs-function">$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_true_f * y_pred_f)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(2 * intersection + smooth)</span></span></span><span class="hljs-function"> / </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K$sum(y_true_f)</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">K</span></span></span><span class="hljs-function">$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_pred_f)</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smooth</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><p>  We will optimize the loss function, which is the sum of the cross-entropy and <code>1 - dice_coef</code> : </p><br><pre> <code class="hljs matlab">bce_dice_loss &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_true, y_pred)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> &lt;- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loss_binary_crossentropy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y_true, y_pred)</span></span></span><span class="hljs-function"> + </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1 - dice_coef(y_true, y_pred)</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h4 id="section6">  6. U-Net architecture </h4><br><p>  <a href="https://lmb.informatik.uni-freiburg.de/people/ronneber/u-net/">U-Net</a> is a classic architecture for solving segmentation problems.  Schematic diagram: </p><br><img src="https://habrastorage.org/webt/0y/w0/rz/0yw0rzavpcedbx5bv9oru0cnd-4.jpeg"><br><p>  <em>Source: <a href="https://www.researchgate.net/figure/311715357_fig3_Fig-3-U-NET-Architecture">https://www.researchgate.net/figure/311715357_fig3_Fig-3-U-NET-Architecture</a></em> </p><br><p>  Implementation for pictures 128x128: </p><br><div class="spoiler">  <b class="spoiler_title">U-Net 128</b> <div class="spoiler_text"><pre> <code class="hljs mel">get_unet_128 &lt;- function(input_shape = c(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), num_classes = <span class="hljs-number"><span class="hljs-number">1</span></span>) { inputs &lt;- layer_input(shape = input_shape) # <span class="hljs-number"><span class="hljs-number">128</span></span> down1 &lt;- inputs %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) down1_pool &lt;- down1 %&gt;% layer_max_pooling_2d(pool_size = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) # <span class="hljs-number"><span class="hljs-number">64</span></span> down2 &lt;- down1_pool %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) down2_pool &lt;- down2 %&gt;% layer_max_pooling_2d(pool_size = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) # <span class="hljs-number"><span class="hljs-number">32</span></span> down3 &lt;- down2_pool %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) down3_pool &lt;- down3 %&gt;% layer_max_pooling_2d(pool_size = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) # <span class="hljs-number"><span class="hljs-number">16</span></span> down4 &lt;- down3_pool %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) down4_pool &lt;- down4 %&gt;% layer_max_pooling_2d(pool_size = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) # <span class="hljs-number"><span class="hljs-number">8</span></span> center &lt;- down4_pool %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">1024</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">1024</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) # center up4 &lt;- center %&gt;% layer_upsampling_2d(<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) %&gt;% {layer_concatenate(inputs = list(down4, .), axis = <span class="hljs-number"><span class="hljs-number">3</span></span>)} %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) # <span class="hljs-number"><span class="hljs-number">16</span></span> up3 &lt;- up4 %&gt;% layer_upsampling_2d(<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) %&gt;% {layer_concatenate(inputs = list(down3, .), axis = <span class="hljs-number"><span class="hljs-number">3</span></span>)} %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) # <span class="hljs-number"><span class="hljs-number">32</span></span> up2 &lt;- up3 %&gt;% layer_upsampling_2d(<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) %&gt;% {layer_concatenate(inputs = list(down2, .), axis = <span class="hljs-number"><span class="hljs-number">3</span></span>)} %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) # <span class="hljs-number"><span class="hljs-number">64</span></span> up1 &lt;- up2 %&gt;% layer_upsampling_2d(<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) %&gt;% {layer_concatenate(inputs = list(down1, .), axis = <span class="hljs-number"><span class="hljs-number">3</span></span>)} %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) %&gt;% layer_conv_2d(filters = <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size = c(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), padding = <span class="hljs-string"><span class="hljs-string">"same"</span></span>) %&gt;% layer_batch_normalization() %&gt;% layer_activation(<span class="hljs-string"><span class="hljs-string">"relu"</span></span>) # <span class="hljs-number"><span class="hljs-number">128</span></span> classify &lt;- layer_conv_2d(up1, filters = num_classes, kernel_size = c(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), activation = <span class="hljs-string"><span class="hljs-string">"sigmoid"</span></span>) model &lt;- keras_model( inputs = inputs, outputs = classify ) model %&gt;% compile( optimizer = optimizer_rmsprop(lr = <span class="hljs-number"><span class="hljs-number">0.0001</span></span>), loss = bce_dice_loss, metrics = c(dice_coef) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(model) } model &lt;- get_unet_128()</code> </pre> </div></div><br><p>  The curly braces in <code>{layer_concatenate(inputs = list(down4, .), axis = 3)}</code> are needed to substitute the object as the desired argument, and not as the first in a row, as the <code>%&gt;%</code> operator would otherwise do.  You can offer many modifications of this architecture: use <code>layer_conv_2d_transpose</code> instead of <code>layer_upsampling_2d</code> , apply separate convolutions of <code>layer_separable_conv_2d</code> instead of usual ones, experiment with filter numbers and with optimizers settings.  Under the link <a href="https://github.com/petrosgk/Kaggle-Carvana-Image-Masking-Challenge">Kaggle Carvana Image Masking Challenge solution with Keras</a> there are options for resolutions up to 1024x1024, which are also easily ported to R. </p><br><p>  There are a lot of parameters in our model: </p><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># Total params: 34,540,737 # Trainable params: 34,527,041 # Non-trainable params: 13,696</span></span></code> </pre> <br><h4 id="section7">  7. Model training </h4><br><p>  It's simple.  Run the Tensorboard: </p><br><pre> <code class="hljs lisp">tensorboard(<span class="hljs-string"><span class="hljs-string">"logs_r"</span></span>)</code> </pre> <br><p>  Alternatively, the <strong><a href="https://tensorflow.rstudio.com/tools/tfruns/articles/overview.html">tfruns</a></strong> package is <strong><a href="https://tensorflow.rstudio.com/tools/tfruns/articles/overview.html">available</a></strong> , which adds an analogue of Tensorboard to the RStudio IDE and allows you to streamline the work of training neural networks. </p><br><p>  Specify the callback.  We will use the early stop, reduce the speed of learning when reaching the plateau and save the weight of the best model: </p><br><pre> <code class="hljs lisp">callbacks_list &lt;- list( <span class="hljs-name"><span class="hljs-name">callback_tensorboard</span></span>(<span class="hljs-string"><span class="hljs-string">"logs_r"</span></span>), callback_early_stopping(<span class="hljs-name"><span class="hljs-name">monitor</span></span> = <span class="hljs-string"><span class="hljs-string">"val_python_function"</span></span>, min_delta = <span class="hljs-number"><span class="hljs-number">1e-4</span></span>, patience = <span class="hljs-number"><span class="hljs-number">8</span></span>, verbose = <span class="hljs-number"><span class="hljs-number">1</span></span>, mode = <span class="hljs-string"><span class="hljs-string">"max"</span></span>), callback_reduce_lr_on_plateau(<span class="hljs-name"><span class="hljs-name">monitor</span></span> = <span class="hljs-string"><span class="hljs-string">"val_python_function"</span></span>, factor = <span class="hljs-number"><span class="hljs-number">0.1</span></span>, patience = <span class="hljs-number"><span class="hljs-number">4</span></span>, verbose = <span class="hljs-number"><span class="hljs-number">1</span></span>, epsilon = <span class="hljs-number"><span class="hljs-number">1e-4</span></span>, mode = <span class="hljs-string"><span class="hljs-string">"max"</span></span>), callback_model_checkpoint(<span class="hljs-name"><span class="hljs-name">filepath</span></span> = <span class="hljs-string"><span class="hljs-string">"weights_r/unet128_{epoch:02d}.h5"</span></span>, monitor = <span class="hljs-string"><span class="hljs-string">"val_python_function"</span></span>, save_best_only = TRUE, save_weights_only = TRUE, mode = <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) )</code> </pre> <br><p>  We start training and we wait.  On the GTX 1050ti, one era takes about 10 minutes: </p><br><pre> <code class="hljs pgsql">model %&gt;% fit_generator( train_iterator, steps_per_epoch = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.integer(length(train_index) / batch_size), epochs = epochs, validation_data = val_iterator, validation_steps = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.integer(length(val_index) / batch_size), <span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, callbacks = callbacks_list )</code> </pre> <br><h4 id="section8">  8. Model Predictions </h4><br><p>    -      run-length encoding. </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">test_dir</span></span> &lt;- <span class="hljs-string"><span class="hljs-string">"input/test/"</span></span> test_samples &lt;- <span class="hljs-number"><span class="hljs-number">100064</span></span> test_index &lt;- sample(<span class="hljs-number"><span class="hljs-number">1</span></span>:test_samples, <span class="hljs-number"><span class="hljs-number">1000</span></span>) load_model_weights_hdf5(model, <span class="hljs-string"><span class="hljs-string">"weights_r/unet128_08.h5"</span></span>) # best model imageRead &lt;- function(image_file, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { img &lt;- image_read(image_file) img &lt;- image_scale(img, paste0(target_width, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) } img2arr &lt;- function(image, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { result &lt;- aperm(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.numeric(image[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>], c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) # transpose dim(result) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">3</span></span>) return(result) } arr2img &lt;- function(arr, target_width = <span class="hljs-number"><span class="hljs-number">1918</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">1280</span></span>) { img &lt;- image_read(arr) img &lt;- image_scale(img, paste0(target_width, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) } qrle &lt;- function(mask) { img &lt;- t(mask) dim(img) &lt;- c(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) img &lt;- arr2img(img) arr &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.numeric(img[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">2</span></span>] vect &lt;- ifelse(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.vector(arr) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) turnpoints &lt;- c(vect, <span class="hljs-number"><span class="hljs-number">0</span></span>) - c(<span class="hljs-number"><span class="hljs-number">0</span></span>, vect) starts &lt;- which(turnpoints == <span class="hljs-number"><span class="hljs-number">1</span></span>) ends &lt;- which(turnpoints == <span class="hljs-number"><span class="hljs-number">-1</span></span>) paste(c(rbind(starts, ends - starts)), collapse = <span class="hljs-string"><span class="hljs-string">" "</span></span>) } cl &lt;- makePSOCKcluster(<span class="hljs-number"><span class="hljs-number">4</span></span>) clusterEvalQ(cl, { library(magick) library(abind) library(reticulate) imageRead &lt;- function(image_file, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { img &lt;- image_read(image_file) img &lt;- image_scale(img, paste0(target_width, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, target_height, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)) } img2arr &lt;- function(image, target_width = <span class="hljs-number"><span class="hljs-number">128</span></span>, target_height = <span class="hljs-number"><span class="hljs-number">128</span></span>) { result &lt;- aperm(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.numeric(image[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>], c(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) # transpose dim(result) &lt;- c(<span class="hljs-number"><span class="hljs-number">1</span></span>, target_width, target_height, <span class="hljs-number"><span class="hljs-number">3</span></span>) return(result) } qrle &lt;- function(mask) { img &lt;- t(mask) dim(img) &lt;- c(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) img &lt;- arr2img(img) arr &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.numeric(img[[<span class="hljs-number"><span class="hljs-number">1</span></span>]])[, , <span class="hljs-number"><span class="hljs-number">2</span></span>] vect &lt;- ifelse(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.vector(arr) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) turnpoints &lt;- c(vect, <span class="hljs-number"><span class="hljs-number">0</span></span>) - c(<span class="hljs-number"><span class="hljs-number">0</span></span>, vect) starts &lt;- which(turnpoints == <span class="hljs-number"><span class="hljs-number">1</span></span>) ends &lt;- which(turnpoints == <span class="hljs-number"><span class="hljs-number">-1</span></span>) paste(c(rbind(starts, ends - starts)), collapse = <span class="hljs-string"><span class="hljs-string">" "</span></span>) } }) registerDoParallel(cl) test_generator &lt;- function(images_dir, samples_index, batch_size) { images_iter &lt;- list.files(images_dir, pattern = <span class="hljs-string"><span class="hljs-string">".jpg"</span></span>, full.names = <span class="hljs-type"><span class="hljs-type">TRUE</span></span>)[samples_index] function() { batch_ind &lt;- sample(<span class="hljs-number"><span class="hljs-number">1</span></span>:length(images_iter), batch_size) batch_images_list &lt;- images_iter[batch_ind] images_iter &lt;&lt;- images_iter[-batch_ind] x_batch &lt;- foreach(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:batch_size) %dopar% { img &lt;- imageRead(image_file = batch_images_list[i]) # return <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> array arr &lt;- img2arr(img) } x_batch &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.call(abind, c(x_batch, list(along = <span class="hljs-number"><span class="hljs-number">1</span></span>))) result &lt;- list(keras_array(x_batch)) } } test_iterator &lt;- py_iterator(test_generator(images_dir = test_dir, samples_index = test_index, batch_size = batch_size)) preds &lt;- predict_generator(model, test_iterator, steps = <span class="hljs-number"><span class="hljs-number">10</span></span>) preds &lt;- foreach(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">160</span></span>) %dopar% { result &lt;- qrle(preds[i, , , ]) } preds &lt;- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.call(rbind, preds)</code> </pre> </div></div><br><p>      ,   <code>qrle</code> ,         (   <strong>skoffer</strong> -): </p><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/k5/z4/b5/k5z4b5opp3rgk7lrljfohvhgq4y.jpeg"></div></div><br><p>       : </p><br><img src="https://habrastorage.org/webt/lo/8s/tw/lo8stwyxn3efstsgimw-sybaiky.gif"><br><p><br>         ‚Äî  128128.        , , . </p><br><p>           ,       . </p><br><p>  <strong>Total</strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this message, it was shown that, while sitting on R, one can keep up with fashion trends and successfully train deep neural networks. </font><font style="vertical-align: inherit;">And even the Windows OS is not able to prevent this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation, as usual, follows.</font></font></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340212/">https://habr.com/ru/post/340212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340200/index.html">Steve Wozniak opened an online university Woz U</a></li>
<li><a href="../340202/index.html">Love static code analysis</a></li>
<li><a href="../340204/index.html">Cj - new programming language</a></li>
<li><a href="../340206/index.html">BaumankaCoin - a bike in 3000 lines or a blockchain on the fingers</a></li>
<li><a href="../340210/index.html">New Yandex.Cashi API: payment lego for e-commerce of all stripes</a></li>
<li><a href="../340214/index.html">Preview RamblerFront & # 3</a></li>
<li><a href="../340216/index.html">SQL Server: Performance when inserting data into a table with a clustered index and without</a></li>
<li><a href="../340218/index.html">MBLTdev 2017 is near: program on hardcore</a></li>
<li><a href="../340220/index.html">3CX PBX Express: 1 year free PBX in the Google Cloud</a></li>
<li><a href="../340222/index.html">Stone in the designer's garden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>