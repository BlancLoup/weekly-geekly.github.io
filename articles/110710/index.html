<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Grammar arithmetic or write a calculator on ANTLR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When the question arises of how to compute an arithmetic expression, then, probably, many people think from the reverse Polish notation. Therefore, in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Grammar arithmetic or write a calculator on ANTLR</h1><div class="post__text post__text-html js-mediator-article">  When the question arises of how to compute an arithmetic expression, then, probably, many people think from the reverse Polish notation.  Therefore, in this topic, I would like to talk about how you can compile a grammar of an arithmetic expression and build on it a lexical and syntactical analyzer using ANTLR. <br><a name="habracut"></a><br>  To begin, consider the necessary tools.  We will need: <br><ol><li>  ANTLRWorks - an environment for developing and debugging grammars </li><li>  ANTLR v3 - ANTLR itself (as of this writing, the latest version is 3.2) </li><li>  C # runtime distribution (Antlr3.Runtime.dll) - .NET library for working with generated analyzers </li><li>  Visual Studio - any other tool for compiling and debugging C # code </li><li>  Java runtime - since ANTLR and ANTLRWorks are written in Java </li></ol><br>  Anything that relates to ANTLR, that is, the first three points, can be downloaded from the official site <a href="http://www.antlr.org/download.html">http://www.antlr.org/download.html for</a> free, that is, for nothing. <br><br>  Now a few words, in fact, about ANTLR (turn to Wikipedia).  <a href="http://ru.wikipedia.org/wiki/ANTLR"><b>ANTLR</b></a> (Another Tool For Language Recognition - ‚ÄúAnother Language Recognition Tool‚Äù) is a parser generator that allows you to automatically create a parser program (like a lexical analyzer) in one of the target programming languages ‚Äã‚Äã(C ++, Java, C #, Python, Ruby) according to the description of LL (*) - grammar in a language close to the RBNF.  The author of this project is Professor Terence Parr (Terence Parr) from the University of San Francisco.  I must say that the project is open source and distributed under the BSD license. <br><br><h2>  1. Statement of the problem </h2><br>  As part of this topic, we will write a program in C #, which will read arithmetic expressions separated by a line break from the console, and then return the result of the calculations.  As arithmetic operations will be supported: addition, subtraction, multiplication, division.  For simplicity, all operations will be performed on integers.  As a bonus, our calculator (let's call it a project) will support the work with variables and, accordingly, the assignment operation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  2. Grammar Development </h2><br>  It's time to start ANTLRWorks and create a project with our grammar.  When running, ANTLRWorks will ask what type of document we want to create.  Select "ANTLR 3 Grammar (* .g)".  In the window that appears, enter the name of the grammar (let's call it ‚ÄúCalc‚Äù), leave the type as default (‚ÄúCombined Grammar‚Äù).  This means that in one file we will have both the rules of the grammar of the lexical and the parser.  To avoid further disagreement, let's call the lexical analyzer a lexer (Lexer), and a syntax parser - a parser (Parser).  If in the drop-down list you look at other options, you will understand the entered notation.  Let me remind you that the lexer from the stream of characters selects tokens (tokens): integers, identifiers, strings, etc., and the parser checks whether the lexemes are in the correct order in the stream of tokens.  I also recommend checking the Identifier and Integer checkboxes so that our grammar already contains rules for identifiers and integers.  The result should be the following: <br><img src="https://habrastorage.org/storage/habraeffect/78/f9/78f9d42ef410f2a11e97919bec41f007.jpg"><br>  Click the ‚ÄúOk‚Äù button and get a grammar with two automatically added lexer rules.  Let's analyze how the rules for the lexer are written using the example of the ‚ÄúINT‚Äù rule.  The rule starts with a name (in this case, INT).  Names for lexer rules must begin with a capital letter.  After the name is the symbol ":", followed by the so-called <b>alternatives</b> .  Alternatives are separated by the symbol "|"  and must end with a ";". <br><br>  We now look at the only alternative to the INT rule.  Writing '0' .. '9' + in ANTLR means that INT is a sequence of digits with at least one digit in it.  If instead of the character '+' stood, for example, the symbol of '*', then this would mean that the sequence of numbers may be empty.  The ID rule is somewhat more complicated and means that the ID is a sequence of characters consisting of lowercase and uppercase Latin letters, numbers, underscores, and starting with a letter or underscore. <br><br>  Well, now we will write independently the first rule for the parser or in a scientific <b>axiom</b> , that is, the rule with which the parser will start to check the flow of tokens.  So: <br><pre> calc	
	 : statement +
	 ;
</pre><br>  As you can see, the rules for the parser do not differ in structure from the rules for the lexer, except that the name must begin with a lowercase letter.  In this case, we tell the parser that the input stream of tokens is a non-empty sequence of statements.  Since the parser is not clairvoyant, it needs to know what statement is.  Tell him: <br><pre> statement
	 : expr NEWLINE
	 |  Id '=' expr NEWLINE
	 |  NEWLINE
	 ;
</pre><br>  Those who have forgotten what alternatives are on this rule can <strike>learn</strike> to remember what kind of beast it is.  The alternative is simply one of the possible variants of the order of the tokens.  That is, statement is either an expression (expr) ending in a newline (NEWLINE), or an assignment operation ending in a newline, or simply a newline.  Yes, by the way, do not forget to add the NEWLINE rule to the lexer rules, which I recommend to place at the end of the grammar file: <br><pre> NEWLINE: '\ r'?  '\ n'
	 ;
</pre><br>  Sign "?"  means that the character '\ r' must be present in the sentence either once or not at all. <br><br>  Now consider the rule in which two alternatives are combined into one: <br><pre> expr
	 : multExpression ('+' multExpression | '-' multExpression) *
	 ;
</pre><br>  In ANTLR, this means that expr is an arbitrary sequence of addends with arbitrary signs.  For example, multExpression-multExpression + multExpression-multExpression-multExpression + multExpression. <br><br>  I will not consider the remaining rules (besides, there are only two of them left), but simply bring them as they are: <br><pre> multExpression
	 : a1 = atom ('*' a2 = atom | '/' a2 = atom) *
	 ;
	
 atom
	 : ID
	 |  Int
	 |  '(' expr ')'
	 ;
</pre><br>  If you write the rules to a grammar file as you read, you probably already noticed that for each rule ANTLRWorks draws a graph.  Did you notice?  Fine!  Now I do not need to comment on every rule: <br><img src="https://habrastorage.org/storage/habraeffect/3c/f0/3cf003d0115fc094a65cef1cb2533e31.jpg"><br>  At this grammar can be finished.  Is it really that simple? <br><br><h2>  3. Generation and launch of parser and lexer </h2><br>  Well, we have developed a grammar.  It's time to generate the parser and lexer in C #.  Since ANTLRWorks is more Java-oriented, it will be easier to generate code manually (personally for me) than with the help of a visual environment.  But more on that later.  First, let's add a couple of lines to the grammar file.  Immediately after the first line of grammar names, you need to add the following: <br><pre> options
 {
	 language = CSharp2;
 }
 @parser :: namespace {Generated}
 @lexer :: namespace {Generated}
</pre><br>  These lines tell ANTLR that we want to get C # code, and also want the parser and lexer classes to be in the generated namespace.  Everything, it is possible to generate the code.  To do this, create a .bat file, in which we add the following contents: <br><pre> java -jar antlr-3.2.jar -o Generated Calc.g
 pause
</pre><br>  <b>Please note</b> that in my case the .bat file is in the same directory as the antlr-3.2.jar and Calc.g files. <br>  The "-o" key sets the path to the folder in which the generated files will be located.  The pause is made solely for convenience - so that in case of errors, we can find out about it. <br>  Run the .bat file and rather look into the Generated folder.  There we see three files: <br><ul><li>  CalcLexer.cs - lexer code </li><li>  CalcParser.cs - parser code </li><li>  Calc.tokens - token list service file </li></ul><br>  To start the parser, I created a console application in Visual Studio and added two received .cs files to it.  For convenience, the namespace is called Generated, so as not to write any usings.  <b>It is important</b> not to forget to add to the reference project on C # runtime distribution (Antlr3.Runtime.dll file in the DOT-NET-runtime-3-3.1.1.zip archive, downloaded from the ANTLR project site).  Add the following code to the Main () function: <br><pre> try
 {
	 // As an input stream of characters set the console input
	 ANTLRReaderStream input = new ANTLRReaderStream (Console.In);
	 // Set lexer to this stream
	 CalcLexer lexer = new CalcLexer (input);
	 // Create a stream of tokens based on a lexer
	 CommonTokenStream tokens = new CommonTokenStream (lexer);
	 // Create a parser
	 CalcParser parser = new CalcParser (tokens);
	 // And run the first grammar rule !!!
	 parser.calc ();
 }
 catch (Exception e)
 {
	 Console.WriteLine (e.Message);
 }
 Console.ReadKey ();
</pre><br>  Done !!!  Compile and run. <br><img src="https://habrastorage.org/storage/habraeffect/4a/e0/4ae0532d23922d91f37cfb0fe1b2573a.jpg"><br>  <b>Note</b> that the input ends when the end-of-file (EOF) character is encountered.  To put this symbol in Windows, you must press CTRL + Z. <br>  Everything is almost great.  You probably noticed that no result is displayed on the screen.  Disorder!  To correct the annoying subtle work, we must again conjure up with grammar.  Not closed ANTLRWorks yet? <br><br><h2>  4. Adding Calculator Functionality to Grammar </h2><br>  The time has come for the most interesting.  First, we will configure ANTLR a little more by adding the following fragment to the beginning of the file with <br>  grammar: <br><pre> @header {
	 using System;
	 using System.Collections;
 }

 @members {
	 Hashtable memory = new Hashtable ();
 }
</pre><br>  I will explain.  @members tells ANTLR that it is necessary to add a private member to the parser class (to store the values ‚Äã‚Äãof variables) and, accordingly, the <a href="http://habrahabr.ru/users/header/" class="user_link">header</a> says what namespaces need to be connected in order to use the Hashtable.  Now you can add C # code to our grammar.  Let's start with the statement statement: <br><pre> statement
	 : expr NEWLINE {Console.WriteLine ($ expr.value);  }
	 |  Id '=' expr NEWLINE {memory.Add ($ id.text, $ expr.value);  }
	 |  NEWLINE
	 ;
</pre><br>  The code is written in curly brackets {}.  If the statement is the first alternative, then we print the value of the arithmetic expression on the screen, if the second one, we save the variable name and its value in the memory so that it can be obtained later.  Everything is very simple here, but the question arises, where does the value of the expression $ expr.value come from?  And it is taken from here: <br><pre> expr returns [int value]	
	 : me1 = multExpression {$ value = me1;}
	 ('+' me2 = multExpression {$ value + = $ me2.value;}
	 | '-' me2 = multExpression {$ value - = $ me2.value;}) *
	 ;
</pre><br>  Here, too, nothing complicated.  We say ANTLR that the rule expr returns a value with the name value of type int.  <b>Note</b> that in both the "$ expr.value" and "returns [int value]" entries, the value is not accidental.  If we write: <br><pre> expr returns [int tratata]
 ...
	 ;
</pre><br>  and then we turn to $ expr.value, then ANTLR will generate an error. <br>  I made some kind of free speech, saying that ‚Äúthe rule returns value‚Äù, but to say it briefly in a different way, without losing meaning, it is rather difficult in my opinion. <br>  <b>Another subtlety.</b>  Consider the statement rule, for example, the first alternative.  In the code corresponding to this alternative, we address the expr rule directly ($ expr.value).  But in the statement rule, this will not work, because there are two multExpression rules in it at once, that is, in order to distinguish them, you must give them names.  In this case, it is me1 and me2.  It seems to be all the details <br>  discussed, now closer to the point. <br>  In the expr rule, two alternatives are written into one through the '|' character.  This is clearly seen in part 2 of this topic.  Recall that expr is a clause of the type multExpression-multExpression + multExpression-multExpression-multExpression + multExpression.  Now we will look at the code in curly brackets and see that the value of the first term is assigned to the returned value first, and then the values ‚Äã‚Äãof the subsequent terms are added or subtracted depending on the operation.  Similarly, the rule looks like <br>  multExpression: <br><pre> multExpression returns [int value]
	 : a1 = atom {$ value = $ a1.value;}
	 ('*' a2 = atom {$ value * = $ a2.value;}
	 | '/' a2 = atom {$ value / = $ a2.value;}) *
	 ;
</pre><br>  The last rule of the atom parser is left.  There should be no problems with it: <br><pre> atom returns [int value]
	 : ID {$ value = (int) memory [$ ID.text];}
	 |  Int {$ value = int.Parse ($ int.text);}
	 |  '(' expr ')' {$ value = $ expr.value;}
	 ;
</pre><br>  If atom is an identifier (ID), then we return its value taken from memory.  If atom is an integer, then simply return the number obtained from its string representation.  Finally, if atom is an expression in brackets, then we simply return the value of the expression. <br>  It remains to generate the parser and lexer using a .bat file.  Even the function code Main () does not have to be changed.  We run our calculator and play. <br><img src="https://habrastorage.org/storage/habraeffect/dc/b1/dcb1e0e2b95682d83cf61902b5fc8dbd.jpg"><br><br>  Interestingly, the generated parser can report syntax errors and moreover recover from them.  To see this, try typing some expression, for example, with spaces (we didn‚Äôt do the processing of spaces, tabs and other things): <br><img src="https://habrastorage.org/storage/habraeffect/7c/06/7c0647374eb5529fb0e5db8721749241.jpg"><br><br>  Parser, found errors, but nevertheless correctly calculated the result.  You can even write something like ‚Äú2 ++ 3‚Äù and get 5. <br><br><h2>  5. Conclusion </h2><br>  It's time to make a small summary.  The solution that we got, it seems to me, is fully consistent with the task.  The expression program reads?  Yes.  The result calculates?  Yes.  On this, perhaps, you can finish.  I really hope, dear Habrelovelek, that you like this topic and you want to learn how to build parse trees with the help of ANTLR on grammar and use the same ANTLR to bypass them.  If you have a dream to write your own programming language, then with ANTLR it has become much closer to implementation! <br><br><h2>  6. Recommended reading </h2><ol><li>  Definite ANTLR Reference, Terence Parr, 2007. <br>  ISBN-10: 0-9787392-5-6, ISBN-13: 978-09787392-4-9 </li><li>  Language Implementation Patterns, Terence Parr, 2010. <br>  ISBN-10: 1-934356-45-X, ISBN-13: 978-1-934356-45-6 </li></ol></div><p>Source: <a href="https://habr.com/ru/post/110710/">https://habr.com/ru/post/110710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../110703/index.html">Short manual on participation in the program "Start" (1 mln. RUR for your project)</a></li>
<li><a href="../110704/index.html">Moscow igrodelov offices</a></li>
<li><a href="../110705/index.html">Christmas trouble, md5, books, gadgets, software</a></li>
<li><a href="../110709/index.html">In the near future, 3D food printers can cook festive dishes.</a></li>
<li><a href="../11071/index.html">AT & T offers live video transmission service.</a></li>
<li><a href="../110711/index.html">A couple of plugins for jQuery Mobile</a></li>
<li><a href="../110712/index.html">WXHR: Good old XHR with Web Workers</a></li>
<li><a href="../110716/index.html">Ease of Being: Antiword, reST</a></li>
<li><a href="../110718/index.html">Another prototype of a solar reactor</a></li>
<li><a href="../110719/index.html">Author of the Facebook Disconnect extension resigned from Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>