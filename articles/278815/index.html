<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android application architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our journey from standard Activity and AsyncTasks to modern MVP architecture using RxJava. 

 The project code should be divided into independent modu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android application architecture</h1><div class="post__text post__text-html js-mediator-article"><h2>  <font color="#999">Our journey from standard Activity and AsyncTasks to modern MVP architecture using RxJava.</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/406/847/d4f/406847d4f66d455191e57d42b733e162.jpeg"></div><br>  <font color="999999"><i>The project code should be divided into independent modules that work with each other as a well-oiled mechanism - a photo of <a href="https://unsplash.com/chesteralvarez">Chester Alvarez</a> .</i></font> <br><br>  The ecosystem of development tools for Android is developing very quickly.  Every week someone creates new tools, updates existing libraries, writes new articles, or makes reports.  If you go on vacation for a month, then by the time you return, the latest version of the Support Library and / or Google Play Services will already be published. <br><br>  I have been developing Android applications at <a href="http://ribot.co.uk/us/">ribot</a> for the past three years, and all this time, the architecture of our applications, and the technologies we use, have been constantly evolving and improving.  This article will take you through the way we have walked, showing the lessons we have learned, the mistakes we have made, and the reasoning that led to all these architectural changes. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Good old times </h3><br>  Back in 2012, the structure of our projects looked very simple.  We did not have any libraries to work with the network, and <code>AsyncTask</code> was still our friend.  The diagram below shows the approximate architecture of those solutions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/07b/392/49d/07b39249d1cc46238784b89c752ed05d.png"></div><br>  The code was divided into two levels: the data layer (data layer), which was responsible for receiving / storing data received through both the REST API and various local storages, and the view layer (responsible for processing and displaying data). <br><br>  <code>APIProvider</code> provides methods that allow activations and fragments to interact with the REST API.  These methods use <code>URLConnection</code> and <code>AsyncTask</code> to execute the request in the background thread, and then deliver the results to the activation via callback functions.  <code>CacheProvider</code> works the same <code>CacheProvider</code> : there are methods that retrieve data from <code>SharedPreferences</code> or SQLite, and there are callback functions that return results. <br><br><h4>  Problems </h4><br>  The main problem with this approach is that the level of representation has too much responsibility.  Let's imagine a simple script in which an application should load a list of posts from a blog, cache them into SQLite, and then display them in a <code>ListView</code> .  <code>Activity</code> should do the following: <br><br><ol><li>  Call the <code>APIProvider#loadPosts(Callback)</code> method. </li><li>  Wait for the <code>onSuccess()</code> method call in the transferred <code>Callback</code> , and then call <code>CacheProvider#savePosts(Callback)</code> . </li><li>  Wait for the <code>onSuccess()</code> method call in the transferred <code>Callback</code> , and then display the data in the <code>ListView</code> . </li><li>  Separately handle two possible errors that may occur in both the <code>APIProvider</code> and the <code>CacheProvider</code> . </li></ol><br>  And this is another simple example.  In real life, it may happen that the API returns the data not in the form in which our view level expects it, which means the <code>Activity</code> will have to somehow transform and / or filter the data before it can work with it.  Or, for example, <code>loadPosts()</code> will take an argument that you need to get from somewhere (for example, an email address that we will request through the Play Services SDK).  Surely the SDK will return the address asynchronously, via a callback function, which means we now have three levels of nesting callback functions.  If we continue to wind down more and more complexity, we end up with what is called a callback hell. <br><br>  Sum up: <br><br><ul><li>  Activations and fragments become too hefty and difficult to maintain. </li><li>  Too many levels of nesting lead to the fact that the code becomes ugly and inaccessible to understand, which leads to the complication of adding new functionality or making changes. </li><li>  Unit testing is difficult (if it doesn‚Äôt become impossible at all), since a lot of logic is in activites or fragments that are not very useful for unit testing. </li></ul><br><h3>  New architecture with RxJava </h3><br>  We have used the above approach for two years.  During this time, we made several changes that lessened the pain and suffering from the problems described.  For example, we added several auxiliary classes, and carried some logic into them to offload activations and fragments, and also we started using <a href="http://developer.android.com/training/volley/index.html">Volley</a> in the <code>APIProvider</code> .  Despite these changes, the code was still difficult to test, and the callback-hell periodically broke through here and there. <br><br>  The situation began to change in 2014, when we read several articles on <a href="http://reactivex.io/">RxJava</a> .  We tried it on several pilot projects, and realized that a solution to the problem of nested callback functions was found.  If you are not familiar with reactive programming, then we recommend reading <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this</a> introduction here.  In short, RxJava allows you to manage your data through asynchronous streams (for example, a translator: in this case, streams are streams, not to be confused with threads - streams of execution), and provides many <a href="http://reactivex.io/documentation/operators.html">operators</a> that can be applied to streams to transform, filter, or combine data as you need. <br><br>  Taking into account all the bumps that we have filled over the past two years, we began to think over the architecture of the new application, and came to the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/293/6ad/c33/2936adc3328a41d7865eaa49832199b6.png"></div><br>  The code is still divided into two levels: the data layer contains the <code>DataManager</code> and a set of helper classes, the presentation layer consists of Android SDK classes, such as <code>Activity</code> , <code>Fragment</code> , <code>ViewGroup</code> , and so on. <br><br>  The helper classes (the third column in the diagram) have very limited areas of responsibility, and implement them in a consistent manner.  For example, most projects have classes for accessing the REST API, reading data from the database, or interacting with third-party SDKs.  Different applications will have a different set of helper classes, but the following will be the most commonly used: <br><br><ul><li>  <code>PreferencesHelper</code> : works with data in <code>SharedPreferences</code> . </li><li>  <code>DatabaseHelper</code> : works with SQLite. </li><li>  <a href="https://github.com/square/retrofit">Retrofit</a> services that make calls to the REST API.  We started using Retrofit instead of Volley, because it supports RxJava.  And the API is more pleasant. </li></ul><br>  Many public methods of helper classes return RxJava <code>Observables</code> . <br><br>  <code>DataManager</code> is a central part of the new architecture.  It makes extensive use of RxJava operators in order to combine, filter, and transform data received from helpers.  The task of the <code>DataManager</code> is to release activations and fragments from the work of ‚Äúcombing‚Äù the data - it will perform all the necessary transformations within itself and give out the data ready for display. <br><br>  The code below shows what a method from the <code>DataManager</code> might look like.  It works as follows: <br><br><ol><li>  Uploads a list of posts via Retrofit. </li><li>  Caches data in a local database through <code>DatabaseHelper</code> . </li><li>  Filters posts, selecting those that were published today, as the presentation level should only display them. </li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;Post&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTodayPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mRetrofitService.loadPosts() .concatMap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;List&lt;Post&gt;, Observable&lt;Post&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;Post&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Post&gt; apiPosts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mDatabaseHelper.savePosts(apiPosts); } }) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;Post, Boolean&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isToday(post.date); } }); }</code> </pre><br>  View-level components will simply call this method and subscribe to the <code>Observable</code> returned to them.  Once the subscription is completed, posts returned by the received <code>Observable</code> can be added to the <code>Adapter</code> to display them in a <code>RecyclerView</code> or something similar. <br><br>  The last element of this architecture is the <b>event bus</b> .  Event bus allows us to run messages about certain events occurring at the data level, and components that are at the presentation level can subscribe to these messages.  For example, the <code>signOut()</code> method in <code>DataManager</code> can trigger a message indicating that the corresponding <code>Observable</code> completed its work, and then the activators subscribed to this event can redraw their interface to show that the user has logged out. <br><br><h4>  How is this approach better? </h4><br><ul><li>  <code>Observables</code> and operators from RxJava save us from nested callback functions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b18/685/4b5/b186854b50c04eb78e8460d43cf2249a.jpeg"></div><br></li><li>  <code>DataManager</code> takes over the work that was previously performed at the presentation level, thus unloading activations and fragments. </li><li>  Moving part of the code to the <code>DataManager</code> and the helpers makes unit testing of activations and fragments easier. </li><li>  A clear division of responsibility and the allocation of <code>DataManager</code> as the only point of interaction with the level of data makes the entire architecture more test-friendly.  Helper Classes, or <code>DataManager</code> , can be easily replaced with special stubs. </li></ul><br><h4>  And what problems remain? </h4><br><ul><li>  In large and complex projects, <code>DataManager</code> may become too bloated, and its support will be significantly more difficult. </li><li>  Although we have made presentation-level components (such as activations and fragments) more lightweight, they still contain a noticeable amount of logic that spins around managing RxJava subscriptions, analyzing errors, and so on. </li></ul><br><br><h3>  We try Model View Presenter </h3><br>  Over the past year, separate architectural patterns have begun to gain popularity in the Android community, as <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">MVP</a> , or <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593viewmodel">MVVM</a> .  After researching these patterns in a <a href="https://github.com/ivacf/archi">test project</a> , as well as a <a href="https://medium.com/ribot-labs/approaching-android-with-mvvm-8ceec02d5442">separate article</a> , we found that MVP can bring significant changes to the architecture of our projects.  Since we have already divided the code into two levels (data and presentation), the introduction of MVP looked natural.  We just needed to add a new level of presenters, and transfer part of the code from the views to it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/62e/4bb/8a3/62e4bb8a30134b178afffe7053b4f64d.png"></div><br>  The data level remains unchanged, but now it is called a <b>model</b> to match the name of the corresponding level from the MVP. <br><br>  <b>Presenters</b> are responsible for loading data from the model and calling the appropriate methods at the presentation level when the data is loaded.  Presenters subscribe to the <code>Observables</code> returned by the <code>DataManager</code> .  Therefore, they should work with such entities as <a href="http://reactivex.io/RxJava/javadoc/rx/Subscription.html">subscriptions</a> and <a href="http://reactivex.io/documentation/scheduler.html">schedulers</a> .  Moreover, they can analyze errors that occur, or apply additional operators to data streams, if necessary.  For example, if we need to filter some data, and this filter most likely will not be used anywhere else, it makes sense to bring this filter to the presenter level, and not to the <code>DataManager</code> . <br><br>  Below is one of the methods that can be at the presenter level.  Here comes the subscription to <code>Observable</code> , returned by the <code>dataManager.loadTodayPosts()</code> method, which we defined in the previous section. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTodayPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mMvpView.showProgressIndicator(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); mSubscription = mDataManager.loadTodayPosts().toList() .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscriber&lt;List&lt;Post&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mMvpView.showProgressIndicator(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ mMvpView.showProgressIndicator(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); mMvpView.showError(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Post&gt; postsList)</span></span></span><span class="hljs-function"> </span></span>{ mMvpView.showPosts(postsList); } }); }</code> </pre><br>  <code>mMvpView</code> is the <code>mMvpView</code> -level component that the presenter works with.  Usually it will be <code>Activity</code> , <code>Fragment</code> or <code>ViewGroup</code> . <br><br>  As in the previous architecture, the presentation layer contains standard components from the Android SDK.  The difference is that now these components do not subscribe directly to <code>Observables</code> .  Instead, they implement the <code>MvpView</code> interface, and provide a list of clear and understandable methods, such as <code>showError()</code> or <code>showProgressIndicator()</code> .  Presentation-level components are also responsible for handling user interaction (for example, push events), and calling the appropriate methods in a presenter.  For example, if we have a button that loads a list of posts, our <code>Activity</code> will have to <code>OnClickListener</code> the <code>presenter.loadTodayPosts()</code> method in <code>OnClickListener</code> . <br><br><blockquote>  If you want to take a look at a working example, you can take a look at <a href="https://github.com/ribot/android-boilerplate">our repository on Github</a> .  Well, if you wanted more, you can see our <a href="">recommendations for building architecture</a> . </blockquote><br><h4>  How is this approach better? </h4><br><ul><li>  Activations and fragments become even more lightweight, since their work is now reduced to drawing / updating the user interface and handling user interaction events.  This makes it even easier to maintain them. </li><li>  Writing unit tests for presenters is very simple - you just need to lock the presentation level.  Previously, this code was part of the presentation level, and unit testing was not possible.  The architecture becomes even more testable. </li><li>  If the <code>DataManager</code> becomes too bloated, we can always transfer part of the code to the presenters. </li></ul><br><h4>  And what problems remain? </h4><br><ul><li>  In the case of a large amount of code <code>DataManager</code> still may become too bloated.  So far this has not happened, but we do not blame for this development of events. </li></ul><br><hr><br>  It is important to mention that the approach I described is not ideal.  In general, it would be naive to believe that there is somewhere the very unique and unique architecture that will take and solve all your problems once and for all.  Android's ecosystem will continue to evolve at high speeds, and we will have to keep up to date, exploring, reading and experimenting.  What for?  To continue making great Android apps. <br><br>  I hope you enjoyed my article and found it useful.  If so, do not forget to click on the Recommend button (comment of the translator: go to the original article, and click on the heart button at the end of the article).  Also, I would like to hear your thoughts on our current approach. </div><p>Source: <a href="https://habr.com/ru/post/278815/">https://habr.com/ru/post/278815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278805/index.html">Charts and other usefulness for UWP applications</a></li>
<li><a href="../278807/index.html">Intel RealSense SDK Plug-in for Unreal Engine 4</a></li>
<li><a href="../278809/index.html">OSSIM - we use integrated open source security management system</a></li>
<li><a href="../278811/index.html">How to organize the transfer of financial data on the American stock exchange Nasdaq: ITCH and OUCH protocols</a></li>
<li><a href="../278813/index.html">Register for the webinar ‚ÄúUsing Panda SaaS Solutions to Protect and Manage Enterprise IT Assets‚Äù</a></li>
<li><a href="../278817/index.html">ReactiveCocoa. Concurrency. Multithreading</a></li>
<li><a href="../278819/index.html">Security in the hands of a smartphone: the first car without keys is on its way</a></li>
<li><a href="../278821/index.html">The book "Algorithms: development and application. Classic Computer Science ¬ª</a></li>
<li><a href="../278823/index.html">Capture and visualize! Or a histogram from a microphone using Web Audio API</a></li>
<li><a href="../278825/index.html">Spoiler: Insert SVG icons in one single way.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>