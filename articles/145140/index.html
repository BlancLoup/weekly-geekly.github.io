<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows Sockets, IOCP and Delphi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 
 Recently, I was faced with the need to effectively work with sockets in a Windows application. The task is typical for a loaded server. Aty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows Sockets, IOCP and Delphi</h1><div class="post__text post__text-html js-mediator-article"><h4>  Prologue </h4><br>  Recently, I was faced with the need to effectively work with sockets in a Windows application.  The task is typical for a loaded server.  Atypical here will only seem to the implementation language - Delphi. <br>  I want to describe the way mass asynchronous work with a large number of sockets using I / O Completion Ports. <a name="habracut"></a>  Microsoft recommends using this technology in its literature.  I think many are familiar with it, but just in case I will provide a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365198%2528v%3Dvs.85%2529.aspx">link</a> to MSDN.  The essence of the technology is that the system organizes a highly efficient event queue, and the program processes it from the thread pool, the size of which is selected by the number of cores.  This approach has advantages when there are a large number of simultaneous asynchronous I / O operations for different endpoints.  Ready source can (better) immediately look <a href="http://files.mail.ru/RXE98D">here</a> .  Not everything is perfect, but it will do for experimentation. <br><h4>  Roadmap </h4><br>  I, in a sense, will stick to the ideology of Node.Js in all that concerns the organization of objects and input-output operations. <br>  In the case of the server part, you need to implement the following: <br><ul><li>  Listening to the socket.  Acceptance or rejection of new connections. </li><li>  Tracking signal closure of client sockets. </li></ul><br>  For the client, the first item in this list is not relevant, but you need to implement an asynchronous connection to the server.  In both classes there will be the possibility of simultaneous reading and writing to one end point. <br>  All created instances of client and server sockets will use one common message queue and one thread pool.  It is necessary to be able to use both types of sockets in the same application in an optimal way. <br><br><h4>  Implementation </h4><br>  Let's get started  To begin with, I note that in connection with an absolutely asynchronous event-based construction model, I will implement not classes, but interfaces.  This is very convenient in this case, since responsibility for the allocated memory is removed from the final programmer.  And in general, to track its use here in another way is either very costly or completely impossible.  A lot of work should occur during module initialization. <br><ul><li>  Creating lists of sockets of different types. </li><li>  Initialization of the socket subsystem. </li><li>  Creating a message queue. </li><li>  Create a pool to handle the queue. </li><li>  Create events for sockets. </li><li>  Creating streams that monitor socket events (for example, connecting a new client). </li></ul><br>  And so, the initialization section contains the following procedure, which implements the list item by item. <br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> Init; var WSAData: TWsaData; i: <span class="hljs-type"><span class="hljs-type">Integer</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> gClients := TProtoStore.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>; gListeners := TProtoStore.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>; gServerClients := TProtoStore.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WSAStartup(MAKEWORD(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), WSAData) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(sErrorInit_WSAtartup); gIOCP := CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, CPUCount * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gIOCP = INVALID_HANDLE_VALUE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(sErrorInit_CreateIoCompletionPort); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> CPUCount * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(gWorkers, Length(gWorkers) + <span class="hljs-number"><span class="hljs-number">1</span></span>); gWorkers[Length(gWorkers) - <span class="hljs-number"><span class="hljs-number">1</span></span>] := TWorkerThread.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; gListenerAcceptEvent := WSACreateEvent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gListenerAcceptEvent = WSA_INVALID_EVENT <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(sErrorInit_WSACreateEvent); gServerClientsCloseEvent := WSACreateEvent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gServerClientsCloseEvent = WSA_INVALID_EVENT <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(sErrorInit_WSACreateEvent); gClisentsConnectAndCloseEvents := WSACreateEvent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gClisentsConnectAndCloseEvents = WSA_INVALID_EVENT <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(sErrorInit_WSACreateEvent); gClientSocketEventThread := TSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> (gClisentsConnectAndCloseEvents, gClients, ET_EVENT_SIGNALED); gClientSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>; gServerClientsSocketEventThread := TSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> (gServerClientsCloseEvent, gServerClients, ET_EVENT_SIGNALED); gServerClientsSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>; gServerSocketEventThread := TSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(gListenerAcceptEvent, gListeners, ET_EVENT_SIGNALED); gServerSocketEventThread.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The CreateIoCompletionPort function in this case creates a special message queue. <br>  You can see that the same thread class TSocketEventThread is used to track events on sockets with different purposes.  Threads of this class perform a procedure that waits for socket events, and immediately queue messages (for each socket of the type that serves this thread) that an event has occurred. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSocketEventThread</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForClientsEvents</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WaitResult: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TimeOut: DWORD = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> WaitResult := WSAWaitForMultipleEvents(<span class="hljs-number"><span class="hljs-number">1</span></span>, @fEvent, FALSE, TimeOut, FALSE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WaitResult = WSA_WAIT_FAILED <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create (sErrorWaitForClientsEvents_WSAWaitForMultipleEvents); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WaitResult = WSA_WAIT_EVENT_0 <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> WSAResetEvent(fEvent) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create (sErrorWaitForClientsEvents_WSAResetEvent); fStore.Post(fKey); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Here is the fStore.Post (fKey) method;  just sends messages to the queue. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProtoStore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletionKey: DWORD)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fLock.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(ProtoArray) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ProtoArray[i]._AddRef; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> PostQueuedCompletionStatus(gIOCP, <span class="hljs-number"><span class="hljs-number">0</span></span>, CompletionKey, POverlapped(ProtoArray[i])) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ProtoArray[i]._Release; <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorPost_PostQueuedCompletionStatus); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> fLock.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The use of objects with interfaces deserves special attention. <br>  The _AddRef method is used to denote the fact that an object is ‚Äúin the queue‚Äù and should not be destroyed.  (Later after processing _Release will be called).  The PostQueuedCompletionStatus procedure directly performs the queuing of the message. <br>  The pool will process each message asynchronously. <br>  To do this, he performs the following procedure. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWorkerThread</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessIOCP</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NumberOfBytes: DWORD; CompletionKey: NativeUInt; Overlapped: POverlapped; Proto: TIOCPSocketProto; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> GetQueuedCompletionStatus(gIOCP, NumberOfBytes, CompletionKey, Overlapped, INFINITE)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Overlapped = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CompletionKey = ET_EVENT_SIGNALED <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Proto := TIOCPSocketProto(Overlapped); <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Proto <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> IOCPProcessEventsProc(); _Release; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CompletionKey &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Proto := TIOCPSocketProto(CompletionKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Proto.IOCPProcessIOProc(NumberOfBytes, Overlapped) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Proto._Release; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The GetQueuedCompletionStatus procedure is used to retrieve a message from a queue.  Next, it is determined whether this message is a message about completed I / O or this message about an event that has occurred.  There are two ways to pass some information through a queue, in this case it is a link to a specific instance of the socket class. <br>  Processing is unified for all types of sockets, this is achieved by inheriting from a common ancestor that contains common handlers, they can be redefined. <br>  Consider the mechanism for handling socket events. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIOCPSocketProto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOCPProcessEventsProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WSAEvents: TWsaNetworkEvents; AcceptedSocket: TSocket; RemoteAddress: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fStateLock &lt;&gt; CLI_SOCKET_LOCK_CLOSED <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fClosingLock.BeginRead; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fStateLock &lt;&gt; CLI_SOCKET_LOCK_CLOSED) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WSAEnumNetworkEvents(fSocket, <span class="hljs-number"><span class="hljs-number">0</span></span>, WSAEvents) &lt;&gt; SOCKET_ERROR <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((WSAEvents.lNetworkEvents <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> FD_CONNECT) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> = WSAEvents.iErrorCode[FD_CONNECT_BIT] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> InterlockedExchange(fStateLock, CLI_SOCKET_LOCK_CONNECTED); CallOnConnect; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((WSAEvents.lNetworkEvents <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> FD_CLOSE) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> = WSAEvents.iErrorCode[FD_CLOSE_BIT]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallOnClose; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((WSAEvents.lNetworkEvents <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> FD_ACCEPT) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> = WSAEvents.iErrorCode[FD_ACCEPT_BIT]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AcceptedSocket := DoAccept(RemoteAddress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> AcceptedSocket &lt;&gt; INVALID_SOCKET <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fClientClass.Create(AcceptedSocket, fOnConnect, fOnClose, RemoteAddress).Prepare; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> fClosingLock.EndRead; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The TMultiReadExclusiveWriteSynchronizer class is interestingly applied here.  It is used to prevent an attempt to close a socket and destroy an object from another thread in the pool (fClosingLock.BeginRead).  All operations with a socket are performed as read operations for this synchronization object, except for the create operation and close operation of the socket ‚Äî they are write operations and therefore can only be performed with exclusive ownership of the resource. <br>  In all other respects, the work with sockets in this procedure is completely ordinary. <br>  The only thing worth considering in this procedure is the additional connection of the new client to the server, the DoAccept method. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIOCPSocketProto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAccept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RemoteAddress: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> TSocket; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addr: TSockAddr; addrlen: Integer; dwCallbackData: NativeUInt; RemoteAddrLen: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dwCallbackData := NativeUInt(self); addrlen := SizeOf(addr); Result := WSAAccept(fSocket, @addr, @addrlen, ServerAcceptCallBack, dwCallbackData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Result &lt;&gt; INVALID_SOCKET <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(RemoteAddress, <span class="hljs-number"><span class="hljs-number">255</span></span>); RemoteAddrLen := Length(RemoteAddress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WSAAddressToString(addr, addrlen, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, PChar(@RemoteAddress[<span class="hljs-number"><span class="hljs-number">1</span></span>]), RemoteAddrLen) = SOCKET_ERROR <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorAccept_WSAAddressToString); SetLength(RemoteAddress, RemoteAddrLen - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The key point here is to use WSAAccept.  This feature allows you to reject client connections in such a way that the client actually receives the FD_CONNECT event. <br>  This is the preferred way to organize the so-called black lists. <br>  We go further.  Consider the organization of input output.  Let's do this on the example of a read operation. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIOCPSocketProto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Length: DWORD; OnRead, OnReadProcess: TOnReadEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Bytes, Flags: DWORD; WsaBuf: TWsaBuf; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fClosingLock.BeginRead; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fStateLock = CLI_SOCKET_LOCK_CONNECTED <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> InterlockedCompareExchange(fReadLock, IO_PROCESS, IO_IDLE) = IO_IDLE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fOnRead := OnRead; fOnReadProcess := OnReadProcess; fReaded := <span class="hljs-number"><span class="hljs-number">0</span></span>; fReadBufLength := Length; fReadBuffer := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; GetMem(fReadBuffer, Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fReadBuffer &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Bytes := <span class="hljs-number"><span class="hljs-number">0</span></span>; FillChar(fOverlappedRead, SizeOf(fOverlappedRead), <span class="hljs-number"><span class="hljs-number">0</span></span>); WsaBuf.buf := fReadBuffer; WsaBuf.len := fReadBufLength; Flags := <span class="hljs-number"><span class="hljs-number">0</span></span>; Bytes := <span class="hljs-number"><span class="hljs-number">0</span></span>; _AddRef; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSARecv(fSocket, @WsaBuf, <span class="hljs-number"><span class="hljs-number">1</span></span>, Bytes, Flags, @fOverlappedRead, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) = SOCKET_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (WSAGetLastError &lt;&gt; WSA_IO_PENDING) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FreeMem(fReadBuffer, Length); InterlockedExchange(fReadLock, IO_IDLE); _Release; <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorRead_WSARecv); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorRead_GetMem); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorRead_InProcess); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorRead_NotConnected); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> fClosingLock.EndRead; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Here I had to use interlocked blocking, since  it is very fast and satisfies the need for clipping an attempt to recall an I / O option.  Memory is allocated to the buffer once in each operation.  Further reading from a socket in an asynchronous mode is caused.  The object is also "marked" with the help of AddRef, for the impossibility of its removal during the time in the queue.  Upon completion of the batch reading, the message is automatically queued. <br>  Consider what happens when retrieving a complete I / O message from a queue. <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TIOCPSocketProto.IOCPProcessIOProc(NumberOfBytes: DWORD; Overlapped: POverlapped): <span class="hljs-type"><span class="hljs-type">Boolean</span></span>; var Bytes, Flags: DWORD; WsaBuf: TWsaBuf; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; fClosingLock.BeginRead; try <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Overlapped = @fOverlappedRead <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NumberOfBytes &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fReadLock = IO_PROCESS <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> inc(fReaded, NumberOfBytes); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fReaded &lt; fReadBufLength <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnReadProcess; WsaBuf.buf := fReadBuffer; inc(WsaBuf.buf, fReaded); WsaBuf.len := fReadBufLength; <span class="hljs-type"><span class="hljs-type">dec</span></span>(WsaBuf.len, fReaded); Flags := <span class="hljs-number"><span class="hljs-number">0</span></span>; Bytes := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSARecv(fSocket, @WsaBuf, <span class="hljs-number"><span class="hljs-number">1</span></span>, Bytes, Flags, @fOverlappedRead, nil) = SOCKET_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (WSAGetLastError &lt;&gt; WSA_IO_PENDING) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnRead; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnReadProcess; CallOnRead; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnRead; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Overlapped = @fOverlappedWrite <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NumberOfBytes &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fWriteLock = IO_PROCESS <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> inc(fWrited, NumberOfBytes); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fWrited &lt; fWriteBufLength <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnWriteProcess; WsaBuf.buf := fWriteBuffer; inc(WsaBuf.buf, fWrited); WsaBuf.len := fWriteBufLength; <span class="hljs-type"><span class="hljs-type">dec</span></span>(WsaBuf.len, fWrited); Flags := <span class="hljs-number"><span class="hljs-number">0</span></span>; Bytes := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSASend(fSocket, @WsaBuf, <span class="hljs-number"><span class="hljs-number">1</span></span>, Bytes, Flags, @fOverlappedWrite, nil) = SOCKET_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (WSAGetLastError &lt;&gt; WSA_IO_PENDING) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnWrite; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnWriteProcess; CallOnWrite; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallOnWrite; Result := <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> finally fClosingLock.EndRead; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The essence of this procedure is that it causes reading or writing to the socket until the allocated buffer is full.  An interesting point in this case is the definition of the type of operation by reference to the overlaped structure.  This link provides a queue and you only need to compare it with the corresponding fields of the class in which the structures for reading and writing are stored. <br>  It is also noteworthy that if the read / write operation is performed instantly, then it still enters the queue, but this can be configured through api. <br>  It is also worth considering creating a socket class and injecting into a queue. <br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIOCPClientSocket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RemoteAddress: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; OnConnect, OnClose: TOnSimpleSocketEvenet)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lRemoteAddress: TSockAddr; lRemoteAddressLength: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create(); fStore := gClients; fOnConnect := OnConnect; fOnClose := OnClose; fStateLock := <span class="hljs-number"><span class="hljs-number">0</span></span>; fRemoteAddressStr := RemoteAddress; fSocket := WSASocket(AF_INET, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, WSA_FLAG_OVERLAPPED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fSocket = INVALID_SOCKET <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorTIOCPClientSocket_WSASocket); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSAEventSelect(fSocket, gClisentsConnectAndCloseEvents, FD_CONNECT <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> FD_CLOSE) = SOCKET_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorTIOCPClientSocket_WSAEventSelect); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CreateIoCompletionPort(fSocket, gIOCP, NativeUInt(self), <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create (sErrorTIOCPClientSocket_CreateIoCompletionPort); fStateLock := CLI_SOCKET_LOCK_CREATED; fStore.Add(self); lRemoteAddressLength := SizeOf(lRemoteAddress); lRemoteAddress.sa_family := AF_INET; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WSAStringToAddress(PChar(@fRemoteAddressStr[<span class="hljs-number"><span class="hljs-number">1</span></span>]), AF_INET, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, lRemoteAddress, lRemoteAddressLength) = SOCKET_ERROR <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create (sErrorTIOCPClientSocket_WSAStringToAddress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSAConnect(fSocket, lRemoteAddress, lRemoteAddressLength, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) = SOCKET_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (WSAGetLastError &lt;&gt; WSAEWOULDBLOCK) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> IOCPClientException.Create(sErrorTIOCPClientSocket_WSAConnect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In the client socket constructor, a socket is created directly (WSASocket), registered in the queue (CreateIoCompletionPort), associated with the event and calls the asynchronous connection function (WSAConnect).  The very fact of the connection is expected in the stream that was considered first (the thread waiting for events in the sockets).  That in turn will put this event in the queue. <br><h4>  Epilogue </h4><br>  This article briefly discusses, in my opinion, successful techniques for creating classes for event-based programming. <br>  It was possible to create a class for high-performance work with sockets for Delphi.  This topic is generally very weakly covered and I plan to continue this publication with another 2 - 3 posts on the topics of socket contexts when using interfaces and creating secure connections when using IOCP (crypto-providers and Winsock Secure Socket Extensions).  The full sample code is <a href="http://files.mail.ru/RXE98D">here</a> . </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/145140/">https://habr.com/ru/post/145140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145135/index.html">Recognizing the pulse of a person in a video</a></li>
<li><a href="../145136/index.html">Class for implementing UNIX daemons in PHP</a></li>
<li><a href="../145137/index.html">Overview of Runet DDoS Attacks: 9: 1 in favor of the primitive</a></li>
<li><a href="../145138/index.html">Groovy as a scripting language and DSL for Java</a></li>
<li><a href="../145139/index.html">3D printing: nylon, ice, chocolate and others</a></li>
<li><a href="../145141/index.html">Work with isometric matrices. Part 1</a></li>
<li><a href="../145142/index.html">Sergey Brin showed Google Glass in a TV interview</a></li>
<li><a href="../145143/index.html">Twitter Bootstrap 2.0.4 Release</a></li>
<li><a href="../145145/index.html">String collections are read-only: we save on matches</a></li>
<li><a href="../145147/index.html">3D printers: even cheaper, more original</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>