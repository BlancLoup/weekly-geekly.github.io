<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Object-Oriented Gin Installer Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 The cycle of articles offered to your attention has several main objectives: 


1. Create useful software - installer programs and upda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Object-Oriented Gin Installer Development</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  The cycle of articles offered to your attention has several main objectives: <br><ol><li>  Create useful software - installer programs and updates. </li><li>  Show the benefits of an object-oriented approach to software development and teach how to create easily extensible software architectures. </li></ol><br>  In this series of articles, I want to share the story of creating software that allows you to install and update company software using packages.  The need to create your own installer (with the rejection of the use of ready-made solutions) is caused by the specificity of the requirements for the installer.  I will not delve into the rationale for the development, since the topic of the article cycle is different. <br>  The main requirements for the architecture being developed will be: <br><ol><li>  The implementation of the transaction mechanism, and transactions can include not only SQL transactions, but also file transactions, as well as transactions related to changing any other OS resources, such as registry entries, changes to configuration files, etc. </li><li>  Extensibility of the operating base of the installer, that is, the addition of new types of commands (operations), both with and without transaction support. </li></ol><br><a name="habracut"></a><br>  So, each package as a first approximation should contain: <br><ol><li>  Description of the sequence of commands executed. </li><li>  An arbitrary set of data files. </li></ol><br>  I intend to save the description of the command sequence in the XML file for the reason that the .NET platform contains convenient and simple classes for serializing / deserializing objects into XML files, which will enable us to focus on the main logic of the application, without delving into the operation of in rows. <br>  The package itself will be in the format of a TAR archive, possibly even subjected to GZIP compression, however, I will try to design the software so that when making a decision to change the way the package is stored (its structure and compression method), we would need minimal interference with the existing code. <br>  Let us estimate the command set of the future software. <br><ol><li>  File operations </li><li>  SQL operations </li><li>  IIS server management </li><li>  Perhaps something else ... </li></ol><br>  As I mentioned, the set of commands can be expanded.  Moreover, we will make so that the main functionality - the core of the software - is stored in a separate assembly, and the possible executable commands are configured by separate assemblies connected to the main module using the concept of plug-ins. <br>  It already takes my breath away from how many interesting tasks will need to be solved in the software development process.  I‚Äôll make a reservation right away that at the moment when I am writing these lines there is already a working prototype of the application, which truth does not yet have all the declared functionality, and making changes to it is a bit more complicated than I would like.  So, I still will refactor it.  He already has the ability to create transactions for file operations, but does not know how to combine file and SQL operations within a single transaction.  It has not yet implemented plugin support.  Adding a new command to the command set makes it necessary to edit 4 files, and I want only a new class to be enough for this.  In general, the work - plowed field. <br>  As a first approximation, the class diagram of the system looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/fea/b3f/538/feab3f5389619c78e0aa8aba77d0a33a.jpg" alt="image"><br>  It has a parent class of all operations (commands) that an application can perform, and several commands inherited from it (CreateFileCommand and DeleteFolderCommand), which in the end will be very much.  There is also the PackageBuilder class, which contains a sequence of commands.  PackageBuilder can create packages and give them to the user.  Packages can save themselves and execute. <br>  As a result, pseudocode using these classes will look like this: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePackage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     PackageBuilder builder = new PackageBuilder(); builder.AddCommand(new CreateFolderCommand() { FolderPath = @"%APPROOT%\files" }); builder.AddCommand(new CreateFileCommand() { SourcePath = @"d:\package\config.xml", //      DestPath = @"%APPROOT%\files\config.xml" //     }); Package package = builder.GetResult(); package.SaveAs(@"d:\package\output\package.pkg"); } void ExecutePackage () { //    Package package = new Package(@"d:\package\output\package.pkg"); package.Execute(); }</span></span></code> </pre> <br>  Of course, the structure of classes still has time to undergo many metamorphoses, but with something you need to start. <br><br><h4>  Basic command system </h4><br>  Let's try to estimate the base system of the installer commands.  Here I am not going to list all the installer functionality, because I am going to give users an easy way to extend the functionality. <br>  Here I am going to describe the basic framework commands, allowing to unite the remaining teams into a single whole.  The abstract class, from which all commands will be inherited, contains a single Do () method, which itself will perform the action programmed by the command.  For example, the DeleteFile command will create a file inside this Do () method, and it will use the public property of the string FilePath as an argument (the path of the file to be deleted).  Here is what it will look like: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteFile</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FilePath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { File.Delete(FilePath); } }</code> </pre><br>  All other commands will be implemented in exactly the same way - the command inherits from the abstract Command class, and its Do () method replaces it, using the public properties of the inherited class as arguments. <br>  So, in the first approximation, I assumed that the teams would be added one by one to PackageBuilder, but I quickly realized the inflexibility of this approach.  Suppose that the sequence of installer commands should depend on the version number of the third-party software installed on the target machine.  For example, the algorithm for installing a site is very dependent on the version installed on the target IIS machine.  Or, for example, the installer should check the presence of the required COM objects on the target machine, and install them if necessary.  In all these cases, it is necessary to check some registry values ‚Äã‚Äãand select further actions depending on the values ‚Äã‚Äãread from there.  From here we came to the need to have a conditional execution command in the basic set, let's call it ExecuteIf.  Here is a description of its interface: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExecuteIf</span></span> : <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgumentName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Then { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Else { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  I mean that the Do () method reads from some execution context a boolean variable named ArgumentName, and if it is True, it executes the Then command, otherwise it executes the Else command.  Here we are faced with a new concept - the context of implementation.  Let the execution context be an instance of the ExecutionContext class, which (the instance) will be the argument of the call to the Do () method of each command.  In order not to inflate the abstract class interface with the overloaded Do (ExecutionContext) method, let's say that the Do () method is always called with the ExecutionContext argument, but those commands that do not change the execution context will simply ignore the Do () method argument. <br><br>  Thus, now our classes now look like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteFile</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FilePath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { File.Delete(FilePath); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExecuteIf</span></span> : <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgumentName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Then { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Else { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us digress from the description of the basic set of commands, and design the class ExecutionContext. <br><br><h4>  Execution context </h4><br>  Each team executed within the package, in addition to performing useful work, can also return the results of its execution.  For example, an SQL command can return the result of executing a stored procedure or the number of rows changed; reading the registry returns the actual value read.  In this case, in the general case, a command can return not one ValueType result, but several, it can also return a complex result, for example, a DataSet.  In order for other teams that rely on the results of previous operations to work correctly, you need to provide them with a way to access the results of previous commands.  In addition, each specific team can rely not only on the result of the strictly previous command, but in general any previously executed command, including it can rely on the results of the execution of several previous commands.  For example, I can create a FindIndexCommand command that defines the index of a certain string (entered by the user) in an array of strings, which was previously returned by the SqlQueryCommand command.  As you can see, the result of the FindIndexCommand command in this case rests on two arguments - the DataSet returned by the SqlQueryCommand command, and the string entered by the user using the UserInputCommand command.  I use the names of the teams that I haven‚Äôt even designed yet, meaning that their purpose is clear from the name of the team. <br>  To give the user such flexibility, I plan to introduce some execution context ExecutionContext.  It will give the opportunity to save the value in it under some key, and read the value from it, if it is there.  Each executed command will receive it as the first argument to the Do () method.  Thus, each team will have access to the results of all previously executed commands. <br>  The ExecutionContext class looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExecutionContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; _results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _results[key] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _results[key]; } }</code> </pre> <br>  Perhaps, in the future, other methods will be added to it, but for now it will have the simplest form, as in the listing above. <br>  At first, I was going to use the ExecutionContext like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteFile</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FilePath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExecutionContext _context; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { _context = context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre> <br><br>  That is, to submit its instance as an argument to the command constructor, save it in a private variable, and then use it as needed in the Do () method.  However, I remembered that the command package is usually first serialized and saved, and then the resulting file is deserialized and executed, and at this second step, the deserializer will automatically restore the package in memory, but it does not initialize the _context closed variable (because it is closed), which means and the package will run in an uninitialized context.  I thought that the context is needed only at the execution stage of the loaded package, and decided to give context as an argument to the Do () method.  This immediately brought another benefit - now we don‚Äôt need to write this repeating code in every new team: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExecutionContext _context; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { _context = context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteFile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  After all, now we don‚Äôt need constructors with arguments, which means that we don‚Äôt need to describe a default constructor, because the compiler will create it for us.  Now the command frame looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteFile</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FilePath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  That is, there is nothing superfluous in it, only the essence.  So a programmer who will support and develop the application, it will become easier to understand its essence. <br>  Now we can write an implementation of the ExecuteIf command: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExecuteIf</span></span> : <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgumentName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Then { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Command Else { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)context.GetResult(ArgumentName)) { Then.Do(context); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Else != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Else.Do(context); } } }</code> </pre> <br><br><h4>  Basic command system. </h4><br>  Let's return to the creation of the installer command frame.  We have already described the base abstract class Command, as well as the conditional execution command ExecuteIf.  The Then and Else parameters of the ExecuteIf command can be not just one command, but a whole block of consecutive commands.  This means that you need to design a command - an analogue of the operator brackets.  Let's call this command CommandSequence.  Its interface and implementation are simple: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CommandSequence</span></span> : <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List Commands; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Command command <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Commands) { command.Do(context); } } }</code> </pre> <br>  Its only parameter is the list of commands, and the Do () method simply executes them in turn. <br><br>  Recall now that the ExecuteIf command takes the name of a Boolean variable from the execution context as an input argument.  This boolean variable should appear from somewhere else in the context.  It should appear there as a result of checking some condition.  And so it was the turn to design the command comparison of quantities.  Let's design for the beginning of the string comparison command.  The command interface and its partial implementation should look like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CompareStringsCommand</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstOperandName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SecondOperandName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ResultName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> operand1 = (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(context.GetResult(FirstOperandName)); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> operand2 = (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(context.GetResult(SecondOperandName)); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = Compare(operand1, operand2); context.SaveResult(ResultName, result); } }</code> </pre> <br>  The team reads two variables from the context by their FirstOperandName and SecondOperandName names, compares them (I compared the comparison itself with the Compare () method), and then stores the comparison result in the context under the name ResultName. <br>  It can be seen that this command is a good contender for becoming the base abstract class for all other string comparison commands, and the Compare method (string, string) is an excellent candidate for becoming an abstract class method and being implemented in the heirs.  Next, I will rewrite only the abstract class interface (the implementation of the Do () method remains the same), and also give the code of one of the heirs: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CompareStringsCommand</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstOperandName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SecondOperandName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ResultName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> operand2</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,       } } public class StringStartsWith : CompareStringsCommand { protected override bool Compare(string operand1, string operand2) { return operand1.StartsWith(operand2); } }</span></span></code> </pre> <br>  As you can see, the set of commands for binary (with two arguments) comparison operators is easy to expand with any other comparison operations (EndsWith, Contains, Equals, NotEquals) just by creating an inheritor of the CompareStringsCommand class and defining the Compare method (string, string) in it. <br>  Unary operations (such as IsNullOrEmpty, for example) at this stage I propose to implement using the same base class, simply ignoring the second operand. <br>  Pay attention to this.  The CompareStringsCommand command compares the two arguments stored in the execution context, which will be there only as the results of the execution of other commands.  But what if I want to find out, for example, does a string that is read from the registry begin with some given constant substring?  I need to ensure that this constant is present in the execution context.  We design a command that simply stores the value in the execution context under the specified name.  Everything is simple here: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveConstantCommand</span></span>: <span class="hljs-title"><span class="hljs-title">Command</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ResultName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { context.SaveResult(ResultName, Value); } }</code> </pre><br>  In the next chapter, I will look at the implementation of the transaction mechanism. <br><br>  <a href="http://habrahabr.ru/blogs/refactoring/134512/">Link to the second part</a> </div><p>Source: <a href="https://habr.com/ru/post/134439/">https://habr.com/ru/post/134439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../134431/index.html">CSS3. Work with shadows. Part 2</a></li>
<li><a href="../134432/index.html">In search of the fat (The Quest For FAT)</a></li>
<li><a href="../134433/index.html">ReactOS Digest # 3: Moving on</a></li>
<li><a href="../134436/index.html">Indicators of the popularity of various mapping systems</a></li>
<li><a href="../134438/index.html">Talk about Docsis?</a></li>
<li><a href="../134440/index.html">Automation of processing video files from webcams using shell</a></li>
<li><a href="../134441/index.html">And we make calculators</a></li>
<li><a href="../134442/index.html">Change the width of the element with a "step" of several pixels</a></li>
<li><a href="../134443/index.html">Fast vector and complex shapes in Illustrator CS5</a></li>
<li><a href="../134446/index.html">Home accounting from the portal FINANCE.UA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>