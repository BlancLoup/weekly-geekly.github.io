<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We understand the protocol 2-wire JTAG</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2-wire JTAG (aka two-wire JTAG, aka CompactJTAG, aka cJTAG) is a newfangled interface that is part of the IEEE 1149.7-2009 standard. It provides the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We understand the protocol 2-wire JTAG</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5ed/a06/036/5eda06036f374b0d98989ac1ca674646.png"><br><br>  2-wire JTAG (aka two-wire JTAG, aka CompactJTAG, aka cJTAG) is a newfangled interface that is part of the IEEE 1149.7-2009 standard.  It provides the same and even greater functionality as a regular JTAG (IEEE 1149.1), but uses only two signals instead of four. <br><br>  Unfortunately, neither the Russian nor the English segments of the Internet have any information about this standard, except for a few articles written by marketers.  Nevertheless, some time ago, I had to deal with this standard on duty, and now you have a unique chance to get acquainted with the results of my research. <br><a name="habracut"></a><br>  I assume that you are familiar with the usual JTAG.  You can refresh your memory here: <a href="http://habrahabr.ru/post/190012/">habrahabr.ru/post/190012</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is often believed that IEEE 1149.7 and 2-wire JTAG are synonymous.  In fact, this is not the case, because IEEE 1149.7 includes modes that use both two and four signals.  So 2-wire JTAG is a subset of IEEE 1149.7. <br><br>  Officially, IEEE 1149.7 is called <i>IEEE Standard for Reduced-Pin and Enhanced-Functionality</i> .  Despite the fact that, in addition to the two-conductor nature, IEEE 1149.7 offers still a lot of new features, in my experience it is the opportunity to save two legs on the microcircuit case that attracts developers the most. <br><br>  Unfortunately, the creators of IEEE 1149.7 used hard drugs without any measure, so the monstrous document that firmly won first place in my personal hit parade of the most ugly written standards gave birth without any understatement.  Besides the fact that it has grown almost ten times (1037 pages versus 139 for the old JTAG), it is also written in such a way that it is absolutely impossible to understand anything. <br><br>  However, if you once face a chip with a chip that has instead of four JTAG legs (TCK, TMS, TDI and TDO) there are only two (TCKC and TMSC - ‚ÄúC‚Äù on the end means ‚ÄúCompact‚Äù), and the finished software to work with it will not, then you have to do something. <br><br>  What an engineer usually does when he sees a microchip with an unidentified JTAG port in front of him.  Of course, trying to figure out which devices are connected to it.  You can find out by reading their IDCODE.  For a regular JTAG, the procedure is simple and looks like described by the link <a href="http://www.fpga4fun.com/JTAG3.html">www.fpga4fun.com/JTAG3.html</a> : <br><ol><li>  First we determine the number of devices in the chain: <br><ul><li>  Go to Test Mode Reset </li><li>  Go to Shift-IR </li><li>  Via TDI, we push a bunch of units (how many do not mind, for example, 1000) in all IRs in the chain.  Now all devices in BYPASS </li><li>  Moving from Shift-IR to Shift-DR </li><li>  Via TDI, we push in a bunch of zeros (how many do not mind, for example, 1000) to all DRs in the chain in order to reset them </li><li>  We begin to push units through DRI through TDI.  As soon as we got a unit from TDO, we stop.  The number of devices in the chain is equal to the number of retracted units. </li></ul></li><li>  Then for each device we read IDCODE: <br><ul><li>  Go to Test Mode Reset - as a result, the address of the IDCODE register is recorded in all IRs. </li><li>  Go to Shift-DR </li><li>  We read from TDO 32 bits for each device (by the way, for this you have to push something into TDI).  The first 32 bits read from TDO are the IDCODE of the last device in the chain, the next 32 bits are the IDCODE of the penultimate device, etc. </li></ul></li></ol><br>  Initially, I wanted to show how to do the same thing using a two-wire JTAG, but it turned out that this procedure is a bit too long for an example.  Therefore, I decided to simplify it by assuming that there is only one device in the JTAG chain, and the address of its IDCODE register is known.  Thus, reading IDCODE will look like this: <br><ol><li>  Write the IDCODE address in the Instruction Register (IR): <br><ul><li>  Go to Shift-IR </li><li>  While in Shift-IR, we push the IDCODE register address into TDI </li></ul></li><li>  We read data from IDCODE: <br><ul><li>  Go to Shift-DR </li><li>  Being in Shift-DR, we push 32 arbitrary bits into TDI and at the same time we get the contents of IDCODE via TDO </li></ul></li></ol><br>  Obviously, being able to perform a simplified procedure, you can easily implement a complete one, because they use the same commands.  However, without TDI and TDO, which the 2-wire JTAG does not have, none of the above will work.  How is it proposed to do without them?  Very simple: Scan-packets containing TMS, TDI and TDO will be transmitted via TMSC.  This is how two successive packets look like (nTDI means that an inverted TDI is transmitted): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d8e/42e/7a3/d8e42e7a36564e4aa759346bf5f48cbf.png"></div><br>  In fact, this is only one of the possible formats described in the standard - it is called OScan1.  There are still JScan, MScan, SScan, and OScan already eight pieces.  However, only JScan0-3, MScan, Oscan0 and Oscan1 are mandatory for 2-wire JTAG. <br><br>  Here it should be noted that the TMSC signal, unlike the usual TMS, is bidirectional, because in each packet TMS and TDI are transmitted in one direction, and TDO - in the other. <br><br>  However, if you try to just start sending OScan-packages, then you will have an unpleasant surprise.  In short, nothing will work.  And all because, by default, any device with IEEE 1149.7 support is in compatibility mode with standard 1149.1 (the so-called ‚Äústandard mode‚Äù - standard mode) and does not accept any such packets.  Therefore, before sending any OSsans, it is necessary to configure such a device to work in the required format and transfer it to ‚Äúadvanced mode‚Äù (advanced mode). <br><br>  Before telling how to do this, a small lyrical digression is required.  One of the main goals in the development of IEEE 1149.7 was to ensure compatibility with the existing ‚Äúiron‚Äù, which at all times looked like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a6d/130/0b3/a6d1300b36c94dd18e79f00a3cad5b44.png"></div><br>  Instead of requiring chipmakers to remake the entire JTAG logic, the standard suggests adding an adapter that converts a two-wire interface to a regular four-wire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ade/dff/927/adedff927d0c459f9519f0e5e9f14264.png"></div> <br>  This adapter contains its own Test Access Port (TAP), called TAP.7, so that you can distinguish it from a regular TAP (aka TAP.1).  The TAP.7 controller inside is exactly the same machine as TAP.1, but there are some differences, for example, it does not have an Instruction Register, but there are many other registers that TAP.1 does not have. <br><br>  By default, TAP.7 is ‚Äútransparent‚Äù, i.e.  the TCKC signal is simply directly connected to the TCK, and the TMSC is connected to the TMS.  Therefore, all signals sent by the TCKC and TMSC are transmitted without any changes to the TCK and TMS: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/838/df1/14c/838df114c5ca4374a356db98780c4b9b.png"></div><br>  Obviously, when trying to transmit an Oscan1 packet in this mode, the ‚ÄúnTDI‚Äù will be perceived by the TAP.1 controller simply as the first bit transmitted via the TMS line, ‚ÄúTMS‚Äù as the second bit, etc.  That is why before transferring the packets, you need to transfer the TAP.7 controller to the ‚Äúadvanced mode‚Äù.  This is done by writing to one of the TAP.7 internal registers.  At the time of configuration, TCK and TMS are disabled (and TDI and TDO were previously disabled): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/63c/75c/51d/63c75c51de5d4a5a824749692a97b9fd.png"></div><br>  After the configuration is complete, the TCK, TMS, TDI and TDO are controlled by the controller's internal logic: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/42c/e54/b13/42ce54b13a374208ac3de0e5e45c3470.png"></div><br>  Thus, the process of switching to "advanced mode" and the subsequent reading of IDCODE looks like this: <br><ol><li>  Initialize the TAP.7 and TAP.1 controllers </li><li>  Disable TCK and TMS </li><li>  Select the desired transfer format </li><li>  If the format is OScan, MScan or SScan, then go to "advanced mode" </li><li>  Connect TCK, TMS, TDI and TDO </li><li>  Write IDCODE address to the Instruction Register </li><li>  Read IDCODE data </li></ol><br><h5>  <b>Initializing TAP.7.</b>  <b>Escape reset</b> </h5><br>  Since you can never know what state the TAP.7 and TAP.1 machines are in, you need to reset them before starting.  To reset the TAP.7 controller, use the Escape Reset, which is one of the types of escape sequences defined by the standard.  Escape sequences differ from all other JTAG commands in that the TMS values ‚Äã‚Äãare not read at the leading edge of the TCK, but asynchronously.  The TAP.7 controller counts the number of edges of the TMS signal that came in while the TCKC is unchanged.  The number of fronts determines the appearance of the escape sequence.  For escape escape it must be more than seven: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/462/775/248/4627752485984dd3b9d326d3eb6eab16.png"></div><br>  Also, Escape Reset takes TAP.7 to Test Logic Reset.  The beauty of escape-sequences is that they have absolutely no effect on TAP.1, which simply ignores them.  TAP.1 reads the TMS values ‚Äã‚Äãonly on the leading edge of the TCK, so it doesn‚Äôt matter to him what happens to TMS the rest of the time. <br>  This is how the Escape Reset looks on the oscilloscope screen, which transmits the <a href="https://www.digilentinc.com/Products/Detail.cfm%3FProd%3DJTAG-HS2">Digilent HS2</a> USB-JTAG adapter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/eed/23b/7b5/eed23b7b56c24a648f714022f685f474.jpg"></div><br>  As you can see, all eight fronts are in place, but the distance between the sixth and seventh looks suspicious.  I have already complained to Digilent - they promised to fix it. <br><br><h5>  <b>Initializing TAP.1</b> </h5><br>  To reset TAP.1 after TAP.7, the standard recommends sending five units via TMSC: they are guaranteed to transfer the TAP controller to the Test-Logic-Reset from absolutely any other state (you can check for yourself): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7f0/b29/46f/7f0b2946feb44ba2b3dc417c3da2e422.png"></div><br>  Since we do not plan to return to Test-Logic-Reset anymore, it makes sense to send a zero followed by five units and thereby transfer the machine to the Run-Test / Idle state.  Let me remind you that the controller reads the TMS values ‚Äã‚Äãat the time of the leading edge of the TCK and immediately changes the state of the machine in accordance with these values: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a0c/fa1/50d/a0cfa150d0464a46bf8fb12a7f8bf3fb.png"></div><br><h5>  <b>Disable TCK and TMS</b> </h5><br>  To disable TCM and TMS, you need to transfer the TAP.7 controller to Control Mode 2. In total, the controller supports eight different Control Mode, numbered from zero to seven.  We are interested in Control Mode 2, since only in it there is access to the controller's service registers, one of which we need to change the format of the packets on OScan1. <br><br>  Switching between control modes is performed sequentially by performing the so-called Zero-bit DR Shift (ZBS).  Each ZBS run increases the Control Mode by one.  Unlike escape sequences, in theory ZBS may affect the TAP.1 controller, but in practice this is highly unlikely.  From the point of view of the IEEE 1149.1 standard, Zero-bit DR Shift makes absolutely no sense, so the developers hoped that neither hardware nor software developed before the advent of 2-wire JTAG should have used ZBS for any of their needs. .  On the timeline, ZBS looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8a7/5eb/662/8a75eb662bf840c2816ab087c9d6cb30.png"></div><br>  As you can see, ZBS starts and ends in the Run-Test / Idle state, so it‚Äôs important not to forget to switch to Run-Test / Idle after Escape Reset and Test-Logic-Reset before sending the first ZBS. <br><br>  When the desired mode is selected, it must be locked (LOCK), after which subsequent ZBS-s will not be able to influence the choice of mode.  LOCK is almost the same as ZBS, only with entering Shift-DR: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/595/9fe/bf4/5959febf4bee473983615ad11ccf42af.png"></div><br>  Notice that the state of TAP.1, unlike TAP.7, does not change.  This is because the TCK and TMS are turned off as soon as the Control Mode number becomes equal to two, even if it is not fixed yet. <br>  Thus, to get into Control Mode 2, you need to: <br><ol><li>  Send two zbs </li><li>  Send LOCK </li></ol><br><h5>  <b>Format selection</b> </h5><br>  Now that we are in Control Mode 2, we can write to the service registers.  The standard describes a set of registers, the entry in which is made by special teams.  The teams are divided into two groups - two-part (two-part command) and three-part (three-part command), which I will not consider. <br><br>  In the case of two-section commands, the command number is transmitted in the first section, and the data is transmitted in the second section.  Both sections are transmitted in the same way: from the Run-Test / Idle state you need to go to Shift-DR, and then return to Run-Test / Idle.  The value transmitted is equal to the number of clock cycles held in Shift-DR. <br>  We are interested in the command number three - STFMT (Store Scan Format), which writes the number of the desired format (for OScan1 it is equal to nine), transmitted in the second section, to the register SCNFMT (Scan Format). <br><br>  Thus, in the first section we need to transfer the top three, and in the second - the nine.  First, we write down the command number, for which we are waiting for three cycles in the Shift-DR state (the TAP.1 state is not shown, since it does not change): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2e0/f05/0c6/2e0f050c651b4d039769bfc3827272cf.png"></div><br>  Then we write the data (nine clock cycles in the Shift-DR state): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/101/4cd/40f/1014cd40fe674aa3b11f2d3682e351bc.png"></div><br>  Writing to the SCNFMT register itself does not change the format.  In order for the controller to switch the format, you need to send a special check packet (check packet). <br><br><h5>  <b>Check packet</b> </h5><br>  The test package checks the correctness of the settings, and if everything is in order, the controller switches the format and, if necessary, switches to the ‚Äúadvanced mode‚Äù.  Like everything else in IEEE 1149.7, the test package has a bunch of different options.  You will have to take my word for it that we need a package with an END directive (and do not ask what this means), which looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/287/ced/3fa/287ced3fadb449c5a8a80e7cc3f8bd91.png"></div><br>  Hooray, now we are in "advanced mode" and we can finally use OScan1!  To return to the "standard mode", just go to Test-Logic-Reset. <br><br><h5>  <b>Connecting TCK, TMS, TDI and TDO</b> </h5><br>  So, we are in ‚Äúadvanced mode‚Äù, but still in Control Mode 2, which means that TAP.1 is still disabled, and we cannot read IDCODE from it.  The standard describes four ways to exit Control Mode: <br><ol><li>  Go to Test Logic Reset </li><li>  Go to Select-IR-Scan </li><li>  Write one to ECL (Exit Control Level) using a two-section STMC command </li><li>  To do something unknown, associated with the synchronization of TAP.7-controllers </li></ol><br>  In Test-Logic-Reset we can not, and then the controller will return to the "standard mode".  Two-team command to send a long time.  But to go to Select-IR-Scan and return to Run-Test / Idle, without going through Test-Logic-Reset, is quite simple - you just need to send the sequence 011011 by TMS (it is not necessary to enter Shift-IR).  Remember that in JTAG, the least significant bit is always transmitted first: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a14/f2a/533/a14f2a5336864382bbe01f1e401c3020.png"></div><br>  Red dots mark the places where the controller reads the TMS bits from the TMSC input.  Zeros are transmitted via TDI (i.e., in all packets, the nTDI bits are equal to one), although they are still ignored, since we do not go into the Shift-IR state. <br><br>  By the way, unlike ‚Äústandard mode‚Äù, the state of TAP.7 does not change immediately after receiving a new TMS bit, but on the third (last) leading edge of TCKC in the OScan1 packet (in the figure these points are shown by black arrows) - this is done for In order for the controller to insert the TDO bit into OScan1-packet and send it to the host (in this particular case, the controller returns zeroes via TDO). <br><br><h5>  <b>Reading IDCODE</b> </h5><br>  Now that TAP.1 is again connected to TAP.7, we can finally read the contents of the IDCODE register. <br><br>  The address of the IDCODE register is not described in the standard, therefore in all controllers it is different (in my case it is four-bit and is equal to 0xC).  To make life easier for users, the Instruction Register is initialized with an IDCODE address in the Test-Logic-Reset state.  However, in the Capture-IR state, the contents of the Instruction Register are overwritten with the number 0x1 (regardless of the length of the Instruction Register, its low-order bit is set to one, and all the others to zero) so that an open circuit can be detected during testing.  Since we entered Capture-IR in the previous step, the IDCODE address is already overwritten, so you first need to overwrite it. <br><br>  To write the register address, you must enter the Shift-IR state and push the address (0xC) along the TDI in the low-order bit.  In this case, the value that was in the Instruction Register before, i.e.  0x1 (again, the low bit forward).  In the case of a conventional four-wire IEEE 1149.1 JTAG, it would look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f72/8dd/8f1/f728dd8f1da249bc941e2003b8bc21c5.png"></div><br>  And this is how it looks when using OScan1 packages: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0a7/443/77a/0a744377a67b411b9592a81fae797f7f.png"></div><br>  Red dots mark the places where the controller reads the TMS bits, and the green dots show the nTDI bits from the TMSC input.  Purple dots mark the places where the controller reads the TDO bits before inserting them into OScan1 packets. <br>  The arrows show some dependencies, for example, the TMS and TDI signals vary along the corresponding edges of the TCKC, and the TDO signal changes along the falling edge of the TCK. <br><br>  Now it only remains to go to the Shift-DR state, push 32 arbitrary bits on TDI and read 32 bits from TDO, which will contain IDCODE.  With your permission, I will not provide a temporary IDCODE reading diagram. <br><br><h5>  <b>Conclusion</b> </h5><br>  I have described about 5% of the IEEE 1149.7 capability.  Nevertheless, I hope that you have some understanding of the principles underlying it. <br><br>  All diagrams in this article are tested on real hardware using the Digilent HS2 USB-JTAG adapter, a commercial 2-wire JTAG controller, to the source codes of which I have access, a debugging board with FPGA and a Xilinx ChipScope logic analyzer. <br><br>  The program for generating sequences was written using the API for HS2 based on an example, which can be downloaded along with the <a href="https://www.digilentinc.com/Products/Detail.cfm%3FNavPath%3D2,66,828%26Prod%3DADEPT2">Digilent Adept SDK</a> and worked fine under both Linux and Windows. </div><p>Source: <a href="https://habr.com/ru/post/237885/">https://habr.com/ru/post/237885/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237875/index.html">SALT: smart beacon protects wallet and phone</a></li>
<li><a href="../237877/index.html">RailsClub'Moscow 2014: interview with Kirill Timofeev</a></li>
<li><a href="../237879/index.html">JetBrains distributes free products to students</a></li>
<li><a href="../237881/index.html">Guide to creating startups, part 4: the most important thing for a startup</a></li>
<li><a href="../237883/index.html">Welcome to the 23rd Moscow Django Meetup</a></li>
<li><a href="../237887/index.html">Backblaze updated HDD reliability statistics</a></li>
<li><a href="../237889/index.html">ORM or how to forget about database design</a></li>
<li><a href="../237891/index.html">WGDC Competition: Latest Recommendations and Jury Composition</a></li>
<li><a href="../237893/index.html">The main types of search queries that online store users use, is your website ready for them? (Part 1)</a></li>
<li><a href="../237899/index.html">Using SmtpClient to send mail via Yandex SMTP server with SSL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>