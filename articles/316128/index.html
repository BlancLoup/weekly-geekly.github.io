<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TCP puzzles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="They say that you can not fully understand the system until you understand its failures. While still a student, I wrote the TCP implementation for fun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TCP puzzles</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/1c0/ac2/6fe/1c0ac26feba04897addf31831cc60ea4.jpg"></div><br>  They say that you can not fully understand the system until you understand its failures.  While still a student, I wrote the TCP implementation for fun, and then worked for several years in IT, but I still continue to study the work of TCP more deeply and more deeply - and its mistakes.  The most amazing thing is that some of these errors manifest themselves in basic things.  And they are not obvious.  In this article, I will present them as puzzles, in the style of <a href="http://www.cartalk.com/content/puzzlers">Car Talk</a> or <a href="https://www.youtube.com/watch%3Fv%3Dwbp-3BJWsU8">old Java puzzles</a> .  Like any other good puzzles, they are very easy to reproduce, but solutions are usually surprising.  And instead of focusing our attention on mysterious details, these puzzles help to explore some of the underlying principles of how TCP works. <br><a name="habracut"></a><br><h1>  The necessary conditions </h1><br>  These puzzles imply basic knowledge of how TCP works on Unix-like systems.  But you do not need to be a master to penetrate into them.  For example: <br><br><ul><li>  Information on TCP session states, the three stages of a connection, and the stages of its completion can be found on <a href="https://ru.wikipedia.org/wiki/TCP">Wikipedia</a> . </li><li> Programs typically interact with sockets using <code>read</code> , <code>write</code> , <code>connect</code> , <code>bind</code> , <code>listen</code> and <code>accept</code> .  In addition, there is also <code>send</code> and <code>recv</code> , but in our examples they will behave like <code>read</code> and <code>write</code> . </li><li>  I will use <code>poll</code> in this article.  Although many systems use something more efficient, such as <code>kqueue</code> or <code>epoll</code> , within the scope of our task all these tools will be equivalent.  As for applications that use blocking operations, and not any of these mechanisms: once you understand how TCP errors affect <code>poll</code> , it will be easier for you to guess what effect they will have on any blocking operation. </li></ul><br>  You can repeat all these examples on your own.  I used two virtual machines running using VMware Fusion.  The results were the same as in the production-server.  For testing, I used <code>nc(1)</code> on SmartOS, and I do not believe that any of the reproducible problems will be specific to a particular OS.  To track system calls and collect rough information about timings, I used the <a href="http://illumos.org/man/truss">truss (1)</a> utility from the illumos project.  You can get this information using <a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dtruss.1m.html">dtruss (1m)</a> under OS X or <a href="http://linux.die.net/man/1/strace">strace (1)</a> under GNU / Linux. <br><br>  <code>nc(1)</code> very simple program.  We will use it in two modes: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Like a server.  In this mode, nc will create a socket, listen on it, call <code>accept</code> and block until a connection is established. </li><li>  As a customer.  In this mode, <code>nc</code> will create a socket and establish a connection with a remote server. </li></ul><br>  In both modes, after the connection is established, each side uses <code>poll</code> to wait for standard input or connect a socket that has ready-to-read data.  Input data are output to the terminal.  The data that you enter into the terminal is sent through a socket.  When you press CTRL-C, the socket closes and the process stops. <br>  In the examples, my client will be called <code>kang</code> , and the server will be <code>kodos</code> . <br><br><h1>  Warm up: normal TCP break </h1><br>  Let's start with the basic situation.  Imagine that we set up a server on <code>kodos</code> : <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t bind,listen,accept,poll,read,write nc -l -p 8080 Base time stamp: 1464310423.7650 [ Fri May 27 00:53:43 UTC 2016 ] 0.0027 bind(3, 0x08065790, 32, SOV_SOCKBSD) = 0 0.0028 listen(3, 1, SOV_DEFAULT) = 0 accept(3, 0x08047B3C, 0x08047C3C, SOV_DEFAULT, 0) (sleeping...)</span></span></code> </pre> <br>  (I recall that in these examples I use <code>truss</code> to display the system calls that <code>nc</code> makes. Time information is displayed using the - <code>d</code> flag, and <code>-t</code> allows you to choose which of the calls we want to see.) <br><br>  Now I am connecting to <code>kang</code> : <br><br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t connect,pollsys,read,write,close nc 10.88.88.140 8080 Base time stamp: 1464310447.6295 [ Fri May 27 00:54:07 UTC 2016 ] ... 0.0062 connect(3, 0x08066DD8, 16, SOV_DEFAULT) = 0 pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  On <code>kodos</code> we see: <br><br>  Server <br><pre> <code class="bash hljs">23.8934 accept(3, 0x08047B3C, 0x08047C3C, SOV_DEFAULT, 0) = 4 pollsys(0x08045680, 2, 0x00000000, 0x00000000) (sleeping...)</code> </pre> <br>  TCP connection is in ESTABLISHED state, and both processes are in <code>poll</code> .  We can see this on every system using <code>netstat</code> : <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.140.8080 10.88.88.139.33226 1049792 0 1049800 0 ESTABLISHED ...</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.139.33226 10.88.88.140.8080 32806 0 1049800 0 ESTABLISHED ...</span></span></code> </pre> <br>  Question: <b>when we complete one of the processes, what happens to the other?</b>  Will he understand what happened?  How will he understand this?  Let's try to predict the behavior of specific system calls and explain why each of them does what it does. <br><br>  Press CTRL-C on <code>kodos</code> : <br><br>  Server <br><pre> <code class="bash hljs">pollsys(0x08045680, 2, 0x00000000, 0x00000000) (sleeping...) ^C127.6307 Received signal <span class="hljs-comment"><span class="hljs-comment">#2, SIGINT, in pollsys() [default]</span></span></code> </pre> <br>  And this is what we see on <code>kang</code> : <br><br>  Customer <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...) 126.1771 pollsys(0x08045670, 2, 0x00000000, 0x00000000) = 1 126.1774 <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(3, 0x08043670, 1024) = 0 126.1776 close(3) = 0 [root@kang ~]<span class="hljs-comment"><span class="hljs-comment">#</span></span></code> </pre> <br>  What happened?  Let's see: <br><br><ol><li>  By exiting the process, we sent SIGINT to the server.  After the exit, the file descriptors closed. </li><li>  When the last handle for the <code>ESTABLISHED</code> socket is closed, the TCP stack on the <code>kodos</code> sends over the FIN connection and enters the <code>FIN_WAIT_1</code> . </li><li>  The TCP stack on <code>kang</code> receives a FIN packet, switches its own connection to the <code>CLOSE_WAIT</code> state and sends an ACK in response.  While the <code>nc</code> client is blocking the socket - it is ready to read, the kernel wakes this thread with a <code>POLLIN</code> . </li><li>  The <code>nc</code> client sees the <code>POLLIN</code> for the socket and calls <code>read</code> , which immediately returns 0. This means the end of the connection.  <code>nc</code> decides that we are done with the socket, and closes it. </li><li>  In the meantime, the TCP stack on <code>kodos</code> receives an ACK and transitions to the <code>FIN_WAIT_2</code> . </li><li>  While the <code>nc</code> client on kang closes its socket, the TCP stack on <code>kang</code> sends FIN to <code>kodos</code> .  Connection to <code>kang</code> goes to <code>LAST_ACK</code> state. </li><li>  The TCP stack on <code>kodos</code> receives FIN, the connection goes to the <code>TIME_WAIT</code> state, and the stack on <code>kodos</code> confirms FIN. </li><li>  The TCP stack on <code>kang</code> receives an ACK for FIN and completely removes the connection. </li><li>  After two minutes, the TCP connection on the <code>kodos</code> closes, and the stack completely removes the connection. </li></ol><br>  The order of the stages may vary slightly.  Also <code>kang</code> can pass through the <code>CLOSING</code> state instead of <code>FIN_WAIT_2</code> . <br><br>  So, according to netstat, the final state looks like: <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.140.8080 10.88.88.139.33226 1049792 0 1049800 0 TIME_WAIT</span></span></code> </pre> <br>  There is no outgoing data for <code>kang</code> for this connection. <br><br>  Intermediate states pass very quickly, but you can track them using the <a href="">DTrace TCP provider</a> .  Packet streams can be viewed using <a href="http://illumos.org/man/snoop">snoop (1m)</a> or <a href="http://www.tcpdump.org/tcpdump_man.html">tcpdump (1)</a> . <br><br>  <b>Conclusions:</b> We saw a normal path for system calls to pass during the installation and close the connection.  Please note that <code>kang</code> immediately discovered that the connection was closed on <code>kodos</code> - it was woken from <code>poll</code> , and returning zero <code>read</code> signaled the end of the transmission stream.  At this point, <code>kang</code> <i>decided to</i> close the socket, which led to the closure of the connection with <code>kodos</code> .  We will come back to this later and see what happens if <code>kang</code> does not close the socket in this situation. <br><br><h1>  Puzzle 1: Power restart </h1><br>  <b>What happens with an inactive TCP connection established when one of the systems restarts?</b> <br><br>  Since many processes are completed correctly in the scheduled reboot process (using the “reboot” command), the result will be the same if you enter the “reboot” command in the <code>kodos</code> console <code>kodos</code> the server using CTRL-C.  But what happens if in the previous example we just turn off the power for <code>kodos</code> ?  In the end, <code>kang</code> will find out about this, right? <br><br>  Let's check.  We establish connection: <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t bind,listen,accept,poll,read,write nc -l -p 8080 Base time stamp: 1464312528.4308 [ Fri May 27 01:28:48 UTC 2016 ] 0.0036 bind(3, 0x08065790, 32, SOV_SOCKBSD) = 0 0.0036 listen(3, 1, SOV_DEFAULT) = 0 0.2518 accept(3, 0x08047B3C, 0x08047C3C, SOV_DEFAULT, 0) = 4 pollsys(0x08045680, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t open,connect,pollsys,read,write,close nc 10.88.88.140 8080 Base time stamp: 1464312535.7634 [ Fri May 27 01:28:55 UTC 2016 ] ... 0.0055 connect(3, 0x08066DD8, 16, SOV_DEFAULT) = 0 pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  To emulate a power restart, I will use the reboot function from VMware.  Please note that this will be a real restart - everything that leads to a gradual shutdown is more like the first example. <br><br>  After 20 minutes, <code>kang</code> still in the same condition: <br><br>  Customer <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</code> </pre> <br>  We tend to believe that the job of TCP is to maintain abstraction (namely, TCP connections) between multiple systems at all times, so that such cases of broken abstraction look amazing.  And if you think that this is some kind of nc (1) problem, then you are mistaken.  The "netstat" on <code>kodos</code> shows no connection to <code>kang</code> , but at the same time <code>kang</code> will show a fully working connection to <code>kodos</code> : <br><br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.139.50277 10.88.88.140.8080 32806 0 1049800 0 ESTABLISHED ...</span></span></code> </pre> <br>  If you leave everything as it is, <code>kang</code> will never know that <code>kodos</code> been reset. <br><br>  <b>Now suppose <code>kang</code> trying to send data to <code>kodos</code> .</b>  <b>What will happen?</b> <br><br>  Customer <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...) kodos, are you there? 3872.6918 pollsys(0x08045670, 2, 0x00000000, 0x00000000) = 1 3872.6920 <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(0, <span class="hljs-string"><span class="hljs-string">" kodos , are y"</span></span>.., 1024) = 22 3872.6924 write(3, <span class="hljs-string"><span class="hljs-string">" kodos , are y"</span></span>.., 22) = 22 3872.6932 pollsys(0x08045670, 2, 0x00000000, 0x00000000) = 1 3872.6932 <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(3, 0x08043670, 1024) Err<span class="hljs-comment"><span class="hljs-comment">#131 ECONNRESET 3872.6933 close(3) = 0 [root@kang ~]#</span></span></code> </pre> <br>  When I enter the message and press Enter, the <code>kodos</code> wakes up, reads the message from stdin and sends it through the socket.  <i>Call</i> <code>write</code> <i>successfully completed</i> !  <code>nc</code> returns to <code>poll</code> , waiting for the next event, and eventually finds that the socket cannot be read without blocking, after which it calls <code>read</code> .  This time <code>read</code> drops with ECONNRESET status.  What does it mean?  <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html">The read (2) documentation</a> tells us: <br><br><pre> <code class="bash hljs">[ECONNRESET]     ,      .</code> </pre> <br>  <a href="">Another source</a> contains a bit more details: <br><br><pre> <code class="bash hljs"> ECONNRESET  filedes      .        .  /      filedes.</code> </pre> <br>  This error does not mean any particular problem with the <code>read</code> call.  It only says that the socket has been disconnected.  For this reason, most socket operations will result in an error. <br><br>  So what happened?  At that moment, when <code>nc</code> tried to send data to <code>kang</code> , the TCP stack still did not know that the connection was already dead.  <code>kang</code> sent a data packet to <code>kodos</code> , who answered the RST because he knew nothing about the connection.  <code>kang</code> saw RST and cut the connection.  The socket file descriptor cannot be closed, file descriptors do not work that way, but subsequent operations will fail with ECONNRESET status until <code>nc</code> closes the file descriptor. <br><br>  <b>Findings:</b> <br><br><ol><li>  A hard power outage is very different from a gentle shutdown.  When testing distributed systems, this scenario should also be checked separately.  Do not expect that everything will be the same as with the normal process stop (kill). </li><li>  <b>There are situations when one side is sure that the TCP connection is established, and the other is not sure, and this situation will never be resolved automatically.</b>  You can control the resolution of such problems using keep-alive for connections at the application level or TCP. </li><li>  The only reason why <code>kang</code> still found out about the disappearance of the remote side is that it sent the data and received a response indicating that there is no connection. </li></ol><br>  The question arises: what if <code>kodos</code> for some reason does not respond to sending data? <br><br><h1>  Puzzle 2: Power Off </h1><br>  <b>What happens if the endpoint of a TCP connection is disconnected from the network for a while?</b>  Do other knots find out about this?  If so, how?  And when? <br><br>  Reconnect using <code>nc</code> : <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t bind,listen,accept,poll,read,write nc -l -p 8080 Base time stamp: 1464385399.1661 [ Fri May 27 21:43:19 UTC 2016 ] 0.0030 bind(3, 0x08065790, 32, SOV_SOCKBSD) = 0 0.0031 listen(3, 1, SOV_DEFAULT) = 0 accept(3, 0x08047B3C, 0x08047C3C, SOV_DEFAULT, 0) (sleeping...) 6.5491 accept(3, 0x08047B3C, 0x08047C3C, SOV_DEFAULT, 0) = 4 pollsys(0x08045680, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t open,connect,pollsys,read,write,close nc 10.88.88.140 8080 Base time stamp: 1464330881.0984 [ Fri May 27 06:34:41 UTC 2016 ] ... 0.0057 connect(3, 0x08066DD8, 16, SOV_DEFAULT) = 0 pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  Now suddenly turn off the power to the <code>kodos</code> and try to send data with <code>kang</code> : <br><br>  Customer <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...) 114.4971 pollsys(0x08045670, 2, 0x00000000, 0x00000000) = 1 114.4974 <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(0, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, 1024) = 1 114.4975 write(3, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, 1) = 1 pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</code> </pre> <br>  The <code>write</code> call ends normally and I see nothing for a long time.  Only five minutes later appears: <br><br>  Customer <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...) 425.5664 pollsys(0x08045670, 2, 0x00000000, 0x00000000) = 1 425.5665 <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(3, 0x08043670, 1024) Err<span class="hljs-comment"><span class="hljs-comment">#145 ETIMEDOUT 425.5666 close(3) = 0</span></span></code> </pre> <br>  This situation is very similar to the one when we restarted the power supply instead of turning it off completely.  There are two differences: <br><br><ul><li>  the system took 5 minutes to understand the situation </li><li>  The error status was ETIMEDOUT. </li></ul><br>  Notice again - this is an expired <code>read</code> timeout.  We would see the same error with other socket operations.  This is because the <i>socket</i> enters a state when the connection has timed out.  The reason for this is that the remote side did not confirm the data packet for too long - 5 minutes, in accordance with the settings of this system. <br><br>  <b>Findings:</b> <br><br><ol><li>  When the remote system simply turns off instead of restarting the power supply, the first system can find out about it only by sending data.  Otherwise, she will never know if the connection is broken. </li><li>  When the system tries to send data for too long and does not receive a response, the TCP connection is closed and all operations with the socket will fail with an ETIMEDOUT error. </li></ol><br><h1>  Puzzle 3: Breaking the connection without falling </h1><br>  This time, instead of describing a specific situation to you and asking what is happening, I will do the opposite: I will describe some kind of observation and see if you can understand how this happened.  We discussed several situations in which <code>kang</code> may believe that it is connected to <code>kodos</code> , but <code>kodos</code> does not know about it.  <b>Is it possible for <code>kang</code> be connected to <code>kodos</code> so that <code>kodos</code> does not know about it for an indefinite period of time (i.e., the problem will not be solved by itself), and there would be no power cut or restart, no other error of the <code>kodos</code> operating system or network equipment?</b> <br><br>  Hint: consider the above case when the connection is stuck in the status of ESTABLISHED.  It is fair to assume that the application is responsible for solving this problem, since it keeps the socket open and can detect it by sending data when the connection was interrupted.  But what if the application no longer holds the socket open? <br><br>  In the warm-up we considered the situation when nc on <code>kodos</code> closed the socket.  We said that nc on <code>kang</code> read 0 (pointer to the end of the transfer) and closed the socket.  Suppose the socket is left open.  Obviously, it would be impossible to read from it.  But nothing is said about TCP that you cannot send additional data to the party that sent you the FIN.  <b>FIN only means closing the data stream in the direction FIN was sent.</b> <br><br>  To demonstrate this, we cannot use <code>nc</code> on <code>kang</code> , because it automatically closes the socket after receiving 0. Therefore, I wrote a demo version of <code>nc</code> , called <a href="https://github.com/davepacheco/experiment-dnc">dnc</a> , that skips this moment.  Also, <a href="https://github.com/davepacheco/experiment-dnc">dnc</a> explicitly outputs the system calls it makes.  This will give us a chance to track the state of TCP. <br><br>  First configure the connection: <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># truss -d -t bind,listen,accept,poll,read,write nc -l -p 8080 Base time stamp: 1464392924.7841 [ Fri May 27 23:48:44 UTC 2016 ] 0.0028 bind(3, 0x08065790, 32, SOV_SOCKBSD) = 0 0.0028 listen(3, 1, SOV_DEFAULT) = 0 accept(3, 0x08047B2C, 0x08047C2C, SOV_DEFAULT, 0) (sleeping...) 1.9356 accept(3, 0x08047B2C, 0x08047C2C, SOV_DEFAULT, 0) = 4 pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...)</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># dnc 10.88.88.140 8080 2016-05-27T08:40:02Z: establishing connection 2016-05-27T08:40:02Z: connected 2016-05-27T08:40:02Z: entering poll()</span></span></code> </pre> <br>  Now make sure that the connection on both sides is in the status of ESTABLISHED: <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.140.8080 10.88.88.139.37259 1049792 0 1049800 0 ESTABLISHED</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.139.37259 10.88.88.140.8080 32806 0 1049800 0 ESTABLISHED</span></span></code> </pre> <br>  On <code>kodos</code> use CTRL-C for the <code>nc</code> process: <br><br>  Server <br><pre> <code class="bash hljs">pollsys(0x08045670, 2, 0x00000000, 0x00000000) (sleeping...) ^C[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment">#</span></span></code> </pre> <br>  We will immediately see the following on <code>kang</code> : <br><br>  Customer <br><pre> <code class="bash hljs">2016-05-27T08:40:12Z: poll returned events 0x0/0x1 2016-05-27T08:40:12Z: reading from socket 2016-05-27T08:40:12Z: <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> end-of-stream from socket 2016-05-27T08:40:12Z: <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> 0 bytes from socket 2016-05-27T08:40:12Z: entering poll()</code> </pre> <br>  Now let's look at the status of TCP connections: <br><br>  Server <br><pre> <code class="bash hljs">[root@kodos ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.140.8080 10.88.88.139.37259 1049792 0 1049800 0 FIN_WAIT_2</span></span></code> </pre> <br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.139.37259 10.88.88.140.8080 1049792 0 1049800 0 CLOSE_WAIT</span></span></code> </pre> <br>  It makes sense: kudos sent FIN to <code>kang</code> .  <code>FIN_WAIT_2</code> indicates that <code>kodos</code> received an ACK from <code>kang</code> in response to the FIN sent to them, and <code>CLOSE_WAIT</code> indicates that <code>kang</code> received a FIN, <i>but did not send FIN in response</i> .  <b>This is a completely normal TCP connection state that can last indefinitely.</b>  Imagine that <code>kodos</code> sent a <code>kang</code> request and did not plan to send anything else;  <code>kang</code> can spend hours happily sending data back.  Only in our case, the <code>kodos</code> <i>actually closed the socket</i> . <br><br>  Let's wait a minute and check the status of TCP connections again.  It <code>kodos</code> out that the connection completely disappears on <code>kodos</code> , but still exists on <code>kang</code> : <br><br>  Customer <br><pre> <code class="bash hljs">[root@kang ~]<span class="hljs-comment"><span class="hljs-comment"># netstat -f inet -P tcp -n TCP: IPv4 Local Address Remote Address Swind Send-Q Rwind Recv-Q State –––––––––––––––––––– –––––––––––––––––––– ––––– –––––- ––––– –––––- ––––––––––- 10.88.88.139.37259 10.88.88.140.8080 1049792 0 1049800 0 CLOSE_WAIT</span></span></code> </pre> <br>  We faced a less well-known situation related to the TCP stack: when the application closed the socket, the stack sent FIN, the remote stack recognized it FIN, and the local stack waited for a fixed period of time <i>and closed the connection</i> .  Cause?  The remote side has been rebooted.  This case is similar to when the connection on one side is in ESTABLISHED status, and the other side does not know about it.  The only difference is that the application closed the socket, and there is no other component that could deal with the problem.  As a result, the TCP stack waits for a set period of time and closes the connection (without sending anything to the other side). <br><br>  Question to follow: <b>what happens if in this situation <code>kang</code> sends data to <code>kodos</code> ?</b>  Do not forget, <code>kang</code> still believes that the connection is open, although on the <code>kodos</code> side it is already completed. <br><br>  Customer <br><pre> <code class="bash hljs">2016-05-27T08:40:12Z: entering poll() kodos, are you there? 2016-05-27T08:41:34Z: poll returned events 0x1/0x0 2016-05-27T08:41:34Z: reading from stdin 2016-05-27T08:41:34Z: writing 22 bytes <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> from stdin to socket 2016-05-27T08:41:34Z: entering poll() 2016-05-27T08:41:34Z: poll returned events 0x0/0x10 2016-05-27T08:41:34Z: reading from socket dnc: <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: Connection reset by peer</code> </pre> <br><br>  This is the same thing that we saw in Puzzle 1: <code>write()</code> succeeds because the TCP stack does not yet know that the connection is closed.  But then comes the RST, which wakes up the thread in the <code>poll()</code> , and the subsequent <code>read()</code> request returns ECONNRESET. <br><br>  <b>Findings:</b> <br><br><ul><li>  It is possible that both parties do not agree on the status of the connection, <i>although there was no error of the operating system, network or hardware</i> . </li><li>  In the case described above, <code>kang</code> does not know whether <code>kodos</code> expecting to receive data from <code>kang</code> , or <code>kodos</code> closed the socket and is not listening on it (at least not without sending a packet).  Therefore, it is not necessary to design a system that, under normal operating conditions, will use sockets in such half-open states for a long time. </li></ul><br><h1>  Conclusion </h1><br>  TCP is usually presented to us as a protocol that supports abstraction - “TCP connection” - between two systems.  We know that due to some software or network problems, the connection will fall.    ,       <i></i> , -         .  For example: <br><br><ul><li>    ,         , ,   ,      . </li><li>     -   ,    . </li></ul><br>       TCP. ,    TCP    ,   .            TCP,        ,     .   ,    ,  TCP-     . <br><br>   ,   ,      ,   ,  <b> «TCP-,   » —   </b> .  -   ,  ,          .        ,    - (     keep-alive). <br><br>  ,   «»   TCP-.   ( ,    )  ,     .       ,  TCP-     . <br><br>  ,    : <br><br><ul><li>    (   ) —     ,      .     . ,       —     ,    . </li><li>      ,   TCP-.     ,   <code>read()</code> , <code>write()</code> ,        .     -    ,        . </li></ul><br><br>   : <br><br><ul><li> ECONNRESET —   ,      <code>read()</code> , <code>write()</code>   .  ,     RST. </li><li> ETIMEDOUT —   ,     <code>read()</code> , <code>write()</code>   .  ,    ,    .     ,        .    ,  FIN   KeepAlive. </li></ul><br>  ,     ,  -         .   ,    . </div><p>Source: <a href="https://habr.com/ru/post/316128/">https://habr.com/ru/post/316128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316118/index.html">Publisher Peter. Black Friday 2016</a></li>
<li><a href="../316120/index.html">Technologies from the “Black Mirror”, which are already with us</a></li>
<li><a href="../316122/index.html">The entire collection of IT Black Friday + Cyber ​​Monday IT discounts in one post ... And let no one leave offended</a></li>
<li><a href="../316124/index.html">Better in RainTime than never: Extend the JIRA API on the fly</a></li>
<li><a href="../316126/index.html">Interweaving the narrative into the procedural worlds</a></li>
<li><a href="../316132/index.html">Google Chrome Developer Console: Ten Unobvious Utilities</a></li>
<li><a href="../316134/index.html">How to make the presentation interactive</a></li>
<li><a href="../316136/index.html">Pro Rendering Optimization - With Optimism</a></li>
<li><a href="../316138/index.html">Call Transfer Using Script in Asterisk</a></li>
<li><a href="../316140/index.html">How to test a legacy without pain and fear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>