<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate Node.js with Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, the network is often mentioned "young and promising" language Rust. He awakened in me curiosity and the desire to do something more or less ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate Node.js with Rust</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f54/346/4b3/f543464b3aa84196bb331ab4360371ea.png"><br><br>  Recently, the network is often mentioned "young and promising" language Rust.  He awakened in me curiosity and the desire to do something more or less useful on him, in order to somehow try on - whether he fit me.  This resulted in a rather curious, as it seems to me, experience of crossing the grass with the hedgehog with the assistance of the cuckoo. <br><br><a name="habracut"></a>  And so, I did this.  There is a project on node.js.  There is a functional that requires a hash count.  Moreover, quite often - for almost every incoming request.  Since this hash is not something that should protect me from collisions and is generally not needed for security reasons, but for convenience, the adler32 algorithm is used.  It provides a short output value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For some nonsense, it is not in node.js.  Let me explain why this is ridiculous.  This algorithm is usually used in compression, in particular, it is used by gzip.  In node.js there is a standard implementation of gzip in the zlib module.  That is, adler32 is actually there, but in an implicit form.  In Python, for comparison, in a similar module it is available and can be used. <br><br>  Anyway.  We take a third-party package from npm.  I took this one: <a href="https://www.npmjs.com/package/adler32">adler32</a> - mainly because it can integrate with the crypto module and can be used just like other hash algorithms.  It's comfortable.  In this case, I did not particularly think about performance.  Whatever it is - it's a penny.  But since I was planning an experiment, this very adler32 was chosen as a victim. <br><br>  In general, let's get started.  Put Rust easy.  Documentation is also quite intelligible in both <a href="https://www.rust-lang.org/ru-RU/documentation.html">Russian</a> and <a href="https://www.rust-lang.org/en-US/documentation.html">English</a> .  Rust is taken version 1.15.  Fun fact: the documentation in Russian is not a direct English translation and is slightly different in structure.  In particular, it added an example of working with threads. <br><br>  In addition to Rust itself, there is also node.js version 6.8.0, Visual Studio 2015 and Python 2.7 - all this is needed. <br><br>  Now let's make a preliminary measurement. <br><br><h4>  Node.js </h4><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5000000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = crypto.createHash(<span class="hljs-string"><span class="hljs-string">'adler32'</span></span>); m.update(<span class="hljs-string"><span class="hljs-string">"-    ,      "</span></span>); m.digest(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>); }</code> </pre> <br>  The average result of three launches: <b>41.601</b> seconds.  The best result: 40,206 <br><br>  To compare with something, let's take for a start the native implementation of the hash in node.js.  Let's say sha1.  Having executed the exact same code, but specifying sha1 as the algorithm, I received the following numbers: <br>  The average result of three starts: <b>9.737</b> seconds.  Best score: 9,321 <br><br>  Well, maybe it is this Adler?  But wait, wait.  Let's still try to do something on Rust. <br><br><h4>  Rusty </h4><br>  And so, on Rust there is a third-party library compress, which is available in this their Cargo.  She also knows how to gzip and provides the ability to read adler32.  It looks like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5000_000</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> state = adler::State32::new(); state.feed(<span class="hljs-string"><span class="hljs-string">"-    ,      "</span></span>.as_bytes()) }</code> </pre> <br>  The average result of three starts: <b>2.314</b> seconds.  The best result: 2,309 <br><br>  Not bad! <br><br><h4>  Node.js and FFI </h4><br>  Since Rust is compiled into C-compatible code, it can be compiled into a dynamic library and connected using <a href="http://rurust.github.io/rust_book_ru/src/ffi.html">FFI</a> .  Node.js has a special package for this, which needs to be installed separately: <br><br><pre> <code class="dos hljs">npm install ffi</code> </pre> <br>  If all is well with you, then after that it will be possible to connect external libraries written in C or compatible with it. <br><br>  So, it is necessary to convert this crusher on the plant now to the library.  In short, the code looks like this: <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> compress; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> libc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> libc::c_char; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ffi::CStr; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ffi::CString; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> compress::checksum::adler; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adler</span></span></span></span>(url: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> c_char { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c_str = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { CStr::from_ptr(url).to_bytes() }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> state = adler::State32::new(); state.feed(c_str); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s:<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:x}"</span></span>, state.result()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = CString::new(s).unwrap(); s.into_raw() }</code> </pre> <br>  As you can see, everything has become a bit more complicated.  At the input, the function receives a C string, which it overtakes in bytes, counts the hash, converts it to hex, then again overtakes the C line, and only then returns it. <br><br>  In addition, in the file Cargo.toml you need to specify what you need to compile into a dynamic library.  There are also dependencies: <br><br><pre> <code class="hljs pgsql">[package] <span class="hljs-type"><span class="hljs-type">name</span></span> = "adler" version = "0.1.0" authors = ["juralis"] [lib] <span class="hljs-type"><span class="hljs-type">name</span></span> = "adler" crate-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = ["dylib"] [dependencies] compress = "*" libc = "*"</code> </pre> <br><br>  Here it is.  Now it will be compiled into the library.  What type - depends on the target platform.  I got a dll at the output, since I did all this from under Windows and indicated the appropriate compilation parameters: <br><br><pre> <code class="dos hljs">cargo build --release --target x86_64-pc-windows-msvc</code> </pre> <br>  Well.  Grab this dll, put it somewhere closer to the project on node.js and add something to the code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ffi = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ffi'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lib = ffi.Library(<span class="hljs-string"><span class="hljs-string">'adler.dll'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">adler</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, [<span class="hljs-string"><span class="hljs-string">'string'</span></span>]] }) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5000000</span></span>; i++) { lib.adler(<span class="hljs-string"><span class="hljs-string">"-    ,      "</span></span>) }</code> </pre><br>  The average result of three starts: <b>27.882</b> seconds.  The best result: 26,642 <br><br>  Well ... Something is somehow not what I would like.  Apparently, all these joys with external challenges are quite expensive.  However, it still works faster.  But can it be done even faster?  Can. <br><br><h4>  Node.js and C ++ addon </h4><br>  In node.js, as it is known, so-called <a href="https://nodejs.org/api/addons.html">add</a> - <a href="https://nodejs.org/api/addons.html">ons are</a> supported.  Why not try it?  The only problem is that I generally speaking in C ++ have no tooth in the foot.  However, there are good people who wrote a little help.  Here it is about how it works.  As it turned out, I am not the first to decide to have fun in this way.  However, there is a rather trivial example of calculating Fibonacci numbers and, accordingly, much remains unclear.  And since I do not know C ++, this of course presented a problem. <br><br>  But it turned out that humanity went much further in the matter of inventing all sorts of perversions and some kind person wrote a small Cpp-wrapper <a href="https://github.com/andruhon/runo-bridge">generator</a> for Rust libraries.  It analyzes the source code for Rust, takes those functions that fit the criteria and generates some code on the pluses.  And for that Rust-code, which was given above, we got such a piece of C ++ code <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Header //This could go into separate header file defining interface: #ifndef NATIVE_EXTENSION_GRAB_H #define NATIVE_EXTENSION_GRAB_H #include &lt;nan.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;node.h&gt; #include &lt;stdio.h&gt; using namespace std; using namespace v8; using v8::Function; using v8::Local; using v8::Number; using v8::Value; using Nan::AsyncQueueWorker; using Nan::AsyncWorker; using Nan::Callback; using Nan::New; using Nan::Null; using Nan::To; #endif /* extern interface for Rust functions */ extern "C" { extern "C" char * adler(char * url); } NAN_METHOD(adler) { Nan::HandleScope scope; String::Utf8Value cmd_url(info[0]); string s_url = string(*cmd_url); char *url = (char*) malloc (s_url.length() + 1); strcpy(url, s_url.c_str()); char * result = adler(url); info.GetReturnValue().Set(Nan::New&lt;String&gt;(result).ToLocalChecked()); free(result); free(url); } NAN_MODULE_INIT(InitAll) { Nan::Set( target, New("adler").ToLocalChecked(), Nan::GetFunction(New&lt;FunctionTemplate&gt;(adler)).ToLocalChecked() ); } NODE_MODULE(addon, InitAll)</span></span></code> </pre> <br>  In addition, from the previous comrade, I took an example of the bindings.gyp file: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"targets"</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">"target_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"adler"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sources"</span></span>: [<span class="hljs-string"><span class="hljs-string">"adler.cc"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"libraries"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"/path/to/lib/adler.dll"</span></span> ] }] }</code> </pre> <br>  I also need an index.js file with obedience: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./build/Release/addon'</span></span>);</code> </pre> <br>  Now we need to collect all this joy using node-gyp.  But it refused to compile from me.  I had to sort out a little about what was going on there. <br><br>  First you need to put the package nan (Native Abstractions for Node.js): <br>  npm install nan -g <br><br>  And add a path to it in bindings.gyp (somewhere on the same level with libraries): <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"include_dirs"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"&lt;!(node -e \"require('nan')\")"</span></span> ]</code> </pre> <br>  There the compiler will look for the header file from this very nan.  After that it was necessary to pick a little more positive file.  Here is the final version, which I deigned to compile: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;nan.h&gt; #include &lt;string&gt; #include &lt;node.h&gt; #pragma comment(lib,"Ws2_32.lib") #pragma comment(lib,"userenv.lib") using std::string; using v8::String; using Nan::New; extern "C" { extern "C" char * adler(char * url); } NAN_METHOD(adler) { Nan::HandleScope scope; String::Utf8Value cmd_url(info[0]); string s_url = string(*cmd_url); char *url = (char*) malloc (s_url.length() + 1); strcpy(url, s_url.c_str()); char * result = adler(url); info.GetReturnValue().Set(Nan::New&lt;String&gt;(result).ToLocalChecked()); free(result); free(url); } NAN_MODULE_INIT(InitAll) { Nan::Set( target, New("adler").ToLocalChecked(), Nan::GetFunction(New&lt;FunctionTemplate&gt;(adler)).ToLocalChecked() ); } NODE_MODULE(addon, InitAll)</span></span></span></span></code> </pre> <br>  However, before this happened, one more thing came to light.  My library was compiled as dynamic, and node-gyp required static.  Therefore, in Cargo.toml you need to change this line here: <br><br>  crate-type = ["dylib"] <br>  on this one: <br>  crate-type = ["staticlib"] <br><br>  Then again you need to compile: <br><br><pre> <code class="dos hljs">cargo build --release --target x86_64-pc-windows-msvc</code> </pre> <br>  In addition, you need to remember now to change the path to the library in bindings.gyp to the lib version: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"libraries"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"/path/to/lib/adler.lib"</span></span> ]</code> </pre> <br>  And then it should be all together and get the coveted file adler.node. <br><br>  In node again we change the code to generate the hash: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> adler = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'/path/to/adler.node'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5000000</span></span>; i++) { adler.adler(<span class="hljs-string"><span class="hljs-string">"-    ,      "</span></span>); }</code> </pre><br>  The average result of three starts: <b>7,802</b> seconds.  Best score: 7,658 <br><br>  Oh, it's already a couple of seconds faster than even the native way of calculating sha1!  Looks very nice! <br><br>  Basically, what is 5 million times hash to calculate and spend 40 seconds on it?  It is approximately as if a little less than one hundred thousand requests came to you in a second, and the application would spend the whole hash on counting hashes.  That is, it would not have time to do anything else.  And with such an acceleration, it will be quite enough to do something other than hashes.  I do not think that this project will ever receive such a load of 100 thousand requests per second, but nevertheless, I find the experience quite useful. <br><br><h4>  By the way, what about python? </h4><br>  Python was mentioned at the beginning of the article, so why not try it too, since it was still at hand?  There, as I said, adler32 can be counted right out of the box.  Something like this will be the code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import zlib st = b'-    ,      ' for i in range(5000000): hex(zlib.adler32(st))[2:]</span></span></code> </pre><br>  The average result of three starts: <b>2.100</b> seconds.  The best result: 2,072 <br><br>  No, this is not a mistake and the comma is not confused anywhere.  Apparently, the thing is that since this is part of the standard library and in fact just a wrapper over the GNU zip S-shny, this gives an advantage in speed.  In other words, this is not compared to Python and Rust, but to C and Rust.  And C gets a little faster. <br><br>  <b>UPD</b> <br>  Python also has the ability to use FFI, so here is a small addition to this issue, at the request of <a href="https://habrahabr.ru/users/ynlvko/" class="user_link">ynlvko</a> . <br><br>  It was necessary to recompile the library under win32, since I have a 32-bit version of python: <br><br><pre> <code class="dos hljs">cargo build --release --target i686-pc-windows-msvc</code> </pre> <br>  Code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cdll lib = cdll.LoadLibrary(<span class="hljs-string"><span class="hljs-string">"adler32.dll"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5000000</span></span>): lib.adler(<span class="hljs-string"><span class="hljs-string">b'-    ,      '</span></span>)</code> </pre>  The average result of three starts: <b>6.398</b> seconds.  The best result: 6.393 <br>  That is, it turns out that the python FFI works several times more efficiently than node-ffi and even more efficiently than the ‚Äúnative‚Äù addons. <br><br><h4>  findings </h4><br><table><thead><tr><th>  Technology </th><th>  Average time, with </th><th>  The best time to </th></tr></thead><tbody><tr><td>  Node.js </td><td>  41,601 </td><td>  40,206 </td></tr><tr><td>  Node.js + ffi + Rust </td><td>  27,882 </td><td>  26,642 </td></tr><tr><td>  Node.js (sha1) </td><td>  9,737 </td><td>  9,321 </td></tr><tr><td>  Node.js + C ++ Rust </td><td>  7,802 </td><td>  7,658 </td></tr><tr><td>  Python + ffi + Rust </td><td>  6.398 </td><td>  6.393 </td></tr><tr><td>  Rusty </td><td>  2.314 </td><td>  2.309 </td></tr><tr><td>  C / Python (zlib) </td><td>  2,100 </td><td>  2,072 </td></tr></tbody></table></div><p>Source: <a href="https://habr.com/ru/post/323106/">https://habr.com/ru/post/323106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323092/index.html">Recreating subdatasheet in table on AngularJS</a></li>
<li><a href="../323094/index.html">Booking.com search architecture</a></li>
<li><a href="../323096/index.html">.Net Core, AppDomain, WCF, RPC marshalling TCP / Ip your bike</a></li>
<li><a href="../323100/index.html">IceCash 2.0 Web Workstation Cashier and AIS for exchanging data with cash registers for Linux to Python</a></li>
<li><a href="../323102/index.html">Another way to localize applications</a></li>
<li><a href="../323108/index.html">Two providers simultaneously or Dual ISP with VRF on Cisco | Part 2</a></li>
<li><a href="../323110/index.html">Protect a remote terminal server or two-factor authentication of RDG clients using Azure MFA</a></li>
<li><a href="../323112/index.html">OSSEC note on configuring parsers (decoders)</a></li>
<li><a href="../323114/index.html">Quadstor - a virtual SAN for state employees</a></li>
<li><a href="../323116/index.html">Solving Winter CrackMe Problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>