<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improve regular expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reading the book about regular expressions (hereinafter simply RV), I had some thoughts about their readability. When the RVs only appeared, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improve regular expressions</h1><div class="post__text post__text-html js-mediator-article">  After reading the book about regular expressions (hereinafter simply RV), I had some thoughts about their readability.  When the RVs only appeared, and there were quite a few symbols like \ d, \ w and the like, then everything was probably not so bad, although even then it was worth thinking about visibility.  Now reading code from PB is a silent horror.  No, if the PB is short, then there are no special problems, but as they become more complex and different brackets appear, everything becomes horrible.  The situation is aggravated by the fact that in some languages ‚Äã‚Äã(we will not point fingers) constantly have to double slashes. <br><br>  In addition, in the notation RV, which is now used in most programming languages, in some seemingly simple situations, you have to get out with the help of various tricks.  The first example that came to mind is to create a regular expression <i>if ‚Äúabc‚Äù, then NOT ‚Äúxyz‚Äù</i> . <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my opinion, it‚Äôs time to abandon the notation that is being used now and create a new one that will be closer to the usual programming language, because the RV notation is in fact a language, but the design is just awful.  The worst thing in today's notation is the abundance of parentheses like <i>(...)</i> , <i>(: ...)</i> , <i>(?: ...)</i> , <i>(? = ...)</i> , <i>(?! ...)</i> , <i>(? &lt;= ...)</i> , <i>(? &lt;! ...)</i> , <i>(? &lt;)</i> .  It is thanks to them that the expressions become confusing and it is impossible to cover all PB's views, to immediately say what it is looking for, and you have to check every character in a string, without forgetting, for example, that <i>^</i> in the middle of a PB is the beginning of a line, and at the beginning of square brackets <i>[ ^ ...]</i> is an inversion.  Well, it‚Äôs wrong that when a new opportunity arises, developers create a new designation, some <i>(&amp; ^% $ # @ ...)</i> , which in itself says absolutely nothing. <br><br>  After all, what is the beauty of conventional programming languages ‚Äã‚Äã(without taking any extreme cases)?  If we see an <i>if</i> or <i>while</i> operator in an unfamiliar language, then we can immediately say that it does about it.  Yes, you can replace these operators with symbols like @ # $% and # &amp; $ ^ respectively, you can even get used to them, but as stated in the anecdote about the lesson of the Russian language in Georgia, "you need to remember this, it is impossible to understand." <br><br>  Perhaps the situation could be improved by clever code editors, who in the regular expression would differently highlight the brackets <i>(?: ...)</i> , <i>(? = ...)</i> , etc., to immediately see the areas of their actions, but for Most programming languages ‚Äã‚Äãdo this almost impossible, since  PB there is a line and the editor would have to be able to determine from the content of the line what is in front of it: PB or plain text.  And anyway, with a big nesting of the RV brackets, it will turn into a multi-colored rainbow. <br><br>  Generally speaking, quite good changes in terms of readability of RVs have already occurred due to the appearance of regimes when RVs are recorded on several lines, as well as thanks to comments inside RVs.  There was even a construction with a clear view (? If ...), in Perl (it will not be mentioned by night) the program code can be embedded in a regular expression, and in .NET instead of a simple replacement by RV, the replaced value can be generated using <del>  specially trained </del>  special delegate.  In general, you can even write a more or less understandable RV, but still it‚Äôs not that, it‚Äôs more like crutches. <br><br>  It is time to create a language RV, similar to the other "human" programming languages, rather than Brainfuck.  Then it would be possible to organize a clear highlight, prompts a la IntelliSense, and in the future, perhaps, step-by-step debugging of the PB. <br><br>  Then I would like to show what I would like to see RV. <br><br>  First, they must somehow be separated RVs from ordinary strings.  It is clear that the functions for their work require exactly strings, I am not sure that RTs should be embedded in the languages ‚Äã‚Äãthemselves, as is done in Perl, even if they remain strings, but in order to somehow identify them inside quotes, you should use some additional notation.  This can be anything, for example, instead of <i>"\ d \ w"</i> (for clarity, I will not double slashes) you should use <i>"! \ D \ w!"</i>  or <i>"&lt;\ d \ w&gt;"</i> , then the editor can easily distinguish PBs from lines.  In the future, I will use the record "! ...!", But this is not important, like the other notation, the main thing is the essence. <br><br>  Secondly, RVs need to be written only in the mode when spaces and line breaks are ignored, and to separate literals inside the expression, which always remain the same from the constructions of the RVs themselves, you can put quotes in literals (no matter what).  For example, instead of <i>‚Äúabcd \ d \ wxyz‚Äù</i> you can write: <br><br><blockquote><code>"! 'abcd' <br> \d\w <br> 'xyz' <br> !" <br></code> </blockquote><br><br>  Or even "! 'Abcd' \ d \ w 'xyz'!" <br><br>  The code editor here can separately tint <i>abcd</i> and <i>xyz</i> .  It may be worth using the ‚Äú+‚Äù sign to link these pieces.  So it will even be clearer: <i>"! 'Abcd' + \ d \ w + 'xyz'!"</i>  because  separate parts of RVs are more visually separated. <br><br>  You may be confused by the fact that the "+" sign is now used in the meaning of "1 or more coincidences", but this is not terrible, because no one is going to use it anymore in this value.  This is not logical.  There are such visual constructions as {min, max}, let's use them together with the operator "*".  The operator "*" should be used just in the meaning of "multiply", that is, the expression <i>"! 'Abc' * 3!"</i>  means that the string 'abc' should repeat 3 times.  PB <i>"! 'Abc' * {1, 3}!"</i>  means that abc should repeat from 1 to 3 times.  Similarly, you can use the entry <i>"! 'Abc' * {1,}!"</i>  in the meaning of "1 or more matches" instead of "+", and instead of the operator "*" write: <i>"! 'abc' * {0,}!"</i>  .  And the entry <i>"! 'Abc' * {3, 3}!"</i>  equivalent to what we have already seen <i>"! 'abc' * 3!"</i>  .  The old operator "*" will then be replaced by the expression <i>"! 'Abc' * {,}!"</i>  . <br><br>  Perhaps instead of curly brackets it is worth using square or round ones, then it will be even closer to the mathematical record of segments and intervals. <br><br>  The question remains with how to denote the minimal operator "*" (it is not greedy).  It would be possible to use the division operator, but this is also not logical, therefore it can be written directly in the form of <i>"! 'Abc' min * 3!"</i>  .  Here <i>min *</i> is one operator without a space.  I don‚Äôt really like this version of the record, but at least he explains the essence with his name. <br><br>  Most brackets should be replaced with built-in functions.  For example, instead of "[abc]" you should write in the form "! Any (a, b, c)!", Then you can replace the expression <i>"(: abc) | (: xyz)"</i> with <i>"! Any (' abc ',' xyz ')! "</i>  and we can also get rid of the operator "|".  You can use PBs as function parameters, for example, <i>"! Any (\ d \ w, 'abc')!"</i>  . <br><br>  It is necessary to decide how to deal with the simplest expressions like \ w, \ b, \ d, etc.  On the one hand, they are quite compact, but, for example, I like the record, which can now be used in square brackets - [: alnum:].  For convenience, you can replace them with a record of the form _alnum_.  Or maybe the simplest \ d and \ w should be left as is.  And instead of ".", Which is not particularly visible in the text, you can use the record _any_.  The same spaces and tabs that are ignored in the expression itself can be written in the form of _space_, or simply put them in quotes. <br><br>  It is necessary to enter the normal <i>if - then - else</i> operator, the essence of which is that if the expression after the <i>if</i> is executed, then the RV is checked in the <i>then</i> branch, otherwise after the <i>else</i> branch.  I think that the word <i>then</i> can be omitted.  Then it will be possible to make such RV: <br><br><blockquote> <code>"! 'abc' <br> if (\w * 3) <br> { <br> 'xyz' <br> } <br> else <br> { <br> \d * {1, } 'klmn' <br> } <br> !" <br></code> </blockquote><br><br>  Here I used the syntax in C-like languages, but this is not critical.  Literally, this expression means: First comes the string 'abc', then the PB is checked '\ w * 3', if it is executed, then 'xyz' should go, otherwise at least one number should go, and then 'klmn'. <br><br>  It may even be worthwhile to introduce operators of type <i>case</i> , <i>while,</i> and <i>for</i> .  In addition, you must enter the logical operations AND, OR, NOT to use them in the condition.  Not sure about AND and OR, because the expression <i>"! If ('abc' &amp;&amp; 'xyz')!"</i>  is equivalent to <i>"! if ('abcxyz')!"</i>  , and <i>"! if ('abc' || 'xyz')!"</i>  - <i>"! If (any ('abc', 'xyz'))!"</i>  .  But the negation operator is needed precisely to determine what should not be in a given place. <br><br>  You need to enter a variable that indicates the position in the line where the search is currently being carried out (let‚Äôs be _pos_ variable), as well as a variable that stores the line itself, to which the PB is applied (_this_).  Then the operator "^" can be replaced by a more understandable <i>"! _Pos_ == 0!"</i>  , and "$" on <i>"! _pos_ == (strlen (_this_) - 1)!"</i>  It may be worthwhile to introduce a separate designation for the end of the line, for example, by analogy with Python: _pos_ == -1.  The same variables will allow for advanced and retrospective verification. <br><br>  Need to leave comments.  What they will look like is no longer important. <br><br>  The assignment operator should work in two modes.  The first is to check and assign a variable to the string corresponding to a regular expression, for which an entry like <i>"(? &lt;Foo&gt; ...)" is</i> now used: <i>"! Foo = \ w \ d *;!"</i>  .  Semicolons will have to be used to show where the assignment statement ends. <br><br>  The second assignment mode is to save the regular expression without checking it.  Used for clarity, for example, <br><br><blockquote> <code>"! <br> foo = !\d\w*! <br> <br> 'abc' foo 'xyz' foo <br> !" <br></code> </blockquote><br><br>  Here is the expression! \ D \ w *!  (note the exclamation marks) is then used by the variable name foo. <br><br>  These are the main ideas that have appeared on PB.  It would be interesting to try such expressions in action, but, unfortunately, my hands are unlikely to reach the implementation of such a parser.  In general, one could begin with the fact that such expressions were converted to the classical type of RV, and then processed by the finished library. <br><br>  Finally, a small example for finding a URL.  Perhaps, not everything is taken into account there, for example, it is believed that the domain zone can only be com, net, info or two-letter. <br><br><blockquote> <code>"! <br> unicode = !% any(\d, AF) * 2 ! //  Unicode  . <br> //   ,    <br> domain = !any ('com', 'net', 'info', (az) * {1, 2})! <br> host = !any (\w, '_', unicode)! <br> <br> "http://" (host '.') * {1,} domain '/' * {0, 1} <br> "! <br></code> </blockquote><br>  I hope that I was not mistaken anywhere, but even if I was wrong, it is not terrible, the main thing I wanted to show the essence. <br><br>  In conclusion, I will say once again that the main goal of all this was to figure out how to increase the readability of PB.  Of course, with this the amount of typed text will increase, but for large RTs it is worth it. </div><p>Source: <a href="https://habr.com/ru/post/62664/">https://habr.com/ru/post/62664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../62648/index.html">Floating anchors</a></li>
<li><a href="../62653/index.html">Russian javascript reference</a></li>
<li><a href="../62655/index.html">Programming Olympiad, view from NSU. Article 1 - drawing up tasks</a></li>
<li><a href="../62660/index.html">Jabber on your domain</a></li>
<li><a href="../62662/index.html">New features of PU VDS</a></li>
<li><a href="../62666/index.html">Antianalogue favorites in the list</a></li>
<li><a href="../62672/index.html">5 deadly sins manager</a></li>
<li><a href="../62678/index.html">repquota server loads - how to treat</a></li>
<li><a href="../62680/index.html">Bugreport on materials of preparation for the exam on computer science</a></li>
<li><a href="../62681/index.html">Uncovered ZFS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>