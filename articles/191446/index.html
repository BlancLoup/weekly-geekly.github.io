<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yandex.Disk client for Linux. Cantilevered</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we are introducing the long-awaited Yandex.Disk client for Linux. One could even say ‚Äúspecifically for Habrahabr,‚Äù since not a single mention of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yandex.Disk client for Linux. Cantilevered</h1><div class="post__text post__text-html js-mediator-article">  Today we are introducing the long-awaited Yandex.Disk client for Linux.  One could even say ‚Äúspecifically for Habrahabr,‚Äù since not a single mention of the Disk here could have done without questions about the client for Linux. <br><br>  It has all the basic functionality that clients have for OS X and Windows, and even more (symlinks!), And one feature - it is a console. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/191446/"><img src="https://habrastorage.org/getpro/habr/post_images/28a/700/118/28a700118ac5a37bfdc71dc693d337b4.png" alt="image"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Below you can read about how it is configured, what exactly it can do, and how exactly it works and what was difficult to do in it. <br><br><a name="habracut"></a><br>  You can install it <a href="http://repo.yandex.ru/yandex-disk/">here</a> .  Immediately after installing the package, the command <b>yandex-disk</b> will appear in the terminal, through which you will continue to communicate with the Yandex cloud.  After that, you need to manually run the <b>setup</b> command. <br><br>  The settings wizard allows you to select a folder for synchronization in the dialog mode, enable autorun at system startup, configure work through a proxy server (unless of course you use it) and log in to Yandex.Disk.  When you manually configure the first thing you need to log in.  After that, a config file will be created in the .config folder located in the home directory, where you can configure the path to the synchronization folder (you can specify it in the console manually), set the path to the token file, specify the folders that will or will not be synchronized, and register proxy settings. <br><br><h4>  Teams </h4><br>  The preparatory work is over, it remains to start the daemon of one of the teams.  They allow you to synchronize files and folders and use them wherever there is Internet. <br><br><ul><li>  <b>Sync</b> starts the daemon, synchronizes everything in the Disk folder, and stops the daemon. </li><li>  <b>Start</b> will do the same, but without stopping the daemon after synchronization is complete.  When using start, the daemon remains running and all changes occurring in the Disk folder will be synchronized automatically. </li><li>  Entering in the terminal <b>stop</b> , you can at any time stop the running daemon, if it bothers you. </li><li>  The <b>status</b> command <b>tells</b> you the status of the synchronization kernel. </li></ul><br>  You can work with the disk folder both from the terminal and from Nautilus. <br><br><h4>  What can </h4><br>  The console client allows you to share a file or folder using the <b>publish</b> command (if the file is not in the disk folder, it will be copied there before publication).  The link will be available in the terminal, and anyone passing on it will be able to see or save a file or folder published by you.  If you accidentally published the wrong file, you can close access to the public object using the <b>unpublish</b> command. <br><br>  In Yandex.Disk selective synchronization is possible.  The <b>exclude</b> command will allow you to exclude the folder from synchronization: all changes made to it after that will not be sent to the cloud. <br><br>  The <b>read-only</b> option will allow you to change files locally, without uploading them to the cloud.  If conflicts arise with local changes, the latter will be saved in the renamed files, and the changes from the cloud will be synchronized.  The <b>overwrite</b> option will overwrite locally modified files in read-only mode. <br><br>  We can not boast of the most interesting innovation in the core of synchronization - from now on, we support synchronization of symlinks!  If there are difficulties and questions in using the console client, the <b>man</b> and <b>help</b> commands will help you to understand them simply and easily. <br><br><h4>  How made </h4><br>  In order to use the code in the future to implement clients for different operating systems, it was decided to write it in C ++.  We rendered code-specific pieces of code into separate functions or classes, and wrote our own implementation for each platform.  We took <a href="http://www.boost.org/">Boost</a> , <a href="http://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a> and <a href="http://jsoncpp.sourceforge.net/">JsonCpp</a> as the main cross-platform libraries, and <a href="http://git-scm.com/">git</a> became the version control system.  The Linux client was built using <a href="http://en.wikipedia.org/wiki/Autoconf">autoconf</a> .  The code was written and debugged in a bunch of KDevelop + console gdb, or in Qt Creator (depending on the preferences of the developer). <br><br>  Interaction with the cloud and synchronization are performed using the Yandex.Disk core library, which is used by desktop clients of the service. <br><br><h4>  How does it work </h4><br>  A console client consists of two parts: a daemon and a client.  They communicate through text packets containing json messages sent via sockets (on Linux and Mac OS X, unix-domain sockets are used).  Asynchronous operation is implemented using the boost :: asio library.  Data access synchronization is implemented through boost :: asio :: io \ _service :: strand, which allows not to think about the problem of simultaneous access to data of several streams, and also eliminates the appearance of deadlocks. <br><br>  For localization, we use the library boost :: locale.  The text inside the client is encoded in utf-8 and, if necessary, is converted into code specific for each operating system.  Linux file system monitoring uses inotify, which fits perfectly with asynchronous work boost :: asio. <br><br><h4>  How synchronization works </h4><br>  Synchronization is the heart of Yandex.Disk, its key feature.  The task of synchronizing a file tree with a cloud is divided into several independent parts. <br><br>  <b>1</b> .  <u>File system monitoring</u> .  The Yandex.Disk sync engine was designed and created as a portable abstraction capable of performing tasks on all supported platforms.  But such a problem as file system monitoring is not implemented either by the standard C ++ library, or even by monsters such as boost.  Moreover, even using the native API of the operating system, we get a set of events specific to each platform. <br><br>  To monitor the file system, an ‚Äúobserver‚Äù interface was designed that can monitor events in a specific directory and return a list of events that occurred in it.  And for each supported platform, the set of these events is different.  For example, Mac OS X is able to report only the fact of some change in one of the child directories without detail.  But Windows and Linux return the full set, including the creation, deletion, modification and movement of objects.  Although practice has shown that events on the Windows platform should not be trusted and the most reliable option is listing the directory after receiving the alert. <br><br>  <b>2</b>  <u>Indexing local files and directories</u> .  To control the integrity and implementation of delta-update files, the Yandex.Disk synchronization kernel uses digests ‚Äî sets of checksums of the file and its individual parts.  For the entire file, we calculate the persistent <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256</a> hash and a set of less persistent amounts for individual blocks.  Each file located in the Yandex.Disk folder and not included in the list of exceptions must be indexed.  But calculating the SHA-256 hash is quite an expensive operation, and calculating hashes with each software launch would be an unforgivable waste of resources.  Therefore, after the file is indexed, the synchronization kernel stores the received digest in a ‚Äúbank‚Äù - a special storage located in the Yandex.Disk service directory.  To search for digests in the repository, a unique file identifier is used - inode (size and time of last change).  Unfortunately, this approach is not without flaws.  For example, many crypto-container files keep the last modification time unchanged even after recording. <br><br>  Probably, in addition to the subtleties of working with symbolic links, nothing in the listing of directories is of particular interest.  To successfully complete synchronization, the kernel must detect and exclude cyclic branches from synchronization. <br><br>  In general, symbolic links are a real ‚Äúheadache‚Äù for the sync kernel.  They can point to arbitrary locations in the file system, and not all of them can use the same sync rules.  For example, Mac OS X application packages very often contain symbolic links to system library directories, and their synchronization to the cloud would be undesirable - especially between different OS versions.  But at the same time, the ability to synchronize additional directories with the help of symbolic links is a very tempting opportunity, which we did not want to miss. <br><br>  Therefore, to synchronize symbolic links, a special policy was introduced, thanks to which the kernel can choose a specific synchronization option for each symbolic link, depending on the location of the object to which it points. <br><br>  <b>3</b>  <u>Obtaining the cloud file system tree</u> .  To solve the synchronization problem, it‚Äôs not enough to have a local file structure and file digests ‚Äî you need to get the current state of the file system in the cloud.  If the synchronization core had to bypass the tree each time using the <a href="">PROPFIND</a> method, then each synchronization cycle would take an unreasonably long time and create an unnecessary load on the channel.  Therefore, Yandex.Disk software uses a special API, which makes it possible to get the current state of the file tree in the cloud and the changes that have occurred in it, starting from a certain known point determined by the version of the tree. <br><br>  <b>4</b>  <u>Receive alerts for cloud file system changes</u> .  Real-time file synchronization requires timely notification of changes to files in the cloud.  It would be possible to use periodic polling of the server by clients, but, having estimated the possible number of clients, we came to the conclusion that such an approach would be poorly scalable and lead to a rapid overload of the service infrastructure.  After a brief search, we stopped at the XMPP protocol.  One of its implementations has long been working in Yandex.  It was developed by a team that later created the WebDAV server for the Yandex.Disk project, so there was no difficulty with integrating this protocol. <br><br>  Now push-notifications processed by the synchronization kernel include not only events that occurred directly with files or folders in the Yandex.Disk cloud, but also various service messages.  For example, about issuing additional space or actions of other users in public folders.  Adding these events to the existing protocol did not cause much difficulty due to the extensibility of XMPP, which once again confirmed the correctness of our choice. <br><br>  <b>5</b>  <u>Creating a list of synchronization operations</u> .  After the synchronization kernel has both file trees ‚Äî local and remote ‚Äî you can proceed to the synchronization procedure itself.  For this purpose, a special tree comparison algorithm is used, which accepts as an input, in addition to the two mentioned trees, also the third one - the last one synchronized.  As a result, the algorithm produces a list of operations that must be performed on local and remote files and directories in order to bring trees to a general view. <br><br>  <b>6</b>  <u>Processing a queue of synchronization operations</u> .  Creating a list of operations for local and remote trees occurs independently.  As a result, conflicting operations may appear.  For example, deleting a file in the cloud that was modified in it and not yet synchronized locally, or changing a file both locally and in the cloud.  Modification / deletion conflicts are always resolved by the kernel in favor of modification, and double modification conflicts are resolved by renaming one of the file versions.  In this way, we can guarantee the safety of the data and, after the synchronization is complete, let the user decide which of the changes is more suitable for him in each particular case. <br><br>  Synchronization operations must follow a strict order; you cannot transfer a file until its parent directory is created.  Also, the directory cannot be deleted as long as there are files inside it that need to be moved to a new location.  The tree comparison algorithm already creates operations in the correct order, but if errors occur it may be broken.  To prevent this situation, each operation has a list of dependencies - a set of operations that must be completed before the start of its execution, and a set of operations that should not start until it is executed. <br><br>  In addition to dependencies, the order of operations is influenced by its priority.  For example, file transfer operations are performed depending on file sizes, from small to large. <br><br>  All these tasks are performed simultaneously, imposing additional requirements on the quality of synchronization of parallel processes and the distribution of resources within the Yandex.Disk synchronization core.  If you do not already have Ya.Disk, you can start it <a href="http://disk.yandex.ru/">here</a> , and install it for Linux - here: <a href="http://repo.yandex.ru/yandex-disk">repo.yandex.ru/yandex-disk</a> . </div><p>Source: <a href="https://habr.com/ru/post/191446/">https://habr.com/ru/post/191446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191436/index.html">Automatic code generation in Yii</a></li>
<li><a href="../191438/index.html">Why is not everything normal with normal distribution</a></li>
<li><a href="../191440/index.html">Delegation</a></li>
<li><a href="../191442/index.html">Android - Live Wallpaper on OpenGL ES 2.0 with Simplified DOF Effect</a></li>
<li><a href="../191444/index.html">Acer Aspire R7 laptop video review</a></li>
<li><a href="../191448/index.html">Slightly anonymous</a></li>
<li><a href="../191450/index.html">The rise and fall of the novice phreaker</a></li>
<li><a href="../191452/index.html">Information and analytical system for monitoring and managing road safety</a></li>
<li><a href="../191454/index.html">Search for a substring. Knuth ‚Äì Morris-Pratt Algorithm</a></li>
<li><a href="../191456/index.html">The official position of the administration opensharing.org on the issue of blocking the resource Roskomnadzor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>