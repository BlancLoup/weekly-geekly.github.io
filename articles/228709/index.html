<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift Features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the framework of Mobile Camp Yandex, our colleague Denis Lebedev presented a report on the new programming language Swift. In his report, he touche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift Features</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/7a9/400/d1c7a9400b299447f388ffaa39af4984.png" align="left" width="128">  In the framework of Mobile Camp Yandex, our colleague <a href="http://tech.yandex.ru/people/452916/">Denis Lebedev</a> presented a report on the new programming language Swift.  In his report, he touched upon the features of interaction with Objective-C, spoke about the features of the language that seemed to him the most interesting.  And also about where to go on Github, and what repositories to look at in order to understand what can be done with Swift in the real world. <br><br>  Swift development began in 2010.  Engaged in her Chris Lattner.  Until 2013, the process was not very active.  Gradually more people were involved.  In 2013, Apple focused on developing this language.  Before the presentation at WWDC about Swift knew about 200 people.  Information about him was kept in the strictest confidence. <br><br><video>  http://video.yandex.ru/users/ya-events/view/2941/ </video><br><a name="habracut"></a><br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.slideshare.net/slideshow/embed_code/36372353&amp;xid=17259,15700023,15700186,15700191,15700253&amp;usg=ALkJrhj1WB9DEwQ0AyHXvsbHsqq97XzZQw" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div><br>  Swift is a multi-paradigm language.  It has OOP, you can try some functional things, although adherents of functional programming believe that Swift is not quite enough.  But, it seems to me that such a goal was not set, after all, it is a language for people, not for mathematicians.  You can write in procedural style, but I'm not sure that this is applicable for entire projects.  Very interesting in Swift everything is arranged with typing.  Unlike dynamic Objective-C, it is static.  There is also a type inference.  Those.  most variable type declarations can be simply omitted.  Well, the killer feature Swift can be considered a very deep interaction with Objective-C.  Later I will talk about runtime, but for now we‚Äôll restrict ourselves to the fact that the code from Swift can be used in Objective-C and vice versa.  Pointers familiar to all developers on Objective-C and C ++ in Swift are absent. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's pass to features.  There are a lot of them.  I singled out for myself a few basic ones. <br><ul><li>  <b>Namespacing.</b>  Everyone understands the problem of Objective-C - because of the two-letter and three-letter classes, name collisions often occur.  Swift solves this problem by introducing obvious and understandable names for all.  While they do not work, but everyone should be fixed for release. </li><li>  <b>Generic classes &amp; functions.</b>  For people who have written in C ++, this is quite an obvious thing, but for those who have come across mainly Objective-C, this is a fairly new feature that will be interesting to work with. </li><li>  <b>Named / default parameters.</b>  You won't surprise anyone with the named parameters, they already were in Objective-C.  But the default settings are a very useful thing.  When our method takes five arguments, three of which are set by default, the function call becomes much shorter. </li><li>  <b>Functions are first class citizens.</b>  Functions in Swift are first order objects.  This means that they can be passed to other methods as parameters, as well as returned from other methods. </li><li>  <b>Optional types.</b>  Optional types are an interesting concept that came to us in a slightly modified form from functional programming. </li></ul><br>  Consider the last feature in a little more detail.  We are all used to that in Objective-C, when we do not know what to return, we return nil for objects and -1 or NSNotFound for scalars.  Optional types solve this problem quite radically.  An optional type can be represented as a box that either contains a value or contains nothing.  And it works with any types.  Suppose we have the following signature: <br><br><pre><code class="hljs objectivec">(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>) indexOfObjec: (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object;</code> </pre> <br>  In Objective-C, it is unclear what the method returns.  If there is no object, then it can be -1, NSNotFound or some other constant known only to the developer.  If we consider the same method in Swift, we will see Int with a question mark: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexOF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object: AnyObject)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span></code> </pre><br>  This construct tells us that either the number or the void will return.  Accordingly, when we received the packed Int, we need to unpack it.  Unpacking can be of two types: safe (everything turns into if / else) and forced.  We can use the latter only if we know for sure that there will be values ‚Äã‚Äãin our imaginary box.  If it does not appear there, there will be a crash in rantayma. <br><br>  Now let's talk briefly about the main features of classes, structures and enumerations. The main difference between classes and structures is that they are passed by reference.  Structures are passed by value.  As the documentation tells us, using structures spends far less resources.  And all scalar types and Boolean variables are implemented through structures. <br><br>  Enumerations I would like to highlight separately.  They are completely different from their counterparts in C, Objective-C and other languages.  It is a combination of class, structure and even a bit more.  To show what I mean, consider an example.  Suppose I want to implement a tree using <code>enum</code> .  Let's start with a small listing with three elements (empty, node and sheet): <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span> }</code> </pre><br>  What to do with this is unclear.  But in Swift, each <code>enum</code> element can carry some value.  To do this, we add <code>Int</code> to the leaf, and the node will have two more trees: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Tree</span></span>, <span class="hljs-type"><span class="hljs-type">Tree</span></span>) }</code> </pre><br>  But since Swift supports generics, we will add support of any type to our tree: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-type"><span class="hljs-type">T</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Tree</span></span>, <span class="hljs-type"><span class="hljs-type">Tree</span></span>) }</code> </pre><br>  The tree declaration will look something like this: <br><br><pre> <code class="hljs dos">let <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>&lt;Int&gt; = .Node(.Leaf(<span class="hljs-number"><span class="hljs-number">1</span></span>), .Leaf(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre><br>  Here we see another cool feature: we can not write the names of enumerations, because Swift displays these types at the compilation stage. <br><br>  <code>enum</code> in Swift has another interesting feature: they can contain functions, just as in structures and classes.  Suppose I want to write a function that returns the depth of our tree. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Tree</span></span>, <span class="hljs-type"><span class="hljs-type">Tree</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depth</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: Tree&lt;T&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre><br>  What I don‚Äôt like about this function is that it takes a tree parameter.  I want to make the function just return values ‚Äã‚Äãto me, and I would not need to transfer anything.  Here we will use another interesting Swift feature: nested functions.  Since  there are no access modifiers yet - this is one of the ways to make the function private.  Accordingly, we have <code>_depth</code> , which will now count the depth of our tree. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_depth</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: Tree&lt;T&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _depth(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } }</code> </pre><br>  We see a standard switch, there is nothing sviftovogo here, just handle the option when the tree is empty.  Further interesting things begin.  We unpack the value that is stored in our list.  But since we do not need it, and we just want to return the unit, we use an underscore, which means that we do not need a variable in the sheet.  Next we unpack the knot from which we take the left and right parts.  Then we call the depth function recursively and return the result.  As a result, we get such a tree implemented on <code>enum</code> with some basic operation. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-type"><span class="hljs-type">T</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Tree</span></span>, <span class="hljs-type"><span class="hljs-type">Tree</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_depth</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: Tree&lt;T&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> t { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Empty</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(let_): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rhs): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(_depth(lhs), _depth(rhs)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _depth(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } }</code> </pre><br>  The interesting thing about this <code>enum</code> is that this code written by him should work, but it does not work.  In the current version, because of the <code>enum</code> bug, it does not support recursive types.  In the future, it will work.  For the time being, different hacks are used to bypass this bug.  I will tell about one of them a bit later. <br><br>  The next item in my story is collections, represented in the standard library by an array, dictionaries, and a string (enchantment collection).  Collections, like scalars, are structures, they are also interchangeable with standard foundation types such as NSDictionary and NSArray.  In addition, we see that, for some strange reason, there is no NSSet type.  Probably used too rarely.  Some operations (for example, <code>filter</code> and <code>reverse</code> ) have lazy calculations: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-function">&lt;S :Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(‚Ä¶)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">FilterSequenceView</span></span>&lt;<span class="hljs-type"><span class="hljs-type">S</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverce</span></span></span><span class="hljs-function">&lt;S :Collection ‚Ä¶&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: C)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ReverseView</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;</code> </pre><br>  Those.  <code>FilterSequenceView</code> and <code>ReverseView</code> types are not a processed collection, but its representation.  This tells us that these methods have high performance.  In the same Objective-C, such tricky constructions cannot be found, since at the time of the creation of this language no one had yet thought about such concepts.  Now lazy calculations penetrate programming languages.  I like this trend, sometimes it is very effective. <br><br>  The following feature was noticed, probably, by everyone who was somehow interested in the new language.  But I still tell you about it.  Swift has built-in variable immutability.  We can declare a variable in two ways: through <code>var</code> and <code>let</code> .  In the first case, the variables can be changed, in the second - not. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = <span class="hljs-number"><span class="hljs-number">3</span></span> b += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> a += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// error</span></span></code> </pre><br>  Here begins an interesting thing.  For example, if we look at a dictionary that is declared using the <code>let</code> directive, then when we try to change a key or add a new one, we will get an error. <br><br><pre> <code class="hljs lua">let d = [<span class="hljs-string"><span class="hljs-string">"key"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] d = [<span class="hljs-string"><span class="hljs-string">"key"</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> //<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> d.updateValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, forKey: <span class="hljs-string"><span class="hljs-string">"key1"</span></span>) //<span class="hljs-built_in"><span class="hljs-built_in">error</span></span></code> </pre><br>  Arrays are different.  We cannot increase the size of the array, but at the same time we can change any of its elements. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// success c.append(5) // fail</span></span></code> </pre><br>  In fact, it is very strange, when trying to figure out what was happening, it turned out that this was a bug confirmed by the developer of the language.  In the near future, it will be corrected, because  This is really a very strange behavior. <br><br>  Extensions in Swift are very similar to categories from Objective-C, but more penetrate the language.  In Swift, you do not need to write imports: we can write an extension anywhere in the code, and it will be picked up by absolutely all the code.  Accordingly, in the same way it is possible to expand structures and enams, which is also sometimes convenient.  With the help of extensions, you can structure the code very well, it is implemented in the standard library. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value : <span class="hljs-type"><span class="hljs-type">Int</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description : <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>} } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Foo, rhs: Foo)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.value == rhs.value }</code> </pre><br>  Next, let's talk about what in Swift is not.  I can not say that something concrete is missing for me, because  I haven't used it in production yet.  But there are things that many complain about. <br><ul><li>  <b>Preprocessor.</b>  It is clear that if there is no preprocessor, then there are no cool macros that generate a lot of code for us.  Cross-platform development is also hampered. </li><li>  <b>Exceptions.</b>  The mechanism is completely missing, but you can create an NSException, and the Objective-C runtime will handle all this. </li><li>  <b>Access control.</b>  After reading the Swift book, many were confused by the lack of access modifiers.  In Objective-C, this was not, everyone understood that it was necessary, and waited in the new language.  In fact, the developers simply did not have time to implement the beta access modifiers.  In the final release they will be. </li><li>  <b>KVO, KVC.</b>  For obvious reasons, there is no Key Value Observing and Key Value Coding.  Swift is a static language, and these are features of dynamic languages. </li><li>  <b>Compiler attributes.</b>  There are no compiler directives that report deprecated methods or whether there is a method on a specific platform. </li><li> <b><code>performSelector.</code></b>  This Swift method is completely mowed down.  This is a rather insecure thing and even in Objective-C you need to use it with caution. </li></ul><br>  Now let's talk about how Objective-C and Swift can interfere.  Everyone already knows that you can call Objective-C code from Swift.  In the opposite direction, everything works exactly the same, but with some limitations.  Enums, tuples, generic types do not work.  Although there are no pointers, CoreFoundation types can be called directly.  For many, the impossibility of calling C ++ code directly from Swift has become a frustration.  However, you can write wrappers in Objective-C and call them already.  Well, it is quite natural that it is impossible to subclass in Objective-C classes that are not implemented in it from Swift. <br><br>  As I said above, some types are interchangeable: <br><ul><li> <code>NSArray &lt; - &gt; Array;</code> </li> <li>  <code>NSDictionary &lt; - &gt; Dictionary</code> ; </li><li>  <code>NSNumber - &gt; Int, Double, Float</code> . </li></ul><br><br>  I will give an example of a class that is written in Swift, but can be used in Objective-C, you just need to add one directive: <br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (bar: String) { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre><br>  If we want a class in Objective-C to have a different name (for example, not <code>Foo</code> , but <code>objc_Foo</code> ), as well as change the method signature, everything becomes a bit more complicated: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@objc(objc_Foo)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc(initWithBar:)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (bar: String) { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre><br>  Accordingly, in Objective-C everything looks absolutely expected: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Foo</span></span> *foo = [[Foo alloc] initWithBar:@<span class="hljs-string"><span class="hljs-string">"Bar"</span></span>];</code> </pre><br>  Naturally, you can use all the standard frameworks.  For all headers, their representation on Swift is automatically generated.  Suppose we have a function <code>convertPoint</code> : <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)convertPoint:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)point toWindow:(<span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span> *)window</code> </pre><br>  It is fully converted to Swift with the only difference: there is an exclamation point near <code>UIWindow</code> .  This indicates the very optional type I mentioned above.  Those.  if there is nil, and we do not check it, there will be crash in runtime.  This is due to the fact that when the generator creates these headers, he does not know whether it can be nil or not, therefore he puts these exclamation marks everywhere.  Perhaps soon it will be corrected somehow. <br><br><pre> <code class="hljs objectivec">finc convertPoint(point: <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>, toWindow window: <span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span>!) -&gt; GCPoint</code> </pre><br>  In detail, it‚Äôs too early to talk about Swift's innards and performance, since it‚Äôs not known that it‚Äôs going to live from the current runtime to the first version.  Therefore, for now let's touch this topic only superficially.  To begin with, all Swift objects are Objective-C objects.  There is a new root class SwiftObject.  Methods are now stored not in classes, but in virtual tables.  Another interesting feature is that the types of variables are stored separately.  Therefore, it becomes a bit more difficult to decode classes on the fly.  For coding method metadata, an approach called name mangling is used.  For example, take a look at the <code>Foo</code> class with the <code>bar</code> method returning <code>Bool</code> : <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>  If we look at the binary, for the <code>bar</code> method we will see a signature of the following form: <code>_TFC9test3Foo3barfS0_FT_Sb</code> .  Here we have <code>Foo</code> with a length of 3 characters, the length of the method is also 3 characters, and <code>Sb</code> at the end means that the method returns <code>Bool</code> .  A not very pleasant thing is connected with this: debug logs in XCode all fall into exactly this form, so it‚Äôs not very convenient to read them. <br>  Probably everyone has already read about the fact that Swift is very slow.  By and large this is true, but let's try to figure it out.  If we compile with the <code>-O0</code> flag, i.e.  without any optimizations, Swift will be slower than C ++ 10 to 100 times.  If we compile with the <code>-O3</code> flag, we will get 10 times slower than C ++.  The <code>-Ofast</code> flag <code>-Ofast</code> not very secure, since it disables inta checking, etc., in runtime.  In production it is better not to use it.  However, it allows you to improve performance up to the C ++ level. <br>  You need to understand that the language is very young, it is still in beta.  In the future, the main problems with speed will be fixed.  In addition, the legacy of Objective-C stretches behind Swift, for example, in cycles there are a huge number of retainers and releases that are essentially not needed in Swift, but they slow down the speed very much. <br><br>  Then I will talk about things that are not very related to each other that I encountered during the development process.  As I said above, macros are not supported, so the only way to make a cross-platform view is as follows: <br><br><pre> <code class="hljs kotlin">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os(iOS) <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> View = UView #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> View = NSView #endif <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyControl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">View { }</span></span></span></span></code> </pre><br>  This <code>if</code> is not exactly a preprocessor, but simply a language construct that allows you to test the platform.  Accordingly, we have a method that returns us to what platform we are on.  Depending on this, we alias the <code>View</code> .  So we create <code>MyControl</code> , which will work on both iOS and OS X. <br><br>  The next feature - pattern matching - I really like.  I'm a little fond of functional languages, where it is used very widely.  Take for example the problem: we have a point on the plane, and we want to understand which of the four quadrants it is in.  We all imagine what that code would be in Objective-C.  For each quadrant, we will have such absolutely wild conditions, where we have to check whether x and y fall into these frames: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> point.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; point.<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; point.<span class="hljs-number"><span class="hljs-number">1</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; point.<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"I"</span></span>) } ...</code> </pre><br>  Swift us in this case gives us a few convenient pieces.  First, we have a tricky range-operator with three points.  Accordingly, the <code>case</code> can check whether the point falls into the first quadrant.  And the whole code will look something like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> point { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"Point is at the origin"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"I"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"II"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">0</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"III"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"IV"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know"</span></span>) }</code> </pre><br>  In my opinion, this is dozens of times more readable than what Objective-C can provide us. <br><br>  In Swift, there is another absolutely niche thing that also came from functional programming languages ‚Äã‚Äã- function currying: <br><br><pre> <code class="hljs pgsql">func <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>)(b: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } let foo = <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)(b: <span class="hljs-number"><span class="hljs-number">3</span></span>) // <span class="hljs-number"><span class="hljs-number">8</span></span> let add5 = <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) // (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> let bar = <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(b: <span class="hljs-number"><span class="hljs-number">3</span></span>) // <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  We see that we have a function <code>add</code> with such a tricky declaration: two pairs of brackets with parameters instead of one.  This gives us the opportunity to either call this function almost as usual and get the result of 8, or call it with one parameter.  In the second case, magic happens: at the output, we get a function that takes an <code>Int</code> and returns an <code>Int</code> too, i.e.  we partially applied our <code>add</code> function to the top five.  Accordingly, we can then use the <code>add5</code> function with a triple and get a figure eight. <br><br>  As I said, the preprocessor is missing, so even implementing <code>assert</code> is not a trivial thing.  Suppose we have a task to write some kind of <code>assert</code> .  We can check it for debag, but in order for the code that is not executed in the assertion, we must pass it as a closure.  Those.  we see that we have <code>5 % 2</code> in curly braces.  In Objective-C terminology, this is a block. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition:</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>, message: <span class="hljs-type"><span class="hljs-type">String</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">DEBUG</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !condition() { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(message) } #endif } <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>({<span class="hljs-number"><span class="hljs-number">5</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">"5 isn't an even number."</span></span>)</code> </pre><br>  It is clear that no one will use asses.  Therefore, there are automatic closures in Swift.  In the method declaration, we see <code>@autoclosure</code> , respectively, the first argument turns into a closure, and you can <code>@autoclosure</code> curly braces. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition: @auto_closure </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>, message: <span class="hljs-type"><span class="hljs-type">String</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">DEBUG</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !condition() { <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(message) } #endif } <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"5 isn't an even number."</span></span>)</code> </pre><br>  Another undocumented, but very useful thing is the explicit type conversion.  Swift is a typed language, so as in Objective-C we cannot stick objects with id-type.  Therefore, consider the following example.  Suppose I have a <code>Box</code> structure, which in gets at initialization some value that cannot be changed.  And we have a packed <code>Int</code> - unit. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Box&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _value : <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">: T</span></span></span><span class="hljs-function">)</span></span> { _value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> boxedInt = Box(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Box&lt;Int&gt;</span></span></code> </pre><br>  We also have a function that takes an <code>Int</code> as input.  Accordingly, we cannot transfer <code>boxedInt</code> there, since  the compiler will tell us that <code>Box</code> not converted to an <code>Int</code> .  The craftsmen slightly gutted the internal parts of the SWIFT and found a function that allows you to convert the <code>Box</code> type into a value that it hides in itself: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> <span class="hljs-type"><span class="hljs-type">Box</span></span> { @<span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span> Func __conversion() -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value } } foo(boxedInt) //success</code> </pre><br>  Static typing of the language also does not allow us to run around the class and replace methods, as could be done in Objective-C.  From what is now, we can only get a list of object properties and display their values ‚Äã‚Äãat the moment.  Those.  information about the methods we can not get. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"Apple"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { } } <span class="hljs-built_in"><span class="hljs-built_in">reflect</span></span>(<span class="hljs-type"><span class="hljs-type">Foo</span></span>()).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> <span class="hljs-comment"><span class="hljs-comment">// 2 reflect(Foo())[0].0 // "str" reflect(Foo())[0].1summary // "Apple"</span></span></code> </pre><br>  From the swift, you can directly call the C-code.  This feature is not reflected in the documentation, but may be useful. <br><br><pre> <code class="hljs objectivec">@asmname(<span class="hljs-string"><span class="hljs-string">"my_c_func"</span></span>) func my_c_func(<span class="hljs-built_in"><span class="hljs-built_in">UInt64</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CMutablePointer</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UInt64</span></span>&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CInt</span></span>;</code> </pre><br>  Swift, of course, is a compiled language, but this does not prevent it from supporting scripts.  First, there is an interactive runtime environment that is run with the <code>xcrun swift</code> command.  In addition, you can write scripts not in familiar scripting languages, but directly in Swift.  They are <code>xcrun -i 'file.swift'</code> using the <code>xcrun -i 'file.swift'</code> . <br><br>  Finally, I will talk about the repositories that are worth a look: <br><ul><li>  BDD Testing framework: <b><a href="https://github.com/modocache/Quick">Quick</a></b> .  This is the first thing that everyone lacked.  The framework is actively developing, new matchers are constantly being added. </li><li>  Reactive programming: <b><a href="https://github.com/jspahrsummers/RxSwift">RXSwift</a></b> .  This is a rethinking of ReactiveCocoa with the help of constructions provided by swift. </li><li>  Model mapping: <b><a href="https://github.com/jspahrsummers/Crust">Crust</a></b> .  Analog Mantle for Swift.  Allows you to map JSON objects to swift objects.  Used many interesting hacks that may be useful in development. </li><li>  Handy JSON processing: <b><a href="https://github.com/lingoer/SwiftyJSON">SwiftyJSON</a></b> .  This is a very small library, literally 200 lines.  But it demonstrates the power of transfers. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/228709/">https://habr.com/ru/post/228709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228695/index.html">Work as a game designer</a></li>
<li><a href="../228697/index.html">How I used a 3d scanner to forge a key, holding a skull, a heart and a gun in my hands</a></li>
<li><a href="../228699/index.html">From Moscow to Silicon Valley: how Alexander Kirov improves Pebble smart watches</a></li>
<li><a href="../228703/index.html">Habrachat quit ARM and now on Heroku</a></li>
<li><a href="../228707/index.html">Fast analogues of popular libraries for Python</a></li>
<li><a href="../228713/index.html">Server-based video encoding solution using integrated Intel HD Graphics video</a></li>
<li><a href="../228715/index.html">Microsoft buys UnityVS - Unity3D debugger for Visual Studio</a></li>
<li><a href="../228719/index.html">Load testing database. ContiPerf + DBUnit</a></li>
<li><a href="../228725/index.html">Veeam Technical Support Department</a></li>
<li><a href="../228729/index.html">How to hear electromagnetic waves</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>