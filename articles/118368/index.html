<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Singleton and object lifetime</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of my first article ‚ÄúUsing the Singleton Pattern‚Äù [0] . At first, I wanted to explain everything related to the life ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Singleton and object lifetime</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of my first article <a href="http://habrahabr.ru/blogs/cpp/116577/">‚ÄúUsing the Singleton Pattern‚Äù [0]</a> .  At first, I wanted to explain everything related to the life time in this article, but the volume of material turned out to be great, so I decided to break it up into several parts.  This is a continuation of a whole cycle of articles on the use of various templates and techniques.  This article is devoted to the lifetime and development of using singleton.  Before reading the second article, it is strongly recommended that you read <a href="http://habrahabr.ru/blogs/cpp/116577/">my first article [0]</a> . <br><br>  The previous article used the following implementation for a singleton: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre> <br><br>  The single function returned us the cherished singleton.  However, this approach has a flaw: in this case we do not control the lifetime of the object and it can retire at the moment when we want to use this object.  Therefore, you should use another mechanism for creating an object using the operator new. <br><a name="habracut"></a><br>  It so happens that in C ++ there is no garbage collector, so you need to follow the creation and destruction of the object.  And although this problem has long been known and even clear methods for how to solve it, this kind of error is not a rare guest in our programs.  In general, the following types of errors that programmers make are: <br><ol><li>  Memory usage for not created object. </li><li>  Memory usage of already deleted object. </li><li>  Non-release of the memory occupied by the object. </li></ol><br>  As a result of such errors, the program either starts ‚Äúflowing‚Äù, starts to behave unpredictably, or simply ‚Äúfalls‚Äù.  You can, of course, talk about what is worse, but one thing is clear: such errors are quite serious. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using the example of a singleton, one can easily show how such errors are made.  Open the <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia article [1]</a> and find the implementation for C ++: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnlyOne</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OnlyOne* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(theSingleInstance==<span class="hljs-number"><span class="hljs-number">0</span></span>) theSingleInstance=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnlyOne; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> theSingleInstance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> OnlyOne* theSingleInstance; OnlyOne(){}; }; OnlyOne* OnlyOne::theSingleInstance=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  It can be seen that memory is allocated for a singleton, but for some reason it is not released.  You can, of course, say that for a singleton, this is not a serious problem, since its lifetime coincides with the running time of the program.  However, there are some but: <br><ol><li>  Memory leak detection programs will show these leaks all the time for singletons. </li><li>  A singleton can be a rather complicated object, serving an open configuration file, connection to a database, and so on.  Improper destruction of such objects can cause problems. </li><li>  It all starts small: first, we do not follow the memory for singletons, and then for other objects. </li><li>  And the main question: why do wrong, if you can do right? </li></ol><br>  You can, of course, say that these arguments are irrelevant.  However, let's still do it right.  I always use the following principle for working with objects: the <b>created object must be destroyed</b> .  And it does not matter whether it is singleton or not, this is a general rule without exceptions, which sets a certain quality of the program. <br><br>  Analyzing the source code of various software products, I highlighted 2 more important rules for myself: <br><ol><li>  Do not use new. </li><li>  Do not use delete. </li></ol><br>  Here it is worth explaining a little what I mean.  It is clear that somewhere, new and delete will be called anyway.  Speech about the fact that it should be strictly in one place, it is better in one class, so that it does not spray on the program.  Then, with the proper organization of this class, it will not be necessary to monitor the lifetime of objects.  And I will immediately say that this is possible!  It should immediately make a reservation that I have never met such an approach.  So we will be some kind of pioneers. <br><br><h4>  Smart pointers </h4><br>  Fortunately, in C ++ there is a wonderful tool called smart pointer.  Their intelligence lies in the fact that, although they behave like ordinary pointers, they control the lifetime of objects.  To do this, they use a counter that automatically counts the number of references to the object.  When the counter reaches zero, the object is automatically destroyed.  We will use a smart pointer from the standard library std :: shared_ptr memory header file.  It is worth noting that such a class is available for modern compilers that support the C ++ 0x standard.  For those using the old compiler, you can use boost :: shared_ptr.  Their interfaces are absolutely identical. <br><br>  We assign the following responsibilities to our class An: <br><ol><li>  Control the lifetime of objects using smart pointers. </li><li>  Creating instances, including derived classes, without using new operators in the calling code. </li></ol><br><br>  The following implementation satisfies these conditions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class">;</span></span> An() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; An(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> An&lt;U&gt;&amp; a) : data(a.data) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; An(An&lt;U&gt;&amp;&amp; a) : data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a.data)) {} T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ data.reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data) reinit(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ anFill(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create&lt;T&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-function">U&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ U* u = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> U; data.reset(u); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *u; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u)</span></span></span><span class="hljs-function"> </span></span>{ anProduce(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, u); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> An&lt;U&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ data.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> U(*a.data)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;An*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.get(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; data; };</code> </pre><br><br>  It is worthwhile to dwell upon the proposed implementation: <br><ol><li>  The constructor uses the <a href="http://en.wikipedia.org/wiki/C%252B%252B0x">move-semantics [6]</a> of the C ++ 0x standard to increase speed when copying. </li><li>  The <b>create</b> method creates an object of the required class; by default, an object of class T is created. </li><li>  The <b>produce</b> method creates an object depending on the value received.  The purpose of this method will be described later. </li><li>  The <b>copy</b> method makes a deep copy of the class.  It should be noted that for copying it is necessary to specify the type of a real class instance as a parameter, the base type is not suitable. </li></ol><br><br>  In this case, the singleton will be rewritten as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnAutoCreate</span></span></span><span class="hljs-class"> :</span></span> An&lt;T&gt; { AnAutoCreate() { create(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; An&lt;T&gt; anSingle() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single&lt;AnAutoCreate&lt;T&gt;&gt;(); }</code> </pre><br><br>  Auxiliary macros will be as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PROTO_IFACE(D_iface, D_an) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; void anFill&lt;D_iface&gt;(An&lt;D_iface&gt;&amp; D_an) #define DECLARE_IMPL(D_iface) \ PROTO_IFACE(D_iface, a); #define BIND_TO_IMPL(D_iface, D_impl) \ PROTO_IFACE(D_iface, a) { a.create&lt;D_impl&gt;(); } #define BIND_TO_SELF(D_impl) \ BIND_TO_IMPL(D_impl, D_impl) #define BIND_TO_IMPL_SINGLE(D_iface, D_impl) \ PROTO_IFACE(D_iface, a) { a = anSingle&lt;D_impl&gt;(); } #define BIND_TO_SELF_SINGLE(D_impl) \ BIND_TO_IMPL_SINGLE(D_impl, D_impl) #define BIND_TO_IFACE(D_iface, D_ifaceFrom) \ PROTO_IFACE(D_iface, a) { anFill&lt;D_ifaceFrom&gt;(a); } #define BIND_TO_PROTOTYPE(D_iface, D_prototype) \ PROTO_IFACE(D_iface, a) { a.copy(anSingle&lt;D_prototype&gt;()); }</span></span></span></span></code> </pre><br><br>  The macro BIND_TO_IMPL_SINGLE, which now uses the anSingle function instead of the single function, which in turn returns an already filled An instance, has undergone some changes.  I will tell about other macros later. <br><br><h4>  Use singleton </h4><br>  Now consider the use of the described class to implement a singleton: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header file struct X { X() { x = 1; } int x; }; //    DECLARE_IMPL(X) // cpp file struct Y : X { Y() { x = 2; } int y; }; //   X   Y   BIND_TO_IMPL_SINGLE(X, Y)</span></span></code> </pre><br><br>  Now it can be used as follows: <br><pre> <code class="cpp hljs">An&lt;X&gt; x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x-&gt;x &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  That on the screen will give figure 2, since  class Y was used for implementation. <br><br><h4>  Lifetime control </h4><br>  Consider now an example that shows the importance of using smart pointers for singletons.  To do this, analyze the following code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; a = <span class="hljs-number"><span class="hljs-number">1</span></span>; } ~A() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~A"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; a = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> B() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ~B() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~B"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; out(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; single&lt;A&gt;().a &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br><br>  Now let's see what is displayed on the out call: <br><pre> <code class="cpp hljs">single&lt;B&gt;().out(); <span class="hljs-comment"><span class="hljs-comment">//    B A 1 ~A ~B -1</span></span></code> </pre><br>  We will understand what is happening here.  At the very beginning we say that we want an implementation of class B taken from a singleton, so a class B is created. Then we call the function out, which takes the implementation of class A from the singleton and takes the value a.  The value a is set in the constructor A, therefore the figure 1 will appear on the screen. Now the program finishes its work.  Objects begin to be destroyed in reverse order, i.e.  first the class A created last is destroyed, and then class B is destroyed. When class B is destroyed, we again call out function out of the singlton, but since  if object A is already destroyed, then we see -1 on the screen.  Generally speaking, the program could crash, because  we use the memory of an already destroyed object.  Thus, this implementation shows that without control of the lifetime, the program can safely fall off at the close. <br><br>  Let's now see how you can do the same, but with the control of the lifetime of objects.  For this we will use our class An: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; a = <span class="hljs-number"><span class="hljs-number">1</span></span>; } ~A() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~A"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; a = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; }; <span class="hljs-comment"><span class="hljs-comment">//   A      BIND_TO_SELF_SINGLE(A) struct B { An&lt;A&gt; a; B() { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } ~B() { std::cout &lt;&lt; "~B" &lt;&lt; std::endl; out(); } void out() { std::cout &lt;&lt; a-&gt;a &lt;&lt; std::endl; } }; //   B      BIND_TO_SELF_SINGLE(B) //  An&lt;B&gt; b; b-&gt;out();</span></span></code> </pre><br><br>  This code is practically no different from the previous one, except for the following important details: <br><ol><li>  Objects A and B use the class An for singletons. </li><li>  Class B explicitly declares a dependency on class A, using the corresponding public member of the class (for more details on this approach, see the previous article). </li></ol><br><br>  Let's see what is now displayed on the screen: <br><pre> <code class="cpp hljs">B A <span class="hljs-number"><span class="hljs-number">1</span></span> ~B <span class="hljs-number"><span class="hljs-number">1</span></span> ~A</code> </pre><br>  As you can see, now we have extended the lifetime of class A and changed the sequence of the destruction of objects.  The absence of the value -1 indicates that the object existed while accessing its data. <br><br><h4>  Total </h4><br>  In this first part of the article, devoted to the lifetime of objects, came to an end.  In the next part (or parts), the rest generating design patterns will be analyzed using the developed functionality and general conclusions will be made. <br><br><h4>  PS </h4><br>  Many people ask, but what is the meaning of it?  Why not just make a singleton?  Why use any additional constructions that do not add clarity, but only complicate the code.  In principle, with careful reading of the <a href="http://habrahabr.ru/blogs/cpp/116577/">first article [0]</a> , it is already possible to understand that this approach is more flexible and eliminates a number of significant shortcomings of the singleton.  In the next article it will be clear why I wrote it this way, because  it will already be a question of not only singlton.  And through the article it will be generally clear that Singleton has absolutely nothing to do with it.  All I'm trying to show is using the <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion principle [4]</a> (see also <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">The Principles of OOD [5]</a> ).  Actually, it was after I first saw this approach in Java that I felt hurt that in C ++ this is hardly used (in principle, there are frameworks that provide similar functionality, but I would like something more lightweight and practical).  This implementation is only a small step in this direction, which already brings great benefits. <br><br>  I would also like to note a few things that distinguish the given implementation from the classic singleton (generally speaking, these are consequences, but they are important): <br><ol><li>  The class describing a singleton can be used in several instances without any restrictions. </li><li>  A singleton is implicitly poured through the anFill function, which controls the number of instances of an object, and you can use a specific implementation instead of a singleton if necessary (shown in the <a href="http://habrahabr.ru/blogs/cpp/116577/">first article [0]</a> ). </li><li>  There is a clear separation: the class interface, the implementation, the connection between the interface and the implementation.  Everyone solves only their problem. </li><li>  Explicit description of dependencies on singletons, including this dependency in class contract. </li></ol><br><br><h4>  Update </h4><br>  After reading the comments, I realized that there are some points that should be clarified, because  many are not familiar with dependency inversion principle (DIP or inversion of control, IoC).  Consider the following example: we have a database that contains the information we need, such as a list of users: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDatabase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDatabase() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beginTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ... };</code> </pre><br>  We have a class that gives us the information we need, including the necessary user: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserManager</span></span></span><span class="hljs-class"> {</span></span> An&lt;IDatabase&gt; aDatabase; <span class="hljs-function"><span class="hljs-function">User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId)</span></span></span><span class="hljs-function"> </span></span>{ aDatabase-&gt;beginTransaction(); ... } };</code> </pre><br>  Here we create a member of aDatabase, which says that it needs some kind of database.  He does not care to know what it will be for the database, he does not need to know who and when it will fill / fill.  But the UserManager class knows that it will be flooded with what it needs.  All he says is: ‚Äúgive me the right implementation, I don't know which one, and I will do everything you need from this database, for example, I will provide the necessary information about the user from this database‚Äù. <br><br>  Now we do a clever trick.  Since we have only one database that contains all of our information, we say: ok, since there is only one database, let's make a singleton, and in order not to steam every time we fill in the implementation, we‚Äôll make it so that the singleton is poured : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDatabase</span></span></span><span class="hljs-class"> :</span></span> IDatabase { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beginTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... }; BIND_TO_IMPL_SINGLE(IDatabase, MyDatabase)</code> </pre><br>  Those.  we create the MyDatabase implementation and say that we will use it for the singleton using the BIND_TO_IMPL_SINGLE macro.  Then the following code will automatically use MyDatabase: <br><pre> <code class="cpp hljs">UserManager manager; User user = manager.getUser(userId);</code> </pre><br>  Over time, it turned out that we have another database in which there are also users, but, let's say, for another organization: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherDatabase</span></span></span><span class="hljs-class"> :</span></span> IDatabase { ... };</code> </pre><br>  Of course, we want to use our UserManager, but with a different database.  No problems: <br><pre> <code class="cpp hljs">UserManager manager; manager.aDatabase = anSingle&lt;AnotherDatabase&gt;(); User user = manager.getUser(userId);</code> </pre><br>  And as if by magic, now we take a user from another database!  This is a rather crude example, but it clearly shows the principle of addressing dependencies: this is when the IDatabase implementation is poured into the UserManager object instead of the traditional approach, when the UserManager itself searches for the necessary implementation.  In the article under review, this principle is used, with the singleton being taken for implementation as a <b>special case</b> . <br><br><h4>  Literature </h4><br>  [0] <a href="http://habrahabr.ru/blogs/cpp/116577/">Use pattern singleton</a> <br>  [1] <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia: Singleton</a> <br>  [2] <a href="http://insidecpp.ru/patterns/singleton">Inside C ++: Singleton</a> <br>  [3] <a href="http://andrey.moveax.ru/post/patterns-oop-creational-singleton.aspx">Generating patterns: Singleton</a> <br>  [4] <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion principle</a> <br>  [5] <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">The Principles of OOD</a> <br>  [6] <a href="http://en.wikipedia.org/wiki/C%252B%252B0x">Wikipedia: Rvalue reference and move semantics</a> </div><p>Source: <a href="https://habr.com/ru/post/118368/">https://habr.com/ru/post/118368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118358/index.html">Google Talk with video and voice chat</a></li>
<li><a href="../118363/index.html">Variables in Photoshop or how to import external PSD files into easy</a></li>
<li><a href="../118364/index.html">Opera in Belarus</a></li>
<li><a href="../118365/index.html">FbBusiness - First Facebook Business Center</a></li>
<li><a href="../118367/index.html">Nokia Ovi Browser application overview</a></li>
<li><a href="../118369/index.html">Unsafe PHP Speedy Suspended Project for Wordpress</a></li>
<li><a href="../118371/index.html">How to tame clouds: examples of practical use. Cloud issues</a></li>
<li><a href="../118373/index.html">How to tame clouds: examples of practical use. First phoned</a></li>
<li><a href="../118374/index.html">Russian remote presence robot is a reality</a></li>
<li><a href="../118376/index.html">Google Docs for Android - UI Template Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>