<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What every C programmer should know about Undefined Behavior. Part 3/3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 2 
 Part 3 

 In the first part of the cycle, we looked at unspecified behavior in C and showed some cases that allow us to make C faste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What every C programmer should know about Undefined Behavior. Part 3/3</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/341048/">Part 1</a> <br>  <a href="https://habrahabr.ru/post/341144/">Part 2</a> <br>  <b>Part 3</b> <br><br>  In the first part of the cycle, we looked at unspecified behavior in C and showed some cases that allow us to make C faster than ‚Äúsafe‚Äù languages.  In Part 2, we looked at some unexpected bugs that could contradict the ideas of many C programmers about the C language. In this part, we look at the problems that the Clang compiler solves in order to achieve high performance and eliminate some surprises. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/4g/nu/za4gnunircwzjpvmibn-vkoxbh8.jpeg" alt="image"></div><a name="habracut"></a><br><h3>  Why is a warning not issued that optimization is done based on UB? </h3><br>  People often ask why the compiler does not generate warnings when it optimizes based on unspecified behavior, because each such case can be caused by a bug in the user code.  The difficulties in this approach are as follows: 1) too many warnings will be generated to be useful - because these optimizations occur all the time, and in the absence of bugs, 2) it is really difficult to generate such warnings only when people want them, 3) several consecutive optimizations unite together.  Consider each item in more detail: <br><br><h3>  It‚Äôs very hard to make warnings really helpful. </h3><br>  Consider an example: although the bugs associated with incorrect type conversion often manifest themselves in TBBA (type based alias analysis), it will not be useful to generate messages like ‚Äúthe optimizer assumes that P and P [i] are not aliases‚Äù when optimizing the example "Zero_array" (from part 1 of the cycle). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *P; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; ++i) P[i] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br>  In addition to the problem of ‚Äúfalse positives,‚Äù there is a logistical problem, which is that the optimizer does not have enough information to generate meaningful warnings. <br><br>  Firstly, it works on the basis of the abstract code representation (LLVM IR), which is completely different from C, and secondly, the compiler has many layers, and at the point where the optimizer tries to bring reading from P beyond the bounds of the loop, it does not know about the analysis of TBAA.  This is a really difficult problem. <br><br>  It is difficult to generate such warnings only because people want it. <br><br>  Clang implements various warnings for simple and obvious cases of undefined behavior, such as going beyond the limits of a shift operation of type "x &lt;&lt; 421".  You may think that this is a simple and obvious thing, but it turns out to be difficult because people do not want to receive warnings about UB in a ‚Äúdead code‚Äù. <br><br>  The dead code has several forms, it can be, for example, macros that unfold in such a strange way when they are given a constant.  There may be a situation when in the switch construction some variants (provably) are not executed, and the user will be dissatisfied if we issue warnings about the code located in these places.  In addition, switch statements in C programs are not necessarily well structured. <br><br>  The solution is that Clang collects warnings about runtime behavior, and then removes those that belong to blocks that will not be executed.  The difficulty here is that there are idioms that we don‚Äôt expect, and doing such things in the front end means that we don‚Äôt catch every case that users want us to catch. <br><br><h3>  Sequences of optimizations open up opportunities for new optimizations. </h3><br>  If the frontend is so hard to generate warnings, perhaps we can generate them from the optimizer!  The biggest problem in generating useful messages is tracking the data.  The compiler optimizer includes dozens of optimization passes, each of which changes the code, making it (we hope) faster.  If the inliner decides to inline a function, this can open up new possibilities in order to remove, for example, expressions like "X * 2/2". <br><br>  Although we are concerned with simple and limited examples to demonstrate such optimizations, most real-world cases occur in code that was formed when macros were deployed, inline functions, and other actions to remove high-level abstractions that the compiler takes.  The reality is that people usually do not write stupid things directly.  For warnings, this means that in order to refer to user code, you need to exactly reconstruct how the compiler received the intermediate code.  We would need the opportunity to say something like this: <br><br>  <i>warning: after three levels of inline functions (possibly located in different files with Link Time Optimization), deleting common subexpressions, removing them from the loop, and proving that these 13 pointers are not aliases, we found a place where you do something unspecified .</i>  <i>This may be because of a bug in your code, or because of a macro, or because of an inline, and the wrong code is actually unavailable, but we cannot prove that it is dead.</i> <br><br>  Unfortunately, we do not have the infrastructure to track this, and even if it were, the compiler does not have a user interface good enough to tell all this to the programmer. <br><br>  In general, UB is valuable to the optimizer in that it says: ‚Äúthe operation is incorrect - it can be assumed that it will never happen.‚Äù  In the case of "* P", this gives the optimizer a reason to believe that P is not invalid NULL.  In the case of "* NULL" (for example, after substitution of constants and inline), this allows the optimizer to assume that such code is not reachable.  An important assumption is that, since the stop problem cannot be solved, the compiler cannot know that the code is actually dead (as it should be according to the C standard) or is a bug resulting from a (possibly long) series of optimizations.  Since there is generally no good way to distinguish between these two things, almost all of these warnings will be a false-positive noise. <br><br><h3>  Clang's approach to UB </h3><br>  Given the sad state of UB, you can ask what Clang and LLVM are doing to remedy the situation.  I already mentioned a couple of things: Clang Static Analyzer, Klee and the -fcatch-undefined-behavior flag are useful tools for tracking some classes of such bugs.  The problem is that they are not as widely used as the compiler, and all that we can do right in the compiler will be a much greater boon than what is done by individual tools.  Remember that the compiler is limited and has no dynamic information, and is also limited by the fact that it can not spend too much time when compiling. <br><br>  The first step of Clang to improve the code is to include more warnings by default than other compilers.  Although some developers are disciplined and compile with "-Wall-Wextra" (for example), many do not know about these flags or do not bother to turn them on.  By including more warnings by default, we catch more bugs. <br><br>  The second step is that Clang generates warnings for many classes of undefined behavior (including zero dereferencing, shifts that are too large, etc.), which allows you to catch common errors in the code.  The above are different <br><br>  The third step is that the LLVM optimizer has much less freedom regarding UB than it could.  Although the standard says that any instance of indefinite behavior can have an unlimited effect, it would not be friendly behavior in relation to the developer to benefit from it.  Instead, the LLVM optimizer processes them in several different ways (links are given to the rules of LLVM IR, not C, unfortunately): <br><br>  1. Some cases of indefinite behavior are simply converted to operations that cause an exception.  For example, Clang for this C ++ function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[x]; }</code> </pre> <br>  compiles the following X86-64 code: <br><br><pre> <code class="cpp hljs">__Z3fool: movl $<span class="hljs-number"><span class="hljs-number">4</span></span>, %ecx movq %rdi, %rax mulq %rcx movq $<span class="hljs-number"><span class="hljs-number">-1</span></span>, %rdi # Set the size to <span class="hljs-number"><span class="hljs-number">-1</span></span> on overflow cmovnoq %rax, %rdi # Which causes <span class="hljs-string"><span class="hljs-string">'new'</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc jmp __Znam</code> </pre> <br>  instead of the code that GCC generates: <br><br><pre> <code class="cpp hljs">__Z3fool: salq $<span class="hljs-number"><span class="hljs-number">2</span></span>, %rdi jmp __Znam # Security bug on overflow!</code> </pre> <br>  The difference is that we decide to spend several cycles on preventing a potentially serious bug from overflowing an integer number, which can lead to buffer overflow and vulnerability (the new operator itself is expensive, so the extra commands are almost imperceptible).  GCC developers have been aware of this vulnerability since at least 2005, but have not fixed it at the time of this writing.  ( <i>Vulnerability resolved in GCC 4.8.1 and higher. approx. transl.</i> ) <br><br>  Arithmetic operations on undefined values ‚Äã‚Äãcan produce undefined values ‚Äã‚Äãinstead of indefinite behavior.  The difference is that an undefined value cannot format your hard drive, or lead to other unwanted effects.  A positive effect occurs when an arithmetic expression leads to the same result for any possible variant of an undefined value.  For example, the optimizer assumes that the ‚Äúundef &amp; 1‚Äù result has zeros in the high-order bits, leaving only the low-order bit undefined.  This means that ((undef &amp; 1) &gt;&gt; 1) will be equal to 0 in the LLVM, and will not be an undefined value. <br><br>  Arithmetic expressions that dynamically perform unspecified operations (such as overflowing a signed integer) generate a ‚Äúlogical trap‚Äù (poison trap) that ‚Äúpoison‚Äù any calculations in which it is used, but does not destroy the rest of the program.  This means that downstream logical operations from an undefined operation may be affected, but not the rest of the program.  This is the reason why the optimizer does not remove the code that performs operations on uninitialized variables.  Writing to null and calling the function at the null pointer turns into a call to __builtin_trap () (which, in turn, turns into a call to the ‚Äúud2‚Äù instruction on x86).  This happens all the time in optimized code (as a result of other transformations, such as inline functions and the distribution of constants).  and we remove the blocks containing such commands, because they are obviously unreachable. <br><br>  If (from the point of view of pedantic execution of standards) they are really unattainable, in reality we understand that people sometimes dereference null-pointers, which causes code execution to fall in subsequent functions and makes it very difficult to understand the problem.  In terms of speed, the most important aspect here is the compression of the subsequent code.  Therefore, clang turns undefined operations into a runtime trap: if one of them is dynamically reached, the program will immediately stop and can be debugged.  The disadvantage here is a slight swelling of the code due to these operations and the conditions governing their predicates. <br><br>  The optimizer makes some efforts to ‚Äúdo it right‚Äù in cases where it is obvious what the programmer meant (for example, in the code "* (int *) P", where P indicates float).  This helps in many cases, but you really shouldn't rely on it, and there are many examples of which you may think that they are ‚Äúobvious‚Äù, but they are not so after a long series of transformations applied to your code. <br><br>  Optimizations that do not fall into any of these categories, such as in the examples zero_array and set / call from part 1, are optimized as described, ‚Äúsilently‚Äù, without messages to the user.  We do this because there is nothing useful that can be reported, and it is very unusual for a (booted) code of a real application, if these optimizations break it. <br><br>  One of the main areas of improvement that we can do comes at the expense of such ‚Äútraps‚Äù.  I think it would be interesting to add (turned off by default) a warning flag that will cause the optimizer to make warnings when it inserts traps.  This will give a lot of ‚Äúnoise‚Äù for some sources, but it will be useful for others.  The first limiting factor here is that the operation of the infrastructure will force the optimizer to issue warnings: they will not have useful locations in the source code if the debugging information is disabled (but this can be fixed). <br><br>  Another more significant limiting factor is that these warnings will not have any tracking information that would help explain that this operation was the result of deploying the loop three times and inline four levels of function calls.  The best we can do is specify a file / row / column, which will be useful in most trivial cases, but will be very confusing in other cases.  In any case, the implementation of this is not a priority for us because: a) it is unlikely to give a good experience b) we will not make this feature enabled by default and c) a lot of work will be required to implement it. <br><br><h3>  Use safe C dialect (and other options) </h3><br>  The last option you have, if you do not need maximum performance, is to use different compiler flags in order to use C dialect, which eliminates undefined behavior.  For example, using the -fwrapv flag eliminates ambiguous behavior resulting from overflow of signed numbers (however, we note that this does not eliminate possible vulnerabilities and security holes related to overflow of signed numbers).  The -fno-strict-aliasing flag disables Type Based Alias ‚Äã‚ÄãAnalysis, and you can ignore these rules for types.  If necessary, we can add a flag to Clang, which by default will reset all local variables, a flag that inserts an ‚Äúand‚Äù operation before each shift with a variable shift value, etc.  Unfortunately, there is no way to completely get rid of the indefinite behavior in C, without breaking the ABI and completely killing speed.  Another problem is that you will no longer write in C, you will write in a similar, but not compatible with C dialect. <br><br>  If writing code in the intolerable C dialect is not yours, then the -ftrapv and -fcatch-undefined-behavior flags (along with the other things mentioned earlier) can be a useful weapon in your arsenal for tracking this kind of bugs.  Enabling them in the debug build can be a good way to detect bugs early.  These flags can also be useful in production if you build a security-critical application.  Although there is no guarantee that you will find all the bugs, they find a useful subset of the bugs. <br><br>  Basically, the real problem is that C is not a safe language and (despite its success and popularity) many people do not understand how the language actually works.  Decades of development preceded its standardization in 1989, and C was transformed from a "low-level system programming language, which is a thin layer above the PDP assembler" to a "low-level system programming language, trying to achieve high performance, breaking people's expectations."  On the one hand, all C tricks almost always work, and the code as a whole is more productive because of this (and in some cases, <i>much</i> more).  On the other hand, the places of cheating tricks are often very surprising people and usually appear at the most inopportune moment. <br><br>  C is much more than a portable assembler, sometimes it can surprise a lot.  I hope that this discussion has clarified some issues regarding indefinite behavior with C, at least from the point of view of the compiler. </div><p>Source: <a href="https://habr.com/ru/post/341154/">https://habr.com/ru/post/341154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341142/index.html">We look for typo names in PostgreSQL</a></li>
<li><a href="../341144/index.html">What every C programmer should know about Undefined Behavior. Part 2/3</a></li>
<li><a href="../341146/index.html">$ mol - the best cure for hemorrhoids</a></li>
<li><a href="../341148/index.html">Fuzzy string comparison: understand me if you can</a></li>
<li><a href="../341152/index.html">Development of 2D sandboxes on JavaScript from scratch</a></li>
<li><a href="../341156/index.html">Security Week 43: The Great IoT Reap Is Coming, Like NATO Cyberconf Hackers Flying, Bad Exception Rabbit Ears ExPetr</a></li>
<li><a href="../341160/index.html">Remove radial distortion from photos and videos using the openCV library and the python language</a></li>
<li><a href="../341164/index.html">Your users do not need passwords.</a></li>
<li><a href="../341166/index.html">How to arrange an open source project</a></li>
<li><a href="../341168/index.html">Virtuozzo Storage: Actual Operating Experience, Optimization and Problem Solving Tips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>