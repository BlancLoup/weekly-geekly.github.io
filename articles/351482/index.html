<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Profiling: optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second article in a series of articles on code optimization. From the first, we learned how to find and analyze bottlenecks in code that d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Profiling: optimization</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/89/l5/lw/89l5lwawiaur0br3lgkjxax3ilq.jpeg"></p><br><p>  This is the second article in a series of articles on code optimization.  From the <a href="https://habrahabr.ru/company/mailru/blog/351320/">first,</a> we learned how to find and analyze bottlenecks in code that degrade performance.  We assumed that the main problem in the example is a slow memory access.  This article will look at how to reduce costs when working with memory, and consequently, increase the speed of the program. </p><a name="habracut"></a><br><p>  Here is the latest version of the code: </p><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Modifier::<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) { Matrix4 mat = obj-&gt;GetTransform(); mat = mTransform*mat; obj-&gt;SetTransform(mat); } }</code> </pre> <br><h2 id="optimizaciya-obrascheniya-k-pamyati">  Memory Access Optimization </h2><br><p>  If our memory assumption is correct, we can speed up the program in several ways: </p><br><ul><li>  Update some objects in the frame, distributing costs over a large number of frames. </li><li>  Update in parallel. </li><li>  Create a compressed matrix format (compressed matrix format) that consumes less memory but requires more processor resources for its processing. </li><li>  Effectively use the possibilities of the cache. </li></ul><br><p>  Of course, we will start with the last step.  Processor developers understand that memory access is a slow process, and they try to compensate for this drawback while designing equipment.  For example, data that you probably need will be retrieved from memory.  When a program actually requests them, the wait time is minimal.  This is easy to implement if the program accesses data consistently, but it is completely impossible with accidental access.  Therefore, it is much faster to access data in an array than from a linked list.  The network has a lot of good documentation on the work of caches, so if you are interested in creating high-performance programs, be sure to study it.  Here is a <a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">good material</a> to start with. </p><br><h2 id="menyaem-shemu-razmescheniya-v-pamyati">  Change the layout in memory </h2><br><p>  Our first step in optimization will be to change not the code, but the memory layout.  I made a simple memory tool that ensures that all data of a certain type can be found in one pool and that this data will be available in order, as far as possible.  So now, when placing an Object, instead of storing matrices and other types inside this instance, we will store a pointer to the data type lying in the pool of such types. </p><br><p>  As a result, the storage of the Object class data changes from </p><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Matrix4 mTransform; Matrix4 mWorldTransform; BoundingSphere mBoundingSphere; BoundingSphere mWorldBoundingSphere; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_IsVisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* mName; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mDirty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>* mParent;</code> </pre> <br><p>  on such: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Matrix4* mTransform = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Matrix4* mWorldTransform = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; BoundingSphere* mBoundingSphere = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; BoundingSphere* mWorldBoundingSphere = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* mName = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mDirty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_IsVisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Object* mParent;</code> </pre> <br><p>  I can hear: ‚ÄúBut now more memory is used!  It contains both the pointer and the data itself, to which it refers. ‚Äù  You're right.  We need more memory.  Optimization is often a trade-off: more memory or less accuracy in exchange for better performance.  In our case, one more pointer is added (4 bytes for the 32-bit assembly), and we need to follow the pointer from Object to find the real matrix that needs to be converted.  Yes, this is additional work, but since the required matrices are arranged in order, like the pointers themselves, which we read from the Object instance, the circuit should work faster than reading from memory in a random order.  This means that we need to place the data in order in the memory used by objects, nodes and modifiers.  In real systems, such a task may be difficult to solve, but since we are considering an example, we will impose arbitrary restrictions to support our position. </p><br><p>  Our Object constructor looked like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>(const <span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>) :mName(<span class="hljs-type"><span class="hljs-type">name</span></span>), mDirty(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), mParent(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { mTransform = Matrix4::<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(); mWorldTransform = Matrix4::<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(); sNumObjects++; }</code> </pre> <br><p>  And now it looks like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>(const <span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>) :mName(<span class="hljs-type"><span class="hljs-type">name</span></span>), mDirty(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), mParent(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { mTransform = gTransformManager.Alloc(); mWorldTransform = gWorldTransformManager.Alloc(); mBoundingSphere = gBSManager.Alloc(); mWorldBoundingSphere = gWorldBSManager.Alloc(); *mTransform = Matrix4::<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(); *mWorldTransform = Matrix4::<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(); mBoundingSphere-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); mWorldBoundingSphere-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); sNumObjects++; }</code> </pre> <br><p>  Calls to <code>gManager.Alloc()</code> are calls to a simple block allocator. </p><br><pre> <code class="hljs xml">Manager<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Matrix4</span></span></span><span class="hljs-tag">&gt;</span></span> gTransformManager; Manager<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Matrix4</span></span></span><span class="hljs-tag">&gt;</span></span> gWorldTransformManager; Manager<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BoundingSphere</span></span></span><span class="hljs-tag">&gt;</span></span> gBSManager; Manager<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BoundingSphere</span></span></span><span class="hljs-tag">&gt;</span></span> gWorldBSManager; Manager<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> gNodeManager;</code> </pre> <br><p>  It pre-allocates large chunks of memory, and then on each call to <code>Alloc()</code> returns the following N bytes: 64 bytes for <code>Matrix4</code> or 32 for <code>BoundingSphere</code> .  However, for a particular type you need a lot of memory.  In fact, this is a large array of a given type of object pre-allocated in memory.  One of the advantages of such a dispenser is that objects of a given type placed in a certain order will go in memory one by one.  If you place objects in the order in which you want to access them, the hardware can more efficiently do a preliminary selection, processing the objects in a given order.  Fortunately, in our example, we go through the matrices and other structures in the order they are placed in memory. </p><br><p>  Now that all the objects, matrices and bounding spheres are stored in the order of their appeal, we will re-program the program and see if the performance has changed.  Please note that the only change in the code was a change in the memory location and the way the data was used through pointers.  For example, <code>Modifier::Update()</code> becomes: </p><br><pre> <code class="hljs php">void Modifier::Update() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object* obj : mObjects) { Matrix4* mat = obj-&gt;GetTransform(); *mat = (*mTransform)*(*mat); obj-&gt;SetDirty(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre> <br><p>  Since we are working with pointers to matrices, it is no longer necessary to copy the results of matrix multiplication back to an object using <code>SetTransform</code> : we will transform right on the spot. </p><br><h2 id="kak-izmenilas-proizvoditelnost">  How has performance changed </h2><br><p>  After the changes, we first verify that the code is correctly compiled and executed.  Here are the previous results from the test profile: </p><br><p><img src="https://habrastorage.org/webt/mc/qv/b0/mcqvb0ofw0l7v8hu-am_rlijutu.png"></p><br><p>  But what happened after changing the layout in memory: <br><img src="https://habrastorage.org/webt/vn/t_/vv/vnt_vvyyu4pnswbmmz4lrle5_1k.png"></p><br><p>  That is, we accelerated the program from 17.5 ms per frame to 10.15 ms!  It has become almost twice as fast after changing <strong>only the layout of the data in memory</strong> . </p><br><p>  Remember in this series of articles the main thing: the layout of the data in memory is critical to the performance of your program.  People talk about the dangers of hasty optimizations, but, as my experience suggests, a little forethought about the relationship of data with the order of treatment and processing can greatly increase productivity.  If you cannot plan the layout in advance, then try to write code conducive to the reorganization of the layout and use scheme, this will facilitate optimization.  In most cases, it is not the code that hinders access to the data. </p><br><h2 id="sleduyuschee-uzkoe-mesto">  Next bottleneck </h2><br><p>  The code got faster, but is it enough?  Of course not.  Performance characteristics have changed, so you need to repurpose and find the next candidate for optimization.  Let's compare the runs of the sampling profiler.  It was: </p><br><p><img src="https://habrastorage.org/webt/pl/_f/bl/pl_fbl2rfmi_cegxiab73-fgjac.png"></p><br><p>  It became: </p><br><p><img src="https://habrastorage.org/webt/-v/9y/wr/-v9ywrxfebcgxuigfddkwubrrju.png"></p><br><p>  Please note that the sampling profile does not tell us if the program is now faster.  It shows only the <strong>relative</strong> amount of time spent on each function.  Now the matrix operator multiply function is the longest running.  This does not mean that it has slowed down, just compared to others, it took longer to complete its implementation.  Let's look at our sampling to see where the bottlenecks are now. </p><br><p>  First, take a look at <code>Modifier::Update()</code> .  The matrix is ‚Äã‚Äãno longer copied to the stack.  This is advisable because we are passing the pointer to the matrix, rather than copying all of its 64 bytes. </p><br><p><img src="https://habrastorage.org/webt/ob/h0/kb/obh0kbid9fgttxsqxzoyq8aryui.png"></p><br><p>  Most of the time the function works is spent on setting up the matrix multiplication call, and then on copying the result into the location of <code>obj-&gt;mTransform</code> (the abbreviated assembler is shown below). </p><br><p><img src="https://habrastorage.org/webt/th/fa/md/thfamdnyqiue6mdzrki7hbz_8wa.png"></p><br><p>  The question arises: how to reduce the cost of calling a function?  The answer is simple: you need to inline it.  But if you look at the matrix multiplication function, it will become clear that it is ready for inline.  Then what is it? </p><br><p>  If the function is small enough, then compilers often decide to inline it automatically.  But programmers can control this behavior.  You can change the maximum size of the inline function, and some compilers also allow you to inline "forcibly", although this comes at a price.  The size of the code may increase, and the cache will begin to slip when executing more bytes from different places. </p><br><h2 id="est-simd">  Have a SIMD? </h2><br><p>  The matrix multiplication operator uses single floating point numbers rather than SIMD (Single Instruction Multiple Data: modern processors provide instructions that can execute one instruction in multiple data instances ‚Äî like the simultaneous multiplication of four floating point numbers).  Even if you tell the computer that you want to use SIMD, it will ignore you and generate similar code: </p><br><p><img src="https://habrastorage.org/webt/po/eb/5n/poeb5nhs_6xkhe2diztkg5vk9lm.png"></p><br><p>  There are no SIMD instructions here, because they need data aligned by 16 bytes, and we only have 4-byte alignment.  Of course, you can download the unaligned data, and then transfer it to the SIMD registers.  But if the volume of SIMD processing is not too large, then the operation speed may be lower than when using a single floating point number at a time.  Fortunately, we wrote a memory manager for such objects, so we can forcefully do 16-byte (or even larger) alignment for our matrices.  In this example, I stopped at 16. I also forced the Vectormath library to generate only SIMD instructions. </p><br><p>  The next time the profiler was run, it turned out that the average frame duration decreased from 10.15 to about 7 ms! </p><br><p><img src="https://habrastorage.org/webt/-d/im/ck/-dimckwwaytl8gwmymna0jeheqe.png"></p><br><p>  Let's look at the sampling profile: </p><br><p><img src="https://habrastorage.org/webt/oy/g-/x-/oyg-x-omh2tq-0b3mwptladaock.png"></p><br><p>  The matrix multiplication operator has disappeared.  Converting SIMD instructions reduced the size of the function so much (from 1060 bytes to about 350) that the compiler could inline it.  The matrix multiplication code was included in each function that called it; now they do not invoke an instance of the multiplication function.  As a side effect, the size of the code has increased (the .exe file instead of 255 began to occupy 256 KB, so I don‚Äôt care too much), but now I don‚Äôt need to copy the function parameters to the stack for their use by the called function. </p><br><p>  Let us consider <code>Modifier::Update()</code> more detail: </p><br><p><img src="https://habrastorage.org/webt/ol/ac/zm/olaczmt9wb3unkqv7kqq4pc4yom.png"></p><br><p>  In the 13th line, the pointer to the mTransform is taken, and almost immediately after this, the matrix SIMD code uses the MOVAPS instruction (Move Aligned Single-Precision Floating-Point Values) to fill the xmm registers.  So, we not only process four floating point numbers at the same time using instructions like MULPS (Multiply Packed Single-Precision Floating-Point Values), but we also load these numbers at the same time.  As a result, the number of instructions in the function is greatly reduced and productivity increases.  The brakes are still there, they can be attributed to cache misses, but now the performance has improved, and largely due to the improved use of instructions and inlineing.  In the past, matrix multiplication was often called in the code, and now we have got rid of a significant amount of function calls. </p><br><p>  So, we have reduced the processing time of the frame from 17.5 to about 7 ms, that is, we increased the performance by 2.5 times without degrading the code.  It began to run faster without a significant increase in complexity.  We have limited the way in which data is stored in memory, but we can still make low-level changes without changing the high-level code. </p><br><h2 id="dopolnitelnoe-zadanie-virtualnye-funkcii">  Additional task: virtual functions </h2><br><p>  In my <a href="https://drive.google.com/open%3Fid%3D1SbmKU0Ev9UjyIpNMOQu7aEMhZBifZkw6">presentation of 2009,</a> I went much further than here: I broke the code, removed all the virtuals and made the code less flexible, but doubled the performance even more.  I will not do it now.  I'm sure we can optimize our example even more, but we will have to pay for it with readability, extensibility, portability, and maintainability.  Instead, we will go through the implementation and consider the impact of virtual functions. </p><br><p>  Virtual are functions in the base class that can be overridden in derived classes.  For example, in the Object class there is a virtual function <code>Render()</code> , from which you can inherit and create <code>Cube()</code> and <code>Elephant()</code> objects that define the functionality of <code>Render()</code> .  These new objects can be added to one of the Nodes, and when <code>Render()</code> called via the pointer in our original Object, the overridden <code>Render()</code> functions will be called - and they will draw a cube or an elephant on the screen. </p><br><p>  The simplest test for our example is the <code>SetVisibilityRecursively()</code> method in Objects and Nodes.  It is used in culling phase, when the node is entirely inside or outside the truncated figure (frustum), so that its children can simply be made visible or invisible.  In the case of Object, the internal flag is just set: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetVisibilityRecursively</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visibility</span></span></span><span class="hljs-function">)</span></span> { m_IsVisible = visibility; }</code> </pre> <br><p>  In the case of Node, <code>SetVisibilityRecursively()</code> is called for all children: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Node::SetVisibilityRecursively(<span class="hljs-type"><span class="hljs-type">bool</span></span> visibility) { m_IsVisible = visibility; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>* obj : mObjects) { mObjects[i]-&gt;SetVisibilityRecursively(visibility); } }</code> </pre> <br><p>  Here is what we see in the Node-version when analyzing the sampling profile: </p><br><p><img src="https://habrastorage.org/webt/zh/oa/-n/zhoa-nkgzlsjcflbirlgqhlc64m.png"></p><br><p>  ESI is the counter for the loop, and EAX is the pointer to the next object.  An interesting highlighted line is CALL DWORD [EAX + 14h]: here the virtual function is called, located in 0x14 (decimal 20) bytes from the beginning of the virtual table.  Since the pointer occupies 4 bytes, and all reasonable people start counting from 0, this is a call to the fifth virtual function in the virtual table of the object.  Or, as we see below, <code>SetVisibilityRecursively()</code> : </p><br><p><img src="https://habrastorage.org/webt/p0/iv/pj/p0ivpjq1j4kbi9db6safkku1db8.png"></p><br><p>  To call a virtual function, you need to do a little more work.  A virtual table must be loaded, then a virtual function is searched in it, called, some parameters are passed to it, as well as ‚Äúthis‚Äù pointer. </p><br><h2 id="virtualno-otsutstvuyuschie-virtualy">  Virtually missing virtuals </h2><br><p>  In the following code example, I have replaced virtual functions with normal ones in Nodes and Objects.  This means that I need to keep two arrays in each Node (Nodes and Objects), since they are different from each other.  Example: </p><br><p><img src="https://habrastorage.org/webt/as/ru/m6/asrum6rgfszrkkjiget20h0jzkq.png"></p><br><p>  As you can see, there are no downloads of virtual tables and dereferencing of virtual functions.  In the first case, there is only a simple function call to implement <code>Node::SetVisibilityRecursively()</code> , and in the second case, in the implementation of Object, the function is completely inline.  The compiler cannot inline virtual functions, because during compilation they cannot be determined, only at runtime.  So this non-virtual implementation should work faster.  Let's profile and find out. </p><br><p><img src="https://habrastorage.org/webt/pg/yg/g_/pgygg_6iajvclgmlpxqewz2lwqq.png"></p><br><p>  This optimization has changed very little performance: from 6.961 to 6.963 ms.  Does this mean that our code has slowed down by 0.002 ms?  Not at all.  This difference can be attributed to the noise background of the system, which is a personal computer running the OS, which simultaneously performs many tasks (updates my Twitter feed, checks mail, updates animation gifs on the page I forgot to close).  To understand how your operating system affects the executable code, you can use the invaluable tool <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-analyzer">Windows Performance Analyzer</a> .  This software will not only show the performance of your code, but will also holistically display your entire system.  So if the code unexpectedly began to be processed twice as long, then check to see if someone else is guilty of this, stealing your processor cycles.  You can also read <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/">Bruce Dawson's</a> excellent <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/">blog</a> . </p><br><p>  So, deleting virtual functions has very little effect on code performance.  Despite the decrease in the number of searches on the virtual table and the execution of fewer instructions, the program works at the same speed.  Most likely, the Miracles of Modern Equipment matter - branch prediction and speculative execution are good not only for hacking, but also to take your duplicate code and figure out how to execute it as quickly as possible. </p><br><p>  To quote Henry Petroski (Henry Petroski): </p><br><p>  <em>"The most surprising achievement of the modern software industry is the continuation of the rejection of the steady and stunning success of the hardware industry."</em> </p><br><p>  I showed you that virtual functions are not free to use, but in this case the cost is negligible. </p><br><h2 id="rezyume">  Summary </h2><br><p>  We profiled the sample code, identified the bottlenecks and tried to reduce their impact.  After each change of the code, we redeveloped it to understand if it became worse or better (errors are useful, we learn from them).  And at each stage, we better understand the code: how it is executed, how it accesses memory.  Our solution minimally changes the high-level code and reduces the duration of rendering an individual frame from 17 to 7 ms.  We learned that memory is slow and you need to work with hardware to write fast code. </p><br><p>  In the third part of the series, we will look at the definition, analysis, and optimization of performance bottlenecks that we recently discovered in <em>League of Legends</em> . </p><br><p><img src="https://habrastorage.org/webt/6s/5x/rj/6s5xrjdvl4d2l8nkqhg2vnro1es.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351482/">https://habr.com/ru/post/351482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351468/index.html">Our on Delex: how was the first DevOps and advanced Test Automation conference held in Minsk</a></li>
<li><a href="../351470/index.html">New 4G LTE vulnerabilities: mass mailing, impersonation of subscriber devices and others</a></li>
<li><a href="../351476/index.html">Protection against creative abuse of HSTS</a></li>
<li><a href="../351478/index.html">Hyperpilot 100% open source for its products.</a></li>
<li><a href="../351480/index.html">[bookmark] JS developer tools to pay attention to</a></li>
<li><a href="../351484/index.html">NeoQuest 2018: Cheating and only</a></li>
<li><a href="../351486/index.html">Video conferencing in 7 steps</a></li>
<li><a href="../351488/index.html">Digital events in Moscow from March 19 to March 25</a></li>
<li><a href="../351490/index.html">KOMPAS-3D Home - professional CAD software for home and hobby</a></li>
<li><a href="../351492/index.html">C ++ 20 is getting closer. Meeting in jacksonville</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>