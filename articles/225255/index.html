<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>One combinatorial generation algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Combinatorics in high school, as a rule, is limited to word problems, in which you need to apply one of three well-known formulas - for the number of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>One combinatorial generation algorithm</h1><div class="post__text post__text-html js-mediator-article">  Combinatorics in high school, as a rule, is limited to word problems, in which you need to apply one of three well-known formulas - for the number of combinations, permutations or placements.  The institute courses in discrete mathematics also tell about more complex combinatorial objects - bracket sequences, trees, graphs ... In this case, as a rule, they set the task to calculate the number of objects of this type for some parameter n, for example the number of trees on n vertices.  Having learned the number of objects for a fixed n, one can ask a more complicated question: how can we present all these objects in a reasonable time?  Algorithms that solve this kind of problem are called combinatorial generation algorithms.  For example, the first chapter of the fourth volume of Donald Knuth's The Art of Programming is devoted to such algorithms.  Knut very thoroughly examines the algorithms for generating all tuples, partitions of numbers, trees, and other structures.  It is easy to come up with any algorithm that works moderately quickly for each of these tasks, but with further optimization serious problems may arise. <br><br>  In the process of writing a master's thesis, defended at the <a href="http://mit.spbau.ru/">Academic University</a> , I needed to study and apply one of the combinatorial generation algorithms suitable for a particular class of problems.  This is the generation of structures on which some equivalence relation is additionally introduced.  To make it clear what is at stake, I will give a simple example.  Let's try to generate all the triangulations of a hexagon.  It turns out something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ae/b26/e4e/9aeb26e4e642d30df2b8760af9c98a39.jpg" height="240"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To write an algorithm that returns all such triangulations is pretty easy.  For example, such a procedure would fit: fix some edge (let it be edge 1-6), after which we loop through vertices that are not its ends.  At the current vertex and fixed edge, we construct a triangle, and the remaining two regions after that are triangulated by recursively.  If you look at the triangulations resulting from the operation of this algorithm, you can see that many of them are almost the same and differ only in how the labels (numbers) of the vertices are arranged.  Therefore, it would be useful to come up with an algorithm that will generate so-called unlabeled triangulations ‚Äî those shown in the following figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/806/cc7/c0c/806cc7c0cce5626ac417dd30737031a8.jpg" height="80"></div><br><a name="habracut"></a><br><br>  More formally, let some <a href="http://ru.wikipedia.org/wiki/%25CE%25F2%25ED%25EE%25F8%25E5%25ED%25E8%25E5_%25FD%25EA%25E2%25E8%25E2%25E0%25EB%25E5%25ED%25F2%25ED%25EE%25F1%25F2%25E8">equivalence relation</a> act on our set of objects, dividing the whole set into classes of objects <i>isomorphic to</i> each other.  It is required to generate one representative from each class.  You have probably noticed that the two right triangulations in the second figure are also very similar to each other and only one of them can be left.  In fact, it all depends on which equivalence relation we choose.  If we consider only those triangulations that can be superimposed on each other after a turn is isomorphic, then there will be four of them, and if we still allow the possibility to turn the hexagon, then three. <br><br>  It would seem that it is easy to generate one representative from each class: we generate all the objects, after which we test in pairs for isomorphism and throw out duplicates.  Unfortunately, for some types of objects this will work terribly long even for small n.  The task of checking isomorphism, for example, two graphs, is not able to solve for polynomial time, which means that it is desirable to call the subroutine that solves this problem as little as possible.  Another disadvantage of the proposed naive approach is that all objects must be kept in memory at the same time.  At the same time, if you wait for a slow program that gives the right answer, you can theoretically still, then getting memory overflow instead of an answer is completely unacceptable.  So, to generate pairwise non-isomorphic objects, you need to use some more cunning method.  Such a method was repeatedly rediscovered for many specific combinatorial objects (graphs, trees, partitions), and in general, was described in the article <a href="http://cs.anu.edu.au/~bdm/papers/orderly.pdf">Isomorph-Free Exhaustive Generation</a> . <br><br>  I will talk about this method using the example of a task that is somewhat more general than the problem of triangulations: we will generate all the ‚Äúcuts‚Äù, that is, the ways to split a polygon are not necessarily triangles, but polygons with a number of sides from the list that is input the program. <br><br>  In order to describe this method we need several formal definitions. <br><br>  Let X be some set of ‚Äústructures‚Äù.  Elements of the set X will be called <i>labeled objects</i> .  In our task, the marked objects are cuts whose vertices are numbered counterclockwise.  The data structure for tagged cuts is simple - these are adjacency lists: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dissection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] adjacent; ... }</code> </pre> <br><br>  Let G be some permutation <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D1%2583%25D0%25BF%25D0%25BF%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">group</a> acting on a set X. This means that each labeled object x from X and each element g of group G are assigned another labeled object y = g * x, and the following properties are true: <br><br><ol><li>  Multiplying any elements of the group h and g corresponds to the sequential application of actions to the object x: h * (g * x) = (hg) * x. </li><li>  The unit of the group e translates each tagged object x into itself: e * x = x. </li></ol><br><br>  It can be shown that the whole set X is divided into equivalence classes of the relative relation: x and y are equivalent if x = g * y.  In our first example with triangulations, the elements of the group ‚Äî turns by 0, 60, 120, 180, 240, and 300 degrees ‚Äî divide the whole set into four equivalence classes, whose elements differ precisely in their structure, and not in the marks of the vertices.  These equivalence classes were depicted in the second figure.  We will call these classes <i>unlabeled objects</i> . <br><br>  To each element of X, we associate a natural number, which we will call order.  The order of all equivalent objects must be the same.  This property allows you to further define the order for equivalence classes (unlabeled objects): it will be equal to the order of any representative of the corresponding class.  For our example in the figure, the order is the number of vertices in the polygon.  All unlabeled objects in the figure are six. <br><br>  These were fairly general definitions.  We now turn to definitions specific to the future algorithm.  To each marked object x, we associate two sets ‚Äî the set of <i>lower objects</i> L (x) and the set of <i>upper objects</i> U (x).  The orders of the elements in these sets are by definition equal to the order of x.  Before giving formal requirements for lower and upper objects, I will try to give an intuitive description.  Each lower object must contain information about how to uniquely move from the current object to an object of a smaller order.  For example, a lower dissection object is a dissection in which one of the "extreme" polygons is additionally highlighted (for example, colored red), which can be cut off from this dissection.  The upper object is, on the contrary, the marked object plus information, allowing it to unambiguously ‚Äúincrease‚Äù it by increasing the order.  The upper dissection, for example, is a dissection in which one of the sides of the polygon is additionally highlighted (for example, colored red) and a number is written on it.  Looking at this cut, we can figure out which side to glue the new polygon to increase the order.  The number of sides of the glued polygon will be determined by what number is written on the edge.  This idea can be illustrated by the following figure, depicting two objects - the lower and the upper, corresponding to the same dissection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c92/d83/947/c92d83947c9377d5aa07a8b05ee5904c.jpg" height="140"></div><br><br>  In the program, the lower and upper cuts are presented as follows: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LowerDissection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dissection dissection; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> after; ... }</code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpperDissection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dissection dissection; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> after, size; ... }</code> </pre><br><br>  For the lower dissection, we store only the number of the vertex from which the polygon begins, which we are going to delete.  For the top cut, the number of the vertex is stored, after which it will be necessary to paste a new polygon, as well as the number of its sides. <br><br>  You can see that some of the lower and upper objects are in the relation of "correspondence": the lower object corresponds to the upper one, which is obtained after we reduced the order in the manner encoded in the lower object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/a37/c67/090a37c679e175a5ff8213b42e15a3cc.jpg" height="140"></div><br><br>  Here the top object is mapped to the lower object, the result of deleting the selected quadrilateral.  In the following picture - the opposite: a pentagon is glued to the top object, or rather, to its highlighted edge with the five written on it.  This results in a lower object that stores information on how to roll back the operation performed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/757/af2/f47757af2cd198e988e3c8e28499aca5.jpg" height="140"></div><br><br>  Now, formally, what do you need to require from the mentioned structures: <br><br><ol><li>  The group G acts on three types of objects: marked, upper and lower.  Each of these three sets is closed with respect to the group action (this means that, for example, by acting on the lower object with an element of the group, we cannot get the upper one ‚Äî a rather formal requirement). </li><li>  For each tagged object x and an element of the group g: L (g * x) = g * L (x);  U (g * x) = g * U (x) (the notation g * L (x) means that we apply g to each element of the set L (x), similarly for g * U (x)). </li><li>  For each lower object y, the corresponding set of upper objects is not empty. </li><li>  If the two lower objects y and x are equivalent (that is, y = g * x), then any two corresponding upper objects are also equivalent. </li><li>  If the two upper objects y and x are equivalent, then any two corresponding lower objects are also equivalent. </li><li>  The order of the lower object is greater than the order of any corresponding upper one. </li></ol><br><br>  To better understand this concept, I suggest you distract from reading for a moment and think about what the lower and upper objects will look like if you take graphs without triangles as X (that is, graphs in which no three vertices are connected by edges all at once ). <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Of course, this is not the only way, but it is quite natural to take graphs without triangles as lower objects, in which one of the vertices is colored red (this will mean that we are going to delete it), and as the upper ones - graphs without triangles, which several vertices are painted red (this will mean that we are going to add a vertex and connect it with all the red vertices).  At the same time, it is necessary to require that the red vertices are not connected in pairs.  In this case, after adding a new vertex, triangles are not formed. <br></div></div><br><br>  We continue.  Let nothing can be ‚Äúbitten off‚Äù from some unlabeled object.  Thus, there are no lower objects corresponding to it (or rather, corresponding to its marked objects).  Such an object is called <i>irreducible</i> .  In our case, irreducible are dissections consisting of a single polygon.  All others are <i>reducible</i> . <br><br>  Our algorithm will generate all non-isomorphic cuts sequentially, starting with irreducible ones, gradually increasing their order.  To do this, we will paste all possible polygons from all possible sides to the current section.  The problem, however, is that one can come to the same dissection in several ways.  For example, you can come to the cut of the octagon, which corresponded to the lower object in the two previous pictures, by gluing a quadrilateral to a triangle, and then a pentagon, or by gluing, on the contrary, a triangle and a quadrilateral to a pentagon.  Thus, it is possible to generate the same dissection several times, and not even notice it.  This is what you just want to avoid. <br><br>  To get around this problem by generating a new dissection, we will check if it is true that the last addition of the polygon corresponds to some single canonical way of constructing this dissection.  To do this, we need the function P, which associates with each marked object a set of lower objects for which it is a ‚Äúdescendant‚Äù.  The function P must meet the following requirements: <br><br><ol><li>  If L (x) is empty, then P (x) is also empty. </li><li>  If L (x) is not empty, then P (x) consists of such and only those corresponding to the object x lower objects that any two of them are transformed into each other under the action of some element g for which g * x = x. </li><li>  For any unlabeled object x and element of the group g: g * P (x) = P (g * x). </li></ol><br><br>  It is worth paying special attention to the second requirement: it, in fact, means that the set P (x) must consist of several objects that are equivalent with respect to the symmetries of the object x.  Suppose, for example, it turned out that the dissection of x is symmetrical about only turns to 0 and 180 degrees.  Then P (x) must consist of exactly two lower objects, obtained from each other by means of such turns. <br><br>  Let's try to satisfy the general requirement in our example.  To do this, take some dissection x and scroll through it marks all n ways (n is the number of vertices).  Every time when the ‚Äúextreme‚Äù polygon starts from the vertices 1 and 2 (such that it can be cut off), we will remember this numbering.  After that, from all the selected vertex numbering options, choose those that give a lexicographically minimal (any other reasonable order) the adjacency list entry.  These numbering allocates us some polygons on the source object x - those that, with appropriate numbering, start with 1 and 2. P (x) just consists of lower objects for x, in which these polygons are colored red.  You can't do without a picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/a89/730/c26a897300d06d8d31ae2ce2e9910e55.jpg" height="300"></div><br><br>  So, we chose the cut x, shown on the left, and rearranged the marks in eight different ways.  The methods a, c, e and g do not immediately suit us: on the vertices 1,2, ..., i, there is no polygon that can be cut off.  It can be seen that methods b and f are essentially the same, as are methods d and h.  Of these four methods, choose those that are in some sense "minimal."  As we have already noticed, you can define at least as you like, but definitely.  For example, a minimal lexicographically record of adjacency lists is appropriate.  In this case, methods b and f win.  This method gives us triangles 2,3,4 and 6,7,8 on the original tagged object x.  As a result, we get the two lower objects shown in the figure on the right. <br><br>  The P function is the most important for fast generation.  To meet these requirements and maintain high speed, in fact, it is very difficult.  As can be seen, the function P, in a certain sense, allows us to indicate which of the ways to ‚Äúbite off‚Äù the extreme polygon is canonical, up to isomorphism.  If the concept is clear, I suggest you figure out how the P (x) function should work for the already mentioned graphs without triangles. <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  The answer, of course, is not straightforward.  One of the simple (but not very efficient) methods is as follows: for a graph without triangles, x will iterate over all ways to renumber the vertices, and then leave those that lexicographically minimally write adjacency lists.  For each of these methods, choose the vertex v having the number 1 and compose the lower object - the graph x with the vertex v colored red.  All such different lower objects form the result of the work P (x). <br></div></div><br><br>  The code that adds to the classes described above methods that implement all of these functions, it is better to look in the <a href="https://code.google.com/p/dissection-generator/">repository</a> : it has too many technical details to discuss it in detail. <br><br>  Now everything is ready to describe directly the generation algorithm.  It will run for every irreducible cut.  For the current dissection, we consider all non-isomorphic ways to create the top object, and then we increment each resulting top object to the bottom with increasing order.  Further, using the P function, we check every lower object for the fact that it is indeed the parent of the corresponding marked object.  If this check passes, then we consider that this tagged object is a representative of a new equivalence class;  we run the algorithm for it recursively.  You can, of course, prove the correctness of this algorithm, but I feel that I already overdid it a little with formalism, and in order to deal with the evidence, it is easier to refer to the <a href="http://cs.anu.edu.au/~bdm/papers/orderly.pdf">original article</a> . <br><br>  Better let's look first at the code responsible for generating: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateSubtreeFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dissection root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxOrder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (UpperDissection upper : root.createAllUpper()) { LowerDissection lower = upper.createArbitraryLower(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lower != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Dissection probableChild = lower.getUnderlyingDissection(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (probableChild.getOrder() &lt;= maxOrder &amp;&amp; lower.isParentFor(probableChild)) { root.addChild(probableChild); generateSubtreeFrom(probableChild, maxOrder); } } } }</code> </pre><br><br>  And now for the result of generating all non-isomorphic cuts into 3.4 and 5-gons, up to an order equal to eight.  Arrows are directed from parents to descendants.  It can be seen that all the dissections formed trees whose roots are irreducible objects. <br><br> <a href=""><img src="//habrastorage.org/files/b40/ca3/580/b40ca3580499429c9886d7e446bbfcfa.png"><br></a> <br><br>  The source code of the program that generated this image is available in <a href="https://code.google.com/p/dissection-generator/">google code</a> .  The result of her work is a description in graphviz format. <br><br>  In conclusion, I will add that for the considered problem, in principle, one can come up with a simpler and faster algorithm.  However, the described procedure is applicable to almost all types of combinatorial objects that can be constructed in an inductive way, ‚Äúbuilding up‚Äù the structure.  Moreover, for some types of graphs, at least, according to the author of the algorithm, this approach provides some of the best, if not the best, generation rates today. </div><p>Source: <a href="https://habr.com/ru/post/225255/">https://habr.com/ru/post/225255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225235/index.html">Swift video course in Russian</a></li>
<li><a href="../225239/index.html">SIP through WebRTC on production. How we went to this and what problems solved</a></li>
<li><a href="../225247/index.html">Art of IT-project management, 2nd ed</a></li>
<li><a href="../225249/index.html">How to gash your dashboard for all occasions?</a></li>
<li><a href="../225251/index.html">Git 2.0.0</a></li>
<li><a href="../225257/index.html">Chinese 3D printers: cheap and cheerful</a></li>
<li><a href="../225259/index.html">[free webinar] 7 sources of energy in work: June 7, 10:00 MSK</a></li>
<li><a href="../225261/index.html">Masters in Finland - the educational process and the subtleties of admission 2014</a></li>
<li><a href="../225263/index.html">WWDC 2014. Second Day Slice</a></li>
<li><a href="../225267/index.html">Week performance in Runet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>