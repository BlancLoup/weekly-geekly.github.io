<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anti-virus bot for Telegram</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last week, Doctor Web released an antivirus bot for Telegram. As a direct participant in this project, I would like on behalf of the whole team to tel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anti-virus bot for Telegram</h1><div class="post__text post__text-html js-mediator-article">  Last week, Doctor Web released an antivirus bot for Telegram.  As a direct participant in this project, I would like on behalf of the whole team to tell about why we made this bot, how it works and whether it‚Äôs time to abandon the desktop antivirus. <br><br><img src="https://habrastorage.org/files/238/a84/cdb/238a84cdb6924620952986ce333e6a75.png"><br><a name="habracut"></a><br><h3>  Concept </h3><br>  Last summer Telegram introduced bots and the Telegram Bot API.  Chat bots existed for a long time, but in this case the platform provided such ample opportunities for integration experiments that only lazy people did not make their own bots.  There are even such <a href="https://geektimes.ru/post/264286/">exotic examples</a> . <br><br>  Most of the bots that we experienced were entertaining (like IQ tests or sticker evaluation), informational (for example, they sent a weather forecast, a translation of words or the address of the nearest ATM), or both, and others, such as bots to search for Indian cinema. .  It turned out to be convenient to use them, and the format itself so fascinated us that we wanted to use it for our own information stand - our bot could give a description of the threat on request: let's say the user asks the bot what exactly is caught by the Linux.Encoder.1 antivirus. and in response receives a detailed description of the threat.  But having slightly twisted the idea in our hands, we found obvious flaws: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  In the format of messages from the messenger, it is inconvenient to read about malware: the description of the mechanism is often very long, with examples of code and a lot of screenshots. </li><li>  The situation itself seemed artificial, when the user found out about the threat on his device, opened Telegram, found the bot and asked him a question about it, rather than simply google it. </li><li>  Different antivirus companies use different threat naming conventions.  The user can search for a threat by a different name and not find the necessary information. </li></ul><br>  Having considered all this, we decided to take a step further - and create a bot with truly applied functionality.  Experimental antivirus bot. <br><br>  The task seemed fascinating and useful.  The messenger is responsible for traffic encryption and secure data exchange, and Telegram has proven itself in this.  For the security of the device on which Telegram is installed, the user is responsible - and all the usual social engineering tricks work.  Both a computer and a smartphone can be infected with a Trojan, which at best will show tons of advertising, and at worst - turn the device into an insensitive set of plastic and metal. <br><br>  We conceived a bot that could check files and links on the fly and warn the user if it detects a threat.  When anti-virus protection is embedded in, say, e-mail, the anti-virus can be located either on the mail hosting side or on the user's device.  Bot API allows you to organize protection differently, in the new paradigm: the bot does not work on the user's machine or on the service side, it does not depend on the operating system or on the performance of the device.  The only condition for his work - the Telegram client version must support the use of bots.  If a suspicious message came in Telegram itself, you can immediately forward it to the bot.  Convenient and send bot a dubious link obtained from other sources. <br><br>  Immediately make a reservation that such a mechanism is not a full replacement for antivirus.  A bot cannot prevent a user from clicking on a dangerous link or launching a file, he can only warn about the danger - while the antivirus will protect, even if the social engineer‚Äôs carefree victim immediately downloads and launches the Trojan.  At the same time, Telegram's tech-savvy audience may be interested in an anti-virus product, which does not limit their actions in any way, but provides information on request.  We think of the bot as a research project, and first of all we are interested in feedback - that's why you see our article here. <br><br><h3>  Implementation </h3><br>  The bot is implemented using the Tornado framework - which, as a traffic controller at the intersection, coordinates data flows between the Telegram Bot API and the closed API of our Dr.Web services.  Initially, we went the standard way and used Django.  However, the feature of the Django framework is such that during data entry and output (retrieving the request body, sending a response, working with a database, etc.), precious time is wasted.  We conducted an experiment using the <a href="https://habrahabr.ru/post/65128/">Siege utility</a> and realized that this model was unsuitable for efficiently processing thousands of one-time requests. <br>  Therefore, we began to look towards asynchronous models of work - and made a choice in favor of Tornado (where asynchrony, in fact, is the main feature).  Currently, the entire bot code is asynchronous: including downloading files, checking references and even working with the database - when adding a record to the database, the bot does not wait for a response from the server, but continues to perform tasks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/376/f72/80d/376f7280d06f454886324a6c89e23ad1.png"></div><br><br>  When the messages intended for the bot come from the Telegram cloud, we need to parse the links in the received text.  At the same time, it is important to avoid discrepancies between how our parser works (that is, which page the bot checks), and how the Telegram parser works (that is, what the user has to open by clicking on the messenger), so we followed the most Parsing links Telegram - focusing on the open source web version.  Although their mechanism is probably not limited to this, and periodically we have questions (for example, in the iOS mobile application, the link ‚Äútest.com:8080‚Äù without specifying the protocol looks like ‚Äú <a href="http://test.com/">test.com</a> : 8080‚Äù at the sender, but as ‚Äú <a href="http://test.com:8080/">Test.com:8080</a> ‚Äú at the recipient). <br><br>  Further processing of links and files goes in several stages: unpacking archives, disclosing reduced links and tracking redirects.  If files are downloaded via a link, we download them - thanks to this, the bot can check not only files sent via Telegram, but also files from external links. <br><br>  In order to more efficiently distribute the load on the servers, first of all the caches of files and links are checked.  After that, the bot passes the baton to various Dr.Web technologies through our internal APIs: the Dr.Web Cloud cloud service, the Scanning Engine anti-virus engine, the Link Checker link checking service, and virus signature databases.  Data exchange is asynchronous and multi-threaded, and with increasing load, we can increase power by adding new servers and writing certain settings in configuration files - the ability to scale is initially incorporated into the architecture of the bot. <br>  Finally, the verified materials are returned to the bot - and it sends the results to users, taking into account the <a href="https://core.telegram.org/bots/faq">restrictions</a> on the frequency of messages from the bots that are set by the Telegram Bot API. <br><br>  Users can check links and files both in private mode (send suspicious content to the bot or send messages received from other users to it) or in group chat - if you add a bot to the chat participants, it will work on all files and links in the chat. <br><br>  The bot works in two modes: "quiet" and normal.  In normal mode, the bot responds to each file or link and sends a message stating that the link is safe or it is not recommended to download the file.  If the bot behaves like this in a group chat, then this may prevent people from communicating, so we made a ‚Äúquiet‚Äù mode.  In this mode, the bot gives a sign only when the file or link in the chat contains a threat, and warns users against rash or click.  Verification error messages also come in ‚Äúsilent‚Äù mode - otherwise, without waiting for an answer, the user could mistakenly find that the link or file was successfully checked and safe.  You can select a mode using the <i>/ mode</i> command. <br><br>  As the API evolves, we will introduce new features if they prove to be useful for our tasks.  Not so long ago, Telegram introduced the use of bots in inline mode without adding a bot to the chat - so far this mechanism does not allow the file to be sent to the bot for verification, but we are considering its use.  In the next updates we plan to make the bot faster and more reliable, we also closely monitor the feedback of users. <br><br>  A few words about localization (since this is not only my profession, but also passion): our bot knows how to communicate in Russian, English or German.  There were no special difficulties, we use the gettext library, and store localization files in the .po format. <br><br>  As a rule, all the texts for our products are written in the official style, so the use of emoji in resource files was an interesting experience - in OS X they are supported out of the box, in Ubuntu it was enough to add the font to the system ( <i>sudo apt-get install ttf- ancient-fonts</i> ), and on Windows, tricks were needed so that translators could see emozdi in localization files.  We tried to insert emoji into .po files using codes, but not all operating systems can read them (for example, users of Windows desktop clients have seen text codes instead of them).  Apparently, there are two reasonable solutions: either select the .po-files editor, which displays all emoji, or replace them with codes, but convert them into emoji on our side.  We think in the direction of the second option - but be that as it may, the user of these torments will not even notice. <br><br>  Another feature that we keep in mind when developing: the same emoji look different on different devices and are not supported everywhere at all.  Emojipedia helped with the solution of this problem - in it you can see if there are any emoji you need on various platforms, and also copy emoji or its code and paste it into a .po file. <br><br>  And a small snag that we encountered: Telegram does not allow to locate the bot completely, the description of the bot and the hints in the input field are always in any one language (in our case, in English).  We hope that a solution for this will appear in the next releases of the Telegram Bot API. <br><br>  In general, the development, internal testing and localization took us 3 months with a team of 7 people.  Colleagues were engaged in development in a relaxed mode in parallel with the main work tasks, so we had enough time to ‚Äúmeditate‚Äù on the logic of the bot's work.  In this mode, it is most difficult to perform load testing - for the main stress test several dozens of employees with Telegram accounts were invited and fed a bot from a thousand files using a conditional signal.  We hope that the influx of curious testers from the Habr will not incapacitate us, but if anything - over time, we will connect additional capacity, do not judge strictly. <br><br>  As far as we know, no one has yet done antivirus bots, therefore there is a wide field for experiments.  We will be happy if you share your thoughts and experiences with our bot: <a href="http://telegram.me/drwebbot">@drwebbot</a> </div><p>Source: <a href="https://habr.com/ru/post/278497/">https://habr.com/ru/post/278497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278483/index.html">Special folders. Translation from Richard Siddaway's Blog</a></li>
<li><a href="../278485/index.html">What is bad to be full stack by the enterprise administrator</a></li>
<li><a href="../278491/index.html">Creating a system of placing objects by level using the blueprint editor. Part 2: Adding a Preview Window</a></li>
<li><a href="../278493/index.html">Compile SQLCipher for Android x86</a></li>
<li><a href="../278495/index.html">Magic Tensor Algebra: Reboot</a></li>
<li><a href="../278501/index.html">Published records of the conference reports ALM Summit 2016</a></li>
<li><a href="../278503/index.html">JS testing. Karmic webpack</a></li>
<li><a href="../278507/index.html">Usability Lynch: looking for interface vulnerabilities in CMS Diafan</a></li>
<li><a href="../278511/index.html">Third Beta Candidate - Vivaldi 1.0.403.20</a></li>
<li><a href="../278513/index.html">Meet linear models</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>