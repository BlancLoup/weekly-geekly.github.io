<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Annealing Simulation Method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dear friends, Good day! 

 This type of optimization algorithms, such as genetic algorithms, has already been discussed more than once. However, there...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Annealing Simulation Method</h1><div class="post__text post__text-html js-mediator-article">  Dear friends, Good day! <br><br>  This type of optimization algorithms, such as genetic algorithms, has already been discussed more than once.  However, there are other ways to find the optimal solution in problems with many degrees of freedom.  One of them (and, I must say, one of the most effective) is the method of simulating annealing, which has not yet been described here.  I decided to eliminate this injustice and introduce you to this wonderful algorithm in the simplest possible words, and at the same time give an example of its use for solving a simple task. <br><br>  I understand why genetic algorithms are so popular: they are very figurative and, therefore, easy to understand.  In fact, it is easy and extremely interesting to present the solution of a certain task as a real biological process of the development of a population of living beings with certain properties.  Meanwhile, the annealing algorithm also has its prototype in the real world (this is understandable from the very name).  True, he came not from biology, but from physics.  The process simulated by this algorithm is similar to the formation of a crystalline structure by a substance with minimal energy during cooling and solidification, when particles at high temperatures randomly move, slowly slowing down and freezing in places with the lowest energy.  Only in the case of a mathematical problem, the role of the particles of matter is played by the parameters, and the role of energy is the function characterizing the optimality of the set of these parameters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  To begin with, those who have forgotten, let me remind you what kind of tasks we are trying to solve with such exotic methods.  There are a number of problems whose exact solution is extremely difficult to find due to the large number of variable parameters.  In general, we have a function F, whose minimum (maximum) we need to find, and a set of its parameters x1..xn, each of which can independently vary within its limits.  Parameters and, accordingly, the function can change both discretely and continuously.  It is clear that such a function is likely to have a complex dependence on the input data, which has many local minima, while we are looking for a global minimum.  Of course, there is always an option to solve the problem by exhaustive search, but it works only in the discrete case and with a very limited set of inputs.  This is where optimization algorithms begin to work. <br><br>  In order not to be dry, I will immediately tell you about the task that I will solve in the framework of this article.  Imagine a checkered board of size m by l.  The side of the cell is one.  On the board, you need to find such an arrangement of n points so that the length of the minimum polyline connecting these points is maximum.  Normal minimax task.  Obviously, in this case, the function F considers the length of the minimum broken line for a certain arrangement of points, and its parameters are the x and y coordinates of the points, i.e.  2 * n parameters. <br><br><h5>  Actually, the algorithm </h5><br>  So, there is a function that characterizes the system, and a set of coordinates on which this function is given.  First of all, you need to set the initial state of the system.  To do this, take just any random state.  Next on each kth step we <br><ol><li>  we compare the current value of F with the best found;  if the current value is better - change the global best </li><li>  randomly generate a new state;  the probability distribution for it should depend on the current state and the current temperature </li><li>  calculate function value for generated point </li><li>  accept or not accept the generated state as current;  the probability of this decision should depend on the difference between the functions of the generated and current states and, of course, on the temperature (the higher the temperature, the more likely it is to accept a state worse than the current one) </li><li>  if the new state is not accepted, we generate another one and repeat the actions from the third item; if accepted, proceed to the next iteration, lowering the temperature (but more often the transition to the next step is performed in any case to avoid a long loop) </li></ol>  The process stops when a certain temperature is reached.  The substance has cooled at the point with the minimum energy. <br>  Why do we need such a complex scheme with probabilities of transitions from point to point?  Why not just move strictly from more energy to less?  The thing is in the already mentioned local minima, in which the solution can simply get stuck.  To get out of them and find the minimum global, it is necessary from time to time to increase the energy of the system.  In this case, the general tendency to search for the lowest energy is saved.  This is the essence of the method of imitation annealing. <br><br><h5>  And again about the points on the board </h5><br>  Now that the general scheme of the algorithm is clear, let us return to our sheep.  We will implement the task in java.  To begin with we will describe a board with points on it. <br>  Board: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Point[] points; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ points = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[n]; N = n; width = w; height = h; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Board board)</span></span></span><span class="hljs-function"> </span></span>{ points = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[board.points.length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; points.length; i++) points[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(board.points[i].getX(), board.points[i].getY()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = board.width; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = board.height; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPointsCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> points.length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> points[index]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Point p)</span></span></span><span class="hljs-function"> </span></span>{ points[index] = p; } }</code> </pre>  And the point: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.sqrt((x - px) * (x - px) + (y - py) * (y - py)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xBorder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yBorder)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(((x + dx) &lt; xBorder) &amp;&amp; ((x + dx) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) x += dx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(((y + dy) &lt; yBorder) &amp;&amp; ((y + dy) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) y += dy; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } }</code> </pre>  Since the order of the points is important for calculating the function we are looking for, we introduce their ordered set: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polyline</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point p[]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Polyline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Num)</span></span></span><span class="hljs-function"> </span></span>{ N = Num; p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[N]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (N - <span class="hljs-number"><span class="hljs-number">1</span></span>); i++) { d += p[i].dist(p[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; } }</code> </pre>  Now we need the function F, which searches for the minimal broken line of a given layout and counts its length. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinPolyline</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> bestDist; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Polyline bestMinPolyl; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Board board; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Polyline </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Board b)</span></span></span><span class="hljs-function"> </span></span>{ N = b.getPointsCount(); board = b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] perm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> used[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { perm[i] = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; used[i] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } bestDist = Double.MAX_VALUE; permute (<span class="hljs-number"><span class="hljs-number">0</span></span>, perm, used); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestMinPolyl; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first_index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] perm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] used)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_index == N) { Polyline polyl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Polyline(N); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++){ polyl.p[i] = board.getPoint(perm[i] - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bestDist &gt; polyl.dist()){ bestDist = polyl.dist(); bestMinPolyl = polyl; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; N+<span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (used[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; perm[first_index] = i; used[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; permute(first_index + <span class="hljs-number"><span class="hljs-number">1</span></span>, perm, used); used[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }</code> </pre> <br>  Well, all the preparations have been made.  Now we can begin to implement the algorithm itself. <br><br><h5>  Algorithm implementation </h5><br>  Returning to the general scheme, we will find there mention of two distributions, depending on coordinates and temperature.  They need to somehow define.  In addition, we need a law that will change the temperature from iteration to iteration.  By selecting these three functions, we will compose a specific scheme of the annealing method.  It must be said that there are several modifications of the algorithm, differing from each other by distributions and the law of temperature variation.  They have their pros and cons, such as speed, a guarantee of finding a global minimum, the complexity of execution. <br>  I chose a modification for my task called superfast annealing ("Very Fast Annealing").  To begin with, we will determine the distribution of the probability of taking a new state. <br><img src="http://habrastorage.org/storage2/4ae/219/3f7/4ae2193f725050c12f898d011b4bfb20.png"><br>  or in code: <br><pre> <code class="java hljs">h = <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">1</span></span> + Math.exp(-(minPolyl.F(board).dist()- maxDist) / T));</code> </pre>  Thus, the probability of accepting a position with a worse result of a function (with higher energy) is lower, the lower the temperature and the greater the difference between the current energy and the optimal one.  Next, we establish the law of decreasing temperature.  A distinctive feature of ultrafast annealing is that changes in all coordinates are considered independently, and even the temperature for each coordinate is determined by its own: <br><img src="http://habrastorage.org/storage2/8cf/ece/43e/8cfece43e8474571678c3dfa125ccaf5.png"><br>  Where D is the number of coordinates (ie, 2 * n), k is the move number.  However, for simplicity, we will do the total temperature: <br><pre> <code class="java hljs">T = To * Math.exp(-decrement * Math.pow(i, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) / (<span class="hljs-number"><span class="hljs-number">2</span></span>*(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)N)));</code> </pre>  As you can see, the temperature will decrease exponentially, and the procedure will end quickly. <br>  Finally, the distribution for the new coordinates.  The following value characterizes the relative change of one coordinate: <br><img src="http://habrastorage.org/storage2/5d8/328/36b/5d832836b5037e91284f209414272a80.png"><br>  Where alpha is a value uniformly distributed on the interval [0, 1].  If the new coordinate does not fit into the scope of its change (in our case, it goes beyond the board), then the calculation is performed again. <br><pre> <code class="java hljs">z = (Math.pow((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>/T), (<span class="hljs-number"><span class="hljs-number">2</span></span> * alpha - <span class="hljs-number"><span class="hljs-number">1</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * T; x = board.getPoint(moveNum).getX() + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(z * border);</code> </pre>  Now we have all the necessary allocations and functions.  It remains only to put everything together.  As input data you need to pass the dimensions of the board, the number of points, the initial and final temperature and the damping factor of the temperature exponent. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnnealingOptimizer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnnealingOptimizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ N = n; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Board </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> To, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decrement)</span></span></span></span>{ Board board = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Board(N, width, height); Board bestBoard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Board(N, width, height); Random r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxDist = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> T = To; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> h; MinPolyline minPolyl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MinPolyline(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j){ board.setPoint(j, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(r.nextInt(height), r.nextInt(width))); bestBoard.setPoint(j, board.getPoint(j)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (T &gt; Tend){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveNum = <span class="hljs-number"><span class="hljs-number">0</span></span>; moveNum &lt; board.getPointsCount(); ++moveNum){ NewX(board, moveNum, T, width, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); NewX(board, moveNum, T, height, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minPolyl.F(board).dist() &gt; maxDist){ bestBoard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Board(board); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ h = <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">1</span></span> + Math.exp(-(minPolyl.F(board).dist()- maxDist) / T)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r.nextDouble() &gt; h){ board = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Board(bestBoard); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ bestBoard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Board(board); } } maxDist = minPolyl.F(board).dist(); T = To * Math.exp(-decrement * Math.pow(i, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) / (<span class="hljs-number"><span class="hljs-number">2</span></span>*(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)N))); ++i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestBoard; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewX</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Board board, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> moveNum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> border, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xCoord)</span></span></span><span class="hljs-function"> </span></span>{ Random r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = r.nextDouble(); z = (Math.pow((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>/T), (<span class="hljs-number"><span class="hljs-number">2</span></span> * alpha - <span class="hljs-number"><span class="hljs-number">1</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xCoord){ x = board.getPoint(moveNum).getX() + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(z * border); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; border) &amp;&amp; (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) { board.getPoint(moveNum).move((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(z * border), <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { NewX(board, moveNum, T, border, xCoord); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = board.getPoint(moveNum).getY() + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(z * border); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; border) &amp;&amp; (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) { board.getPoint(moveNum).move(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(z * border), width, height); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { NewX(board, moveNum, T, border, xCoord); } } } }</code> </pre> <br>  It should be noted that some modifications of the annealing imitation method provide a statistical guarantee for finding the optimal solution.  This means that with the right choice of parameters, the algorithm will find the optimal solution in a reasonable time without going through all the inputs.  This implementation finds the answer for a 12x12 board and 5 points in approximately 15,000 iterations.  Let me remind you that the total number of placement options is 12 ^ 10.  Obviously, the difficulties of setting parameters are worth such a win.  By the way, the method of annealing in terms of speed and accuracy at least does not lose to the genetic algorithm, but more often it is ahead of it. <br>  Finally, a visual result of the algorithm. <br><img src="http://habrastorage.org/storage2/008/a0c/457/008a0c4579e8b581db8403e909442041.png"><br>  References: <br>  <a href="http://cs-seminar.spb.ru/reports/52.pdf">A. Lopatin "Annealing Method"</a> </div><p>Source: <a href="https://habr.com/ru/post/112189/">https://habr.com/ru/post/112189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112184/index.html">Fairware</a></li>
<li><a href="../112185/index.html">Questions on the promotion of applications for Android</a></li>
<li><a href="../112186/index.html">Scholarships Do they need?</a></li>
<li><a href="../112187/index.html">Tomsk StartPoint Announcement</a></li>
<li><a href="../112188/index.html">qutIM 0.3 now on N900</a></li>
<li><a href="../112190/index.html">Do I need a touchpad laptop (no) beech?</a></li>
<li><a href="../112191/index.html">Array HP P4000 can now work as a NAS-server</a></li>
<li><a href="../112192/index.html">DirectAccess in Windows 7. Part 3</a></li>
<li><a href="../112193/index.html">Using mod_macro to configure Apache virtual hosts</a></li>
<li><a href="../112196/index.html">On Habr√© open beta testing of new ICQ 7.4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>