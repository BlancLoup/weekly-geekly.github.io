<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Booking.com search architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the HighLoad ++ 2016 conference, Ivan Kruglov talked about how the Booking.com service developed its search - one of the central functions of the o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Booking.com search architecture</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d07/a0e/9b1/d07a0e9b189d46ca88e8559fbf2e4f8f.jpg"><br><br>  <em>At the <a href="http://www.highload.ru/">HighLoad ++</a> 2016 conference, Ivan Kruglov talked about how the Booking.com service developed its search - one of the central functions of the online hotel booking system.</em> <br><br>  Hello!  I am Vanya, I write in Perl - you can sympathize with me.  [Light laugh in the hall and from the stage.] 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Okay.  Seriously, my name is Ivan Kruglov, I'm from the company Booking.com, from the city of Amsterdam.  I have been working there for the last 4 years, where for the last year and a half I have been working in a team that makes our search better. <br><br>  I want to start a little distance.  Here is from this phrase: <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/165/9cc/2bb/1659cc2bbbfa4c76b4336a87c7880718.png"><br><br>  Do not be surprised if you do not know the author, this is my colleague Eduardo Shiota.  Why do I want to show it?  In my opinion, it very accurately reflects the culture of developing Booking.com.  Its essence is that we must ensure the best impression, the best experience, grow and adapt quickly to the needs of our customers. <br><br>  There are several components here, I want to briefly run through each of them, at the same time tell about Booking.com.  We first presented on HighLoad ++.  I think you will be interested. <br><br><h1>  Statistics </h1><br>  Let's start with growth.  We grow like this: <br><br><img src="https://habrastorage.org/files/699/7c4/10b/6997c410bbf64feba98d1cea05828adb.png"><br><br>  The blue graph is the number of accommodation facilities that are currently in the database.  Accommodation facilities are hotels, villas, apartments, and so on.  At the moment there are about 1 million.  The orange line is the number of nights booked daily.  Through Booking.com daily booked over 1 million nights. <br><br>  The second is quick adaptation.  To adapt, you need to understand what your client wants.  How to do it?  We use this method: we make some observation, then we build a hypothesis why this is happening, and we check this hypothesis.  If something went wrong, it means that our observations are incorrect, or its interpretation suffers.  We go fix, try again.  Most of these options.  If our test showed ‚Äúeverything is OK,‚Äù then everything is fine, we can move on to the next observation. <br><br>  The mechanism that we use to confirm these hypotheses is A / B testing or experiments.  Experiments allow us to say with some statistical accuracy, yes or no. <br><br>  There are many experiments, they are different.  Experiments are such when we change something graphic on the site: <br><br><img src="https://habrastorage.org/files/aa9/db4/12b/aa9db412b6eb4772924a315f3563088b.png"><br><br>  The classic example is the color of the button, either they added or changed the icon, or they added a new feature, a block appeared, a new item in the menu, and so on.  This is something that is visible to the user. <br><br>  The second kind of experiment is when something has changed inside.  For example, we have a new API, or some new service, or we just upgraded or some package.  In this case, we want to collect quantitative characteristics.  Here on the slide is the response time distribution.  The top is what was.  Below is what became. <br><br><img src="https://habrastorage.org/files/55a/4c2/9fd/55a4c29fd5804f51b8770f7273e485d8.png"><br><br>  The next and most important point is that we want to confirm that our user has not become worse from our innovation, that is, his experience has not deteriorated. <br><br>  There is another type of experiment that is very extensive and covers everything.  Conventionally, it can be represented as: <br><br><img src="https://habrastorage.org/files/26b/ac0/53c/26bac053cc5846ea8d38f428b00a0e19.png"><br><br>  What do I want to say here?  It is clear that I am exaggerating a little, no one immediately pulls the code into production.  But there is no testing - it is very minimal, it is performed by the developer himself. <br><br>  We have very good monitoring, there is a good experiment tool, which allows us not only to run our experiment on some part of the traffic, but if something happens, we can quickly understand, put out the fire and move on.  Plus, we have an error budget - error tolerance, which significantly reduces the moral burden on the developer.  A set of these factors allows us to pay more attention to the business side of the issue than to the quality of its implementation. <br><br>  If you count the number of experiments that are currently running on Booking.com, they will get more than a thousand.  Such a number of experiments need to write, zadelopit.  Preparing for the report, I looked at the statistics for the last year.  It turned out that on average we do about 70 deployes per day.  If this is put on a standard eight-hour working day, then it turns out that some part of the Booking.com site changes every 5-10 minutes. <br><br><h1>  Best experience </h1><br>  In order for our user to have the best impression, the entire company - not just the IT department - has to assemble a big puzzle.  There are many elements in this puzzle, some less obvious, some more obvious, some less important, some super-important.  For example, the list might look like this: <br><br><img src="https://habrastorage.org/files/ed1/7b3/c96/ed17b3c96e6144259b05d369dab3abfd.png"><br><br>  It is clear that the list is incomplete, just an example.  One big obvious point that should be here is a good search, which, in turn, should provide two things: it should be fast, it should give up-to-date information.  In my report, I will talk about these two things: the speed and relevance of information. <br><br>  Let's talk a little about speed.  Why is speed important?  Why do we all make our sites faster? <br><br>  Someone does to compete with competitors.  Others do so that customers do not leave them, there was more conversion.  If we ask Google, it will give us many articles that will talk about it.  This is all so, on Booking.com we do it all.  But we single out for ourselves another interesting component. <br><br>  Let's imagine that we have a conditional search page, which conditionally takes two seconds.  Imagine that these two seconds are our threshold, after which our client becomes ill.  If within our search page our main search logic takes 90% of the time, then for all features, for all other experiments, only 10% of the time remains.  If we suddenly launched some kind of hard experiment, then it can push us beyond two seconds. <br><br>  If we did it quickly, the search began to occupy only 50% of the time, then a lot of time was freed up for new features, for new experiments.  One of the things why we do on Booking.com quickly - we want to free up time for experiments, under the features. <br><br><h1>  Search </h1><br>  Then we talk about the search and what is special about it.  We will talk about the evolution of the search, about its current architecture and conclusion. <br><br>  I want to start with an example.  Let's imagine that we have a guest who wants to go to Paris.  He can go there alone, with his family, with friends, by car, if he lives close (then it is desirable that he has a parking lot, where he will stop), and he can also go by public transport (then it would be nice if the stop was not far).  And of course, he wants breakfast.  The task of Booking.com is to help him find a temporary place of residence that meets all his requirements. <br><br>  What does the interaction of our guest with the site look like in this case?  He first comes to the main page.  There is a form there, I think you all know it.  He drives a "Paris".  He immediately begins to interact with the autocomplete &amp; disambiguation service (clarifying ambiguities), the purpose of which is to help us understand exactly what geo-location he has in mind. <br><br><img src="https://habrastorage.org/files/989/2c7/a5b/9892c7a5bbe043c39072f79e308bf666.png"><br><br>  The fact is that if you simply search for the word "Paris", then it turns out that there are about 30 pieces in Paris all over the world.  For example, the village of Paris, Kiginsky district, Republic of Bashkortostan, Russia.  This is hardly what he had in mind.  There is a village in Belarus, even two, one island of the Pacific Ocean, there are 10-15 pieces in the USA. <br><br><img src="https://habrastorage.org/files/6d2/c8e/3f1/6d2c8e3f19534481a32dacd691130055.png"><br><br>  Our user begins to see a list where he can choose what he means. <br><br><img src="https://habrastorage.org/files/2b3/0de/fe0/2b30defe0a7f48af8eedf28e04513c79.png"><br><br>  If there is no element in the list, then our guest will be redirected to disambiguation, where, in fact, the same data, only the list is a little more - a couple of dozen elements. <br><br><img src="https://habrastorage.org/files/f5e/c34/7eb/f5ec347eb9274bc095c69b0b0dfc4ddd.png"><br><br>  As soon as our guest has explained what he wants (I want in that same Paris), a search query is formed in the search logic, which does the following: <br><br><ul><li>  It <strong>selects a hotel by attributes</strong> , for example, filters hotels that do not have a parking, or which do not have breakfast. </li><li>  Then she does, if necessary, <strong>group fit</strong> .  If our guest travels with his family, the family is large - 6 people, but we do not have a room that accommodates 6 people, we can try to play: 3 + 3, 4 + 2, 5 + 1. </li><li>  Next is the <strong>selection of hotels for availability</strong> . </li><li>  And in the end the <strong>ranking</strong> . </li></ul><br>  When the search service has worked, a search page is formed, on which our guest reads the description and review, looks at the prices, chooses.  As a result, goes to the final stage - booking.  At Booking.com - new booking, success, all is well. <br><br><img src="https://habrastorage.org/files/501/3eb/94a/5013eb94ab284893ad2f57a81ac99a77.png"><br><br>  Here I want to make two digressions.  First, my further report will be about that search box, I will focus on the search logic, what is going on inside there.  Second - I have already mentioned the selection for availability.  Let me tell you what I meant to make it clear. <br><br>  Here you need to define two terms.  The first is <strong>inventory</strong> , availability.  The second is <strong>availability</strong> .  What is the difference? <br><br>  Let's imagine that we have the ‚ÄúHouse with a Pipe‚Äù hotel.  There is one room in it, and its owner wants to hand over this hotel for the New Year holidays.  He set the following prices: <br><br><img src="https://habrastorage.org/files/85d/63a/6e8/85d63a6e83c14e73bc8174d695349a44.png"><br><br>  From January 1 to 2 - 2000 ‚ÇΩ, from 2 to 3 - 1750 ‚ÇΩ and so on.  This is the data our hotel works with.  Hotel, room, date, price. <br><br>  From the point of view of our guest, everything looks a little different.  He thinks like this: ‚ÄúI want to stay in the‚Äú House with a pipe ‚Äùhotel from January 1 to January 5, its price for me will be 6500 ‚ÇΩ‚Äù.  The data is the same, the presentation is slightly different.  The transition between these representations is not always trivial. <br><br><img src="https://habrastorage.org/files/9c9/c36/add/9c9c36add0c8457683177ca5beb8feda.png"><br><br>  In this case, it is simple, we just take and summarize them.  And if we have a big hotel where there are a lot of rooms, a lot of tariffs, a lot of policies, some rooms may be occupied, some politicians may be unavailable?  The result is a non-trivial price calculation function. <br><br><h1>  Search evolution </h1><br>  With the introduction finished, it was determined with the search, I introduced the terminology.  Let's go to hardcore. <br><br>  In ancient times, when we had fewer than 100,000 hotels in our database, Booking.com used a warm LAMP stack.  LAMP - Linux, Apache, MySQL and P - not PHP, but Perl.  Also Booking.com used monolithic architecture.  Business processes were as follows: <br><br><img src="https://habrastorage.org/files/eb6/0af/0f8/eb60af0f8b20487cbf9e509f8a263273.png"><br><br>  Our hotel.  There is an inventory database in MySQL, the hotel brings in the data: I am such a hotel, I have such a room, on such and such days my price.  Next, we have search logic that pulls data from the inventory database, calculates availability and gives the search result to our guest.  Then the guest goes to the stage ‚ÄúI am booking‚Äù.  The logic of this stage goes to the inventory database and makes a minus-minus to some record, saying that there is no such number anymore. <br><br>  In the area of ‚Äã‚Äã2010, when there were about 150,000 hotels in the database, this approach has completely exhausted itself.  The problem was in the difficult calculation of availability.  This feature was very heavy.  To better understand what the pain was, here is an example: <br><br><img src="https://habrastorage.org/files/f02/b07/467/f02b07467d8742119e12faa10d32293d.png"><br><br>  If at that time there were 500 hotels in the database, each with an average of 3 types of room, 2 tariffs, then in order for us to sample and sort it by price, you need about 3 thousand calculations.  According to archival data, our stack could give something like this: <br><br><img src="https://habrastorage.org/files/f6b/fde/a78/f6bfdea787454a369327aad6bdd27e32.png"><br><br>  In one second I could calculate only 1000 prices for living in one day and only 90 for living in 30 days.  The longer our stay, the more options we need to go through. <br><br>  By the way, for this reason, in Booking.com for some time in 2008 there was no sorting by price.  I personally remember the first time I came to Amsterdam while still a student.  There was little money, I want to find the cheapest hotel.  I could not sort by price for just this reason.  Now this is all good. <br><br>  What to do? <br><br><ul><li>  The first thing that came to mind colleagues - let's all <strong>caches</strong> .  It did not work.  It turned out that the max cache hit ratio was only 60%. </li><li>  Let's rewrite everything to a <strong>new technology</strong> .  We decided not to do so.  Why?  First, the monolithic architecture.  That is, if you rewrite, then you need to rewrite most of it, it takes a lot of time.  Secondly, agility will suffer.  Companies need to move forward.  Let's see what is better? </li><li>  Let's try to <strong>materialize</strong> everything. </li></ul><br>  What is materialization?  In this context, this is about the following.  Returning to the example, we take and simply predict all possible combinations of check-in and length of stay.  For example, from the 1st to the 2nd, from the 1st to the 3rd, from the 1st to the 4th, from the 1st to the 5th, from the 2nd to the 3rd, from the 2nd go to 4th and so on  We take and consider everything in advance. <br><br><img src="https://habrastorage.org/files/ea7/e6b/d05/ea7e6bd053044e548bfa10a5e7879677.png"><br><br>  We get good performance, because everything is calculated in advance, we just need to pull out this price.  It turns out an even way, which is important.  We don‚Äôt have a fast path when data comes from a cache, for example, and slow when it‚Äôs not in a cache.  The disadvantage is a huge amount of data.  We need to keep all these options. <br><br>  On this option, and stopped.  To understand how huge this data is, I'll show you the current information: <br><br><img src="https://habrastorage.org/files/879/7fb/11d/8797fb11d5ef42a38df77ef6c9b6e808.png"><br><br>  At the moment there are 1 million hotels, 3 types of rooms, 2 tariffs, from 1 to 30 days the duration of stay.  (It is impossible to book a hotel for 2 months in Booking.com for a maximum of 30 days.) Data is considered approximately one and a half years in advance.  If you multiply all these numbers, it turns out that about 100 billion prices are currently stored in Booking.com. <br><br><h1>  Business processes in the case of materialization </h1><br><img src="https://habrastorage.org/files/83b/8f7/f21/83b8f7f217a1404ca6eebef2a3594eeb.png"><br><br>  Familiar hotel, familiar inventory database.  A new availability base and a materialization process appear, which materializes prices and adds them to the availability database.  The search logic uses pre-calculated prices, and the booking logic still changes the data in the original inventory database.  It turns out that inventory is our primary database in which the whole truth lies, and availability is its some cache, in which the hit ratio is always 100%. <br><br>  With this scheme, there are two challenges.  The most important thing: how to make it so as not to spoil the user experience?  How not to make it so that we first said in the search logic that there is such a hotel, there is such a number, and then, when we went to the booking stage, we said that it does not exist?  We need to maintain our two databases in a consistent form. <br><br>  In order to solve this problem, made the following observation.  I return you to the diagram, which I have already shown, how our user interacts with the service. <br><br><img src="https://habrastorage.org/files/d04/00d/4af/d0400d4af0254fb4a28b41310b68edf6.png"><br><br>  Look at this part, when the search selection was given, the transition to the stage ‚ÄúI am booking‚Äù.  Here you can see that the time that the user spends here takes minutes: 5-10 minutes while we read the review, while we read the description.  It turns out that when our guest moved to the booking stage, it may happen that the last room he wanted to book has already left.  There is some natural inconsistency in the business model. <br><br>  Even if we make our two databases absolutely consistent, there will always be a percentage of errors at the ‚ÄúI book‚Äù stage simply because that is nature.  We thought, why would we then make the data completely consistent?  Let's make them inconsistent, but the level of errors that occurs due to this inconsistency will be no higher than the threshold that is due to business processes. <br><br><h1>  Pipeline </h1><br><img src="https://habrastorage.org/files/71f/5c4/363/71f5c43633614f27ab62a5e347aba628.png"><br><br>  First of all, we have sources of updates.  Whenever they make a change to inventory, they send a notification to one of the global queues.  The notice is, for example, ‚Äúsuch a hotel, they have booked a room‚Äù or ‚Äúsuch a hotel has changed the price‚Äù. <br><br>  There are two lines, one is realtime, the other is batch, this is a backlog.  This is done to set some priorities.  If we have a reservation for tomorrow, it makes sense to count faster than a reservation for the year ahead. <br><br>  Further notifications flow into one of the materialization clusters, where there are many materialisers.  They are specially made over capacity so that in the event of a problem, we can quickly pounce on our line, quickly calculate everything and quickly add everything to the base of availability.  They pull the data from the inventory database, sort through all the possible options and put in the availability. <br><br>  There is one interesting point.  The blue button ‚ÄúI am booking‚Äù sends a notification not only in the case of a successful booking, but in the case of an unsuccessful booking, in the event of an error.  In the event of an error, we know that there is potentially some inconsistency - let's calculate it just in case, that is, such a self-healing mechanism. <br><br>  The last element is the calculation of the new day.  Roughly speaking, availability is such a moving window with a size of one and a half years.  Every day we need to calculate one year and one day ahead, for example.  They always go through the batch queue for obvious reasons. <br><br><h1>  Data storage </h1><br><img src="https://habrastorage.org/files/f99/c36/edb/f99c36edb14d4c4ab8680aed47c34406.png"><br><br>  There is a lot of data, requests for reading and search requests prevail.  Therefore, optimized for reading.  Used cunning clustered primary key index, stored in MySQL. <br><br>  Why clustered?  Why geo-location?  Whenever a search is performed, it is performed on a group of hotels that are close to each other - this is a property of locality.  It would be good if those hotels that are geographically close in reality, were close to the database.  So that our poor MySQL would not have to run on our disk in different directions.  The more compact the data is on the disk, the better. <br><br>  For this we used the Z-order curve technique, I will not dwell on it, everything is very simple there.  More on the <a href="https://goo.gl/24mFR8">link</a> . <br><br>  Did sharding on check-in.  There are many entries: a single inventory entry can cause thousands of entries changes in availability.  Therefore, we had to use SSD - hard drives did not hold the load.  The load was 4 thousand IOPS. <br><br><h1>  results </h1><br><ul><li>  Received the acceleration of the calculation of availability in the 50-100 times.  We do not need to count, everything is counted, just take and pull out the right. </li><li>  Due to the cunning clustered MySQL-index, we got a quick cold start.  All data are close to each other, you need to pull up a few pages from the disk. </li><li>  Got the materialization time in normal less than a minute.  In practice - tens of seconds. </li><li>  In order to make sure that our initial assumption is valid, we have overlaid the system from head to foot with all sorts of metrics and alerts.  The key metric was quality check.  Quality check is some kind of external process that selects from availability, selects from inventory, reads the availability based on this data, and compares.  If our data matches, everything is fine.  If there is no data different, or there is no record, and there too, we send a notification, some kind of alert.  There are always such alerts, but it is critical that they do not go beyond a certain threshold. </li></ul><br>  Materialization solved the problem for a sufficiently long period of time.  During this time, the stack has changed a bit, they began to use uWSGI + Nginx + Perl + MySQL. <br><br>  In the area of ‚Äã‚Äã2014, there were about half a million hotels in the database, there was a growth in business, new features appeared, a search appeared by countries and regions.  For example, in Italy - 100 thousand hotels. <br><br>  We rested on the same problem, only slightly from the other side.  The problem was that we have Perl, it is single-threaded.  One request is processed by one worker.  He is not able to digest all these samples, sortings and so on. <br><br>  What to do?  We decided to parallelize the whole thing according to the Map-Reduce scheme.  Wrote your Map-Reduce framework.  Switched to service-oriented architecture.  And got the following results: we have big requests have become faster.  Due to this, our request beats to smaller ones, it is sent to the worker, the worker looks at his small parts, sends the data back to the main worker, he merges the whole thing and builds the final result. <br><br>  Large queries have become faster, but at the same time the search around the world began to take about 20 seconds.  Still not very good, but better than it was.  The counter result was that small queries became slower.  The reason for this is big IPS overheads, in particular, for serialization and data transfer between processes.  Perl is single-threaded, and we can only serialize it with a variety of processes. <br><br>  This is about the time when they began to think about changing the architecture that led us to the architecture that we are currently using. <br><br><h1>  Current architecture </h1><br>  We understood that if we modernized what we had, tweak, tune, change workflow, then in the trailer it can be made to work for some time.  But the stack was close to exhausting its capabilities.  Our camel is a little tired. <br><br>  I wanted to abandon outdated approaches.  The architecture was built on the approaches under which the foundation was laid 5-10 years ago, when there were 50‚Äì100 thousand hotels in the database.  Those approaches that were used at that time are very poorly suited when we have 500,000 or even a million hotels in our database, as at the moment. <br><br>  I wanted to save MapReduce, I wanted to save the service-oriented architecture.  I wanted our service to have quick access to availability and all other data that is needed to fulfill a search query.  I wanted a fast database to write to quickly.  For us update availability.  I wanted to have cheap concurrency. <br><br>  Looked around.  We liked Tarantool, we tried it.  That was about a year and a half ago.  However, they decided not to use it for the following reasons. <br><br>  First of all, we were greatly embarrassed by the fact that if we switch to Tarantool, we will have to write all the business logic on Lua.  We don't know her very well, even though she is a good student.  It's one thing when you have a script, a small stored procedure, another thing is the whole business logic on Lua.  The second is the code that we took and immediately wrote on Lua, we did not work as fast as we would like.  We had a parallel implementation in Java.  Java code worked faster. <br><br>  In the end, we decided to switch from Perl to Java.  Java gives cheap multithreading, less constant factor.  Java is basically faster, it has fewer internal overheads.  We decided that all the data we have is in-memory for quick access.  We decided that we are switching from MySQL to RocksDB. <br><br><h1>  Architecture </h1><br><img src="https://habrastorage.org/files/212/e57/aed/212e57aedb49431da0cebf6cf0af43ff.png"><br><br>  The search node is in the center of everything, its availability database is locally embedded.  This means that the database is in the same namespace as your process.  This node has in-memory indexes, there is an in-memory database that is persisted. <br><br>  Nodes are many, they are combined into a cluster.  In rows - shards, in columns - replicas.  We apply static sharding; we assign handles to each node which shard it belongs to.  The number of shards is such that all our data is stored in the memory of the node.  We spread the data using the simple ‚Äúdivision with remainder‚Äù operation, hotel_ id mod N. All replicas are equivalent.  We have no master, we are all peer, there is no interaction between the nodes. <br><br>  Now our search query falls on one of the coordinators, there are many of them.  The task of the coordinator is to make a scatter-gather when we take a request and broadcast it to all shards.  Each shard, after processing its local data, sends a request back to the coordinator, which merges this data and forms the final result. <br><br>  Inside the shards a replica is selected randomly.  If the replica is not available, we take and try another.  Coordinators constantly ping all nodes to understand the current state of our cluster. <br><br>  In fact, this is a standard search engine, the same Yandex or Google work about the same.  We have a cherry here in the form of availability, we need to update the embedded databases, we need to update them in realtime, because the availability changes constantly. <br><br>  To do this, we used our existing experience based on Perl and MySQL.  We used the same Pipeline with a slight change: instead of writing data directly to the databases, we wrote to the materialized queue availability.  Why is she materialized?  Within the black square of materialization, all the queues were only notifications, that is, the orange queues are the data itself, the meat itself. <br><br>  How do we update the availability data?  Each node, regardless of someone takes and reads this queue, applies the update to its local state.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We counted the data once, which is very expensive, and we apply it many times. In this queue, data is stored in the last hours. If the node is lagging behind, she would be able to catch up. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this scheme, we have a cluster that is eventually consistent. In the end, if all nodes will not work at the same speed, we will stop our changes, then they will all come to the same state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This situation suits us. Here we rely on the principle that we used in the construction of materialization: we do not need to make our base completely consistent. We only need to make sure that this level of errors does not go beyond the allowable value.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, again, there is a quality check, plus we use one metric: we monitor each line, we observe how far it is behind the end of the queue. </font><font style="vertical-align: inherit;">If she is too far behind, we take her and pull her out of the cluster. </font><font style="vertical-align: inherit;">This is an automated process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see what happens inside. </font><font style="vertical-align: inherit;">We have input data:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geography: Paris; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attributes search: parking, breakfast and so on; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check-in, check-out; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The composition of the "team" (for example, a family of 6 people). </font></font></li></ol><br>       ,        .    ,   , value ‚Äî     . ,    ,    .   , ,      .        ‚Äî    , ‚Äî          . <br><br><img src="https://habrastorage.org/files/606/01b/1b8/60601b1b8df444f38dc1b4ee0bf624bb.png"><br><br>     ,    ,    ,    . :       availability,    ,   ,  ,    .    group fit.      .     topn. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if our search query said ‚ÄúI want the first page,‚Äù on page 15 queries. That is, each of the threads will pull out only the top15 and send this data to the main thread, which will do the merge. Merge it is done in the following way: it takes data from all n-threads, it turns out ntop15 and they get top15 from them. Then sends the data to the coordinator, who in turn is waiting for the results from all the shard. From each shard he got top15 and again he does top15. It turns out a cascade reduction of data. So it works inside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I promised to tell you why we stopped at RocksDB. For this you need to answer two sub-questions. Why is the embedded database? Why choose RocksDB? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is the embedded database? I want to demonstrate this sign:</font></font><br><br><img src="https://habrastorage.org/files/58a/138/1a6/58a1381a666f41969156143a83c59fea.png"><br><br>    event      latency.         .    ‚Äî    .   0,3 .   ,    1 ?        L1   3 ,   L3  ‚Äî 43 ,     ‚Äî 6 ,      ‚Äî 9 , round trip   ‚Äî 19 ,  TCP  ‚Äî 200 . <br><br>       ,    ,    ,    .      ,     ‚Äî     , MySQL, Cassandra,   ‚Äî      .     . <br><br>    RocksDB,    GitHub,    Tarantool,     ,     transaction,   QPS (Queries per second),   .     ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why RocksDB? There is a very simple story. We needed a database that would handle our workload. We didn‚Äôt need any particular features, just key-value, just store, get, delete. We tried different options: MapDB, Tokyo / Kyoto cabinet, leveldb. How did you try? We just took them into battle conditions: dataset in pagecache, 80% reading + 20% writing, reading significantly prevails. RocksDB showed us the most stable random read performance with random writes. Random record is our update availability, and happy reading is our search queries. We stopped at this.</font></font><br><br>  :  RocksDB ‚Äî Facebook.     SSD optimized   write and space amplification.          .           . <br><br>    : <br><br><img src="https://habrastorage.org/files/493/65e/623/49365e623dda4573ae8957713874f296.png"><br><br>   ‚Äì     , ,  ,  ,  . ,            .  ,      (   ,   30  ),    (,   300 ). <br><br>      ,   ,    ,   ,    .  ‚Äî  ,  ,   ‚Äî   2 .   ‚Äî  ,  , 1,3 .      700 ,       , .   . <br><br><h1>  Conclusion </h1><br>    : ,    . , ,   .     RocksDB ‚Äî      ,        ,    ,    workload.  , ,   ,    .       , ,      . <br><br>  The second.    ,      .   ,  ‚Äî     ,   ,         ,       . <br><br>   .            .   100  ,    ‚Äî  -  800 .  ‚Äî  8   . 800        ,      .   ,   .      ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Be sure to look at your business processes. </font><font style="vertical-align: inherit;">Your business processes can tell you a lot, they can significantly simplify life. </font><font style="vertical-align: inherit;">In our case, we say that it makes no sense for us to maintain the consistency of the data between the two databases, because there is a lack of consistency in the business process. </font><font style="vertical-align: inherit;">The main thing is that the level of errors that was not exceed a certain threshold. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this I have everything, thank you very much for coming! </font><font style="vertical-align: inherit;">I hope I told you something useful.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VdRmsOAvv0A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><a href="http://www.highload.ru/2016/abstracts/2310.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ivan Kruglov - Search architecture on Booking.com</font></font></a></em> </div><p>Source: <a href="https://habr.com/ru/post/323094/">https://habr.com/ru/post/323094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323080/index.html">The fate of the package. Cisco IOS XE</a></li>
<li><a href="../323084/index.html">What you need to know to use omnichannel communications?</a></li>
<li><a href="../323086/index.html">Creating images on CSS makes a maker-up better, or What to do during long winter evenings</a></li>
<li><a href="../323090/index.html">Uninvented stories about EastBanc Technologies in photos</a></li>
<li><a href="../323092/index.html">Recreating subdatasheet in table on AngularJS</a></li>
<li><a href="../323096/index.html">.Net Core, AppDomain, WCF, RPC marshalling TCP / Ip your bike</a></li>
<li><a href="../323100/index.html">IceCash 2.0 Web Workstation Cashier and AIS for exchanging data with cash registers for Linux to Python</a></li>
<li><a href="../323102/index.html">Another way to localize applications</a></li>
<li><a href="../323106/index.html">Accelerate Node.js with Rust</a></li>
<li><a href="../323108/index.html">Two providers simultaneously or Dual ISP with VRF on Cisco | Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>