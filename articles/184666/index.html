<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a game using canvas and sprites.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The web is everywhere now and offers a very powerful environment for creating and distributing applications. Instead of a cycle: writing code ‚Üí compil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a game using canvas and sprites.</h1><div class="post__text post__text-html js-mediator-article">  The web is everywhere now and offers a very powerful environment for creating and distributing applications.  Instead of a cycle: writing code ‚Üí compiling ‚Üí launch, just update the application or even write the code ‚Äúlive‚Äù in the browser.  In addition, it relatively painlessly allows you to distribute your application on a huge number of platforms.  Interestingly, in the past few years, developing games using HTML5 has become a reality. <br>  The <i>canvas element</i> was introduced with HTML5 and provides an API for working with it.  The API is simple, but if you have never worked with graphics, you will need time to get used to.  Canvas is supported by a large number of browsers, which makes the web a good platform for creating games. <a name="habracut"></a><br>  Using canvas is simple: create a tag, create a display context in javascript, and use methods such as fillRect and drawImage on this context to display forms and images.  The API contains many methods for creating a variety of contours, image conversion and more. <br>  In this article, we will create a game using canvas;  real game with sprites, tracking collisions, and of course explosions.  What a game without explosions! <br>  And here is the game we are going to create - <a href="http://jlongster.github.com/canvas-game-bootstrap/">to play</a> . <br><br><h4>  Getting ready </h4><br>  The game may seem complicated, but in fact it all comes down to using several components.  I have always been amazed at how far you can go with the canvas, a few sprites, collision tracking and the game loop. <br>  In order to fully focus on the components of the game, I will not chew every line of code and API.  This article is written by advanced-level, but I hope that it will be clear for people of all levels.  The article assumes that you are already familiar with JavaScript and the basics of HTML.  We will also touch upon the canvas API and such basic game principles as the game cycle. <br><br><h4>  Creating a Canvas </h4><br>  Let's start learning the code.  Most of the game is in <a href="">app.js.</a> <br>  The first thing we do is create a tag and set its width and height.  We do this dynamically in order to keep everything in JS, but you can create a canvas in an HTML document and get it using <i>getElementById</i> .  There is no difference between these two ways, it is just a matter of preference. <br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Create the canvas var canvas = document.createElement("canvas"); var ctx = canvas.getContext("2d"); canvas.width = 512; canvas.height = 480; document.body.appendChild(canvas);</span></span></code> </pre> <br>  <i>Canvas</i> has a <i>getContext</i> method that is used to get the display context.  A context is an object, calling methods of which you interact with the canvas API.  You can also pass the 'webgl' parameter if you want to use WebGL for 3D scenes. <br>  Next we will use the variable <b>ctx</b> to display all elements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Game cycle </h4><br>  We need a cycle of the game that would constantly update and display the game.  <a href="">Here's what it looks like</a> : <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The main game loop var lastTime; function main() { var now = Date.now(); var dt = (now - lastTime) / 1000.0; update(dt); render(); lastTime = now; requestAnimFrame(main); };</span></span></code> </pre><br>  We update and display the scenes, and then use <b>requestAnimationFrame</b> to queue up the next loop.  Indeed, it would be easier to use setTimeout (main, 1000/60), trying to display 60 frames / sec.  In top app.js itself, we wrapped the requestAnimationFrame, since not all browsers support this method. <br>  SetTimeout (main, 1000/60) is never used, as it is less accurate and spends many cycles on display when it is not required. <br>  The parameter in dt in the update function is the difference between the current time and the time of the last update.  Never update the scene using a constant value for the frame (in the spirit of, x + = 5).  Your game will work on different computers / platforms in different ways, so you need to update the scene regardless of the frame rate. <br>  This is achieved by calculating the time since the last update and expressing all displacements in pixels per second.  And the motion becomes the next x + = 50 * dt, or 50 pixels per second. <br><br><h4>  Download resources and start the game </h4><br>  The next part of the code initializes the game and loads all the necessary resources.  This is done using one of the separately written helper classes, <a href="">resources.js</a> .  This is a very simple library that loads all images and raises an event when they all load. <br>  The game includes more resources, such as images, scene data and more.  For 2D games, the main resource is images.  You need to download all the resources before running the application, in order to be able to use from immediately. <br>  In JavaScript, it is easy to upload images and use them when they are needed: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); img.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ startGame(); }; img.src = url;</code> </pre><br>  It becomes very tedious, if of course you have a lot of images.  You need to make a bunch of global variables and check for each one.  I wrote a basic resource loader to do all this automatically: <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceCache = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loading = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readyCallbacks = []; <span class="hljs-comment"><span class="hljs-comment">// Load an image url or an array of image urls function load(urlOrArr) { if(urlOrArr instanceof Array) { urlOrArr.forEach(function(url) { _load(url); }); } else { _load(urlOrArr); } } function _load(url) { if(resourceCache[url]) { return resourceCache[url]; } else { var img = new Image(); img.onload = function() { resourceCache[url] = img; if(isReady()) { readyCallbacks.forEach(function(func) { func(); }); } }; resourceCache[url] = false; img.src = url; } } function get(url) { return resourceCache[url]; } function isReady() { var ready = true; for(var k in resourceCache) { if(resourceCache.hasOwnProperty(k) &amp;&amp; !resourceCache[k]) { ready = false; } } return ready; } function onReady(func) { readyCallbacks.push(func); } window.resources = { load: load, get: get, onReady: onReady, isReady: isReady }; })();</span></span></code> </pre><br>  How it works: You call resources.load with all the images to load, and then call resources.onReady to create a callback to the event of loading all the data.  resources.load is not used later in the game, only at the start time <br>  Downloaded images are stored in a cache in the resourcesCache, and when all images are uploaded, all callbacks will be called.  Now we can just do this: <br><pre> <code class="javascript hljs">resources.load([ <span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, <span class="hljs-string"><span class="hljs-string">'img/terrain.png'</span></span> ]); resources.onReady(init);</code> </pre><br>  To get the image used resources.get ('img / sprites.png).  Easy! <br>  You can manually download all the images and run the game, or, to simplify the process, use something in the spirit of resources.js. <br>  In the above code, init is called when all images have been loaded.  Init will create a background image, hang events on the ‚ÄúPlay Again‚Äù buttons, reset and start the game, start the game. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ terrainPattern = ctx.createPattern(resources.get(<span class="hljs-string"><span class="hljs-string">'img/terrain.png'</span></span>), <span class="hljs-string"><span class="hljs-string">'repeat'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'play-again'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ reset(); }); reset(); lastTime = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); main(); }</code> </pre><br><br><h4>  Game state </h4><br>  Now we begin!  Let's get down to implementing some game logic.  In the core of each game - the "state of the game."  This is data that represents the current state of the game: a list of objects on the map, coordinates and other data;  current points, and more. <br>  Below is the state of our game: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Game state var player = { pos: [0, 0], sprite: new Sprite('img/sprites.png', [0, 0], [39, 39], 16, [0, 1]) }; var bullets = []; var enemies = []; var explosions = []; var lastFire = Date.now(); var gameTime = 0; var isGameOver; var terrainPattern; // The score var score = 0; var scoreEl = document.getElementById('score');</span></span></code> </pre><br>  It seems that a lot of things, but in fact everything is not so difficult.  Most of the variables are tracked values: when the player last shot (lastFired), how long the game is running (gameTime), is the game finished (isGameOver), terrain image (terrainPattern) and points (score).  Objects on the map are also described: bullets, enemies, explosions. <br>  There is also the essence of the player, which tracks the position of the player and the state of the sprite.  Before we get to the code, let's talk about entities and sprites. <br><br><h4>  Entities and Sprites </h4><br><br><h5>  Entities </h5><br>  Entity is an object on the map.  It doesn't matter if a ship, a bullet or an explosion are all entities. <br>  Entities in the system is a javascript object that stores information about the position of the object and much more.  This is a fairly simple system, in which we manually monitor each type of entity.  Each our entity has the property pos and sprite, and possibly others.  For example, if we want to add an enemy to the map, we do: <br><pre> <code class="javascript hljs">enemies.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>], <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-comment"><span class="hljs-comment">/* sprite parameters */</span></span>) });</code> </pre><br>  This code adds the enemy to the map, to the position x = 100, y = 50 with a certain sprite. <br><br><h5>  Sprites and animations </h5><br>  A sprite is an image that displays a representation of an entity.  Without animation, sprites are a regular image represented by ctx.drawImage. <br>  We can implement animation by loading several images and changing them over time.  This is called frame animation. <br><img src="https://habrastorage.org/storage2/2bf/b76/553/2bfb765531db73deafa220609142b475.png" alt="image"><br>  If we alternate these images from the first to the last, it will look like this: <br><img src="https://habrastorage.org/storage2/475/b5b/3be/475b5b3bec96c2896d4db44e480b4141.gif" alt="image"><br>  In order to simplify editing and uploading of images, usually everyone composes on one, this is called a sprite map.  You may already be familiar with this CSS technique. <br>  This is a sprite map for our game (with a transparent background): <br><img src="https://habrastorage.org/storage2/aeb/045/378/aeb0453784033c5b9c0a700f5952d84b.png" alt="image"><br>  We use the <a href="http://www.lostgarden.com/2005/03/game-post-mortem-hard-vacuum.html">Hard Vacuum</a> image set.  This set is a set of bmp files, so I copied the images I needed and pasted out onto one sprite sheet.  For this you need a simple graphic editor. <br>  It will be difficult to manage all the animations manually.  For this we use the second auxiliary class - <a href="">sprite.js</a> .  This is a small file that contains the animation logic.  We'll see: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sprite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, pos, size, speed, frames, dir, once</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos = pos; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> speed === <span class="hljs-string"><span class="hljs-string">'number'</span></span> ? speed : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frames = frames; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.url = url; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir = dir || <span class="hljs-string"><span class="hljs-string">'horizontal'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.once = once; };</code> </pre><br>  This is the Sprite class constructor.  It takes a lot of arguments, but not all of them are required.  Consider each of them: <br><ul><li>  <i>url</i> : image path </li><li>  <i>pos</i> : x and y coordinates of the image on the sprite map </li><li>  <i>size</i> : sizes (single frames only) </li><li>  <i>speed</i> : speed of animation in frame / s </li><li>  <i>frames</i> : an array of frame indices in the order of animation </li><li>  <i>dir</i> : in which direction to go on the sprite map: 'horizontal (default) or' vertical ' </li><li>  <i>once</i> : true if it is necessary to display only one animation loop, false - by default </li></ul><br>  The frames argument probably needs further explanation.  This implies that all animation frames are the same size (this size is transferred above).  During the animation, the system simply ‚Äúpasses‚Äù the sprite map horizontally or vertically (depending on the dir value) starting from the position pos c in increments along the x or y axis by the size value.  You need to define the frames in order to describe how to go through the frames of the animation.  The value of [0, 1, 2, 3, 2, 1] frames will pass from beginning to end and back to the beginning. <br>  Only url, pos, size are required, as you may not need animation. <br>  Each Sprite object has an update method for updating the animation, and its argument is the time delta, as well as in our global update.  Each sprite must be updated for each frame. <br><pre> <code class="javascript hljs">Sprite.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed*dt; }</code> </pre><br>  Each Sprite object also has a render method for rendering itself.  It contains the basic logic of the animation.  It keeps track of which frame should be drawn, calculates its coordinates on the sprite map, and calls ctx.drawImage to draw the frame. <br><pre> <code class="javascript hljs">Sprite.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frames.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idx = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index); frame = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frames[idx % max]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.once &amp;&amp; idx &gt;= max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { frame = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir == <span class="hljs-string"><span class="hljs-string">'vertical'</span></span>) { y += frame * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x += frame * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } ctx.drawImage(resources.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.url), x, y, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br>  We use the 3rd form drawImage, which allows us to specify the size of the sprite, offset and direction separately. <br><br><h4>  Scene update </h4><br>  Remember how in our game cycle we called update (dt) every frame?  We need to define this function now, which should handle the update of all sprites, the update of the positions of entities and collisions. <br><pre> <code class="javascript hljs">unction update(dt) { gameTime += dt; handleInput(dt); updateEntities(dt); <span class="hljs-comment"><span class="hljs-comment">// It gets harder over time by adding enemies using this // equation: 1-.993^gameTime if(Math.random() &lt; 1 - Math.pow(.993, gameTime)) { enemies.push({ pos: [canvas.width, Math.random() * (canvas.height - 39)], sprite: new Sprite('img/sprites.png', [0, 78], [80, 39], 6, [0, 1, 2, 3, 2, 1]) }); } checkCollisions(); scoreEl.innerHTML = score; };</span></span></code> </pre><br>  Notice how we add enemies to the map.  We add an enemy if a random value is less than the set threshold, and we add it on the right side, out of sight.  The ordinate establishes, by multiplying a random number by the difference between the height of the map and the height of the enemy.  The height of the image of the enemy is ‚Äúhardcoded‚Äù, so we know its height, and this code is used as an example. <br>  The threshold is raised every time by the function <code>1 - Math.pow(.993, gameTime)</code> . <br><br><h5>  Keystrokes </h5><br>  To handle keystrokes, I created another small library: <a href="">input.js</a> .  This is a very small library that simply saves the state of the key pressed by adding a keyup and keydown event handler. <br>  This library provides one single function - input.isDown.  Which takes as its argument a character, for example, 'a', and returns true, in case this key was pressed.  You can also pass the following values: <br><ul><li>  SPACE </li><li>  LEFT </li><li>  Right </li><li>  UP </li><li>  DOWN </li></ul><br>  Now we can handle keystrokes: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(input.isDown(<span class="hljs-string"><span class="hljs-string">'DOWN'</span></span>) || input.isDown(<span class="hljs-string"><span class="hljs-string">'s'</span></span>)) { player.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] += playerSpeed * dt; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(input.isDown(<span class="hljs-string"><span class="hljs-string">'UP'</span></span>) || input.isDown(<span class="hljs-string"><span class="hljs-string">'w'</span></span>)) { player.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] -= playerSpeed * dt; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(input.isDown(<span class="hljs-string"><span class="hljs-string">'LEFT'</span></span>) || input.isDown(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)) { player.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] -= playerSpeed * dt; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(input.isDown(<span class="hljs-string"><span class="hljs-string">'RIGHT'</span></span>) || input.isDown(<span class="hljs-string"><span class="hljs-string">'d'</span></span>)) { player.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] += playerSpeed * dt; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(input.isDown(<span class="hljs-string"><span class="hljs-string">'SPACE'</span></span>) &amp;&amp; !isGameOver &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - lastFire &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = player.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] + player.sprite.size[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = player.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] + player.sprite.size[<span class="hljs-number"><span class="hljs-number">1</span></span>] / <span class="hljs-number"><span class="hljs-number">2</span></span>; bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'forward'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>], [<span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]) }); bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'up'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]) }); bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'down'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]) }); lastFire = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); } }</code> </pre><br>  If the player presses "s" or the down arrow, we move the player up the vertical axis.  The canvas coordinate system has coordinates (0,0) in the upper left corner and therefore an increase in the player‚Äôs position leads to a decrease in the player‚Äôs position on the screen.  We did the same for all the other keys. <br>  Please note that we defined playerSpeed ‚Äã‚Äãat the beginning of app.js.  Here are the speeds that we asked: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Speed in pixels per second var playerSpeed = 200; var bulletSpeed = 500; var enemySpeed = 100;</span></span></code> </pre><br>  Multiplying playerSpeed ‚Äã‚Äãwith the dt parameter, we consider the sum of pixels for moving through the frame.  If one second has passed since the last update, the player will advance 200 pixels, if 0.5 then 100. This is shown as a constant movement speed depending on the frame rate. <br>  The last thing we do is a bullet shot, under the conditions: a space was pressed and this happened more than 100 milliseconds since the last shot.  lastFire is a global variable and is part of the game state.  It helps us control the frequency of shots, otherwise the player could shoot each frame.  And it is very easy, right ?! <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = player.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] + player.sprite.size[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = player.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] + player.sprite.size[<span class="hljs-number"><span class="hljs-number">1</span></span>] / <span class="hljs-number"><span class="hljs-number">2</span></span>; bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'forward'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>], [<span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>]) }); bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'up'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]) }); bullets.push({ <span class="hljs-attr"><span class="hljs-attr">pos</span></span>: [x, y], <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'down'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sprite</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sprite(<span class="hljs-string"><span class="hljs-string">'img/sprites.png'</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]) }); lastFire = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code> </pre><br>  We calculate the position of the new bullets in x and y coordinates.  We will add to them the position of the player, plus half of its height and width, so that it shoots from the center of the ship. <br><img src="http://habrastorage.org/storage2/c92/179/376/c92179376c758aa7fa01e4c45065db4e.png" alt="image"><br>  We add 3 bullets because they shoot in different directions.  This makes the game easier because the player will not be trapped.  To distinguish between bullet entities, we added the 'dir' property with values: 'forward', 'up', 'down'. <br><br><h5>  Entities </h5><br>  All entities need updating.  We have the essence of the player and 3 arrays with the essence of bullets, enemies and explosions. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateEntities</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Update the player sprite animation player.sprite.update(dt); // Update all the bullets for(var i=0; i&lt;bullets.length; i++) { var bullet = bullets[i]; switch(bullet.dir) { case 'up': bullet.pos[1] -= bulletSpeed * dt; break; case 'down': bullet.pos[1] += bulletSpeed * dt; break; default: bullet.pos[0] += bulletSpeed * dt; } // Remove the bullet if it goes offscreen if(bullet.pos[1] &lt; 0 || bullet.pos[1] &gt; canvas.height || bullet.pos[0] &gt; canvas.width) { bullets.splice(i, 1); i--; } } // Update all the enemies for(var i=0; i&lt;enemies.length; i++) { enemies[i].pos[0] -= enemySpeed * dt; enemies[i].sprite.update(dt); // Remove if offscreen if(enemies[i].pos[0] + enemies[i].sprite.size[0] &lt; 0) { enemies.splice(i, 1); i--; } } // Update all the explosions for(var i=0; i&lt;explosions.length; i++) { explosions[i].sprite.update(dt); // Remove if animation is done if(explosions[i].sprite.done) { explosions.splice(i, 1); i--; } } }</span></span></code> </pre><br>  Let's start over: the player's sprite is updated simply by calling the update function of the sprite.  This moves the animation forward. <br>  The following 3 cycles for bullets, enemies and explosions.  The process is the same for everyone: refresh the sprite, refresh the motion, and delete if the entity has gone offstage.  Since all entities can never change the direction of their movement, we do not need to save their essence after leaving the zone of visibility. <br>  Bullet movement is the most difficult: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(bullet.dir) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'up'</span></span>: bullet.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] -= bulletSpeed * dt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'down'</span></span>: bullet.pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] += bulletSpeed * dt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: bullet.pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] += bulletSpeed * dt; }</code> </pre><br>  If bullet.dir = 'up', we move the bullet down along the ordinate axis.  On the contrary, if dir = 'down', for the default value, we move along the abscissa axis. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Remove the bullet if it goes offscreen if(bullet.pos[1] &lt; 0 || bullet.pos[1] &gt; canvas.height || bullet.pos[0] &gt; canvas.width) { bullets.splice(i, 1); i--; }</span></span></code> </pre><br>  Then we check whether we can remove the bullet's essence.  Positions are checked against the top, bottom and right edges, because the bullets only move in these directions. <br>  To remove bullets, we remove this object from the array and decrease i, otherwise the next bullet will be skipped. <br><br><h5>  Collision tracking </h5><br>  And now for what everyone fears: collision tracking!  In fact, it is not as difficult as it seems, at least for our game. <br>  There are 3 types of collisions that we should track: <br><ol><li>  Enemies and bullets </li><li>  Enemies and player </li><li>  Player and screen edge </li></ol><br>  The definition of 2D collisions is simple: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collides</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, r, b, x2, y2, r2, b2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(r &lt;= x2 || x &gt; r2 || b &lt;= y2 || y &gt; b2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boxCollides</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, size, pos2, size2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collides(pos[<span class="hljs-number"><span class="hljs-number">0</span></span>], pos[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] + size[<span class="hljs-number"><span class="hljs-number">0</span></span>], pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] + size[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos2[<span class="hljs-number"><span class="hljs-number">0</span></span>], pos2[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos2[<span class="hljs-number"><span class="hljs-number">0</span></span>] + size2[<span class="hljs-number"><span class="hljs-number">0</span></span>], pos2[<span class="hljs-number"><span class="hljs-number">1</span></span>] + size2[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br>  These 2 functions could be combined into one, but it seems to me easier to read.  collides takes the coordinates of the top / left and bottom / right corners of both objects and checks if there are any intersections. <br>  The boxCollides function is a wrapper for collides that accepts arrays with the position and size of each element.  In the function using the dimensions in calculates the absolute coordinates of the position. <br>  And here is the code that actually detects collisions: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkCollisions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkPlayerBounds(); <span class="hljs-comment"><span class="hljs-comment">// Run collision detection for all enemies and bullets for(var i=0; i&lt;enemies.length; i++) { var pos = enemies[i].pos; var size = enemies[i].sprite.size; for(var j=0; j&lt;bullets.length; j++) { var pos2 = bullets[j].pos; var size2 = bullets[j].sprite.size; if(boxCollides(pos, size, pos2, size2)) { // Remove the enemy enemies.splice(i, 1); i--; // Add score score += 100; // Add an explosion explosions.push({ pos: pos, sprite: new Sprite('img/sprites.png', [0, 117], [39, 39], 16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], null, true) }); // Remove the bullet and stop this iteration bullets.splice(j, 1); break; } } if(boxCollides(pos, size, player.pos, player.sprite.size)) { gameOver(); } } }</span></span></code> </pre><br>  The collision detection turned out to be exponential, because we have to check the collisions between each entity on the stage.  For our game, we must check every enemy against every bullet.  We run a loop through the array of enemies and check for collisions in the loop for each bullet. <br>  Called boxCollides pass the function the position and size of the enemy and the bullet, and if the function returns true, the following happens: <br><ul><li>  Removal of the enemy </li><li>  Adding points </li><li>  Adding Blast Entity </li><li>  Bullet removal </li><li>  Stopping the internal cycle of bullets, because the enemy no longer exists </li></ul><br>  Notice how we create the explosion.  We create an object with pos and sprite properties, and an indication of 13 frames for animation on the sprite map.  It also indicates that the once parameter is true, so that the animation is played only once. <br>  Look at these 3 lines: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(boxCollides(pos, size, player.pos, player.sprite.size)) { gameOver(); }</code> </pre><br>  Here we check player and enemy collisions, and if there is a collision, the game is over. <br>  Finally, let's talk about checkPlayerBounds: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkPlayerBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Check bounds if(player.pos[0] &lt; 0) { player.pos[0] = 0; } else if(player.pos[0] &gt; canvas.width - player.sprite.size[0]) { player.pos[0] = canvas.width - player.sprite.size[0]; } if(player.pos[1] &lt; 0) { player.pos[1] = 0; } else if(player.pos[1] &gt; canvas.height - player.sprite.size[1]) { player.pos[1] = canvas.height - player.sprite.size[1]; } }</span></span></code> </pre><br>  It simply does not allow the player to go beyond the map, keeping his coordinates within 0 and canvas.width / canvas.height. <br><br><h4>  Render </h4><br>  We are almost done!  Now we just need to define the render function, which will be called by our game loop to display the scene of each frame.  Here's what it looks like: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Draw everything function render() { ctx.fillStyle = terrainPattern; ctx.fillRect(0, 0, canvas.width, canvas.height); // Render the player if the game isn't over if(!isGameOver) { renderEntity(player); } renderEntities(bullets); renderEntities(enemies); renderEntities(explosions); }; function renderEntities(list) { for(var i=0; i&lt;list.length; i++) { renderEntity(list[i]); } } function renderEntity(entity) { ctx.save(); ctx.translate(entity.pos[0], entity.pos[1]); entity.sprite.render(ctx); ctx.restore(); }</span></span></code> </pre><br>  The first thing we do is draw the background.  We created the terrain background in the init functions using ctx.createPattern, and we draw the background by setting fillStyle and calling the fillRect functions. <br>  Then we draw the player, all the bullets, all the enemies and the explosions.  renderEntites loop around arrays of entities and draws them.  renderEntity uses the canvas transformation to position the object on the screen.  ctx.save saves the current transformation, and ctx.restore restores it. <br>  If you look at the render function of sprites, you will see that sprite is in position (0,0), but calling ctx.translate moves the object to the right place. <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game over </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we need to do is handle the end of the game. </font><font style="vertical-align: inherit;">We need to define the gameOver function, which will show the game end screen, and another reset, which will start the game again.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Game over function gameOver() { document.getElementById('game-over').style.display = 'block'; document.getElementById('game-over-overlay').style.display = 'block'; isGameOver = true; } // Reset game to original state function reset() { document.getElementById('game-over').style.display = 'none'; document.getElementById('game-over-overlay').style.display = 'none'; isGameOver = false; gameTime = 0; score = 0; enemies = []; bullets = []; player.pos = [50, canvas.height / 2]; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gameOver shows the screen defined in index.html, saying ‚ÄúGane Over‚Äù and having a ‚Äúrestart‚Äù button. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reset sets all game state values ‚Äã‚Äãto the initial ones, hides the game end screen, and restarts the game.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final thought </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are a lot of things to learn in this article, but I hope that I broke it into quite simple pieces to show that creating a game is not so difficult. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I focused on using the low-level Canvas API to shed light on how easy it is to create 2D games these days. </font><font style="vertical-align: inherit;">Of course, there are several game engines that you can use to create something really complex. </font><font style="vertical-align: inherit;">Many game engines standardize the interface for entities, and all you need to do is define the render and update functions for each type and the scene manager will automatically call them for all entities in all frames.</font></font></div><p>Source: <a href="https://habr.com/ru/post/184666/">https://habr.com/ru/post/184666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184648/index.html">Salaries of Ukrainian developers - May-June 2013</a></li>
<li><a href="../184650/index.html">Review of iOS 7 Beta 2 on iPad</a></li>
<li><a href="../184652/index.html">Photo storage Topface now open source</a></li>
<li><a href="../184660/index.html">Images: formats and compression (2/3)</a></li>
<li><a href="../184662/index.html">Radioastron - the telescope of the future</a></li>
<li><a href="../184672/index.html">Muzz car tuner</a></li>
<li><a href="../184674/index.html">Java programming training</a></li>
<li><a href="../184678/index.html">Apple Online Store is now in Russia</a></li>
<li><a href="../184680/index.html">Is PRISM a watchful eye or a golden treasure?</a></li>
<li><a href="../184682/index.html">Microsoft's main conference begins - Build</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>