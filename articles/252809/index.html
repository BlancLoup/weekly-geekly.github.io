<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Restart daemon in PHP without losing connections to it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At various conferences, we repeatedly told about our cloud for CLI scripts ( videotape of the report , slides ). The cloud is designed to run various ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Restart daemon in PHP without losing connections to it</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/575/7a7/d3e/5757a7d3eabe48deb6dc624cd61470a8.jpg" align="left">  At various conferences, we repeatedly told about our cloud for CLI scripts ( <a href="http://www.youtube.com/watch%3Fv%3DOmN3ltIyV8M">videotape of the report</a> , <a href="http://www.slideshare.net/BadooDev/badoo-hl">slides</a> ).  The cloud is designed to run various PHP scripts on a schedule or through an API.  As a rule, these scripts process queues, and the load is spread over approximately 100 servers.  Previously, we focused on how the control logic is implemented, which is responsible for evenly distributing the load over such a number of servers and generating tasks on a schedule.  But beyond that, we needed to write a daemon that would be able to run our PHP scripts in the CLI and monitor their execution status. <br><br>  It was originally written in C, like all the other demons in our company.  However, we are faced with the fact that a significant part of the processor time (about 10%) was spent, in fact, wasted: it is the launch of the interpreter and the loading of the ‚Äúcore‚Äù of our framework.  Therefore, in order to be able to initialize the interpreter and our framework only once, it was decided to rewrite the daemon in PHP.  We called it Php <i>rock</i> syd (by analogy with Phproxyd - PHP Proxy Daemon, the C demon that we had before).  It accepts requests to launch individual classes and does fork () for each request, and is also able to report on the execution status of each of the launches.  This architecture is in many ways similar to the Apache web server model, when all initialization is done once in the ‚Äúwizard‚Äù and the ‚Äúchildren‚Äù are already engaged in processing the request.  As an additional ‚Äúbun‚Äù, we get the ability to enable opcode cache in the CLI, which will work correctly, since all children inherit the same area of ‚Äã‚Äãshared memory as the master process.  To reduce delays in processing the launch request, you can fork () in advance (prefork-model), but in our case, fork () delays are about 1 ms, which is fine with us. <br><a name="habracut"></a><br>  However, since we update the code quite often, this daemon also has to be restarted frequently, otherwise the code that is loaded into it may become outdated.  Since each restart would be accompanied by a lot of <i>connection reset by peer</i> errors, including end-user service failures (the daemon is useful not only for the cloud, but also for part of our site), we decided to look for ways to restart the daemon without losing already established connections.  There is one popular technique that makes a <i>graceful reload</i> for daemons: fork-exec is done and the descriptor from the listen-socket is passed to the child.  Thus, the new connections are already accepted by the new version of the daemon, and the old ones are being modified using the old version. <br><br>  In this article we will look at the complicated version of <i>graceful reload</i> : the old connections will continue to be processed by the new version of the daemon, which is important in our case, because otherwise it will run the old code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Theory </h3><br>  Let's first think: is it possible that we want to get?  And if so, how can this be achieved? <br><br>  Since the daemon runs on Linux, which is POSIX-compatible, the following features are available to us: <br><br><ol><li>  All open files and sockets are numbers corresponding to the number of the open descriptor.  Standard input, output, and error stream have descriptors 0, 1, and 2, respectively. </li><li>  There are no significant differences between the open file, the socket and the pipe (pipe) (for example, you can work with sockets using both read / write and sendto / recvfrom system calls). </li><li>  When executing the fork () system call, all open descriptors are inherited with their numbers and read / write positions (in files) preserved. </li><li>  When execve () system call is executed, all open descriptors are also inherited, and in addition the PID of the process is saved and, therefore, binding to its children. </li><li>  The list of open process descriptors is available from the / dev / fd directory, which in Linux is a symlink on / proc / self / fd. </li></ol><br>  Thus, we have every reason to believe that our task is accomplished, and without much effort.  So let's get started. <br><br><h3>  PHP patches </h3><br>  Unfortunately, there is one small detail that complicates our work: in PHP there is no possibility to get the file descriptor number for streams (streams) and open the file descriptor by number (instead, a copy of the file descriptor opens, which is not suitable for our daemon, since we are very we carefully monitor open handles in order not to create leaks when restarting and when starting child processes). <br><br>  To begin, we will make a couple of small patches in the PHP code to add the ability to get fd from the stream (stream) and make fopen (php: // fd / &lt;num&gt;) not open the copy of the descriptor (the second change is incompatible with the current PHP behavior, so you can add a new ‚Äúaddress‚Äù instead, for example, php: // fdraw / &lt;num&gt;): <br><br><div class="spoiler">  <b class="spoiler_title">Patch code</b> <div class="spoiler_text"><pre><code class="diff hljs">diff --git a/ext/standard/php_fopen_wrapper.cb/ext/standard/php_fopen_wrapper.c index f8d7bda..fee964c 100644 --- a/ext/standard/php_fopen_wrapper.c +++ b/ext/standard/php_fopen_wrapper.c @@ -24,6 +24,7 @@ #if HAVE_UNISTD_H #include &lt;unistd.h&gt; #endif +#include &lt;fcntl.h&gt; #include "php.h" #include "php_globals.h" @@ -296,11 +297,11 @@ php_stream * php_stream_url_wrap_php(php_stream_wrapper *wrapper, char *path, ch "The file descriptors must be non-negative numbers smaller than %d", dtablesize); return NULL; } - - fd = dup(fildes_ori); - if (fd == -1) { + + fd = fildes_ori; + if (fcntl(fildes_ori, F_GETFD) == -1) { php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, - "Error duping file descriptor %ld; possibly it doesn't exist: " + "File descriptor %ld invalid: " "[%d]: %s", fildes_ori, errno, strerror(errno)); return NULL; } diff --git a/ext/standard/streamsfuncs.cb/ext/standard/streamsfuncs.c index 0610ecf..14fd3b0 100644 --- a/ext/standard/streamsfuncs.c +++ b/ext/standard/streamsfuncs.c @@ -24,6 +24,7 @@ #include "ext/standard/flock_compat.h" #include "ext/standard/file.h" #include "ext/standard/php_filestat.h" +#include "ext/standard/php_fopen_wrappers.h" #include "php_open_temporary_file.h" #include "ext/standard/basic_functions.h" #include "php_ini.h" @@ -484,6 +485,7 @@ PHP_FUNCTION(stream_get_meta_data) zval *arg1; php_stream *stream; zval *newval; + int tmp_fd; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &amp;arg1) == FAILURE) { return; @@ -502,6 +504,9 @@ PHP_FUNCTION(stream_get_meta_data) add_assoc_string(return_value, "wrapper_type", (char *)stream-&gt;wrapper-&gt;wops-&gt;label, 1); } add_assoc_string(return_value, "stream_type", (char *)stream-&gt;ops-&gt;label, 1); + if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&amp;tmp_fd, 1) &amp;&amp; tmp_fd != -1) { + add_assoc_long(return_value, "fd", tmp_fd); + } add_assoc_string(return_value, "mode", stream-&gt;mode, 1);</code> </pre> <br></div></div><br>  We added the fd field to the result returned by the stream_get_meta_data () function if it makes sense (for example, the fd field will not be present for zlib streams).  We also replaced the dup () call from the transferred file descriptor with a simple check.  Unfortunately, this code will not work without modifications under Windows, since the fcntl () call is POSIX-specific, so the full patch must contain additional code branches for other OSs. <br><br><h3>  The demon without the possibility of restarting </h3><br>  To begin with, we will write a small server that can receive requests in JSON format and give some answer.  For example, it will give the number of elements in the array that came in the request. <br><br>  The daemon is listening on port 31337. The output should be something like: <br><blockquote><pre> <code class="hljs kotlin">$ telnet localhost <span class="hljs-number"><span class="hljs-number">31337</span></span> Trying <span class="hljs-number"><span class="hljs-number">127.0</span></span>.0.1... Connected to localhost. Escape character <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} #   <span class="hljs-string"><span class="hljs-string">"Request had 1 keys"</span></span> {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cnt"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>} #   <span class="hljs-string"><span class="hljs-string">"Request had 2 keys"</span></span></code> </pre><br></blockquote><br>  We will use stream_socket_server () to start listening to the port, and stream_select () to determine which descriptors are ready to read / write. <br><br><div class="spoiler">  <b class="spoiler_title">The code of the simplest implementation (Simple.php)</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Simple</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = <span class="hljs-number"><span class="hljs-number">31337</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_KEY = <span class="hljs-string"><span class="hljs-string">'SERVER'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> resource[] (client_id =&gt; stream) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $streams = []; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string[] (client_id =&gt; read buffer) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $read_buf = []; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string[] (client_id =&gt; write buffer) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $write_buf = []; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> resource[] (client_id =&gt; stream from which to read) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $read = []; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> resource[] (client_id =&gt; stream where to write) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $write = []; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> int Total connection count */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $conn_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;listen(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Entering main loop\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;mainLoop(); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $port = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::PORT; $ip_port = <span class="hljs-string"><span class="hljs-string">"0.0.0.0:$port"</span></span>; $address = <span class="hljs-string"><span class="hljs-string">"tcp://$ip_port"</span></span>; $server = stream_socket_server($address, $errno, $errstr, STREAM_SERVER_BIND | STREAM_SERVER_LISTEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$server) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"stream_socket_server failed: $errno $errstr\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::SERVER_KEY] = $server; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Listening on $address\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id, $response)</span></span></span><span class="hljs-function"> </span></span>{ $json_resp = json_encode($response); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"stream$stream_id "</span></span> . $json_resp . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write($stream_id, $json_resp . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id, $buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id] .= $buf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write[$stream_id])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write[$stream_id] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;streams[$stream_id]; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($server)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Accepting new connection\n"</span></span>; $client = stream_socket_accept($server, <span class="hljs-number"><span class="hljs-number">1</span></span>, $peername); $stream_id = (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;conn_count++); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$client) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Accept failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } stream_set_read_buffer($client, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_write_buffer($client, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_blocking($client, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_timeout($client, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id] = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id] = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read[$stream_id] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;streams[$stream_id] = $client; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Connected stream$stream_id: $peername\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Disconnect stream$stream_id\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id], <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id]); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;streams[$stream_id]); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write[$stream_id], <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read[$stream_id]); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id)</span></span></span><span class="hljs-function"> </span></span>{ $buf = fread(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;streams[$stream_id], <span class="hljs-number"><span class="hljs-number">8192</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($buf === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> || $buf === <span class="hljs-string"><span class="hljs-string">''</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"got EOF from stream$stream_id\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;disconnect($stream_id); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read[$stream_id]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id] .= $buf; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;processJSONRequests($stream_id); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processJSONRequests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id], <span class="hljs-string"><span class="hljs-string">"\n"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; $requests = explode(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id]); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read_buf[$stream_id] = array_pop($requests); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $req) { $res = json_decode(rtrim($req), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($res !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;response($stream_id, <span class="hljs-string"><span class="hljs-string">"Request had "</span></span> . count($res) . <span class="hljs-string"><span class="hljs-string">" keys"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;response($stream_id, <span class="hljs-string"><span class="hljs-string">"Invalid JSON"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream_id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $wrote = fwrite(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;streams[$stream_id], substr(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">65536</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($wrote === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"write failed into stream #$stream_id\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;disconnect($stream_id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($wrote === strlen(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id] = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write[$stream_id]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read[$stream_id])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;disconnect($stream_id); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id] = substr(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write_buf[$stream_id], $wrote); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $read = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;read; $write = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write; $except = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Selecting for "</span></span> . count($read) . <span class="hljs-string"><span class="hljs-string">" reads, "</span></span> . count($write) . <span class="hljs-string"><span class="hljs-string">" writes\n"</span></span>; $n = stream_select($read, $write, $except, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$n) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Could not stream_select()\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count($read)) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Can read from "</span></span> . count($read) . <span class="hljs-string"><span class="hljs-string">" streams\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count($write)) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Can write to "</span></span> . count($write) . <span class="hljs-string"><span class="hljs-string">" streams\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($read[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::SERVER_KEY])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;accept($read[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::SERVER_KEY]); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($read[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::SERVER_KEY]); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($read <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $stream_id =&gt; $_) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handleRead($stream_id); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($write <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $stream_id =&gt; $_) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handleWrite($stream_id); } } } } $instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simple(); $instance-&gt;run();</code> </pre><br></div></div><br>  The code for this daemon is more than standard, but I would like to note one implementation detail: we store all the read and write buffers with binding to specific connections and perform request processing right in the same place where we read the request.  This is important because one of such requests may be restart, and in this case it will not come to processing the following requests.  However, since we have not yet read the requests, the next time stream_select () from the same descriptors will return the same result.  Thus, we will not lose a single request if we restart directly from the command handler (except when several commands are sent to us at the same connection, and restart is one of these commands). <br><br>  So, how to make it possible to restart the daemon? <br><br><h3>  Daemon with restarting and maintaining established connections </h3><br>  Our simplest example did not know how to do anything useful, so let's still write the demon that was discussed at the very beginning.  We want to get something like the following (commands to the daemon are sent as ‚Äúcommand_name [JSON-data]‚Äù, response as JSON): <br><blockquote><pre> <code class="hljs kotlin">$ telnet localhost <span class="hljs-number"><span class="hljs-number">31337</span></span> Trying <span class="hljs-number"><span class="hljs-number">127.0</span></span>.0.1... Connected to localhost. Escape character <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. #      restart #      <span class="hljs-string"><span class="hljs-string">"Restarted successfully"</span></span> #    run {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"params"</span></span>:[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>],<span class="hljs-string"><span class="hljs-string">"class"</span></span>:<span class="hljs-string"><span class="hljs-string">"TestClass1"</span></span>} #   {<span class="hljs-string"><span class="hljs-string">"error_text"</span></span>:<span class="hljs-string"><span class="hljs-string">"OK"</span></span>} #     ( child TestClass1   ) restart <span class="hljs-string"><span class="hljs-string">"Restarted successfully"</span></span> #   :    check {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-string"><span class="hljs-string">"error_text"</span></span>:<span class="hljs-string"><span class="hljs-string">"Still running"</span></span>} #  <span class="hljs-number"><span class="hljs-number">5</span></span>     :  TestClass1   check {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-string"><span class="hljs-string">"retcode"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>} #     ,    free check {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-string"><span class="hljs-string">"retcode"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>} free {<span class="hljs-string"><span class="hljs-string">"hash"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-string"><span class="hljs-string">"error_text"</span></span>:<span class="hljs-string"><span class="hljs-string">"OK"</span></span>} restart <span class="hljs-string"><span class="hljs-string">"Restarted successfully"</span></span> #   ,          restart restart {<span class="hljs-string"><span class="hljs-string">"error_text"</span></span>:<span class="hljs-string"><span class="hljs-string">"Restarted successfully"</span></span>} bye Connection closed <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> foreign host.</code> </pre><br></blockquote><br>  The idea for restarting is simple: we will create a file with all the necessary information, and when we start, we will try to read it and restore the open file descriptors. <br><br>  First, we write the code to write to the restart file: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Creating restart file...\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$res = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getFdRestartData()) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Could not get restart FD data, exiting, graceful restart is not supported\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Close all extra file descriptors that we do not know of, including opendir() descriptor :) */</span></span> $dh = opendir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); $fds = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> !== ($file = readdir($dh))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; $fds[] = $file; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;known_fds[$fd])) { fclose(fopen(<span class="hljs-string"><span class="hljs-string">"php://fd/"</span></span> . $fd, <span class="hljs-string"><span class="hljs-string">'r+'</span></span>)); } } $contents = serialize($res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_put_contents(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_DIR . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_FILENAME, $contents) !== strlen($contents)) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Could not fully write restart file\n"</span></span>); unlink(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_DIR . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_FILENAME); }</code> </pre><br><br>  The code for getting an array of data (the getFdRestartData () function) is shown below: <br><br><pre> <code class="php hljs">$res = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$restart_fd_resources <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $prop) { $res[$prop] = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;$prop <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $k =&gt; $v) { $meta = stream_get_meta_data($v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($meta[<span class="hljs-string"><span class="hljs-string">'fd'</span></span>])) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"No fd in stream metadata for resource $v (key $k in $prop), got "</span></span> . var_export($meta, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } $res[$prop][$k] = $meta[<span class="hljs-string"><span class="hljs-string">'fd'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;known_fds[$meta[<span class="hljs-string"><span class="hljs-string">'fd'</span></span>]] = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$restart_fd_props <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $prop) { $res[$prop] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;$prop; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res;</code> </pre><br>  The code takes into account that we have 2 types of properties: <br><ol><li>  Properties containing resources with connections: $ restart_fd_resources = ['read', 'write', 'streams']. </li><li>  Properties containing buffers and other information about connections that can be ‚Äúserialized‚Äù in raw form: $ restart_fd_props = ['read_buf', 'write_buf', 'conn_count']. </li></ol><br>  We also remember all the fd stored in the restart file, and close all the others (if any), because otherwise you can prevent the leaking of file descriptors. <br><br>  Next we need to load this file at the start and continue to use open handles as if nothing happened :).  The code for the two functions (loading a restart file and loading file descriptor information) is as follows: <br><br>  <b>File upload:</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_exists(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_DIR . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_FILENAME)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Restart file found, trying to adopt it\n"</span></span>; $contents = file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_DIR . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_FILENAME); unlink(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_DIR . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::RESTART_FILENAME); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($contents === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Could not read restart file\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $res = unserialize($contents); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$res) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Could not unserialize restart file contents"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$restart_props <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $prop) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!array_key_exists($prop, $res)) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"No property $prop in restart file\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;$prop = $res[$prop]; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loadFdRestartData($res);</code> </pre><br><br>  <b>The loadFdRestartData () function to expand the file descriptor array back:</b> <br><br><pre> <code class="php hljs">$fd_resources = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$restart_fd_resources <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $prop) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($res[$prop])) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Property '$prop' is not present in restart fd resources\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $pp = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($res[$prop] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $k =&gt; $v) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($fd_resources[$v])) { $pp[$k] = $fd_resources[$v]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $fp = fopen(<span class="hljs-string"><span class="hljs-string">"php://fd/"</span></span> . $v, <span class="hljs-string"><span class="hljs-string">'r+'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$fp) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Failed to open fd = $v, exiting\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } stream_set_read_buffer($fp, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_write_buffer($fp, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_blocking($fp, <span class="hljs-number"><span class="hljs-number">0</span></span>); stream_set_timeout($fp, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::CONN_TIMEOUT); $fd_resources[$v] = $fp; $pp[$k] = $fp; } } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;$prop = $pp; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$restart_fd_props <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $prop) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($res[$prop])) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Property '$prop' is not present in restart fd properties\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;$prop = $res[$prop]; }</code> </pre><br>  We re-set the read_buffer and write_buffer values ‚Äã‚Äãfor open file descriptors and set timeouts.  Oddly enough, after these manipulations, PHP calmly does accept () on these file descriptors and continues to read / write normally in them even though it does not know that these are sockets. <br><br>  In the end, we need to write logic to launch and monitor the execution status of the workers.  Since this is not related to the topic of the article, the full implementation of the daemon is placed on the github repository, the link to which is given below. <br><br><h3>  Conclusion </h3><br>  So, this article described the implementation of a daemon that communicates using the JSON protocol and is able to run arbitrary classes in separate processes while tracking the process of their execution.  To launch individual classes, the <i>fork ()</i> model is used <i>for the request</i> , therefore, to process the request, the interpreter does not need to be restarted and the framework is loaded, and it becomes possible to use opcode cache in the CLI.  Since every time the code is updated, the daemon needs to be restarted, it is necessary to provide a mechanism for smoothly restarting this daemon (in our company, the code is sometimes updated every few minutes, in the form of ‚Äúhotfixes‚Äù). <br><br>  The restart occurs by execve () execve () system call, as a result of which all descendants remain attached to the parent (since the process PID does not change during execve ()).  All open file descriptors are also saved, which allows you to continue processing requests from users in already open connections.  All network buffers, information about running children and open descriptors are stored in a separate restart file, which is read by a new daemon instance, after which work continues in the standard event loop. <br><br>  The full implementation code can be seen on GitHub at the following address: <a href="https://github.com/badoo/habr/tree/master/phprocksyd">github.com/badoo/habr/tree/master/phprocksyd</a> <br><br>  Questions, suggestions, clarifications are welcome. <br><br>  Respectfully, <br>  <i>Yuri <a href="https://habrahabr.ru/users/yourock/" class="user_link">youROCK</a> Nasretdinov</i> <i><br></i>  <i>Lead PHP developer</i> <i><br></i>  <i>Badoo</i> </div><p>Source: <a href="https://habr.com/ru/post/252809/">https://habr.com/ru/post/252809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252793/index.html">GPS control on the free service ViaLatM 2.0</a></li>
<li><a href="../252799/index.html">How to create instances in Google Cloud, set up access and hook Bucket to it. Howto</a></li>
<li><a href="../252801/index.html">VMware VDI Solutions Video Review, Horizon 6 Update Review</a></li>
<li><a href="../252803/index.html">Coub API Tutorial</a></li>
<li><a href="../252805/index.html">Hardware Shared DAS or why LSI Syncro is needed</a></li>
<li><a href="../252813/index.html">Can you trust the code in the editor? bi-directional text</a></li>
<li><a href="../252817/index.html">Automation of financial statements</a></li>
<li><a href="../252819/index.html">How to prepare TCP</a></li>
<li><a href="../252821/index.html">Nginx and https. We get class A +</a></li>
<li><a href="../252823/index.html">Custom SQLite Android functions or its own LOWER_FNC ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>