<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test automation for Android applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing is an important part of the application development process. For Android, testing is especially important, since the devices are very differen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test automation for Android applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/366/0fb/88e/3660fb88eaade16de39a55bd98b58e09.jpg"><br>  Testing is an important part of the application development process.  For Android, testing is especially important, since the devices are very different from each other: <br><ul><li>  The size and resolution of the screen. </li><li>  Android version. </li><li>  Form factor </li><li>  Command system processor. </li><li>  Presence of front camera, NFC, external keyboard, etc. </li></ul><br>  Therefore, the application has to test on a variety of devices. <br>  The testing process includes various types of testing.  Consider the process of functional testing of the application manually.  The tester installs the application on the device, thoughtfully checks all the functionality, then returns the device to its original state.  And so for each application and each device.  The obvious disadvantage of this method is a great investment of time for regular testing. <br>  The obvious advantage of automated testing - it can be regularly carried out without special costs.  For example, every night, test a fresh build of the application on the entire set of available devices, and in the morning analyze the results and correct errors. <br>  This article will discuss the means of implementing automatic testing.  Only tools included in the Android SDK or distributed under an Open Source license are considered. <br><a name="habracut"></a><br><h2>  The concept of automatic testing </h2><br>  The task is to automate with the greatest accuracy the actions that the tester performs.  Let's consider them.  There are several applications and several Android devices.  For each application and each device, the following steps are performed: <br><br><ol><li>  Install the application on the device </li><li>  Application launch </li><li>  Testing the application in a selected way </li><li>  Uninstall application </li><li>  Reset device status </li></ol><br>  At each step, you need to collect and analyze data, such as logs and screenshots.  Then on the basis of this data to form a test result. <br><br>  Next, we consider the means to automate the listed steps. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Manage Android devices </h2><br>  First you need to select the computer on which the automatic testing will run and configure the <a href="http://developer.android.com/sdk/index.html">Android SDK</a> on it.  Examples are given for a computer running Linux. <br><br>  On all tested devices, you need to disable the lock screen and maximize the wait time.  For some testing methods, you need to turn off the screen orientation change. <br><br>  The Android SDK has two utilities for managing devices: adb and MonkeyRunner. <br><br>  I will try to describe in detail the automation of the actions used in testing.  For those familiar with ADB and MonkeyRunner, it makes sense to immediately go to the section " <a href="https://habr.com/ru/company/intel/blog/152122/">Methods of automated testing</a> ." <br><br><h3>  Management using the ADB utility </h3><br>  ADB (Android Debug Bridge) is a utility for managing Android devices from the command line.  Official ADB documentation: <a href="http://developer.android.com/tools/help/adb.html">developer.android.com/tools/help/adb.html</a> <br><br>  The adb utility is located in the <code>&lt;android_sdk&gt;/platform-tools/</code> directory.  The path to this directory is recommended to be registered in the PATH environment variable. <br><br><h3>  ADB operation check </h3><br>  Install and configure the Android SDK, connect the Android device to the computer and execute the command: <br><pre> <code class="bash hljs">adb devices</code> </pre><br>  The command will list all connected devices.  If the device list is not empty, then ADB is configured and working. <br><br><h3>  Work with multiple devices </h3><br>  To specify the ADB with which device you need to work, you must specify the serial number of the device after the <code>-s</code> key: <br><pre> <code class="bash hljs">adb -s &lt;serial_number&gt; &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre><br>  For example: <br><pre> <code class="bash hljs">adb -s &lt;serial_number&gt; logcat</code> </pre><br>  The serial number of the device can be viewed with the <code>adb devices</code> command.  The <code>-s</code> allows you to work simultaneously with several connected devices.  In the future, the <code>-s</code> in the commands, I will not specify. <br><br><h3>  ADB basic commands </h3><br>  Open console on device: <br><pre> <code class="bash hljs">adb shell</code> </pre><br>  Run the command on the device: <br><pre> <code class="bash hljs">adb shell &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre><br>  Android has many standard Linux utilities: ls, cat, dmesg, ... <br><br>  Install the application from the apk file: <br><pre> <code class="bash hljs">adb install example.apk</code> </pre><br>  Remove application: <br><pre> <code class="bash hljs">adb uninstall &lt;package&gt;</code> </pre><br>  The package name can be obtained from the apk file with the command: <br><pre> <code class="bash hljs">aapt dump badging example.apk | grep <span class="hljs-string"><span class="hljs-string">"package"</span></span></code> </pre><br>  Download file from device to computer: <br><pre> <code class="bash hljs">adb pull &lt;path-on-device&gt; &lt;file&gt;</code> </pre><br>  Download file from computer to device: <br><pre> <code class="bash hljs">adb push &lt;file&gt; &lt;path-on-device&gt;</code> </pre><br>  <strong>Note:</strong> <br>  Most directories on the device are read-only.  Write access is allowed in the <code>/sdcard</code> directory (programs cannot be run from it) and <code>/data/local/tmp/</code> . <br><br>  Application launch: <br><pre> <code class="bash hljs">adb shell am start -n &lt;package&gt;/&lt;activity&gt;</code> </pre><br>  Starts the specified activity.  The name of the activity that is started when the application is selected in the menu can be obtained from the apk file with the command: <br><pre> <code class="bash hljs">aapt dump badging example.apk | grep <span class="hljs-string"><span class="hljs-string">"launchable-activity"</span></span></code> </pre><br><h3>  Reading logs </h3><br>  Reading logs on Android is done using the logcat utility. <br>  Logcat utility home page: <a href="http://developer.android.com/tools/help/logcat.html">developer.android.com/tools/help/logcat.html</a> <br><br>  Read logs from the device (blocked until Ctrl-C is pressed): <br><pre> <code class="bash hljs">adb logcat</code> </pre><br>  Clear the log buffer on the device: <br><pre> <code class="bash hljs">adb logcat -c</code> </pre><br>  Read the log buffer on the device (gives the current contents of the buffer, is not blocked): <br><pre> <code class="bash hljs">adb logcat -d</code> </pre><br>  Example: <br><pre> <code class="bash hljs">adb logcat -c <span class="hljs-comment"><span class="hljs-comment">#    #   adb logcat -d &gt; file.log #       file.log</span></span></code> </pre><br><h3>  Taking screenshots using screencap utility </h3><br>  The screencap utility saves the current screen contents to a graphic file: <br><pre> <code class="bash hljs">adb shell screencap /sdcard/screen.png adb pull /sdcard/screen.png screen.png adb shell rm /sdcard/screen.png</code> </pre><br>  The <code>screencap</code> utility is available on phones with Android 4.x and higher.  On previous versions of Android, screenshots can be taken using MonkeyRunner. <br><br><h3>  Sample BASH script for testing an application using ADB </h3><br><div class="spoiler">  <b class="spoiler_title">Script: app_test.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #------------------------------------------------------------------------------- #  BASH      c  ADB # # : # 1.   # 2.   # 3.     monkey # 4.   # #       log-. #------------------------------------------------------------------------------- APK="example.apk" PACKAGE="com.example.package" ACTIVITY="com.example.package.activity" rm -rf log mkdir log # 1.   adb uninstall $PACKAGE #   adb logcat -c #    adb install $APK #   adb logcat -d &gt; log/install.log #     # 2.   adb logcat -c adb shell am start -n $PACKAGE/$ACTIVITY #   sleep 10 #  10      adb logcat -d &gt; log/start.log # 3.   adb logcat -c #     monkey adb shell monkey --pct-touch 70 -p $PACKAGE -v 1000 --throttle 500 adb logcat -d &gt; log/test.log # 4.   adb logcat -c adb uninstall $PACKAGE adb logcat -d &gt; log/uninstall.log</span></span></code> </pre><br></div></div><br><h2>  Control with MonkeyRunner </h2><br>  MonkeyRunner provides an API for writing scripts that control Android devices.  With the help of MonkeyRunner, you can write a Python script that installs an Android application, launches it, simulates user actions, takes screenshots and saves them to a computer.  MonkeyRunner uses <a href="http://www.jython.org/">Jython</a> to execute scripts. <br><br><img src="https://habrastorage.org/storage2/0ea/183/d18/0ea183d1806a6a1dba65e3810af17fee.jpg"><br><br>  MonkeyRunner utility homepage and API description: <a href="http://developer.android.com/tools/help/monkeyrunner_concepts.html">developer.android.com/tools/help/monkeyrunner_concepts.html</a> <br><br><h3>  Reading logs with MonkeyRunner </h3><br>  File log.py: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding: utf-8 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice def log(fn, device): msg = device.shell('logcat -d') f_log = open(fn, 'at') if msg is None: msg = 'None' f_log.write(msg.encode('utf-8')) f_log.close() device.shell('logcat -c') if __name__ == '__main__': device = MonkeyRunner.waitForConnection() device.shell('logcat -c') #    # ... log('example.log', device) #  </span></span></code> </pre><br>  Run: <br><pre> <code class="bash hljs">monkeyrunner log.py</code> </pre><br>  The script will write the logs to the file <code>example.log</code> in the current directory. <br><br><h3>  Taking screenshots </h3><br>  Screen.py file: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding: utf-8 from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice if __name__ == '__main__': device = MonkeyRunner.waitForConnection() image = device.takeSnapshot() image.writeToFile('screenshot.png','png')</span></span></code> </pre><br>  Run: <br><pre> <code class="bash hljs">monkeyrunner screen.py</code> </pre><br>  The script takes a screenshot and saves it to the <code>screenshot.png</code> file in the current directory. <br><br><h3>  Device control example with MonkeyRunner </h3><br><div class="spoiler">  <b class="spoiler_title">Script: monkeyrunner_test.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding: utf-8 import time from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice APK = "example.apk" PACKAGE = "com.example.package" ACTIVITY = "com.example.package.activity" def log(fn, device): msg = device.shell('logcat -d') f_log = open(fn, 'at') if msg is None: msg = 'None' f_log.write(msg.encode('utf-8')) f_log.close() device.shell('logcat -c') if __name__ == '__main__': device = MonkeyRunner.waitForConnection() device.removePackage(PACKAGE) #  ,     device.shell('logcat -c') #    device.installPackage(APK) #   log('install.log', device) #     run_component = PACKAGE + '/' + ACTIVITY device.startActivity(component=run_component) #  activity time.sleep(10) #  10  log('start.log', device) #     device.press('KEYCODE_MENU', MonkeyDevice.DOWN_AND_UP) #   screen = device.takeSnapshot() #   screen.writeToFile('screenshot.png', 'png') #   screenshot.png log('run.log', device) #     device.removePackage(PACKAGE) #   log('uninstall.log', device) #    </span></span></code> </pre><br></div></div><br>  Run: <br><pre> <code class="bash hljs">monkeyrunner monkeyrunner_test.py</code> </pre><br><a name="testing_methods"></a><br><h2>  Automated Testing Tools </h2><br><h3>  Monkey testing </h3><br>  Imagine that the device got into tenacious paws of a very active and creative monkey - the monkey utility is designed to imitate a similar situation. <br><br>  The monkey utility is included with the Android SDK.  The utility sends pseudo-random user actions to the device.  The command line parameters specify the number of user actions, the ratio of their types and the name of the package being tested, so that, for example, the monkey does not go beyond the limits of the application being tested and does not start sending SMS to all contacts from the address book. <br><br>  Examples of use and a list of parameters are given on the home page: <a href="http://developer.android.com/tools/help/monkey.html">developer.android.com/tools/help/monkey.html</a> <br><br>  The main advantage of monkey is the lack of support costs.  In addition, stress testing an application with a stream of arbitrary events can detect nontrivial errors. <br><br>  Disadvantages of testing with monkey: <br><ul><li>  Ineffective for testing functionality caused by a complex sequence of actions.  For example, monkey will not be able to authenticate and the main functionality of the application will be ignored. </li><li>  Games with complex controls that require quick response and complex gestures will be completed at the very beginning, or will not start at all. </li><li>  Errors found with monkey are very difficult to reproduce. </li><li>  No check of application status. </li></ul><br>  Using the monkey utility, you can easily test any application - this is a good starting point.  It is possible that this method will show adequate results for a particular application.  If the quality of testing is unsatisfactory, then you should use other methods of testing. <br><br><h3>  MonkeyRunner Testing </h3><br>  Using scripts that use the MonkeyRunner API, you can not only develop a framework for a testing system, but also write scripts to test a specific application on a specific device. <br><br>  <strong>Advantages:</strong> <br><ul><li>  Flexibility - you can implement almost anything. </li></ul><br>  <strong>Disadvantages:</strong> <br><ul><li>  The complexity of writing scripts, even in simple cases. </li></ul><br>  As a rule, this method is not justified - writing scripts takes a long time.  However, in particular cases, this method may work. <br><br><h3>  Testing with getevent / sendevent </h3><br>  The getevent and sendevent utilities allow you to record a sequence of user actions, and then play this sequence.  Utilities are located on the Android device itself and do not require root access. <br>  <strong>Advantages:</strong> <br><ul><li>  The sequence of actions can be recorded at no additional cost during manual testing, if it is already underway. </li><li>  Scripting does not require programming skills. </li></ul><br>  <strong>Disadvantages:</strong> <br><ul><li>  The sequence of actions must be recorded separately for each application and for each device.  When changing the application interface, all recorded actions must be performed anew. </li><li>  There is no application status check.  For example, when testing a browser, a page opens.  If it opens longer than at the moment of recording, then further actions will be performed before the page is fully loaded and the result will be incorrect.  Sometimes it is possible to write a script in such a way that in all such cases the waiting exceeds the maximum possible. </li><li>  Fast and complex sequence of actions will be played longer than recorded - therefore, the method is not always suitable for testing dynamic games, where the reaction time and timeliness of the action are critical. </li></ul><br>  Record a sequence of actions: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    #    ,    Ctrl-C adb shell getevent -t &gt; events.txt #      ./decode_events.py events.txt &gt; events.sh #     adb push events.sh /data/local/tmp/ #     adb shell chmod 755 /data/local/tmp/events.sh #   adb shell sh /data/local/tmp/events.sh</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Script: decode_events.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python # coding: utf-8 USAGE = """    getevent   shell-,       sendevent  sleep. : ./decode_events.py input.txt &gt; output.sh """ import re import sys # [ 43319.628481] /dev/input/event1: 0003 0039 ffffffff # 48470-342082: /dev/input/event1: 0000 0000 00000000 _re = re.compile(r'[^\d]*(?P&lt;sec&gt;\d+)[.-](?P&lt;msec&gt;\d+)[:\]] (?P&lt;device&gt;[^:]+):' ' (?P&lt;class&gt;[0-9a-f]+) (?P&lt;event&gt;[0-9a-f]+) (?P&lt;params&gt;[0-9a-f]+)') T_FIX = 0.1 last_time = None if __name__ == '__main__': if len(sys.argv) &lt; 2: print USAGE sys.exit(1) print '#!/bin/sh' input_fn = sys.argv[1] for line in open(input_fn, 'rt'): m = _re.match(line) if m is not None: d = m.groupdict() cur_time = float(d['sec']) + float(d['msec'][:2])/100 if last_time is not None: diff_time = (cur_time - last_time) if diff_time &gt; 0.2: print 'sleep %.2f' % (diff_time-T_FIX,) last_time = cur_time print 'sendevent', d['device'], int(d['class'], 16), \ int(d['event'], 16), int(d['params'], 16) else: print '#', line.strip('\n\r\t ')</span></span></code> </pre><br></div></div><br>  Recorded actions must be played on the device. <br><br><h3>  Robotium Testing </h3><br>  Unlike the previously discussed methods, Robotium is not included in the Android SDK, but distributed under an Open Source license. <br><br>  Robotium home page: <a href="http://code.google.com/p/robotium/">code.google.com/p/robotium</a> <br><br>  The main difference of Robotium is that test actions are described at the application interface level.  In the previously discussed methods, test actions were explicitly or implicitly described at the input device level. <br><br>  For example, in the application you need to click the "OK" button.  Using the MonkeyRunner script, pressing the button is implemented as: ‚ÄúTouch the screen point with coordinates (x0, y0)‚Äù.  Using Robotium, this is implemented as: ‚ÄúPress the button with the text‚Äú OK ‚Äù.‚Äù <br><br>  When actions are described at the application interface level, they can be made independent of the location of the interface elements, the screen resolution and the device position. <br><br>  In addition, Robotium allows you to check the application's reaction to the action. <br><br>  For example, after clicking on the ‚ÄúOK‚Äù button in the application, a list should appear with the element ‚ÄúItem 1‚Äù.  With the help of Robotium you can check whether the list has appeared with such an element <br><br>  If you perform checks after each action, it is easy to detect at which step the error occurred. <br><br>  <strong>Disadvantages:</strong> <br><ul><li>  For each application, it is necessary to develop a test script in the Java language.  This requires programming skills and time-consuming. </li><li>  If you change the application interface, the test script will have to be modified. </li><li>  Writing a Robotium script is more difficult than writing actions using getevent / sendevent. </li></ul><br>  In general, Robotium allows you to develop the highest quality test scenarios at adequate cost. <br><br><h3>  Comparison of testing methods </h3><br><table><tbody><tr><th>  <strong>Test method</strong> </th><th>  <strong>Virtues</strong> </th><th>  <strong>disadvantages</strong> </th></tr><tr><td>  Monkey - a stream of random user actions. </td><td>  There are no maintenance costs. <br>  Does not depend on the device. <br>  Stress testing can detect nontrivial errors. <br></td><td>  The quality of testing varies from application to application. <br>  The errors found are difficult to reproduce. <br>  No check of application status. <br></td></tr><tr><td>  MonkeyRunner is a device management script. </td><td>  Flexibility. </td><td>  The complexity of writing and maintaining scripts even for simple applications. </td></tr><tr><td>  getevent / sendevent - record / play user actions. </td><td>  Recording a sequence of actions does not require programming skills. </td><td>  The recorded sequence of actions applies only to one device with a fixed orientation. <br>  When changing the application interface, you need to re-record the sequence of actions. <br>  No check of application status. <br></td></tr><tr><td>  Robotium - a script for testing the application's interface with state checking. </td><td>  Actions are described at the application interface level. <br>  The script can be independent of the screen resolution and device orientation. <br>  After completing the action, you can check the status of the application. <br></td><td>  The complexity of writing scripts in the Java language.  When the application interface changes, the script will have to be modified. </td></tr></tbody></table><br><h2>  Results analysis </h2><br>  As a result of testing the application using the methods listed above, we received logs and screenshots.  Now they need to be analyzed for errors. <br><br><h3>  Log Analysis </h3><br>  For starters, you can do a search by substrings: <br><ul><li>  I / DEBUG </li><li>  FATAL EXCEPTION </li><li>  WIN DEATH </li></ul><br>  The list can be supplemented as errors are detected during manual testing. <br><br><h3>  Screenshot Analysis </h3><br>  In the process of testing manually, you can prepare a series of screenshots at key points of testing, and then compare them with the screen contents in the process of automated testing.  This will determine if the automated testing process is proceeding correctly and detect errors. <br><br>  It is also useful to compare the screenshot before and after running the application - this allows you to determine when an application crashes without messages on the screen and in the logs. <br><br>  MonkeyRunner allows you to compare two screenshots with a given tolerance in percent: <br><pre> <code class="python hljs">image1 = device.takeSnapshot() <span class="hljs-comment"><span class="hljs-comment"># ... image2 = device.takeSnapshot() if image2.sameAs(image1, 0.1): print 'image1 and image2 are the same (10%)'</span></span></code> </pre><br>  Unfortunately, the MonkeyImage API does not provide a function to load from a file.  Therefore, to compare the saved screenshots, you will have to write your own function, for example, using the <a href="http://www.pythonware.com/products/pil/">Python Imaging Library</a> . <br><br><h2>  Reset device status after testing </h2><br>  After testing the application, the device must be returned to its original state. <br><br>  This can be achieved in several ways: <br><ul><li>  Repeatedly pressing the back button. </li><li>  Reboot the device. </li><li>  Restart zygote process. </li></ul><br>  Consider the first option, as the most appropriate. <br><br><h3>  Pressing the back button repeatedly </h3><br>  Press the "Back" button using MonkeyRunner: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): device.press(<span class="hljs-string"><span class="hljs-string">'KEYCODE_BACK'</span></span>, MonkeyDevice.DOWN_AND_UP) time.sleep(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre><br>  In practice, this option is optimal, since it simulates the behavior of a real user. <br><br><h2>  Conclusion </h2><br>  In the note, some methods of automatic testing of Android applications, their advantages and disadvantages were considered.  In addition, the tools included in the Android SDK or distributed under the Open Source license are reviewed. <br><br>  It should be noted that automatic testing is not a panacea and does not replace other types of testing.  A quality product is obtained with a well-constructed testing process that combines various methods. </div><p>Source: <a href="https://habr.com/ru/post/152122/">https://habr.com/ru/post/152122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152115/index.html">Great plugin to check the layout</a></li>
<li><a href="../152116/index.html">Easy way to record technical subjects with LibreOffice Math</a></li>
<li><a href="../152117/index.html">Selectel lies again</a></li>
<li><a href="../152118/index.html">Default structures and constructors</a></li>
<li><a href="../152119/index.html">LispyScript - Lisp JavaScript</a></li>
<li><a href="../152123/index.html">User queries to the database in MODx Revolution</a></li>
<li><a href="../152125/index.html">Sectioning: Shot and forget</a></li>
<li><a href="../152126/index.html">Kotlin M3 released</a></li>
<li><a href="../152129/index.html">Dots without a point - for and against</a></li>
<li><a href="../152131/index.html">oDesk for beginners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>