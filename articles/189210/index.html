<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Looking for loopholes: DOM Based XSS Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="XSS is not without reason at the top of the list of hazards OWASP TOP 10. Any intelligent programmer knows about them. But this does not prevent stati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Looking for loopholes: DOM Based XSS Guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/8e9/fd5/035/8e9fd5035c6b4c7bda977188bef00b85.jpg"><br><br>  <i>XSS is not without reason at the top of the list of hazards OWASP TOP 10. Any intelligent programmer knows about them.</i>  <i>But this does not prevent statistics: eight out of ten web applications have XSS vulnerabilities.</i>  <i>And if you recall the personal experience of pentest banks, then the picture ‚Äúten out of ten‚Äù seems more realistic.</i>  <i>It seems that the topic has been moved away from and to, but there is a subspecies of XSS, which has been lost for various reasons.</i>  <i>This is a DOM Based XSS.</i>  <i>And just about him today I am writing.</i> <br><br><a name="habracut"></a><h4>  Focus offset </h4>  Attacks against clients represent one of the main problems in web security.  XSS, Clickjacking, CSRF - all of them are directed against ordinary users, and not against the server components of the systems.  And if earlier it was possible to get a decent profit by exploiting vulnerabilities in the server part (and penetrating into the corporate network), now the focus of hackers is shifting to the client side.  For this reason, XSSs, which are widely regarded with skepticism, can serve well. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What you can skip </h4>  First, I will make two explanations related to this article. First.  The main goal is to introduce to DOM Based XSS those people who have so far bypassed this type of vulnerability.  Tell about the intricacies of operation, as well as share thoughts on how to properly put the process of identifying such vulnerabilities.  This is a kind of educational program.  Therefore, depending on your knowledge, you can skip this or that piece. Now the second.  <a href="http://goo.gl/mY3zM">About</a> half a year ago, Vladimir Kochetkov wrote an excellent article on Habr√©, ‚Äú <a href="http://goo.gl/mY3zM">The whole truth about XSS, or why cross-site scripting is not a vulnerability?</a>  ".  It dealt with the fact that XSS is an attack, not a type of vulnerability.  I remember that it inflamed a number of fierce disputes and ‚Äúcrusades‚Äù, which is very amusing ... But I will call XSS both attack and vulnerability, although the statement ‚ÄúXSS is a type of attack‚Äù is true.  So it will be easier, although correctly understand the meaning, of course, important. <br><br><h4>  Alphabet XSS </h4>  I can not remind you why we need XSS'ki.  No, not to execute our user JavaScript code.  For this purpose, we can simply drag it onto a site that is completely under our control (http://evil.com). <br><br>  The task is to execute OUR JavaScript code in the user's browser in the context of the attacked domain (for example, in the context of gmail.com).  That is, the goal is to bypass the Same Origin Policy, because almost all browser security is on the SOP. <br><br>  Further, what XSS will give us?  Of course, in the simplest case, we just get user session cookies.  But in fact, we can do everything that JavaScript can: control what is displayed on the page and what is sent to the server, emulate user actions, steal data from the molds ... It is important to understand that XSS, depending on the situation and skill, can become a powerful weapon. Now about the classification.  Usually distinguished "stored" ("stored XSS" or "Type 2") and "reflected" ("reflected XSS" or "Type 1").  In the stored we send XSS-ku, and it is stored on the server, and then we send users to this page.  In the "reflected", our XSS returns in the body of the response from the server to a specific request from the XSS itself. But something is missing here.  And as you probably guessed, this is the topic of today's article DOM Based XSS (or Type 0).  For various reasons (some of which will be described below), this type of XSS is little known, even in our circles ... Perhaps this is due to the fact that they are not often scanned by scanners.  But let's move on to the theory. <br><br><h4>  What is DOM Based XSS? </h4>  To answer a question, you must first understand what the DOM is.  I'll start from afar, from my favorite topic - XML. For XML there are two main types of parsers.  The first is SAX (Simple API for XML) - this is a type of parsers with sequential processing of documents.  It reads the element and generates events.  Requires few resources, but very simple.  The second, the DOM (Document Object Model), completely loads the entire document into memory and presents it as a tree.  But more importantly, it allows you to completely manipulate it.  You can add, delete, change the structure, the elements (nodes) themselves and their attributes.  And what have XML?  Moreover, for some time now HTML is a subtype of XML. In general, this concept is used in browsers.  All received HTML-document from the server is represented as a DOM-tree in the browser, and in addition, it is possible to change it using the standard API through a particular language.  In our case, this is basically JavaScript.DOM consists of objects nested into each other in a hierarchical order, which are called nodes.  Each node in the structure represents an HTML element on the page.  The root element is document. The value stored in the nodes is text.  In addition, nodes have attributes that can also be accessed.  In fig.  1 shows the simplest HTML file, as well as the hierarchy that the browser creates.  More detail you can read about the DOM and try on examples with JavaScript here: <a href="http://goo.gl/suiZE">goo.gl/suiZE</a> . <br><br><img src="https://habrastorage.org/storage3/687/e32/36a/687e3236a165488d308effa439183f60.png"><br>  <strong>Fig.</strong>  <strong>1.</strong> The simplest DOM tree <br><br>  And, as already mentioned, we have the ability to manipulate DOM from JavaScript.  And what does this give us?  In certain cases, using these methods (if the data is incorrectly filtered), we can modify the DOM of the attacked site and achieve the execution of our JavaScript code in the context of the attacked site.  That is, the essence is the same XSS.  The simplest example is: <br><br><pre><code class="javascript hljs">&lt;body&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.write(location.href);</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/body&gt;</span></span></code> </pre> <br>  Having received such HTML, the browser will execute the JavaScript code and add a string to the body of the page (document.write), taking its value from location.href.  The problem here is that a hacker can control the value of location.href and insert his javascript, which will also be executed.  That is, if this page is test.html, then in order to add our code, we need our victim to go to the following URL (see Figure 2): <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//victim.com/test.html#&lt;script&gt;alert(document.cookie);&lt;/script&gt;</span></span></code> </pre><br><br><img src="https://habrastorage.org/storage3/b98/4af/950/b984af950eed957e76f5ddafe96d506e.png"><br>  <strong>Fig.</strong>  <strong>2.</strong> DOM Based XSS <br><br><img src="https://habrastorage.org/storage3/dc2/6e2/7cc/dc26e27cc0193eb116c89bd1d79f4f5c.png"><br>  <strong>Fig.</strong>  <strong>2.1.</strong>  Classic DOM Based XSS <br><br>  It is important to note here that in Firefox this example will not work.  For IE and Chrome, it is necessary to follow the link, and not just write a script in the address bar, since in the second case everything will be behind the URL before execution of the code (it will look like "% 3Cscript% 3Ealert (1);% 3C / script% 3E") . But the second example will be working for everyone: <br><br><pre> <code class="javascript hljs">&lt;body&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript"> </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">var</span></span></span></span><span class="xml"><span class="javascript"> l = location.hash.slice(</span></span><span class="hljs-number"><span class="xml"><span class="javascript"><span class="hljs-number">1</span></span></span></span><span class="xml"><span class="javascript">); </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">eval</span></span></span></span><span class="xml"><span class="javascript">(l); </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/body&gt;</span></span></code> </pre><br>  Exploitation: <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//victim.com/test_eval.html#alert(document.cookie)</span></span></code> </pre><br>  The XSS version is a little more non-standard: <br><br><pre> <code class="javascript hljs">&lt;body&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello my window name is: </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.write(</span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">.name);</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/body&gt;</span></span></code> </pre><br>  Operation (we open the victim's page from ours so that we can control window.name) - fig.  3: <br><br><pre> <code class="javascript hljs">&lt;script&gt;<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(<span class="hljs-string"><span class="hljs-string">"http://victim.com/test_window.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;script&gt;alert('XSS')&lt;/scr"</span></span> + <span class="hljs-string"><span class="hljs-string">"ipt&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  I hope it became clear where the legs grow for the DOM XSS. <br><br><img src="https://habrastorage.org/storage3/9fa/2d5/d14/9fa2d5d14d5fcbfd1792074998664704.png"><br>  <strong>Fig.</strong>  <strong>3.</strong> DOM Based XSS from window.name <br><br><h4>  Terminology? </h4>  The attack itself, oddly enough, is very bearded.  At least in 2005, Amit Klein (Amit Klein, <a href="http://goo.gl/OOb3U">goo.gl/OOb3U</a> ) wrote a sensible idea about the third kind of XSS, although the DOM XSS itself had already been found before that.  In his work a certain list was presented of where the data from the user could come from (Fig. 4) and which dangerous functions could lead to XSS (Fig. 5).  But, oddly enough, the theme has been developed and rethought in recent years - thanks in large part to people like Stefano Di Paola and Mario Heiderich. <br><br><img src="https://habrastorage.org/storage3/594/bfd/b31/594bfdb310e7937f4de982dd8c175f7a.png"><br>  <strong>Fig.</strong>  <strong>4.</strong> From where ... <br><br><img src="https://habrastorage.org/storage3/4b3/67d/dd6/4b367ddd60821270ae0b723d6798df76.png"><br>  <strong>Fig.</strong>  <strong>5.</strong> Where ... <br><br>  Most importantly, a certain terminology has been developed - what we control and can pass to the page is called ‚Äúsource‚Äù, and the result is where the data comes in, the dangerous functions with which we can attack and operate our XSS, are called ‚Äú sink  I will not even try to search for Russian analogues of terms. And if the sinks have not changed much (supplemented), the understanding of sources has grown greatly, which somewhat changes the understanding of the attack (its classification), but more on that later. It is important to understand here what is what in principle.  Details too much.  So, one of the most significant resources when digging DOM XSS will be the domxsswiki project ( <a href="http://goo.gl/yycvJ">goo.gl/yycvJ</a> ), which lists the main sources and sinks, as well as their subtleties in the context of various browsers. So, about the new classification that Aspect Security recently introduced (as trolling, probably) - see fig.  6. This classification is precise and underlines the essence of the DOM XSS.  No matter where the input data from the attacker comes from (from a specific server response, from the client, from the static part of the page) - it is important that they are used in critical functions by the client part.  For example, imagine a situation that we can send your nickname to the server and it will be stored somewhere there - the potential for Stored XSS is.  But if filtering hinders us, it would seem that we cannot do anything already.  And if our nickname is used somewhere else, but already in the context of the client side and is used somewhere to modify DOM?  It turns out that we have a second attempt for XSS'ki (now DOM XSS), because perhaps we don‚Äôt need those characters that were needed for Stored XSS, but were filtered on the server. <br><br><img src="https://habrastorage.org/storage3/684/b31/99c/684b3199c1143b30f2360409212c7900.png"><br>  <strong>Fig.</strong>  <strong>6.</strong> New classification? <br><br><img src="https://habrastorage.org/storage3/98c/444/c89/98c444c89ed7651cd03ec8c1945eba45.png"><br>  <strong>Fig.</strong>  <strong>7.</strong> New version of source types changes classification <br><br><img src="https://habrastorage.org/storage3/fbd/181/11b/fbd18111b9e58d827dbc556a1c85efa0.png"><br>  <strong>Fig.</strong>  <strong>8.</strong> From (new version) ... <br><br>  What is the essence of this part?  To make you understand that there are important general concepts, but the DOM XSS is a very specific and non-trivial in many ways. <br><br><h4>  DOM XSS Specificity </h4>  So, after a general reflection on the topic and a few examples, what can we isolate specific in the DOM XSS? First, the DOM XSS is first of all the problem of the client side of the web application.  I will clarify: this is not a client problem, but a problem of the client part of the application.  This is incorrect filtering / use of data obtained from untrusted sources in the client part of the web application, that is, mainly in JavaScript. This item has several consequences.  DOM XSS can be on ‚Äúany‚Äù page, even on plain HTML, if JavaScript is used there. Previously, the search for vulnerabilities focused on scripts, on pages where we could enter some data, as well as pages where we got the result, - while the static pages were not interesting as such.  Now, even ‚Äústatic‚Äù can bring vulnerability. Often enough for the DOM XSS, we don‚Äôt need to send XSS to the server at all.  The three examples above are proof of this.  For the first two examples, it is important to note that browsers (according to standards) do not send to the server what is after the ‚Äú#‚Äù symbol.  This Fragment identifier is a special part of the URI scheme used initially to create links to parts of the document.  Wiki example: ‚Äúhttp://www.example.org/foo.html#bar‚Äù refers to an element with id = bar on the foo.html page.  Its trick is that it is not sent to the server, but is available from JavaScript.  Such an identifier is constantly used in web 2.0 sites (the Gmail service is an example). So, the ‚Äúhttp://victim.com/test.html#‚Äù from the first example will force the browser to make a request to test.html, but without XSS, in js there will be a full line.  And no means of server protection (user data filtering, all kinds of WAF or IPS) will work.  The problem lies mainly in the client side of the web application.  This is the first point.  Secondly, we, as a rule, cannot use the standard techniques and tools that we use to identify classic XSS and SQL injections, since they are designed specifically to identify server problems.  Thirdly, although we, in fact, have the ability to access the source code (JavaScript is delivered to the client), but to properly and deeply look for such vulnerabilities is a very trivial task.  Subtleties and tricks - even dig a shovel :). <br><br><h4>  Difficulties and fishes </h4>  So, in the course of the last point, I want to give an illustrative picture from the presentation by Stefano Di Paola (Fig. 9).  Analyzing JavaScript is a terrible thing, especially with standard tools.  Yes, Mario Heiderich wrote two regexps to identify the main sink and source: <br><br><pre> <code class="javascript hljs">/((src|href|data|location|code|value|action)\s*[<span class="hljs-string"><span class="hljs-string">"'\]]*\s*\+?\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\s*["</span></span><span class="hljs-string"><span class="hljs-string">'\]]*\s*\()/ /(location\s*[\[.])|([.\[]\s*["'</span></span>]?\s*(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\W)|(localStorage|sessionStorage|Database)/</code> </pre><br>  But you have to go through the entire dataflow to understand where it comes from and what it takes, where and how it gets ... Not only that, besides searching for a potential DOM XSS vulnerability, you also need to write an exploit for it.  And browsers are different, and, worse, their behavior is different.  Not to mention the fact that browsers have a means of countering reflected XSS'kam - and they also have to be bypassed. If you take the first example and the value in location.href, then it contains the URL (general idea): <br><br><pre> <code class="javascript hljs">scheme:<span class="hljs-comment"><span class="hljs-comment">//user:pass@host/path/to/page.ext/Pathinfo;semicolon?search.location=value#hash=value&amp;hash2=value2</span></span></code> </pre><br>  And browsers have different urlencod URLs.  Firefox, for example, encodes &lt;&gt; characters after #, but IE does not encode .IE: <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//host/path/to/page.ext/test%3Ca%22'%0A%60=%20+%20%3E;test%3Ca%22'%0A%60=%20+%20%3E?test&lt;a"'%0A`=%20+%20&gt;;#test&lt;a"'%0A`=%20+%20&gt;;</span></span></code> </pre><br>  FF: <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//host/path/to/page.ext/test%3Ca%22%27%0A%60=%20+%20%3E;test%3Ca%22%27%0A%60=%20+%20%3E?test%3Ca%22%27%0A%60=%20+%20%3E;#test%3Ca%22%27%0A%60=%20+%20%3E;</span></span></code> </pre><br>  Because the first attack will be suitable only for IE, Chrome. At the same time, if the vulnerable page had the code <br><br><pre> <code class="javascript hljs">&lt;body&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.write(location.hash);</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/body&gt; &lt;!--  location.hash  location.href --&gt;</span></span></code> </pre><br>  then the exploit would work in all browsers, since FF for this object stores the value in decoded form. Next, another example of browser tricks.  There is, for example, a vulnerable page that adds to the script only the server name from the referer: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.write(<span class="hljs-string"><span class="hljs-string">'&lt;script src="http://Host/image.gif?t='</span></span>+(referrer.split(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>])+<span class="hljs-string"><span class="hljs-string">'&gt;&lt;/script&gt;'</span></span>);</code> </pre><br>  It would seem that there can be done?  Yes, we can influence referer!  All we need is to lure the user to our site and redirect it from the page we need to vulnerable.  Thus, we will affect the referer field. But here, it seems, a bummer begins ... But no.  Stefano found out that IE supports special characters in the host name.  That is, we can create a subdomain in ".evil.com" or, as in the example of Stefano, "" onreadystatechange = eval (name) .attacker.com ". In addition to browser pieces and native JavaScript code differences, there are also various JS frameworks which is used more than everywhere.  The same jQuery has a lot of wrappers over standard sinks (see fig. 10). <br><br><img src="https://habrastorage.org/storage3/8a9/778/506/8a9778506e1df823ec65c571044d938e.png"><br>  <strong>Fig.</strong>  <strong>9.</strong> JavaScript analysis is a thankless task <br><br><img src="https://habrastorage.org/storage3/61d/223/e14/61d223e14c1bf5437360f99770efd5b8.png"><br>  <strong>Fig.</strong>  <strong>10.</strong> jQuery and other frameworks make analysis more difficult. <br><br><h4>  Bypass filters </h4>  Hopefully, an understanding regarding DOM XSS has begun to appear.  Now indirectly touch protection.  Of course, the simplest option is to refuse JS on the client side :).  But it is clear that this is unreal.  The next option is not to use the safe functions of changing the DOM, as well as implement filtering of user data ... But, as you probably noticed, the DOM XSS is the same Temka.  It‚Äôs like some kind of colorful, bubbling essence that has no particular boundaries.  Therefore, there is no understanding of the sensible among the masses, and therefore, from the point of view of error protection, many are allowed. Not so long ago I read an <a href="http://goo.gl/5Djf7">excellent article</a> , which we will now examine.  It describes two examples of ‚Äúsafe‚Äù DOM changes by using filtering of user data. Example 1. Using element.textContent, which is used to set / read the text value of a node.  Used also for filtering HTML.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = <span class="hljs-string"><span class="hljs-string">'Hello &lt;a href="http://bob.com"&gt;Bob&lt;/a&gt;!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(div.textContent); <span class="hljs-comment"><span class="hljs-comment">// Hello Bob!;</span></span></code> </pre><br>  Here div.textContent cut out ‚Äú <a href="http://bob.com/">Bob</a> ‚Äù when adding an element.  It seems to be safe and we can not add XSS?  And no.  This method has a feature: it converts the HTML entity back to HTML: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = <span class="hljs-string"><span class="hljs-string">'Hello &lt;a&gt;&amp;lt;script&amp;gt;alert(&amp;quot;!&amp;quot;)&amp;lt;/script&amp;gt;&lt;/a&gt;!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(div.textContent); <span class="hljs-comment"><span class="hljs-comment">// Hello &lt;script&gt;alert("!")&lt;/script&gt;!</span></span></code> </pre><br>  That is, with minor frauds, we can simply implement XSS'ku.  If we use this method in a slightly different order. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.textContent = <span class="hljs-string"><span class="hljs-string">'&lt;span&gt;Foo &amp; bar&lt;/span&gt;'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(div.innerHTML) <span class="hljs-comment"><span class="hljs-comment">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span></span></code> </pre><br>  then it will again seem to be a completely safe result.  The author notes that document.createTextNode has a similar behavior.  The characters &lt;,&gt;, &amp; were replaced with the corresponding entities.  And this method is also used for "filtering".  But you probably noticed that there is no important enough character in the filter - the quotation mark.  And this fact from the theory of classic XSS reminds us of the possibility of operating XSS on the basis of events (event), which the author shows by example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">escapeHtml</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(str)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div.innerHTML; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userWebsite = <span class="hljs-string"><span class="hljs-string">'" onmouseover="alert(\'derp\')" "'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> profileLink = <span class="hljs-string"><span class="hljs-string">'&lt;a href="'</span></span> + escapeHtml(userWebsite) + <span class="hljs-string"><span class="hljs-string">'"&gt;Bob&lt;/a&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'target'</span></span>); div.innerHtml = profileLink; <span class="hljs-comment"><span class="hljs-comment">// &lt;a href="" onmouseover="alert('derp')" ""&gt;Bob&lt;/a&gt;</span></span></code> </pre><br>  Oddly enough, the problem stretches and "flows" into other solutions.  For example, jQuery has the same features in .text ().  In addition, some filtering information can be found in the same domxsswiki. <br><br><h4>  Reality </h4>  A couple of examples.  Firstly, the classic version, which was found on Twitter: e: XSS, oddly enough, was trivial: <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//twitter.com/#!javascript:alert(document.domain);</span></span></code> </pre><br>  There is a substitution of the pseudo-jander javascript in the location and, as a result, the execution of our code. A modern example from the AVG site: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//display the correct tab based on the url (#name) var pathname = $(location).attr('href');var urlparts = pathname.split("#");</span></span></code> </pre><br>  Operation is again trivial: <br><br><pre> <code class="javascript hljs">http:<span class="hljs-comment"><span class="hljs-comment">//www.avg.com/eu-en/download#"&gt;&lt;img src=x onerror=prompt(/xss/);&gt;</span></span></code> </pre><br>  Further, a slightly more strange example, when it seems that the vulnerability is close, but it is not easy to exploit it.  This vulnerability was found in Adobe Flex 3. The vulnerable page - / history / historyFrame.html - is still massively on the web (including on ‚Äúpowerful‚Äù portals). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = url.indexOf(<span class="hljs-string"><span class="hljs-string">"?"</span></span>); url = pos != <span class="hljs-number"><span class="hljs-number">-1</span></span> ? url.substr(pos + <span class="hljs-number"><span class="hljs-number">1</span></span>) : <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parent._ie_firstload) { parent.BrowserHistory.setBrowserURL(url); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parent.BrowserHistory.browserURLChange(url); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent._ie_firstload = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.href; processUrl(); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.write(url);</code> </pre><br>  If you look at the last lines, it seems - XSS here, on a silver platter.  But no, there is a problem - checks the parent._ie_firstload in the processUrl function.  Directly do not exploit the vulnerability - javascript just does not reach the right place. Since the page does not have such an object as parent, then JavaScript will fly to ‚Äúparent.BrowserHistory.setBrowserURL (url);‚Äù.  But we can cheat and create a page on our website that will contain two frames: <br><br><pre> <code class="javascript hljs">&lt;html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"_ie_firstload"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"http://www.vuln.site/app/history/historyFrame.html?#&lt;script&gt;alert('xss')&lt;/script&gt;"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/html&gt;</span></span></code> </pre><br>  Thus, we create a frame to which the code from the vulnerable page will be accessed as a result of the ‚Äúif (! Parent._ie_firstload)‚Äù check.  And since now some object already exists, the check falls on Else and the function successfully completes, giving you the opportunity to start the DOM XSS. But this method also has its subtleties.  For example, FF prohibits contacting a parent from another domain, and therefore, according to the author‚Äôs experience, you could only use it against IE. If you are interested in the DOM XSS theme, you should look at other examples to gain experience: <a href="http://goo.gl/ZWei3">goo.gl/ZWei3</a> , <a href="http://goo.gl/gZawa">goo .gl / gZawa</a> , <a href="http://goo.gl/XRwBT">goo.gl/XRwBT</a> , <a href="http://goo.gl/plqs9">goo.gl/plqs9</a> . <br><br><h4>  Afterword </h4>  Perhaps, I repeat, but, summing up, I would like to say that the DOM Based XSS is the still incomprehensible animal.  And the more incomprehensibility and subtleties - the more bugs.  Especially given the fact that JavaScript is increasingly ‚Äúpulling the blanket over itself,‚Äù and the web is becoming more and more dynamic.  In general, learning is light, and creating is wonderful :).  Successful perecherv! <br><br><img src="https://habrastorage.org/storage2/6ba/78d/e11/6ba78de1193ba257dd7b576cfe343386.jpg"><br>  <i>First published in the Hacker magazine dated 05/2013.</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://www.xakep.ru/articles/magazine/pdf/">Read in PDF</a> </li><li>  <a href="http://bit.ly/digital_xakep">Read iPad / iPhone</a> </li><li>  <a href="http://bit.ly/habr_android">Read on Android</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Subscribe to the paper magazine</a> </li></ul><br> <a href="http://bit.ly/xakep_on_ipad"><img src="https://habrastorage.org/storage2/a86/fc6/a22/a86fc6a22179b180d53a36f9cb5a7d3f.png"></a> <br><br>  PS Can you share knowledge and interesting ideas by writing for] [?  Let me know :).  We pay fees, but this should not be the main motivation. <habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/189210/">https://habr.com/ru/post/189210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189194/index.html">Languages ‚Äã‚Äãin Europe: when does translation make sense?</a></li>
<li><a href="../189200/index.html">Is there life without Resharper - 2?</a></li>
<li><a href="../189202/index.html">Compact server ETegro Hyperion ES200 G4</a></li>
<li><a href="../189206/index.html">Barrier to the Big Games</a></li>
<li><a href="../189208/index.html">RFID tag for ravioli</a></li>
<li><a href="../189212/index.html">What do you know about Tom?</a></li>
<li><a href="../189214/index.html">Thai authorities threatened with prison for huskies posts on Facebook</a></li>
<li><a href="../189216/index.html">test.it - ‚Äã‚Äãnot again, but again</a></li>
<li><a href="../189220/index.html">Petition to lift the ban on the sale of Company of Heroes 2</a></li>
<li><a href="../189226/index.html">Dunbar number and VKontakte users</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>