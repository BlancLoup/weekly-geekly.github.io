<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Load balancing: basic algorithms and methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The question of load planning should be addressed at an early stage of development of any web project. The ‚Äúfall‚Äù of the server (and it always happens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Load balancing: basic algorithms and methods</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/e36/94b/3cae3694b07da2e9c81c9512bb406d5c.png" alt="load balancing" width="100%" height="100%"><br><br>  The question of load planning should be addressed at an early stage of development of any web project.  The ‚Äúfall‚Äù of the server (and it always happens unexpectedly, at the most inopportune moment) is fraught with very serious consequences, both moral and material.  Initially, problems with insufficient server performance due to increased loads can be solved by increasing server capacity, or by optimizing the algorithms used, software codes, and so on.  But sooner or later there comes a time when these measures are also insufficient. <br><br>  It is necessary to resort to clustering: several servers are combined into a cluster;  the load between them is distributed using a set of special methods called balancing.  In addition to solving the problem of high loads, clustering also helps provide redundancy of servers to each other. <br>  The efficiency of clustering directly depends on how the load is distributed (balanced) between the cluster elements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Load balancing can be carried out using both hardware and software tools.  We would like to talk about the basic methods and algorithms and balancing in this article. <br><a name="habracut"></a><br><h2>  Balancing levels </h2><br>  The balancing procedure is carried out with the help of a whole complex of algorithms and methods corresponding to the following levels of the OSI model: <br><br><ul><li>  networked; </li><li>  transport; </li><li>  applied. </li></ul><br><br>  Consider these levels in more detail. <br><br><h3>  Network Level Balancing </h3><br>  Balancing at the network level involves solving the following problem: you need to make sure that different physical machines are responsible for one specific server IP address.  Such balancing can be carried out using a variety of different ways. <br><br><ul><li>  <b>DNS balancing.</b>  Multiple IP addresses are allocated to one domain name.  The server to which the client request will be sent is usually determined using the Round Robin algorithm (the methods and algorithms of balancing will be described in detail below). </li><li>  <b>Building NLB Cluster.</b>  When using this method, servers are combined into a cluster consisting of input and compute nodes.  The load is distributed using a special algorithm.  Used in solutions from Microsoft. </li><li>  <b>IP balancing using an optional router.</b> </li><li>  <b>Balancing on a territorial basis is</b> carried out by placing the same services with the same addresses in geographically different regions of the Internet (this is how the Anycast DNS technology works, which we <a href="http://blog.selectel.ru/vnedrenie-anycast-dns/">have already written about</a> ).  Territorial balancing is also used in many CDNs (see <a href="http://habrahabr.ru/company/ivi/blog/237349/" rel="nofollow">interesting implementation example</a> ). </li></ul><br><br><h2>  Balancing at the transport level </h2><br>  This type of balancing is the simplest: the client calls the balancer, who forwards the request to one of the servers, which will process it.  The choice of the server on which the request will be processed may be carried out in accordance with a variety of algorithms (this will be discussed below): by simple round-robin, by selecting the least loaded server from the pool, etc. <br><br>  Sometimes balancing at the transport level is difficult to distinguish from balancing at the network level.  Consider the following rule for the pf network filter in BSD systems: for example, formally, this is about balancing traffic on a specific TCP port (an example for a pf network filter in BSD systems): <br><br><pre> web_servers = "{10.0.0.10, 10.0.0.11, 10.0.0.13}"

 match t_p to port 80 rdr-to $ web_servers round-robin sticky-address
</pre><br><br>  It is about balancing traffic on a specific TCP port. <br><br>  Consider now another example: <br><br><pre> pass in on $ int_if from $ lan_net \
    route-to {($ ext_if1 $ ext_gw1), ($ ext_if2 $ ext_gw2)} \
    round-robin
</pre><br><br>  This rule is about balancing outbound traffic at the network level.  It does not specify a specific port or a specific protocol. <br><br>  The difference between the balancing levels can be explained as follows.  The network level includes solutions that do not terminate user sessions on themselves.  They simply redirect traffic and do not work in proxy mode. <br>  At the network level, the balancer simply decides which server to send packets to.  The session with the client is carried out by the server. <br><br>  At the transport level, communication with the client is closed on the balancer, which works as a proxy.  It interacts with servers on its own behalf, passing information about the client in additional data and headers.  Thus, for example, the popular software balancer HAProxy works. <br><br><h3>  Balancing at the application level </h3><br>  When balancing at the application level, the balancer works in the ‚Äúsmart proxy‚Äù mode.  It analyzes client requests and redirects them to different servers depending on the nature of the requested content.  This is how, for example, the Nginx web server works by distributing requests between the front-end and the backend.  Upstream module is responsible for balancing in Nginx.  For more information about the features of balancing Nginx based on various algorithms can be found, for example, <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-load-balancing" rel="nofollow">here</a> . <br><br>  As another example of an application level balancing tool, pgpool is an intermediate layer between the client and the PostgreSQL DBMS server.  With it, you can distribute requests to database servers depending on their content, for example, read requests will be sent to one server, and write requests to another.  You can read more about pgpool and the specifics of working with it <a href="http://searchadmin.org/Thread-ha-postgresql-cluster-by-streaming-replication-pgpool-ii/" rel="nofollow">in this article</a> ). <br><br><h2>  Algorithms and methods of balancing </h2><br>  There are many different algorithms and methods for load balancing.  Choosing a specific algorithm, you need to proceed, firstly, from the specifics of a particular project, and secondly, from goals.  which we plan to achieve. <br><br>  Among the goals for which balancing is used, the following should be highlighted: <br><br><ul><li>  <b>fairness</b> : it is necessary to ensure that system resources are allocated for the processing of each request and to prevent situations in which one request is processed and all others are waiting for their turn; </li><li>  <b>efficiency</b> : all servers that process requests must be 100% busy;  It is desirable not to allow a situation where one of the servers is idle while waiting for requests for processing (we will immediately make a reservation that in real practice this goal is not always achieved); </li><li>  <b>shortening the query execution time</b> : it is necessary to ensure a minimum time between the beginning of the processing of a request (or its queuing for processing) and its completion </li><li>  <b>shorter response time</b> : you need to minimize the response time to a user request. </li></ul><br><br>  It is also highly desirable that the balancing algorithm has the following properties: <br><br><ul><li>  <b>predictability</b> : you need to clearly understand in what situations and under what loads the algorithm will be effective for solving the set tasks; </li><li>  <b>uniform loading of system resources</b> ; </li><li>  <b>scalability</b> : the algorithm must remain operable with increasing load. </li></ul><br><br><h3>  Round robin </h3><br>  Round Robin, or round-robin algorithm, is a round-robin loop: the first request is sent to one server, then the next request is sent to another and so on until the last server is reached, and then it all starts over again. <br><br>  The most common implementation of this algorithm is, of course, the Round Robin DNS balancing method.  As you know, any DNS server stores a pair of "host name - IP address" for each machine in a specific domain.  This list might look like this: <br><br><pre> example.com xxx.xxx.xxx.2
 www.example.com xxx.xxx.xxx.3
</pre><br><br>  You can associate several IP addresses with each name from the list: <br><br><pre> example.com xxx.xxx.xxx.2
 www.example.com xxx.xxx.xxx.3
 www.example.com xxx.xxx.xxx.4
 www.example.com xxx.xxx.xxx.5
 www.example.com xxx.xxx.xxx.6
</pre><br><br>  The DNS server goes through all the records in the table and gives the following IP address for each new request: for example, the first request is xxx.xxx.xxx.2, the second is xxx.xxx.xxxx.3, and so on.  As a result, all servers in the cluster receive the same number of requests. <br><br>  Among the undoubted advantages of this algorithm should be called, first, independence from the high-level protocol.  To work using the Round Robin algorithm, any protocol is used in which the server is accessed by name. <br>  Balancing based on the Round Robin algorithm does not depend on the load on the server: the caching DNS servers will help to cope with any influx of clients. <br><br>  Using the Round Robin algorithm does not require communication between servers, so it can be used for both local and global balancing. <br>  Finally, solutions based on the Round Robin algorithm have a low cost: in order for them to start working, just add a few records to the DNS. <br><br>  The Round Robin algorithm also has a number of significant drawbacks.  In order for the load distribution according to this algorithm to meet the above criteria of fairness and efficiency, it is necessary that each server should have the same set of resources.  When performing all operations, the same amount of resources should also be involved.  In actual practice, these conditions, in most cases, turn out to be impossible. <br><br>  Also, when balancing according to the Round Robin algorithm, the load of one or another server within the cluster is completely ignored.  Imagine the following hypothetical situation: one of the nodes is 100% loaded, while the others are only 10 - 15%.  The Round Robin algorithm does not take into account the possibility of such a situation in principle, so the overloaded node will still receive requests.  In this case, there is no question of any fairness, efficiency and predictability. <br><br>  Due to the circumstances described above, the scope of the Round Robin algorithm is very limited. <br><br><h3>  Weighted round robin </h3><br>  This is an enhanced version of the Round Robin algorithm.  The essence of the improvements is as follows: each server is assigned a weighting factor in accordance with its performance and power.  This helps to distribute the load more flexibly: servers with more weight handle more requests.  However, this does not solve all the problems with fault tolerance.  More effective balancing is provided by other methods in which a greater number of parameters are taken into account when planning and distributing the load. <br><br><h3>  Least connections </h3><br>  In the previous section, we listed the main disadvantages of the Round Robin algorithm.  Let's call one more: it does not take into account the number of currently active connections. <br><br>  Consider a practical example.  There are two servers - let's denote them conditionally as A and B. Fewer users are connected to server A than to server B. Server A is more overloaded.  How is this possible?  The answer is quite simple: connections to server A are maintained for a longer time compared to connections to server B. <br><br>  The described problem can be solved with the help of an algorithm known as least connections (in abbreviated form - leastconn).  It takes into account the number of connections currently supported by servers.  Each following question is transmitted to the server with the least number of active connections. <br><br>  There is an improved version of this algorithm, intended primarily for use in clusters consisting of servers with different technical characteristics and different performance.  It is called Weighted Least Connections and takes into account in the load distribution not only the number of active connections, but also the weighting factor of the servers. <br><br>  Among other advanced variants of the Least Connections algorithm, we should first of all highlight Locality-Based Least Connection Scheduling and Locality-Based Least Connection Scheduling with Replication Scheduling. <br><br>  The first method was created specifically for caching proxy servers.  Its essence is as follows: the largest number of requests is transmitted to servers with the least number of active connections.  Each client server is assigned a group of client IPs.  Requests from these IPs are sent to the ‚Äúnative‚Äù server, if it is not fully loaded.  Otherwise, the request will be redirected to another server (it should be loaded less than half). <br><br>  In the Locality-Based Least Connection Scheduling with Replication Scheduling algorithm, each IP address or group of IP addresses is assigned not to a separate server, but to a whole group of servers.  The request is transferred to the least loaded server from the group.  If all the servers from the ‚Äúnative‚Äù group are overloaded, then a new server will be reserved.  This new server will be added to the group serving the IP from which the request was sent.  In turn, the most loaded server from this group will be removed - this avoids redundant replication. <br><br><h3>  Destination Hash Scheduling and Source Hash Scheduling </h3><br>  The Destination Hash Scheduling algorithm was designed to work with a cluster of caching proxy servers, but it is often used in other cases.  In this algorithm, the server processing the request is selected from a static table by the recipient's IP address. <br><br>  The Source Hash Scheduling algorithm is based on the same principles as the previous one, only the server that will process the request is selected from the table by the sender's IP address. <br><br><h3>  Sticky sessions </h3><br>  Sticky Sessions is an algorithm for distributing incoming requests, in which connections are transmitted to the same server in the group.  It is used, for example, in the Nginx web server.  User sessions can be assigned to a specific server using the IP hash method (for more information about it, see the <a href="http_upstream_module.html" rel="nofollow">official documentation</a> ).  With this method, requests are distributed across servers based on the client's IP address.  As stated in the documentation (see link above), "the method ensures that requests for the same client will be transmitted to the same server."  If the server assigned to a specific address is not available, the request will be redirected to another server.  An example of a fragment of the configuration file: <br><br><pre> upstream backend {
 ip_hash;

 server backend1.example.com;
 server backend2.example.com;
 server backend3.example.com;
 server backend4.example.com;
 }
</pre><br><br>  Starting with version 1.2.2 in Nginx, you can specify a weight for each server. <br><br>  The use of this method poses some problems.  Session binding problems can occur if the client uses dynamic IP.  In a situation where a large number of requests go through one proxy server, balancing can hardly be called effective and fair.  The problems described, however, can be solved using cookies.  In the commercial version of Nginx there is a special module sticky, which just uses cookies for balancing.  He also has free analogues - for example, <a href="https://code.google.com/p/nginx-sticky-module" rel="nofollow">nginx-sticky-module</a> . <br>  You can use the sticky-sessions method in HAProxy too - for more information, see <a href="https://serversforhackers.com/haproxy/" rel="nofollow">here.</a> <br><br><h2>  Conclusion </h2><br>  This article is essentially an introduction to load balancing.  We will continue the discussion of this topic in further publications.  If you have questions, comments and additions - welcome to comments.  We would also be grateful if you share non-trivial practical examples of load balancing for various projects. <br><br>  Readers who for one reason or another cannot post comments here are invited to <a href="http://blog.selectel.ru/balansirovka-nagruzki-osnovnye-algoritmy-i-metody/">our blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/250201/">https://habr.com/ru/post/250201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250191/index.html">Binary operations on ordered sets</a></li>
<li><a href="../250193/index.html">Flames in CSS</a></li>
<li><a href="../250195/index.html">Ubuntu 14.04 + Asterisk 11 + CDR-Stats</a></li>
<li><a href="../250197/index.html">How to be ready or DR on Nutanix: asynchronous replication</a></li>
<li><a href="../250199/index.html">What every programmer should know about compiler optimization</a></li>
<li><a href="../250203/index.html">What Mono 4.0.0 prepares for us</a></li>
<li><a href="../250205/index.html">From React to Riot 2.0</a></li>
<li><a href="../250207/index.html">Technologies that improve the resiliency of VPS</a></li>
<li><a href="../250209/index.html">PVS-Studio for Microsoft Visual Studio Community 2013</a></li>
<li><a href="../250217/index.html">Reduce development and testing time with Azure Web Sites and Visual Studio Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>