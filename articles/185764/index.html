<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Device file UEFI BIOS, part and a half: UEFI Platform Initialization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of this article, we learned about the UEFI Capsule and Intel Flash Image format. It remains to consider the structure and contents o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Device file UEFI BIOS, part and a half: UEFI Platform Initialization</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/185704/">first part of this article,</a> we learned about the UEFI Capsule and Intel Flash Image format.  It remains to consider the structure and contents of EFI Firmware Volume, but to understand the differences between <abbr title="Pre-EFI Initialization">PEI</abbr> modules and <abbr title="Driver Execution Environment">DXE</abbr> drivers, we start with the UEFI boot process, and leave the structure of EFI Firmware Volume to the second part. <br><a name="habracut"></a><br><h4>  UEFI Platform Initialization </h4><br>  From a bird's eye view, the UEFI boot process looks like this: <br><img src="https://habrastorage.org/storage2/893/3b8/f4e/8933b8f4e804bc0de56aec0d77305566.png"><br>  Generally speaking, we are not interested in all this process, but in its part - Platform Initialization (PI), which is divided into 3 phases: <abbr title="Security">SEC</abbr> , <abbr title="Pre-EFI Initialization">PEI</abbr> and <abbr title="Driver Execution Environment">DXE</abbr> . <br>  All PI documentation can be freely <a href="http://www.uefi.org/specs/download_platform/">downloaded from the UEFI Forum website</a> .  The SEC and PEI phases are described in Volume 1, the DXE phase in Volume 2, common architectural elements, including the EFI <abbr title="Firmware File System">FFS</abbr> file and header formats that interest us in Volume 3, the <abbr title="System Management Mode">SMM</abbr> subphase (starts in the middle of DXE and runs parallel) in Volume 4, standards for equipment and software compatible with PI are in Volume 5. I will not write about equipment and software here, but the remaining phases should be mentioned, since  without knowing them, it is difficult to understand why there is so much in the BIOS file and how it all differs from each other. <br><br><h5>  SEC Phase </h5><br>  The first phase of the download, the tasks of which are as follows: <br><ol><li>  Process all types of platform restarts: power on after inactive state, rebooting from active state, exit from deep sleep mode, various exceptions </li><li>  Prepare a temporary memory </li><li>  Become a Root of Trust system: either trust the rest of the PI, or check their validity in some way </li><li>  Prepare the necessary data structures and transfer them and control to the PEI phase.  At a minimum, the state of the platform, the address and size of the <abbr title="Boot firmware">BFV</abbr> , the address and size of the temporary RAM, the address and size of the stack are transmitted </li></ol><br>  In fact, on x86-64, the SEC phase goes like this: <br><ol><li>  Reset Vector: reset the cache and go to the main initialization procedure in ROM </li><li>  Switch to protected mode: switch to a protected mode processor with flat memory without paging </li><li>  Initialize MTRRs for BSP: caching of known values ‚Äã‚Äãfor different memory areas </li><li>  Microcode Patch Update: microcode update of all available processors </li><li>  Initialize <abbr title="No-Eviction Mode">NEM</abbr> : the free cache is marked as non-resettable, after which it can be used as temporary RAM before initialization of the main one, and also allows you to write this initialization on ordinary PLs with a stack, in this case C </li><li>  Early <abbr title="Bootstrap Processor">BSP</abbr> / <abbr title="Application processor">AP</abbr> interactions: sending all AP interrupts INIT <abbr title="Inter-Processor Interrupt">IPI</abbr> , then Start-up IPI, receiving <abbr title="Build-In Self Test">BIST</abbr> data from all APs </li><li>  Hand-off to PEI entry point: transfer of control and data to the PEI phase </li></ol><br>  It can be seen that participants in the SEC phase from the BIOS image will need at least patches for the CPU microcode stored there, as well as the address and size of the Boot Firmware Volume.  Yes, and the SEC code itself is recorded in the same chip and is still running there. <br><br><h5>  PEI phase </h5><br>  The second phase, the main task of which is to initialize enough continuous RAM so that you can start the DXE phase, prepare and transfer the detected devices to the DXE phase so that the DXE drivers can correctly initialize them.  The PEI executable code consists of a kernel called the PEI Foundation, which is common to processors with the same architecture and <abbr title="PEI Module">PEIM</abbr> modules that perform initial initialization of specific devices and developed by the manufacturers of these devices.  Chain of Trust support modules that perform validation checks on other modules may also be present.  PEI allows independent development and debugging of modules, and no one bothers to write and integrate your own module, if necessary. <br>  PEIM may have a list of dependencies on other modules, so the order of their launch is not random and is chosen by the PEI dispatcher.  PEIM modules can fill in data-independent data structures ‚Äî <abbr title="Hand-off block">HOBs</abbr> , which contain data for transmission to the DXE driver and GUID of this driver. <br>  In fact, on x86-64, the PEI phase happens like this: <br><ol><li>  Establish use of "memory": transfer data from ROM to early RAM (i.e., cache) </li><li>  PEI Dispatcher: Launching PEIM modules in order from non-dependencies to complex dependencies.  This is a loop that ends at the moment when there are no remaining modules </li><li>  CPI PEIM: CPU initialization, MSR setup, etc.  (We will return to this module when discussing the CPU PM patch) </li><li>  Platform PEIM: early initialization of <abbr title="Memory Controler Hub">MCH</abbr> , <abbr title="I / O Controler Hub">ICH</abbr> , embedded platform interfaces ( <abbr title="System Management Bus">SMBus</abbr> , Reset, etc.).  Determination of the boot mode (normal, Recovery, S3 Resume), using data obtained in the SEC phase. </li><li>  Memory Initialization PEIM: initialize the main RAM and transfer cache data to it, which can now be used normally.  the process depends on the state of the system defined at the previous step, for example, when S3 Resume memory testing is not performed, which reduces the load time </li><li>  If the system is not in S3 Resume, then HOBs and control are transferred to the DXE phase, and the PEI phase ends there. </li><li>  If it does, it is running the PEIM for S3 Boot Script CPU, which returns all processors to their saved state. </li><li>  S3 Boot Script Executor: restore the status of other devices </li><li>  OS Resume Vector: transition to OS </li></ol><br>  Thus, with S3 Resume, the launch of the DXE phase does not occur at all, which makes it possible to speed up the loading greatly.  When you turn on FastBoot, loading can be accelerated even more by running the minimum set of tests and PEIM modules. <br>  It can be seen that in the PEI phase from the BIOS image, at least the PEI Foundation and modules for all equipment that needs early initialization will be needed.  It is also worth telling that the format of PEI modules may either coincide with the format of the DXE (PE32 +) drivers, or be different from it by the header, since  The PE32 + header contains many fields that are not used in the PEI phase, and the place in the processor cache is not rubber.  Therefore, a special <abbr title="Terse executable">TE</abbr> format was developed for PEIM, the header of which contains only the required fields.  TEs are executable-in-place ( <abbr title="Execute-in-place">XIP</abbr> ), relocatable and position independent ( <abbr title="Position-Independent Code">PIC</abbr> ).  There are also hybrid DXE / PEI modules with two entry points, but they must be in PE32 + format, because otherwise the DXE driver will not launch such a module. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  DXE Phase </h5><br>  Here, the main and final initialization of everything is performed based on the HOBs received from PEI.  The DXE code consists of the kernel, it is the DXE Foundation, the dispatcher, and the drivers.  The kernel initializes and starts various UEFI services: Boot Services, Runtime Services, and DXE Services.  The dispatcher is responsible for finding and running DXE drivers, which also have dependencies.  Drivers perform final hardware initialization and provide hardware abstraction for services.  All DXE code, except the Runtime parts of the Foundation and the Runtime DXE drivers, is unloaded from memory at the end of the <abbr title="Boot device selection">BDS</abbr> phase, which I will not discuss here. <br>  There is no sense in describing the DXE startup process thoroughly either, it can be described in two words: the kernel is loaded, it creates the necessary data structures, then the dispatcher starts up and loads all available drivers from all available media, then the bootloader starts up and tries to find the OS bootloader on these media his management.  If it is found, it is excellent; if not, we try further until we find it.  If they didn‚Äôt find anything, we execute the code of the Platform Policy module, which the motherboard manufacturer wrote for us, giving us a message that ‚ÄúOperating System is missing‚Äù. <br>  It can be seen that from the BIOS image for this phase you need DXE-drivers and everything that they may need.  Most of the files in EFI FS are used here. <br><br><h5>  SMM subphase </h5><br>  During the DXE phase, the moment comes when the dispatcher loads the SMM Init driver, from which this subphase begins.  <abbr title="System Management Mode">SMM</abbr> is a special mode of the processor, which it switches to when receiving a special interrupt - <abbr title="System Management Interrupt">SMI</abbr> , which can be both software and hardware.  Most (or even all) SMI sources can be disabled if the transition to SMM is not required.  The SMM code runs in <abbr title="System Management RAM">SMRAM</abbr> , which becomes inaccessible to the OS after the end of the DXE phase, because the SMM driver intentionally closes access to it.  The SMM code is executed even after the end of the DXE phase, before the PC is turned off. <br>  The SMM Init driver opens SMRAM, creates its map and data structures needed to run other SMM drivers, and before the end of the phase, DXE closes SMRAM access completely.  SMM drivers are hardware dependent and do not have access to the bytecode interpreter, so writing SMM drivers on <abbr title="EFI Byte Code">EBC is</abbr> not supported.  There are two kinds of these drivers: pure SMM, which are loaded by the Init directly into SMRAM, and SMM / DXE hybrids, which are first launched by the DXE controller and then copy a part of themselves into SMRAM.  The SMM Init itself is just such a hybrid. <br>  It can be seen that SMM drivers are needed for this subphase from a BIOS image. <br><br><h4>  Conclusion </h4><br>  Now you know how UEFI boots and what modules are needed for it. <br>  I decided to divide the planned second part into two more in order to reduce the size of the post and reduce the cognitive load on the reader. <br>  In the second part of the article, we will finally look at the structure of the EFI FV file, and the information from this one will be very useful for you there. <br>  Thanks for attention. <br><br><h4>  Literature </h4><br><ol><li> <a href="http://www.sans.org/reading_room/whitepapers/services/analysis-building-blocks-attack-vectors-unified-extensible-firmware_34215">Unified Extensible Firmware Interface (UEFI), Paper by Jean-Fran√ßois Agneessens</a> </li><li>  <a href="http://www.intel.de/content/dam/www/public/us/en/documents/white-papers/reducing-platform-boot-time-paper.pdf">Reducing Platform, Michael Rothman, Genliu Xing, Yan Wang and Jiong Gong</a> </li><li>  <a href="">UEFI Platform Initialization Specification 1.2.1 Errata A, Documents by UEFI Forum</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/185764/">https://habr.com/ru/post/185764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185750/index.html">jQuery plugin for using SVG graphics. Part 1</a></li>
<li><a href="../185752/index.html">Biryulki and Gugloservis</a></li>
<li><a href="../185754/index.html">Unlocking AES-NI on Lenovo U310</a></li>
<li><a href="../185756/index.html">4K video of Saturn and its satellites</a></li>
<li><a href="../185760/index.html">Infinite non-repeating textures using Van's mosaic</a></li>
<li><a href="../185766/index.html">Vkontakte iOS SDK v2</a></li>
<li><a href="../185768/index.html">Oracle 12c Data Redaction. Hiding information from unprivileged users</a></li>
<li><a href="../185770/index.html">QLiveBittorrent - console bittorrent client for viewing files before downloading</a></li>
<li><a href="../185772/index.html">Technology companies recognize sarcasm</a></li>
<li><a href="../185774/index.html">UEFI BIOS File Device Part Two: UEFI Firmware Volume and its contents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>