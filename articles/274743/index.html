<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the syntax of templates in Angular2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of the first time they saw the syntax of the Angular2 templates begin to lament, saying that they did some horror, it really wasn‚Äôt like in Angul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the syntax of templates in Angular2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/17a/88a/20f/17a88a20f74f474893ac8637fb787db4.jpg" width="40%" align="right"><br>  Many of the first time they saw the syntax of the Angular2 templates begin to lament, saying that they did some horror, it really wasn‚Äôt like in Angular1 at least.  Why it was necessary to introduce this variety of brackets, stars and other nonsense!  However, upon closer inspection, everything becomes much easier, the main thing is not to be afraid. <br><br>  Since the templates in AngularJS are an integral part of it, it is important to understand them at the very beginning of the acquaintance with the new version of this framework.  At the same time we will discuss what advantages this syntax gives us in comparison with angular 1.x.  And it would be best to consider this with small examples. <br><br>  This article is largely based on the materials of these two articles: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://julienrenaux.fr/2015/12/02/angular2-series-template-syntax/">Angular2: template syntax</a> </li><li>  <a href="http://www.wintellect.com/devcenter/jcarroll/build-an-angular-2-app-data-binding-syntax">Angular2: Data Binding Syntax</a> </li></ul><br><br>  In order to simplify the flow of material, let's see.  By AngularJS I will mean the whole Angular 1.x branch, while by Angular2 - the 2.x branch. <br><br>  Also, thanks to Mr. <a href="https://habrahabr.ru/users/bronx/" class="user_link">Bronx</a> for the valuable <a href="http://habrahabr.ru/post/274743/">addition</a> that I have included in the text of the article. <br><br>  Note: Weekend evening, because of typos, etc.  inform in lichku.  Much grateful and pleasant reading. <a name="habracut"></a><br><br><a name="bindingh-svoistv-eliemientov"></a><br><h2>  Binding properties of elements </h2><br>  In the case of simple data output, you will not feel the difference, however, if you decide to transfer part of the state as the value of any attribute of elements, you can already observe interesting solutions. <br><br>  Let's refresh in memory how the binding on the attributes in AngularJS.  To do this, we usually directly forward expressions (interpolated when compiling a template) directly into an element attribute, or use one of a number of directives.  For example, <code>ngValue</code> to set the value of the <code>value</code> the input parameter. <br><br>  Here is an example of how this works in AngularJS: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"expression"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Just do not forget that we can simply interpolate the result of the expression directly as the value of the argument: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{expression}}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Note the interesting feature.  The second option is avoided by many, as you can see the intermediate state before the angular interpolates the values.  However, the first option uses directives.  That is, in order for everything to be all right, nice and comfortable, we need to follow the directive for each property of all elements.  Agree, not very convenient.  Why not add some notation for an attribute that would tell the angular substitute a value on it.  And it would be nice that the syntax was valid.  And they added, now for this you just need to wrap the attribute of interest (any attribute) in square brackets - <code>[]</code> . <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"valueExpression"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"placeholderExpression"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><br>  In essence, the <code>[]</code> syntax is nothing more than a shorthand notation for <code>bind-prop</code> .  If you remove the sugar, the example above will be written as: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind-value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"valueExpression"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind-placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"placeholderExpression"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><br>  However, remember how you can change the attributes in Javascript: <br><br><pre> <code class="javascript hljs">element[prop] = <span class="hljs-string"><span class="hljs-string">'value'</span></span>;</code> </pre><br><br>  it is from here that these square brackets are taken.  We explain that the values ‚Äã‚Äãwill be mapped directly on the properties of the elements.  That is, instead of the <code>ng-bind-html</code> directive, we can simply bandage the result of an expression in <code>[inner-html]</code> .  Or instead of <code>ng-hide</code> we can use the <code>[hidden]</code> property of the element itself.  This significantly reduces the number of angular-specific things that you need to know and brings us closer to the DOM, while we still have an abstraction from it. <br><br>  Well, to close this question is to indicate that we also have the opportunity to map the interpolated value, just as it was in AngularJS: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ valueExpression }}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ placeholderExpression }}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><br><a name="sobytiia"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Developments</a> </h2><br>  In AngularJS we could subscribe for events of elements using special directives.  Just as in the case of properties, we have to deal with a <a href="https://developer.mozilla.org/en-US/docs/Web/Events">whole bunch of</a> possible events.  And for each event I had to make a directive.  Perhaps the most popular of these directives is <code>ngClick</code> : <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"doSomething($event)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Considering that we have already solved such a problem for the properties of the elements, it is probably also worth solving this problem?  That is exactly what they did!  In order to subscribe to an event, it is enough to register an attribute using the following syntax: <code>(eventName)</code> .  Thus, we have the opportunity to subscribe to any event generated by our element, without needing to write a separate directive: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"doSomething($event)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  As with the binding properties, it is also sugar for on-writing.  That is, the example above could be written as: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"doSomething($event)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  And the look of the parentheses is obtained from the associations with the installation of event handlers in javascript: <br><br><pre> <code class="javascript hljs">element.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, ($event) =&gt; doSomething($event));</code> </pre><br><br>  It is also worth noting an important difference in behavior when compared with the binding of events in AngularJS.  Now Angular2 will throw us errors in case of a call to a nonexistent method.  As if we were calling the code directly in javascript.  I think many of those who have been stupid bugs because of typos in this context will be happy.  In some cases, this adds certain inconveniences and therefore the Elvis operator was added, which we will talk about later. <br><br><a name="dvustoronnii-bindingh"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Bilateral binding</a> </h2><br>  There is a widespread belief that double-sided binding is bad, and that this is the main sin of the angular.  This is not entirely true.  The problem with bilateral binding in AnugularJS was that it is used everywhere, not giving developers an alternative (perhaps the situation with this will soon change). <br><br>  Yet sometimes there are cases when bilateral binding makes the development great, especially in the case of forms.  So how is this implemented in Angular2?  Let's think about how to organize bilateral binding with one-sided binding of the property of elements and binding of events: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"firstName"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"firstName=$event.target.value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Again, not very convenient.  Therefore, in Angular2 there is also syntactic sugar using <code>ngModel</code> .  The result will be identical to what we quoted above: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"firstName"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <a name="lokal-nyie-pieriemiennyie"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Local variables</a> </h2><br>  Local variables are used to transfer data between elements within the same template.  The closest analogy in AngularJS, perhaps, is the access to form elements by name via ngForm.  Of course, this is not an entirely correct comparison, since it works only at the expense of the <code>ngForm</code> directive.  In Angular2, you can use a reference to any object or DOM element within the template element and its descendants using local variables <code>#</code> . <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">video</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">movieplayer</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"movieplayer.play()"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">video</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In this example, we can see how, through the <code>movieplayer</code> variable <code>movieplayer</code> we can access the media element's API directly in the template. <br><br>  In addition to the <code>#</code> symbol, you can also declare variables using the <code>var-</code> prefix.  In this case, instead of <code>#movieplayer</code> we could write <code>var-movieplayer</code> . <br><br>  Thanks to local variables, we no longer need to make new directives whenever actions on some elements have to change something in others.  For example, in the example above, we can quickly add a button that starts watching a video.  This is actually the main conceptual difference between Angular2 and AngularJS, less useless micro-directives, a greater focus on components. <br><br><a name="zviezdochka-simvol"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Asterisk (*)</a> </h2><br>  The <code>*</code> symbol causes the most questions.  Let's see why he needed.  To understand the reasons for adding this symbol, we should remember about such an element as the <code>template</code> . <br><br>  The <code>template</code> element allows us to declare a piece of DOM that we can initialize later, which gives us better performance and more efficient use of resources.  Something like a <code>documentFragment</code> in the context of HTML. <br><br>  Perhaps it will be easier to show why it is necessary with an example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"display:none"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"path/to/your/image.png"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In this small example, we can see that the block is hidden ( <code>display:none</code> ).  However, the browser will still try to download the image, even if it is not needed.  If there are a lot of such things on the page, this can adversely affect the overall performance of the page. <br><br>  The solution to this problem is to use the <code>template</code> element. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"path/to/your/image.png"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In this case, the browser will not load the image until we initialize the template. <br><br>  But back to our sheep.  Using the <code>*</code> character in front of an element directive will allow the angular to compile the element into a template when compiling.  It's easier to look at an example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hero-detail</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"isActive"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hero</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"currentHero"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hero-detail</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  This template will be transformed into: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"isActive"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hero-detail</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hero</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"currentHero"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hero-detail</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  It should now become clear that this symbol provides syntactic sugar for higher performance when using conditional directives like <code>ngFor</code> , <code>ngIf</code> and <code>ngSwitch</code> .  It is logical that there is no need to create an instance of the <code>hero-detail</code> component while <code>isActive</code> not true. <br><a name="paipy"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Pipe</a> </h2><br>  Payp is a direct analogue of filters from AngularJS.  In general, the syntax of their use has not changed much: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>My birthday is {{ birthday | date:"MM/dd/yy" }} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Why did it take to change the name from the already familiar filters to the new pipes - a separate question.  This was done to emphasize the new mechanics of the filters.  Now these are not synchronous filters, but asynchronous pipes (by analogy with unix pipes). <br><br>  In AngularJS, filters run synchronously on every $ digest cycle.  This is required by the mechanism for tracking changes in AngularJs.  In Angular2, however, tracking changes takes into account data dependencies, so it allows you to optimize a number of concepts.  There was also a separation between stateful and stateless pipes (while AngularJS films were considered stateful). <br><br>  Stateless pipes, as the name implies, do not have their own state.  These are pure features.  They are executed only once (or if the input data has changed).  Most pipelines in Angular2 are stateless pipes.  This can significantly increase productivity. <br><br>  Stateful pipes, on the contrary, have their own state and they are often executed due to the fact that the internal state may change.  An example of such a pipe is <code>Async</code> .  It receives a promise at the input, subscribes to the changes, and returns the value returned. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   TypeScript,  babel  stage-1,  ,   @Component({ selector: 'my-hero', template: 'Message: {{delayedMessage | async}}', }) class MyHeroAsyncMessageComponent { delayedMessage = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve('You are my Hero!'), 500); }); } // ? ,   TypeScript   .</span></span></code> </pre> <br>  In this example, the <code>my-hero</code> component displays <code>Message: You are my Hero!</code>  only after the delayedMessage is <code>delayedMessage</code> . <br><br>  In order to make a stateful pipe, we must explicitly declare it in the metadata thereof.  Otherwise, Angular2 will consider it stateless. <br><a name="elvis-opierator"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">Elvis operator</a> </h2><br>  In AngularJS, we could make calls to anything completely painless, which often resulted in very insidious bugs and made it difficult to debug.  You probably had to deal with typos in <code>ngClick</code> , in which the code did not perform the required actions and the framework did not give us any hints about what went wrong.  In Angular2 we will finally get errors!  However, this solution may not appeal to everyone without additional sugar. <br><br>  In Javascript, we often have to check for any properties.  I think we all wrote something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cordova &amp;&amp; cordova.plugins &amp;&amp; cordova.plugins.notification){ <span class="hljs-comment"><span class="hljs-comment">// use cordova.plugins.notification }</span></span></code> </pre> <br>  By doing such checks, we certainly want to avoid this: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: Cannot read property <span class="hljs-string"><span class="hljs-string">'notification'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>.</code> </pre> <br>  To solve this problem, the <a href="">Elvis operator</a> was introduced as a shortened version of the ternary operator.  You could see similar in coffeescript.  Angular2 solved this problem using the same operator, but at the template level: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"employer?.goToWork()"</span></span></span><span class="hljs-tag">&gt;</span></span>Go To Work<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  This entry indicates that the <code>employer</code> property is optional, and if it is null, the rest of the expression is ignored.  If you remove the sugar, then this entry will look like this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"employer === undefined ? : employer.goToWork()"</span></span></span><span class="hljs-tag">&gt;</span></span>Go To Work<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  If we did not use this operator and at the same time would not do such a check, then in this situation we would get a <code>TypeError</code> . <br><br>  As in coffescript, this operator can be used as many times as possible within a single expression, for example: <code>a?.b?.c?.d</code> <br><a name="vyvody"></a><br><h2>  <a href="https://habr.com/ru/post/274743/">findings</a> </h2><br>  The developers of Angular2 have done a great job in order to make the pattern syntax more flexible and powerful.  Yes, some things take a little time to adapt, but in general, over time, it all seems more than natural.  And most importantly, not so scary as it seems at first glance. </div><p>Source: <a href="https://habr.com/ru/post/274743/">https://habr.com/ru/post/274743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274731/index.html">Easy setup Asterisk + Fail2Ban</a></li>
<li><a href="../274733/index.html">Using LSM engine from SQLite 4 as a separate NoSQL database using Python</a></li>
<li><a href="../274735/index.html">How much does it cost: Gigabyte traffic in Africa</a></li>
<li><a href="../274739/index.html">Translation: The tragedy of common lisp</a></li>
<li><a href="../274741/index.html">Steam CEG from Valve and what it eats. Introduction</a></li>
<li><a href="../274745/index.html">Quickly create phar files using Box</a></li>
<li><a href="../274749/index.html">LetsEncrypt in Go</a></li>
<li><a href="../274757/index.html">Rust in 2016</a></li>
<li><a href="../274759/index.html">Well tuned emacs</a></li>
<li><a href="../274765/index.html">Software Internet gateway for not a small company (Shorewall, buns). Part 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>