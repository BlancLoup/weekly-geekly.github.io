<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 3.3 - 3D model class</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="3D model class 
 Well, it's time to roll up your sleeves and plunge into the wilds of working with the code to download and convert Assimp data! The g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 3.3 - 3D model class</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><br><h2>  3D model class </h2><br>  Well, it's time to roll up your sleeves and plunge into the wilds of working with the code to download and convert Assimp data!  The goal of the lesson is to create another class, which is an entire model containing a multitude of polygonal meshes, and also, possibly, consisting of several sub-objects.  A building with a wooden balcony, a tower and, for example, a swimming pool will still be loaded as a single model.  With the help of Assimp, we will load the data and convert it into a set of Mesh objects from the last lesson. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Cadre buffer</a> </li></ol></div></div><br>  Let's not pull the cat by the tail - let's see the Model class structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> Model(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *path) { loadModel(path); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader shader)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mesh&gt; meshes; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aiNode *node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aiScene *scene)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aiMesh *mesh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aiScene *scene)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> typeName); };</code> </pre> <br>  As you can see, the class contains a vector of <i>Mesh</i> type objects and requires specifying the path to the model file in the constructor.  Loading takes place directly in the constructor and uses the auxiliary method <i>loadModel</i> .  All private methods are responsible for working with some part of the Assimp data import process and we will discuss them in more detail below. <br>  The <i>Draw</i> method is trivial: here we iterate through the list of polygonal meshes and call their <i>Draw</i> methods. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader shader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; meshes.size(); i++) meshes[i].Draw(shader); }</code> </pre> <br><h3>  Import 3D model in OpenGL </h3><br>  First, turn on the required Assimp header files: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;assimp/Importer.hpp&gt; #include &lt;assimp/scene.h&gt; #include &lt;assimp/postprocess.h&gt;</span></span></span></span></code> </pre> <br>  The first method that will be invoked in the constructor is <i>loadModel</i> , which uses the library to load the model into a structure called the scene object in Assimp terminology.  Remember the <a href="https://habrahabr.ru/post/338436/">first lesson of the section</a> ‚Äî we know that the scene object is the root object of the data hierarchy in Assimp.  As soon as we get the finished object of the scene we will be able to access all the necessary model data. <br><br>  A great feature of the API Assimp is its abstraction from particulars and technical details of loading various formats.  All download goes to one call: <br><br><pre> <code class="cpp hljs">Assimp::Importer importer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);</code> </pre> <br>  An instance of the <i>Importer</i> class is created first, then there is a call to <i>ReadFile</i> with the parameters for the model file path and a list of post-processing flags.  In addition to simply loading the data, the API allows you to specify some flags that force Assimp to do some additional processing on the imported data.  The <i>aiProcess_Triangulate</i> setting indicates that if there are objects in the model that are not composed of triangles, the library will convert such objects into a grid of triangles.  The <i>aiProcess_FlipUVs</i> flag activates the inversion of the texture coordinates along the oY axis where necessary (as you learned from the <a href="https://habrahabr.ru/post/315294/">texturing</a> lesson - in OpenGL, almost all images were inverted along the oY axis, so this flag helps to correct everything as it should).  There are some more useful options: <br><br><ul><li>  <i>aiProcess_GenNormals</i> : calculates the normals for the vertices, if they are absent in the source data; </li><li>  <i>aiProcess_SplitLargeMeshes</i> : splits large polygonal grids into smaller grids, which is useful if your render has a limit on the number of processed values; </li><li>  <i>aiProcess_OptimizeMeshes</i> : conducts the reverse action - trying to sew a lot of grids into one large one to optimize the number of calls per drawing. </li></ul><br>  The library API contains <a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html">many</a> more <a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html">processing options</a> .  The very same loading model is surprisingly simple.  A little harder is the work involved in extracting data from the resulting scene object and converting it into <i>Mesh</i> objects. <br><br>  Full listing of the <i>loadModel</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path)</span></span></span><span class="hljs-function"> </span></span>{ Assimp::Importer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aiScene *scene = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::ASSIMP::"</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.GetErrorString() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } directory = path.substr(<span class="hljs-number"><span class="hljs-number">0</span></span>, path.find_last_of(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)); processNode(scene-&gt;mRootNode, scene); }</code> </pre> <br>  After loading, we check for zero pointers to the scene object and the root node of the scene, as well as a status flag indicating that the returned data is incomplete.  Any of these events results in an error message with a description obtained from the method of the import object object <i>GetErrorString</i> , and a further exit from the function.  Also from the full path to the file we extract the path to the directory with it. <br><br>  If everything passed without errors, then we proceed to processing the scene nodes by passing the root node to the recursive <i>processNode</i> method.  The recursive processing form is chosen as obvious for the scene hierarchy, where after processing the current node we must process each of its descendants, if any.  Let me remind you that the recursive function performs some processing and then calls itself with modified parameters until a certain condition is violated - the exit condition.  In our case, this condition is the lack of processing new nodes. <br><br>  As you remember, the Assimp data structure assumes that each node stores a set of polygonal mesh indices that are actually stored in the scene object.  Accordingly, for each node and its descendants, we must sample the data of polygonal meshes using a list of grid indices stored in the node.  Listing of the <i>processNode</i> method <i>is</i> shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aiNode *node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aiScene *scene)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ( ) for(unsigned int i = 0; i &lt; node-&gt;mNumMeshes; i++) { aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; meshes.push_back(processMesh(mesh, scene)); } //          for(unsigned int i = 0; i &lt; node-&gt;mNumChildren; i++) { processNode(node-&gt;mChildren[i], scene); } }</span></span></code> </pre> <br>  At the beginning, we get a pointer to an Assimp mesh object by sampling the <i>scene</i> object's <i>mMeshes</i> array using the indices of the current node.  Next, the <i>aiMesh</i> object <i>is</i> converted using the <i>processMesh</i> method into an instance of our <i>Mesh</i> class and stored in the <i>meshes</i> list. <br><br>  After receiving all the polygonal grids of the node, we go through the list of descendants, performing the same <i>processNode</i> already for them.  After the list of descendants has dried up, the method ends. <br><blockquote>  The attentive reader might have noticed that the list of grids could have been obtained simply by walking through their array stored in the object of the scene, without all this commotion with indexes in the node.  However, a more complicated method that was used is justified by the possibility of establishing parent-child relationships between polygonal grids.  Recursive passage allows you to establish similar relationships between certain objects. <br>  Example of use: any multi-component moving model, for example, a car.  When moving it, you would like all dependent parts (engine, steering wheel, tires, etc.) to move as well.  Such a system of objects is easily created as a parent-child hierarchy. <br><br>  At the moment, such a system is not used by us, however, it is recommended to adhere to this approach, if in the future you want to add more control capabilities of polygonal meshes.  Ultimately, these relationships are established by the model artists who created this model. </blockquote><br>  The next step is to convert the Assimp data to the <i>Mesh</i> class format that we created earlier. <br><br><h4>  Convert Assimp to Mesh </h4><br>  Directly converting an <i>aiMesh object</i> to our internal format is not too burdensome.  It is enough to consider the attributes of the polygonal mesh object that we need and save in the <i>Mesh</i> type object.  The skeleton of the <i>processMesh</i> method is shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aiMesh *mesh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aiScene *scene)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Vertex&gt; vertices; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mesh-&gt;mNumVertices; i++) { Vertex vertex; <span class="hljs-comment"><span class="hljs-comment">//  ,      ... vertices.push_back(vertex); } //   ... //   if(mesh-&gt;mMaterialIndex &gt;= 0) { ... } return Mesh(vertices, indices, textures); }</span></span></code> </pre> <br>  Processing is reduced to three steps: reading the vertices, indexes and obtaining material data.  The obtained data is stored in one of the three declared vectors, which are used in the creation of the <i>Mesh</i> object, which will be returned. <br><br>  Obtaining vertex data is trivial: we declare a <i>Vertex</i> structure, an instance of which we add to the <i>vertices</i> array at each processing step.  The loop runs until the stored vertex data runs out (determined by the value of <i>mesh-&gt; mNumVertices</i> ).  In the body of the loop, we fill the structure fields with relevant data, for example, for the position of the vertex: <br><br><pre> <code class="cpp hljs">glm::vec3 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.x = mesh-&gt;mVertices[i].x; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.y = mesh-&gt;mVertices[i].y; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.z = mesh-&gt;mVertices[i].z; vertex.Position = <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>;</code> </pre> <br>  Note that we declare an auxiliary object of type <i>vec3</i> , for Assimp stores information in its internal data types, which are not directly converted to the types declared by glm. <br><blockquote>  The array of vertex positions in Assimp is simply called mVertices, which is somewhat unintuitive. </blockquote><br>  For normals, the process is similar: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.x = mesh-&gt;mNormals[i].x; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.y = mesh-&gt;mNormals[i].y; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.z = mesh-&gt;mNormals[i].z; vertex.Normal = <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>;</code> </pre> <br>  Have you guessed how the texture coordinates are read?  It was not there: Assimp assumes that vertices can have up to 8 sets of texture coordinates.  We do not need such wealth, it is enough to obtain the data of the first set.  And, at the same time, it would be nice to check whether the grid in question has texture coordinates in principle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mesh-&gt;mTextureCoords[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//     ? { glm::vec2 vec; vec.x = mesh-&gt;mTextureCoords[0][i].x; vec.y = mesh-&gt;mTextureCoords[0][i].y; vertex.TexCoords = vec; } else vertex.TexCoords = glm::vec2(0.0f, 0.0f);</span></span></code> </pre> <br>  An instance of the Vertex structure is now fully equipped with the required vertex attributes and can be sent for storage in the vertices array.  This process will be repeated by the number of vertices in the polygonal mesh. <br><br><h4>  Indices </h4><br>  The Assimp library defines each polygonal mesh as containing an array of faces, where each face is represented by a certain primitive.  In our case, these are always triangles (thanks to the <i>aiProcess_Triangulate</i> import <i>option</i> ).  The face itself contains a list of indices that indicate which vertices and in what order are used to draw the primitive of this face.  Accordingly, we can go through the list of faces and read all the index data: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mesh-&gt;mNumFaces; i++) { aiFace face = mesh-&gt;mFaces[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; face.mNumIndices; j++) indices.push_back(face.mIndices[j]); }</code> </pre> <br>  After the end of the outer loop, we <i>‚Äôll have a</i> full list of indices in our hands, enough to display the grid using the OpenGL <i>glDrawElements</i> procedure.  However, in order for our lesson to be complete, we will sort out the material to add details to our model. <br><br><h4>  Material </h4><br>  The grid object only refers to the index of the object material actually stored in the <i>mMaterials</i> array of the <i>scene</i> object.  Accordingly, the material data can be obtained at this index, if the material is, of course, assigned to the grid: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mesh-&gt;mMaterialIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { aiMaterial *material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex]; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, <span class="hljs-string"><span class="hljs-string">"texture_diffuse"</span></span>); textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end()); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, <span class="hljs-string"><span class="hljs-string">"texture_specular"</span></span>); textures.insert(textures.end(), specularMaps.begin(), specularMaps.end()); }</code> </pre> <br>  First we get a pointer to the <i>aiMaterial</i> object from the object mMaterials array.  Next, we load diffuse textures and / or specular textures.  The material object contains an array of paths to the textures of each type.  Each type of texture has its own identifier with <i>aiTextureType_</i> prefix.  The helper method <i>loadMaterialTextures</i> returns a vector of <i>Texture</i> objects containing textures of the appropriate type, extracted from the material object.  The data of these vectors is stored in a common array of textures of the model object. <br><br>  The <i>loadMaterialTextures</i> function <i>itself</i> in a loop goes through all the textures of the specified type, reads the paths to the files, loads and generates textures of the OpenGL format, saving the necessary information into an instance of the <i>Texture</i> structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> typeName) { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mat-&gt;GetTextureCount(type); i++) { aiString str; mat-&gt;GetTexture(type, i, &amp;str); Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str; textures.push_back(texture); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> textures; }</code> </pre> <br>  First, the number of textures is checked by calling <i>GetTextureCount</i> , which is passed to the texture type of interest.  Next, the path to the texture file is read using the <i>GetTexture</i> method, which returns the result as a string of type <i>aiString</i> .  Another auxiliary function, <i>TextureFromFile</i> , directly loads the file and generates a texture (using the SOIL library) with the return of its identifier.  If you are not sure how exactly this function should look, then its full text can be found in the full program code at the end of the article. <br><blockquote>  Note that in our code there is an assumption about the nature of the texture file paths stored in the model file.  We believe that these paths are relative to the folder containing the model file.  In this case, the full path to the texture file can be obtained by merging the previously saved path to the folder with the model (done in the <i>loadModel</i> method) and the path to the texture (therefore, the path to the folder is also passed to <i>GetTexture</i> ). <br><br>  Some models available for download on the web store texture paths in an absolute form, which will obviously cause problems on your machine.  You will probably need to use an editor to get the textures in order. </blockquote><br>  Well, it seems, and all that concerns the import model, using Assimp? <br><br><h3>  Significant optimization </h3><br>  Not really.  The opportunity for optimization remains open (although it is not necessary).  In many scenes, some objects can reuse a certain amount of textures.  Imagine a house where granite texture is used for walls.  But the same texture is perfect for the floor, ceilings, stairs, and maybe for a table or a small well at a distance.  Loading a texture from a file is not the most lightweight procedure, but the current implementation loads and creates texture objects for each grid separately, even if such a file has already been loaded.  Such an oversight can easily become a bottleneck in the implementation of loading a model file. <br><br>  As an optimization, we will create a separate list of already loaded textures, which we will store in the scope of the <i>Model</i> object, and when loading a regular texture we will check for its presence in the list of loaded textures.  This will help save decent processing power on duplicates.  But in order to check for duplicates, you will have to store the path to the texture in the <i>Texture</i> structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Texture</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> type; aiString path; <span class="hljs-comment"><span class="hljs-comment">//          };</span></span></code> </pre> <br>  The list of already loaded textures will be formatted as a vector declared as a closed variable of the <i>Model</i> class: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures_loaded;</code> </pre> <br>  And in the <i>loadMaterialTextures</i> method, <i>we</i> will search for the occurrence of the path of the loaded texture in this vector and, if there is a copy, skip the load, substituting the identifier of the already loaded texture into the array of textures of the current polygonal mesh: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> typeName) { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mat-&gt;GetTextureCount(type); i++) { aiString str; mat-&gt;GetTexture(type, i, &amp;str); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> skip = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; textures_loaded.size(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(textures_loaded[j].path.C_Str(), str.C_Str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { textures.push_back(textures_loaded[j]); skip = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!skip) { <span class="hljs-comment"><span class="hljs-comment">//      ‚Äì   Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str; textures.push_back(texture); //       textures_loaded.push_back(texture); } } return textures; }</span></span></code> </pre> <br>  Done!  We have in our hands not only a universal, but also an optimized system for loading models, coping with its task rather quickly. <br><blockquote>  Some versions of Assimp become noticeably slow, being compiled as a debug version or used in the debug build of your project.  If you come across this behavior, you should try working with release assemblies. </blockquote><br>  The complete source code, including the optimization, is located <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dincludes/learnopengl/model.h">here</a> . <br><br><h3>  Containers - down! </h3><br>  Well, it's time to test our system in a battle by feeding it a real model, developed by a professional 3D artist, and not marvelously draped by Kulibin on his knee miracle-yudo (although admit, those containers were one of the most beautiful representatives of cubes you have seen ).  Not wanting to win all the glory alone, I‚Äôll turn to someone else‚Äôs creativity: the experimental model will be a <a href="http://tf3dm.com/3d-model/crysis-2-nanosuit-2-97837.html">nanotechnological costume</a> from the Crysis shooter (in this case, downloaded from tf3dm.com, any other model will do).  The model is prepared as an .obj file and an auxiliary .mtl, which contains data on diffuse, specular textures and normal maps).  You can download the model <a href="">here</a> (slightly modified).  I also recall that all the textures should be in the folder with the model. <br><blockquote>  Modifying the model file consists in changing the paths to textures to relative, instead of absolute, which is stored in the original file. </blockquote><br>  In the code, we declare a Model instance and pass the path to the model file to the constructor.  Upon successful loading, the model will be displayed by calling its Draw method in the main program loop.  Actually, everything!  No hassle with allocating buffers, assigning pointers to vertex attributes and drawing calls through OpenGL procedures - now one line is enough.  It remains only to create a simple set of shaders, where the fragment will only produce the diffuse texture color of the model.  The result will be something like this: <br><br><img src="https://habrastorage.org/webt/59/ce/3d/59ce3d6e11ee0875475126.png"><br><br>  The full source code is <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/3.model_loading/1.model_loading/model_loading.cpp">here</a> . <br>  By introducing two light sources, connecting the use of the specular reflection maps and the lighting calculation model from the <a href="https://learnopengl.com/">relevant lesson</a> you can achieve remarkable results: <br><br><img src="https://habrastorage.org/webt/59/ce/3d/59ce3d6e0c78e273292474.png"><br><br>  Even I will have to admit that this is the result of the harshness of my darling containers.  With the help of Assimp you have the opportunity to download almost any of the thousands of models available on the network.  There is no one resource that provides free download of models in several formats.  Of course, not all models will be successfully loaded, have incorrect texture paths or, in principle, be in a format not supported by Assimp. <br><br>  <i>Note</i>  <i>per.</i>  <i>- I apologize for the link to the original, driven through the MC (o) rotator links.</i>  <i>Habroparser refused to recognize a normal link in the original URL.</i> </div><p>Source: <a href="https://habr.com/ru/post/338998/">https://habr.com/ru/post/338998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338988/index.html">What is ERP-Platfoma</a></li>
<li><a href="../338990/index.html">Checklist: how to choose a model of an access rights management system and not miscalculate</a></li>
<li><a href="../338992/index.html">Simulation of the physical world</a></li>
<li><a href="../338994/index.html">404 pages</a></li>
<li><a href="../338996/index.html">‚ÄúWe have a normal UX. Ux? Not before us, we have deadlines here! ‚ÄùRemoving the mantle is my interpretation</a></li>
<li><a href="../339000/index.html">On the issue of strangeness and systematic approach</a></li>
<li><a href="../339004/index.html">Useful lifehacks: answering the most popular questions (Part 2)</a></li>
<li><a href="../339008/index.html">Simple Scada in Python</a></li>
<li><a href="../339012/index.html">Scheduling tasks in Android using JobScheduler and IntentService</a></li>
<li><a href="../339014/index.html">PostgreSQL load testing using JMeter, Yandex.Tank and Overload</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>