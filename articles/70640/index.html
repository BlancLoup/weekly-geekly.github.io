<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MySQL indices: multicolumn indices versus combined indices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I often see errors related to creating indexes in MySQL. Many developers (and not only beginners in MySQL) create many indexes on those columns that w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MySQL indices: multicolumn indices versus combined indices</h1><div class="post__text post__text-html js-mediator-article"> I often see errors related to creating indexes in MySQL.  Many developers (and not only beginners in MySQL) create many indexes on those columns that will be used in the samples, and they consider this the optimal strategy.  For example, if I need to execute a query like <b>AGE = 18 AND STATE = 'CA'</b> , then many people will simply create 2 separate indexes on the columns AGE and STATE. <br><br>  Much better ( <i><b>hereafter approx. Translator:</b> and usually the only correct one</i> ) strategy is to create a combined type index (AGE, STATE).  Let's look at why this is so. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually (but not always) indexes in MySQL are <a href="http://ru.wikipedia.org/wiki/B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">BTREE-indices</a> - this type of index is able to quickly look through the information contained in its prefixes and sort through ranges of sorted values.  For example, when you request <b>AGE = 18</b> with a BTREE index on the AGE column, MySQL will find the first matching line in the table and continue searching until it finds the first unsuitable row - then it stops the search, since  believes that further nothing suitable will be.  Ranges, such as queries like <b>BETWEEN 18 AND 20</b> , work in a similar way ‚Äî MySQL stops at other values. <br><br>  The situation with requests of type <b>AGE IN (18,20,30) is</b> somewhat more complicated, since  in fact, MySQL has to go through the index several times. <br><br>  So, we discussed <u>how</u> MySQL searches by index, but did not determine <u>what</u> it returns after the search ‚Äî usually (if we are not talking about covering indexes), we get a ‚Äústring pointer‚Äù, which can be the primary key value (if the InnoDB engine is used ), physical file offset (for MyISAM) or something like that.  It is important that the internal MySQL engine can find a complete line with all the necessary data corresponding to the specified index value using this pointer. <br><br>  And what options does MySQL have if you created two separate indexes?  It can either use only one of them to select suitable rows (and then filter the extracted data, guided by WHERE - <i>but without using indexes</i> ), or it can get pointers to rows from all suitable indexes and calculate their intersection, and then return the data . <br><br>  Which method is more appropriate depends on the selectivity and correlation of the indices.  If, after working WHERE, 5% of the rows will be selected by the first column, and applying further WHERE to the second column filters up to 1% of the total number, then the use of intersections, of course, makes sense.  But if the second WHERE filters only up to 4.5%, then it is usually much more profitable to use only the first index and filter out the rows that we do not need after extracting the data. <br><br>  Let's look at a few examples: <br> <code>CREATE TABLE `idxtest` ( <br> `i1` int(10) UNSIGNED NOT NULL, <br> `i2` int(10) UNSIGNED NOT NULL, <br> `val` varchar(40) DEFAULT NULL, <br> KEY `i1` (`i1`), <br> KEY `i2` (`i2`), <br> KEY `combined` (`i1`,`i2`) <br> ) ENGINE=MyISAM DEFAULT CHARSET=latin1</code> <br> <br>  I created columns i1 and i2 independent of each other, each of which selects about 1% of the rows in the table, which contains a total of 10 million records. <br><br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest WHERE i1=50 AND i2=50; <br> +----+-------------+---------+------+----------------+----------+---------+-------------+------+-------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+----------------+----------+---------+-------------+------+-------+ <br> | 1 | SIMPLE | idxtest | ref | i1,i2,combined | combined | 8 | const,const | 665 | <br> +----+-------------+---------+------+----------------+----------+---------+-------------+------+-------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  As you can see, MySQL chose to use a combined index, and the query ran in less than 10 ms! <br><br>  Now suppose that we have an index only for individual columns (to tell the optimizer to ignore the combined index): <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX (combined) WHERE i1=50 AND i2=50; <br> +----+-------------+---------+-------------+---------------+-------+---------+------+------+-------------------------------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+-------------+---------------+-------+---------+------+------+-------------------------------------+ <br> | 1 | SIMPLE | idxtest | index_merge | i1,i2 | i1,i2 | 4,4 | NULL | 1032 | USING intersect(i1,i2); USING WHERE <br> +----+-------------+---------+-------------+---------------+-------+---------+------+------+-------------------------------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  As you can see in this case, MySQL did a search for intersection of indexes, and it took 70 ms to execute the query - <b>7 times longer!</b> <br><br>  Now let's see what happens if you use only one index and filter the data: <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX (combined,i2) WHERE i1=50 AND i2=50; <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | 1 | SIMPLE | idxtest | ref | i1 | i1 | 4 | const | 106222 | USING WHERE <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  This time, MySQL had to bypass significantly more rows, and the execution of the query took <b>290 ms</b> .  Thus, we see that using intersection of indices is much better than using a single index, but it is much better to use combined indexes. <br><br>  However, problems with intersection of indices do not end there.  Currently, the possibilities of using this procedure in MySQL are significantly limited, therefore MySQL does not always use them: <br><br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX (combined) WHERE i1=50 AND i2 IN (49,50); <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | 1 | SIMPLE | idxtest | ref | i1,i2 | i1 | 4 | const | 106222 | USING WHERE <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  As soon as a query on one of the columns becomes not a comparison, but an enumeration, MySQL will no longer be able to use the intersection of the indexes, despite the fact that in this case, when requesting <b>i2 IN (49.50),</b> this would be more than reasonable, because .  The query remains quite selective. <br><br>  Now let's do another test.  I cleared the table and re-filled it with data so that the values ‚Äã‚Äãin i1 and i2 strongly correlated.  In fact, they are now generally equal: <br> <code>mysql [localhost] {msandbox} (test)&gt; UPDATE idxtest SET i2=i1; <br> Query OK, 10900996 rows affected (6 min 47.87 sec) <br> Rows matched: 11010048 Changed: 10900996 Warnings: 0</code> <br> <br>  Let's see what happens in this case: <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest WHERE i1=50 AND i2=50; <br> +----+-------------+---------+-------------+----------------+-------+---------+------+------+-------------------------------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+-------------+----------------+-------+---------+------+------+-------------------------------------+ <br> | 1 | SIMPLE | idxtest | index_merge | i1,i2,combined | i2,i1 | 4,4 | NULL | 959 | USING intersect(i2,i1); USING WHERE <br> +----+-------------+---------+-------------+----------------+-------+---------+------+------+-------------------------------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  The optimizer decided to use the intersection of indices, although this was perhaps the worst solution!  The request took <b>360 ms</b> .  Also note the large margin of error in estimating the approximate number of rows. <br><br>  This was due to the fact that MySQL considers the values ‚Äã‚Äãin columns i1 and i2 to be independent, and therefore chooses the intersection of indices.  In fact, he can not suggest another, because  He has no statistics on the correlation of values ‚Äã‚Äãin the columns. <br><br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX(i2) WHERE i1=50 AND i2=50; <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> | 1 | SIMPLE | idxtest | ref | i1,combined | i1 | 4 | const | 106222 | USING WHERE <br> +----+-------------+---------+------+---------------+------+---------+-------+--------+-------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  And now, when we have banned MySQL from using the index on column i2 (which means it cannot even find the intersection of indices), it uses the index in one column rather than a combined one.  This happened because MySQL has statistics about the approximate number of matching rows, and since it is equal for both indices, MySQL chose a smaller one.  Execution of the request again took <b>290 ms</b> - exactly the same as last time. <br><br>  Make MySQL use only the combined index: <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX(i1,i2) WHERE i1=50 AND i2=50; <br> +----+-------------+---------+------+---------------+----------+---------+-------------+--------+-------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+---------------+----------+---------+-------------+--------+-------+ <br> | 1 | SIMPLE | idxtest | ref | combined | combined | 8 | const,const | 121137 | <br> +----+-------------+---------+------+---------------+----------+---------+-------------+--------+-------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  It can be seen that MySQL is about 20% mistaken in estimating the number of rows being iterated, which, of course, is incorrect, because  the same prefix is ‚Äã‚Äãused as when using the index only on column i1.  MySQL does not know this, because  looks at the statistics for individual indices and does not attempt to reconcile them. <br><br>  Due to the fact that the combined index used is larger than the index in one column, the request took <b>300 ms to complete</b> . <br><br>  Thus, we see that MySQL may decide to use the intersection of indexes even if it is the worst option, although from a technical point of view it will certainly be the best plan, considering that it does not have other statistics. <br><br>  There are simple ways to force MySQL not to use intersection of indexes, but, unfortunately, I do not know how to force it to use intersections if it considers this option to be non-optimal.  I hope that this opportunity will be added in the future. <br><br>  Finally, let's consider a situation where the procedure for finding the intersection of indices works much better than the combined indices in several columns.  This is the case when we use <b>OR</b> when sampling between columns.  In this case, the combined index becomes completely useless, and MySQL has a choice between full table scanning (FULL SCAN) and performing a union (UNION) of values ‚Äã‚Äãinstead of searching for an intersection on the data that it received from one table. <br><br>  I again changed the values ‚Äã‚Äãin columns i1 and i2 so that they contained independent data (typical situation for tables). <br><br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest WHERE i1=50 OR i2=50; <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+---------------------------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+---------------------------------+ <br> | 1 | SIMPLE | idxtest | index_merge | i1,i2,combined | i1,i2 | 4,4 | NULL | 203803 | USING union(i1,i2); USING WHERE <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+---------------------------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  Such requests are performed <b>660 ms</b> .  Turning off the index on the second column we get FULL SCAN: <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest IGNORE INDEX(i2) WHERE i1=50 OR i2=50; <br> +----+-------------+---------+------+---------------+------+---------+------+----------+-------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+------+---------------+------+---------+------+----------+-------------+ <br> | 1 | SIMPLE | idxtest | ALL | i1,combined | NULL | NULL | NULL | 11010048 | USING WHERE <br> +----+-------------+---------+------+---------------+------+---------+------+----------+-------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br>  Please note that MySQL has indicated the i1, combined keys as <i>possible</i> to use, but in fact it <b>does not have</b> such a possibility.  Execution of such requests takes <b>3370 ms</b> ! <br><br>  Also note that the execution of the query took 5 times longer despite the fact that the FULL SCAN passed about 50 times more rows.  This shows a very large performance difference between a full pass through the table and access by key, which takes 10 times longer (in the sense of the ‚Äúcost‚Äù of access per row), despite being performed in memory. <br><br>  In the case of UNION, the optocoupler is more advanced and quite capable of handling the ranges: <br> <code>mysql [localhost] {msandbox} (test)&gt; EXPLAIN SELECT avg(length(val)) FROM idxtest WHERE i1=50 OR i2 IN (49,50); <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+--------------------------------------+ <br> | id | select_type | TABLE | type | possible_keys | KEY | key_len | ref | rows | Extra <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+--------------------------------------+ <br> | 1 | SIMPLE | idxtest | index_merge | i1,i2,combined | i1,i2 | 4,4 | NULL | 299364 | USING sort_union(i1,i2); USING WHERE <br> +----+-------------+---------+-------------+----------------+-------+---------+------+--------+--------------------------------------+ <br> 1 row IN SET (0.00 sec)</code> <br> <br><h4>  Summing up </h4><br>  In most cases, using combined indexes across multiple columns is the best solution if you use AND between similar columns in WHERE.  Using intersection of indexes improves performance in principle, but it is still significantly worse than when using combined keys.  In case you use OR between columns, you will need to have an index on each of the columns in order for MySQL to find their intersections, and combined indexes cannot be used in such queries. </div><p>Source: <a href="https://habr.com/ru/post/70640/">https://habr.com/ru/post/70640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../70632/index.html">Lamborghini Flavored Laptop</a></li>
<li><a href="../70633/index.html">RedLynx Trials 2 Second Edition: very addictive motorcycles!</a></li>
<li><a href="../70634/index.html">Canobuvosti 6th edition</a></li>
<li><a href="../70636/index.html">Technical writer: you to me - I to you</a></li>
<li><a href="../70637/index.html">Another logical problem</a></li>
<li><a href="../70641/index.html">Yota users are indignant</a></li>
<li><a href="../70647/index.html">Propel comes to life</a></li>
<li><a href="../70649/index.html">Backup systems</a></li>
<li><a href="../70655/index.html">Google Maps enters Yelp market</a></li>
<li><a href="../70656/index.html">"Fast" and "slow" search: two different approaches to search the site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>