<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreaded web server for 1C: Enterprise using .Net Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of automating an enterprise using 1C: Enterprise often 
 there are problems of integration and exchange with equipment and other third-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreaded web server for 1C: Enterprise using .Net Framework</h1><div class="post__text post__text-html js-mediator-article">  In the process of automating an enterprise using 1C: Enterprise often <br>  there are problems of integration and exchange with equipment and other third-party information <br>  systems, for example, banks, websites, partner information systems. <br>  Traditionally, 1C: Enterprise acts as a consumer of services, and less often - as <br>  provider.  Up to this point, the developers of popular technologies in obtaining <br>  Information from 1C was COM and web services, which appeared only in version 8.1. <br><br>  Both technologies (COM and web services) have their drawbacks.  The main disadvantages are <br>  in the following.  COM technology allows you to perform only one at a time. <br>  request.  Circulation is possible only within your local network.  Simultaneous processing <br>  queries for COM is possible, but requires the costs of connection pooling and debugging <br>  multi-threaded application.  Web services are complex and inflexible to program: <br>  tightly bound to SOAP standards.  Connecting devices sharing simple <br>  packages that use the http protocol are not possible. <br><br>  The new idea of ‚Äã‚Äãorganizing a web server within 1C, proposed in the article, is based on <br>  time-tested rich functionality. Net Framework.  Solution based on <br>  ideas are free from the disadvantages of COM and web services 1C.  Compared to the COM http server you can <br>  use outside the local network; simultaneous processing of several <br>  requests.  Compared to web services 1C solution based on http-server has <br>  more flexibility, because the programmer is free to choose the server response format <br>  (including HTML, JSON, graphics, RSS, etc.), as well as control <br>  when answering the URL, user identification, error codes, cookies, encoding, <br>  implement caching.  Setting the same http-server inside 1C is reduced to a simple <br>  launching external processing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h1>  Example Description </h1><br><br>  The example attached to the article consists of two files: http-server (external processing <br>  1C 8.2 HttpServer82) and a test application emulating simultaneous requests to the server <br>  (external processing 1C 8.2 TestHttpServer82).  Both treatments are based on managed <br>  forms.  By default, both applications are configured to work with port 8082. <br><br>  Server and test application developed on 1C: Enterprise 8.2 and use .Net <br>  Framework 4.0 and the Elisy .Net Bridge 4 component. Accordingly, for the example to work <br>  Requires installed .Net Framework 4.0 and version of the Elisy library .Net Bridge <br>  v.4.0.2.0 and higher.  Elisy .Net Bridge allows harmonious use of classes and technologies. <br>  .Net Framework on 1C, the leading role leaving 1C. <br><br>  To check the work, it is enough to launch external processing of HttpServer82.epf from 1C: Enterprise <br>  8.2.  If you have Windows with UAC enabled, then you need to run 1C: Enterprise <br>  under the administrator, otherwise the application will not have enough rights to listen <br>  requests. <br><br>  External processing allows you to specify the port on which to listen <br>  and the number of threads created to handle simultaneous requests.  Default set <br>  port 8082 and 50 streams. <br><br>  After pressing the Start button, the server goes to a working state and carries out <br>  processing requests to a given port.  For example, you can now refer from your <br>  browser at <a href="http://localhost/">localhost</a> : 8082 and open <br>  page returned by the server.  In the request, you can pass parameters, for example, <br>  like this: <a href="http://localhost/">localhost</a> : 8082 / test? x = 1 <br><br>  To test the server in multi-threaded mode, an external processing was created TestHttpServer82.epf, <br>  which executes simultaneous queries in a loop.  The basis of processing for <br>  organization of parallel work put a great technology PLINQ (Parallel <br>  LINQ) of .Net framework 4. <br><br>  Test processing of TestHttpServer82.epf should be started from a separate server. <br>  of 1C: Enterprise session, otherwise simultaneous launching of two treatments in one session <br>  will cause a hang.  The test case parameters are the request address, <br>  the number of simultaneous requests and the number of cycles.  By default, running the algorithm will result in <br>  to 3 cycles of visits to the address <a href="http://localhost/">localhost</a> : 8082 <br>  with 20 simultaneous requests (it should be noted that the number of simultaneous requests is limited <br>  number of processor cores). <br><br><h1>  Principle of operation </h1><br><br>  The .Net framework offers to its developers the HttpListener class, which is responsible for listening to the http protocol.  Using HttpListener, <br>  You can create an HTTP traffic listener that responds to http requests. <br>  You can use this class only on Windows XP SP2 operating systems. <br>  or Windows Server 2003 and up.  Attempt to use class on earlier systems <br>  will cause an exception. <br><br>  Below is a sample code for 1C, which initializes an object of type HttpListener, <br>  configuring it to listen on all URLs on port 8082. When running in 1C, work <br>  the program pauses until a request is made for a port, for example, from a browser. <br>  As soon as you send a request from the browser, for example, <a href="http://127.0.0.1/">127.0.0.1</a> : 8082 / 1C will return the html-string described in the program. <br><br>  What each piece of code is responsible for can be understood from the comments provided <br>  inside the source code. <br><br><pre><code class="javascript hljs">(<span class="hljs-string"><span class="hljs-string">"Elisy.NetBridge4"</span></span>); AddIn = New(<span class="hljs-string"><span class="hljs-string">"AddIn.ElisyNetBridge4"</span></span>); net = AddIn.GetNet();   net.GetStatic(<span class="hljs-string"><span class="hljs-string">"System.Net.HttpListener"</span></span>,<span class="hljs-string"><span class="hljs-string">"IsSupported"</span></span>)  (<span class="hljs-string"><span class="hljs-string">"  HttpListener   Windows XP SP2/2003  "</span></span>); ; ; listener = net.New(<span class="hljs-string"><span class="hljs-string">"System.Net.HttpListener"</span></span>); listener.Prefixes.Add(<span class="hljs-string"><span class="hljs-string">"http://*:8082/"</span></span>); listener.Start(); (<span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-comment"><span class="hljs-comment">// GetContext      . context = listener.GetContext(); request = context.Request; //    response = context.Response; //   - HTML- responseString = "  HttpListener"; buffer = net.GetStatic("System.Text.Encoding", "UTF8").GetBytes(responseString); //        . response.ContentLength64 = buffer.Length; output = response.OutputStream; output.Write(buffer,0,buffer.Length); //        output.Close(); listener.Stop();</span></span></code> </pre> <br><br>  This is the simplest example.  The main point of the simplest example is that 1C turns <br>  into a full-featured http-server, and 1C-programmer gets a tool for flexible <br>  response settings from the server.  He can return it in any format (html, drawing <br>  or JSON), request user identification, or return an error altogether.  But <br>  however, there are drawbacks: blocking the entire application, processing only one <br>  request.  The example for the article contains more complex code, due to which disadvantages are eliminated <br>  the simplest example from listing. <br><br><h1>  From simple to complex </h1><br><br>  The finished example included a modified code for working with HttpListener, in which the call <br>  the listener.GetContext () method has been replaced by a call to asynchronous analogs listener.BeginGetContext () <br>  and listener.EndGetContext ().  In addition, N separate threads are created and laid. <br>  synchronization between threads with a call to the request-code-processing request on the 1C: Enterprise side. <br><br>  The advantage of the proposed implementation of the http-server is the possibility of simultaneous <br>  processing N requests in different threads with transfer of processing logic to the form method <br>  1C: Enterprise.  The example at each request returns html with the description of the source <br>  and the request URL.  The solution is very flexible, since all improvements can be made directly from <br>  configurator 1C.  No additional projects (for example, C # or VB.Net) are involved. <br><br>  The example can be divided into 2 parts: the code that runs on the 1C: Enterprise side <br>  and code that runs on the .Net framework side.  At the same time, the .Net framework took <br>  everything that cannot be implemented using 1C: Enterprise, for example, creating <br>  and thread synchronization. <br><br>  Http server is designed as a managed form.  Pressing the Start button occurs. <br>  creating objects of the HttpServer and Helper classes.  Both classes are described in C # in the layout. <br>  Processing Source Code and compiled "on the fly" in the handler of the Open Form. <br>  The Helper class is responsible for redirecting .Net events to the Edit Request function. <br>  on the form 1C and the formation of an error message. <br><br>  Omitting non-subject initialization tasks of the form and auxiliary classes, <br>  it is necessary to dwell on the Process Request method, which is responsible for returning the result <br>  http client  The handler from the class Helper is called, takes as a parameter <br>  context object may return an error message that will be returned <br>  to the client. <br><br>  The context object of the HttpListenerContext type, passed to the ProcessEquery method <br>  contains two important properties: Request and Response, responsible for information about the request <br>  and answer accordingly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/146/43b/879/14643b879ceb872d096a9b4448b28583.png"><br><br>  The Request property allows you to get the parameters and contents passed by the client. <br>  upon request.  Request information placed in the Request property contains such <br>  Basic properties like: <br><br>  AcceptTypes - client-supported MIME types <br>  ContentEncoding - encoding information in response <br>  Headers - a set of headers <br>  HttpMethod - client-defined HTTP method <br>  InputStream - a stream containing body data from the client <br>  IsAuthenticated - a boolean value indicating whether the user is identified <br>  IsLocal - value indicating whether the request is local (via localhost) <br>  QueryString - query string from query <br>  RawUrl - URL information without a host and port <br>  UrlReferrer - resource URL - source of the transition <br>  UserAgent - information about the user's browser agent <br><br>  Through the Response property, content is returned to the client, information is transferred <br>  error or redirection.  All can be accompanied by exhibiting the necessary <br>  headers.  Many properties of the response (Response) are similar to the properties of the request.  Significant <br>  among them are the following: <br><br>  ContentEncoding - encoding information in response <br>  Headers - a set of headers <br>  OutputStream - the stream to which the response will be written (for example, the text Html, XML or <br>  image byte array) <br>  RedirectLocation - the property is responsible for the HTTP Location header and allows you to redirect <br>  call <br>  StatusCode - status code when returning to the client, for example: 200 (OK), 404 (the resource is not <br>  found) <br>  StatusDescription - status description when returning to the client <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15c/692/350/15c692350d6563d543b9a74d29054735.png"><br><br>  The following method code, Process, Request, converts the generated string Result to HTML <br>  with the html code in the byte set and writes this byte set to the output stream, which <br>  will be returned to the customer.  The link to the output stream is obtained through the method parameter. <br><br><pre> <code class="javascript hljs"> = context.Response;  = net.GetStatic(<span class="hljs-string"><span class="hljs-string">"System.Text.Encoding"</span></span>, <span class="hljs-string"><span class="hljs-string">"UTF8"</span></span>).GetBytes(HTML); .ContentLength64 = .Length;  = .OutputStream; .Write(, <span class="hljs-number"><span class="hljs-number">0</span></span>, .Length); .Close();</code> </pre><br><br>  The processing is based on the HttpServer class, which creates an HttpListener object. <br>  and the required number of threads to process.  When you call the Start method, it starts <br>  all handler threads and a separate thread for HttpListener to work.  Thanks <br>  you can continue to work with 1C while the http server is running.  Upon enrolment <br>  the HttpListener request puts the request in a queue, where each request is sequentially <br>  processes the first free stream.  When processing a thread, a call chain is triggered: <br>  event HttpServer.ProcessRequest, Helper event handler.  HttpServer_ProcessRequest, <br>  1C-function Form.  Edit Request.  C # code class HttpServer when running 1C from the layout <br>  Source Code is compiled on the fly. <br><br><pre> <code class="hljs pgsql">_listener.AuthenticationSchemes = authenticationScheme; _listener.Prefixes.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(String.Format(@"http://+:{0}/", port)); _listener.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(); _listenerThread.<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _workers.Length; i++) { _workers[i] = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Thread(Worker); _workers[i].<span class="hljs-keyword"><span class="hljs-keyword">Start</span></span>(); }</code> </pre><br><br>  The start of receiving requests occurs in the HandleRequests method until processing <br>  will not be terminated by the user.  When a request is received, the request is passed to the method <br>  ContextReady and the listening process continues. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRequests</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_listener.IsListening) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = _listener.BeginGetContext(ContextReady, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == WaitHandle.WaitAny(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { _stop, context.AsyncWaitHandle })) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { WaitHandle[] wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { _ready, _stop }; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == WaitHandle.WaitAny(wait)) { HttpListenerContext context; <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_queue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_queue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) context = _queue.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _ready.Reset(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Console.Error.WriteLine(e); } } }</code> </pre><br><br><h1>  Conclusion </h1><br><br>  Multithreaded server, described in the article, for ease of configuration and functionality <br>  surpasses the traditional methods of access from the outside to the information databases of 1C: Enterprise <br>  8.x.  This is a simple start-up method that allows you to simultaneously process several <br>  requests.  At the same time, the 1C application is not blocked, and the user can continue <br>  work after starting the server. <br><br>  The main advantage of the proposed approach is complete control of the programmer. <br>  process from receiving a request to form a response.  For example, at the stage of obtaining <br>  request, you can parse the URL, get information on how to identify yourself <br>  user, as well as complete customer information (supported languages, recorded <br>  cookies, headers, access method).  The answer can be returned to almost anyone, starting <br>  error 404 Not found, ending with different graphic formats, Word formats, <br>  Excel and popular XML based formats (JSON, HTML, RSS). <br><br>  The example attached to the article is designed so that its functionality can be <br>  easy to expand.  For example, to organize the cache, use System.Web.Caching.Cache <br>  class from .Net framework.  When parsing a URL, try working with the RouteCollection class. <br>  from Asp.Net MVC.  When creating an RSS feed, the System.ServiceModel.Syndication class will help you. <br>  .SyndicationFeed.  And with Json serialization, notice the System.Runtime.Serialization.Json.DataContractJsonSerializer class. <br><br>  Specifically for the proposed approach at the moment there are no obvious shortcomings. <br>  There is a possibility that, due to its limitations, 1C: Enterprise will not be able to provide <br>  on its side, proper parallelization and a significant increase in performance. <br>  Nevertheless, experiments conducted earlier for 1C: Enterprise 8.2 showed that in similar <br>  the use of 1C achieved an increase in productivity, and 1C works at the same time <br>  stable <br><br>  It is necessary to draw the attention of developers for a few moments.  Any publication <br>  Information on the Internet is associated with the risk of hacking, regardless of the method of publication. <br>  But in the proposed method due to the flexibility there are more opportunities to resist <br>  threats from the outside.  For example, in the request, the client‚Äôs IP address is now available; <br>  block by some rules (by searching the blacklist locally or <br>  in specialized services).  Query parameters are available as strings and can be <br>  analyze on the side of 1C or .Net framework and block dangerous content. <br>  In addition, there are several specialized .Net libraries available to solve. <br>  This problem that can be brought into 1C, for example AntiXSS. <br><br>  The second point is that the well-known methods, including this one, of providing <br>  1C services are not intended for mass calls and will always be inferior <br>  from this point of view, professional servers such as IIS. <br><br>  Examples for the article: <br><br>  <a href="">HttpServer82.epf (11.50 kb)</a> <br><br>  <a href="">TestHttpServer82.epf (8.30 kb)</a> </div><p>Source: <a href="https://habr.com/ru/post/163859/">https://habr.com/ru/post/163859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163847/index.html">Controlled caching of pages in nginx</a></li>
<li><a href="../163849/index.html">What is wrong with the work on the result</a></li>
<li><a href="../163853/index.html">Git internals: data storage and merge</a></li>
<li><a href="../163855/index.html">Creating a Django web application in Visual Studio 2012 and publishing it to the Windows Azure cloud</a></li>
<li><a href="../163857/index.html">EBS RAID for faster performance and cost effectiveness</a></li>
<li><a href="../163861/index.html">Minicomputer from router with OpenWRT: write USB class-driver under Linux</a></li>
<li><a href="../163865/index.html">Started collecting pre-orders for virt2real (Virtuirlka)</a></li>
<li><a href="../163869/index.html">Atari Portfolio - John Connor's laptop</a></li>
<li><a href="../163871/index.html">Cheat Sheet by layout for large and small</a></li>
<li><a href="../163877/index.html">Is progressive improvement so expensive?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>