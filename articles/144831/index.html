<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effect of Glow Gaussian Blur on Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This epic work appeared thanks to several events. 

 Firstly, Android video acceleration support appeared in the Android emulator, whic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effect of Glow Gaussian Blur on Android</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/storage2/062/c73/02b/062c7302bd7117539622c6a975ad8f92.png" alt="Result" align="left">  This epic work appeared thanks to several events. <br><br>  Firstly, Android video acceleration support <a href="http://android-developers.blogspot.com/2012/04/faster-emulator-with-better-hardware.html">appeared</a> in the Android emulator, which allows working at full speed not only with the interface, but also with testing programs using OpenGL ES 2.0. <br><br>  Secondly, the birthday of his beloved spouse is nearing, and the best addition to the new smartphone or tablet will be the hand-written card program for him. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is said - done: we create the outline of the project on the android <a href="http://developer.android.com/resources/tutorials/opengl/opengl-es20.html">Tutorial</a> , we get the old Direct3D projects off the shelf using .3ds file upload, render-in-texture and shader packs, rewrite in Java and OpenGL ES 2.0, we get what we see in the picture .  Greeting text and the like will be added later. <br><br>  All the information on using OpenGL ES 2.0 on Android turned out to be very fragmented, knowledge was collected bit by bit ... I hope this post will help those who will face the same difficulties in the future as I am. <br><br>  And now more. <br><a name="habracut"></a><br><h4>  Training </h4><br>  The first thing to do is enable hardware acceleration in the emulator.  This is done either through the AVD Manager (see screenshot; do not forget to set the value to ‚Äúyes‚Äù), or by adding the line ‚Äúhw.gpu.enabled = yes to the file‚Äú .android / avd / &lt;your_ emulator_name&gt; .avd / config.ini ‚Äù. ".  There is one subtlety: hardware acceleration is incompatible with snapshots.  Accordingly, we remove this checkbox (or write in the .ini file ‚Äúsnapshot.present = false‚Äù). <br><br><img src="https://habrastorage.org/storage2/6e3/898/7f3/6e38987f3e531ba754f957fd47745791.png"><br><br>  Next, follow the above-mentioned Tutorial to create everything you need, in particular the heir to the Renderer class. <br><br><h4>  Model </h4><br>  By the word ‚Äúmodel‚Äù I mean here this very rosette.  In essence, you can use any object or the whole scene, it does not matter. <br><br>  This implies that all further code is located in the same class inherited from the Renderer class. <br><br><h5>  Loading model </h5><br>  I will not give the code for downloading the .3ds file here: long, and the post is not about that (in principle, it is worthy of a separate post), but I will give the model drawing code, because, firstly, I raked a lot along the way, secondly, it consists almost entirely of gl * calls, and thirdly, some functions will be needed below.  However, if only the implementation of the effect is interesting, you can skip this section.  So, as a result, all these models fit into such structures: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light3D</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] pos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] color; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Material3D</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] ambient; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] diffuse; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceMat</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material3D material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> faces; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>[] indexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bufOffset; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object3D</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;FaceMat&gt; faceMats; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertCount; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indCount; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glVertices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glIndices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] vertexBuffer; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene3D</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;Material3D&gt; materials; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;Object3D&gt; objects; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;Light3D&gt; lights; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] ambient; }</code> </pre> <br><br>  Here we deliberately removed such subtleties as specular and directional light sources: the scene will be hard enough to draw anyway.  The array of object vertices contains 6 * (the number of vertices) of real numbers: the coordinates of the vertices and the normals recorded in a row. <br><br>  Drawing from float / short arrays was not fast, but from buffers it was quite tolerable (depending on the driver and the video core, this data can be immediately located in the video memory).  We convert from one to another, separately vertex, separately index.  Do not forget after filling the buffer to finish working with it, specifying 0 as the active buffer. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] genbuf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] buffer)</span></span></span><span class="hljs-function"> </span></span>{ FloatBuffer floatBuf = ByteBuffer.allocateDirect(buffer.length * <span class="hljs-number"><span class="hljs-number">4</span></span>).order(ByteOrder.nativeOrder()).asFloatBuffer(); floatBuf.put(buffer); floatBuf.position(<span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glBuf = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, glBuf); GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, buffer.length * <span class="hljs-number"><span class="hljs-number">4</span></span>, floatBuf, GLES20.GL_STATIC_DRAW); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> glBuf; } ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, num = scene.objects.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; i++) { Object3D obj = scene.objects.get(i); obj.glVertices = createBuffer(obj.vertexBuffer); GLES20.glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); obj.glIndices = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, obj.glIndices); GLES20.glBufferData(GLES20.GL_ELEMENT_ARRAY_BUFFER, obj.indCount * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, GLES20.GL_STATIC_DRAW); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k, mats = obj.faceMats.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; mats; k++) { FaceMat mat = obj.faceMats.get(k); ShortBuffer indBuf = ByteBuffer.allocateDirect(mat.indexBuffer.length * <span class="hljs-number"><span class="hljs-number">2</span></span>).order(ByteOrder.nativeOrder()).asShortBuffer(); indBuf.put(mat.indexBuffer); indBuf.position(<span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glBufferSubData(GLES20.GL_ELEMENT_ARRAY_BUFFER, mat.bufOffset * <span class="hljs-number"><span class="hljs-number">2</span></span>, mat.indexBuffer.length * <span class="hljs-number"><span class="hljs-number">2</span></span>, indBuf); } GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  The vertex buffer generation is moved to a separate function in order to use it when creating a quad. <br><br><h5>  Shaders for a model </h5><br>  Create shaders for scene rendering: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String vertexShaderCode = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat4 uMVPMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat4 uMVMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat3 uNMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uAmbient;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uDiffuse;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"const int MaxLights = 8;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"struct LightSourceParameters {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" bool enabled;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 color;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 position;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"};\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform LightSourceParameters uLight[MaxLights];\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec4 vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec3 vNormal;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 FrontColor;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"vec4 light_point_view_local(vec3 epos, vec3 normal, int idx);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_Position = uMVPMatrix * vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 epos = uMVMatrix * vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 normal =uNMatrix * vNormal;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 vcolor = uAmbient;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" int i;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" for (i = 0; i &lt; MaxLights; i++) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (uLight[i].enabled) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vcolor += light_point_view_local(epos.xyz, normal, i);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" FrontColor = clamp(vcolor, 0.0, 1.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"vec4 light_point_view_local(vec3 epos, vec3 normal, int idx) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vert2light = uLight[idx].position - epos;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 ldir = normalize(vert2light);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float NdotL = dot(normal, ldir);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 outCol = vec4(0.0, 0.0, 0.0, 1.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (NdotL &gt; 0.0) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" outCol = uLight[idx].color * uDiffuse * NdotL;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" return outCol;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String fragmentShaderCode = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 FrontColor;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = FrontColor;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mProgram; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maNormal; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muMVPMatrix; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muMVMatrix; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muNMatrix; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muAmbient; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muDiffuse; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] muLightOn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] muLightPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] muLightCol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>];</code> </pre><br><br>  Compile them, determine the location of the attributes: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, String shaderCode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shader = GLES20.glCreateShader(type); GLES20.glShaderSource(shader, shaderCode); GLES20.glCompileShader(shader); Log.i(<span class="hljs-string"><span class="hljs-string">"Shader"</span></span>, GLES20.glGetShaderInfoLog(shader)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String vs, String fs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vs); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fs); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prog = GLES20.glCreateProgram(); <span class="hljs-comment"><span class="hljs-comment">// create empty OpenGL Program GLES20.glAttachShader(prog, vertexShader); // add the vertex shader to program GLES20.glAttachShader(prog, fragmentShader); // add the fragment shader to program GLES20.glLinkProgram(prog); // creates OpenGL program executables return prog; } ... mProgram = Compile(vertexShaderCode, fragmentShaderCode); // get handle to the vertex shader's vPosition member maPosition = GLES20.glGetAttribLocation(mProgram, "vPosition"); maNormal = GLES20.glGetAttribLocation(mProgram, "vNormal"); muMVPMatrix = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix"); muMVMatrix = GLES20.glGetUniformLocation(mProgram, "uMVMatrix"); muNMatrix = GLES20.glGetUniformLocation(mProgram, "uNMatrix"); muAmbient = GLES20.glGetUniformLocation(mProgram, "uAmbient"); muDiffuse = GLES20.glGetUniformLocation(mProgram, "uDiffuse"); int i; for (i = 0; i &lt; 8; i++) { muLightOn[i] = GLES20.glGetUniformLocation(mProgram, String.format("uLight[%d].enabled", i)); muLightPos[i] = GLES20.glGetUniformLocation(mProgram, String.format("uLight[%d].position", i)); muLightCol[i] = GLES20.glGetUniformLocation(mProgram, String.format("uLight[%d].color", i)); }</span></span></code> </pre><br><br>  I will not dwell on the work of these shaders: fragmentary and so trivial, and the vertex implements the usual work with omnidirectional light sources. <br><br><h5>  Model rendering </h5><br>  It is assumed that we already have the Model, View and Projection transformation matrices ready (for me, for example, the rosette turns smoothly).  From the work Model-View we select only a turn, it is necessary for working with normals. <br><br>  Drawing is simple and pleasant: we take the previously created buffers, assign attributes, draw.  It is worth noting that the coordinates of the light sources are transmitted in the eye-space, for this they are multiplied by the View matrix. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawScene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT); GLES20.glUseProgram(mProgram); GLES20.glEnable(GLES20.GL_CULL_FACE); GLES20.glEnable(GLES20.GL_DEPTH_TEST); Matrix.multiplyMM(mMVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mMMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>); Matrix.multiplyMM(mMVPMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mProjMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mMVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Apply a ModelView Projection transformation GLES20.glUniformMatrix4fv(muMVPMatrix, 1, false, mMVPMatrix, 0); GLES20.glUniformMatrix4fv(muMVMatrix, 1, false, mMVMatrix, 0); int i, j, num; for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 3; j++) mNMatrix[i*3 + j] = mMVMatrix[i*4 + j]; GLES20.glUniformMatrix3fv(muNMatrix, 1, false, mNMatrix, 0); num = min(scene.lights.size(), 8); float[] eyepos = new float[3]; for (i = 0; i &lt; num; i++) { Light3D light = scene.lights.get(i); for (j = 0; j &lt; 3; j++) { eyepos[j] = mVMatrix[4*3 + j]; for (k = 0; k &lt; 3; k++) eyepos[j] += light.pos[k] * mVMatrix[k*4 + j]; } GLES20.glUniform1i(muLightOn[i], 1); GLES20.glUniform3fv(muLightPos[i], 1, eyepos, 0); GLES20.glUniform4fv(muLightCol[i], 1, light.color, 0); } for (i = num; i &lt; 8; i++) GLES20.glUniform1i(muLightOn[i], 0); // Prepare the triangle data GLES20.glEnableVertexAttribArray(maPosition); GLES20.glEnableVertexAttribArray(maNormal); num = scene.objects.size(); for (i = 0; i &lt; num; i++) { Object3D obj = scene.objects.get(i); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, obj.glVertices); GLES20.glVertexAttribPointer(maPosition, 3, GLES20.GL_FLOAT, false, 24, 0); GLES20.glVertexAttribPointer(maNormal, 3, GLES20.GL_FLOAT, false, 24, 12); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, obj.glIndices); int mats = obj.faceMats.size(); for (j = 0; j &lt; mats; j++) { FaceMat mat = obj.faceMats.get(j); for (int k = 0; k &lt; 3; k++) mAmbient[k] = mat.material.ambient[k] * scene.ambient[k]; GLES20.glUniform4fv(muAmbient, 1, mAmbient, 0); GLES20.glUniform4fv(muDiffuse, 1, mat.material.diffuse, 0); GLES20.glDrawElements(GLES20.GL_TRIANGLES, mat.indexBuffer.length, GLES20.GL_UNSIGNED_SHORT, mat.bufOffset * 2); } GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, 0); } GLES20.glDisableVertexAttribArray(maPosition); GLES20.glDisableVertexAttribArray(maNormal); }</span></span></code> </pre><br><br><img src="http://habrastorage.org/storage2/72a/252/658/72a25265819fc99297baff1e5560c5ae.png" alt="Scene without effect" align="right"><br>  As a result, we got the function of rendering the scene without textures, but with materials and eight light sources.  Actually, this particular scene, and even on such a small screen, has nothing to do with the texture, and it looks good.  But I still want a glow! <br><br>  Now - the most interesting: let's render this scene for texture. <br><br><h4>  Quad </h4><br>  Quad we will need, first, to apply a Gaussian blur to a pre-rendered scene, and second, to apply the final ‚Äúglow‚Äù to the scene. <br><br><h5>  Create Quad </h5><br>  We prepare vertices and texture coordinates, create a buffer, compile the shader - everything is the same as for the model, except that the shaders have become even simpler: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadVS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec4 vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec4 vTexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_Position = vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" TexCoord0 = vTexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = texture2D(uTexture0, TexCoord0.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mQProgram; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maQPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maQTexCoord; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muQTexture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glQuadVB; ... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> quadv[] = { -<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; glQuadVB = createBuffer(quadv); mQProgram = Compile(quadVS, quadFS); maQPosition = GLES20.glGetAttribLocation(mQProgram, <span class="hljs-string"><span class="hljs-string">"vPosition"</span></span>); maQTexCoord = GLES20.glGetAttribLocation(mQProgram, <span class="hljs-string"><span class="hljs-string">"vTexCoord0"</span></span>); muQTexture = GLES20.glGetUniformLocation(mQProgram, <span class="hljs-string"><span class="hljs-string">"uTexture0"</span></span>);</code> </pre><br><br><h5>  Texture Buffer Preparation </h5><br>  Create two 256x256 buffers at once, this should be done in the onSurfaceChanged function. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> filterBuf1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> filterBuf2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> renderTex1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> renderTex2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scrWidth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scrHeight; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> texWidth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> texHeight; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRenderTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] handles)</span></span></span><span class="hljs-function"> </span></span>{ GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> renderTex = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, renderTex); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); IntBuffer texBuffer = ByteBuffer.allocateDirect(width * height * <span class="hljs-number"><span class="hljs-number">4</span></span>).order(ByteOrder.nativeOrder()).asIntBuffer(); GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GLES20.GL_RGBA, width, height, <span class="hljs-number"><span class="hljs-number">0</span></span>, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, texBuffer); GLES20.glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depthBuf = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER, depthBuf); GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_COMPONENT16, width, height); GLES20.glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameBuf = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuf); GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, renderTex, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT, GLES20.GL_RENDERBUFFER, depthBuf); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER); GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>); handles[<span class="hljs-number"><span class="hljs-number">0</span></span>] = frameBuf; handles[<span class="hljs-number"><span class="hljs-number">1</span></span>] = renderTex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL10 gl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ ratio = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) width / height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] handles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; scrWidth = width; scrHeight = height; texWidth = <span class="hljs-number"><span class="hljs-number">256</span></span>; texHeight = <span class="hljs-number"><span class="hljs-number">256</span></span>; makeRenderTarget(texWidth, texHeight, handles); filterBuf1 = handles[<span class="hljs-number"><span class="hljs-number">0</span></span>]; renderTex1 = handles[<span class="hljs-number"><span class="hljs-number">1</span></span>]; makeRenderTarget(texWidth, texHeight, handles); filterBuf2 = handles[<span class="hljs-number"><span class="hljs-number">0</span></span>]; renderTex2 = handles[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre><br><br>  There are two variables associated with each texture buffer: the actual texture and frame buffer (I apologize for the tautology). <br><br><h5>  Drawing a quad from texture / texture </h5><br>  Literally a couple of functions: one sets the current source and target of the drawing (0 is our screen, the rest is the previously created frame buffers), the second draws a quad. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRenderTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameBuf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> texture)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frameBuf == <span class="hljs-number"><span class="hljs-number">0</span></span>) GLES20.glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scrWidth, scrHeight); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> GLES20.glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, texWidth, texHeight); GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuf); GLES20.glActiveTexture(GLES20.GL_TEXTURE0); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GLES20.glUseProgram(mQProgram); GLES20.glDisable(GLES20.GL_DEPTH_TEST); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, glQuadVB); GLES20.glEnableVertexAttribArray(maQPosition); GLES20.glVertexAttribPointer(maQPosition, <span class="hljs-number"><span class="hljs-number">3</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glEnableVertexAttribArray(maQTexCoord); GLES20.glVertexAttribPointer(maQTexCoord, <span class="hljs-number"><span class="hljs-number">2</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glUniform1i(muQTexture, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); GLES20.glDisableVertexAttribArray(maQPosition); GLES20.glDisableVertexAttribArray(maQTexCoord); }</code> </pre><br><br><img src="http://habrastorage.org/storage2/c76/717/fcc/c76717fccc5ed9519327178be924cf02.png" alt="Scene in texture" align="right">  Since the effect will overlap in several passes, for performance reasons, the texture is low resolution, so the result of its rendering on the quad will be similar to something like the one shown in the picture. <br><br>  Phew!  Just a little bit left: a couple more shaders and a few blocks of code! <br><br><h4>  Gaussian blur </h4><br>  One-dimensional blur is implemented here as follows: for each point of our frame, 44 neighboring pixels are taken, and their colors are added with different weights, in accordance with the Gaussian distribution.  We will do this in 11 passes, in each of which we will add 4 pixels of the original scene to the resulting image.  Appropriately, the shaders are designed to impose four textures in a single pass, with different offsets.  Of course, you can make a smaller number of passes, here you have to look to your taste and according to how much you can draw out the iron on which you plan to launch the program with acceptable performance. <br><br>  The effect is applied in two stages: horizontally and vertically.  We will need to calculate something in advance. <br><br><h5>  Gauss Supporting Data </h5><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterKernelElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> du; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dv; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> coef; } ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mOffsets[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] pix_mult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FilterKernelElement[] mvGaussian1D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FilterKernelElement[<span class="hljs-number"><span class="hljs-number">44</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mfPerTexelWidth; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mfPerTexelHeight; ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cent = (mvGaussian1D.length - <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, radi; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; mvGaussian1D.length; u++) { FilterKernelElement el = mvGaussian1D[u] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FilterKernelElement(); el.du = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)u) - cent - <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; el.dv = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; radi = (el.du * el.du) / (cent * cent); el.coef = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-number"><span class="hljs-number">0.24</span></span>/Math.exp(radi*<span class="hljs-number"><span class="hljs-number">0.18</span></span>)) + <span class="hljs-number"><span class="hljs-number">0.41</span></span>/Math.exp(radi*<span class="hljs-number"><span class="hljs-number">4.5</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rr = texWidth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) texHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rs = rr / ratio; mfPerTexelWidth = rs / texWidth; mfPerTexelHeight = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / texHeight;</code> </pre><br><br>  The constants calculated at the end are needed to correct the aspect ratio: the screen, unlike the texture buffer, is not square, so without such an adjustment the glow will be somewhat flattened. <br><br><h5>  Gauss Shaders </h5><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String gaussVS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec4 vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"attribute vec4 vTexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexOffset0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexOffset1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexOffset2;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexOffset3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord2;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_Position = vPosition;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" TexCoord0 = vTexCoord0 + uTexOffset0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" TexCoord1 = vTexCoord0 + uTexOffset1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" TexCoord2 = vTexCoord0 + uTexOffset2;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" TexCoord3 = vTexCoord0 + uTexOffset3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String gaussFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexCoef0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexCoef1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexCoef2;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uTexCoef3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord2;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 c0 = texture2D(uTexture0, TexCoord0.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 c1 = texture2D(uTexture0, TexCoord1.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 c2 = texture2D(uTexture0, TexCoord2.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 c3 = texture2D(uTexture0, TexCoord3.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = uTexCoef0 * c0 + uTexCoef1 * c1 + uTexCoef2 * c2 + uTexCoef3 * c3;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mGProgram; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maGPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maGTexCoord; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> muGTexture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] muGTexCoef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] muGTexOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ... mGProgram = Compile(gaussVS, gaussFS); maGPosition = GLES20.glGetAttribLocation(mGProgram, <span class="hljs-string"><span class="hljs-string">"vPosition"</span></span>); maGTexCoord = GLES20.glGetAttribLocation(mGProgram, <span class="hljs-string"><span class="hljs-string">"vTexCoord0"</span></span>); muGTexture = GLES20.glGetUniformLocation(mGProgram, <span class="hljs-string"><span class="hljs-string">"uTexture0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { muGTexOffset[i] = GLES20.glGetUniformLocation(mGProgram, String.format(<span class="hljs-string"><span class="hljs-string">"uTexOffset%d"</span></span>, i)); muGTexCoef[i] = GLES20.glGetUniformLocation(mGProgram, String.format(<span class="hljs-string"><span class="hljs-string">"uTexCoef%d"</span></span>, i)); }</code> </pre><br><br><h5>  Gauss drawing </h5><br>  This function will blur on one axis: either horizontally or vertically, and in several passes.  That is why two textures were needed! <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawGauss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> invert)</span></span></span><span class="hljs-function"> </span></span>{ GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); GLES20.glUseProgram(mGProgram); GLES20.glDisable(GLES20.GL_DEPTH_TEST); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, glQuadVB); GLES20.glEnableVertexAttribArray(maGPosition); GLES20.glVertexAttribPointer(maGPosition, <span class="hljs-number"><span class="hljs-number">3</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glEnableVertexAttribArray(maGTexCoord); GLES20.glVertexAttribPointer(maGTexCoord, <span class="hljs-number"><span class="hljs-number">2</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glUniform1i(muGTexture, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, n, k; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvGaussian1D.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; n++) { FilterKernelElement pE = mvGaussian1D[i + n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; k++) pix_mult[k] = pE.coef * <span class="hljs-number"><span class="hljs-number">0.10f</span></span>; GLES20.glUniform4fv(muGTexCoef[n], <span class="hljs-number"><span class="hljs-number">1</span></span>, pix_mult, <span class="hljs-number"><span class="hljs-number">0</span></span>); mOffsets[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mfPerTexelWidth * (invert ? pE.dv : pE.du); mOffsets[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mfPerTexelHeight * (invert ? pE.du : pE.dv); GLES20.glUniform4fv(muGTexOffset[n], <span class="hljs-number"><span class="hljs-number">1</span></span>, mOffsets, <span class="hljs-number"><span class="hljs-number">0</span></span>); } GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); } GLES20.glDisableVertexAttribArray(maGPosition); GLES20.glDisableVertexAttribArray(maGTexCoord); }</code> </pre><br><br>  This is what the result will look like after horizontal and vertical blur, respectively: <br><br><img src="http://habrastorage.org/storage2/690/28c/daa/69028cdaa46afdc858f585d8c467aa08.png" alt="After horizontal blur"><img src="http://habrastorage.org/storage2/8f4/5cf/0b4/8f45cf0b4a077d335b64fca4933734e0.png" alt="After vertical blur"><br><br><h4>  Putting it all together </h4><br>  The last step: the procedure of drawing the entire frame, with all the effects.  We must once again render the model, and then impose a glow on it. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL10 arg0)</span></span></span><span class="hljs-function"> </span></span>{ setRenderTexture(filterBuf1, <span class="hljs-number"><span class="hljs-number">0</span></span>); DrawScene(); GLES20.glEnable(GLES20.GL_BLEND); GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE); setRenderTexture(filterBuf2, renderTex1); DrawGauss(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRenderTexture(filterBuf1, renderTex2); DrawGauss(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); GLES20.glDisable(GLES20.GL_BLEND); setRenderTexture(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); DrawScene(); GLES20.glEnable(GLES20.GL_BLEND); GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE); setRenderTexture(<span class="hljs-number"><span class="hljs-number">0</span></span>, renderTex1); DrawQuad(); GLES20.glDisable(GLES20.GL_BLEND); }</code> </pre><br><br>  Total: <br>  1. Draw a scene in the first texture; <br>  2. For the first texture, we make a horizontal blur, save the result to the second; <br>  3. We erase the second texture vertically, save it to the first; <br>  4. Draw a scene in the usual mode; <br>  5. We put the first texture on top of the scene with a quad; <br>  6. Done! <br><br>  In fact, the scene can be drawn once, only on the texture, immediately copying it at the very beginning into the screen buffer using quad.  However, to ensure a decent picture quality, this will require a texture of the same resolution as the screen itself, and this will significantly slow down its blurring. <br><br>  By the way, the resulting program serves as a good benchmark, although it rests mainly in the fillrate.  The only "but": it does not work well on Qualcomm processors (some kind of problem with the shader of the original scene), and I could not figure out the reason, because  I do not have a single device from HTC to debug to the end, but everything is perfectly drawn on the PowerVR 540 (on the old Galaxy S), Mali 400 (S2, Tab 7.7, Note) and in the emulator. <br><br>  <b>Update:</b> Since the publication, several errors have been found, so the article has been slightly updated.  The model's shader code has changed (vertexShaderCode, several lines have been removed), the DrawScene function code (the transformation of the coordinates of the light sources to eye-space has been added) and the final rendering (onDrawFrame), the screenshots have been updated (the redraw has disappeared).  The rest remains the same. <br><br>  <b>Update 2:</b> <a href="http://habrahabr.ru/post/144955/">Downloading post .3ds is</a> ready. <br><br>  <b>Update 3:</b> The problem of drawing on the squares is solved: it turned out that this line is in the shader <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; uLights; i++)</code> </pre> <br>  worked wrong.  Who would have thought?.. <br>  Shaders and everything else is updated, now this problem will not be. </div><p>Source: <a href="https://habr.com/ru/post/144831/">https://habr.com/ru/post/144831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144826/index.html">Java IQ test</a></li>
<li><a href="../144827/index.html">"Nahlobuchka" - all</a></li>
<li><a href="../144828/index.html">Fedora 17 Beefy Miracle</a></li>
<li><a href="../144829/index.html">Digital Sound Museum</a></li>
<li><a href="../144830/index.html">Create syntax highlighting in Notepad ++</a></li>
<li><a href="../144832/index.html">Experiment Opera Mini. Episode 2: Insidious Invasion</a></li>
<li><a href="../144834/index.html">A couple of words about Header Map in Xcode</a></li>
<li><a href="../144835/index.html">Overview of the HP Folio 13-2000 Ultrabook</a></li>
<li><a href="../144836/index.html">UI State Management for Windows Phone Development</a></li>
<li><a href="../144837/index.html">Herrmann Dominanz Instrument (HDI). Part I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>