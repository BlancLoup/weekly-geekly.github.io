<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sorting on a single-linked list in O (nlogn) time, at worst, with O (1) additional memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with this topic on gamedev.ru. Topikstarter suggested finding a sort that has the following properties: 


1. Execution time - guarante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sorting on a single-linked list in O (nlogn) time, at worst, with O (1) additional memory</h1><div class="post__text post__text-html js-mediator-article">  It all started with <a href="http://www.gamedev.ru/flame/forum/%3Fid%3D196521">this topic</a> on gamedev.ru.  Topikstarter suggested finding a sort that has the following properties: <br><ol><li>  Execution time - guaranteed O (nlogn). </li><li>  Use O (1) extra memory. </li><li>  Applicability for sorting data in single-linked lists (but not limited to). </li></ol><br>  Reservations on all three restrictions: <br><ol><li>  Guaranteed O (nlogn) means that, for example, the average fast sorting time is not suitable - O (nlogn) should be obtained for any, even the worst input data. </li><li>  Recursion cannot be used because it implies O (logn) memory for storing a stack of recursive calls. </li><li>  There is no arbitrary access to the elements of the sorted array, we can move the iterator from any element only to the next (for O (1)), and only in one direction (forward in the list).  To modify the list itself (to move pointers to the following elements) is impossible. </li></ol><br>  All the information we know about the elements of an array is that they all form a <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25BE_%25D1%2583%25D0%25BF%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D1%2587%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE">linearly ordered set</a> .  All we can do is compare the two elements of the array (for O (1)) and swap them (also for O (1)). <br><br>  Under the cut you can find out what happened with us. <br><br>  <b>Challenge</b>  Before looking under the cut, I suggest you first think about the algorithm yourself.  If you think up something cooler than our version - write in the comments. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Reservations </h4><br>  I will make a reservation that no thorough search for articles has been made - perhaps we have re-discovered some already known algorithm, or the algorithm that solves this problem has long been known (perhaps much more efficiently than ours). <br><br>  Practical application of our algorithm is hardly possible, the task is more of academic interest. <br><br><h4>  Collection of information </h4><br>  Known sortings that immediately come to mind do not satisfy all three points at the same time, for example: <br><ul><li>  Bubble sorting (bubble sort) is suitable for items 2 and 3, but it works for O (n <sup>2</sup> ). </li><li>  Quick sorting (quick sort) satisfies items 2 and 3 (item 2 - with knowledge of some idea), but for item 1 it gives O (nlogn) time only on average and there are input data on which it will work for O (n <sup>2</sup> ). </li><li>  Heap sorting satisfies constraints 1 and 2, but unfortunately, random access to memory is required. </li><li>  Merge sorting is limited to 1 and 3, but requires O (n) additional memory. </li><li>  Sorting by merging in place (in-place merge sort) fits within constraints 1 and 2 (there is even its <a href="http://habrahabr.ru/post/205290/">stable version</a> , but there is tin), but it is completely unclear how to effectively implement it without random access to memory. </li></ul><br><br><h4>  Median of Medians or BFPRT algorithm </h4><br>  In the first comment by a comrade of FordPerfect, the Median of Medians algorithm, which is not very widely known, was proposed.  Its other name is BFPRT from the names of the scientists who invented it: Manuel <b>B</b> Lum, Robert V. <b>F</b> Loyd, Von Pratt, Ronald L. <b>R</b> Yvest and Robert E. <b>T.</b> Arjan.  The algorithm is described on Wikipedia ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25B2%25D1%258B%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0">ru</a> , <a href="http://en.wikipedia.org/wiki/Median_of_medians">en</a> ), as well as in Cormen, but I will tell you a little about it, because on Wikipedia it is described so clumsily that I understood its essence only after comparing the Russian and English versions (and I also had to look at the <a href="http://people.csail.mit.edu/rivest/pubs/BFPRT73.pdf">original article</a> ).  And on Habr√© his description was not yet.  In Kormen, if anything, the description is normal, but I already learned that this algorithm is there later.  If you already know this algorithm, you can skip this piece of the article. <br><br>  The Median of Medians algorithm allows you to find the k-th ordinal statistics on any array for linear time in the worst case.  In the C ++ STL library there is a similar algorithm std :: nth_element, which also finds the k-th ordinal statistics for linear time, but on average, since it is based on the Quickselect algorithm.  The latter is essentially a quick sort, in which at each step we descend only one branch of recursion (for more information about Quickselect, read <a href="http://en.wikipedia.org/wiki/Quickselect">here</a> and <a href="http://e-maxx.ru/algo/kth_order_statistics">here</a> ).  Median of Medians is a modification of the Quickselect algorithm and does not allow the selection of a bad element for ‚Äúbranching‚Äù, which in the worst case leads to a quadratic operating time. <br><br>  Why do we need this Median of Medians?  Yes, everything is quite simple - with its help it is possible to find the median of the array (n / 2 nd order statistics) in linear time and it is for this element to branch the quick sort algorithm.  This will make quick sort work for O (nlogn) not on average, but in the worst case. <br><br>  Algorithm description Median of Medians.  Input data: an array (given, for example, by the first and last elements of the list) and the number k - which element we need to find in a row. <br><ol><li>  If the array is small enough (less than 5 elements), sort it in the forehead with a bubble and return the k-th element. </li><li>  We break all the elements of the array into blocks of 5 elements.  We do not pay attention to the possible incomplete last block. </li><li>  In each block we sort the elements of the bubble. </li><li>  Select the subarray from the middle (third) elements of each block.  You can simply transfer them to the beginning of the array. </li><li>  Recursively run Median of Medians for these [n / 5] elements and find their median (n / 10th element).  This element will call the pivot element. </li><li>  We make the separation procedure, probably familiar to everyone in the quick sort and quickselect algorithms: move all elements less than the reference one to the beginning of the array, and all elements more than that - to the end.  Elements from a possible incomplete block at the end of an array are also taken into account.  Total, we get three blocks: the elements are smaller than the reference, equal to and greater than it. </li><li> We determine in which of the blocks we need to look for our k-th element.  If it is in the second block, we return any item from there (they are all the same all the same).  Otherwise, we recursively launch the Median of Medians for this block with possible correction for the element number: for the third block, subtract the lengths of the previous blocks from the number k. </li></ol><br><br>  Consider the example of what is happening here.  Suppose there is an array and we want to find its median: <br><br><img src="https://habrastorage.org/files/81d/42e/8b1/81d42e8b10c343ddbc99aeef7af5e8ad.png"><br><br>  There are 27 different numbers from 1 to 27. We are looking for the 14th element in a row.  We divide the elements into blocks of length 5 and sort the numbers inside each block: <br><br><img src="https://habrastorage.org/files/147/8be/5ea/1478be5eafc340fea71c2a3892fa6ad0.png"><br><br>  The medians of each block are highlighted in yellow.  Move them to the beginning of the array and recursively run our algorithm to find the median in it: <br><br><img src="https://habrastorage.org/files/386/16c/67e/38616c67e79143f08c06dd10c9bd3f48.png"><br><br>  I will not describe what is going on inside recursion, one thing is clear - the number 12 will be the desired median. <br><br><img src="https://habrastorage.org/files/cce/8fa/165/cce8fa165bf14e86bd3f375951ccb44a.png"><br><br>  This number 12 - the reference element or median of the medians - has the following remarkable property.  Let's go back a couple of pictures and <i>mentally</i> move our blocks as follows: <br><br><img src="https://habrastorage.org/files/493/fa0/f70/493fa0f70a00450db85c0795112834a0.png"><br><br>  All columns are sorted by the middle element, plus the elements in each column are also sorted.  We can see that about 30% of the elements (3 / 10n + O (1), to be exact), which are higher and to the left of the support element, are no more than that.  Similarly, for about 30% of the elements below and to the right of the support element - they are not less than he.  This means that when we carry out the separation procedure, approximately 30% of all elements will necessarily be to the left of the support element and approximately 30% to the right: <br><br><img src="https://habrastorage.org/files/036/d17/285/036d172856b649069753bb52edab1f7b.png"><br><br>  In fact, there is a small inaccuracy: we are lucky that there are exactly one element equal to the reference one.  If there are a lot of such elements, then they all form a whole block, and where exactly the supporting element will stand is not clear.  But it does not really matter.  We know that elements that are not less than a support element are not less than 30%, which means elements that are strictly less than a support element are not more than 70%.  Similarly, elements that are strictly larger than the support element are also not more than 70%.  Thus, the sizes of the first and third blocks from the description of the algorithm above will always have a length of no more than 7 / 10n + O (1)! <br><br><img src="https://habrastorage.org/files/4df/02f/588/4df02f588f1d48ac8ceeb6c1eb6ed31d.png"><br><br>  Let's continue the analysis of the example.  After the separation procedure, it becomes clear that our 14th element is in the third block, so we recursively run the entire algorithm for it, but now we are looking for the 2nd element in it. <br><br>  What is the complexity of the algorithm considered by us? <br><br>  Let T (n) be the number operation of the Median of Medians algorithm in the worst case for an array of length n.  At each step, the algorithm recursively calls itself twice.  The first time is to find the median of the medians on an array of length n / 5 + O (1) elements.  The second time is reducing the search space, while in the worst case the size of the array is reduced to 7 / 10n + O (1).  All other operations require linear time.  Total we get the ratio: <br><br>  T (n) = T (2 / 10n) + T (7 / 10n) + Cn, where C is some constant. <br><br>  We decompose this relation: <br><br>  T (n) = Cn + ( <sub>2/10 + 7/10</sub> ) Cn + ( <sub>2/10 + 7/10)</sub> ( <sub>2/10 + 7/10</sub> ) Cn + ... = Cn * ‚àë <sub>i = 0..‚àû</sub> ( 9/10) <sup>i</sup> = 10Cn = O (n) <br><br>  Fine!  The algorithm has linear complexity! <br><br>  Median of Medians is easy to implement on lists using recursion, which gives us a good partial solution to the original problem: guaranteed sorting by O (nlogn) on a simply connected list using O (logn) memory. <br><br>  <a href="http://www.everfall.com/paste/id.php%3Fz5pialpyrfrf">Code</a> <br><br>  Let's get rid of recursion now. <br><br><h4>  Flat quick sort </h4><br>  First, let's remove the recursion from, in fact, a quick sort.  How to do this is not entirely obvious, so in this section we will look at how to do it. <br><br>  This section will describe the idea that FordPerfect suggested on the gamedev.ru forum (yes, in fact, all the ideas of this article are not mine - I just posted it).  The original source of the idea is unknown, Google on this occasion is mostly silent and gives out many references to the so-called iterative quicksort, where the stack is emulated all along (however, <a href="http://stackoverflow.com/questions/11455242/is-it-possible-to-implement-quicksort-with-o1-space-complexity">there</a> was a discussion of a similar idea), and FordPerfect himself said that his groupmate in 40 minutes of thinking about the task "quicksort with O (1) memory."  The name ‚ÄúFlat quick sort‚Äù is also self-made, perhaps this algorithm is known by another name. <br><br>  Let's remember how ordinary recursive quick sort works.  Input data: an array defined by, for example, two iterators to the initial and final elements of a simply linked list. <br><ol><li>  Check in one pass: if the array is already sorted, then there is nothing to do - we exit. </li><li>  We select an element (pivot) for the separation procedure - usually by chance, but for our case - the median using the Median of Medians algorithm. </li><li>  We create the separation procedure - we get three blocks: elements, which is less than pivot;  elements that are equal to him;  and items more. </li><li>  Recursively run a quick sort for the first and third blocks. </li></ol><br><br>  The information that we need to memorize during the recursion is where the third block begins and ends. <br><br>  Note the following thing: any element of the first block is less than any element of the second block, and any element of the second block is less than any element of the third block. <br><br>  The idea is as follows: let's move the largest element to the beginning of the block in each block.  Then we can uniquely determine where the next block will begin!  To do this, we will simply go from the beginning of the block until we meet the element strictly more - it will signal the beginning of the next block! <br><br>  Now the quick sort algorithm can be rewritten as follows: <br><ol><li>  Create pointers X and Y. Let pointer X point to the beginning of the array, and pointer Y to its end.  Also create a pointer Z, which will point to the end of the current block.  Initially, Z = Y. </li><li>  Endlessly perform the following actions: </li><li><ol><li>  If the current XZ block is already sorted, look for the next block.  We move X to the element following Z. If X cannot be moved, because Z = Y, we exit the loop.  Now we are looking for the closest element a after X, which is larger than the element pointed to by X. If there is no such thing, do Z = Y, otherwise move Z to the element before a. </li><li>  We perform the usual quick sort actions: selecting the item to be divided and the separation itself.  We get three blocks. </li><li>  We do blocking of the third block: we look for the maximum element in it and move it to the beginning. </li><li>  Move Z to the end of the first block. </li></ol></li></ol><br><br>  Now let's look at this algorithm by example: <br><br><img src="https://habrastorage.org/files/81d/42e/8b1/81d42e8b10c343ddbc99aeef7af5e8ad.png"><br><br>  Somewhere I have already seen this array ... Let's set the pointers X, Y and Z: <br><br><img src="https://habrastorage.org/files/73d/773/277/73d773277bb144d6a96e9a2be18521b6.png"><br><br>  XZ block is not sorted.  Then we find the median: <br><br><img src="https://habrastorage.org/files/16f/597/652/16f5976527e24e6ca96f27e6a12399ce.png"><br><br>  We assume that the median search procedure mixes the elements in the most bizarre way, leaving the median itself at the very beginning (for clarity of the example! The implementation may, for example, return an iterator to the element that is the median).  Ok, let's do the split procedure now: <br><br><img src="https://habrastorage.org/files/762/23d/9d9/76223d9d9d1c427682bbe895253569b5.png"><br><br>  It turned out 3 blocks.  Block the final block and move Z to the end of the first block: <br><br><img src="https://habrastorage.org/files/a1c/00b/744/a1c00b7441f9466181b6082006c392d4.png"><br><br>  Now we start from the beginning.  The current XZ block is not sorted, so we are looking for a median in it: <br><br><img src="https://habrastorage.org/files/5f6/1ba/384/5f61ba384acc464ab6d972551b7c4547.png"><br><br>  Perform the separation procedure: <br><br><img src="https://habrastorage.org/files/61e/8a8/b1a/61e8a8b1a0674abeaa6471d4405ee031.png"><br><br>  Block the third block and move Z to the end of the first block: <br><br><img src="https://habrastorage.org/files/bcb/ef5/c47/bcbef5c47dd94d9fbdee5fcebbb8eb7c.png"><br><br>  Look at the XZ again: <br><br><img src="https://habrastorage.org/files/b6a/b04/717/b6ab0471740249309195c27c00d33c9c.png"><br><br>  We were lucky!  The block is sorted, so you can leave it alone and look for the next block.  Pointers X and Z will move as follows: <br><br><img src="https://habrastorage.org/files/abc/f10/56c/abcf1056c95e4ae2aef2daed270f4692.png"><br><br>  Suddenly, this block is also sorted, since this is the second block of the previous step.  We are looking for the next block: <br><br><img src="https://habrastorage.org/files/03e/8d1/213/03e8d12137494b499e40a7ad91f3dcb3.png"><br><br>  We check for orderliness - unfortunately, this time no luck, it is necessary to streamline.  We find the median, and then we do the separation procedure: <br><br><img src="https://habrastorage.org/files/9ca/f6e/506/9caf6e50692f4e038919f0bf3fa91cce.png"><br><br><img src="https://habrastorage.org/files/291/045/0f1/2910450f113e4018ad14f7a832e1deba.png"><br><br>  Next, we move to block [8,9], it is sorted, so X and Z will move to block [10], which is also sorted, after which the algorithm will consider the block [13, 11, 12], in which everything is completely trivial .  Analysis of the second half of the array sorting is proposed for the reader to perform independently. <br><br>  <a href="http://www.everfall.com/paste/id.php%3Ftvgw5rwfnw3o">Code</a> <br><br><h4>  Approximate Median of Medians with O (1) Extra Memory </h4><br>  Unfortunately, with the Median of Medians such a focus, as the use of the maximum element to identify blocks in a flat quick sort, will not work, because the elements of the array are mixed each time it is not clear how.  Here we will use another trick. <br><br>  In fact, to make quick sort work beyond guaranteed O (nlogn), it is not necessary to find the exact median for the separation stage.  It is enough to find something approximate.  If we give a guarantee that the first and third blocks after the separation stage will not exceed Cn for some particular C &lt;1, the quick sort will work for O (nlogn).  Even for C = 0.99.  With a <s>fierce</s> mad hidden constant, but O (nlogn)! <br><br>  Therefore, we modify the Median of Medians so that it finds the median with some error K = O (log <sup>2</sup> n).  That is, an element will be found whose sequence number is somewhere in the range from n / 2-K / 2 to n / 2 + K / 2.  Since K is of the order of the degree of the logarithm, it is easy to find such a (concrete) n, starting from which the segment [n / 2-K / 2, n / 2 + K / 2] will lie, say, between 1 / 4n and 3 / 4n.  For all smaller n, you can just sort by bubble. <br><br>  Why is K = O (log <sup>2</sup> n)?  Yes, we simply use K elements of the array in order to store all the necessary information on the stack (the idea, again, by a friend of FordPerfect).  Recursion levels O (logn), at each of them we need to save O (1) numbers to O (logn) bits.  And we will find the median for quick sort among the remaining NK elements. <br><br>  Each bit is represented by two consecutive different elements of the array.  If the first of them is less than the second - the bit stores the state 0, otherwise - 1 (or vice versa).  The first task that we need to solve is to find K / 2 pairs of different elements of the array and understand what to do if there are not so many pairs. <br><br>  This is done very simply.  Let iterators X and Y point to the first element of the array.  We will move Y forward until we find an element that is not equal to X. If we find it, move X forward, swap the elements pointed to by X and Y, move X again forward (+ still need to handle a minor case - move Y forward if turned out to be X).  And so until we find the K / 2 pairs.  What if Y has already reached the end of the array, and K / 2 pairs have not yet been found?  This means that all elements from X to Y inclusive are the same!  (It is quite simple to verify that this invariant is preserved throughout the execution of the entire algorithm).  Then, as a reference element, you can immediately select one of these elements.  If you select K &lt;n / 2, this reference element will be the exact median. <br><br>  Now the question is: will work with the stack break the asymptotics of the algorithm?  This is a very good question, because at first glance it seems that the vertices in our recursive tree are of order O (n) and for each vertex we need O (log <sup>2</sup> n) stack operations.  Do the asymptotics worsen to O (nlog <sup>2</sup> n) for our Median of Medians (and to O (nlog <sup>3</sup> n) for the whole algorithm)?  It's all a bit more complicated. <br><br>  To calculate the exact number of vertices in the tree, the following recurrent must be solved: <br><br>  N (n) = N (n / 5) + N (7N / 10) + 1 <br>  N (n) = 1 for n &lt;C <br><br>  Something like this could be seen above, but replacing Cn with 1 makes the recurrent somewhat more difficult to compute.  The <a href="https://en.wikipedia.org/wiki/Akra%25E2%2580%2593Bazzi_method">Akra-Bazzi method</a> comes to the rescue.  Our recurrence fits all conditions and after all the appropriate permutations we get that the number of vertices N (n) grows as O (n <sup>0.84</sup> ) (Œò (n <sup>0.839780 ...</sup> ) to be more precise).  Total time complexity of the algorithm is O (n + n <sup>0.84</sup> log <sup>2</sup> n) = O (n). <br><br>  I consider further specification of the algorithm unnecessary, you just need to implement what was described in one of the previous chapters of the article.  Better to look at the <a href="http://www.everfall.com/paste/id.php%3Fc7yaynxcsydp">code</a> right away.  There will be no pictures either - in order for the algorithm to work at all, you need a fairly large number of elements in the array.  Which one exactly?  About this below. <br><br>  How impractical is the proposed algorithm?  Here are some calculations: <br><br>  Suppose we want to get a deviation of no more than 1 / 4n from the real median (that is, K &lt;n / 2).  Then we need to stack the stack with 3 [logn] levels of recursion (here log is binary, 3 due to the fact that (3/4) <sup>3</sup> &lt;0.5, and [x] is rounding the number x up to the nearest integer).  For each level of recursion we need 2 [logn] bits - we need to store the current length of the array, which element we are looking for in order now (this number always fits into [logn] -1 bit) and one more bit to maintain the recursion tree traversal order ( remember which branch of recursion we are back from).  For every bit of 2 elements, it takes 12 [logn] <sup>2</sup> elements per stack. <br><br>  Now we solve the equation: 12 [logn] <sup>2</sup> &lt;n / 2 or 24 [logn] <sup>2</sup> &lt;n.  It is necessary to find n 'such that for any n&gt; = n' 24 [logn] <sup>2</sup> &lt;n.  Such n 'is about 3500. That is, for n &lt;3500 it is necessary to sort the bubble. <br><br>  The limit for n, starting from which K always does not exceed n - 1500, that is, for n &lt;1500, sorting does not even work (there are not enough elements to emulate the stack), then without thinking you should use a bubble.  However, if you play with constants, then you can probably improve this estimate. <br><br>  <a href="http://www.everfall.com/paste/id.php%3Fc7yaynxcsydp">Code</a> <br><br><h4>  Code </h4><br>  All links to the code throughout the article in one place: <br><ul><li>  <a href="http://www.everfall.com/paste/id.php%3Fz5pialpyrfrf">Quick sort + Median of Medians</a> (Guaranteed O (nlogn), O (logn) extra memory) </li><li>  <a href="http://www.everfall.com/paste/id.php%3Ftvgw5rwfnw3o">Flat quick sort + Median of Medians</a> (Guaranteed O (nlogn), O (logn) extra memory) </li><li>  <a href="http://www.everfall.com/paste/id.php%3Fc7yaynxcsydp">Flat quick sort + Approximate Median of Medians</a> (Guaranteed O (nlogn), O (1) extra memory) </li></ul><br><br><h4>  Read </h4><br><ol><li>  <a href="http://www.gamedev.ru/flame/forum/%3Fid%3D196521">Discussion of the algorithm</a> on gamedev.ru. </li><li>  Median of Medians on wikipedia ( <a href="http://en.wikipedia.org/wiki/Median_of_medians">en</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25B2%25D1%258B%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0">ru</a> ). </li><li>  You can read about Quickselect <a href="http://en.wikipedia.org/wiki/Quickselect">here</a> and <a href="http://e-maxx.ru/algo/kth_order_statistics">here</a> . </li><li>  <a href="https://en.wikipedia.org/wiki/Akra%25E2%2580%2593Bazzi_method">Acra-Bazzi method</a> on wikipedia. </li><li>  Manual Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E. Tarjan.  <a href="http://people.csail.mit.edu/rivest/pubs/BFPRT73.pdf">Time Bounds for Selection</a> .  (pdf, eng) </li><li>  S.Battiato, D.Cantone, D.Catalano and G.Cincotti.  <a href="http://web.cs.wpi.edu/~hofri/medsel.pdf">An Efficient Algorithm for Approximate Median Selection Problem</a> .  (pdf, eng) - fast approximate probabilistic Median of Medians </li></ol></div><p>Source: <a href="https://habr.com/ru/post/247053/">https://habr.com/ru/post/247053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247039/index.html">How Iceland becomes a data center paradise</a></li>
<li><a href="../247041/index.html">VNC Roulette. Srsly?</a></li>
<li><a href="../247045/index.html">Plotter based on the Makeblock constructor</a></li>
<li><a href="../247047/index.html">C #: Internal structure of array initializers</a></li>
<li><a href="../247049/index.html">em-dosbox and 50 gifts for the new year</a></li>
<li><a href="../247055/index.html">Adventures Tyzh-programmer. New Year's Eve Mood Post</a></li>
<li><a href="../247057/index.html">Samsung Introduces SE790C - Ultra WQHD 34-inch Curved Monitor</a></li>
<li><a href="../247059/index.html">Drupal - choosing a business consultant</a></li>
<li><a href="../247071/index.html">Features and configuration of 3CX WebMeeting</a></li>
<li><a href="../247073/index.html">Expressive ReactJS or Type Angular features in our framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>