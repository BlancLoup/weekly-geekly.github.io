<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing formulas with functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 It took a little project. In the project analysis and calculation of mathematical formulas. 
 Requirements: nested functions, unlimited n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing formulas with functions</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  It took a little project.  In the project analysis and calculation of mathematical formulas. <br>  Requirements: nested functions, unlimited nesting depth and external variables. <br><br>  There are a lot of solutions on the Internet, but it's all wrong, or not.  Either without formulas, or without variables, or the simplest possibilities like "1+ (2-3) / 4".  But most of the answers were in the direction of lexical analysis and the reverse Polish notation.  Here I also applied them, taking examples from different sources. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, we analyze the lexical analysis.  Because a simple analysis of a formula by symbols with the search for functions, operators, variables, etc., would be extremely unreadable. <br><br>  The implementation of algorithms can be taken on the Internet and edited to fit your needs. <br><br>  For lexical analysis made small changes: <br><ul><li>  load variable list.  In the constructor, variables are replaced with their values; </li><li>  replacing separators of the whole fractional part of the number with the one used in the system; </li><li>  added unary minus; </li><li>  deleted unnecessary lexemes for me. </li></ul><br>  That's what happened.  Below is a link to the source. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">List of available tokens</b> <div class="spoiler_text"><pre><code class="hljs cmake">enum LexemType { Plus, Minus, Multiply, Divide, UnarMinus, Equals, NotEquals, <span class="hljs-keyword"><span class="hljs-keyword">Greater</span></span>, Lower, GreaterEquals, LowerEquals, <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Or</span></span>, LBracket, RBracket, Semicolon, Identifier, Number }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Definition of tokens</b> <div class="spoiler_text"><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexemDefinitions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticLexemDefinition[] Statics = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, LexemType.Plus), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"-"</span></span>, LexemType.Minus), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"*"</span></span>, LexemType.Multiply), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, LexemType.Divide), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"%"</span></span>, LexemType.UnarMinus), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"=="</span></span>, LexemType.Equals), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"!="</span></span>, LexemType.NotEquals), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, LexemType.GreaterEquals), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, LexemType.LowerEquals), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>, LexemType.Greater), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>, LexemType.Lower), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span>, LexemType.<span class="hljs-keyword"><span class="hljs-keyword">And</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"||"</span></span>, LexemType.<span class="hljs-keyword"><span class="hljs-keyword">Or</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"("</span></span>, LexemType.LBracket), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">")"</span></span>, LexemType.RBracket), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">";"</span></span>, LexemType.Semicolon), }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DynamicLexemDefinition[] Dynamics = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicLexemDefinition(<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_][a-zA-Z0-9_]*"</span></span>, LexemType.Identifier), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicLexemDefinition(@<span class="hljs-string"><span class="hljs-string">"([0-9]*\.?[0-9]+)"</span></span>, LexemType.Number), }; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Search and replace unary minus and plus</b> <div class="spoiler_text"><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ReplaceUnarOperator(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> src) { return Regex.<span class="hljs-built_in"><span class="hljs-built_in">Replace</span></span>(Regex.<span class="hljs-built_in"><span class="hljs-built_in">Replace</span></span>(Regex.<span class="hljs-built_in"><span class="hljs-built_in">Replace</span></span>(Regex.<span class="hljs-built_in"><span class="hljs-built_in">Replace</span></span>(src, @<span class="hljs-string"><span class="hljs-string">"(\(\+)"</span></span>, <span class="hljs-string"><span class="hljs-string">"("</span></span>), @<span class="hljs-string"><span class="hljs-string">"(\A[\+]{1})"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>), @<span class="hljs-string"><span class="hljs-string">"(\(-)"</span></span>, <span class="hljs-string"><span class="hljs-string">"(%"</span></span>), @<span class="hljs-string"><span class="hljs-string">"(\A[-]{1})"</span></span>, <span class="hljs-string"><span class="hljs-string">"%"</span></span>); }</code> </pre><br></div></div><br>  Replacing the unary plus and minus could have been more beautifully implemented, but the writing of regular expressions is not my talent.  I am pleased to use your option. <br><br>  Then he rewrote the implementation of the reverse Polish record taken from the wiki.  It was necessary to transfer to the input no longer a string but a list of tokens.  This fact slightly simplified the algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Conversion to HMO</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">private static Lexem[] ConvertToPostfixNotation(List&lt;Lexem&gt; _lexems) { List&lt;Lexem&gt; outputSeparated = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Lexem&gt;(); Stack&lt;Lexem&gt; stack = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Stack&lt;Lexem&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Lexem c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _lexems) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operators.Contains(c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> != LexemType.LBracket)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == LexemType.RBracket) { Lexem s = stack.Pop(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> != LexemType.LBracket) { outputSeparated.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(s); s = stack.Pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetPriority(c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) &gt; GetPriority(stack.Peek().<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { stack.Push(c); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; GetPriority(c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) &lt;= GetPriority(stack.Peek().<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) outputSeparated.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(stack.Pop()); stack.Push(c); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stack.Push(c); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> outputSeparated.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(c); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Lexem c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> stack) outputSeparated.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(c); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outputSeparated.ToArray(); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Calculation of HMO</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">private static String getResult(List&lt;Lexem&gt; _lexems) { Stack&lt;Lexem&gt; stack = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Stack&lt;Lexem&gt;(); Lexem[] postfix = ConvertToPostfixNotation(_lexems); Queue&lt;Lexem&gt; queue = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Queue&lt;Lexem&gt;(postfix); Lexem str = queue.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (queue.Count &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operators.Contains(str.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { Lexem result = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Lexem(); result.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = LexemType.Number; try { switch (str.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.UnarMinus: { <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (-a).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Plus: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (a + b).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Minus: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (a - b).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Multiply: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (a * b).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Divide: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (a / b).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Equals: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a == b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.NotEquals: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a != b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Greater: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a &gt; b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.GreaterEquals: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a &gt;= b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.Lower: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a &lt; b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.LowerEquals: { <span class="hljs-type"><span class="hljs-type">Double</span></span> b = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Double</span></span> a = Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a &lt;= b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.<span class="hljs-keyword"><span class="hljs-keyword">Or</span></span>: { <span class="hljs-type"><span class="hljs-type">Boolean</span></span> b = Convert.ToBoolean(Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> a = Convert.ToBoolean(Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a || b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LexemType.<span class="hljs-keyword"><span class="hljs-keyword">And</span></span>: { <span class="hljs-type"><span class="hljs-type">Boolean</span></span> b = Convert.ToBoolean(Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> a = Convert.ToBoolean(Convert.ToDouble(stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">Boolean</span></span> r = (a &amp;&amp; b); result.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = (r ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>).ToString(); break; } } } catch (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> ex) { <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InvalidOperationException(ex.Message); } stack.Push(result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) str = queue.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> break; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stack.Push(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { str = queue.Dequeue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> break; } } String rValue = stack.Pop().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rValue; }</code> </pre><br></div></div><br>  The peculiarity of logical operations is that if the number is greater than zero, then it becomes <b>True</b> , otherwise <b>False</b> . <br>  Actually, at this stage, the formulas are quite considered.  Support functions only not. <br><br>  At first, I wanted to implement functions through a separate token.  But something went wrong ... I took the path of least resistance.  In a lexical analysis of a formula, all variables that have been replaced by numeric values ‚Äã‚Äãbecome numbers, and everything else that has not been replaced becomes functions.  Not logical, but it works. <br><br>  Further, according to the algorithm, all our lexemes with the new functions are found and placed in the list of functions. <br><div class="spoiler">  <b class="spoiler_title">Function class implementation</b> <div class="spoiler_text"><pre> <code class="hljs php">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Functions&gt; FunctionList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Functions&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;&gt; operands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Functions(Queue&lt;Lexem&gt; queue) { Queue&lt;Lexem&gt; lexems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;Lexem&gt;(); Lexem currLextm = queue.Dequeue(); int brackets = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (queue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; brackets &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { currLextm = queue.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.Identifier) { currLextm.Value = currLextm.Value + <span class="hljs-string"><span class="hljs-string">"{"</span></span> + FunctionList.Count.ToString() + <span class="hljs-string"><span class="hljs-string">"}"</span></span>; lexems.Enqueue(currLextm); FunctionList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Functions(queue)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.LBracket) { brackets++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.RBracket) { brackets--; } lexems.Enqueue(currLextm); } } <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt; operand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lexems.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { currLextm = lexems.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.LBracket) { brackets++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.RBracket) { brackets--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currLextm.Type == LexemType.Semicolon)&amp;&amp;(brackets==<span class="hljs-number"><span class="hljs-number">0</span></span>)) { operands.Add(operand); operand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { operand.Add(currLextm); } } operand.Remove(operand.Last()); operands.Add(operand); } }</code> </pre><br></div></div><br><br>  The function may contain other functions.  Everything is entered into the operands of the function, and if a function is there, then a new function is recursively added to its list.  Of course, the depth of investment is not limited. <br><br>  Actually, the recursive algorithm for calculating the function values ‚Äã‚Äãand replacing it with the result: <br><div class="spoiler">  <b class="spoiler_title">Constructor and recursive replacement of a function by calculation results</b> <div class="spoiler_text"><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Int32, NTDClass&gt; NTDs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Int32, NTDClass&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;String, Double&gt; variables = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;string,double&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Functions&gt; FunctionList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Functions&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;&gt; operands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;LexemType&gt; operators = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;LexemType&gt;() { LexemType.Multiply, LexemType.Divide, LexemType.Plus, LexemType.Minus, LexemType.UnarMinus, LexemType.<span class="hljs-keyword"><span class="hljs-keyword">And</span></span>, LexemType.<span class="hljs-keyword"><span class="hljs-keyword">Or</span></span>, LexemType.Equals, LexemType.NotEquals, LexemType.Greater, LexemType.Lower, LexemType.GreaterEquals, LexemType.LowerEquals, LexemType.LBracket, LexemType.RBracket }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PostfixNotationExpression(String formula) { Queue&lt;Lexem&gt; queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;Lexem&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexer(formula, variables).Lexems); Lexem currLextm = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; Queue&lt;Lexem&gt; lexems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;Lexem&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (queue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { currLextm = queue.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.Identifier) { currLextm.Value = currLextm.Value + <span class="hljs-string"><span class="hljs-string">"{"</span></span> + FunctionList.Count.ToString() + <span class="hljs-string"><span class="hljs-string">"}"</span></span>; lexems.Enqueue(currLextm); FunctionList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Functions(queue)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lexems.Enqueue(currLextm); } } <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt; operand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;(); Int32 brackets = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lexems.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { currLextm = lexems.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.LBracket) { brackets++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currLextm.Type == LexemType.RBracket) { brackets--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currLextm.Type == LexemType.Semicolon) &amp;&amp; (brackets == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { operands.Add(operand); operand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { operand.Add(currLextm); } } operands.Add(operand); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String Calc() { String sep = NumberFormatInfo.CurrentInfo.NumberDecimalSeparator; String res = Calc(FunctionList, operands).First(); res = res == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-string"><span class="hljs-string">"0.0"</span></span> : res; res = res.Replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, sep).Replace(<span class="hljs-string"><span class="hljs-string">","</span></span>, sep); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;String&gt; Calc(<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Functions&gt; fList, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt;&gt; lOps) { <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;String&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fList.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt; op in lOps) { String resOp = getResult(op); res.Add(resOp); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Lexem&gt; op in lOps) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; op.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op[i].Type == LexemType.Identifier) { String fName = op[i].Value.Remove(op[i].Value.IndexOf(<span class="hljs-string"><span class="hljs-string">"{"</span></span>)); String fNumStr = op[i].Value.Remove(<span class="hljs-number"><span class="hljs-number">0</span></span>, op[i].Value.IndexOf(<span class="hljs-string"><span class="hljs-string">"{"</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>); fNumStr = fNumStr.Remove(fNumStr.IndexOf(<span class="hljs-string"><span class="hljs-string">"}"</span></span>)); Int32 fNum = Int32.Parse(fNumStr); Functions func = fList[fNum]; <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;String&gt; funcRes = Calc(func.FunctionList, func.operands); <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Double&gt; rList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;double&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; funcRes.Count; k++) { rList.Add(Double.Parse(funcRes[k])); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"NTD"</span></span>: { String val = <span class="hljs-string"><span class="hljs-string">"0.0"</span></span>; Int32 key = (Int32)rList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NTDs.ContainsKey(key)) { val = NTDs[key].getValue(rList[<span class="hljs-number"><span class="hljs-number">1</span></span>]).ToString(); } op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = val }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"If"</span></span>: { op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = (rList[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span> ? rList[<span class="hljs-number"><span class="hljs-number">1</span></span>] : rList[<span class="hljs-number"><span class="hljs-number">2</span></span>]).ToString() }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Sqr"</span></span>: { op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = (rList[<span class="hljs-number"><span class="hljs-number">0</span></span>] * rList[<span class="hljs-number"><span class="hljs-number">0</span></span>]).ToString() }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Sqrt"</span></span>: { op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = (Math.Sqrt(rList[<span class="hljs-number"><span class="hljs-number">0</span></span>])).ToString() }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Min"</span></span>: { Double Min = Double.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; rList.Count; k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rList[k] &lt; Min) { Min = rList[k]; } } op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = Min.ToString() }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Max"</span></span>: { Double Max = Double.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; rList.Count; k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rList[k] &gt; Max) { Max = rList[k]; } } op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem() { Type = LexemType.Number, Value = Max.ToString() }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } } String resOp = getResult(op); res.Add(resOp); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br></div></div><br>  All implemented functions are implemented here.  Add something of their own is not something difficult. <br><br>  For example, I will give a solution to the quadratic equation: <br><div class="spoiler">  <b class="spoiler_title">Calculation example</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;String, <span class="hljs-type"><span class="hljs-type">Double</span></span>&gt; variables = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;string, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>("a", <span class="hljs-number"><span class="hljs-number">1</span></span>); variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>("b", <span class="hljs-number"><span class="hljs-number">2</span></span>); variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>("c", <span class="hljs-number"><span class="hljs-number">-27</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var ivar <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variables) { textBox1.Text += ivar.Key + " = " + ivar.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.ToString() + "\r\n"; } textBox1.Text += "--------------\r\n"; // a*x2 + bx + c = <span class="hljs-number"><span class="hljs-number">0</span></span> String q1 = "(-b+Sqrt(Sqr(b)-4*a*c))/(2*a)"; String q2 = "(-b-Sqrt(Sqr(b)-4*a*c))/(2*a)"; String Formula = "If((b*b-4-ac)&gt;0;" + q1 + "; If((b*b-4-ac)==0; " + q2 + "; 0))"; textBox1.Text += Formula + "\r\n"; textBox1.Text += <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PostfixNotationExpression(Formula, variables).Calc() + "\r\n"; Formula = "If((b*b-4-ac)&gt;0;" + q2 + "; If((b*b-4-ac)==0; " + q1 + "; 0))"; textBox1.Text += Formula + "\r\n"; textBox1.Text += <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PostfixNotationExpression(Formula, variables).Calc() + "\r\n";</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output</b> <div class="spoiler_text"><pre> <code class="hljs perl">a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> c = -<span class="hljs-number"><span class="hljs-number">27</span></span> -------------- If((b*b-<span class="hljs-number"><span class="hljs-number">4</span></span>-ac)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>;(-b+Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(b)</span></span>-<span class="hljs-number"><span class="hljs-number">4</span></span>*a*c))/(<span class="hljs-number"><span class="hljs-number">2</span></span>*a); If((b*b-<span class="hljs-number"><span class="hljs-number">4</span></span>-ac)==<span class="hljs-number"><span class="hljs-number">0</span></span>; (-b-Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(b)</span></span>-<span class="hljs-number"><span class="hljs-number">4</span></span>*a*c))/(<span class="hljs-number"><span class="hljs-number">2</span></span>*a); <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-number"><span class="hljs-number">4.2915026221292</span></span> If((b*b-<span class="hljs-number"><span class="hljs-number">4</span></span>-ac)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>;(-b-Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(b)</span></span>-<span class="hljs-number"><span class="hljs-number">4</span></span>*a*c))/(<span class="hljs-number"><span class="hljs-number">2</span></span>*a); If((b*b-<span class="hljs-number"><span class="hljs-number">4</span></span>-ac)==<span class="hljs-number"><span class="hljs-number">0</span></span>; (-b+Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(b)</span></span>-<span class="hljs-number"><span class="hljs-number">4</span></span>*a*c))/(<span class="hljs-number"><span class="hljs-number">2</span></span>*a); <span class="hljs-number"><span class="hljs-number">0</span></span>)) -<span class="hljs-number"><span class="hljs-number">6.2915026221292</span></span></code> </pre><br></div></div><br><br>  Of course, solving quadratic equations is not a good example.  There is no possibility to get several answers in the results, and then if there are no roots, this formula will return zero.  But to demonstrate the possibilities will go. <br><br>  [ <a href="http://1drv.ms/1vdKf5v">Link to project</a> ] <br><br>  The project has enough space for optimization.  For example, there is a duplicate code and the results of all branches of the condition are calculated.  And you never know what can be optimized.  The main thing is to stop in time. <br><br>  PS: While writing, added a function to get values ‚Äã‚Äãfrom the graph. <br><br><div class="spoiler">  <b class="spoiler_title">Graph function</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> NTDClass { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> String <span class="hljs-type"><span class="hljs-type">Name</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>&gt; Graph; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> NTDClass(String <span class="hljs-type"><span class="hljs-type">name</span></span>, DataTable <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) { Graph = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(DataRow <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>.AsEnumerable()) { <span class="hljs-type"><span class="hljs-type">Double</span></span> x = <span class="hljs-type"><span class="hljs-type">Double</span></span>.Parse(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>["Id"].ToString()); <span class="hljs-type"><span class="hljs-type">Double</span></span> y = <span class="hljs-type"><span class="hljs-type">Double</span></span>.Parse(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>["VALUE"].ToString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Graph.ContainsKey(x)) { Graph.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(x, y); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x += <span class="hljs-number"><span class="hljs-number">0.00001</span></span>; Graph.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(x, y); } } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> getValue(<span class="hljs-type"><span class="hljs-type">Double</span></span> b) { <span class="hljs-type"><span class="hljs-type">Double</span></span> res = <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>; var xScale = Graph.Keys.AsEnumerable(); <span class="hljs-type"><span class="hljs-type">Double</span></span> minX = xScale.OrderBy(x =&gt; x).<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x &lt;= b).DefaultIfEmpty(xScale.OrderBy(x =&gt; x).First()).LastOrDefault(); <span class="hljs-type"><span class="hljs-type">Double</span></span> maxX = xScale.OrderBy(x =&gt; x).<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x &gt;= b).DefaultIfEmpty(xScale.OrderBy(x =&gt; x).Last()).FirstOrDefault(); <span class="hljs-type"><span class="hljs-type">Double</span></span> minY = Graph[minX]; <span class="hljs-type"><span class="hljs-type">Double</span></span> maxY = Graph[maxX]; res = (((b - minX) * (maxY - minY)) / (maxX - minX) + minY); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Function call</b> <div class="spoiler_text"><pre> <code class="hljs scala">switch (fName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"NTD"</span></span>: { <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-string"><span class="hljs-string">"0.0"</span></span>; <span class="hljs-type"><span class="hljs-type">Int32</span></span> key = (<span class="hljs-type"><span class="hljs-type">Int32</span></span>)rList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">NTDs</span></span>.<span class="hljs-type"><span class="hljs-type">ContainsKey</span></span>(key)) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-type"><span class="hljs-type">NTDs</span></span>[key].getValue(rList[<span class="hljs-number"><span class="hljs-number">1</span></span>]).<span class="hljs-type"><span class="hljs-type">ToString</span></span>(); } op[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Lexem</span></span>() { <span class="hljs-type"><span class="hljs-type">Type</span></span> = <span class="hljs-type"><span class="hljs-type">LexemType</span></span>.<span class="hljs-type"><span class="hljs-type">Number</span></span>, <span class="hljs-type"><span class="hljs-type">Value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ..... ..... .....</code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/246707/">https://habr.com/ru/post/246707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246695/index.html">Vulnerabilities PayPal accounts, fraud refund transactions, hacking account</a></li>
<li><a href="../246697/index.html">AWS and edX offer $ 1000 for completing online course</a></li>
<li><a href="../246699/index.html">Designing a RESTful API with Python and Flask</a></li>
<li><a href="../246701/index.html">The first interview, or Why get a job is more difficult than passing an exam</a></li>
<li><a href="../246703/index.html">Development of Magento modules with application deployment through Magento Composer</a></li>
<li><a href="../246709/index.html">How to disable updates in Skype and advertising at the same time</a></li>
<li><a href="../246711/index.html">Named C ++ Parameters. Not useful</a></li>
<li><a href="../246713/index.html">Registration of offshore company in Belize</a></li>
<li><a href="../246717/index.html">Christmas tales engineer post</a></li>
<li><a href="../246719/index.html">InterSystems iKnow. We load data from VKontakte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>