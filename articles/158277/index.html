<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Paradigms of programming. Data Driven vs Domain Driven</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Information technologies are developing in leaps and bounds, new devices, platforms, operating systems are emerging, and with it the range of tasks th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Paradigms of programming. Data Driven vs Domain Driven</h1><div class="post__text post__text-html js-mediator-article">  Information technologies are developing in leaps and bounds, new devices, platforms, operating systems are emerging, and with it the range of tasks that developers have to solve grows.  But, not everything is so bad - new development tools, ide'shiki, new programming languages, methodologies, etc. are rushing to help programmers.  The <a href="http://en.wikipedia.org/wiki/Programming_paradigm">list of programming paradigms</a> alone is impressive, and taking into account modern multi-paradigm PL (for example, C #), the question is reasonable: ‚ÄúHow to deal with all this?  What to choose?". <br><br>  Let's try to understand a little. <br><a name="habracut"></a><br><h4>  Where did so many paradigms come from? </h4><br>  In fact, the answer has already sounded in this post - different types of tasks are easier and faster to solve using the appropriate paradigms.  Accordingly, with the development of IT, new types of tasks appeared (or old ones became relevant), and solving them using the old approaches was inconvenient, which entailed rethinking and the emergence of new techniques. <br><br><h4>  What to choose? </h4><br>  It all depends on what needs to be done.  It is worth noting that all development tools are different, some support one, others support another.  For example, PHP with a ‚Äústandard‚Äù set of modules does not support <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">aspect-oriented programming</a> .  Therefore, the choice of methodology is quite closely related to the development platform.  Well, and do not forget that you can combine different approaches, which leads us to the choice of a stack of paradigms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To categorize paradigms, I use 4 dimensions that are inherent in almost any task: <br><ul><li>  <i>Data</i> <br>  Any program, anyway, works with data: stores them, processes, analyzes, transfers <br></li><li>  <i>Actions</i> <br>  Any program should do something, usually actions are data related. <br></li><li>  <i>Logic</i> . <br>  Logic or business logic defines the rules by which data and actions are subject.  Without logic, the program is meaningless. </li><li>  <i>Interface</i> . <br>  How the program interacts with the outside world <br></li></ul><br><br>  You can go further and delve into this idea: come up with qualitative characteristics for these four measures, add strict rules and a bit of mathematics, but this is perhaps a topic for a separate post.  I think most system architects define these characteristics for a specific task based on their knowledge and experience. <br><br>  After you analyze your task on these 4 dimensions, you will most likely see that a certain dimension is more pronounced than the rest.  And this, in turn, will make it possible to determine the programming paradigm, since they are usually aimed at a single dimension. <br><br>  Consider examples: <br><ul><li>  <a href="http://en.wikipedia.org/wiki/Data-driven_programming">Data Driven Design</a> ( <a href="http://en.wikipedia.org/wiki/Data-driven_programming">Data Driven Design</a> ). We are primarily concerned with data, and not with how they are interconnected. <br>  Types of suitable applications: <br><ul><li>  grabbers (collect data from various sources, save somewhere) </li><li>  various admins, database interfaces, all where there are a lot of simple CRUD operations </li><li>  cases when work with data is already defined, for example, a program is required to be developed, a database already exists and a data scheme is not changed.  In this case, it is probably easier to focus on what is already there than to create additional wrappers over data and data access levels. </li><li>  often data orientation appears when using ORM, but it is impossible to say in advance whether this is good or bad (more on this below) </li></ul><br></li><li>  Orientation to actions - imperative approaches to development.  I think that such paradigms as <a href="http://en.wikipedia.org/wiki/Event-driven_programming">Event Driven Programming</a> , Aspect Oriented Programming can be included here. </li><li>  Logic Orientation - <a href="http://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> (DDD) and everything connected with it.  Here the subject area of ‚Äã‚Äãthe problem is important to us, we pay attention to the modeling of objects, the analysis of relationships and dependencies.  Used primarily in business applications. <br>  Also, this includes a declarative approach and partly functional programming (solving problems that are well described by mathematical formulas) </li><li>  Interface orientation.  It is used when it is primarily important how the program interacts with the outside world. <br>  Developing an application with an interface-only focus is a rather rare situation.  Although in some books I met the mention that this approach was considered seriously, and based on the user interface - they took what the user sees directly and, based on this, designed the data structures and everything else. <br>  Orientation to the user interface in business applications often manifests itself indirectly: for example, the user needs to see certain data that is difficult to obtain, due to which the architecture acquires additional structures (for example, forced data redundancy). <br>  Formally, this includes Event Driven Programming </li></ul><br><br><h4>  And what in practice? </h4><br>  In our company, we are developing business applications (startups, web services, websites, application programs, etc.), so we‚Äôll talk further about programming paradigms that are found both in our practice and in other teams working in this field. <br><br>  Based on my experience, I can say that in this area two approaches prevail: data orientation (Data Driven) and logic orientation (Domain Driven).  In fact, they are competing methodologies, but in practice they can be combined in symbiosis, which are often known anti-patterns. <br><br>  One of the advantages of Data Driven compared to Domain Driven is its ease of use and implementation.  Therefore, Data Drivens begin to be used wherever you need to apply Domain Driven (and often this happens unconsciously).  The problems arise from the fact that Data Driven is poorly compatible with the concepts of object-oriented programming (of course, if you use OOP at all).  On small applications, these problems are almost imperceptible.  On medium-sized applications, these problems are already noticeable and are beginning to lead to anti-patterns, well, and on large projects, the problems become serious and require appropriate measures. <br><br>  In turn, Domain Driven is advantageous on large projects, and on small projects it complicates the solution and requires more resources for development, which is often critical from the business point of view (bring the project to the asap market, for a small budget). <br><br>  In order to understand the difference in approaches, we consider a more specific example.  Suppose we need to develop an order accounting system.  We have such entities as: <br><ul><li>  Product </li><li>  Customer </li><li>  Quota (sent to the customer as an offer) </li><li>  Order (order) </li><li>  Invoice (payment) </li><li>  Warrant supplier </li><li>  Bill (in fact, the payment from the supplier) </li></ul><br><br>  Having decided that we have a clear context, we begin to design a database.  We create the corresponding tables, run the ORM, generate the entity classes (well, or in the case of the smart orm, we prescribe the scheme somewhere separately, for example, in xml, and already generate the base and the essence classes from it).  As a result, we obtain for each entity a separate, independent class.  We rejoice in life, work with objects is easy and simple. <br><br>  Time passes, and we need to add additional logic to the program - for example, to find the goods with the highest price from the order.  There may already be problems if your orm does not support external relations (i.e., entity classes do not know anything about the data context), in this case, you will have to create a service in which there will be a method - to return the required product on an order.  But, our orm is good, can work with external relations, and we simply add a method to the order class.  We enjoy life again, the goal has been achieved, a method has been added to the class, we have almost the real PLO. <br><br>  Time passes, and we need to add the same method for the quota, for the invoice and for other similar entities.  What to do?  We can simply register this method in all classes, but this will, in fact, duplicate code and backfire with support and testing.  We do not want to complicate and simply copy the method to all classes.  Then similar methods appear, the entity classes begin to swell with the same code. <br><br>  Time passes, and logic appears, which cannot be described by external links in the database, and therefore it is not possible to place it in the essential classes.  We are starting to create services that perform these functions.  As a result, we find that the business logic is scattered throughout the essential classes and services; it is becoming increasingly difficult to understand where to look for the desired method.  We decide to refactor and render, for example, repetitive code to services ‚Äî select the general functionality of the interface (for example, we make the interface IProductable, that is, something that contains products), services can work with these interfaces, thereby winning a little in abstraction.  But fundamentally this does not solve the problem, we get more methods in services and decide for the unity of the picture to transfer all the methods from the essential classes to the services.  Now we know where to look for methods, but our essential classes are deprived of all logic, and we got the so-called ‚ÄúAnemic Model‚Äù (Anemic Model). <br><br>  At this stage, we completely left the concept of OOP - objects store only data, all logic is in separate classes, neither encapsulation nor inheritance. <br><br>  It is worth noting that this is not as bad as it may seem - nothing prevents to introduce unit testing, and indeed development through testing, implement dependency management patterns, etc., in general, you can live with it.  Problems will arise when the application grows into a large one, when there are so many entities that it is impossible to keep them in mind, and there is no need to talk about interaction.  In this case, the support and development of such an application will become a problem. <br><br>  As you may have guessed, this scenario describes the use of the Data Driven approach and its problems. <br>  In the case of Domain Driven, we would do the following.  First, about any design of the database at the first stage of speech would not go.  We would need to carefully analyze the contextual area of ‚Äã‚Äãthe problem, model it and transfer it to the PLO language. <br><br>  For example, we can create an abstract document model that has a set of basic properties.  Inherit from it a document that has products, inherit a ‚Äúpayment‚Äù document from it, with a price and billing address, and so on.  With this approach, add a method that gets the most expensive product, it is easy - we just add it to the appropriate base class. <br><br>  As a result, the contextual area of ‚Äã‚Äãthe task will be described using OOP to its fullest. <br>  But there are obvious problems: how to save data in the database?  Actually, for this, you will need to create functionality for mepping data from our models onto fields in the database.  Such meppers can be quite complex, and as models change, meppers will have to be changed. <br><br>  Moreover, you are not insured against modeling errors, which can lead to complex refactoring. <br><br>  So, let's summarize the Data Driven vs Domain Driven: <br>  <b>Data Driven</b> : <br><ul><li>  pros <br><ul><li>  Allows you to quickly develop an application or prototype </li><li>  It is convenient to design (code generation according to the scheme, etc.) </li><li>  On small or medium-sized projects, it may be quite a solution. </li></ul><br></li><li>  Minuses <br><ul><li>  May lead to anti-patterns and avoiding OOP </li><li>  On large projects leads to chaos, complex support, etc. </li></ul><br></li></ul><br><br>  <b>Domain Driven:</b> <br><ul><li>  pros <br><ul><li>  Uses the power of OOP </li><li>  Allows you to control the complexity of the context area (domain) </li><li>  There are a number of advantages not described in the article, for example, the creation of a domain language and the introduction of BDD. </li><li>  Gives a powerful tool for developing complex and large solutions. </li></ul><br></li><li>  Minuses <br><ul><li>  It requires significantly more resources in the development, which increases the cost of solutions </li><li>  Certain parts become more difficult to maintain (data mappers, etc.) </li></ul><br></li></ul><br><br><h4>  So, what the hell should I choose? </h4><br>  Unfortunately, there is no definite answer.  Analyze your problem, your resources, development prospects, goals and objectives.  The right choice is always a compromise. </div><p>Source: <a href="https://habr.com/ru/post/158277/">https://habr.com/ru/post/158277/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../158265/index.html">Automatic gearbox for bike on iPhone</a></li>
<li><a href="../158267/index.html">"Virtual" keyboard for iPhone from a sheet of paper, a table and an application</a></li>
<li><a href="../158269/index.html">Experience and knowledge are the basis of any assessment.</a></li>
<li><a href="../158273/index.html">Theory of radio waves: antennas</a></li>
<li><a href="../158275/index.html">Matrix printing technology</a></li>
<li><a href="../158283/index.html">Recovering virtual machines from SAN snapshots using Veeam Backup & Replication</a></li>
<li><a href="../158285/index.html">Crossposting from Twitter to VKontakte using a router</a></li>
<li><a href="../158287/index.html">Developer Contest: integrate the application with Evernote and please the first users with premium subscriptions</a></li>
<li><a href="../158291/index.html">Do you need a service to find information about the training being held to develop business skills (webinars, offline, online), or the possibility of training online?</a></li>
<li><a href="../158293/index.html">Mobile Developer & Business Day Russia in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>