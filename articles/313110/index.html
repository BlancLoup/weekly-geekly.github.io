<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we tried DDD, CQRS and Event Sourcing and what conclusions did</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For about three years now I have been using the principles of Spec By Example , Domain Driven Design and CQRS . During this time, the experience of pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we tried DDD, CQRS and Event Sourcing and what conclusions did</h1><div class="post__text post__text-html js-mediator-article">  For about three years now I have been using the principles of <a href="https://habrahabr.ru/post/166747/">Spec By Example</a> , <a href="https://habrahabr.ru/post/259829/">Domain Driven Design and CQRS</a> .  During this time, the experience of practical application of these practices on the .NET platform has been gained.  In the article I want to share our experience and conclusions that can be useful to teams wishing to use these approaches in the design. <br><img src="https://habrastorage.org/files/115/c67/b98/115c67b98085429792f0fe18383b136b.png"><br><a name="habracut"></a><br><h2>  DDD.  findings </h2><br><ol><li>  Very expensive </li><li>  Works well in established business processes. </li><li>  Sometimes it's the only way to do the right thing. </li><li>  Badly scaled </li><li>  Difficult to implement in high load applications </li><li>  It works poorly in startups </li><li>  Not suitable for building reports </li><li>  Requires special attention with ORM </li><li>  Entity words are best avoided because everyone understands it in their own way. </li><li>  With LINQ, the standard implementation of the Specification "does not work" </li></ol><br><h3>  Very expensive </h3><br>  All development managers using DDD, with whom I discussed the topic, noted the ‚Äúhigh cost‚Äù of this methodology, primarily due to the lack of answers to practical questions ‚Äúhow do I do FooBar without violating DDD principles in the Evans book?‚Äù. <br><br>  The most common question in the Google CQRS group is Greg Young: ‚ÄúThe boss asks me to build an annual report.  When I raise all the roots of the aggregation in memory, everything starts to slow down.  What should I do?".  There is an obvious answer to this question: ‚Äúyou need to write a SQL query‚Äù.  However, writing a manual SQL query is definitely against the DDD rules. <br><br>  Evans himself agreed with Young that the book should have been written in a different order.  The key concepts are the <b>Bounded Context</b> and <b>Ubiquitous Language</b> , not <b>Entity</b> and <b>ValueObject</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Reports do not need a domain model.  A report is simply a table with data.  Data Driven - much better suited for reporting than Domain Driven.  At first glance, at this moment DDD sucks should be said.  However, it is not.  Simply using DDD to build reports is not the correct Bounded Context. <br><br><h3>  Bounded context </h3><br><ol><li>  <a href="http://martinfowler.com/bliki/BoundedContext.html">Fowler in English</a> </li><li>  <a href="https://habrahabr.ru/post/232881/">My stuff is in Russian</a> </li></ol><br>  The most important thesis of DDD is not to try to develop one large domain model for the entire application.  It is too complicated and no one needs.  It is possible to create one domain model for the entire application only if it is decided at the company management level that all departments use the same terminology and understand all business processes in the same way. <br><br><h3>  Entity everyone understands their own way </h3><br>  We made sure that it is very difficult to reach an agreement with all members of the team on terminology.  The term <i>Entity</i> became a stumbling block: we tried to use the <i>IEntity &lt;TKey&gt;</i> interface, but we quickly realized that Id could also use <i>ValueObjects</i> to send commands.  Using <i>IEntity &lt;TKey&gt;</i> for such objects confused people, and we abandoned <i>IEntity</i> in favor of <i>IHasId</i> . <br><br><h3>  DDD requires special attention with ORM </h3><br>  There are quite a few NHibernate vs Entity Framework for DDD discussions on Stack Overflow.  NHibernate, on the whole, does better, but there are still a lot of problems.  The standard approach for using ORM is to use parameterless constructors and set values ‚Äã‚Äãthrough property setters.  This is a break encapsulation.  There are certain problems with collections and Lazy Load.  In addition, the team must decide where the ‚Äúdomain‚Äù ends and the ‚Äúinfrastructure‚Äù begins and how to ensure Persistence Ignorance. <br><br><h3>  With LINQ, the standard implementation of the Specification "does not work" </h3><br>  Evans is a man from the world of Java.  In addition, the book was written a long time ago. <br><br><pre><code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Specification</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T entity)</span></span></span><span class="hljs-function"> }</span></span>;</code> </pre> <br>  This interface allows you to work with collections in memory, but not suitable for building SQL queries.  In modern C #, <a href="https://nblumhardt.com/archives/implementing-the-specification-pattern-via-linq/">this option is</a> more suitable: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Specification</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SatisfyingElementsFrom(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { item }.AsQueryable()).Any(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SatisfyingElementsFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IQueryable&lt;T&gt; candidates)</span></span></span></span>; }</code> </pre><br><h3>  Application area </h3><br>  Domain modeling is not an easy task.  DDD involves delegating some of the tasks for analytics to developers.  This is justified in cases where the cost of the error is high.  It doesn‚Äôt matter how quickly you write the code and how fast your system works, if it doesn‚Äôt work correctly and you lose money.  Actually, the opposite is true - if you develop software for HFT and do not fully understand how it should work, it is better that your software slows down or does not work at all.  So you will at least not lose money on super-fast, but not correct trading :) <br><br>  In unsustainable businesses (especially startups) there is often no understanding of the subject model.  Everything can change daily.  Under these conditions, it is useless to require business process participants to use common terminology. <br><br><h2>  CQRS </h2><br>  The conclusion is obvious: DDD is not a ‚Äúsilver bullet‚Äù, but it's a pity :) However, you can get a significant gain due to the ‚Äúpoint application‚Äù of DDD in certain <i>Bounded Context</i> . <br><br>  In 1980, Bertrand Meyer coined the very simple term CQS.  At the beginning of the two thousandth, Greg Young expanded and popularized this concept.  So CQRS appeared ... and CQRS in many respects repeated the fate of the DDD, in the sense that it was repeatedly not correctly interpreted. <br><br>  Despite the fact that there are plenty of materials on the CQRS on the Internet, everyone ‚Äúprepares‚Äù it differently.  Many teams use the principles of CQRS, although they do not call it that.  The system may not have <i>Command</i> and <i>Query</i> abstractions.  They can be replaced by <i>IOperation</i> or even <i>Func &lt;T1, T2&gt;</i> and <i>Action &lt;T&gt;</i> . <br><br>  This is a simple explanation.  The first results for the CQRS query produce something like the image below: <br><br><img src="https://habrastorage.org/files/ca1/db7/b1b/ca1db7b1bb664a439141cddacbd3344e.PNG"><br><br>  This implementation Dino Esposito <a href="https://www.youtube.com/watch%3Fv%3DCrBi33fpFh4">calls DELUXE</a> .  The point here is that GQ Young is interested in CQRS mainly <a href="https://www.youtube.com/watch%3Fv%3DLDW0QWie21s">in the context of Event Sourcing</a> .  In fact, you must use CQRS for Event Sourcing, but not vice versa. <br><br><img src="https://habrastorage.org/files/c34/399/d5a/c34399d5a21b481788efa1330e010242.png"><br><br>  Thus, using CQRS, we can solve the problem of brake reports by dividing application stacks by Read and Write and without using the Domain Model in the Read stack.  A read stack <b>can</b> use another database and / or another more optimal data access API. <br><br>  Splitting the application into commands, handlers, and requests has another advantage: better predictability.  In the case of DDD, in order to know where to look for this or that business logic, you need to understand the subject area.  In the case of CQRS, the programmer always knows that the recording takes place in command handlers, and Query is used to access the data.  In addition, there are still some not obvious, at first glance, advantages.  We will look at them below. <br><br><h2>  CQRS main findings </h2><br><ol><li>  Event Sourcing requires CQRS, but not vice versa. </li><li>  Cheap </li><li>  Fits everywhere </li><li>  Scaled </li><li>  Does not require 2 data stores.  This is one of the possible implementations, but not an obligation. </li><li>  The command handler may return a value.  If you do not agree, argue with <a href="https://www.youtube.com/watch%3Fv%3DLDW0QWie21s">Greg Young</a> and Dino Esposito, but not with me </li><li>  If the handler returns a value, it is worse scaled, but there is async / await, but you need to understand how they work </li></ol><br>  The main interfaces in CQRS might <a href="https://github.com/hightechtoday/costeffectivecode/tree/master/src/CostEffectiveCode/Cqrs">look like this</a> : <br><br><pre> <code class="hljs kotlin"> [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out TOutput</span></span></span><span class="hljs-class">&gt; </span></span>{ TOutput Ask(); } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TSpecification, out TOutput</span></span></span><span class="hljs-class">&gt; </span></span>{ TOutput Ask([NotNull] TSpecification spec); } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAsyncQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TOutput</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task&lt;TOutput</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAsyncQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TSpecification, TOutput</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IQuery</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TSpecification, Task&lt;TOutput</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TInput</span></span></span><span class="hljs-class">&gt; </span></span>{ void Handle(TInput input); } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TInput, out TOutput</span></span></span><span class="hljs-class">&gt; </span></span>{ TOutput Handle(TInput input); } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAsyncCommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TInput</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ICommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TInput, Task</span></span></span><span class="hljs-class">&gt; </span></span>{ } [PublicAPI] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAsyncCommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in TInput, TOutput</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ICommandHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TInput, Task&lt;TOutput</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ }</code> </pre><br>  We have agreed that: <br><br><ol><li>  Query always only receives data, but does not change the state of the system.  To change the system, use the commands </li><li>  Query can return the necessary projections to the line, bypassing the domain model </li></ol><br>  In this case, <b>in the absence of commands, all Query always return the same results on the same input data</b> .  Such an organization greatly simplifies debugging, because Query does not have a state that could change the return result. <br><br>  If necessary, Audit Log or full-fledged Event Sourcing can be connected to all command handlers via the base class. <br><blockquote><img src="https://habrastorage.org/files/a7c/750/269/a7c750269834465d9ba877bf695cb1d3.png" align="right">  It's not hard to see that the main CQRS interfaces can be brought to <i>Func &lt;T1, T2&gt;</i> and <i>Action &lt;T&gt;</i> .  Add stateless and immutable, and you will get <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">pure functions</a> (hello functional programming;) Strictly speaking, this is certainly not the case, because most of the Query will work with the file system, database or network.  You also probably want to cache the results of the Query, but you can get the benefit from the linearization of data-flow and composability. </blockquote><br><h3>  CQRS over HTTP </h3><br>  CQRS principles are very well suited for HTTP protocol implementation.  The HTTP specification clearly says GET requests should return data from the server.  POST, PUT, PATCH - change the state.  A good practice in web programming is to redirect to GET after performing a POST operation, for example, submitting a form. <br><br><h3>  so </h3><br><ol><li>  GET is Query </li><li>  POST / PUT / PATCH / DELETE - this is Command </li></ol><br><h3>  Base Classes for Commonly Used Operations </h3><br>  Reports are not the only frequent data reading task.  A more general definition of typical read operations is: <br><br><ol><li>  Filtration </li><li>  Pagination (paginated) </li><li>  Creation of projections (representation of aggregates in the form required on the client side) </li></ol><br>  We actively use <a href="http://automapper.org/">AutoMapper</a> to build projections.  One of the distinguishing features of this mapper are <a href="https://github.com/AutoMapper/AutoMapper/wiki/Queryable-Extensions">Queryable-Extensions</a> : the ability to build an Expression for conversion to SQL, instead of mapping in RAM.  These projections are not always accurate and productive, but they are ideal for rapid prototyping. <br><br>  For paginal output from any table in the database and filtering support, you can use just <a href="">one implementation of IQuery</a> . <br><br><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ProjectionQuery&lt;TSpecification, TSource, TDest&gt; : IQuery&lt;TSpecification, IEnumerable&lt;TDest&gt;&gt; , IQuery&lt;TSpecification, <span class="hljs-type"><span class="hljs-type">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TSource : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, IHasId <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TDest : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { protected readonly ILinqProvider LinqProvider; protected readonly IProjector Projector; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ProjectionQuery([<span class="hljs-keyword"><span class="hljs-keyword">NotNull</span></span>] ILinqProvider linqProvier, [<span class="hljs-keyword"><span class="hljs-keyword">NotNull</span></span>] IProjector projector) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (linqProvier == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException(nameof(linqProvier)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (projector == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException(nameof(projector)); LinqProvider = linqProvier; Projector = projector; } protected virtual IQueryable&lt;TDest&gt; GetQueryable(TSpecification spec) =&gt; LinqProvider .GetQueryable&lt;TSource&gt;() .ApplyIfPossible(spec) .Project&lt;TSource, TDest&gt;(Projector) .ApplyIfPossible(spec); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual IEnumerable&lt;TDest&gt; Ask(TSpecification specification) =&gt; GetQueryable(specification).ToArray(); <span class="hljs-type"><span class="hljs-type">int</span></span> IQuery&lt;TSpecification, <span class="hljs-type"><span class="hljs-type">int</span></span>&gt;.Ask(TSpecification specification) =&gt; GetQueryable(specification).Count(); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagedQuery&lt;TSortKey, TSpec, TEntity, TDto&gt; : ProjectionQuery&lt;TSpec, TEntity, TDto&gt;, IQuery&lt;TSpec, IPagedEnumerable&lt;TDto&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, IHasId <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TDto : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, IHasId <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TSpec : IPaging&lt;TDto, TSortKey&gt; { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagedQuery(ILinqProvider linqProvier, IProjector projector) : base(linqProvier, projector) { } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override IEnumerable&lt;TDto&gt; Ask(TSpec spec) =&gt; GetQueryable(spec).Paginate(spec).ToArray(); IPagedEnumerable&lt;TDto&gt; IQuery&lt;TSpec, IPagedEnumerable&lt;TDto&gt;&gt;.Ask(TSpec spec) =&gt; GetQueryable(spec).ToPagedEnumerable(spec); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IQuery&lt;TSpec, IPagedEnumerable&lt;TDto&gt;&gt; AsPaged() =&gt; this <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IQuery&lt;TSpec, IPagedEnumerable&lt;TDto&gt;&gt;; }</code> </pre><br>  The <i>ApplyIfPossible</i> method <i>will</i> check <i>whether</i> filtering is performed at the level of the aggregate or projection (sometimes it is necessary both <i>ways</i> ).  The Project method will create a projection using AutoMapper. <br><br>  <a href="">AutoFilter</a> and Dynamic Linq can help if you work with a large number of uniform forms. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AutoFilterExtensions { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static IQueryable&lt;T&gt; ApplyDictionary&lt;T&gt;(this IQueryable&lt;T&gt; query , IDictionary&lt;string, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; filters) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var kv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filters) { query = query.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(kv.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> string ? $"{kv.Key}.StartsWith(@0)" : $"{kv.Key}=@0", kv.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return query</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static IDictionary&lt;string, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; GetFilters(this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o) =&gt; o.GetType() .GetTypeInfo() .GetProperties(BindingFlags.<span class="hljs-built_in"><span class="hljs-built_in">Public</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x.CanRead) .ToDictionary(k =&gt; k.Name, v =&gt; v.GetValue(o)); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AutoFilter&lt;T&gt; : ILinqSpecification&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IDictionary&lt;string, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AutoFilter() { <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;string, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AutoFilter([<span class="hljs-keyword"><span class="hljs-keyword">NotNull</span></span>] IDictionary&lt;string, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException(nameof(<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IQueryable&lt;T&gt; Apply(IQueryable&lt;T&gt; query) =&gt; query.ApplyDictionary(<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>); }</code> </pre><br>  To build aggregates from create / edit commands, you can use a generic <a href="https://habrahabr.ru/post/307378/">TypeConverter</a> . <br><br>  In order to simplify the registration in the container, you can <a href="">use the agreement</a> . <br><br><h2>  Conclusion </h2><br>  We actively use CQRS without Event Sourcing at work and so far the impressions are very good. <br><br><ol><li>  It's easier to test the code, because the classes are small and guaranteed to answer for only one thing. </li><li>  For the same reason, making changes to the system is simplified. </li><li>  Simplified communication, the debate about where a particular code should be.  The code of different team members has become uniform. </li><li>  DDD is used for initial system modeling and aggregation.  Aggregates may not be instantiated at all if all methods above the corresponding table are rigidly optimized (implemented to bypass the ORM) </li><li>  Event sourcing in full banana - implementation has never been required, Audit Log is implemented quite often. </li></ol><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/313110/">https://habr.com/ru/post/313110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313100/index.html">Testing EnGenius ezMaster Solution</a></li>
<li><a href="../313102/index.html">According to Rambler.iOS # 8</a></li>
<li><a href="../313104/index.html">Quality control code in the future development of the project</a></li>
<li><a href="../313106/index.html">5 best reports at the MBLTdev mobile developers conference 15</a></li>
<li><a href="../313108/index.html">Pro friendship boa with an elephant, or our experience of integrating Bitrix24 with Cisco telephony</a></li>
<li><a href="../313112/index.html">The peaceful profession of bomb shelter</a></li>
<li><a href="../313114/index.html">Top 5 Threats to Online Gaming Users</a></li>
<li><a href="../313116/index.html">A simple class for building lines of the level of a two-dimensional grid function</a></li>
<li><a href="../313118/index.html">Introduction to Labtech - we automate the work of a system administrator</a></li>
<li><a href="../313120/index.html">Google Opens Source Code for Nomulus - Top-Level Cloud Domain Management Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>