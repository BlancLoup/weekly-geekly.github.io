<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Garbage collector in the .NET environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Great and terrible habrazhiteli! 
 As I recently learned, not many people know how the garbage collector works. Although I understand that 99% ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Garbage collector in the .NET environment</h1><div class="post__text post__text-html js-mediator-article">  Hello, Great and terrible habrazhiteli! <br>  As I recently learned, not many people know how the garbage collector works.  Although I understand that 99% of developers do not really need this, but I would like everyone who develops applications on .NET to know how it works.  In this article I will try to briefly describe how <b>the garbage collector</b> actually works. <br><br><h4>  Basic information about the lifetime of the object </h4><br>  As you know, when initializing an object in memory, it allocates the right place for an object.  Using the <b>new</b> keyword results in adding a class object to the so-called <b>managed heap</b> , and a reference to the object is returned. <br>  When creating C # applications, you can safely assume that the .NET runtime will take care of the <i>management heap itself</i> without direct intervention from the programmer.  In fact, the ‚Äú <s>golden</s> rule‚Äù of memory management is: <br><blockquote>  Place the object in the control heap using the <b>new</b> keyword and forget about it. </blockquote><br><a name="habracut"></a><br>  After creation, the object will be automatically deleted by the garbage collector when it is no longer needed.  The question immediately arises of how the garbage collector determines when the object is not needed? <br><br>  Let's look at a simple example: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeACar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  myCar      // Car,      //   Car **  . Car myCar = new Car(); ... }</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Note that the reference to the Car object (myCar) was created directly inside the MakeACar () method and was not passed outside of the defining scope (neither as a return value, nor as a ref / out parameter).  Therefore, after calling the method, the reference to myCar will be unreachable, and the Car object will be a candidate for removal <i>by the garbage collector</i> .  However, it should be understood that there is no guarantee that the object will be deleted immediately after the execution of the MakeACar () method.  All that can be assumed at the moment is that when the garbage collection is performed in the CLR environment the next time, the myCar object will be <b>set</b> for deletion. <br><br>  C ++ programmers are well aware that unless they deliberately take care of deleting objects located in a heap, <b>memory leaks</b> will soon appear.  In fact, tracking down memory leaks is one of the most tedious and lengthy aspects of programming in unmanaged environments. <br><br><h4>  Role of application root elements </h4><br>  To figure out how the garbage collector is determined when the object is no longer needed, you need to know what the <i>application application root elements are</i> .  Simply put, a <i>root element</i> is a cell in memory that contains a reference to a heaped object.  Strictly speaking, the root elements can be called: <br><ul><li>  Links to global objects (although they are not allowed in C #, the CIL code allows you to place global objects </li><li>  Links to any static objects or static fields. </li><li>  References to local objects within the application code base. </li><li>  References to the object parameters passed to the method. </li><li>  References to the object awaiting <i>finalization</i> . </li><li>  Any CPU registers that reference the object. </li></ul><br><br>  During garbage collection processes, the runtime will examine the objects on the heap to determine if they are still reachable (i.e., root) to the application.  To do this, the CLR will create <i>object graphs</i> representing all the objects reachable by the application.  In addition, it should be borne in mind that the garbage collector will never create a graph for the same object twice, avoiding the need to perform cyclic reference counting, which is typical for programming in the COM environment. <br><br><h5>  Object Generations </h5><br>  When trying to detect unreachable code, CLR environment objects <b>do not literally check every object in the heap</b> .  Obviously, this would take a lot of time, especially in large projects. <br>  To optimize the process, each object in the heap refers to a certain <i>‚Äúgeneration‚Äù.</i> The meaning in the use of generations looks quite simple: <blockquote>  The longer the object is in the heap, the higher the likelihood that it will remain there. </blockquote><br>  For example, a class defined in the main window of a desktop application will remain in memory until the end of the program.  On the other hand, an object that has recently fallen into a heap (for example, those that are in the scope of methods) will most likely become unattainable quickly enough.  Worryingly of these assumptions, every object in the heap refers to: <br><ul><li>  <i>Generation 0.</i> Identifies a new, just-placed object that has never been marked as proper removal during garbage collection. </li><li>  <i>Generation 1.</i> Identifies an object that has already ‚Äúsurvived‚Äù one garbage collection process (was marked as being properly deleted, but was not deleted due to sufficient free space on the heap). </li><li>  <i>Generation 2.</i> Identifies an object that has experienced more than one garbage collection run. </li></ul><br><br>  Generations 0 and 1 are called <i><b>ephemeral</b></i> . <br><br>  The garbage collector first analyzes all objects that belong to generation 0. If after their removal there is a sufficient amount of memory, the status of all the surviving objects rises to generation 1. If all objects of generation 0 were checked, but additional space is still required, it will be checked generation objects 1. Objects of this generation, which managed to survive, will become objects of generation 2. if the garbage collector <b>still</b> needs memory, then objects of generation 2 will undergo garbage collection. Since  There are no objects above the 2nd generation, the status of the objects will not change. <br>  From the above, we can conclude that newer objects will be deleted faster than older ones. <br><br><h5>  Parallel garbage collection in .NET 1.0 - .NET 3.5 </h5><br>  Before the release of .NET 4.0, the cleaning of unused objects was carried out using the technique of <i>parallel garbage collection</i> .  In this model, when performing garbage collection of <b>ephemeral</b> objects, the garbage collector temporarily suspended all active <i>threads</i> within the current process, so that the application could not access the managed heap until the garbage collection process was completed. <br>  At the end of the garbage collection cycle, suspended threads were allowed to continue working again.  Fortunately, in .NET 3.5 the garbage collector was well optimized and therefore the associated short interruptions in working with the application rarely became noticeable. <br>  Like optimization, parallel garbage collection allowed cleaning of objects that were not found in any ephemeral generation in a separate stream.  This reduced (but did not eliminate) the need to suspend active threads by the .NET runtime.  Moreover, parallel garbage collection made it possible to place objects on the heap during the assembly of objects of non-ephemeral generations. <br><br><h5>  Background garbage collection in .NET 4.0 </h5><br>  And finally, I would like to tell you about improving the work of the garbage collector in .NET 4.0. <br><br>  In .NET 4.0, the garbage collector decides in a different way about suspending threads and cleaning objects in a managed heap, using the <i>background garbage collection</i> technique.  Despite its name, this does not mean that all garbage collection now occurs in additional background threads.  In fact, in the case of background garbage collection for non-ephemeral generation objects, the .NET runtime can now collect garbage from ephemeral generation objects in a separate background thread. <br>  The garbage collection mechanism in .NET 4.0 has been improved so that it takes less time to suspend the flow associated with garbage collection details.  Thanks to these changes, the process of cleaning unused objects of generation 0 and 1 has become optimal.  It allows you to get a higher level of application performance. <br><br><h5>  Conclusion </h5><br>  In conclusion, I would like to say that the garbage collector that is used in .NET 4.0 allows you to optimize the performance of programs and has virtually no effect on performance. <br>  In the next article I will explain how you can personally manage the garbage collection process using the System.G namespace. <br><br>  More detail: <a href="http://fileaddnet.ucoz.ru/publ/books_program/2-1-0-605">here</a> </div><p>Source: <a href="https://habr.com/ru/post/125968/">https://habr.com/ru/post/125968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125960/index.html">AMD introduces RAM under the brand Radeon</a></li>
<li><a href="../125961/index.html">We use Flickr API from Perl</a></li>
<li><a href="../125964/index.html">LHC @ home 2.0 opens for everyone</a></li>
<li><a href="../125965/index.html">Severe Caucasian tender</a></li>
<li><a href="../125967/index.html">How we started to launch our SaaS product to the global market</a></li>
<li><a href="../125969/index.html">New type of freelancing - Dealkovo</a></li>
<li><a href="../125970/index.html">Droider Chart. Issue 64, laconic</a></li>
<li><a href="../125971/index.html">Video tour to the data center: Free-cooling</a></li>
<li><a href="../125972/index.html">Labs ROUTE: EIGRP</a></li>
<li><a href="../125973/index.html">Shorts - short and funny, or how we prepared the site for the Habraeffect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>