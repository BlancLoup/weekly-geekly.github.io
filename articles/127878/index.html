<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NTRUEncrypt cryptosystem of the future?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All modern asymmetric cryptography is currently based on two simple and understandable principles: faith and hope. The belief is that when the conditi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NTRUEncrypt cryptosystem of the future?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/c01b0494/368e65ea/b5b28673/8c90c7d1.jpg" align="left">  All modern asymmetric cryptography is currently based on two simple and understandable principles: faith and hope.  The belief is that when the condition P ‚â† NP is fulfilled, the cryptosystem is not cracked in polynomial time.  The hope that a quantum computer is as far from us as the creation of Cassiopeia.  So, these two principles are so unreliable and difficult to prove from a mathematical point of view, that the only way out of this situation is to acquire a hat like the one on the left.  Alternative?  She exists.  A relatively young cryptosystem NTRUEncrypt, which may be able to defeat these two principles and quite possibly will become the prototype for all the asymmetric cryptography of the ‚Äúpost-quantum‚Äù era.  Detailed analysis of this fastest asymmetric algorithm resistant to attacks using quantum computers <a name="habracut"></a><br><br><h5>  A brief description of the cryptosystem </h5><br>  So NTRU (Nth-degree TRUncated polynomial ring or simply Number Theorists aRe Us) was proposed in 1995.  Unlike its eminent predecessors such as RSA or El Gamal, NTRU does not work on a residue ring modulo an integer N, but on a ring of polynomials of degree n-1, modulo x <sup>n</sup> -1.  The addition of elements in such a group occurs as usual addition, and when multiplying, the element x <sup>n is</sup> reduced to 1, x <sup>n + 1</sup> to x, and so on.  By multiplying two elements of the ring a (x) * b (x), we obtain the element c (x) = c <sub>0</sub> + c <sub>1</sub> x + ... + c <sub>n-1</sub> x <sup>n-1</sup> , in which the coefficient c <sub>k is</sub> calculated as follows: <br><img src="https://habrastorage.org/storage1/f0553c23/d147bc80/b0a6a5f9/6adc243e.jpg"><br>  This ring is called the ring of truncated polynomials.  We denote it for convenience R. In the NTRU cryptosystem, all coefficients of polynomials are modulo integers p and q.  For example, the polynomial 13 + 12x + 14x <sup>2</sup> + 7x <sup>3</sup> mod 3 = 1-x <sup>2</sup> + x <sup>3</sup> . <br><br>  After this small prelude, we proceed directly to the description of the algorithm itself. <br>  NTRU uses three constant parameters: N, p, q.  The number N is the size of the polynomials chosen as keys.  The numbers p and q need not be simple, but the GCD (p, q) must be equal to 1. It should be noted that the parameter p serves to determine the interval to which all coefficients of the polynomials used in the cryptosystem are required to belong.  And more precisely, the message space L of the cryptosystem NTRU is defined as <br><img src="https://habrastorage.org/storage1/213ceaf1/e59e8b0b/b72b16cf/9528f7c5.jpg"><br>  Thus, if N = 11 and p = 3, then we can use in our cryptosystem only polynomials with coefficients {-1,0,1}.  For example: -1 + x + x <sup>3</sup> -x <sup>4</sup> -x <sup>5</sup> + x <sup>10</sup> <br>  After selecting these three basic parameters, it will be necessary to select three more additional parameters, which are usually denoted by d <sub>f</sub> , d <sub>g</sub> , d.  These three parameters are used to define a set of polynomials. <br>  L <sub>f</sub> = L (d <sub>f</sub> , d <sub>f</sub> -1), L <sub>g</sub> = L (d <sub>g</sub> , d <sub>g</sub> ), L <sub>r</sub> = L (d, d). <br>  A small explanation: a record of the form L <sub>f</sub> = L (d <sub>f</sub> , d <sub>f</sub> -1) means that L <sub>f</sub> is a set of all possible polynomials of the ring R, which have exactly d <sub>f</sub> units (1) and d <sub>f</sub> -1 minus ones ( -1) all other coefficients are zero. <br>  For example, the polynomial -1 + x + x <sup>3</sup> -x <sup>4</sup> + x <sup>8</sup> belongs to the set L (3,2) because it has 3 1 and 2 -1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now you can try to generate a pair of secret / public key.  This is done as follows. <br><ol><li>  An arbitrary polynomial f (x) is chosen from the set L <sub>f</sub> . </li><li>  The polynomial g (x) is chosen from the set Lg. </li><li>  The polynomials f <sub>q</sub> (x) and f <sub>p</sub> (x) are calculated such that f <sub>p</sub> (x) * f (x) = 1 mod p and f <sub>q</sub> (x) * f (x) = 1 mod q </li><li>  The public key is defined as h (x) = f <sub>q</sub> (x) * g (x) mod q </li><li>  The secret key is a pair (f (x), f <sub>p</sub> (x)). </li></ol><br>  We describe the encryption procedure in the NTRU cryptosystem: <br><ol><li>  Bob chooses message m and converts it into a polynomial M (x) ‚àà L <sub>m</sub> remind that the coefficients of the polynomials belonging to L <sub>m</sub> lie in the interval <img src="https://habrastorage.org/storage1/48401cc7/cf64be7a/b62b3daa/835cc182.jpg"></li><li>  Bob chooses a so-called.  ‚ÄúBlinding‚Äù the polynomial r (x) ‚ààL <sub>r</sub> and using Alice‚Äôs public key computes C (x) = p * r (x) * h (x) + M (x) mod q.  The polynomial c (x) and will be a ciphertext. </li></ol><br>  And the decryption procedure: <br><ol><li>  Having received C (x) from Bob, Alice uses her secret key to calculate <img src="https://habrastorage.org/storage1/e985b0bf/5137d156/63a747eb/0224743a.jpg">  At the same time, Alice carefully monitors that the coefficients of the obtained polynomial a (x) lie in the interval (‚Äìq / 2, q / 2]. Why this is done later. </li><li>  Alice calculates <img src="https://habrastorage.org/storage1/bec7d996/6ffdfb54/f3d5637a/61ac873b.jpg"><br>  the first term of the expression b (x) has a factor p and therefore b (x) = f (x) * M (x) mod p.  However, this all happens only if, when calculating a (x), its coefficients were not greater than q, therefore, at the first stage of decryption, it is checked that all coefficients lie in the specified interval. </li><li>  Calculating <img src="https://habrastorage.org/storage1/f6bd8b82/e1449b50/a9023f36/584c3a9b.jpg">  Alice recovers the original message M. </li></ol><br>  I personally consider the most interesting point in the entire encryption-decryption scheme is the moment of checking the coefficients of the resulting polynomial a (x) to the interval (-q / 2; q / 2). As I explained above, all the coefficients of the polynomial should not be greater than q in order not to violate divisibility by p of the left side of the sum. But why, then, do we check the interval (-q / 2; q / 2] and not (-q; q]. The point is this. Suppose q = 32. P = 3. As a result, modulo 32 turned out the number 18. Modulo 3 it will be zero, but 18 = -14 mod 32. And if we calculate -14 mod 3, we get an incorrect result.  Accordingly, you should always know in advance at what interval the obtained coefficients will be. The NTRU developers claim that for the recommended parameters with a probability almost equal to 1, the coefficients will always be in the interval (-q / 2; q / 2], therefore when deciphering, Alice gives the conditionally obtained number 18 to -14. <br><br><h5>  A few words about the practical side of the issue </h5><br>  <b>pros</b> <br>  So, what advantages and disadvantages can be seen from the transition to the NTRU now. <br>  First, a great speed of work.  Performing encryption / decryption operations requires O (n <sup>2</sup> ) operations, unlike O (n <sup>3</sup> ) in the same RSA. <br>  Secondly, it is small, but an increase in durability with virtually the same key length. <br><img src="https://habrastorage.org/storage1/7b1f3a7b/bc91b303/ddc35ef5/4ab51a30.jpg"><br>  <b>Minus</b> <br>  He is alone for now, but for paranoids it is very serious.  The need to use only the recommended parameters.  It was the same requirement that caused general discontent during the transition to elliptic curves and contributed to all sorts of suspicions about the presence of backdoors. <img src="https://habrastorage.org/storage1/262c0648/33719fa1/40dbb1ca/8ec4f069.jpg"><br><br><h4>  NTRU strength </h4><br>  Let {b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>n</sub> } be a linearly independent system of vectors.  The lattice L is the set of integer linear combinations. <br><img src="https://habrastorage.org/storage1/1a1c8d55/dfb43218/b25e7949/321a7052.jpg"><br>  For example, the lattice generated by a pair of vectors b1 = (2,0) and b2 = (1,1) consists of all the vectors of the form <img src="https://habrastorage.org/storage1/7555f695/67565f39/d39146c4/a1585726.jpg">  or in other words view vectors <img src="https://habrastorage.org/storage1/6ab8791b/b9632e24/982bdd30/7470b9c2.jpg">  such that <img src="https://habrastorage.org/storage1/fcb80652/dc4de763/3f11006f/5aab2d4d.jpg"><br>  The frontal attack on the NTRU is based on the lattices and the search for the shortest vector in the lattice.  To unlock the secret key f (x), an attacker can build a matrix <br><img src="https://habrastorage.org/storage1/51b3ee48/074456ca/dfb3b1cc/0eb80fcb.jpg"><br>  And generate from the rows of this matrix the lattice L. Since  Alice's public key h (x) = g (x) * f <sup>-1</sup> (x) this lattice will contain the vector t = (a * f (x), g (x)).  Moreover, this vector is the shortest in the lattice L. Accordingly, finding such a vector will lead to finding the secret key f (x).  The task of finding the shortest lattice vector is considered to be computationally difficult.  The temporal estimate of NTRU hacking using the lattice method can be calculated using the formula T = 2 <sup>(0.4N-3.5)</sup> .  For N = 251, this is about <sup>2,100</sup> . <br><br>  A few words about quantum computing.  The fact is that with the advent of a quantum computer, it will be possible to implement Shor‚Äôs algorithm, which allows to solve the factorization problem, and the discrete logarithm for the company.  Naturally, in the light of this, RSA, DSA, and other similar algorithms become useless.  But differently, the situation is with the NTRU, because there is no quantum algorithm for solving the problem of the shortest lattice vector (although the search is actively conducted from the first half of the 90s), which means it is fully applicable in the ‚Äúpost-quantum‚Äù era. <br><br>  Well, one more thing about persistence.  The fact is that although NTRU, like RSA, does not guarantee stability in the case of proving the inequality P  NP (this is explained by the fact that the task belongs to the NP class even if there is at least one difficultly solvable variant or, more simply, on the <b>worst case</b> While the remaining options can have an easy solution. Accordingly, no one can guarantee that even if P ‚â† NP is proved, the attacker will not get an easier version of the task and the hacking will not be possible in polynomial time), some tasks based on lattices  interconnection resistance was proved average and worst case.  This gives hope that in the future the emergence of a cryptosystem similar to that of the NTRU guaranteeing polynomial stability is possible if the condition P ‚â† NP is fulfilled.  It is these two differences that make the NTRU so different from its predecessors. <br><br><h5>  Known System Vulnerabilities </h5><br>  Let's briefly go over the vulnerabilities of the system and consider the most successful attacks. <br>  <b>Brute force</b> <br>  When breaking with brute force, the main task of the enemy is to pick up Alice's secret key, i.e.  polynomial f (x).  The adversary knows that a polynomial f (x) of length N has d <sub>f</sub> unit coefficients and (d <sub>f</sub> -1) coefficients -1.  Selection of such a polynomial will require checking <img src="https://habrastorage.org/storage1/268d73f9/ec0bb51d/f8afb64a/8bf44043.jpg">  options.  For N = 251 and d <sub>f</sub> = 50, this expression is 3 * 10 <sup>100</sup> .  Comparing this assessment with the assessment of the complexity of solving the problem of finding the shortest lattice vector, we can conclude that, as in the case of RSA, brute-force key is not the most successful attack against the NTRU. <br><br>  <b>Attack meeting in the middle</b> <br>  But Andrew Odlyzko (I will not undertake to write Russian transcription) suggested the option of an attack meeting in the middle, which requires the NTRU to successfully open the secret key. <img src="https://habrastorage.org/storage1/7b403bd4/5a8e80ee/5c60262b/f083bcad.jpg">  time and exactly the same space on the hard disk (r-integer not greater than N).  As a matter of fact, attacks of this type are called a meeting in the middle because they allow exchanging the time required for memory calculations necessary for storing temporary data. <br>  The attack proposed by Odlyzko is as follows. <br>  The definition of the public key h = f <sub>q</sub> * g mod q implies the equality g = h * f mod q. <br>  In this case, the attacker presents f as the concatenation of two polynomials of length N / 2. <br>  f (x) = f <sub>1</sub> || f <sub>2</sub>  g = h * (f <sub>1</sub> || f <sub>2</sub> ) = f <sub>1</sub> * h + f <sub>2</sub> * h mod q.  We know that the polynomial g consists of the coefficients {1,0, -1} for the case p = 3 or the coefficients {1, 0} for the case p = 2, i.e.  in other words <br>  f <sub>1</sub> * h = {1,0} -f <sub>2</sub> * h. <br>  Based on this fact, an attacker can act according to the following algorithm (for the case p = 2): <br><ol><li>  The number k is chosen.  And 2 <sup>k</sup> baskets are written in which suitable candidates f <sub>1</sub> and f <sub>2</sub> will be stored.  An increase in the number k leads to a decrease in the algorithm time, but to an increase in the memory required for cracking. </li><li>  The attacker enumerates all variants of the polynomial f <sub>1</sub> whose length is equal to N / 2 and which contains d / 2 1ki.  Such a search will require <img src="https://habrastorage.org/storage1/e0a41f88/a5a384c8/2ee87ee1/29a6d5a6.jpg">  iterations. </li><li>  Each attacking polynomial is placed in the basket as follows: f <sub>1 is</sub> written into the basket with the number consisting of the most significant bits of the first k coefficients f <sub>1</sub> * h mod q. <br>  For example: let N = 4, q = 8.  Then the polynomial with coefficients {7,2,3,5} will be placed in the basket with the number {1,0,0,1}.  A polynomial with coefficients {6,4,3,1} <br>  Add to cart {1,1,0,0}. <br></li><li>  After that, the attacker begins to iterate over the variants of the polynomial f <sub>2</sub> containing d / 2 1ki.  This bust will also take <img src="https://habrastorage.org/storage1/e0a41f88/a5a384c8/2ee87ee1/29a6d5a6.jpg">  iterations. </li><li>  During the iteration of the polynomial f <sub>2, the</sub> attacker writes the resulting polynomial not in one basket, but in a slightly different way: first, he writes f <sub>2</sub> into the basket that corresponds to the high bits of the polynomial ‚Äìf <sub>2</sub> * h mod q, and secondly, adding for each coefficient from ‚Äìf <sub>2</sub> * h, the unit and getting a new version of the baskets writes a polynomial f <sub>2</sub> and in them.  So for example the polynomial ‚Äìf <sub>2</sub> * h mod q = {6,2,1,5} is written only in the basket {1,0,0,1} and the polynomial ‚Äì f <sub>2</sub> * h mod q = {7,2,3, 5} into baskets {1,0,0,1}, {1,0,1,1}, {0,0,0,1}, {0,0,1,1}. </li><li>  If the basket in which the attacker writes the polynomial f <sub>2</sub> already contains f <sub>1,</sub> then the condition f <sub>1</sub> * h = {1,0} -f <sub>2</sub> * h mod q is satisfied for these polynomials.  Therefore, they are considered good candidates for recovery f.  The attacker calculates (f <sub>1</sub> || f <sub>2</sub> ) * h mod q and if the result is a polynomial with coefficients {0,1} which corresponds to the polynomial g, then the secret key f is found. </li></ol><br>  Thus, if the cryptosystem key space of the NTRU is <img src="https://habrastorage.org/storage1/2c8c13e5/5f0d3c1a/b5a8c089/a5a683a3.jpg">  , then the search for a key by the method of a meeting in the middle requires to sort through <img src="https://habrastorage.org/storage1/e0a41f88/a5a384c8/2ee87ee1/29a6d5a6.jpg">  options. <br>  So for NTRU with parameters N = 251, p = 2, d = 35, the key space has a size of ‚âà2,140, ‚Äã‚Äãand the attack in the middle of the meeting requires going through ‚âà2 <sup>70</sup> options (using 2 <sup>70</sup> memory).  Those.  in order to guarantee a 2 <sup>x</sup> durability level, it is necessary to select the NTRU cryptosystem parameters with 2 <sup>2x</sup> key space. <br><br>  <b>Attack with selected ciphertext</b> <br>  And finally, I want to talk about the most interesting and most dangerous attack from a practical point of view. <br>  I remind you that when deciphering a message, Alice calculates the expression <br><img src="https://habrastorage.org/storage1/1bd3d479/9b384abd/97997800/845169ca.jpg">  . <br>  I also remind you that all the coefficients of the obtained polynomial lie in the interval (-q / 2, q / 2]. This means that <img src="https://habrastorage.org/storage1/512658c6/5d1a8fc9/64193e4e/d2215c87.jpg">  . <br>  Those.  a polynomial before modulo q corresponds to a polynomial after a modulo q.  An attack with a selected ciphertext on the NTRU is to create a polynomial a (x) for which a (x) mod q a (x). <br>  The attack is as follows: <br><ol><li>  The attacker creates a ciphertext C (x) = y * h (x) + y (where y is an integer and h (x) is Alice‚Äôs public key) and sends it to Alice. </li><li>  When trying to decrypt a message, Alice calculates <img src="https://habrastorage.org/storage1/49d704f3/85b37d20/4d1a29b6/f77f614e.jpg">  Because  Since the polynomials g (x) and f (x) have coefficients {-1,0,1}, then the coefficients of a polynomial a belong to the set {0, y, -y, 2y, -2y}.  It turns out that if the attacker chose y, such that y &lt;q / 2 and 2y&gt; q / 2, then when a (x) is minimized modulo q, only those elements of a (x) polynomial the coefficients of which are equal to ¬± 2y change. </li><li>  Imagine now that the i-th coefficient a <sub>i</sub> = 2y, then <br><img src="https://habrastorage.org/storage1/8e728c4c/333dac73/dc3be293/2710e213.jpg"><br>  and then the final message after decryption takes the form <br><img src="https://habrastorage.org/storage1/9e79b728/4bcd206b/48ae0195/7161485e.jpg">  . <br>  So  if the attacker chooses y by dividing completely on p, then the result is a polynomial <img src="https://habrastorage.org/storage1/bc62a964/89d674ec/78cbc42e/b6914058.jpg">  . </li><li>  To calculate Alice‚Äôs secret key, all that remains is to calculate <img src="https://habrastorage.org/storage1/5b40caee/7a05b194/78cd88cd/78a7fd11.jpg"></li></ol><br>  Using this attack scheme, the enemy can restore the secret key with a probability of P = 0.13, or, roughly speaking, to recover the secret key, the attacker will need to send in total about 10 selected ciphertexts. <br><br>  <b>Protection against attack with ciphertext</b> <br>  In order to protect the NTRU from such an attack, it is recommended to use the NTRU in conjunction with the FORST supplement scheme. <br>  When encrypting using the NTRU-FORST method, Bob, as in the usual NTRU scheme, calculates the plaintext polynomial m (x).  Complementing the polynomial with a random set of k bits of R, Bob computes r (x) = H (m (x) || R), where H (x) is a cryptographically strong hash function. <br>  Further, to obtain a ciphertext as in the usual NTRU scheme, Bob forms the polynomial c (x) = r (x) * h (x) + m (x) mod q. <br>  Upon receiving the ciphertext, Alice recovers the message m (x), and calculates H (m (x) || R). <br>  Then Alice calculates H (m (x) || R) * h (x) + m (x) mod q and compares the obtained value with c (x).  If H (m (x) || R) * h (x) + m (x) mod q = c (x) then Alice accepts the message, otherwise rejects it. <br><br><h4>  Conclusion </h4><br>  Although the NTRU algorithm is patented, which reduces the interest of researchers to it, the lack of publications about serious vulnerabilities over the almost 15-year period of existence allows one to look at its further use with optimism.  Moreover, even in the most pessimistic case for asymmetric cryptography, namely the invention of the quantum computer today, there is no reason for panic and the NTRU is a completely reliable version of the cryptosystem of the ‚Äúpost-quantum‚Äù era. <br><br><h5>  Bibliography </h5><br>  1. Stamp M., Low RM Applied cryptanalysis <br>  2. Mariano Monteverde NTRU software implementation for constrained devices. <br>  3. Phong Q. Nguyen and David Pointcheval Analysis and Improvements of NTRU Encryption Paddings <br>  4. Nick Howgrave-Graham A hybrid attack against NTRU </div><p>Source: <a href="https://habr.com/ru/post/127878/">https://habr.com/ru/post/127878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127870/index.html">Just about Qt. Container library</a></li>
<li><a href="../127871/index.html">About caching resource-intensive SQL queries on a web server</a></li>
<li><a href="../127874/index.html">How to write code?</a></li>
<li><a href="../127875/index.html">Effective way to protect against piracy</a></li>
<li><a href="../127876/index.html">90 Node.js modules for public use</a></li>
<li><a href="../127879/index.html">Home server WiFi router</a></li>
<li><a href="../127881/index.html">Damage to the optical highway in Germany</a></li>
<li><a href="../127886/index.html">Adobe Flash 11 and AIR 3 Release Candidate</a></li>
<li><a href="../127887/index.html">Interview with Linus Torvalds</a></li>
<li><a href="../127888/index.html">Bash RSS parser for LostFilm.TV: Transmission + SQLite + mkvtools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>