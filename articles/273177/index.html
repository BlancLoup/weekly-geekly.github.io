<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to work with timestamps in PostgreSQL?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of working with timestamps in PostgreSQL is poorly disclosed in Russian-language specialized publications on the Internet and is a frequent ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to work with timestamps in PostgreSQL?</h1><div class="post__text post__text-html js-mediator-article">  <i>The topic of working with timestamps in PostgreSQL is poorly disclosed in Russian-language specialized publications on the Internet and is a frequent source of problems in the work of programmers.</i>  <i>I bring to your attention the translation of material from Hubert Lubaczewski, the author of the popular foreign blog <a href="http://depesz.com/">depesz.com</a> .</i>  <i>I hope the article will be useful for you!</i> <br><br><img src="https://habrastorage.org/files/553/182/d30/553182d3066c414fa164417261ebb44c.png" alt="image"><br><br>  From time to time in the IRC or in the mailing lists, someone asks questions that show a deep misunderstanding (or lack of understanding) of timestamps, especially those that take into account time zones.  Since I‚Äôve come across this before, let me tell you what timestamps are, how to work with them, and what are the most common problems you might encounter. <br><a name="habracut"></a><br>  We have two types of data that we can use: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  timestamp </li><li>  timestamp with time zone (or timestamptz) </li></ul><br>  The <i>timestamp</i> type contains only the date and time, no other information.  On the one hand, it may seem like a good idea (after all, in everyday life we ‚Äã‚Äãonly use the date and time, don‚Äôt we?), But on the other, it‚Äôs a complete horror. <br><br>  Let's imagine that you have a time stamp ‚Äú2014-04-04 20:00:00". What does it tell you? Unfortunately, not much. It all depends on what point of the planet we are talking about. Eight pm 4 April is a different point in time in Los Angeles, Chicago, London, Warsaw or Moscow. This is the problem of time zones. <br><br>  Of course, you might think: ‚ÄúI will always be in the same time zone, I do not need any problems with the support of different time zones.  In my time zone, the date and time will be quite enough to mark any point in time, because this is exactly what we do in ‚Äúreal life‚Äù. <br><br>  But is it really? <br><br>  Imagine that you have the label '2013-10-27 02:00:00', and you know that your application is tied to Polish time.  In this case, you are no longer lucky, because it may be 2 am CST or an hour more, in the usual Central European time.  All because of the seasonal shift hours. <br><br>  I believe that using timestamps without a time zone is almost always a bug and needs to be fixed.  There are even more problems if the entries in your application come from different time zones (for example, a scheduler application). <br><br>  So the most obvious solution is to use timestamps with time zones (timestamptz). <br><br>  First, it will not take more disk space: <br><br><pre><code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> typname, typlen <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_type <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> typname ~ <span class="hljs-string"><span class="hljs-string">'^timestamp'</span></span>; typname | typlen <span class="hljs-comment"><span class="hljs-comment">-------------+-------- timestamp | 8 timestamptz | 8 (2 rows)</span></span></code> </pre> <br>  How does this work?  The label must know the time zone, so why it does not require more space? <br><br>  The fact is that she does not know the time zone.  Inside, all values ‚Äã‚Äãin the timestamptz columns are in UTC (Coordinated Universal Time) format. <br><br>  UTC has nice features: it has no offset (it itself is the starting point from which the offset of other time zones is considered), and it has no difference between summer and winter time.  So any timestamp in UTC format is always guaranteed to indicate only one point in time. <br><br>  But if I always use UTC, how do I know the time in the time zone I need? <br><br>  Every time, when it comes to the values ‚Äã‚Äãof timestamptz, if the time zone is not specified, PostgreSQL uses a pre-configured time.  And you can configure it in different ways: <br><br><ul><li>  timezone parameter in postgresql.conf </li><li>  alter database ... set timezone = '...' </li><li>  alter user ... set timezone = '...' </li><li>  SET timezone = '...' </li></ul><br>  The first parameter is used to indicate in which time zone your server is located.  In other words, the default time zone that will be used in the absence of other changes. <br><br>  The following two methods change the default for the selected database and user. <br><br>  The latter method can be used if you want your database connection to work with different settings. <br><br>  Take into account how the output now () changes: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(); now <span class="hljs-comment"><span class="hljs-comment">------------------------------- 2014-04-04 20:32:59.390583+02 (1 row) $ set timezone = 'America/New_York'; SET $ select now(); now ------------------------------- 2014-04-04 14:33:06.442768-04 (1 row)</span></span></code> </pre><br>  So every time you view or change the timestamptz values, PostgreSQL converts them to / from UTC. <br><br>  This means that the values ‚Äã‚Äãcan be easily compared (they are all in the same time zone, there are no changes in daylight saving time, so comparison is always possible). <br><br>  And now let's imagine that you have the value '2014-04-04 20:00:00'.  And you know that this is the time in Los Angeles, but you want to save it in your database, which operates in a different time zone.  You can check that the current offset is -7 hours, and use the value like this: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00-07'</span></span>::timestamptz; timestamptz <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-05 05:00:00+02</span></span></code> </pre><br>  What happened?  Why is not shown 8 pm? <br><br>  The reason is simple - I inserted a timestamp in a request in some time zone.  Inside, the label was converted to UTC, and then, again converted (perhaps even without UTC, I'm not sure) to my usual time zone, which is: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> timezone; TimeZone <span class="hljs-comment"><span class="hljs-comment">---------- Poland (1 row)</span></span></code> </pre><br>  If I had set the time zone of Los Angeles, the result of the query would be: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> timezone = <span class="hljs-string"><span class="hljs-string">'America/Los_Angeles'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00-07'</span></span>::timestamptz; timestamptz <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-04 20:00:00-07 (1 row)</span></span></code> </pre><br>  It is important to understand that the displayed value always takes into account the setting of the time zone. <br><br>  There is another way to get 20:00 in Los Angeles: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> timezone = <span class="hljs-string"><span class="hljs-string">'Poland'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'America/Los_Angeles'</span></span>; timezone <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-05 05:00:00+02 (1 row)</span></span></code> </pre><br>  It is very important to add ‚Äú:: timestamp" after the value, otherwise we will get something strange: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> timezone = <span class="hljs-string"><span class="hljs-string">'Poland'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'America/Los_Angeles'</span></span>; timezone <span class="hljs-comment"><span class="hljs-comment">--------------------- 2014-04-04 11:00:00 (1 row)</span></span></code> </pre><br>  What happened here?  Where did 11:00 come from? <br><br>  Value in quotes (2014-04-04 20:00:00) is interpreted as timestamptz, which means 8 pm in my time zone: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00'</span></span>::timestamptz; timestamptz <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-04 20:00:00+02 (1 row)</span></span></code> </pre><br>  And only after transferring the value to my time zone, the PG reads ‚Äúat time zone ...", which is used to display the time in the selected time zone. <br><br>  Thus, the timestamp at time zone gives the timestamptz value, which indicates the time when the local time in the selected time zone was as specified in the command. <br><br>  And timestamptz at time zone gives the timestamp value, which shows what time it was in the selected time zone at the specified time. <br><br>  This sounds a bit confusing, so let me give examples: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 20:00:00'</span></span>::timestamptz <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>; timezone <span class="hljs-comment"><span class="hljs-comment">--------------------- 2014-04-04 18:00:00 (1 row) select '2014-04-04 20:00:00'::timestamp at time zone 'UTC'; timezone ------------------------ 2014-04-04 22:00:00+02 (1 row)</span></span></code> </pre><br>  Interestingly, we can use this to transfer time from one time zone to another, even if Pg is not in any of them. <br><br>  Suppose we want to know what time it is in Los Angeles when it is 8 am in Moscow.  My local time is as follows: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> timezone; TimeZone <span class="hljs-comment"><span class="hljs-comment">---------- Poland (1 row)</span></span></code> </pre><br>  There is little benefit from it. <br><br>  First we need to define a point in time (in the format of timestamptz), which shows 8 am in Moscow: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2014-04-04 08:00:00'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'Europe/Moscow'</span></span>; timezone <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-04 06:00:00+02 (1 row)</span></span></code> </pre><br>  This tells me that it corresponds to 6 am in my time zone.  But we want to know the time in Los Angeles.  I could write '2014-04-04 06: 00: 00 + 02' in the time zone 'LA', but you can do it differently: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-string"><span class="hljs-string">'2014-04-04 08:00:00'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'Europe/Moscow'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'America/Los_Angeles'</span></span>; timezone <span class="hljs-comment"><span class="hljs-comment">--------------------- 2014-04-03 21:00:00 (1 row)</span></span></code> </pre><br>  Since the expression 'timestamp at time zone ..' is the same as timestamptz, we can use ‚Äúat time zone" again to translate it back to the timestamp (without specifying a time zone) related to some another place. <br><br>  I hope now everything is clear to you.  I myself for a long time tried to understand this question, and finally understood everything :) <br><br>  All of this has one interesting side effect: it‚Äôs not so easy to add indexes to functions that work with timestamptz.  For example, you cannot create an index that will be used to get the day of the week: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (i timestamptz); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (to_char(i, <span class="hljs-string"><span class="hljs-string">'Day'</span></span>)); ERROR: functions in index expression must be marked IMMUTABLE</code> </pre><br>  As shown in the example above, the reason is very simple - the same point in time can refer to different days of the week depending on the time zone.  And since to_char () uses the current time zone, it can produce different values ‚Äã‚Äãfor the same source data, depending on the time zone settings in the system: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> timezone = <span class="hljs-string"><span class="hljs-string">'Europe/Warsaw'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (i) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'2014-04-04 06:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> i, to_char(i, <span class="hljs-string"><span class="hljs-string">'Day'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; i | to_char <span class="hljs-comment"><span class="hljs-comment">------------------------+----------- 2014-04-04 06:00:00+02 | Friday (1 row) $ set timezone = 'Europe/Moscow'; SET $ select i, to_char(i, 'Day') from test; i | to_char ------------------------+----------- 2014-04-04 08:00:00+04 | Friday (1 row) $ set timezone = 'America/Los_Angeles'; SET $ select i, to_char(i, 'Day') from test; i | to_char ------------------------+----------- 2014-04-03 21:00:00-07 | Thursday (1 row)</span></span></code> </pre><br>  The same point in time, but different days.  These may be different months or even different years, depending on where it was. <br><br>  The timestamp (without a time zone) here "shows" a strong side - since it does not indicate the time zone, you can safely use it to extract information. <br><br>  But we know how to translate timestamptz into a timestamp.  You just need to specify her time zone.  Therefore, we can try to do this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (to_char(i <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'Poland'</span></span>, <span class="hljs-string"><span class="hljs-string">'Day'</span></span>));</code> </pre><br>  But, unfortunately, nothing comes out.  The fact is that to_char is too versatile.  You can use to_char like this: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_char(<span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), <span class="hljs-string"><span class="hljs-string">'TMMonth'</span></span>); to_char <span class="hljs-comment"><span class="hljs-comment">--------- April (1 row) $ set lc_time = 'pl_PL.UTF-8'; SET $ select to_char(now(), 'TMMonth'); to_char ---------- Kwiecie≈Ñ (1 row)</span></span></code> </pre><br>  This time we get other results not because of the time zone, but because of locale. <br><br>  The correct solution to the problem of indexing is to write your own function, which will call to_char in an absolutely constant "environment" and then index it.  Like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> day_from_ts(timestamptz) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_char( $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'Poland'</span></span>, <span class="hljs-string"><span class="hljs-string">'Day'</span></span> ); $$ language sql immutable; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span></code> </pre><br>  And now we can use it to index: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> q <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (day_from_ts( i )); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span></code> </pre><br>  This is safe because the function itself causes the time zone to take the value ‚ÄúPoland‚Äù, and it calls to_char in such a way as to ignore the value of the locale (in other words, there is no TM prefix in the to_char format). <br><br>  Naturally, to use this index, all queries must also use this function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> day_from_ts(i) = <span class="hljs-string"><span class="hljs-string">'Friday'</span></span>;</code> </pre><br>  Another important thing when working with time zones is getting Unix time, or the so-called epoch.  In general, it is simple: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()); date_part <span class="hljs-comment"><span class="hljs-comment">------------------ 1396638868.57491 (1 row)</span></span></code> </pre><br>  Interestingly, it does not depend on the time zone: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> timezone; TimeZone <span class="hljs-comment"><span class="hljs-comment">---------- Poland (1 row) $ select now(), extract(epoch from now()); now | date_part -------------------------------+------------------ 2014-04-04 21:15:27.834775+02 | 1396638927.83477 (1 row) $ set timezone = 'America/Los_Angeles'; SET $ select now(), extract(epoch from now()); now | date_part -------------------------------+------------------ 2014-04-04 12:15:27.834775-07 | 1396638927.83477 (1 row) $ commit; COMMIT</span></span></code> </pre><br>  The reason not known to all is that Unix time is always accepted in the UTC time zone.  This means that when you extract an epoch from the timestamp timestamp, the PG assumes that it is in UTC.  From which the following potential problems arise: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()); now | date_part <span class="hljs-comment"><span class="hljs-comment">-------------------------------+----------------- 2014-04-04 21:19:01.456205+02 | 1396639141.4562 (1 row) $ select extract(epoch from '2014-04-04 21:19:01.456205'::timestamp); date_part ----------------- 1396646341.4562 (1 row)</span></span></code> </pre><br>  In the first case, Pg gets a ‚Äúpoint in time‚Äù, which is converted internally to UTC (and when it is displayed, it is converted to my time zone, +2). <br><br>  In the second case, the timestamp is in my time zone, but it is assumed that this is UTC (without conversion!), And the epoch is taken from the value '2014-04-04 21: 19: 01.456205 UTC', not '2014-04-04 21: 19: 01.456205 + 02 '. <br><br>  Wisely. <br><br>  In short, try to avoid timestamp and use timestamptz. <br><br>  The last thing I would like to say is not a bug or a potential problem, but rather a functionality that many people don‚Äôt know about. <br><br>  As you have seen, PostgreSQL uses the timestamp (and timestamptz) up to microseconds.  Many people insist that accuracy be only up to a second, although I personally do not like it. <br><br>  Both the timestamp and timestamptz (and other time related data) can have extra precision (‚Äúprecision‚Äù). <br><br>  Let me give you a simple example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()::timestamptz(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()::timestamptz(<span class="hljs-number"><span class="hljs-number">1</span></span>); now | now | now <span class="hljs-comment"><span class="hljs-comment">-------------------------------+------------------------+-------------------------- 2014-04-04 21:23:42.322315+02 | 2014-04-04 21:23:42+02 | 2014-04-04 21:23:42.3+02 (1 row)</span></span></code> </pre><br>  Of course, you can use it in the tables: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (i timestamptz(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; i <span class="hljs-comment"><span class="hljs-comment">------------------------ 2014-04-04 21:24:16+02 (1 row)</span></span></code> </pre><br>  Fine!  You do not need to change ‚Äúnow ()" or anything else, just add precision to the data type and it will correct everything. <br><br>  I mentioned that I do not like it.  The reason is simple - in any sufficiently loaded system, the second is too low level of accuracy.  Moreover, the storage of data up to a microsecond does not cost me anything, but it can be useful.  On the other hand, if the data is up to microseconds, how can I get the values ‚Äã‚Äãto be displayed without fractions of a second? <br><br>  It's simple: I use (in SELECT queries) to_char (), or date_trunc functions, or even cast to the timestamptz (0) type: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), to_char(<span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), <span class="hljs-string"><span class="hljs-string">'YYYY-MM-DD HH24:MI:SS TZ'</span></span>), date_trunc(<span class="hljs-string"><span class="hljs-string">'second'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>()::timestamptz(<span class="hljs-number"><span class="hljs-number">0</span></span>); now | to_char | date_trunc | now <span class="hljs-comment"><span class="hljs-comment">-------------------------------+--------------------------+------------------------+------------------------ 2014-04-04 21:28:20.827763+02 | 2014-04-04 21:28:20 CEST | 2014-04-04 21:28:20+02 | 2014-04-04 21:28:21+02 (1 row)</span></span></code> </pre><br><br>  <i>For more details on how to work with timestamps, we are going to talk at the <a href="http://pgday.ru/ru/2016%3Futm_source%3Dhabrahabr%26utm_medium%3Dpost%26utm_campaign%3Dkak_rabotat_s_metkami_vremeni">PG Day'16 Russia</a> conference in July 2016!</i>  <i>Prepare your questions, we will try to answer them.</i> <i><br><br></i>  <i>You, for sure, will also find for yourself <a href="http://habrahabr.ru/company/mailru/blog/242645/">an article</a> written by colleagues from the Mail.ru Group.</i>  <i>It clearly shows an example when only timestampt is not enough to solve the problem.</i> </div><p>Source: <a href="https://habr.com/ru/post/273177/">https://habr.com/ru/post/273177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273167/index.html">How do postgreSQL security_barrier views work</a></li>
<li><a href="../273169/index.html">Pebble: Timeline - Inside View</a></li>
<li><a href="../273171/index.html">Results of 2015: web development</a></li>
<li><a href="../273173/index.html">Server "second-hand" as an anti-crisis solution</a></li>
<li><a href="../273175/index.html">Usability of trading terminals: UX-trends of mobile and desktop applications for trading on the stock exchange</a></li>
<li><a href="../273179/index.html">Atlassian Plugins: Diving into Active Objects and Plugin Settings</a></li>
<li><a href="../273181/index.html">Lan Lite and Lan Base Differences for Cisco 2960 Switches</a></li>
<li><a href="../273183/index.html">Intel¬Æ Tamper Protection Toolkit - Obfuscating compiler and code integrity checking tools</a></li>
<li><a href="../273185/index.html">A bit about Facebook data center</a></li>
<li><a href="../273189/index.html">XML, XQuery and Triple Grief with Performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>