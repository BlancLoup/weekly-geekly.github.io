<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous alternative for Kotlin in the face of Vert.x</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin is a popular tool for Android developers, but as you know, this is not its only use. So when I decided to write a simple web service, it seemed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous alternative for Kotlin in the face of Vert.x</h1><div class="post__text post__text-html js-mediator-article"><p>  Kotlin is a popular tool for Android developers, but as you know, this is not its only use.  So when I decided to write a simple web service, it seemed sensible to do it on Kotlin. </p><br><p>  It turns out that the Spring Framework is not the only option.  There is another powerful asynchronous alternative - Vert.x, which for some reason is rarely mentioned in the context of Kotlin.  About this tandem and talk in this article. </p><br><p><img src="https://habrastorage.org/files/90d/48f/ca6/90d48fca650c4acd9224b9faa4dbcd6e.png" alt="Vert.x + Kotlin"></p><a name="habracut"></a><br><h2 id="motivaciya">  Motivation </h2><br><p>  Starting a project, I wanted the impossible: I could write a prototype quickly, and just host some Heroku, and if necessary, expand the prototype to a full-fledged project without rewriting it from scratch. </p><br><p>  Official documentation and examples from good bloggers in one voice recommended the Spring Framework, citing good compatibility and even native support for Kotlin in a future version.  But if you think so, do you need some special compatibility?  The language is already friendly with Java, so you choose any framework, import the standard library and go ahead. </p><br><h2 id="chto-takoe-vertx">  What is Vert.x? </h2><br><p>  Vert.x is an asynchronous event-oriented framework for any application, with a module for the web.  The architecture is similar to Node.js, so much so that the project even began its existence in 2011 under the name "Node.x", and only then the creator Tim Fox considered it risky and remembered another synonym for the word "node" ("node" and " vertex "is a" node "in graph theory).  Unlike Node.js, which is limited to JavaScript, Vert.x also supports Java, Groovy, Ruby, and Ceylon (in the past, it also supported Python, Scala, and Clojure). </p><br><p>  I was interested in the following Vert.x options: </p><br><ul><li>  Performance and asynchrony, thanks in no small part to <a href="http://netty.io/">Netty</a> , on which it is based. </li><li>  Single-threaded model that simplifies development approach </li><li>  Splitting an application into minimal cells called "verticals" </li><li>  Distributed event bus allowing individual verticals to communicate with each other, regardless of the language in which they are written </li></ul><br><p>  This concludes the description of the framework itself, because this site already had a good <a href="https://habrahabr.ru/post/276771/">article</a> about it.  My task is to show how you can use all these amenities in Kotlin. </p><br><h2 id="zadacha">  Task </h2><br><p>  Suppose we need a web service that will return a list of islands (for example, <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2582%25D0%25BB%25D0%25B8%25D0%25BD">Kotlin</a> ) and the countries in which these islands are located in JSON format by REST model. </p><br><ul><li><code>GET /islands</code> <br> <ul><li>  List of all islands and countries </li></ul></li><li> <code>GET /countries</code> <br> <ul><li>  List of all countries with islands </li></ul></li><li> <code>GET /countries/:code</code> <br> <ul><li>  Country according to its ISO 3166 code </li></ul></li></ul><br><p>  I agree, this is not a particularly useful web service, but this is quite enough to demonstrate the framework, avoiding unnecessary details of the project and other libraries that only distract from the main theme. </p><br><h2 id="dannye">  Data </h2><br><p>  Let's start with the data that the web service will return.  Models need only two: <code>Island</code> and <code>Country</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Island</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> country: Country) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Country</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> code: String)</code> </pre> <br><p>  Thanks to the date classes in Kotlin, you don‚Äôt have to worry about anything else - the methods <code>equals()</code> , <code>hashCode()</code> , getters and setters are all automatically embedded in this simple design. </p><br><p>  Further <code>IslandDao</code> for data access: in the real application there will be requests to a certain database, and we have a simple static array with harvested islands. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IslandsDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> MOCK_ISLANDS <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { listOf( Island(<span class="hljs-string"><span class="hljs-string">"Kotlin"</span></span>, Country(<span class="hljs-string"><span class="hljs-string">"Russia"</span></span>, <span class="hljs-string"><span class="hljs-string">"RU"</span></span>)), Island(<span class="hljs-string"><span class="hljs-string">"Stewart Island"</span></span>, Country(<span class="hljs-string"><span class="hljs-string">"New Zealand"</span></span>, <span class="hljs-string"><span class="hljs-string">"NZ"</span></span>)), Island(<span class="hljs-string"><span class="hljs-string">"Cockatoo Island"</span></span>, Country(<span class="hljs-string"><span class="hljs-string">"Australia"</span></span>, <span class="hljs-string"><span class="hljs-string">"AU"</span></span>)), Island(<span class="hljs-string"><span class="hljs-string">"Tasmania"</span></span>, Country(<span class="hljs-string"><span class="hljs-string">"Australia"</span></span>, <span class="hljs-string"><span class="hljs-string">"AU"</span></span>)) ) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchIslands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = MOCK_ISLANDS <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCountries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = MOCK_ISLANDS.map { it.country } .distinct() .filter { code == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || it.code.equals(code, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } .sortedBy { it.code } }</code> </pre> <br><p>  Overview of methods: </p><br><ul><li>  <code>fetchIslands()</code> returns the entire list of islands with their countries </li><li> <code>fetchCountries(code)</code> <br> <ul><li>  <code>map</code> - pulls countries from the list of islands </li><li>  <code>distinct</code> - remarks (Australia) </li><li>  <code>filter</code> - filters by a given code (if present) </li><li>  <code>sortedBy</code> - sorts by codes </li></ul></li></ul><br><p>  This minimum DAO is enough to go to the application itself. </p><br><h2 id="vertikl">  Vertikl </h2><br><p>  The heart of the Vert.x application is the verticals themselves.  My fantasy is bad, so let's call it "MainVerticle". </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainVerticle</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>()</code> </pre> <br><p>  To begin with, we will create a field in it for the DAO, which we have already written above. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dao = <span class="hljs-type"><span class="hljs-type">IslandsDao</span></span>()</code> </pre> <br><p>  Now the important part: a router that will distribute requests by type and path.  To begin with we will disassemble the simplest route. </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val router = Router.router(vertx).apply { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>).handler { ctx -&gt; ctx.<span class="hljs-built_in"><span class="hljs-built_in">response</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(<span class="hljs-string"><span class="hljs-string">"Welcome!"</span></span>) } }</code> </pre> <br><p>  This is a root GET route that returns the plain text "Welcome!". </p><br><p>  But why do we need the text?  We'd rather JSON serialize objects.  To do this, write the <code>endWithJson(Any)</code> extension in <code>endWithJson(Any)</code> , which ends the request chain only by filling out the "Content-Type" header with the JSON format and serializing any object that is passed to it. </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> HttpServerResponse.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endWithJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { putHeader(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/json; charset=utf-8"</span></span>).end(Json.encodePrettily(obj)) }</code> </pre> <br><p>  Now you can add a couple of routes to the router, which will take lists of data from the DAO and return them as JSON. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("/islands").<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> { ctx -&gt; val islands = dao.fetchIslands() ctx.response().endWithJson(islands) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("/countries").<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> { ctx -&gt; val countries = dao.fetchCountries() ctx.response().endWithJson(countries) }</code> </pre> <br><p>  Already more interesting and useful, is not it? </p><br><p>  From the task, there was only a route to search for countries by code. </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/countries/:code"</span></span>).handler { ctx -&gt; val code = ctx.<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>().getParam(<span class="hljs-string"><span class="hljs-string">"code"</span></span>) val countries = dao.fetchCountries(code) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countries.<span class="hljs-built_in"><span class="hljs-built_in">isEmpty</span></span>()) { ctx.fail(<span class="hljs-number"><span class="hljs-number">404</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ctx.<span class="hljs-built_in"><span class="hljs-built_in">response</span></span>().endWithJson(countries.first()) } }</code> </pre> <br><p>  Everything is almost the same as in the previous ones, only the parameter was added <code>:code</code> to the path itself (which can be retrieved using <code>HttpServerRequest.getParam(String)</code> ) and, in addition to the successful <code>end()</code> , it also appeared <code>fail()</code> with the HTTP error code in case of not found country. </p><br><p>  So, the router is ready.  It remains only to collect the server itself.  It sounds, admit, much grander than it actually is. </p><br><p>  In the AbstractVerticle abstract class, there is a <code>start()</code> method that is called when the vertical is started.  The procedure for starting the web server is placed just there. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(startFuture: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Future</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;?)</span></span></span></span> { vertx.createHttpServer() .requestHandler { router.accept(it) } .listen(Integer.getInteger(<span class="hljs-string"><span class="hljs-string">"http.port"</span></span>, <span class="hljs-number"><span class="hljs-number">8080</span></span>)) { result -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.succeeded()) { startFuture?.complete() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { startFuture?.fail(result.cause()) } } }</code> </pre> <br><p>  The code above does the following: </p><br><ol><li>  Creates a new HTTP server </li><li>  Sends requests to our router </li><li>  Listens to requests through the port, which is specified in the parameters (or 8080 by default) </li></ol><br><p>  This completes the code of the application itself, now the configuration is magic! </p><br><h2 id="konfiguraciya">  Configuration </h2><br><p>  The configuration will live in the Gradle script "build.gradle" </p><br><pre> <code class="hljs perl">buildscript { ext { kotlin_version = <span class="hljs-string"><span class="hljs-string">'1.1.0'</span></span> vertx_version = <span class="hljs-string"><span class="hljs-string">'3.3.3'</span></span> } repositories { jcenter() } dependencies { classpath <span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span> } }</code> </pre> <br><p>  First, the <code>buildscript</code> part where we set versions and plugins (in this case only one). </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">plugins</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> <span class="hljs-string"><span class="hljs-string">'java'</span></span> id <span class="hljs-string"><span class="hljs-string">'application'</span></span> id <span class="hljs-string"><span class="hljs-string">'com.github.johnrengelman.shadow'</span></span> version <span class="hljs-string"><span class="hljs-string">'1.2.4'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin'</span></span></code> </pre> <br><p>  Next, we use the specified and embedded plugins. </p><br><p>  The first two, "java" and "application", are needed as a skeleton of a Java application, on the basis of which we build everything. </p><br><p>  The "kotlin" specified above is all that is needed in terms of setting up a Kotlin application. </p><br><p>  The " <a href="https://github.com/johnrengelman/shadow">shadow</a> " plugin is used here so that the created JAR is "fat" ("fat jar"), that is, it contains all the libraries used.  This makes it much easier to deploy, but for this we need to configure it as well. </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">shadowJar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">baseName</span></span> = <span class="hljs-string"><span class="hljs-string">'app'</span></span> classifier = <span class="hljs-string"><span class="hljs-string">'shadow'</span></span> manifest { <span class="hljs-attribute"><span class="hljs-attribute">attributes</span></span> <span class="hljs-string"><span class="hljs-string">'Main-Verticle'</span></span>: <span class="hljs-string"><span class="hljs-string">'net.gouline.vertxexample.MainVerticle'</span></span> } mergeServiceFiles { <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> <span class="hljs-string"><span class="hljs-string">'META-INF/services/io.vertx.core.spi.VerticleFactory'</span></span> } }</code> </pre> <br><p>  The first two fields "baseName" and "classifier" indicate how the output JAR should be called (i.e. "app-shadow.jar") so that the deployment script can be easily found.  In addition, we configure the path to the vertical, written earlier, and to the standard <code>VerticleFactory</code> . </p><br><pre> <code class="hljs perl">repositories { jcenter() } dependencies { compile <span class="hljs-string"><span class="hljs-string">"io.vertx:vertx-core:$vertx_version"</span></span> compile <span class="hljs-string"><span class="hljs-string">"io.vertx:vertx-web:$vertx_version"</span></span> compile <span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"</span></span> }</code> </pre> <br><p>  Now we apply the required libraries, in this case, we need only three of them: </p><br><ul><li>  vertx-core - the main core of Vert.x </li><li>  vertx-web - additions to Vert.x for working with the web </li><li>  kotlin-stdlib-jre8 - Kotlin Standard Library (for JRE 8) </li></ul><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sourceCompatibility</span></span> = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> mainClassName = <span class="hljs-string"><span class="hljs-string">'io.vertx.core.Launcher'</span></span></code> </pre> <br><p>  Finally, we install Java 8 source compatibility (this is the minimum for Vert.x) and the main class at launch, which will be the built-in <code>Launcher</code> . </p><br><p>  That's all, the configuration is ready! </p><br><h2 id="sborka-i-hosting">  Build and Hosting </h2><br><p>  Building on a local computer is very simple: <code>gradle run</code> to run on localhost or <code>gradle shadowJar</code> to export a JAR file that can be uploaded to a web server. </p><br><p>  But, as I mentioned at the very beginning, I would like everything to work on Heroku too.  To do this, simply create a "Procfile" with the following content: </p><br><pre> <code class="hljs perl">web: java $JAVA_OPTS -Dhttp.port=$PORT -jar build/libs/app-shadow.jar</code> </pre> <br><p>  This line describes how to run the application: via <code>java</code> , specifying the port number (which is decided by Heroku itself) and, finally, the same ‚Äúapp-shadow.jar‚Äù, ‚Äã‚Äãwhich we have registered in ‚Äúbuild.gradle‚Äù. </p><br><p>  That's all!  Now this application can be completely filled in with Git remout, as the <a href="https://devcenter.heroku.com/articles/git">Heroku documentation</a> describes, and enjoy the result. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I hope I convinced someone to try Kotlin, Vert.x, or both.  There is plenty of documentation (official and amateur) for both projects, so it‚Äôs easy to figure out how to write a more complex application. </p><br><p>  Although the Vert.x documentation does not have a section for Kotlin, it uses the Java API, so the functions of one language are rather trivially transferred to another.  Moreover, when copying examples in Java to the Kotlin class, IntelliJ IDEA itself will offer to convert the code automatically. </p><br><p>  The full version of the project can be found in "vertx-kotlin-example" on GitHub, which I support with all the updates and some extensions.  This version starts easily after the jump and even deploys to Heroku. </p><br><p>  Thanks for attention! </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="https://github.com/mgouline/vertx-kotlin-example">vertx-kotlin-example</a> (GitHub) - an example on which the code in this article is based </li><li>  <a href="https://github.com/vert-x3/vertx-examples">vertx-examples</a> (GitHub) - examples of Vert.x applications in different languages </li><li>  <a href="http://vertx.io/docs/vertx-core/java/">Vert.x Core Manual</a> - <a href="http://vertx.io/docs/vertx-core/java/">Framework</a> Documentation </li><li>  <a href="http://vertx.io/docs/vertx-web/java/">Vert.x-Web</a> - documentation of the vertx-web module </li><li>  <a href="https://kotlinlang.org/docs/reference/whatsnew11.html">What's New in Kotlin 1.1</a> - New in Kotlin 1.1 </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322406/">https://habr.com/ru/post/322406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322394/index.html">C #: 10 common pitfalls and bugs</a></li>
<li><a href="../322396/index.html">Happy birthday, Microsoft</a></li>
<li><a href="../322400/index.html">MWC-2017. New technologies for mobile recognition (3 videos + links to the demo on the App store and Google play)</a></li>
<li><a href="../322402/index.html">Cisco Spark Cloud Collaboration Solution: Overview and Configuration</a></li>
<li><a href="../322404/index.html">Training with reinforcements: from Pavlova to slot machines</a></li>
<li><a href="../322408/index.html">How IT professionals work. Semen Bagreev, Rambler Digital Solutions, Python / Ruby Development Manager</a></li>
<li><a href="../322414/index.html">Will data scientists soon be replaced by automated algorithms and artificial intelligence?</a></li>
<li><a href="../322416/index.html">Choosing the right error handling strategy (parts 1 and 2)</a></li>
<li><a href="../322418/index.html">The horror story about coding standards</a></li>
<li><a href="../322420/index.html">3 steps to an interactive prototype</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>