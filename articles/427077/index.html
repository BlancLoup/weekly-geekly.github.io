<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Laplace Blur - Is it possible to blur Laplace instead of Gauss, how many times is it faster, and is it worth the loss of 1/32 accuracy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blur in the common people - the effect of blurring, in digital image processing. It can be very effective both by itself and as a component of interfa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Laplace Blur - Is it possible to blur Laplace instead of Gauss, how many times is it faster, and is it worth the loss of 1/32 accuracy</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ge/pb/p3/gepbp3bpdluk4yg0-xzbn0via3y.jpeg" alt="image"><br><br>  Blur in the common people - the effect of blurring, in digital image processing.  It can be very effective both by itself and as a component of interface animations, or more complex derivative effects (bloom / focusBlur / motionBlur).  With all this honest blur in the forehead rather slow.  And often the implementations embedded in the target platform leave much to be desired.  That speed is sad, then artifacts cut eyes.  The situation gives rise to many compromise realizations, better or worse suitable for certain conditions.  The original implementation with good quality of reliability and the highest speed, while the lowest dependence on the hardware is waiting for you under the cut.  Enjoy your meal! <br><a name="habracut"></a><br>  (Laplace Blur - The proposed original name of the algorithm) <br><br>  Today, my internal demoscenary kicked me and made me write an article that had to be written six months ago.  As an amateur at leisure to develop original effect algorithms, I would like to propose to the public an ‚Äúalmost gaucian blura‚Äù algorithm, featuring the use of extremely fast processor instructions (shifts and masks), and therefore is available for implementation up to microcontrollers (extremely fast in limited environments). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      According to my tradition of writing articles on Habr, I will give examples in JS, as in the most popular language, and believe it or not, it is very convenient for the rapid prototyping of algorithms.  In addition, the ability to implement this effectively on JS came along with typed arrays.  On my not very powerful laptop, the fullscreen image is processed at a speed of 30fps (the multithreading of the workers was not involved). <br><br><div class="spoiler">  <b class="spoiler_title">Disclaimer for cool mathematicians</b> <div class="spoiler_text">  Immediately I will say that I take off my hat in front of you, because I myself consider myself not sufficiently savvy in basic mathematics.  However, I am always guided by the general spirit of the fundamental approach.  Therefore, before heytit mine, to some extent ‚Äúobservant‚Äù approach to approximation, take care to count the bit complexity of the algorithm, which, as you think, can be obtained by the methods of classical approximation by polynomials.  I guessed?  You wanted to quickly approximate them?  Given that they will require floating arithmetic, they will be much slower than a single bit shift, to which I will explain in the end.  In a word, do not rush into theoretical fundamentalism, and do not forget about the context in which I solve the problem. <br></div></div><br>  This description is here rather to explain the course of my thoughts and guesses that led me to the result.  For those who will be interested: <br><br>  Original Gauss Function: <br><br><img src="https://habrastorage.org/webt/63/h0/km/63h0kmf5xougnx-tcp05_esii1y.png" alt="image"><br><br>  g (x) = a * e ** (- ((xb) ** 2) / c), where <br>  a is the amplitude (if the color is eight bits per channel, then it is = 256) <br>  e is the Euler constant ~ 2.7 <br>  b - the shift of the graph in x (we do not need = 0) <br>   - parameter affecting the width of the graphics associated with it as ~ w / 2.35 <br><br>  Our private function (minus from the exponent is removed with the substitution of multiplication by division): <br><br><img src="https://habrastorage.org/webt/rj/o-/ns/rjo-nsq8o1nptsuyrbhpit1ozkw.png" alt="image"><br><br>  g (x) = 256 / e ** (x * x / c) <br><br>  Let the dirty approximation action begin: <br>  Note that the parameter c is very close to the half-width and set to 8 (this is due to how many steps you can move along one 8-bit channel). <br><br>  We will also roughly replace e with 2, noting, however, that this affects the curvature of the ‚Äúbell‚Äù more than its borders.  In fact, it affects 2 / e times, but the surprise is that this error compensates for the parameter introduced in the definition of the parameter s, so that the boundary conditions are still in order, and the error appears only in a slightly incorrect ‚Äúnormal distribution‚Äù, for graphic algorithms, this will affect the dynamics of gradient color transitions, but it is almost impossible to notice with the eye. <br><br>  So now our function is: <br>  gg (x) = 256/2 ** (x * x / 8) or gg (x) = 2 ** (8 - x * x / 8) <br>  Note that the exponent (x * x / 8) has the same range of values ‚Äã‚Äã[0-8] as the function of the smaller order abs (x), because the latter is a candidate for replacement.  Quickly check the guess by looking at how the graph changes with it gg (x) = 256 / (2 ** abs (x)): <br><br>  GaussBlur vs LaplasBlur: <br><br><img src="https://habrastorage.org/webt/ri/9m/wn/ri9mwnl06vzoim4atrlhnyi5wye.png" alt="image"><br><br>  It seems that the deviations are too great, besides the function, having lost its smoothness, now has a peak.  But wait. <br><br>  First, let us not forget that the smoothness of the gradients obtained by blurring does not depend on the probability density function (which is the Gauss function), but on its integral ‚Äî the distribution function.  At that time I did not know this fact, but in fact, after conducting a ‚Äúdestructive‚Äù approximation with respect to the probability density function (Gauss), the distribution function remained quite similar. <br><br>  It was: <br><br><img src="https://habrastorage.org/webt/gj/nl/_l/gjnl_lzdrv_e_yvi87kxcrnu-e4.png" alt="image"><br><br>  It became: <br><br><img src="https://habrastorage.org/webt/le/nw/te/lenwteibjhhx9mwosint393sgjo.png" alt="image"><br><br>  The proof taken from the finished algorithm is the same: <br><br><img src="https://habrastorage.org/webt/lg/ly/bm/lglybmx2fx4-rtff1eq_natuodm.png" alt="image"><br><br>  (looking ahead, I‚Äôm saying that the blur error of my algorithm for Gausian x5 was only 3%). <br><br>  So, we have moved much closer to the Laplace distribution function.  Who would have thought, but they can wash images at 97% no worse. <br><br>  Proof, the difference Gaucian Blura x5 and "Laplace Blura" x7: <br><br><img src="https://habrastorage.org/webt/qy/1g/z1/qy1gz1d0fahnsbstiqwijj-rb3y.png" alt="image"><br><br>  (this is not a black image! You can study in the editor) <br><br>  The admission of this transformation allowed us to proceed to the idea of ‚Äã‚Äãobtaining the value by iterative filtering, which I planned to reduce to the beginning. <br><br>  Before the narration of a specific algorithm, it will be fair if I run ahead and immediately describe its only drawback (although the implementation can be fixed, with a loss of speed).  But this algorithm is implemented using shear arithmetic, and degrees 2k are its limitation.  So the original is made to blur x7 (which in the tests is the closest to the Gausian x5).  This restriction of the implementation is connected with the fact that with eight-bit color, shifting the value in the filter drive by one bit per step, any effect from a point ends in a maximum of 8 steps.  I also implemented a slightly slower version in terms of proportions and additional additions, which realizes a quick division by 1.5 (having obtained as a result a radius of x15).  But with the further application of this approach, the error increases, and the speed drops, which does not allow using it so.  On the other hand, it is worth noting that x15 is already enough to not notice the difference much, the result is obtained from the original or from the downsampled image.  So the method is quite suitable if you need extreme speed in a limited environment. <br><br>  So, the algorithm core is simple, four passes of the same type are performed: <br><br>  1. Half of the value of the drive t (initially equal to zero) is added to half the value of the next pixel, the result is assigned to it.  We continue this way until the end of the image line.  For all lines. <br><br>  Upon completion of the first pass, the image is blurred in one direction. <br><br>  2. In the second pass we do the same in the opposite direction for all lines. <br>  Get the image completely blurred horizontally. <br><br>  3-4.  Now do the same thing vertically. <br>  Done! <br><br>  Initially, I used a two-pass algorithm with the implementation of reverse blurring through the stack, but it is difficult to understand, not graceful, and besides, on the current architectures it turned out to be slower.  Perhaps the one-pass algorithm will be faster on microcontrollers, plus it will also be possible to output the result progressively. <br><br>  The current four-pass method of implementation, I looked at Habr√© from the previous guru on blur algorithms.  <a href="https://habr.com/post/151157/">habr.com/post/151157</a> Taking this opportunity, I express my solidarity and deep gratitude to him. <br><br>  But the hacks didn't end there.  Now, on how to calculate all three color channels for one processor instruction!  The fact is that the bit shift used as a division by two allows the position bits of the result to be very well controlled.  The only problem is that the lower bits of the channels slide into the neighboring older ones, but you can simply reset them, rather than correct the problem, with some loss of accuracy.  And according to the described filter formula, the addition of half the value of the drive with half the value of the next cell (assuming zeroing of the discharged discharges) never leads to overflow, so you should not worry about it.  And the filter formula for calculating all digits at the same time becomes: <br><br>  buf32 [i] = t = (((t &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  However, another addition is required: it was empirically found that the loss of accuracy in this formula is too significant, the brightness of the picture visually jumps noticeably.  It became clear that the bit to be lost should be rounded to the whole, and not discarded.  A simple way to do this in integer arithmetic is to add half the divider before division.  We have a divider deuce, it means you need to add one, in all digits, - the constant 0x010101.  But with any addition you need to be careful not to get overflow.  So we cannot use this correction to calculate the half value of the next cell.  (If there is a white color, we will get an overflow, because we will not correct it).  But it turned out that the main mistake was made by the multiple division of the drive, which we can correct.  Because, in fact, even with such a correction, the value in the drive will not rise above 254. But when added to 0x010101, overflow will not be guaranteed.  And the filter formula with correction takes the form: <br><br>  buf32 [i] = t = ((((0x010101 + t) &gt;&gt; 1) &amp; 0x7F7F7F) + ((buf32 [i] &gt;&gt; 1) &amp; 0x7F7F7F); <br><br>  In fact, the formula performs a fairly good correction, so that with repeated repeated application of this algorithm to the image, artifacts begin to be seen only in the second dozen passes.  (not the fact that the repetition of the Gauchian Blur will not give such artifacts). <br><br>  Additionally, there is a remarkable property, with multiple passes.  (It is not the merit of my algorithm, but the ‚Äúnormality‚Äù of the normal distribution itself).  Already on the second pass, the Laplace Blur probability density function (if I figured it all out correctly) will look something like this: <br><br><img src="https://habrastorage.org/webt/sl/1m/tk/sl1mtkidvvurt8z7vxiuhjbfzka.png" alt="image"><br><br>  That, you see, is already very close to the Ghousiana. <br><br>  Experimentally, I found that using modifications with a large radius is permissible in a pair, since  The property described above compensates for errors if the last pass is more accurate (the most accurate is the algorithm described here x7 blur). <br><br>  <a href="https://impfromliga.github.io/LaplaceBlur/">demo</a> <br>  <a href="https://github.com/impfromliga/LaplaceBlur">rap</a> <br>  <a href="https://codepen.io/impfromliga/pen/brXZjJ">kodpen</a> <br><br>  A call for cool mathematicians: <br>  What would be interesting to know how well to use such a filter is separable, not sure if there is a symmetrical distribution pattern.  Although the eye of heterogeneity and is not visible. <br><br>  upd: Here I will raise useful links, courtesy presented by commentators, and found in other habrovchan. <br>  1. How intel masters work, relying on the power of SSE - <a href="https://software.intel.com/en-us/articles/iir-gaussian-blur-filter-implementation-using-intel-advanced-vector-extensions/">software.intel.com/en-us/articles/iir-gaussian-blur-filter-implementation-using-intel-advanced-vector-extensions</a> (thanks <a href="https://habr.com/users/vladimirovich/" class="user_link">vladimirovich</a> ) <br>  2. Theoretical base on the topic ‚ÄúFast image convolutions‚Äù + some of its custom applications in relation to honest gaucian blyur - <a href="http://blog.ivank.net/fastest-gaussian-blur.html">blog.ivank.net/fastest-gaussian-blur.html</a> (thanks to <a href="https://habr.com/users/grox/" class="user_link">Grox</a> ) <br><br>  Suggestions, comments, constructive criticism - welcome! </div><p>Source: <a href="https://habr.com/ru/post/427077/">https://habr.com/ru/post/427077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427059/index.html">"Human, too human." Will we not become hostages of our mind, realizing a universal AI?</a></li>
<li><a href="../427061/index.html">Voice assistants driving a car: for whom the future</a></li>
<li><a href="../427065/index.html">Class attribute metamorphosis</a></li>
<li><a href="../427069/index.html">Local NPM repository in 5 minutes with its packages and caching</a></li>
<li><a href="../427075/index.html">History of one development</a></li>
<li><a href="../427079/index.html">NetApp Insight 2018</a></li>
<li><a href="../427081/index.html">Criteria of the human mind, from the point of view of one programmer</a></li>
<li><a href="../427087/index.html">MIT course "Computer Systems Security". Lecture 12: "Network Security", part 2</a></li>
<li><a href="../427091/index.html">Numerical test of abc hypothesis (yes, the one)</a></li>
<li><a href="../427093/index.html">MIT course "Computer Systems Security". Lecture 12: "Network Security", part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>