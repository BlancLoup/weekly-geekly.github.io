<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Delegates and Lambda Expressions in C # .Net - Cheat Sheet or Briefly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear reader! 
 Almost everyone who has worked in .Net more or less knows what Delegates are. And those who do not know about them, almost certa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Delegates and Lambda Expressions in C # .Net - Cheat Sheet or Briefly</h1><div class="post__text post__text-html js-mediator-article"><h2>  Hello, dear reader! </h2><br>  Almost everyone who has worked in .Net more or less knows what Delegates are.  And those who do not know about them, almost certainly at least in the know about <b>Lambda expressions</b> (Lambda expressions).  But personally, I constantly forget about the syntax of their declarations, then come back to the multipage explanations of smart people about how the compiler reacts to such constructions.  If such a problem happens to you, you are welcome! <br><a name="habracut"></a><br><h2>  Delegates </h2><br>  A delegate is a special type.  And it is announced in a special way: <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Everything is simple, there is the <b>delegate</b> keyword, and then the delegate itself with the name MyDelegate, returned by the int type and one argument of the string type. <br><br>  In fact, when compiling code in a CIL, the compiler turns each such delegate type into the <b>same type-class</b> and all instances of a given delegate type are in fact instances of the corresponding class-types.  Each such class inherits the type MulticastDelegate from which it gets the Combine and Remove methods, contains a constructor with two arguments <b>target</b> (Object) and <b>methodPtr</b> (IntPtr), a field <b>invocationList</b> (Object), and three of its own methods <b>Invoke, BeginInvoke, EndEnvoke</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By declaring a new delegate type, we immediately, through the syntax of its declaration, <b>strictly define the signature of valid methods</b> with which instances of such a delegate can be initialized.  This immediately affects the signature of the auto-generated methods Invoke, BeginInvoke, EndEnvoke, so these methods are not inherited from the base type, but are defined for each delegate type separately. <br><br>  An instance of such a delegate should be understood as a <b>link to a specific method or list of methods</b> that will be transmitted somewhere and most likely executed on the other side.  Moreover, the client will not be able to pass with the method the value of the arguments with which it will be executed (if only we do not allow it to it), or change its signature.  But he can determine the logic of the method, that is, his body. <br><br>  This is convenient and safe for our code, since we know what type of argument to pass to the delegate at runtime and what return type to expect from the delegate. <br><br>  If we dream up, then we can provide the right to pass an argument for delegates to the client side, for example, to create a method with a delegate argument and an argument that will be passed to this delegate within our method, which will allow the client to specify the argument value for the method in the delegate.  For example in this way. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myDelegate deleg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span>{deleg.Invoke(arg);}</code> </pre> <br>  By creating an instance of the delegate in the code, a method is passed to its constructor (both the instance and static approaches, the main thing is that the method signature matches the delegate signature).  If the method is instance-specific, then in the <b>target</b> field a reference is written to the instance owner of the method (we need it, because if the method is instance- <b>specific,</b> this at least implies working with the fields of this target object), and in <b>methodPtr, a</b> reference to the method.  If the method is static, then the <b>target</b> and <b>fieldPtr fields</b> are written null and the method reference, respectively. <br><br>  You can initialize a delegate variable through creating an instance of the delegate: <br><br><pre> <code class="hljs lisp">MyDeleg x = new MyDeleg(<span class="hljs-name"><span class="hljs-name">MyFunc</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Or simplified syntax without calling a constructor: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">MyDeleg</span></span> x = MyFunc;</code> </pre> <br>  You can organize the transfer / receipt of a delegate instance in different ways.  Since the delegate as a result is just a type-class, you can freely create fields, properties, method arguments, etc.  specific type of delegate. <br><br>  Delegate methods: <br><br>  <b>Invoke</b> - synchronous execution of the method that is stored in the delegate. <br>  <b>BeginInvoke, EndEnvoke</b> - is similar but asynchronous. <br><br>  You can also call the execution of methods stored in the delegate via the simplified syntax: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">delegInst</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Invoke</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">argument</span></span>);</code> </pre> <br>  it's like writing: <br><br><pre> <code class="hljs lisp">delegInst(<span class="hljs-name"><span class="hljs-name">argument</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><h3>  And what for to the delegate a field invocationList? </h3><br>  The <b>invocationList</b> field is null for the delegate instance while the delegate stores a reference to one method.  This method can always be rewritten to another by equating the variable with a new argument to the delegate (or the method we need right away through a simplified syntax).  But you can also create a call chain when the delegate stores references to more than one method. <br>  To do this, call the <b>Combine</b> method: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">MyDeleg</span></span> first = MyFunc1; <span class="hljs-attribute"><span class="hljs-attribute">MyDeleg</span></span> second = MyFunc2; <span class="hljs-attribute"><span class="hljs-attribute">first</span></span> = (MyDeleg) Delegate.Combine(first, second);</code> </pre> <br>  The <b>Combine</b> method returns a reference to a new delegate in which the target and methodPtr fields are empty, but invocationList, which contains two references to delegates: the one that was previously in the first variable and the one that is still stored in second.  It is necessary to understand that adding the third delegate through the Combine method and writing its result to first, the method returns a reference to the new delegate with an invocationList field in which there will be a collection of three references, and the delegate with two references will be deleted by the garbage collector during the next cleaning cycle. <br><br>  When such a delegate is executed, all its methods will be executed in turn.  If the delegate signature assumes receiving parameters, the parameters for all methods will have the same value.  If there is a return value, then we can only get the value of the last method in the list. <br><br>  The <b>Remove</b> method, in turn, performs a search in the list of delegates by the value of the owner object and method, and, if found, deletes the first matched. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Deleg</span></span> first = first.Remove(MyFunc2);</code> </pre> <br>  The <b>+ =</b> and <b>- =</b> operators defined for delegates are analogous to the Combine and Remove methods: <br><br><pre> <code class="hljs vbscript">first = (Deleg) Delegate.Combine(first, <span class="hljs-built_in"><span class="hljs-built_in">second</span></span>);</code> </pre> <br>  similar to the following entry: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">first</span></span> += MyFunc2;</code> </pre> <br>  And correspondingly: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">first</span></span> = first.Remove(MyFunc2);</code> </pre> <br>  similar to the following entry: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">first</span></span> -= MyFunc;</code> </pre> <br>  It is worth saying that delegates can be <b>generic</b> (Generic), which is a more correct approach to creating separate delegates for different types. <br><br>  It is also worth mentioning that <b>the FCL library already contains the most popular delegate types (generic and none)</b> .  For example, the delegate <b>Action &lt;T&gt;</b> is a method with no return value but with an argument, and <b>Fucn &lt;T, TResult&gt;</b> with a return value and an argument. <br><br><h2>  Lambda Operators and Lambda Expressions </h2><br>  You can also initialize the delegate instance with a <b>lambda operator</b> (lambda-operator) or a <b>lambda expression</b> (lambda-expression).  Since, on the whole, they are the same, then hereinafter I will simply call them ‚Äúlambdas‚Äù in places where there is no need to emphasize their differences. <br>  It is worth mentioning that they were introduced in C # 3.0, and before them there were anonymous functions that appeared in C # 2.0. <br><br>  A distinctive feature of lambda is the operator =&gt;, which divides the expression into the left part with the <b>parameters</b> and the right part with <b>the method body</b> . <br><br>  Suppose we have a delegate: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDeleg</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verb</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Then the general syntax of the lambda operator will be as follows: <br><br><pre> <code class="hljs coffeescript">MyDeleg myDeleg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string x)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; };</code> </pre> <br>  This is exactly the <b>Lambda operator</b> since we frame its body in braces, which allows us to place more than one operator in it: <br><br><pre> <code class="hljs javascript">MyDeleg myDeleg = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = x + x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; };</code> </pre> <br>  It is allowed not to specify the types of arguments, because the compiler already knows the type and signature of your delegate, but you can also specify for ease of reading the code by another person: <br><br><pre> <code class="hljs coffeescript">MyDeleg myDeleg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; };</code> </pre> <br>  If there is only one argument, you can omit the brackets enclosing it: <br><br><pre> <code class="hljs javascript">MyDeleg myDeleg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; };</code> </pre> <br>  If there is no argument in the delegate signature, then you must specify empty brackets: <br><br><pre> <code class="hljs coffeescript">AnotherDeleg myDeleg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; };</code> </pre> <br><br>  If a lambda body consists of only one expression, then it is a <b>lambda expression</b> .  This is very convenient, since we have the opportunity to use a simplified syntax in which: <br><br>  - you can omit the curly brackets framing the body of the lambda; <br><br>  - without the above-mentioned curly brackets, we do not need to use the return keyword before the operator and the comma after the operator in the body of the lambda: <br><br>  As a result, the lambda definition code may become tiny: <br><pre> <code class="hljs javascript">MyDeleg myDeleg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x+x;</code> </pre> <br><br><h3>  What does the compiler think about lambdas? </h3><br>  It is important to understand that lambda expressions are not magic strings transmitted directly to the delegate.  In fact, at the compilation stage, each such expression is turned into an anonymous private method with the name beginning with "&lt;", which excludes the possibility of calling such a method directly.  This method is always a <b>member of the type in which you use the given lambda expression</b> , and is passed to the delegate constructor explicitly in CIL code. <br><br>  Moreover, the compiler analyzes whether the expression contains in its body operations with instance fields of the type in which the expression is updated or not.  If so, the generated method will be an instance method, and if not, the method will be static.  The use of static fields of a given type in lambda expressions, as well as instances and instance fields of other types, do not affect this. <br><br>  You may ask why the CLR does not generate an instance method in both cases, the answer is simple - this method needs the extra parameter this, which makes it more difficult to execute compared to a static one. <br><br>  In addition, the CLR creates a construct that <b>caches the</b> delegate with our method in an anonymous private field (all the same in our type where the lambda expression was used) on the first call to it, and on subsequent ones it just reads from the field.  Indeed, there is no point in creating it anew each time, because the information about the method given by the expression is unchanged at the program execution stage. <br><br><h3>  Eventually </h3><br>  But in the end I spent the whole evening ... Phew!  I tried to make the cheat sheet the most compact and informative, but still somehow a lot of letters came out.  Thanks for the comments in advance, I will try to immediately correct all my flaws. <br><br>  Special thanks to the great Jeffrey Richter, who of course will not read the article, but he just wrote a wonderful book ‚ÄúCLR via C #‚Äù, which I reread again and again, and the information from which I used when writing this cheat sheet. <br><br>  <b>Thank you all very much!</b> </div><p>Source: <a href="https://habr.com/ru/post/329886/">https://habr.com/ru/post/329886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329876/index.html">Limit the speed of processing requests in nginx</a></li>
<li><a href="../329878/index.html">The largest Git repository in the world</a></li>
<li><a href="../329880/index.html">JaCarta PKI and OpenVPN for Windows</a></li>
<li><a href="../329882/index.html">9 reasons that prevent you from becoming a timlid</a></li>
<li><a href="../329884/index.html">Machine intelligence in a Gboard keyboard</a></li>
<li><a href="../329888/index.html">ACM ICPC 2017: Final Results</a></li>
<li><a href="../329890/index.html">PHDays VII: Confrontation Chronicles</a></li>
<li><a href="../329892/index.html">What are women talking about? (Text mining of beauty blogs)</a></li>
<li><a href="../329894/index.html">Reactive Stream Log Processing with RxJava - Part 1</a></li>
<li><a href="../329896/index.html">Recipes for Android: Scroll-To-Dismiss Activity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>