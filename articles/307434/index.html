<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Friendly introduction to Dagger 2. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is dependency injection, what is Dagger and how can it come in handy for us to write cleaner and easier to test code. 
 Disclaimer from the trans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Friendly introduction to Dagger 2. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  What is dependency injection, what is Dagger and how can it come in handy for us to write cleaner and easier to test code. </h4><br>  <i>Disclaimer from the translator.</i>  <i>This translation was made for the purpose of self-education, and on Habr√© is laid out on the assumption that many novice Android developers, who, like me, did not have the opportunity to be born as a fifth-generation Java-speaking developer, find it difficult to understand the end products of multi-year layers of concepts and development methods .</i>  <i>This series of articles is an excellent example of how <b>to</b> explain complex things, and I hope you will like it as much as I do.</i>  <i>About all the errors and inaccuracies noted, please report to the PM.</i> <br><br>  Dependency injection (DI) is a great technique that makes it easy to cover an application with tests, and Dagger 2 is one of the most popular Java / Android frameworks designed for this purpose.  Moreover, most of the introductory courses on Dagger 2 are based on the assumption that the reader is already well acquainted with DI and its rather complicated terminology, which makes it difficult for newcomers to enter. <br><br>  In this series of articles, I will try to provide you with a more friendly introduction to Dagger 2 with many examples of ready-to-compile code. <br><a name="habracut"></a><br>  In order not to spread the idea of ‚Äã‚Äãthe tree, I deliberately leave behind the history of DI frameworks, exactly like their countless varieties.  We begin with the introduction to the class constructor, and look at the remaining options as we go. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  So, what is dependency injection? </h3><br>  Dependency injection is a technique that simplifies testing and reusing classes.  Let's look at an example of how it can be applied.  Suppose we need to write an application that prints the current weather conditions to the console.  The simplest implementation would look something like this: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherReporter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WeatherService weatherService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocationManager locationManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeatherReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ weatherService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherService(); locationManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocationManager(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// locationManager.getCurrentLocation() // weatherService.getTemperature(location) // print(temperature) } }</span></span></code> </pre> <br>  Some methods are intentionally omitted because they are unimportant in this case.  Note that <i>WeatherReporter</i> needs two objects to perform its own work: the <i>LocationManager</i> , which determines the user's location, and the <i>WeatherService</i> , which <i>outputs the</i> temperature at the specified coordinates. <br><br>  In a well-designed object-oriented application, only a small share of responsibilities lies on each object, the rest of the work is delegated to other objects.  These other objects are called <b>dependencies</b> .  Before an object starts doing any real work, all its dependencies must be somehow <b>resolved</b> .  For example, dependencies are resolved for our <i>WeatherReporter</i> by creating new instances of these objects in the constructor. <br><br>  For small applications, dependency initialization in the class constructor works quite well, but as the application grows, this approach reveals a number of drawbacks.  First, it makes the class less flexible.  For example, if the application should be multiplatform, we may need to replace our current <i>LocationManager with</i> another one, but this will not be so easy.  We may want to use the same <i>LocationManager</i> in several places, but this will be difficult to do until we change the class. <br><br>  Secondly, our class does not give in to isolated testing.  Creating one <i>WeatherReporter</i> object entails creating two other objects, which ultimately fall under testing along with the original object.  This can be a serious problem if one of the dependencies depends on a costly external resource (an Internet connection, for example) or it itself has a large number of dependencies. <br><br>  The root of evil in this case is that our class performs two different duties.  He is obliged to know not only <i>how</i> to perform his task, but also <i>where to</i> find the components necessary for its implementation.  If, instead, we provide the object with everything needed to do its work, the problem will disappear.  It also facilitates the interaction of the class with other components of the application, not to mention the simplification of testing. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherReporter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WeatherService weatherService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocationManager locationManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeatherReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WeatherService weatherService, LocationManager locationManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.weatherService = weatherService; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.locationManager = locationManager; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// locationManager.getCurrentLocation() // weatherService.getTemperature(location) // print(temperature) } }</span></span></code> </pre> <br>  This approach is called <b>dependency injection</b> .  In an application that relies on DI, objects do not have to "scour around" in search of dependencies or create them themselves.  All dependencies that are provided to them ( <b>implemented</b> ) are ready for use. <br><br><h3>  Graphing </h3><br>  Of course, at some point someone must initialize all the dependencies and provide them to those objects that need them.  This step, referred to as <b>dependency graph building</b> , is usually performed at the point of entry to the application.  In a desktop application, for example, this code is located inside the <i>main</i> method, as in the example below.  In an Android application, this can be done inside the <i>onCreate</i> activity method. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ WeatherService ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherService(); LocationManager lm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocationManager(); WeatherReporter reporter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherReporter(ws, lm); reporter.report(); } }</code> </pre> <br>  If the project is simple, as in our previous example, initialization and implementation of several dependencies in the <i>main</i> method are justified.  However, most projects consist of many classes with their dependencies that must be resolved.  Initializing and binding all of this together requires writing a lot of code.  Even worse, this code will be changed regularly when adding a new class to the application or adding a new dependency to an existing class. <br><br>  To illustrate this problem, let's turn our example into a more realistic one.  In practice, the <i>WeatherService</i> class will need, say, a <i>WebSocket</i> to communicate with the network.  <i>LocationManager</i> will need a <i>GPSProvider</i> to interact with the hardware.  Among other things, most classes will need a <i>Logger</i> to display debug information in the console.  The modified <i>main</i> method now looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ Logger logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logger(); WebSocket socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(); GPSProvider gps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GPSProvider(); WeatherService ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherService(logger, socket); LocationManager lm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocationManager(logger, gps); WeatherReporter reporter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherReporter(logger, ws, lm); reporter.report(); } }</code> </pre><br>  Very quickly, the entry point to our application began to swell from the abundance of initialization code.  To create the only <i>WeatherReporter</i> object we really need, we have to manually initialize many other objects.  As the application grows and grows into classes, the <i>main</i> method will also continue to swell until one day it becomes completely unsupported. <br><br><h3>  How can Dagger 2 help? </h3><br>  <b>Dagger 2</b> is an open source tool that generates most of the initialization code for us, based on just a few annotations.  When using Dagger 2, the entry point to our application can be written in just a few lines of code, no matter how many classes we have and how many dependencies are present.  Below is a new <i>main</i> method for our example using Dagger. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ AppComponent component = DaggerAppComponent.create(); WeatherReporter reporter = component.getWeatherReporter(); reporter.report(); } }</code> </pre><br>  Note that we are not required to write code to resolve dependencies or indicate how these dependencies are intertwined.  This has already been done for us.  The <i>DaggerAppComponent</i> class, automatically generated during project compilation, is smart enough to know that the <i>WeatherReporter</i> class needs a <i>Logger</i> , <i>LocationManager,</i> and <i>WeatherService</i> , which in turn needs <i>GPSProvider</i> and <i>WebSocket</i> .  When the <i>getWeatherReporter</i> method is <i>called,</i> it will create all these objects in the correct sequence, create connections between them, and return only what we needed. <br><br>  In order for Dagger to work, we need to complete a few steps.  First, add annotation to the constructor of each class that Dagger should be aware of.  Below is an example of how to do this for one particular class, but it is also necessary to annotate all classes that need some dependencies or which themselves act as dependencies for other classes. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPSProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GPSProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  If you are worried about the contamination of the application with Dagger-specific code, you will be pleased to know that the <i>Inject</i> annotation <i>is</i> standardized (JSR 330) and many other tools work with it, like Spring or Guice.  Accordingly, switching to another DI framework will not require changing the set of classes in the application. <br><br>  In the next step, we need to create an interface with the <i>Component</i> annotation, which declares the methods that will return the objects we need.  It is not necessary to declare methods for each class in our project here, only methods for classes directly used at the application entry point are required.  In our example, the <i>main</i> method needs only <i>WeatherReporter</i> , so we declare only one method in the interface. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">WeatherReporter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeatherReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  All that's left is to integrate Dagger with our build system.  When using Gradle, simply add new dependencies to <i>build.gradle</i> . <br><br><pre> <code class="bash hljs">plugins { id <span class="hljs-string"><span class="hljs-string">"net.ltgt.apt"</span></span> version <span class="hljs-string"><span class="hljs-string">"0.7"</span></span> } dependencies { apt <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-compiler:2.6'</span></span> compile <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger:2.6'</span></span> }</code> </pre> <br>  Everything, the project can be compiled and executed.  If you want to try to do it yourself, the source code for our example is <a href="https://github.com/iSoron/dagger2-examples">available on Github</a> . <br><br>  As a conclusion.  Please note: we can still use any class without the Dagger, as before.  For example, we can still initialize the <i>Logger</i> manually using the <i>new</i> operator, for example, in a unit test.  Dagger does not change the behavior of the language, it simply generates convenient classes that initialize objects for us. <br><br>  In the next article in this series, we will see what happens when the same dependency can be used in multiple classes or when we cannot annotate a class for some reason. <br><br><h3>  What to read </h3><br>  If dependency injection seems like a useless technique, or you want to see more examples when DI simplifies testing, take a look at Mi≈°ko Hevery, Russ Ruffer and Jonathan Wolter‚Äôs amazing <a href="http://misko.hevery.com/code-reviewers-guide/">Writing Testable Code</a> ( <a href="http://misko.hevery.com/attachments/Guide-Writing%2520Testable%2520Code.pdf">pdf</a> ). <br><br>  If you are more interested in the theory of introducing dependencies and all its varieties, I recommend the essay <a href="http://www.martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection Pattern</a> (translated into Russian - <a href="http://yugeon-dev.blogspot.ru/2010/07/inversion-of-control-containers-and_21.html">Part 1</a> , <a href="http://yugeon-dev.blogspot.ru/2010/07/blog-post.html">Part 2</a> ) by Martin Fowler. <br><br>  To be continued ... <br><br>  <a href="https://medium.com/%40isoron/a-friendly-introduction-to-dagger-2-part-1-dbdf2f3fb17b">Original article</a> </div><p>Source: <a href="https://habr.com/ru/post/307434/">https://habr.com/ru/post/307434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307424/index.html">Cat-and-mouse game: how anti-spam was created in Mail.Ru Mail and what does Tarantool have to do with it</a></li>
<li><a href="../307426/index.html">Moving to the cloud: how modern companies use the benefits of IP telephony</a></li>
<li><a href="../307428/index.html">Creating levels using the Super Mario World method</a></li>
<li><a href="../307430/index.html">ProjectSauron: cyber spyware hacking into encrypted communication channels of state organizations</a></li>
<li><a href="../307432/index.html">Lead from the fields: who and how applied qualitative methods in UX Research to develop IT products. Part 3 of 6</a></li>
<li><a href="../307436/index.html">Cisco OpenDNS in every home</a></li>
<li><a href="../307438/index.html">On the hunt for "insects": the program bug bounty in Odnoklassniki</a></li>
<li><a href="../307440/index.html">Lead from the fields: who and how applied qualitative methods in UX Research to develop IT products. Part 4 of 6</a></li>
<li><a href="../307442/index.html">Lead from the fields: who and how applied qualitative methods in UX Research to develop IT products. Part 5 of 6</a></li>
<li><a href="../307444/index.html">Lead from the fields: who and how applied qualitative methods in UX Research to develop IT products. Part 6 of 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>