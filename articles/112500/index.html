<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>XSD: partial validation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="XSD is a language for describing the structure of an XML document. It is also called XML Schema. When using XML Schema, an XML parser can verify not o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>XSD: partial validation</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/xml/90696/">XSD</a> is a language for describing the structure of an XML document.  It is also called XML Schema.  When using XML Schema, an XML parser can verify not only the correctness of the XML document syntax, but also its structure, content model, and data types.  Many one way or another came across a full validation procedure to ensure that the document conforms to a given scheme or to report possible errors.  This article will deal with partial validation, in addition to the above, which allows the construction of valid documents on the fly.  We will understand what opportunities this approach and ways of its implementation can provide. <br><a name="habracut"></a><br><br><h4>  the main goal </h4><br>  Why in general it may be necessary to construct a document with specified properties, and what properties can we control?  The answer to the first question is almost obvious;  most documents are not just text, but endowed with some semantics.  XML solves the problem of syntactic representation, and the schema partially solves the question of semantic meaning.  Due to the document‚Äôs compliance with the scheme, it is possible to perform over it a set of predefined actions that are permissible for a whole class of valid documents, be it in a different format, export a significant part of information for a specific task, import new information, taking into account global constraints.  The most commonly used mechanism in this case is the XSLT transformation, the meaning of which can be illustrated by the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1d/630/01c/b1d63001c99579dd3958524fc0f3bfa0.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <a href="http://citforum.ru/internet/xml/scheme/">specification of the scheme</a> will completely answer the second question, and we will only dwell on the most important points that give an idea of ‚Äã‚Äãthe capabilities of the schemes.  So, the scheme allows: <br><ul><li>  Strictly control the typing of data nodes and attributes; </li><li>  Determine the order of the nodes, to monitor the presence of mandatory nodes and attributes; </li><li>  Require uniqueness of elements in a given context; </li><li>  Create variant nodes that require the presence of some attributes or others, depending on the context; </li><li>  Require the execution of a specific predicate on a group of nodes or attributes. </li></ul><br>  As a simple example, the article‚Äôs table of contents can be given - the schema can be used to specify the semantics of the data ‚Äútitle - page‚Äù, check that the pages are ascending, that there are no identical names, that the predefined element ‚ÄúIntroduction‚Äù goes to the ‚ÄúLiterature list‚Äù and is required, if there is element "Conclusion".  The most complex and powerful example is <a href="http://www.elbib.ru/index.phtml%3Fpage%3Delbib/rus/methodology/xmlbase/tutorial">XML databases</a> , where both the typification and validity of data are determined solely by schemas. <br><br>  Often there is a desire to modify the document, which already corresponds to the chosen scheme, so that it does not lose validity.  Here we are talking about automatic modifications, for example, adding web agents (aggregators) to information in a document or modifying queries in an XML database, as well as manual modification, for example, in a visual XML editor.  The operation of full validation for large documents can take significant time, tens of seconds or more, which generally prevents the use of the ‚Äúatomic change - check - reject / permit‚Äù approach.  And for visual editors, I would like even more - to be able not only to check the atomic action, but to offer all the options for modifying a specific node that are valid under the scheme.  However, <a href="http://habrahabr.ru/blogs/development/100949/">good XML editors</a> can do this, and we will try to figure out how they do it. <br><br><h4>  Required XML Schema Information </h4><br>  The W3C XML Schema is an evolution of the <a href="http://ru.wikipedia.org/wiki/DTD">XML DTD</a> (Document Type Definition) idea.  Both standards describe the document scheme through a set of declarations (parameter objects, elements, and attributes) that describe its class (or type) in terms of the syntactical limitations of this document.  The DTD considers a set of regular expressions over atomic terms or elements of a type dictionary.  Each type is built on the basis of other types, atomic terms and alternative operations ‚Äú|‚Äù, concatenation ‚Äú,‚Äù and operators ‚Äú?‚Äù, ‚Äú+‚Äù, ‚Äú*‚Äù, Meaning optional, presence of one-or-more or zero-or-more items.  XML schema differs from XML DTD syntax, and extends DTD functionality in three ways: <br><ul><li>  Templates (any, anyType, anyAttribute), allowing to use any element corresponding to the specified namespace; </li><li>  The substitution groups that define a set of types that can be used instead of a specific type declaration; </li><li>  The number of repetitions, which determines for each element the minimum and maximum allowable number of its occurrences in the type (generalization of the Kleene operators: "*", "+"). </li></ul><br>  Algorithmically, the validation according to the scheme is a more complicated task than the corresponding task for the DTD [1], but the later standard for describing XML schemas is supplemented by a rule that essentially facilitates validation. <br><br>  The <a href="http://en.wikipedia.org/wiki/Unique_Particle_Attribution">Unique Particle Attribution</a> (unambiguous definition of particles) rule requires that each element of the document uniquely corresponds to exactly one xsd: element or xsd: any particle in the content model of the parent element [2]. <br><br>  Generally speaking, the Unique Particle Attribution (UPA) rule is not a strict requirement for the structure of XML schemas, but only a highly desirable recommendation and some of the schemes used do not correspond to it.  Let us consider the simplest example illustrating the violation of the rule of unambiguous determination of particles. <br><br>  We define the scheme as follows: <br> <code>&lt;xsd:element name="root"&gt; <br> &lt;xsd:complexType&gt; <br> &lt;xsd:choice&gt; <br> &lt;xsd:element name="e1"/&gt; <br> &lt;xsd:any namespace="##any"/&gt; <br> &lt;/xsd:choice&gt; <br> &lt;/xsd:complexType&gt; <br> &lt;/xsd:element&gt; <br></code> <br>  Then an XML document consisting of one element proves a violation of the uniqueness rule;  An element can be mapped to both the xsd: elment and xsd: any branches at the same time. <br>  Fortunately, most ready-made schemes follow the UPA rule.  Further reasoning will be true only if the scheme complies with the UPA rule, but in general, with minor modifications of the reasoning, it is possible to achieve correctness also on incompatible UPA schemes, due to the loss of speed. <br><br><h4>  Building a validator </h4><br>  To begin with, we will define elementary changes in the structure, which we will check for correctness: <br><ul><li>  ADD: creating a sub-element with type x at position n; </li><li>  REMOVE: deletes the subitem at position n; </li><li>  MOVE: moving an element from position n to position m (although the transfer is reduced to performing deletion and addition of elements, but an intermediate state may violate the validity of the document). </li></ul><br>  Now we describe the content model of a complex schema type: <br><ul><li>  Particle: <br>  ‚Ä¢ MinOccurs - the minimum number of repetitions of a term (if 0, then the term becomes optional); <br>  ‚Ä¢ MaxOccurs - the maximum number of repetitions of a term (infinity is allowed - inf). <br>  ‚Ä¢ Term: element description, pattern, sequence or selection; <br></li><li>  Item Description (typedef): <br>  ‚Ä¢ Local name; <br>  ‚Ä¢ Namespace name (may be omitted, then the element is considered valid in any namespace); <br>  ‚Ä¢ Substitution group - the set of all elements taken in expressions containing typedef; <br></li><li>  Template (any): <br>  ‚Ä¢ Name of the namespace valid for the substitution element (may be absent); <br></li><li>  Sequence (sequence): <br>  ‚Ä¢ Consecutive listing of permissible particles; <br></li><li>  Choice (choice): <br>  ‚Ä¢ Set of permissible particles. <br></li></ul><br>  You can go directly to the validation algorithm.  The first necessary action is the construction of the correspondence ‚Äútype of scheme‚Äù -&gt; ‚Äúan automaton that is able to check the descendants of an element of this type for validity‚Äù.  The task is reduced to two recursive actions: <br><br>  1. Construction of a <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">non-deterministic finite automaton</a> (NFA) with a given final state S on a given particle: <br>  a.  Set the initial state n to S; <br><br>  b.  If the MaxOccurs particle is infinity (inf): <br>  ‚Ä¢ Add a new intermediate state t;  derived from term conversion to NFA (case 2);  add epsilon edges from t to n and from n to s: <br><img src="https://habrastorage.org/getpro/habr/post_images/573/4b3/dad/5734b3dad052b9bb2ea60f78c60068cb.png" alt="image"><br><br>  c.  If the MaxOccurs particles are the number m: <br>  ‚Ä¢ Build a chain of (MaxOccurs-MinOccurs) term transformations, starting from the final state S, adding epsilon-edge from the intermediate state at each step to the final state S; <br>  For example, for MaxOccurs = 4 and MinOccurs = 2 we get the following automaton: <br><img src="https://habrastorage.org/getpro/habr/post_images/54c/f09/078/54cf09078d8a4918061dc7511b187671.png" alt="image"><br><br>  d.  We complete the minOccurs copies of the term transformation from the new initial state n, to the initial state obtained in the previous steps. <br><br>  2. Construction of a non-deterministic finite automaton with a given receiving state S for a given term: <br>  a.  If term is a template (any): <br>  ‚Ä¢ Create a new state b, and connect it with S edge marked type of term, return b; <br><br>  b.  If term is the item description: <br>  ‚Ä¢ Create a new state b, then for each element of the permutation group create an edge from b to S, marked with the element type and return b; <br><br>  c.  If term is a choice: <br>  ‚Ä¢ Create a new state b, create an automaton for each choice (case 1) and connect it with epsilon edges with state b and state S. Return b; <br><br>  d.  If term is a sequence: <br>  ‚Ä¢ For each selection element, we create an automaton (case 1) and connect the resulting automata in the reverse order, starting with state S, and return the first state in the chain; <br><br>  Then we apply <a href="http://neerc.ifmo.ru/mediawiki/index.php/%25D0%259F%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%259D%25D0%259A%25D0%2590_%25D1%258D%25D0%25BA%25D0%25B2%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BB%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%2594%25D0%259A%25D0%2590,_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25A2%25D0%25BE%25D0%25BC%25D0%25BF%25D1%2581%25D0%25BE%25D0%25BD%25D0%25B0">the Thompson algorithm</a> to the obtained NFA [3], to build deterministic automata.  The Thompson algorithm can be applied in the same cases as the algorithm for constructing the deterministic automaton Aho and Ullman, based on folding the equally marked non-epsilon edges [4].  However, in some cases, using the original automaton (created in steps 1‚Äì2), the Aho and Ulman algorithm cannot construct a deterministic automaton. <br><br>  This happens when there are two outgoing edges from the same vertex, such that: <br><ul><li>  Their labels are type descriptions with the same local names and namespace names; </li><li>  Their labels are template names, with overlapping areas; </li><li>  The label of one edge is a template, the other is a type description, both are in the same namespace, and the type description is included in the template area. </li></ul><br>  It is easy to show that each case corresponds to the violation of the UPA restriction (the third case has already been considered in the example of a scheme that violates the rule of single-valued determination of particles).  Thus, these points do not interfere with the correctness of the solution, and at the output of the algorithm we always get a deterministic finite automaton validating the content of elements of the corresponding type. <br><br>  We apply the proposed algorithm to each type of circuit and obtain a type -&gt; automaton that can check the descendants of an element of this type. <br><br>  It remains to solve the last problem - the choice of the desired state machine when validating operations on a given element of the tree.  With this, the validation type binding structure (PSVI, <a href="http://en.wikipedia.org/wiki/PSVI">Post-Schema-Validation Infoset</a> ), generated by almost any (for example, <a href="http://msdn.microsoft.com/en-us/library/616fabdz(v%3Dvs.71).aspx">MSXML</a> or libxml) full validator, will help us.  For any element of the tree, it points to the corresponding type in the description of the scheme - exactly the one according to which we generated the necessary automaton. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d99/336/2e8/d993362e866fdad7d81cbd4f0f652be2.png" alt="image"><br><br>  In our case, the implementation of the PSVI structure is represented by a reference to the type of scheme for each element of the tree. <br><br>  The MOVE and REMOVE operations do not change the type of the operand (therefore, they do not require changing the PSVI structure), and the ADD operation, together with the addition of the x element, will require adding the x type to the PSVI structure.  Thus, together with the change in the structure, we change the information set of the validation type binding, solving the partial validation problem and maintaining the PSVI tree without calling the external validator. <br><br><h4>  Comparison of results </h4><br>  Generally speaking, there will be no direct comparison - after all, we have described an add-in that solves a particular task (ADD / REMOVE / MOVE operations) in a particular case (UPA compliance), but I want to show that in this case it gives a significant speed increase regarding the attempt to use full validation .  MSXML6 was chosen as the reference validator generating PSVI, therefore we will compare it with its operation time. <br><table><tbody><tr><td>  The number of elements of the structure </td><td>  Nesting levels </td><td>  Number of schema types </td><td>  Average validation time of MSXML6 </td><td>  Average validation time using the described add-in </td></tr><tr><td>  32 </td><td>  four </td><td>  sixteen </td><td>  10 ms </td><td>  &lt;1 ms </td></tr><tr><td>  32 </td><td>  four </td><td>  40 </td><td>  16 ms </td><td>  &lt;1 ms </td></tr><tr><td>  120,000 </td><td>  four </td><td>  sixteen </td><td>  51 ms </td><td>  &lt;2 ms </td></tr><tr><td>  120,000 </td><td>  four </td><td>  40 </td><td>  62 ms </td><td>  &lt;2 ms </td></tr><tr><td>  120,000 </td><td>  32 </td><td>  sixteen </td><td>  2300 ms </td><td>  &lt;5 ms </td></tr><tr><td>  120,000 </td><td>  32 </td><td>  40 </td><td>  2600 ms </td><td>  &lt;6 ms </td></tr></tbody></table><br>  Thus, we obtained a quite admissible average waiting time for checking, which allows implementing the Drag'n'Drop mechanism ‚Äúon the fly‚Äù in the visual editor, and providing a good number of requests per second for a possible XML database. <br><br><h4>  Links </h4><br>  [1] XML Schema Validator.  Thompson, Henry S. and R. Tobin, W3C and University of Edinburgh, 2003. <br>  [2] <a href="http://www.w3.org/TR/xmlschema-1">XML Schema Part 1: Structures.</a>  <a href="http://www.w3.org/TR/xmlschema-1">Henry S. Thompson, David Beech, Murray Maloney, Noah Mendelsohn, editors.</a>  <a href="http://www.w3.org/TR/xmlschema-1">W3C Recommendation, 2001.</a> <br>  [3] <a href="http://swtch.com/~rsc/regexp/regexp1.html">Regular Expression Matching Can Be Simple And Fast.</a>  <a href="http://swtch.com/~rsc/regexp/regexp1.html">Russ Cox, 2007.</a> <br>  [4] Principles of building compilers.  A. Aho.  D. Ullman.  M .: Mir, 1977. </div><p>Source: <a href="https://habr.com/ru/post/112500/">https://habr.com/ru/post/112500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112493/index.html">Breaking safes with brute force</a></li>
<li><a href="../112495/index.html">Code editor with syntax highlighting of popular languages ‚Äã‚Äã- Touchqode</a></li>
<li><a href="../112496/index.html">Confines of privacy</a></li>
<li><a href="../112497/index.html">Sony Ericsson Xperia Arc - first impressions</a></li>
<li><a href="../112499/index.html">Information technology in medicine</a></li>
<li><a href="../112502/index.html">Fully touchscreen concept</a></li>
<li><a href="../112503/index.html">Satellite running Android OS</a></li>
<li><a href="../112507/index.html">A lot of useful pieces for AS3 # 2</a></li>
<li><a href="../112511/index.html">220V device control via LPT port (full creation cycle)</a></li>
<li><a href="../112514/index.html">Mark Russinovich wrote a new book</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>