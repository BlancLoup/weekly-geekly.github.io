<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about type casting in C ++ or the arrangement of all points above the cast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is an attempt to summarize everything I read or heard from various sources about type conversion operators in C ++. Information is focused m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about type casting in C ++ or the arrangement of all points above the cast</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/39f/2cb/6ba/39f2cb6bad01443faeeda391a0601689.jpg" align="left"><br><br>  This post is an attempt to summarize everything I read or heard from various sources about type conversion operators in C ++.  Information is focused mainly on those who study C ++ for a relatively short time and, it seems to me, should help to understand the specific use of these operators.  Old-timers and C ++ gurus may help to complement or correct the picture I have described.  I invite everyone interested under the cat. <a name="habracut"></a><br><br>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><br><br><hr><br><h4>  <b>Type casting in the C language style (C-style cast)</b> </h4><br>  A type conversion in the C language style can result in the expression of any type to any other data type (the exception is casting custom types by value if the rules for casting are not defined, and also casting a real type to a pointer or vice versa).  For example, an unsigned int can be converted to a pointer to a double.  This type conversion method can be used in the C ++ language.  However, the C-style type conversion method does not check type compatibility, as static_cast and dynamic_cast can do at the compilation stage and at the execution stage, respectively.  In this case, all that const_cast and reinterpret_cast can do this type conversion method can do. <br><br>  General view of the cast: <br><br>  <i>(new_type) exp</i> <br><br>  where <i>new_type</i> is a new type to which we are <i>casting</i> , and <i>exp</i> is an expression that is being <i>cast</i> to a new type. <br><br>  Since  This operator does not have a reserved keyword (for example, static_cast). It will not be very convenient to find all type conversions in the program text if it is required. <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;iostream&gt; //   //   struct AAA{ }; struct BBB{ }; // BBB struct BBB_X:BBB{ }; struct BBB_Y:BBB{ }; int main() { //         int i = 5; double d = 111.222; char c = 'a'; int* pi = &amp;i; double * pd = &amp;d; const int* cpi = &amp;i; void* v = NULL; //  AAA A; BBB B; BBB_X BX; BBB_Y BY; //    AAA* pA = &amp;A; BBB* pB = &amp;B; BBB_X* pBX = &amp;BX; BBB_Y* pBY = &amp;BY; //  double  int i = (int)d; //  d = (double)i; //  int  char c = (char)pi; //char    void v = (void*)c; //  void    int pi = (int*)v; //  const int* pi = (int *) cpi; //    AAA     BBB //   pA = (AAA*) pB; //   double  double d = (double)pd;//!!! //  ? pd = (double*)d;//!!! //       pB = (BBB*)pBX; pBY = (BBB_Y*) pB; return 0; }</code> </pre> <br></div></div><br><hr><br><h4>  <b>const_cast</b> </h4><br>  The cast operator const_cast removes or adds const and volatile qualifiers from the original data type (simple types, custom types, pointers, references).  For example, there was a const int, and after conversion it became an int or vice versa.  The const and volatile qualifiers are called cv qualifiers (cv-qualifiers).  These qualifiers are specified before type names.  No matter how hard it is to guess the const qualifier sets constancy, i.e.  protects a variable from change.  The volatile qualifier says that the value of a variable can change without explicit assignment.  This provides protection from compiler optimization of operations with this variable. <br><br>  General view of the cast: <br><br>  <i>const_cast &lt;new_type&gt; (exp)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; //  void test_func_X(const int* in1, const int&amp; in2) { int *p; //    33 p = const_cast&lt;int*&gt;(in1); *p = 33; //    55 const_cast&lt;int&amp;&gt;(in2) = 55; } //  void test_func_Y(int* in1, int&amp; in2) { const int *p; //  //   33 p = const_cast&lt;const int*&gt;(in1); *p = 33;// !!! //   //   33 const_cast&lt;const int&amp;&gt;(in2) = 55;//!!! } // volatile void test_func_Z(volatile int* in1, volatile int&amp; in2) { int *p; // volatile   33 p = const_cast&lt;int*&gt;(in1); *p = 33; // volatile   55 const_cast&lt;int&amp;&gt;(in2) = 55; } // volatile void test_func_A(int* in1, int&amp; in2) { volatile int *p; // volatile   33 p = const_cast&lt;volatile int*&gt;(in1); *p = 33; // volatile   55 const_cast&lt;volatile int&amp;&gt;(in2) = 55; } int main() { int x=3,y=5; std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; //  test_func_X(&amp;x,y); std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; x=3; y=5; //  test_func_Y(&amp;x,y);//!!! std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; // volatile test_func_Z(&amp;x,y); std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; x=3; y=5; std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; // volatile test_func_A(&amp;x,y); std::cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;std::endl; system("pause"); return 0; }</code> </pre><br></div></div><br>  An additional example from <a href="https://habr.com/ru/users/5nw/" class="user_link">5nw</a> <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; using namespace std; void f(int *x) { cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl; } void f(const int *x) { cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl; } int main() { int x = 5; int *px = &amp;x; f(px); f(const_cast&lt;const int*&gt;(px)); return 0; }</code> </pre><br></div></div><br>  The const and volatile qualifiers can be removed or added only using the cast operator const_cast and type-C casting. Other type casting operators do not affect the const and volatile qualifiers (reinterpret_cast, static_cast, dynamic_cast). <br><hr><br><h4>  <b>reinterpret_cast</b> </h4><br>  The cast operator reinterpret_cast is used to cast incompatible types.  It can result in an integer to a pointer, a pointer to an integer, a pointer to a pointer (the same applies to links).  It is a functionally truncated analogue of type conversion in the C language style. The difference is that the reinterpret_cast cannot remove const and volatile qualifiers, and also cannot make unsafe type conversion not directly via pointers, but directly by value.  For example, a variable of type int to a variable of type double cannot be cast using reinterpret_cast. <br><br>  General view of the cast: <br><br>  <i>reinterpret_cast &lt;new_type&gt; (exp)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; //   //   struct AAA{ }; struct BBB{ }; // BBB struct BBB_X:BBB{ }; struct BBB_Y:BBB{ }; int main() { //         int i = 5; double d = 111.222; char c = 'a'; int* pi = &amp;i; double * pd = &amp;d; const int* cpi = &amp;i; void* v = NULL; //  AAA A; BBB B; BBB_X BX; BBB_Y BY; //    AAA* pA = &amp;A; BBB* pB = &amp;B; BBB_X* pBX = &amp;BX; BBB_Y* pBY = &amp;BY; //  double  int i = reinterpret_cast&lt;int&gt;(d);//!!! //  /d = reinterpret_cast&lt;int&gt;(i);//!!! //  int  char c = reinterpret_cast&lt;char&gt;(pi); //char    void v = reinterpret_cast&lt;void*&gt;(c); //  void    int pi = reinterpret_cast&lt;int*&gt;(v); //  const int* pi = reinterpret_cast&lt;int *&gt;(cpi);//!!! //    AAA     BBB //   pA = reinterpret_cast&lt;AAA*&gt;(pB); //   double  double d = reinterpret_cast&lt;double&gt;(pd);//!!! //  ? pd = reinterpret_cast&lt;double*&gt;(d0;//!!! //       pB = reinterpret_cast&lt;BBB*&gt;(pBX); pBY = reinterpret_cast&lt;BBB_Y*&gt;(pB); return 0; }</code> </pre><br></div></div><br><hr><br><h4>  <b>static_cast</b> </h4><br>  The cast operator static_cast is used for non-polymorphic type casting at the compilation stage of a program.  The difference between static_cast and C-style type casting is that this cast operator can track invalid conversions, such as casting a pointer to a value or vice versa (unsigned int to a pointer to a double will not result), and casting pointers and links of different types is considered only valid if it is a coercion of up or down one class inheritance hierarchy, or it is a pointer to void.  In case of fixing deviations from these restrictions, an error will be generated when compiling the program.  In case of multiple inheritance, static_cast can return a pointer not to the source object, but to its sub-object. <br><br>  General view of the cast: <br><br>  <i>static _cast &lt;new_type&gt; (exp)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; //   //   struct AAA{ }; struct BBB{ }; // BBB struct BBB_X:BBB{ }; struct BBB_Y:BBB{ }; int main() { //         int i = 5; double d = 111.222; char c = 'a'; int* pi = &amp;i; double * pd = &amp;d; const int* cpi = &amp;i; void* v = NULL; //  AAA A; BBB B; BBB_X BX; BBB_Y BY; //    AAA* pA = &amp;A; BBB* pB = &amp;B; BBB_X* pBX = &amp;BX; BBB_Y* pBY = &amp;BY; //  double  int i = static_cast&lt;int&gt;(d); //  d = static_cast&lt;int&gt;(i); //  int  char c = static_cast&lt;char&gt;(pi);//!!! //char    void v = static_cast&lt;void*&gt;(c);//!!! //  void    int pi = static_cast&lt;int*&gt;(v); //  const int* pi = static_cast&lt;int *&gt;(cpi);//!!! //    AAA     BBB //   pA = static_cast&lt;AAA*&gt;(pB);//!!! //   double  double d = static_cast&lt;double&gt;(pd);//!!! //  ? pd = static_cast&lt;double*&gt;(d0);//!!! //       pB = static_cast&lt;BBB*&gt;(pBX); pBY = static_cast&lt;BBB_Y*&gt;(pB); return 0; }</code> </pre><br></div></div><br><hr><br><h4>  <b>dynamic_cast</b> </h4><br>  The cast operator dynamic_cast is used for polymorphic type casting at the program execution stage (a class is considered polymorphic if it contains at least one virtual function).  If the pointer to be cast refers to an object of the resulting class or an object of the class derived from the resulting one, then the cast is considered successful.  Same for links.  If casting is not possible, then at the program execution stage, NULL will be returned if pointers are given.  If casting over links, an exception std :: bad_cast will be generated.  Despite the fact that dynamic_cast is intended to bring polymorphic types according to the inheritance hierarchy, it can also be used for ordinary non-polymorphic types up through the hierarchy.  In this case, the error will be received at the compilation stage.  The dynamic_cast cast operator will result in a pointer to void, but it cannot cast a pointer to void to another type.  The ability dynamic_cast lead polymorphic types provided by the system RTTI (Run-Time Type Identification), which allows you to identify the type of object during program execution.  With multiple inheritance, dynamic_cast can return a pointer not to the source object, but to its sub-object. <br><br>  General view of the cast: <br><br>  <i>dynamic_cast &lt;new_type&gt; (exp)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Show example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; //   //   struct AAA{ //  virtual void do_some(){}; }; struct BBB{ //  virtual void do_some(){}; }; // BBB struct BBB_X:BBB{ }; struct BBB_Y:BBB{ }; int main() { //         void* v = NULL; //  AAA A; BBB B; BBB_X BX; BBB_Y BY; //    AAA* pA = &amp;A; BBB* pB = &amp;B; BBB_X* pBX = &amp;BX; BBB_Y* pBY = &amp;BY; //    AAA     BBB //   pA = dynamic_cast&lt;AAA*&gt;(pB); if (pA == NULL) { std::cout&lt;&lt;"FAIL"&lt;&lt;std::endl;//   !!! } //   void     BBB pB = dynamic_cast&lt;AAA*&gt;(v); //   !!! //   BBB    void v = dynamic_cast&lt;void*&gt;(pB); //       pB = dynamic_cast&lt;BBB*&gt;(pBX); pBY = dynamic_cast&lt;BBB_Y*&gt;(pB); if (pBY == NULL) { std::cout&lt;&lt;"FAIL"&lt;&lt;std::endl;//   !!! } system("pause"); return 0; }</code> </pre><br></div></div><br><hr><br><h5>  <i>Sources:</i> </h5><br>  <a href="https://www.lektorium.tv/lecture/13733">Video lecture by Evgeny Linsky from the project Lectorium</a> <br>  <a href="http://alenacpp.blogspot.ru/2005/08/c.html">Blog Alena C + +</a> <br>  <a href="http://habrahabr.ru/post/106294/">This post @dreary_eyes</a> <br>  <a href="http://www.ozon.ru/context/detail/id/1498452/">"A complete guide to C ++" Herbert Shildt</a> <br>  <a href="http://www.ozon.ru/context/detail/id/2576269/">‚ÄúDesign and evolution of the C ++ language‚Äù by Bjorn Straustrup</a> <br><hr><br><h5>  <i>Source:</i> </h5><br>  <a href="https://isocpp.org/std/the-standard">C ++ Standard ($ 212 price)</a> <br>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">Free working draft of the C ++ N3337 standard</a> <br><hr><br><h5>  <i>Additionally:</i> </h5><br>  <a href="http://habrahabr.ru/post/164193/">Image taken from post @ SOLON7</a> <br><hr></div><p>Source: <a href="https://habr.com/ru/post/266747/">https://habr.com/ru/post/266747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266731/index.html">Run a mega-manual from Stackoverflow</a></li>
<li><a href="../266733/index.html">Why SMS is limited to 160 characters, and Twitter messages - 140 characters?</a></li>
<li><a href="../266735/index.html">Snaql. Raw SQL in Python projects</a></li>
<li><a href="../266743/index.html">Python 3.5; async / await</a></li>
<li><a href="../266745/index.html">Vim-like control with xmodmap</a></li>
<li><a href="../266749/index.html">Group the same applications from different stores by icon</a></li>
<li><a href="../266753/index.html">Walking across tiles</a></li>
<li><a href="../266757/index.html">With 100,000,000 days a year</a></li>
<li><a href="../266759/index.html">PostgreSQL 9.5: what's new? Part 2. TABLESAMPLE</a></li>
<li><a href="../266761/index.html">Managing complexity in ruby ‚Äã‚Äãon rails projects. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>