<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visitor pattern. Advanced use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habravchane! 

 I want to share with you my experience of using the visitor design pattern and its interesting modification, which I calle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visitor pattern. Advanced use</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habravchane! <br><br>  I want to share with you my experience of using the visitor design pattern and its interesting modification, which I called the upcast visitor.  Unfortunately, it is not easy to come up with a simple short example and describe how everything works, this article may also seem difficult for beginners, however I will try to simplify the task as much as possible.  Code examples are given in C ++ and are required to be read.  Without understanding the code, it will be difficult to grasp the essence of the article. <br><br><h3>  Prehistory </h3><br>  Imagine that we are designing a 2D game in which fruit falls from a tree, hitting the branches along the way.  The goal of the game is to catch all the fruits by moving the basket under the tree. <br>  Build the following class diagram: <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage1/086d839c/78fd3dc1/7aae1295/e88292fd.png"><br>  Following the principles of OOP, we declare a virtual drawing function in the base class and override it in all derivatives (except for the class Fruit). <br><img src="https://habrastorage.org/storage1/0d0a96de/fa6524f7/d7c34841/0384cf28.png"><br>  For example, this is the code responsible for drawing an apple: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Apple::draw() { Graphics&amp; graphics = GetGraphicsFromSomeMagicalPlace(); Texture&amp; texture = GetAppleTextureFromEvenMoreMagicalPlace(); graphics.draw(texture, x(), y(), angle()); }</code> </pre> <br>  Our main drawing method, which is called in the game loop, looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::draw(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;&amp; allObjects) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;::iterator it = allObjects.begin(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;::iterator end = allObjects.end(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(it != end) { (*it)-&gt;draw(); ++it; } }</code> </pre> <br>  Woo!  Polymorphism is cool, we think and continue to write the game.  We want to portray the fall realistically, so we decide to use the <a href="http://box2d.org/">Box2D</a> library.  Some classes from the diagram need to have a pointer to an object from Box2D, but not all.  For example, the Tree class does not need such functionality; its task is only to draw itself and store information about the amount of fruit.  Therefore, we will not put this pointer into the base Object class, but create an intermediate class Box2DObject, after which our diagram will look like this (only the upper part of the diagram is shown): <br><img src="https://habrastorage.org/storage1/1160968b/c66165c3/f8e416aa/9aec184d.png"><br>  The code responsible for creating b2Body objects will be in the constructor of each derived class, and the code responsible for deleting will be in the destructor.  Take for example the Branch class: <br><pre> <code class="cpp hljs">Branch::Branch() { b2BodyDef bodyDef; bodyDef.type = b2_staticBody; b2Body* body = GetBox2DWorldFromSomewhrere().CreateBody(&amp;bodyDef); b2PolygonShape shape; shape.SetAsBox(BRANCH_WIDTH, BRANCH_HEIGHT); b2FixtureDef fixtureDef; fixtureDef.shape = &amp;shape; fixtureDef.friction = BRANCH_FRICTION; fixtureDef.restitution = BRANCH_RESTITUTION; body-&gt;CreateFixture(&amp;fixtureDef); m_box2dBody = body; body-&gt;SetUserData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } Branch::~Branch() { GetBox2DWorldFromSomewhrere().DestroyBody(m_box2dBody); }</code> </pre> <br>  Cool again, we think.  Although the concept of ‚Äúvirtuality‚Äù is not applicable for designers, it is still possible to draw an analogy with drawing - each class creates objects from Box2D in its own way. <br>  We notice that the deletion code will be the same for all classes derived from Box2DObject, so it is logical to move it to the Box2DObject destructor.  Like this: <br><pre> <code class="cpp hljs">Box2DObject::~Box2DObject() { GetBox2DWorldFromSomewhrere().DestroyBody(m_box2dBody); }</code> </pre> <br>  Also, the code for creating an orange and an apple is no different, therefore we transfer it to the constructor of the base class Fruit: <br><pre> <code class="cpp hljs">Fruit::Fruit() { b2BodyDef bodyDef; bodyDef.type = b2_dynamicBody; b2CircleShape shape; shape.m_radius = FRUIT_RADIUS; b2Body* body = GetBox2DWorldFromSomewhrere().CreateBody(&amp;bodyDef); b2FixtureDef fixtureDef; fixtureDef.shape = &amp;shape; fixtureDef.density = FRUIT_DENSITY; fixtureDef.friction = FRUIT_FRICTION; fixtureDef.restitution = FRUIT_RESTITUTION; body-&gt;CreateFixture(&amp;fixtureDef); m_box2DBody = body; body-&gt;SetUserData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Here, now everything seems to work, but there are several problems: <br>  - The code responsible for drawing and working with the Box2D library is randomly scattered across all classes. <br>  - Interfaces for working with graphics and Box2D need to be ‚Äúdragged‚Äù through a chain of constructors of hierarchy and saved in base classes (otherwise how to access them)? <br>  - With a large number of classes in the hierarchy, the code can be compiled much longer, because the header files for working with graphics and Box2D are included in each cpp file. <br>  - When adding a new functionality will have to modify all classes in the hierarchy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Visitor pattern </h3><br>  How to avoid these problems? <br>  Of course, you need to use the visitor design pattern!  If you are familiar with it, you probably already guessed that we will have visitor'y for drawing and for Box2D.  If you are not familiar - now you will understand everything, this is a very useful pattern, which I love to use. <br>  We need four new classes: Visitor, Painter, Creator and Destroyer: <br><img src="https://habrastorage.org/storage1/46349db2/f0f7a8e6/f8f23eb0/be4ae85a.png"><br>  All methods for working with graphics will go to Painter, and for working with Box2D - to Creator and Destroyer.  We also need to add the purely virtual accept method to the base Object class and implement it in all the leaves of the hierarchy. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Visitor&amp; visitor)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶Everything else };</span></span></code> </pre> <br>  The hierarchy after this will be: <br><img src="https://habrastorage.org/storage1/b2323ce0/9d1895d5/4016f2c7/28c8a42e.png"><br>  The implementation of the accept method is the same in absolutely all leaves and consists of one line. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Visitor&amp; visitor)</span></span></span><span class="hljs-function"> </span></span>{ visitor.visit(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Superhard to understand single line of code } //‚Ä¶Everything else };</span></span></code> </pre> <br>  When I first became acquainted with the visitor pattern, this line of code carried my brain and I did not understand anything.  A few months later I took the <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">book of the gang of four</a> and was able to master this pattern.  The point is that when the this pointer is dereferenced, the necessary function is selected from the Visitor interface (overloading by the type of parameter works).  In other words, when this string is called from the Tree class, we get into void visit (Tree &amp; tree), when called from Basket - we get into void visit (Basket &amp; basket).  And in every visitor, we are already doing what we want with the object.  For example, take drawing: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Painter::visit(Apple&amp; apple) { m_graphics.draw(m_appleTexture, apple.x(), apple.y(), apple.angle()); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Painter::visit(Tree&amp; tree) { m_graphics.draw(m_treeTexture, tree.x(), tree.y()); }</code> </pre>  Depending on the type of parameter, we draw an apple or a tree.  The same principle in the Creator class: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Creator::visit(Basket&amp; basket) { <span class="hljs-comment"><span class="hljs-comment">// Setup basket b2Body } void Creator::visit(Branch&amp; branch) { // Setup branch b2Body }</span></span></code> </pre> <br>  Our general drawing method, which is called from the game loop, will be: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::draw(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;&amp; allObjects) { Painter&amp; painter = GetPainter(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;::iterator it = allObjects.begin(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Object*&gt;::iterator end = allObjects.end(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(it != end) { (*it)-&gt;accept(painter); ++it; } }</code> </pre> <br>  When creating an object, we will need to visit it with a Creator, and when deleting, with a Destroyer.  I think it's better than putting code in a constructor and destructor. <br>  So, we solved all the problems that we have.  Now: <br>  - The code responsible for drawing, is in one file.  The other two files contain the code for working with the Box2D library. <br>  - Access to interfaces for working with graphics and Box2D is needed only from the classes Painter, Creator and Destroyer. <br>  - The code is compiled quickly, because the header files for working with graphics and Box2D are included only in painter.cpp, creator.cpp and destroyer.cpp. <br>  - When adding a new functionality will have to modify only Visitor'y.  The hierarchy classes remain the same. <br><br><h3>  UpcastVisitor Interlayer </h3><br>  Here we could finish and enjoy the work done, but we notice with horror that in several places we have duplicated code.  In the Destroyer class, all methods have the same appearance, for example, the same code is used for an apple and an orange: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroyer::visit(Apple&amp; apple) { m_box2dWorld.DestroyBody(apple.b2Body()); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroyer::visit(Orange&amp; orange) { m_box2dWorld.DestroyBody(orange.b2Body()); }</code> </pre> <br>  Attendance of all classes inherited from Box2DObject is implemented in Destroyer in the same way.  You have to bring duplicate code into the additional method visitBox2DObject and call it from everywhere: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroyer::visitBox2DObject(Box2DObject&amp; object) { m_box2dWorld.DestroyBody(object.b2Body()); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroyer::visit(Apple&amp; apple) { visitBox2DObject(apple); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroyer::visit(Orange&amp; orange) { visitBox2DObject(orange); }</code> </pre> <br>  And do not want to do this.  It would be desirable that instead of a heap of overloaded methods in the Destroyer class, which contain the same code, there was only one with the ‚Äúcorrect‚Äù type of parameter - Box2DObject.  And so that it works for Apple, Orange, Basket, etc., for example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Destroyer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Visitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Box2DObject&amp; object)</span></span></span><span class="hljs-function"> </span></span>{ m_box2dWorld.DestroyBody(object.b2Body()); } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Take the risk and add this method to the base class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Box2DObject&amp; object)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ };</span></span></code> </pre> <br>  Unfortunately, it will never be called, because in the Box2DObject class there is no implementation of the accept method.  And even if it were, it would be overloaded in derived classes and the result would be the same - the visit method with the parameter type Box2DObject would never be called.  Then the idea of ‚Äã‚Äãa visitor-a layer between the base class Visitor and the classes Creator and Destroyer came to my mind.  I called this layer UpcastVisitor.  This is how the hierarchy of our visitor changes: <br><img src="https://habrastorage.org/storage1/9896eac1/dacb97e9/e57563a3/baeab0ef.png"><br>  Now the most important thing is the code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Object&amp; object) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Box2DObject&amp; object) { visit(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Object&amp;&gt;(object)); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Fruit&amp; fruit) { visit(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Box2DObject&amp;&gt;(fruit)); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Apple&amp; apple) { visit(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Fruit&amp;&gt;(apple)); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Orange&amp; orange) { visit(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Fruit&amp;&gt;(orange)); }</code> </pre>  If an Apple object is sent to UpcastVisitor, it leads it to the Fruit type, then to the Box2DObject type and at the very end to the Object type.  By the same principle, each visited class in UpcastVisitor goes through the chain of hierarchy to the most basic one.  Now we inherit the class Destroyer from UpcastVisitor and rejoice!  If UpcastVisitor is implemented correctly, then we need to overload only one method. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Destroyer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UpcastVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Box2DObject&amp; object)</span></span></span><span class="hljs-function"> </span></span>{ m_box2dWorld.DestroyBody(object.b2Body()); } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><br>  UpcastVisitor will also come in handy for you in the Creator class, because the Box2D entity creation code is the same for apple and orange: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UpcastVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Fruit&amp; fruit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Setup fruit's Box2D body } // ‚Ä¶ };</span></span></code> </pre> <br>  Perfectly.  Very easy life.  One small drawback - you need to keep track of the UpcastVisitor class, which is not so difficult.  Unfortunately, you can never completely get rid of shortcomings in your program, you can only choose and leave the smallest of them. <br><br>  If you already use the visitor pattern, and you have a similar situation, you can safely create the UpcastVisitor class.  It's very simple, you just need to add methods to visit all intermediate types in the base class Visitor, as well as monitor and update UpcastVisitor as new types appear in the hierarchy.  Well, inherit from it as needed. <br><br>  Thanks for attention!  I hope this article will be useful to someone! <br><br>  <b>Update</b> : <br>  <a href="http://habrahabr.ru/blogs/programming/133183/">7vies</a> suggests that in UpcastVisitor you can get rid of static_cast as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpcastVisitor::visit(Box2DObject&amp; object) { Object&amp; o = object; visit(o); }</code> </pre> <br>  Thanks for the helpful advice! </div><p>Source: <a href="https://habr.com/ru/post/133183/">https://habr.com/ru/post/133183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133173/index.html">Banking Trojan Carberp acquires bootkit functionality</a></li>
<li><a href="../133174/index.html">Future plans for Enot tablets</a></li>
<li><a href="../133175/index.html">Startup Battle is waiting for its members!</a></li>
<li><a href="../133176/index.html">WebService with gzip C support</a></li>
<li><a href="../133179/index.html">Startup Weekend Report in Haifa</a></li>
<li><a href="../133184/index.html">How corporate-secret becomes publicly explicit</a></li>
<li><a href="../133189/index.html">New TileMill Release</a></li>
<li><a href="../133191/index.html">Integration of JavaScript cookies into CURL requests</a></li>
<li><a href="../133193/index.html">‚ÄúEvolution of Development‚Äù // Reports from the Mail.Ru Technology Forum 2011: text of the report, video, presentation</a></li>
<li><a href="../133194/index.html">Another promotion Humble Bundle. This time with games from Introversion Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>