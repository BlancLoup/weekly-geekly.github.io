<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>First Steps with Stellaris LM4F120 launchpad evaluation board</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The board of Stellaris LM4F120, which I finally decided to figure out, was dumped in my desk. We will write a program that turns on / off the LEDs ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>First Steps with Stellaris LM4F120 launchpad evaluation board</h1><div class="post__text post__text-html js-mediator-article">  The board of Stellaris LM4F120, which I finally decided to figure out, was dumped in my desk.  We will write a program that turns on / off the LEDs installed on the board in response to pressing the buttons on the board. <br><a name="habracut"></a><br>  I‚Äôll say right away that it‚Äôs a bit tough with electronics, so the article will express my opinion on how it works, which may not coincide with reality.  My terminology is very bad, so if you know the correct term, please correct it. <br><br><h4>  Training </h4>  First, you need to install the necessary software for development: <br><ul><li>  Compiler and development environment </li><li>  SDK (StellarisWare) </li><li>  Debug Module Drivers </li><li>  Firmware program </li><li>  Documentation </li></ul><br><br>  With compilers and IDE, Texas Instruments provides a <a href="http://www.ti.com/tool/sw-ek-lm4f120xl">choice</a> : their own Code Composer Studio based on Eclipse (can be installed both separately and as a plug-in to an already installed Eclipse, if any), IAR Embedded Workbench, Keil and Mentor Graphics Sourcery CodeBench: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c82/877/c49/c82877c490f0adcb396571a029e7f6e2.png"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The free version of CCS is fully functional and I will use it for her.  By the above link, you can download the ‚ÄúCD‚Äù, hiding behind the part number of EK-LM4F120XL-CCS, which will have everything you need for development, but the contents of the archive are somewhat out of date, and do not seem to be updated.  But you can download all separately: <br><br>  <a href="http://processors.wiki.ti.com/index.php/Download_CCS">Code Composer Studio</a> , StellarisWare is hidden behind part number SW-EK-LM4F120XL <a href="http://www.ti.com/tool/sw-ek-lm4f120xl">here</a> , <a href="http://www.ti.com/tool/stellaris_icdi_drivers">Stellaris ICDI drivers</a> , <a href="http://www.ti.com/tool/lmflashprogrammer">LMFlash programmer</a> , <a href="">Evaluation board User's Manual</a> , <a href="">Datasheet</a> .  After installing StellarisWare in the directory where it was installed, you will be able to find the docs subdirectory with the documentation.  The SW-DRL-UG-9453.pdf file is of primary interest (the numbers may vary depending on the SW version) - the documentation for the functions provided by the SDK (also, if you look at SW-EK-LM4F120XL-UG-9453.pdf, you can find high-level functions to work directly with the LEDs and buttons, but this is not the way of the real Jedi: we want to understand what is happening inside?) <br><br>  I must say that some <a href="http://e2e.ti.com/support/microcontrollers/tiva_arm/f/908/t/271820.aspx">renaming</a> took place in TI, and the LM4F120H5QR microcontroller used in the board began to be called TM4C1233H6PM, respectively, at the moment you should use the second name to search for information. <br><br>  On the Texas Instruments website, you can find <a href="http://focus.ti.com/docs/training/catalog/events/event.jhtml%3Fsku%3DOLT212013">video lectures</a> about the board and <a href="http://processors.wiki.ti.com/index.php/Getting_Started_with_the_Stellaris_EK-LM4F120XL_LaunchPad_Workshop%3FDCMP%3Dstellaris-launchpad%26HQS%3Dstellaris-launchpadtraining">printed materials</a> for them. <br><br>  We connect the board to the computer: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/032/04c/900/03204c900b2a1e8535f31dfe7408973d.jpg"></div><br>  We connect the USB cable to the debugger port, make sure that the power switch (next to the USB port) is in the ‚Äúdebug‚Äù position.  If everything is done correctly, except for the green power LED, the LED next to the ‚Äúreset‚Äù button should light up, and after 5 seconds, start flashing with different colors (if, of course, you did not have time to flash something different from the factory firmware). <br><br>  Windows 8.1 hint.  This default operating system does not allow loading unsigned drivers, which makes it impossible to install ICDI drivers.  This is treated as follows: press Win + I ‚Üí Power, hold Shift and click on Restart, wait, a menu with repair options will appear, select Troubleshoot ‚Üí Advanced options ‚Üí Startup settings ‚Üí Restart.  After the reboot, a menu will appear in which you must select ‚ÄúDisable driver signature enforcement‚Äù. <br><br><h4>  The very first program </h4><br>  So, we have installed everything you need.  It's time to write.  Create a project in CCS: File ‚Üí New ‚Üí CCS Project.  Configure similar to the picture: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/cfa/5c4/e43cfa5c43bf7783b430844bcf334650.png"></div><br>  We will get a project in which there will be two source files at once: an empty <code>main.c</code> and <code>lm4f120h5qr_startup_ccs.c</code> .  The second file contains the boilerplate code for initializing the interrupt table and the stub function for interrupt handling. <br><br>  Immediately configure the path to search for header files and libraries, go to the menu Project ‚Üí Properties, then: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57d/263/4ea/57d2634ea3ebfc17f41b8abb42c5e083.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/cee/26f/be1cee26fe9e13ad638e4ff49e8bb024.png"></div><br>  Of course, replace the paths with your own. <br><br>  Add <code>#include</code> to <code>main.c</code> and check that everything compiles: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;inc/hw_types.h&gt; #include &lt;inc/hw_gpio.h&gt; #include &lt;inc/hw_memmap.h&gt; #include &lt;driverlib/sysctl.h&gt; #include &lt;driverlib/gpio.h&gt; int main(void) { return 0; }</span></span></span></span></code> </pre><br><br>  If it does not work, we repair it; if it works, you can begin to do something useful. <br><br><h4>  Operating frequency </h4><br>  First of all, you need to adjust the frequency at which our microcontroller will work.  The maximum frequency with which it can work is 80 MHz, but less is possible.  Section 5.2.5 of the data sheet tells us how to adjust the frequency and scares with Figure 5-5: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ed/0b8/f06/6ed0b8f06ea5e214be9ecd661ade973c.png"></div><br>  At the moment, we are interested in the release of "System clock".  According to the data sheet, as a source of clock pulses can be: <br><ul><li>  Precision Internal OSC 16 MHz </li><li>  Main OSC (on this board is designated as Y1, and has a frequency of 16 MHz) </li><li>  Internal OSC 30 kHz </li><li>  Hibernation OSC (32.768 kHz) - Y2 on board </li><li>  PLL </li><li>  Precision Internal OSC through a divider of 4 </li></ul><br><br>  Two of these sources are external, with respect to the microcontroller (Main OSC and Hibernation OSC), the rest are inside it. <br><br>  The divider, indicated in the diagram as SYSDIV, can be set to 1x ‚Äì 64x frequency reduction.  If PLL is used as the source, the frequency divider by 2 can be enabled, controlled by the DIV400 bit (enabled by default).  For the operation of the PLL, a master pulse generator is required.  Its frequency can vary widely, but it must be specified at initialization.  Using PLL is the only way to start the microcontroller at the maximum frequency, so we will use it (although for our purposes such a crazy frequency is not needed).  For clocking PLL can be used as an external crystal, and internal. <br><br>  StellarisWare offers the <code>SysCtlClockSet</code> function to configure everything that is related to the System clock in one fell swoop.  To do this, she enters a bunch of flags at the entrance: <br>  To begin with, we‚Äôll define whether we use PLL ( <code>SYSCTL_USE_PLL</code> ) or something else ( <code>SYSCTL_USE_OSC</code> ) - the BYPASS flag in the diagram. <br>  If you use PLL, you need to choose who will be the master oscillator: Main OSC ( <code>SYSCTL_OSC_MAIN</code> ) or Precision Internal OSC ( <code>SYSCTL_OSC_INT</code> ).  If you use Main OSC, you must specify its frequency (in our case, <code>SYSCTL_XTAL_16MHZ</code> ). <br>  If you do not use PLL, you must specify the source: <br><ul><li>  Precision Internal OSC - <code>SYSCTL_OSC_INT</code> </li><li>  Precision Internal OSC through a divisor of 4 - <code>SYSCTL_OSC_INT4</code> </li><li>  Main OSC - <code>SYSCTL_OSC_MAIN</code> </li><li>  Internal OSC - <code>SYSCTL_OSC_INT30</code> </li><li>  Hibernation OSC - <code>SYSCTL_OSC_EXT32</code> </li></ul><br><br>  And finally, you need to configure the divider.  For this there are macros from <code>SYSCTL_SYSDIV_1</code> to <code>SYSCTL_SYSDIV_64</code> .  If PLL is used, you can additionally use macros <code>SYSCTL_SYSDIV_2_5</code> (/2.5) - <code>SYSCTL_SYSDIV_63_5</code> (/63.5).  For reasons unknown to me, for calling <code>SysCtlClockSet</code> PLL frequency is considered equal to 200 MHz, i.e.  in order to operate at a frequency of 80 MHz, you must specify a divider 2.5. <br><br>  So, the <code>SysCtlClockSet</code> call might look like this: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  PLL,   - Main OSC   16 ,   2.5,   80  SysCtlClockSet(SYSCTL_USE_PLL | SYSCTL_SYSDIV_2_5 | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span></span></code> </pre><br>  or so: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  PLL,   - Precision Internal OSC,   2.5,   80 ,  Main OSC SysCtlClockSet(SYSCTL_USE_PLL | SYSCTL_SYSDIV_2_5 | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);</span></span></code> </pre><br>  Or as you please. <br><br><h4>  Blink LEDs </h4><br>  It's time to make a program, the result of which can be seen.  The documentation on the board has a LED on circuit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/331/6b2/1813316b2dce13c2adeb3d672483c0e5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40b/f19/973/40bf199732ef19d35bdc859e0cb3784b.png"></div><br>  Those.  the LEDs are connected to the feet of 1-3 GPIO port F (if anyone knows why there is a resistor between the base and the emitter of the transistor - please enlighten, and why is its value not indicated?).  The GPIO port has eight legs, each of which can be individually configured as an input or output.  Writing and reading is carried out with all legs at once by writing or reading the register <code>GPIODATA</code> , mapped into memory (respectively, read / write one byte - the state of all legs).  Access to the port can be done in two ways: through Advanced Peripheral Bus (APB) or through Advanced High-performance Bus (AHB).  The first method is ‚Äúold‚Äù and slow, the second is modern and fast.  Honestly, what difference between them in terms of programming, I do not know (at least the basic addresses for ports differ), I used APB, the base address for port F is 0x40025000. <br><br>  So, in order to light the LED it is necessary to set a high voltage level on the corresponding foot.  Those.  write 1 to the appropriate bit.  Usually, to change the state of a bit, you need to read the state of the register, set the values ‚Äã‚Äãof the necessary bits and write the resulting value back.  Memory operations are slow, so the developers of the microcontroller provide an opportunity to do with one entry (without prior reading): the register is accessed not by one address, but by a range of 1024 bytes starting at the base address.  In bits 2‚Äì9 of the address, a mask of bits is placed, the values ‚Äã‚Äãof which must be updated.  Those.  if we want to write 1 in bit number 1, we must take the corresponding mask: 0x02, move it to the left by 2 bits and add the resulting value to the base address - we get the address to write down the required port state (0x02 or 0xFF - it will still be taken only the first bit). <br><br>  The function of setting the necessary bits could look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pins, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)base + ((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)pins &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>)) = value; }</code> </pre><br><br>  StellarisWare provides the <code>GPIOPinWrite</code> function with the same signature that does the same. <br><br>  Only one thing is missing: you need to turn on the port and configure the legs to which the LEDs are connected as exits.  For those who want to do without the SDK, the process is described in section 10.3 of the microcontroller's data sheet.  With StellarisWare, this is done by calling <code>SysCtlPeripheralEnable</code> and <code>GPIOPinTypeGPIOInput</code> / <code>GPIOPinTypeGPIOOutput</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;inc/hw_types.h&gt; #include &lt;inc/hw_gpio.h&gt; #include &lt;inc/hw_memmap.h&gt; #include &lt;driverlib/sysctl.h&gt; #include &lt;driverlib/gpio.h&gt; const unsigned int LED_RED = 0x02; const unsigned int LED_GREEN = 0x08; const unsigned int LED_BLUE = 0x04; const unsigned int LEDS_ALL = 0x02 | 0x08 | 0x04; int main(void) { SysCtlClockSet(SYSCTL_USE_PLL | SYSCTL_SYSDIV_2_5 | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); SysCtlPeripheralEnable(SYSCTL_PERIPH2_GPIOF); SysCtlDelay(2); GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, LEDS_ALL); const unsigned long int delay = 80000000 / 3 / 2; // 80 , 3    , 1/2    while (1) { GPIOPinWrite(GPIO_PORTF_BASE, LEDS_ALL, LEDS_ALL); SysCtlDelay(delay); GPIOPinWrite(GPIO_PORTF_BASE, LEDS_ALL, 0); SysCtlDelay(delay); } return 0; }</span></span></span></span></code> </pre><br><br>  The <code>SysCtlDelay</code> function <code>SysCtlDelay</code> <code>n</code> iterations of the empty loop, allowing you to make delays of the desired length.  Each iteration lasts 3 processor cycles.  Compile, run (F11 in CCS, then it will be necessary to press F8, because the default at the beginning of the program is an implicit breakpoint).  The LED on the board should start blinking white with a period of one second.  If instead of <code>LEDS_ALL</code> third argument of the first <code>GPIOPinWrite</code> call <code>GPIOPinWrite</code> passed, for example, <code>LED_GREEN</code> , then the blink will be green. <br><br><h4>  Buttons! </h4><br><br>  Two buttons are connected to feet 0 and 4 of the GPIO port F according to this scheme: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/764/d9f/8cf/764d9f8cf4dbbcd6a46843587d9d72ae.png"></div><br>  From the diagram it can be seen that pressing the button connects the foot to the ground, and in the unpressed state the foot is not connected anywhere.  This is bad, if you try to read anything from an unconnected foot, it can be read.  We need to connect the supply voltage when the button is not pressed.  This will help us pull up (pull-up), which practically connects the leg to the power through a resistor, so that when the button is not pressed, the supply voltage through the tightening will come, and when pressed, the current from it will go to the ground, those.  the released button will be read as a unit in the port, pressed - as zero. <br><br>  So, we adjust legs 0 and 4 on an input, we include pull-up: <br><pre> <code class="cpp hljs"> GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4); GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_0 | GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</code> </pre><br><br>  The <code>GPIOPadConfigSet</code> function allows <code>GPIOPadConfigSet</code> to set the current that the foot (2, 4 or 8 mA) and its mode can issue.  It is worth noting that the microcontroller has protection against changing the settings of some legs of some GPIO ports (those that can be used for the JTAG / SWD port (bits 0‚Äì3 of the C port) or for the nonmaskable interrupt input ‚Äî NMI (7 bits of the D port and 0 bits port F)): you can change the pull-up / pull-down settings for these legs only if you write 1 in the <code>GPIOCR</code> register. <code>GPIOCR</code> can only write the <code>GPIOLOCK</code> register <code>GPIOLOCK</code> is a special ‚Äúmagic number‚Äù in the <code>GPIOLOCK</code> register. <br><br>  Putting it all together: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;inc/hw_types.h&gt; #include &lt;inc/hw_gpio.h&gt; #include &lt;inc/hw_memmap.h&gt; #include &lt;driverlib/sysctl.h&gt; #include &lt;driverlib/gpio.h&gt; const unsigned int LEDS_ALL = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3; const unsigned int SW1 = GPIO_PIN_0; const unsigned int SW2 = GPIO_PIN_4; void crSet(unsigned int base, unsigned char value); int main(void) { int led = 2; SysCtlClockSet(SYSCTL_USE_PLL | SYSCTL_SYSDIV_2_5 | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); SysCtlPeripheralEnable(SYSCTL_PERIPH2_GPIOF); SysCtlDelay(2); GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, LEDS_ALL); GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, SW1 | SW2); HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY_DD; crSet(GPIO_PORTF_BASE, 1); GPIOPadConfigSet(GPIO_PORTF_BASE, SW1 | SW2, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU); crSet(GPIO_PORTF_BASE, 0); HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0; while (1) { unsigned int state = ~GPIOPinRead(GPIO_PORTF_BASE, SW1 | SW2); led = ((state &amp; SW1) &lt;&lt; 1) | ((state &amp; SW2) &gt;&gt; 1); GPIOPinWrite(GPIO_PORTF_BASE, LEDS_ALL, led); } return 0; } void crSet(unsigned int base, unsigned char value) { unsigned long v = (HWREG(GPIO_PORTF_BASE + GPIO_O_CR) &amp; 0xFFFFFF00) | value; HWREG(base + GPIO_O_CR) = v; }</span></span></span></span></code> </pre><br><br>  This wonderful program and a fee for 12 bucks, finally, allows you to do the same thing as a simple shemka of less than a dozen parts, worth 10 rubles, congratulations! </div><p>Source: <a href="https://habr.com/ru/post/206864/">https://habr.com/ru/post/206864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206852/index.html">Porting and localizing the application on Windows Phone 8</a></li>
<li><a href="../206854/index.html">Increase smartphone performance. All the pros and cons</a></li>
<li><a href="../206856/index.html">IBM Watson supercomputer toolkit became available to developers in the form of "cloud"</a></li>
<li><a href="../206858/index.html">Happy New Year to you!</a></li>
<li><a href="../206860/index.html">Mail.Ru Cloud - 1 terabyte for free and forever</a></li>
<li><a href="../206866/index.html">GnuCash Personal Finance</a></li>
<li><a href="../206868/index.html">Practice good code.</a></li>
<li><a href="../206870/index.html">Knowledge of language and Yandex. Why do we have cases? Lecture of a small school of data analysis</a></li>
<li><a href="../206876/index.html">Asterisk 12 released</a></li>
<li><a href="../206880/index.html">TV on the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>