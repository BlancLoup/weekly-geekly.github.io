<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sparrow plug-ins and Ansible modules - comparative analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Ansible modules and sparrow plug-ins are the building blocks for solving the simplest tasks in the field of configuration management ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sparrow plug-ins and Ansible modules - comparative analysis</h1><div class="post__text post__text-html js-mediator-article"><h1 id="vvedenie">  Introduction </h1><br><p>  <a href="https://www.ansible.com/">Ansible</a> modules and <a href="https://github.com/melezhik/sparrow">sparrow</a> plug-ins are the building blocks for solving the simplest tasks in the field of configuration management and automation of deployment.  Ansible modules are used in higher-level scripts - playbooks written in YAML, while sparrow plug-ins are similarly embedded in <a href="https://sparrowdo.wordpress.com/">sparrowdo</a> scripts written in <a href="http://perl6.org/">Perl6</a> . </p><br><p>  This article is a <em>free</em> author's translation of its own <a href="https://sparrowdo.wordpress.com/2017/01/20/sparrow-plugins-vs-ansible-modules/">original</a> from English. </p><br><a name="habracut"></a><br><h1 id="podderzhka-yazykov-razrabotki">  Development language support </h1><br><p>  <em>ansible</em> - you can choose virtually any development language for writing modules. <br>  Out of the box, the ansible provides an advanced API for Python (so-called shortcuts).  When developing modules in other languages, you will need to use supporting libraries (native to each language) to simplify the process of development and integration into ansible. </p><br><p>  <em>sparrow</em> - you have a choice of one of the three (*) languages ‚Äã‚Äã- Perl5, Bash or Ruby.  For the plugin developer, sparrow provides a unified API (available for any of the three languages), as well as in the case of ansible, which simplifies the development and integration of plug-ins into the sparrow system.  This API provides only basic features and is not as advanced as the ansible API for Python. </p><br><p>  (*) In the near future it is planned to add support for Python. </p><br><h1 id="dizayn">  Design </h1><br><p>  <em>ansible</em> - ansible modules - autonomous blocks of software when (scripts) for solving elementary problems.  Ansible modules cannot depend or cause other ansible modules. </p><br><p>  <em>sparrow</em> - sparrow plug-ins are similar to ansible modules - autonomous, closed blocks of code for solving elementary tasks.  However, sparrow provides an extra degree of freedom at this level of development.  Sparrow plugins are suites of scripts.  Some scripts can call others, passing them parameters.  This kind of design allows you to break any task into scripts that interact with each other.  As an example, consider the simple case - installing and removing software packages.  We can look at this task as a single block of code (script), but when implemented, break everything into two scripts: one to install the packages, the other to remove.  You can also enter the third script, which will parse the input parameters and do dispatching calls (*).  This approach is described in detail in the article <a href="https://sparrowdo.wordpress.com/2017/01/16/sparrow-plugins-evolution/">Evolution sparrow plug-ins</a> . </p><br><p>  (*) In fact, <a href="https://sparrowhub.org/info/package-generic">package-generic</a> plugin is implemented this way. </p><br><p>  Here is a simple illustration of everything said: </p><br><p><img src="https://sparrowdo.files.wordpress.com/2017/01/sparrow-plugins-design1.png" alt="image"></p><br><h1 id="integraciya-v-instrument-upravleniya-konfiguraciyami">  Configuration Management Integration </h1><br><p>  <em>ansible</em> - ansible modules are an integral part of higher-level configuration scripts - ansible <a href="http://docs.ansible.com/ansible/playbooks.html">playbooks</a> .  ansible playbook - written in <a href="https://ru.wikipedia.org/wiki/YAML">YAML</a> script, declaring a call to ansible modules with some specified parameters.  Such a construction in ansible is called a task. </p><br><p><img src="https://sparrowdo.files.wordpress.com/2017/01/ansible-modules-and-playbooks.png" alt="image"></p><br><p>  <em>sparrow</em> - like ansible modules sparrow plugins are an integral part <br>  a more common system - <a href="https://github.com/melezhik/sparrowdo">sparrowdo</a> scripts written in Perl6.  Like ansible - sparrowdo - configuration management system, but built on sparrow plugins.  Sparrow plugins are invoked with parameters inside sparowdo scripts. </p><br><p><img src="https://sparrowdo.files.wordpress.com/2017/01/sparrow-plugins-and-sparrowdo1.png" alt="image"></p><br><h1 id="interfeys-konechnogo-polzovatelya">  End-user interface </h1><br><p>  <em>ansible</em> - ansible modules, as already mentioned, are invoked via a YAML DSL code, which declares the launch of modules with transmitted parameters.  This happens in playbooks.  It is possible to launch modules with a console script with parameters passed as command line arguments. </p><br><p>  Below is an example of a playable ansible code for installing the httpd web server using the yum package manager (the same name ansible module): </p><br><pre><code class="hljs delphi">$ cat playbook.yml --- - hosts: webservers tasks: - <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: ensure apache <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> at the latest version yum: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>=httpd state=latest</code> </pre> <br><p>  <em>sparrow</em> - sparrow plugins are invoked inside sparrowdo scripts using the Perl6 API.  Plugin parameters are passed as Perl6 hashes.  You can also use the <a href="https://github.com/melezhik/outthentic">console client</a> to run plugins "as is", bypassing sparrowdo (in a similar way as you can do ansible modules).  This can be handy when developing and debugging plugins.  In this startup mode, you have a lot of additional opportunities to transfer input parameters - the command line, JSON / YAML formats and <a href="https://metacpan.org/pod/Config::General">Config :: General</a> </p><br><p>  The following is the equivalent of the previous ansible playbook for installing the web server httpd.  There are two code variants (core-dsl and plugin API) of the sparrowdo script: </p><br><pre> <code class="hljs vhdl">$ cat sparrowfile # core-dsl API  ,     #  <span class="hljs-string"><span class="hljs-string">""</span></span>    #         <span class="hljs-keyword"><span class="hljs-keyword">package</span></span>-install <span class="hljs-symbol"><span class="hljs-symbol">'httpd</span></span>'; # ,       core-dsl #      , #  plugin API #     : task-run <span class="hljs-symbol"><span class="hljs-symbol">'ensure</span></span> apache <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> at the latest version', <span class="hljs-symbol"><span class="hljs-symbol">'package</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">generic</span></span>', %( list =&gt; <span class="hljs-symbol"><span class="hljs-symbol">'httpd</span></span>' );</code> </pre> <br><h1 id="peredacha-i-obrabotka-vhodnyh-parametrov">  Transmission and processing of input parameters </h1><br><p>  <em>ansible</em> - the input parameters of the module are passed in the form of pairs <em>key = value</em> (*). In general, when developing a module, you must parse the parameters in order to ‚Äúextract‚Äù the data and assign them to the corresponding variables, with a view to further use in the module code.  Under different development languages ‚Äã‚Äãthere are numerous "helpers" that solve this problem. </p><br><p>  (*) It is possible to transfer nested data structures. </p><br><p>  Also, as already mentioned, ansible provides a high-level API for Python, called the ansible documentation for shortcuts.  This API allows you to automatically parse input parameters, generate accessors, determine the types of input parameters and test them, determine default values, and the like. </p><br><p>  Below is a slice of an anible module that implements the parsing of input parameters using the Python ansible API: </p><br><pre> <code class="hljs pgsql">$ cat library/greetings.py <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ansible.module_utils.basic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * def main(): fields = { "message": {"default": "Hi!", "type": "str" } } module = ansibleModule(argument_spec=fields) module.params[<span class="hljs-string"><span class="hljs-string">'message'</span></span>] # <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other code here <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre> <br><p>  <em>sparrow</em> - sparrow implements a unified API (available for any development language) to handle the input parameters of the plugin, so you don‚Äôt have to manually parse the data. </p><br><p>  Thus, regardless of the language in which you are developing the plugin, you get <br>  out of the box API for accessing input data without actually writing a single line of auxiliary code. </p><br><p>  It is also possible to determine default values ‚Äã‚Äãfor parameters, in case the latter are not explicitly specified. </p><br><p>  Built-in typing and parameter checking, as in the case of the ansible Python API is missing. </p><br><p>  Below is the equivalent of the aforementioned ansible code that parses input parameters.  Bash (*) is selected as the plugin implementation language. </p><br><p>  (*) to show how even in such a far from the most high-level development language, you can easily write sparrow plug-ins, without ‚Äústicking‚Äù to the processing of input parameters: </p><br><pre> <code class="hljs smalltalk">#    <span class="hljs-string"><span class="hljs-string">$ </span></span>cat story.bash message=<span class="hljs-string"><span class="hljs-string">$(</span></span>config message) #    : <span class="hljs-string"><span class="hljs-string">$ </span></span>cat story.ini message = <span class="hljs-type"><span class="hljs-type">Hi</span></span>!</code> </pre> <br><p>  But how can you use the same Bash to parse nested input parameters: </p><br><pre> <code class="hljs smalltalk">#    sparrowdo  <span class="hljs-string"><span class="hljs-string">$ </span></span>cat sparrowfile task-run <span class="hljs-comment"><span class="hljs-comment">"run my task"</span></span>, <span class="hljs-string"><span class="hljs-string">'foo-plugin'</span></span>, %( foo =&gt; { bar =&gt; { baz =&gt; <span class="hljs-string"><span class="hljs-string">'BAZ'</span></span> } } ); #    <span class="hljs-type"><span class="hljs-type">Bash</span></span> #    : <span class="hljs-string"><span class="hljs-string">$ </span></span>cat story.bash baz=<span class="hljs-string"><span class="hljs-string">$(</span></span>config foo.bar.baz)</code> </pre> <br><h1 id="vozvraschaemye-znacheniya">  Return values </h1><br><p>  <em>ansible</em> - ansible modules always return the result as a JSON string.  And JSON itself should have a special structure.  More information about this can be found on the pages of the <a href="https://metacpan.org/pod/Config::General">documentation of</a> ansible module development. </p><br><p>  But here's what I want to note about the process of returning values ‚Äã‚Äãfrom the ansible modules: </p><br><ul><li><p>  termination code (script implements the mold) ansible modules ignored </p><br></li><li><p>  the only requirement for returning from a module is the presence of a string in JSON format in STDOUT.  The JSON response structure must also meet certain requirements. </p><br></li><li><p>  Thus, if we do not receive <em>valid</em> JSON in the response from the module, this is regarded as an error </p><br></li><li><p>  STDOUT / STDERR generated by the module is not visible (*) in the output of the player <br>  (*) - under certain conditions or by writing additional code, this output can still be obtained, but here I am talking about the <em>default</em> behavior </p><br></li><li>  In order for a module to return a value, it must be represented as a field of JSON structure, which must be returned in STDOUT </li></ul><br><p>  I will give an example with the currenttime module for returning the current time: </p><br><pre> <code class="hljs pgsql">$ cat library/currentime.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span> = str(datetime.datetime.now()) print <span class="hljs-type"><span class="hljs-type">json</span></span>.dumps({ "time" : <span class="hljs-type"><span class="hljs-type">date</span></span> })</code> </pre> <br><p>  <em>sparrow</em> - sparrow plugins, unlike ansible modules can return anything, sparrow doesn‚Äôt regulate the data returned by the plugin.  (However, see the following section - "Output Processing"). </p><br><p>  Here is what is important to know about the output in terms of sparrow: </p><br><ul><li><p>  The plug-in termination code (resulting, as in the case of sparrow, we can deal not with one script, but with several) matters.  If it is non-zero, it is interpreted as a plug-in execution error. </p><br></li><li>  The STDOUT generated by the plugin is simply passed on and is visible in the resulting output.  No "repacking" or filtering the results, as is the case with ansible.  We always see the output as it is, as if we just ran a similar script from the console. </li></ul><br><p>  Next, I will give the equivalent of the previous ansible module to display the current time.  This time, when writing a plugin, it will be to use Perl5, by virtue of all the plugin code is said to be trivial: </p><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#   $ cat story.pl print scalar localtime;</span></span></code> </pre> <br><h1 id="obrabotka-vyhodnyh-dannyh">  Output Processing </h1><br><p>  <em>ansible</em> - ansible modules must always return JSON, so it‚Äôs very easy to have structured data at the output to turn them into variables and process them somewhere "higher", in fact, in ansible playbooks.  Although this is a powerful enough feature, its value in configuration management systems is a controversial one for me.  The fact is that by the time (*) of the task list execution on the target server everything should already be definitely in the form of a static, deterministic list, any attempt to add branching and dynamics in such an already formed list only complicates, but does not simplify, the solution of the common task - convergence server to a given form. </p><br><p>  (*) it is important to understand here that I‚Äôm not against the dynamic generation of such lists of tasks or resources, just here the imperative approach is quite appropriate, as is the case with chef or sparrowdo.  But maybe I don‚Äôt know so well ansible to reason how the data returned by the modules are used later in playbooks. </p><br><p>  Here is an example of a simple module that simply returns the input parameter passed to it, which is then "registered" in the playbook and output to the console: </p><br><pre> <code class="hljs java">$ cat playbook.yml - hosts: localhost tasks: - name: tell me what I say echo: message: <span class="hljs-string"><span class="hljs-string">"hi there!"</span></span> register: result - debug: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>=result $ cat library/echo.py from ansible.module_utils.basic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> </span></span>= ansibleModule(argument_spec={}) response = {<span class="hljs-string"><span class="hljs-string">"you_said"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.params[<span class="hljs-string"><span class="hljs-string">'message'</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.exit_json(changed=True, meta=response) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre> <br><p>  <em>sparrow</em> - as already mentioned, sparrow is ‚Äúall the same‚Äù that the plugin reports in STDOUT, there is no way to use this data further.  In fact this is not true. </p><br><p>  From the point of view that this data <em>will not be processed further</em> - this is true, but you can determine the <em>verification rules</em> with the help of which you can verify the output of the script.  This kind of built-in testing is a characteristic feature of sparrow plug-ins.  Verification rules are <a href="https://github.com/melezhik/outthentic-dsl">written</a> in the form of constructions of the <a href="https://github.com/melezhik/outthentic-dsl">Outthentic :: DSL</a> language and allow you to do various textual checks - matching the text with different regular expressions, working with individual pieces of text that correspond to our expressions (so-called captures) and much more.  All this can be read on the documentation pages Outthenic :: DSL. </p><br><p>  If verification is not passed, it is interpreted (along with a non-zero completion code), as a plug-in execution error. </p><br><p>  Thus, writing such "self-testing" scripts allows you to write plug-ins not only for tasks from the area of ‚Äã‚Äãconfiguration management, but for tasks of testing, monitoring and auditing. </p><br><p>  It is difficult to build an analogy with the previous ansible module, in view of all the above, but <br>  here is something roughly "similar" that can be done in sparrow.  Pass the parameter to the plugin, output it to STDOUT and write a check rule to make sure that the output is exactly what was at the input: </p><br><pre> <code class="hljs smalltalk">#     sparrowdo <span class="hljs-string"><span class="hljs-string">$ </span></span>cat sparrowfile run-task <span class="hljs-comment"><span class="hljs-comment">"tell me what I say"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"echo"</span></span>, %( message =&gt; <span class="hljs-string"><span class="hljs-string">'hi there!'</span></span> ) #      <span class="hljs-string"><span class="hljs-string">$ </span></span>cat story.bash echo you said <span class="hljs-string"><span class="hljs-string">$(</span></span>config message)</code> </pre> <br><p>  $ cat story.check <br>  generator: config () -&gt; {message} </p><br><h1 id="process-ustanovki">  Installation process </h1><br><p>  <em>ansible</em> - a large number of ansible are supplied as part of ansible, they are ready for use, you do not need to install them in any special way.  Also, users write the so-called custom modules and, as a rule, save them in some version control system - Git / Svn (for example, in github or gitlab).  Further, modules <em>in the form of</em> regular files are checked to the master server (the one from which the ansible tasks are launched by ssh on the target servers), again in this case the message is reduced to the usual checkout from the version control system. </p><br><p>  So, the ecosystem of modules includes two large subsystems: </p><br><ul><li><p>  The main repository ansible ( <a href="https://github.com/ansible/ansible/tree/devel/lib/ansible/modules">main ansible repository</a> ) - modules that come with ansible </p><br></li><li>  Custom modules </li></ul><br><p>  Summarizing, we can say that the push-based deployment scheme is implemented in ansible, and with the absence of an agent (agentless) on the target server.  Modules in the form of files are simply copied to the target server and are already running there as scripts. </p><br><p>  The following is a graphical diagram of the process of deploying custom modules ansible: </p><br><p><img src="https://sparrowdo.files.wordpress.com/2017/01/ansible-modules-deploy.png" alt="image"></p><br><p>  <em>sparrow</em> - in sparrow the deployment process is a bit different.  Although in general, the same push-based scheme was adopted there.  However, in the case of sparrow, there is an agent (or client, to whom, as it is more convenient), who installs plug-ins. </p><br><p>  So, sparrow plugins are nothing more than <em>packaged</em> scripts, distributed like a classic distribution system for software packages, such as deb, rpm, CPAN, RubyGems. </p><br><p>  sparrow is provided by the plugin installation manager, the same manager is used to launch plugins.  The manager must be preinstalled on the target server for everything to work. </p><br><p>  sparrowdo compiles scripts placed on the central (master) server into meta data, which is copied into scp as target JSON files, on the target machines, then the manager uses the copied data, downloads, installs, and finally sparrow starts the result is returned back (as in the case of ansible) in the form of a response to the central server. </p><br><p>  So, it is important to understand that, unlike ansible, installing plugins is not just copying files to the target server, since  in the case of sparrow, not the plugins themselves are copied, but their meta information, then the actual deployment process takes place according to the meta information. </p><br><p>  sparrow plugins are located in the central repository of sparrow plugins - <a href="https://sparrowhub.org/">sparrowHub</a> .  Plugins have author, version, description and documentation. </p><br><p>  Here is the meta information file of the above <a href="https://sparrowhub.org/info/package-generic">package-generic</a> plugin for installing software packages: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"package-generic"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-string"><span class="hljs-string">"0.2.16"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Generic package manager. Installs packages using OS specific package managers (yum,apt-get)"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"https://github.com/melezhik/package-generic"</span></span> }</code> </pre> <br><p>  In sparrow there is no hard division into custom and "core" plugins.  Any plugin loaded on sparrowHub becomes immediately available to users of the system, and thus it can be used in sparrowdo scripts. </p><br><p>  At will, users can place their plugins on remote git repositories, in sparrow such plugins are called private, and these plugins can easily be used in your configuration scripts, along with sparrowHub plugins (so-called public plugins) </p><br><p>  The following is a diagram of the deployment of plug-ins in sparrow: </p><br><p><img src="https://sparrowdo.files.wordpress.com/2017/01/sparrowdo-system2.png" alt="image"></p><br><h1 id="zavisimosti">  Dependencies </h1><br><p>  <em>ansible</em> - in ansible there is no possibility to manage software dependencies at the module level.  Most likely (I know the ansible so well, I guess) it happens a level higher - in playbooks.  Thus, if your module is dependent on a library, you need to take care of resolving dependencies somewhere else, for example, causing the dependencies to be installed elsewhere in the playbook. </p><br><p>  <em>sparrow</em> - sparrow provides regular dependency management capabilities (*) at the level of the sparrow plugin.  Thus, if the plugin is dependent on any libraries, you can <em>describe</em> these dependencies right in the plugin and the plugin manager will take care of them <br>  during installation of the plugin.  For now, dependency management is limited to CPAN modules for Perl5 through the <a href="https://metacpan.org/pod/Carton">cpanfile</a> file and <a href="http://bundler.io/">RubyGems</a> modules for Ruby through the Gemfile file. </p><br><p>  (*) - dependencies are limited while CPAN for Perl5 and RubyGems for Ruby </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  ansible won great popularity, not least due to the large number of ready-made modules.  However, in my personal opinion, the process of developing new modules has its drawbacks and the architecture itself is not a good solution for some tasks.  I find the individual features of the sparrow more attractive and interesting compared to the ansible.  This, of course, IMHO :), I will list some points: </p><br><ul><li><p>  Playbooks <em>against</em> sparrowdo scripts - sparrowdo provides imperative programming options for configurations using powerful and modern Perl6 language <br>  While in ansible you are limited by the capabilities of a purely declarative YAML. </p><br></li><li>  Script-oriented design - thanks to a script-oriented scheme, sparrow encourages splitting a task into separate pieces and writing a separate script for each piece, and the scripts themselves organically interact with each other, using the parameters that they send to <a href="https://github.com/melezhik/outthentic">history modules</a> ) In the case of ansible, you are usually limited to a single module scheme = one script.  Of course, in the case of ansible you can write in a similar style (several scripts in the module), but ansible, of course, by design is not suitable for this kind of things. </li></ul><br><p>  So, in a practical sense, often when solving problems and writing routine scripts, we break the problem into several parts and have a set of scripts interacting with each other, so why not bring this approach here too? </p><br><ul><li><p>  Life cycle and module and plug-in management - sparrow plug-ins are even more isolated and separate from the configuration management tool itself.  As I said, sparrow plugins can be used <em>without</em> sparrowdo.  In fact, they are developed, debugged and hosted and managed outside the framework of this system (sparrowdo) and used as black boxes.  All this makes the process of developing new plug-ins and their use inside sparrowdo even more flexible and simple. </p><br></li><li><p>  Bash / Shell scripting - sparrow provides better, compared to ansible support for the integration of regular bash / shell scripts.  Due to the fact that the latter imposes a restriction on the returned data and does not display STDOUT / STDERR streams by default, in some cases it becomes difficult to debug ordinary bash scripts or to understand <em>what</em> is going wrong.  While sparrow actually transparently translates all output from the scripts back to the report.  It also plays a significant role ignoring the script completion code in ansible, where the developer is assigned the "override" error at the level of the returned JSON.  Sparrow in this case simply generates an error, acting in the convection style of executing unix / linux commands. </p><br></li><li><p>  Software API - sparrow provides a unified interface for all plug-in development languages.  This means that virtually every language in the list of supported "has the same rights" from the point of view of the basic API provided by the system.  While the modules of ansible are mostly written in python, due to the fact that support for this language is the most complete (ansible modules python API) </p><br></li><li>  Testing capabilities - sparrow provides built-in testing capabilities that allow you to look at this tool as a universal automation tool that can be used including (besides those listed) in audit, monitoring and testing tasks. </li></ul><br><p>  PS as always interesting to hear the reader‚Äôs opinion and constructive criticism.  This time I don‚Äôt cite the traditional questionnaire, and the article turned out to be voluminous. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320220/">https://habr.com/ru/post/320220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320206/index.html">On the fabulous Bali snow fell or how easy it is to deceive the GPS</a></li>
<li><a href="../320210/index.html">Exam for future "Russian hackers" at the Moscow Polytech</a></li>
<li><a href="../320212/index.html">Rounded Images on Qt Quick Scene Graph</a></li>
<li><a href="../320214/index.html">Big data protection - how to start and minimize possible risks?</a></li>
<li><a href="../320218/index.html">How a former command post becomes a data center</a></li>
<li><a href="../320222/index.html">How IT professionals work. Ilya Titov, Managing Director for IT at Modbank</a></li>
<li><a href="../320224/index.html">IAP in Unity3D</a></li>
<li><a href="../320226/index.html">Is your call very important to us? Or how the prioritization system works in service departments</a></li>
<li><a href="../320228/index.html">Automation of load testing: a bunch of Jmeter + TeamCity + Grafana</a></li>
<li><a href="../320230/index.html">We test the Fujitsu PRIMERGY RX2530 M2 server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>