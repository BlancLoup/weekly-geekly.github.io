<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Events, processes and services: a modern approach to automating business processes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary 


- Using event-driven architecture to reduce connectivity is a very popular idea when designing microservices. 
- Event-based business logic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Events, processes and services: a modern approach to automating business processes</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/q5/nm/ob/q5nmobd3xria1dy2ikxuq0dtxjq.jpeg"></p><br><h2 id="kratkoe-soderzhanie">  Summary </h2><br><ul><li>  Using event-driven architecture to reduce connectivity is a very popular idea when designing microservices. </li><li>  Event-based business logic is well suited for decentralized data and solving end-to-end functionality problems.  However, it is not necessary to build complex chains on the transfer of events from service to service.  Coordination of services with the help of commands, rather than events - allows you to unleash them even more. </li><li>  ESB (Enterprise Service Bus, in the context of the article - "smart bus" - note of the translation.) Does not fit well with microservice architecture.  It is preferable to use simple data transfer channels and smart customers (smart endpoints, dumb pipes).  But, do not refuse the coordinating service of other services only out of fears of receiving one god-like service: business logic still needs a home. </li><li>  Workflow engines of the past were mostly vendor-dependent.  The so-called "zero-code" solutions - in practice turned into a nightmare for developers.  There are currently lightweight and simple workflow management tools, many of which are open source. </li><li>  Do not waste time writing your own finite automata.  On the contrary, use ready-made solutions to avoid difficulties. <a name="habracut"></a></li></ul><br><blockquote>  Use event-driven architecture to achieve loose coupling. </blockquote><p>  Such advice is often found in discussions on the subject of microservices.  In particular, it is popular and supported in <a href="https://www.infoq.com/minibooks/domain-driven-design-quickly">DDD (Domain-Driven Design)</a> communities.  The authors of the article, being potential supporters of event models, nevertheless asked themselves the question: what risks can be borne by thoughtless use of events?  For the answer, 3 popular hypotheses were considered: </p><br><ul><li>  Events reduce connectivity </li><li>  God-like (central control) services should be avoided. </li><li>  Workflow engines have their sores. </li></ul><br><p>  The examples below are artificial, but inspired by the real business process of order processing in Zalando.  Suppose there are 4 limited contexts ( <a href="https://www.infoq.com/articles/ddd-contextmapping">bounded context</a> ) in 4 isolated applications (this can be either <a href="https://martinfowler.com/articles/microservices.html">microservices</a> or <a href="https://www.infoq.com/articles/scs-microservices-done-right">representatives of</a> <a href="https://www.infoq.com/articles/service-oriented-architecture-and-legacy-systems">other</a> architectures): </p><br><p><img src="https://habrastorage.org/webt/-u/vp/bv/-uvpbvfhht5fo5lqnbn_s42owls.png"></p><br><h2 id="kak-umenshit-svyazannost-s-pomoschyu-sobytiy">  How to reduce connectivity with events </h2><br><p>  Suppose that the Checkout service must notify the user if the product has appeared in stock and can be shipped immediately.  Of course, Checkout can directly poll the Inventory service about the quantity of goods in stock, but this would make Checkout dependent on Inventory, i.e.  would strengthen connectivity. </p><br><p>  Alternative approach: Inventory publishes product change events in stock.  Checkout listens for events and stores fresh values ‚Äã‚Äãin the local cache.  This data is a copy, the absolute integrity of which is not at all mandatory.  Although, a certain level of event integrity is usually necessary in distributed systems. </p><br><p><img src="https://habrastorage.org/webt/i9/di/o5/i9dio5tisap2v66xj01hafmobnq.png"></p><br><p>  Another scenario: end-to-end functionality.  Let it be necessary to send notifications to the customer at certain steps of the order.  We could add to the system a fully autonomous Notification service that stores the settings and contact details of customers.  Having received an event like "payment received" or "order shipped", this service would send letters without requiring changes to other services.  As we can see, <a href="https://martinfowler.com/articles/201701-event-driven.html">event-driven</a> architecture is very flexible, and allows you to easily add new services, or expand old ones. </p><br><h2 id="opasnosti-slozhnyh-cepochek-peredachi-sobytiy">  The dangers of complex event transmission chains </h2><br><p>  Developers who implement event-driven architecture often become obsessed: events superbly reduce the coherence of the system, so let's use events everywhere and always!  Problems begin when a team implements a business process (eg order processing) through a chain of messages from one service to another.  Consider the simplest example: let each service in the chain decide for itself what to do and which events to send: </p><br><p><img src="https://habrastorage.org/webt/i9/di/o5/i9dio5tisap2v66xj01hafmobnq.png"></p><br><p>  Yes it works.  But the problem is that none of the links in the chain has a clear vision of the whole process.  This makes the business process difficult to understand and (more importantly) difficult to change.  Consider also that in the real world business processes are far from being so simple, and usually involve much more services.  The authors of the article have seen complex microservice systems that no one else understands in detail. </p><br><p>  And now we will think about how we would realize the reservation of goods at the warehouse BEFORE making a payment: </p><br><p><img src="https://habrastorage.org/webt/ti/3b/k2/ti3bk2ua6lrsc0f6l4r3ohhdntc.png"></p><br><p>  It is necessary to correct and re-assign several services in order to simply change the sequence of order execution steps!  This is the anti-pattern for microservice architecture, since its key principle is to strive for less cohesiveness and greater isolation.  Therefore, think twice before using events in similar ‚Äúservice-to-service‚Äù processes, especially where high complexity is expected. </p><br><h2 id="komandy-no-bez-neobhodimosti-v-centralnom-kontrole">  Commands, but without the need for central control </h2><br><p>  It would be more reasonable to keep the whole business process in a separate service.  Such a service manager can send commands to others, for example, ‚Äúmake a payment‚Äù.  At the same time, one should avoid the knowledge of microservices about each other.  The authors call this pattern "orchestration" (orchestration).  For example: "Order controls (orchestrates) the Payment, Inventory and Shipment services". </p><br><p><img src="https://habrastorage.org/webt/9i/py/-f/9ipy-f5to_tynb0zfnzmfrijl80.png"></p><br><p>  Speaking of orchestration, many come to mind with the miraculous <a href="https://www.infoq.com/presentations/Enterprise-Service-Bus">Enterprise Service Bus (ESB)</a> bus, as well as <a href="https://www.infoq.com/articles/seven-fallacies-of-bpm">Business Process Modeling (BPM)</a> solutions.  These complex, proprietary tools have a bad reputation and for good reason.  Often they deprive us of simple, understandable testing and lightweight application delivery.  At the same time, James Lewis and Martin Fowler laid many of the foundations of the microservice architecture, suggesting the use of "smart endpoints and simple transfer channels" ( <a href="https://martinfowler.com/articles/microservices.html">smart endpoints, dumb pipes</a> ). </p><br><p>  The picture above does not imply the use of a ‚Äúsmart bus‚Äù.  All control over the processing of the order is assigned to a separate service manager Order.  The team is free to implement this service as convenient, using any technology to taste.  Thus, changes in the business process will affect one, and only one microservice.  Moreover, a business process concentrated in one place is much easier to understand. </p><br><p>  Sam Newman, in his book <a href="http://samnewman.io/books/building_microservices/">Building Microservices,</a> considers the risk that such a service manager will grow into a godlike monster over time.  Such a god service will collect all the business logic, and the rest will degenerate into anemic services, or worse: <a href="http://www.michaelnygard.com/blog/2017/12/the-entity-service-antipattern/">CRUD</a> will become simple. </p><br><p> Did this happen due to the use of commands to the detriment of the event architecture?  Or is the problem in the orchestration itself?  Neither one nor the other.  Let's take a look at Fowler's "smart endpoints".  What defines a smart endpoint?  Good API design.  For the Payment service, you can develop a high-level API that responds to commands like "return payment" and publishes events like "payment made", "failed to make payment", etc.  All sensitive information (for example, about the user's credit card) should be kept inside and only inside microservice.  In this case, Microservice Payment will not become anemic, even if it is used by a service manager or someone else. </p><br><p><img src="https://habrastorage.org/webt/hw/iu/kl/hwiuklxyl0z7wyqbmfdukoi7c1a.png"></p><br><h2 id="cervisy-rabotayuschie-dolgo">  Long-term services </h2><br><p>  To develop smart endpoints and suitable client APIs, it should be assumed that some processes can be performed for a long time - they also need to solve real business problems behind the scenes!  Suppose that in case of an overdue credit card, the customer should have a chance to correct the situation (an example is inspired by GitHub, where a business account is closed only 2 weeks after non-payment).  If our Payment service is not going to be engaged in waiting for the customer‚Äôs actions, he can delegate this task to his customer, the Order service. </p><br><p>  However, if you keep this functionality inside the Payment service, the architecture will become cleaner and more consistent with the idea of ‚Äã‚Äãthe "bounded context" of DDD.  The fact of waiting until the customer starts a new credit card means that payment can still be made.  As a result, the Payment API becomes clean and simple.  Sometimes waiting can be 2 weeks - that's what we call a ‚Äúlong-running‚Äù business process! </p><br><p><img src="https://habrastorage.org/webt/ia/bv/fq/iabvfq7abzr6u5xqlpz1yokvtzk.png"></p><br><h2 id="hranenie-sostoyaniya-servisa">  Service state storage </h2><br><p>  Long-running processes must somewhere keep their state, such as "waiting for payment", etc.  To save the state of the application after a reboot is far from a new task, and here are two typical solutions: </p><br><ul><li>  Create your own state storage mechanism based on Entity, Persistent Actor, etc. patterns.  Has anyone ever created an Order table with a Status column?  That's it! </li><li>  Understand and accept a state machine or a whole workflow engine.  We have access to many such tools, including quite mature ones.  But progress does not stand still: for example, <a href="https://github.com/Netflix/conductor">Netflix</a> and <a href="https://github.com/uber/cadence">Uber are</a> developing their open source solutions. </li></ul><br><p><img src="https://habrastorage.org/webt/uj/un/j_/ujunj_as_rdfdxo_lyqhyrsrb9a.png"></p><br><p>  According to the experience of the authors of the article, their state storage bikes often evolve into homemade finite automata.  Because new and new tasks are set for the written system.  For example: </p><br><ul><li>  support for timeouts ("let's add a scheduler"), </li><li>  reporting tools ("hey, why don't business guys just use SQL to fetch the right data") </li><li>  monitoring tools. </li></ul><br><p>  We write our state machines not only because of the ‚ÄúNot-Invented-Here‚Äù syndrome, but because of the negative reputation that old-fashioned business process automation tools deserve.  Many have a painful experience with similar "zero-code" tools.  Management buys technology in the hope of getting rid of developers ... which, of course, is not happening.  Instead, support for heavyweight and proprietary technology falls on the shoulders of the IT department, where it remains forever an alien, rejected element. </p><br><h2 id="legkovesnye-konechnye-avtomaty-i-workflow-engines">  Lightweight state machines and workflow engines </h2><br><p>  There are simple and flexible tools, to work with which it is enough to write just a few lines of code.  These are not zero-code solutions, but regular developer libraries.  They take on the work with finite automata, quickly pay for themselves and begin to bring benefits. </p><br><p><img src="https://habrastorage.org/webt/o4/98/my/o498mypa8ppr6c2oa67kqnjm_r0.png"></p><br><p>  As a rule, such tools allow you to graphically describe workflow using BPMN ISO notation, or using JSON, YAML, or DSL based on Java, Golang, etc.  An important point: the description of the workflow - this is the real code that is executed in the process. </p><br><p><img src="https://habrastorage.org/webt/8z/lo/ht/8zlohtce39ruv81myfn6idgtwgi.png"></p><br><p>  BPMN, and others like it, support quite complex operations: time management, timeouts, business transactions.  And yet, this is quite a popular and mature notation, so we can talk about its suitability for solving complex problems. </p><br><p><img src="https://habrastorage.org/webt/bg/0l/ka/bg0lkaz0sevmnyvfuwaq3dv0uu4.png"></p><br><p>  In the picture above, the workflow instance is waiting for the ‚ÄúGoods Fetched‚Äù event ... but the wait time is limited.  In the event of a timeout, we roll back the business transaction by performing a special compensating action.  In this case, the payment will be returned to the sender - the state machine remembers all previously performed actions, which allows you to perform all the corresponding compensation code.  What allows the state machine to manage the business transaction is the idea here is the same as in the <a href="http://microservices.io/patterns/data/saga.html">Saga pattern</a> . </p><br><p>  Graphic notation is also a kind of "live documentation", which has no chance to become obsolete and break away from the real system.  What about testing?  Some libraries support unit tests, incl.  for long-running scenarios.  For example, <a href="https://camunda.org/">Camunda</a> for each test run generates HTML with a test execution script, which is easy to insert into a regular CI report.  In this case, the graphical notation takes on even more meaning: </p><br><p><img src="https://habrastorage.org/webt/jw/iu/ay/jwiuayvbnk_dzdnxbsrkbdenidk.png"></p><br><h2 id="workflow-zhivut-vnutri-servisov">  Workflow live within services </h2><br><p>  The choice and use of a specific workflow framework should be decentralized, at the discretion of each development team separately.  A state machine is implementation details that should not be visible outside the service.  There is no need for one and only one global framework for the company.  A finite state machine is just a library that simplifies development. </p><br><p><img src="https://habrastorage.org/webt/rg/5b/kp/rg5bkpx8amhejhiexjdxocb7f4w.png"></p><br><p>  In addition, a finite state machine is part of business logic.  Depending on the tool, it can be embedded in the process of your application (for example, using Java, Spring and Camunda), or as a separate process, communicating via the client library ( <a href="https://zeebe.io/">Zeebe</a> ) or the REST API (Camunda and Netflix Conductor).  Having a ready state machine at hand with support for long-running business tasks, you can focus on business logic and API design by implementing a real smart endpoint. </p><br><p><img src="https://habrastorage.org/webt/ep/h-/id/eph-idn8o6ccxry8kqilx9dubjy.png"></p><br><h2 id="pokazhite-kod">  Show the code </h2><br><p>  Without slipping into a dry theory, the authors of the article wrote a demo application and posted it on <a href="https://github.com/flowing/flowing-retail/">GitHub</a> .  There are living examples of ideas presented in the article. </p><br><p>  Java code using only open source libraries (Spring Boot, Camunda, Apache Kafka). </p><br><p><img src="https://habrastorage.org/webt/d4/3a/q7/d43aq7lfx7s2ctpazlmmyl6ulpa.png"></p><br><h2 id="vyvody">  findings </h2><br><ul><li>  Do events reduce connectivity?  Not always.  Events are great for decentralization and end-to-end functionality, but you should not make complex chains of message transfer from service to service.  Instead, use teams and services managers. </li><li>  Should we avoid centralization?  Without fanaticism.  Smart ESB does not work well with microservices.  Prefer simple transmission channels and smart endpoints.  Smart services with business logic inside - prevent the god-like service manager, who has absorbed everything and everyone, from coming to light.  Smart service will be able to perform long-running business process. </li><li>  Is a workflow engine a pain?  Not always.  In the past, there was a vendor-lok and attempts to create "zero-code" tools.  Now there are lightweight open source frameworks that solve typical problems.  Do not cycle the state machines, use ready-made tools. </li></ul><br><div class="spoiler">  <b class="spoiler_title">About the authors</b> <div class="spoiler_text"><p>  <strong>Bernd Rucker.</strong>  Participated and trained in a huge number of software development projects related to long-running business processes.  Including: in Zalando (international clothes seller) and several telecom companies.  Contributor of several open source workflow engines.  Author of the book "Real-Life BPMN", co-founder of Camunda. </p><br><p>  <strong>Martin Schimak.</strong>  Over 10 years of experience in the energy industry, telecom and ... wind tunnels.  Contributor of several projects on GitHub.  Speaker at ExploreDDD, O'Reilly Software Architecture Conference and KanDDDinsky.  Personal blog <a href="http://plexiti.com/">plexiti.com</a> .  Organizer of mitapov on microservices and DDD (Vienna). </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346630/">https://habr.com/ru/post/346630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346608/index.html">We test user scripts with Hermione. Yandex lecture</a></li>
<li><a href="../346610/index.html">Reasoning around systems engineering and comments on "Richard Hamming: Chapter 28. Systems Engineering"</a></li>
<li><a href="../346618/index.html">Correcting typos with context</a></li>
<li><a href="../346622/index.html">Examination of internal FPGA defects: we are looking for a black cat in a dark room</a></li>
<li><a href="../346628/index.html">Spring Security interrogation query path</a></li>
<li><a href="../346632/index.html">Parsim memes in python: how to bypass the server lock</a></li>
<li><a href="../346634/index.html">Lab: Introduction to Docker from scratch. Your first microservice</a></li>
<li><a href="../346636/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ297 (January 8 - 14, 2018)</a></li>
<li><a href="../346640/index.html">Studying the wget command with 12 examples</a></li>
<li><a href="../346642/index.html">PHP Digest 123 (January 1 - 14, 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>