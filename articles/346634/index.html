<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lab: Introduction to Docker from scratch. Your first microservice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, username! Today I will try to present you another article about the docker. Why am I doing this if there are already many such articles? There are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lab: Introduction to Docker from scratch. Your first microservice</h1><div class="post__text post__text-html js-mediator-article">  Hi, username!  Today I will try to present you another article about the docker.  Why am I doing this if there are already many such articles?  There are several answers here.  First of all, not all of them describe what I myself would have been very useful at the very beginning of my study of the docker.  Secondly, I would like to give people a little practice to theory directly on this theory.  One of the important reasons is to put all the experience accumulated over this short period of study by the docker (I have been working with him for a little more than six months) in some kind of format, having laid out everything for myself.  Well, in the end, to pour out my soul, describing some rakes to which I have already stepped (to give advice about them) and forks, the solution of which in the docker is simply not provided out of the box and whose problems it would be worth thinking about at the stage when you are bursting with keen desire to transfer the whole world around itself into containers before realizing that this technology is not suitable for all things. <br><br>  What will we consider in this article? <br><br>  In Part 0 (theoretical) I will tell you about the containers, what it is and what they eat <br>  In Parts 1-5 there will be a theory and practical task, where we will write microservice in python, working with the rabbitmq queue. <br>  In Part 6 - the afterword <br><a name="habracut"></a><br><h2>  Part 0.0: we warm up the tires </h2><br>  What is a docker?  This is such a new way to isolate your applications from each other using linux namespaces.  It is extremely easy to manage, expand, migrate, and is suitable for a huge range of tasks ranging from application development and package building to five-minute tests (run-check 1-2 commands-close and forget, and also clean up the trash) .  Read more on the <a href="https://www.docker.com/what-docker">off site</a> .  It is only necessary to imagine at the first stage that the container consists of layers, i.e.  from the file system state casts.  I will tell about it a bit later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The laboratory infrastructure of this article can be replicated on the same operating system with Linux on board, or on the \ vps \ whatever virtual machine series.  I did everything on one dedicated server with Debian OS.  Hereinafter, I assume that you are working in the same Debian 9 OS. Commands and approaches from the OS to the OS may differ, it‚Äôs impossible to describe everything in one article, so the server OS I‚Äôve chosen is the most familiar to me.  I hope it will not be difficult for you to install yourself a virtual machine and give it access to the Internet. <br><br>  We will need to install docker-ce ( <a href="https://docs.docker.com/engine/installation/linux/docker-ce/debian/">official man</a> ) <br>  I do not set my task to chew on what is already written, so here I will give a link to the documentation, and in the listing I will give commands to install on <b>pure</b> Debian9 x64.  Commands that need to be executed on behalf of the superuser begin with the # character, and regular user commands start with $. <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common # curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | apt-key add - # add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") $(lsb_release -cs) stable" # apt update &amp;&amp; apt install docker-ce</span></span></code> </pre> <br><h2>  Part 0.1 Comparison with VM </h2><br>  It is important to remember that Docker is a means of isolating a process (task), and this means that you cannot treat a docker as a virtual machine.  It wraps around containerization tools (cgroups + namespaces) specifically the linux kernel.  But it has many similar features, like virtualization: <br><br><ol><li>  independence - the container can be moved to any OS with a docker service on board and the container will work.  (Officially, yes, in fact, I‚Äôm not sure that compatibility is as bright as pony, rainbow and butterflies. If you have any other experience, please share) </li><li>  self-sufficiency - the container will perform its functions in any place wherever it is launched. </li></ol><br>  Nevertheless, it differs from the usual virtualization: <br><br><ol><li>  Inside the container is the minimum required set of software necessary for the operation of your process.  This is no longer a full-fledged OS that needs to be monitored, monitor the rest of the space, etc., etc. </li><li>  A different approach to virtualization is used.  <a href="https://www.docker.com/what-container">read about it</a> .  I mean the principle itself - there is no familiar host OS. </li><li>  It should be particularly relevant to the container and the data generated by it.  A container is a data processing tool, but not a storage tool.  As an example, a container is a nailing machine, data submitted to the input is a board and a nail, and the result of the work is to hammer a nail into the board.  At the same time, the board with the nail does not remain part of the same nailing machine, the result is separate, the tool is separate.  Output data should not be saved inside the container (it is possible, but this is not a docker-way).  Therefore, the container is either a worker (worked, reported to the queue), or, if it is, for example, a web server, then you need to use external volumes.  (all this is very simple, you should not be sad at this moment). </li></ol><br><h2>  Part 0.2 Container processes </h2><br>  Now that we‚Äôve figured out what a docker is, we‚Äôll see through the binoculars what‚Äôs inside.  We need to remember the following postulates: <br><br><ol><li>  The container lives while the process lives around which the container is born. </li><li>  Inside the container this process has pid = 1 </li><li>  Next to the process with pid = 1, you can spawn as many other processes as you like (within the capabilities of the OS, of course), but by killing (restarting) the process with pid = 1, the container exits.  (see item 1) </li><li>  Inside the container you will see the usual directory arrangement according to <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">FHS</a> standards.  The location is identical to the original distribution (from which the container was taken). </li><li>  The data created inside the container remains in the container and is not stored anywhere else (well, you can still access this layer from the host OS).  deleting the container will lose all your changes.  Therefore, the data in the containers are not stored, and carried out to the host OS. </li></ol><br><h2>  Part 0.3 Where do you get these containers from?  how to store? </h2><br>  There are public and private storage of official and unofficial images.  They are called docker registry.  The most popular of them is <a href="https://hub.docker.com/">Docker hub</a> .  When you dock any service, go first to the hub and see if someone has already done it for you? <br><br>  It will also be a great help for you at the time of study.  since the finished Dockerfile is visible on the hub, you can see the cool uncles and how they do this or that thing.  A lot of them are stored on github and other similar resources. <br><br>  In addition to the public registry, there are also private ones - paid and free.  Paid you will need it when you, after having been tortured by the maintenance, exclaim ‚Äúlet these guys follow all this puffed docker orgy in these your registry‚Äù.  And the truth is, when you actively use the docker with DevOps, when people or automation build hundreds of containers, then sooner or later you will start to burn from how to clean and maintain it. <br><br>  Not all of course so bad, of course.  For a dozen people and a couple of builds per day, your registry will do.  For personal use all the more. <br><br>  Why registry can be useful?  it is a single place for storing and exchanging containers between you, other people, or automatics.  And this is a really cool thing.  You can put and pick up the finished container with just one team, and provided that it weighs a penny (compared to VM), then the advantages are just on the face.  The truth is that the docker is a tool, the docker registry does not store the data of your working containers.  In this way, you can have a very convenient workflow: developers write a product, build a new container, push it into the repository.  Testers take it, test it, give it a go-ahead.  Devopsy then using, for example, ansible roll containers on the prod.  And it doesn‚Äôt matter to you whether you have a server or 100, using ansible and registry, rolling containers into food is a pleasure.  Here and all the stuffing with CI - new versions can be automatically downloaded by the build server.  Therefore, I highly recommend, even for personal use, to get a VPS \ DS with the registry, it is very convenient to exchange containers. <br><br>  Download the image from the repository: <br><br><pre> <code class="bash hljs">docker pull wallarm/node</code> </pre> <br>  Upload image to repository: <br><br><pre> <code class="bash hljs">docker push example.com:5000/my_image</code> </pre> <br>  In private repositories, you also need to login, for this you need the command <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  where you need to enter a username and password. <br><br>  You can run your registry with just one command: <br><br><pre> <code class="bash hljs">docker run -d -p 5000:5000 --restart=always --name registry registry:2</code> </pre> <br>  <a href="https://docs.docker.com/registry/deploying/">More</a> on the off site.  SSL, authorization - all this is possible. <br><br><h2>  Part 0.4. Containers and images (images) </h2><br>  The docker image (image) is a certain set of layers.  Each layer is the result of the command in the Dockerfile.  Roughly speaking, an image is a template on the basis of which you will run containers.  Everything that runs on the basis of this image is a container, or an instance.  those.  From one image you can run multiple identical copies of this image - containers.  And then, after some manipulations, from this container you can create a template - a new image.  All this mess is stored in / var / lib / docker. <br>  <a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/">documentation</a> <br><br>  The list of images on your system can be viewed with the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># docker images</span></span></code> </pre> <br>  Container list: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  the -a switch will show the stopped ones, and the -s switch will show its size.  those.  how much actually, now, in runtime, this container takes up disk space. <br><br><h2>  Part 0.5 How to name containers and images (images)? </h2><br>  The image has 3 fields related to naming: <br><br>  1) Repository <br>  2) Tag <br>  3) Image ID <br><br>  The repository is real or unreal, is this the place from where or where your image will be downloaded / uploaded, or is it just a made-up name if you are not going to download it anywhere. <br>  A tag is usually a product version.  In theory, this is any set of characters.  (from the allowed list [a-z0-9.-] etc.) If there is no tag, then the word <b>latest is</b> automatically used.  a tag is placed through the symbol: on behalf of the repository and is automatically substituted if not specified during push \ pull. <br>  ImageID is a locally generated unique ID of your image by which you can operate on this image. <br><br>  Thus, you or the author of the container influence the repository and / or tag, and the system locally affects the ID.  But, by the way, no one bothers you to reuse any other repository name, another question is what you can not push (load) into it <br><br>  For example: <br><br>  1/2/3-blah.blah.blah - the name of your local image, you have invented it <br>  projects / my_first_docker is also the name of your local image <br>  projects / my_first_docker: latest is the same name but tagged.  equivalent to the previous one. <br>  projects / my_first_docker: 1.13.33 - and this is a specific version of the image in this repository. <br>  projects / my_first_docker: 1.13.34 <br>  projects / my_first_docker: 1.13.35 <br>  ... etc - all this is the same project, but the versions of your images will be different. <br><br>  One of the big docker chips is the reuse of layers.  This means that if the layer has not changed, then the new version of your image will be able to use layers of other containers.  For example, the root layer with debian will be used by all containers based on debian.  If your second layer, for example, the nginx installation, and the third - to put a config, then at change of a config and assembly of a new image, it will consist of 2 old layers and one new.  But do not rush to rejoice.  Although this reuse can save space, the docker can still podstraat these layers, which he creates for every sneeze.  due to reuse, these layers will have hellish dependencies on each other and in the end, on large installations where a lot of containers are assembled, this will be the same flaky orgy about which I have already spoken above.  But you should not take what has been said as something that will happen to you, I'm talking about a loaded system with dozens of new builds on a day when the entire office, along with automation, collects something all day.  There is no such bacchanalia on ordinary servers - there you will only have a couple of containers.  And on the other hand, this is also pretty simple to clean - just rm -rf.  The most important thing for you is the containers, and they are in the repository and will simply be automatically downloaded again.  Well, the result of the work and so you do not store in the container. <br><br>  More examples: <br><br>  wallarm / node - and this is an image already downloaded from a public docker hub with the best WAF from Wallarm. <br>  debian: stretch - the debian image, the version of the image is stretch (not a number, but a word) <br>  centos: 7 is similar to debian. <br>  mongo: 3.2 - mongodb version 3.2 image downloaded from public repository <br>  nginx - latest stable nginx - the same. <br><br>  And most often on the hub, you can see the various versions of the software you need.  For example, mongo will give you download 3.2, 3.4 and 3.6, and even dev versions.  and various intermediate.  and a bunch of others. <br><br>  Imagine how convenient - you have Monga 3.2 spinning, you want to try another version next to it.  just download the container with the new version and launch it.  and no need to raise any virtual locks, tweak them, clean them up.  After all, all that is needed to remove the docker image is to enter the docker rmi command.  And it weighs incomparably less.  200 meters for example.  And if you want even cooler - you can use a ready-made solution based on alpine linux.  bind9-alpine.  one demon.  3 config.  15 megabytes !!!  and this is a complete, ready-to-use installation. <br><br>  It should be remembered: the same image can have as many repository names and tags, but will have the same imageid.  At the same time, the image will not be deleted until all tags of this image are deleted.  those.  After downloading the debian image, giving it a new tag you will receive 2 images in the list with different names, but the same imageid.  and removing debian: stretch, you simply remove one of the tags, and the image itself will live. <br><br>  To set a different name for an existing image, use the command: <br><br><pre> <code class="bash hljs">docker tag &lt;existing image name&gt; &lt;new image name&gt;</code> </pre> <br>  To delete an image: <br><br><pre> <code class="bash hljs">docker rmi &lt;image&gt;</code> </pre> <br>  But containers have 2 names: <br><br>  1) CONTAINER ID <br>  2) Name <br><br>  With id - the same thing here - this is the unique name of a specific unique launched instance of an image.  to put it simply - the unique name of the running image.  The image can be run as many times as desired and each copy will receive a unique name. <br><br>  Name - and this is the name that is more convenient for humans and scripting.  The fact is that when launching various images you will never know with what name you launched it, until you climb up, look at the running containers, or take this exhaust when you start the container.  considering that you can log to stdout, your container name will be lost.  So you can pre-set the name for the running container using the --name key, then you can operate on it with a immediately known name. <br><br>  Container list: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  To remove a container: <br><br><pre> <code class="bash hljs">docker rm &lt;container&gt;</code> </pre> <br><h2>  Part 0.6 Okay, all these are other people's containers, and how can I make my own, from scratch? </h2><br>  There is a docker build mechanism for creating your containers.  It uses a set of instructions in the Dockerfile to build your own image.  When building the container, the sh shell is used inside and your commands are executed in it. <br><br>  You should know the following: <br><br><ol><li>  Each completed command creates a file system layer with the results of changes generated by this command.  those.  for example, running the apt install htop command will create a layer that will contain the result of executing this command - binaries, libraries, etc.  in the end, each such layer will be superimposed on each other, and then on the original (the image of the operating system) and you will get the final result.  From here come several limitations: </li><li>  Layers are independent of each other.  This means that any service running during the build process inside the container exists only within its layer.  A vivid example is an attempt to fill the database in mysql.  How does this usually happen?  you need to start a mysql server and use the following command to fill in the database.  It won't work that way here.  A layer will be created that will save the results of running mysql (logs, etc.) and then mysql will simply end.  in the next layer (when executing the base fill command), the muskul will no longer be running and there will be an error.  The solution to this problem is simply to unite the teams through &amp;&amp;. </li><li>  3) But the permanent data will be superimposed from the first team to the last one on top of each other and stored permanently from layer to layer.  Therefore, creating a file with the first command, you can access it in the last command. </li></ol><br><h2>  Part 0.7 Finally, and "This is not docker-wei" </h2><br>  Docker pretty litter layers in the build.  In addition, you can leave a bunch of stopped containers.  Remove all with one command. <br><br><pre> <code class="bash hljs">docker system prune</code> </pre> <br><h3>  This is not docker-wei </h3><br>  The docker on the idea virtualizes exactly one process (with any number of descendants).  Nobody bothers you, of course, stuffing in one container and 10 processes, but then blame yourself. <br>  This can be done using, for example, supervisor. <br><br>  But, you say, what about the services that, well, all their lives will be together and should not be separated?  use content that a friend will generate for a friend? <br><br>  In order to do this beautifully and correctly, docker-compose is a yaml file that describes N your containers and their relationships.  what container with which to cross, what ports for each other to open, what data to share. <br><br>  In the case of compose, you actually manage your project easier.  for example, the nginx + uwsgi + mongo bundle is 3 containers, although it is known that no one except nginx will go to uwsgi, and besides uwsgi - no one in mongo.  Yes, and they will always live together.  (THIS IS A PRIVATE CASE).  This is where we get the following situation - your application (api) will be updated often - you write and push it every day.  and, for example, releases of nginx or mongodb come out much less often - maybe a month, maybe longer.  So why bother to build this heavyweight every time, when changes happen in one place?  When it comes time to update nginx, you simply change the name of the tag and the entire project rebuild, just download the new container from nginx. <br><br><h2>  Part 1: when is practice? </h2><br>  At this stage, you can try to touch the containers and teach the necessary commands.  I am a supporter of driving teams from tutorials manually.  Therefore - only screenshots. <br><br>  1. Let's try download debian image <br><br><img src="https://habrastorage.org/webt/9f/pq/je/9fpqjemaarlnz2smq4gzpye_6i4.png" alt="image"><br><br>  2. Look what happened.  In my case, I used the word debian for the filter, since  otherwise a bunch of other images would have fallen out in the output.  you do not need to use it.  Well, as a result - you will have 2 identical imageid with different tags (I have the first two). <br>  ZY  hello to the future!  for those who will live to debian10 and will read this article, you will not have the same result as me.  I hope you understand why. <br><br><img src="https://habrastorage.org/webt/63/sw/gf/63swgfgljzxsoo6qzr4gbvkyldi.png"><br><br>  3. Run the bash process inside the debian: stretch image.  Look at his pid - it is equal to one.  Those.  This is the main process around which we are dancing.  Please note - we could not execute ps aux so easily - there is no package in the container.  we can put it as usual with apt. <br><br><img src="https://habrastorage.org/webt/kf/2y/ar/kf2yard1a0ntvyt9sjq41typ7sy.png"><br><br>  4. Exit the container (exit | Ctrl + D) and try to launch the bash again ‚Äî this is in the upper console (you can open another one, I did this for simplicity of screenshots).  In the lower window - see the list of running containers. <br><br><img src="https://habrastorage.org/webt/_b/1t/vz/_b1tvzdpmmhm7q9mx-yla-szpjc.png"><br><br>  Wow!  and where did the procps go?  yes nowhere  he is not here and was not.  when we launched the image again, we took the same impression without the installed program.  and where did the result of our work go?  And there he lies - in a state of exited.  As well as a bunch of other containers that I started earlier and stopped afterwards. <br><img src="https://habrastorage.org/webt/rn/c7/ef/rnc7efey8tt92u28amu4toggiqm.png"><br><br>  All this is rubbish.  But it can still be revived: <br><br>  1. exit container in terminal 1 <br>  2. in the second terminal we copy the ID of the container, suitable for the timeshtamp as the one we then stopped <br>  3. in 1 terminal we start this container with the start command.  he goes to the background <br>  4. in the second terminal we look at the list of running containers - according to the timestamp the one that is running 7 seconds is clearly ours. <br>  5. Feint ears.  Attach to the already running container with the exec command and start the second instance of bash. <br>  6. perform ps aux - note that the first bash lives with pid 1.  and we in the container now manage it via bash with pid = 7.  and now, if we leave, the container will live. <br><img src="https://habrastorage.org/webt/iq/tk/0v/iqtk0vd9z5-akk-1h71ysjjteya.png"><br><br>  So: <br>  <b>run</b> - take image X and create container Z with process Y <br>  <b>exec</b> - take the container Z and run the process N in it, while the process Y will work as before. <br><br>  Findings: <br><br>  1) The container can live both in the background and in the foreground, so long as the process that we virtualize is alive. <br>  2) a container is an instance deployed from an image. <br>  3) containers can be stopped and started without data loss (but not worth it, this is not docker-wei) <br><br><h2>  Part 2: Making Your Own Docker Image </h2><br><br>  Learning to use dockerfile. <br>  Here are two approaches to development: <br><br>  1) take ready and sharpen for themselves <br>  2) do it yourself from scratch <br><br>  Option one is when you are sure that you have already done all the work perfectly.  For example, why install nginx when you can get a ready-made official container with nginx.  This is especially true of those systems that are not put into one command or which, for example, in debian have outdated versions, and on the docker hub they are built with more recent stable ones.  Moreover, there is already an auto-assembly done - the latest versions arrive there pretty quickly. <br><br>  Option two - you are paranoid or you do not like the approach of the author of the image (for example, the official was not found, but there is only on the hub of Vasya Pupkin).  No one bothers to see how Basil did it, and then go and do it yourself.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, or in case you just write your logic, which is definitely nowhere to be found, such as a docker image for the build of your deb-packages in jenkins. But it is very convenient! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dockerfile is a file with a set of instructions that will be performed in a clean container of the image you specified, and you will receive your image at the output. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important thing you need to specify is the FROM and CMD directives (not necessary in principle). I will give an example of such a file: </font></font><br><br><img src="https://habrastorage.org/webt/cj/fr/of/cjfrofsisd3mxqe165ybgklo9mu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FROM - which image to base. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAINTAINER - the author of this development (someone to kick for the work of this, a new image) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RUN - a command executed inside the container, on the basis of which a new image will be obtained. Pay attention - the usual bash transfers and &amp;&amp; makes the code readable and beautiful.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also write at least 10 RUN - commands (but each from a new line) in which to describe your logic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPOSE - which ports, according to which protocol will be available outside the container when using docker-compose. Here it is important to remember that this does not mean that they will be accessible from the outside immediately.</font></font> those.  ,            : ,     .           : <br><br> 1)     0.0.0.0:80 (  0.0.0.0!!!,     ‚Äî      ).      mysql. ,         ,      . <br> 2) docker run -p 80:80 image <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is the only way - it turns out that when accessing a host on port 80, you will be mapped into a container on port 80. when the container was started, this port was opened, and inside the container, the application listens to port 80. and so, you will get from port 80 of the host to port 80 of the application. Naturally ports can be made any. So, you can run a lot of containers, inside which nginx listen to port 80, and make the mapping outside like this: 8000: 80, 8001: 80, 8002: 80 ... well, etc., the idea is clear. Thus, you can make 1 image with one config, and run it parallel and independently many times.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMD - and this is the most crucial place. This is the command that will be executed when the container is started and it works all the time. Remember yes? while the process works, the container lives. Here, the approach is the same as in systemd - the process should not go to the background - this is no need, the process is just one inside this container. From here by the way and different approaches logging. for example, you can leave the output in STDOUT, and you can in the logs. The main thing is that the process (main process) after the launch remains live. and forks-threads can be as much as you like. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to CMD, there is another type of shamanism - ENTRYPOINT. this is usually a shell script to which the CMD value is passed as an argument. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to remember the following things: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) the final command to start the process in the container = sum ENTRYPOINT + CMD.</font></font><br> 2)          entrypoint  cmd ‚Äî     ,   . <br><br>  For example: <br> ENTRYPOINT ["/entrypoint.sh"] <br> CMD [¬´haproxy¬ª, "-c", "/etc/haproxy/haproxy.conf"] <br>        : <br> sh -c "/entrypoint.sh haproxy -c /etc/haproxy/haproxy.conf". <br>        ‚Äî   . <br><br>    ?    entrypoint     .       ,      CMD    ENTRYPOINT . <br><br>  1: <br>    : <br> docker run haproxy <br>  ENTRYPOINT + CMD: <br> sh -c "/entrypoint.sh haproxy -c /etc/haproxy/haproxy.conf" <br>     .   entrypoint.sh    :    = haproxy,  haproxy = haproxy -db -W $@.   .       : <br><br><pre> <code class="bash hljs">haproxy -db -W -c /etc/haproxy/haproxy.conf<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  2: <br>    : <br> docker run haproxy bash <br>  bash ‚Äî   CMD  dockerfile.   ENTRYPOINT + CMD  : <br> sh -c "/entrypoint.sh bash" <br>   ,    != haproxy,    .         . <br><br>  3: <br>    haproxy       . <br> docker run haproxy haproxy -c /opt/haproxy.conf <br>   haproxy ‚Äî  ,      ‚Äî ,  .    CMD,   : <br> sh -c "/entrypoint.sh haproxy -c /opt/haproxy.conf" <br>    : <br><br><pre> <code class="bash hljs">haproxy -db -W -c /opt/haproxy.conf<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>      ,  .        ENTRYPOINT+CMD.  ,            ,       dockerfile. <br><br>    ,    ,  ADD, COPY ‚Äî      ,   ADD     ,        .      . <br><br>   Dockerfile ! (   ) <br>     Dockerfile        ,     . <br>  Example: <br><br><pre> <code class="hljs lua">COPY <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> RUN apt install <span class="hljs-number"><span class="hljs-number">100500</span></span>-programms-pack</code> </pre><br>                   100500 .         ,       ‚Äî ..      . <br><br><h2>  3:      </h2><br>           .     :  , ,       .             ,       .    ‚Äî     . - ‚Äî   \  .    ‚Äî  \   \ .   ,           .  ,        ‚Äî        -.   ‚Äî        ,  ,    .  . <br><br>       -v: <br><br><pre> <code class="bash hljs">-v /<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>/folder:/destination/folder -v /path/to/file:/path/to/config</code> </pre> <br>             ,    -      . <a href="https://habrahabr.ru/post/337306/"></a> <br><br>        ,  .     ,      Dockerfile (ENV key=value),       ,     ,    . <br><br><h2>  4:     </h2><br>       ,  ,     ,     ?   ‚Äî  systemd! <br><br> ,  : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># &gt;/etc/systemd/system/my-project.service # systemctl daemon-reload # systemctl edit --full my-project.service</span></span></code> </pre><br>    : <br><br><pre> <code class="bash hljs">[Unit] Description=my first docker service Requires=docker.service After=docker.service [Service] Restart=always RestartSec=3 ExecStartPre=/bin/sh -c <span class="hljs-string"><span class="hljs-string">"/usr/bin/docker rm -f my-project 2&gt; /dev/null || /bin/true"</span></span> ExecStart=/usr/bin/docker run --rm -a STDIN -a STDOUT -a STDERR -p 80:80 -v /etc/my-project/:/etc/my-project --name my-project:2.2 ExecStop=/usr/bin/docker stop my-project [Install] WantedBy=multi-user.target</code> </pre><br>      : <br><br> ExecStartPre ‚Äî     \      -     my-project.       (,  ) ‚Äî         ,          . <br> --rm ‚Äî       .       <br> --name my-project ‚Äî    <br> -a STDIN -a STDOUT -a STDERR ‚Äî attach to std* ‚Äî    \\  .               systemd <br> -p ‚Äî  0.0.0.0:80  -&gt; 80    <br> -v ‚Äî     <br>    ,    .         ‚Äî tcp  udp. - ‚Äî tcp. <br><br>  -: <br><br><pre> <code class="bash hljs">systemctl restart my-project.service &amp;&amp; journalctl -u my-project.service --no-pager -f</code> </pre> <br>    ‚Äî      systemd ,  journalctl ‚Äî  stdout  . <br><br><h2>  5:   .    </h2><br>      : <br> send.py -&gt; rabbitmq -&gt; read.py <br><br>  Those.  3 ,      ,  .      systemd. <br><br> sender.py    5       1  7,   (receiver.py)        ‚Äî   -    . <br><br>       ,      ‚Äî    ,     ‚Äî .      , ,      .      ,    .       /etc   /var/log,       , .    .      ,        ,        .  ,       . ssh  docker,   ? (,  , ,     puppet,        -.   ‚Äî       .      ,    ‚Äî   . ,       ,     .      ,     ) <br><br> 1. RabbitMQ <br> RabbitMQ ‚Äî     .       .         .       .    rabbitmq    3  ‚Äî Dockerfile  2   .   ‚Äî    .  , ,   ‚Äî  json  definitions. <br><br><pre> <code class="bash hljs">mkdir -p ~/Documents/my_project/{sender,receiver,rabbitmq} <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Documents/my_project/rabbitmq <span class="hljs-comment"><span class="hljs-comment">##  ,     (  ) docker build -t rabbitmq:1.0 . &gt;/etc/systemd/system/my_project-rabbitmq.service ##    systemd systemctl edit --full my_project-rabbitmq.service ##   systemctl start my_project-rabbitmq ##  docker ps systemctl status my_project-rabbitmq</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">/etc/systemd/system/my_project-rabbitmq.service</b> <div class="spoiler_text"><pre> <code class="bash hljs">[Unit] Description=my first docker service Requires=docker.service After=docker.service [Service] Restart=always RestartSec=3 ExecStartPre=/bin/sh -c <span class="hljs-string"><span class="hljs-string">"/usr/bin/docker rm -f rabbitmq 2&gt; /dev/null || /bin/true"</span></span> ExecStart=/usr/bin/docker run --rm -a STDIN -a STDOUT -a STDERR -p 5672:5672 --name rabbitmq rabbitmq:1.0 ExecStop=/usr/bin/docker stop rabbitmq [Install] WantedBy=multi-user.target</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/rabbitmq/rabbitmq.conf</b> <div class="spoiler_text"> management.load_definitions = /etc/rabbitmq/definitions.json <br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/rabbitmq/definitions.json</b> <div class="spoiler_text"><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"rabbit_version"</span></span>:<span class="hljs-string"><span class="hljs-string">"3.7.2"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"users"</span></span>:[{<span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"username"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"password_hash"</span></span>:<span class="hljs-string"><span class="hljs-string">"P2bFyWm2oSwuzoRDw37nRYgagL0ciZSGus3kYnkG1aNaUWeD"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"hashing_algorithm"</span></span>:<span class="hljs-string"><span class="hljs-string">"rabbit_password_hashing_sha256"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"tags"</span></span>:<span class="hljs-string"><span class="hljs-string">""</span></span>},{<span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"guest"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"password_hash"</span></span>:<span class="hljs-string"><span class="hljs-string">"SjeLNFEWLHwuC5QRAaZIF/SX/uMasQFyt5+dELgKK03TgsC8"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"hashing_algorithm"</span></span>:<span class="hljs-string"><span class="hljs-string">"rabbit_password_hashing_sha256"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"tags"</span></span>:<span class="hljs-string"><span class="hljs-string">"administrator"</span></span>}],<span class="hljs-attr"><span class="hljs-attr">"vhosts"</span></span>:[{<span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"virtualhost"</span></span>},{<span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"/"</span></span>}],<span class="hljs-attr"><span class="hljs-attr">"permissions"</span></span>:[{<span class="hljs-attr"><span class="hljs-attr">"user"</span></span>:<span class="hljs-string"><span class="hljs-string">"guest"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"vhost"</span></span>:<span class="hljs-string"><span class="hljs-string">"/"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"configure"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"write"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"read"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>},{<span class="hljs-attr"><span class="hljs-attr">"user"</span></span>:<span class="hljs-string"><span class="hljs-string">"username"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"vhost"</span></span>:<span class="hljs-string"><span class="hljs-string">"virtualhost"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"configure"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"write"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>,<span class="hljs-attr"><span class="hljs-attr">"read"</span></span>:<span class="hljs-string"><span class="hljs-string">".*"</span></span>}],<span class="hljs-attr"><span class="hljs-attr">"topic_permissions"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"parameters"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"global_parameters"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"policies"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"queues"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"exchanges"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"bindings"</span></span>:[]}</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/rabbitmq/Dockerfile</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rabbitmq:management <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> rabbitmq.conf /etc/rabbitmq/rabbitmq.conf <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> definitions.json /etc/rabbitmq/ RUN chown rabbitmq:rabbitmq /etc/rabbitmq/rabbitmq.conf /etc/rabbitmq/definitions.json CMD ["rabbitmq-server"]</code> </pre><br></div></div><br> 2.   <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Documents/my_project/sender <span class="hljs-comment"><span class="hljs-comment">##   sender.py  Dockerfile,   docker build -t sender:1.0 . &gt;/etc/systemd/system/my_project-sender.service ##    systemd systemctl edit --full my_project-sender.service ##   systemctl start my_project-sender ##  docker ps systemctl status my_project-sender</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">/etc/systemd/system/my_project-sender.service</b> <div class="spoiler_text"><pre> <code class="bash hljs">[Unit] Description=my first docker service Requires=docker.service After=docker.service [Service] Restart=always RestartSec=3 ExecStartPre=/bin/sh -c <span class="hljs-string"><span class="hljs-string">"/usr/bin/docker rm -f sender 2&gt; /dev/null || /bin/true"</span></span> ExecStart=/usr/bin/docker run --rm -a STDIN -a STDOUT -a STDERR -v /etc/my_project/sender:/etc/my_project/sender --name sender sender:1.0 ExecStop=/usr/bin/docker stop sender [Install] WantedBy=multi-user.target</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">sender.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import pika, yaml, base64, time, random config_file = open("/etc/my_project/sender/sender.yaml","r") config = yaml.load(config_file) pika_username = config["rabbitmq"]["username"] pika_password = base64.b64decode(config["rabbitmq"]["password"]) pika_addr = config["rabbitmq"]["host"] pika_port = config["rabbitmq"]["port"] pika_virtualhost = config["rabbitmq"]["virtualhost"] pika_queue = config["rabbitmq"]["queue"] def send_message_rabbitmq(message="Hello World!"): credentials = pika.PlainCredentials(pika_username, pika_password) parameters = pika.ConnectionParameters(pika_addr, pika_port, pika_virtualhost, credentials) connection = pika.BlockingConnection(parameters) channel = connection.channel() channel.queue_declare(queue=pika_queue, durable=True) channel.basic_publish(exchange='', routing_key=pika_queue, body=message, properties=pika.BasicProperties( delivery_mode=2, )) connection.close() while True: send_message_rabbitmq(str(random.randint(1,7))) time.sleep(5)</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/sender/Dockerfile</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> debian:stretch RUN apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y -q install \ python3-pip &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> RUN pip3 install pika pyyaml <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> sender.py /opt/ CMD ["/usr/bin/python3", "/opt/sender.py"]</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">/etc/my_project/sender/sender.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">-- rabbitmq: username: username password: MTIzNDU2Nzg5MA== host: 192.168.136.181 port: 5672 virtualhost: virtualhost queue: queue</code> </pre><br></div></div><br> 3. Receiver ‚Äî   -worker. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Documents/my_project/receiver <span class="hljs-comment"><span class="hljs-comment">##   receiver.py  Dockerfile,   docker build -t sender:1.0 . &gt;/etc/systemd/system/my_project-sender.service ##    systemd systemctl edit --full my_project-sender.service ##   systemctl start my_project-sender ##  docker ps systemctl status my_project-sender</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">/etc/systemd/system/my_project-receiver.service</b> <div class="spoiler_text"><pre> <code class="bash hljs">[Unit] Description=my first docker service Requires=docker.service After=docker.service [Service] Restart=always RestartSec=3 ExecStartPre=/bin/sh -c <span class="hljs-string"><span class="hljs-string">"/usr/bin/docker rm -f receiver 2&gt; /dev/null || /bin/true"</span></span> ExecStart=/usr/bin/docker run --rm -a STDIN -a STDOUT -a STDERR -v /etc/my_project/receiver:/etc/my_project/receiver --name receiver receiver:1.0 ExecStop=/usr/bin/docker stop receiver [Install] WantedBy=multi-user.target</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">/etc/my_project/receiver/receiver.yaml</b> <div class="spoiler_text"><pre> <code class="hljs cpp">--- rabbitmq: username: username password: MTIzNDU2Nzg5MA== host: <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.136</span></span><span class="hljs-number"><span class="hljs-number">.181</span></span> port: <span class="hljs-number"><span class="hljs-number">5672</span></span> virtualhost: virtualhost <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/receiver/receiver.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import pika, yaml, base64, time log_file = open("/var/log/my_project/receiver/receiver.log","a") config_file = open("/etc/my_project/receiver/receiver.yaml","r") config = yaml.load(config_file) pika_username = config["rabbitmq"]["username"] pika_password = base64.b64decode(config["rabbitmq"]["password"]) pika_addr = config["rabbitmq"]["host"] pika_port = config["rabbitmq"]["port"] pika_virtualhost = config["rabbitmq"]["virtualhost"] pika_queue = config["rabbitmq"]["queue"] credentials = pika.PlainCredentials(pika_username, pika_password) parameters = pika.ConnectionParameters(pika_addr, pika_port, pika_virtualhost, credentials) connection = pika.BlockingConnection(parameters) channel = connection.channel() channel.queue_declare(queue=pika_queue, durable=True) print(' [*] Waiting for messages. To exit press CTRL+C') def callback(ch, method, properties, body): print(" [x] Received %r" % (body,)) #this goes to stdout print("[x] Received %r" % (body,), file=log_file) #this goes to log file time.sleep(int(body.decode('ascii'))) channel.basic_ack(delivery_tag = method.delivery_tag) channel.basic_qos(prefetch_count=1) channel.basic_consume(callback, queue=pika_queue) channel.start_consuming()</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">~/Documents/my_project/receiver/Dockerfile</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> debian:stretch RUN apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y -q install \ python3-pip &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> RUN pip3 install pika pyyaml RUN mkdir /var/<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>/receiver <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> receiver.py /opt/ CMD ["/usr/bin/python3", "/opt/receiver.py"]</code> </pre><br></div></div><br>   ,  .       .         ,     .     .      ‚Äî      .  ‚Äî  . <br><br><h2>  6:  </h2><br>      .        .    ,     ,    ,    ,     ‚Äî      ,       .   ,  ,      !    -  Dockerfile ‚Äî ,       ,        .      -         ansible\puppet\chef,              .    ,        .   ‚Äî  !        ‚Äî  . ,      virtualenv, , ,          ‚Äî  . <br><br>  ,       ,         docker hub.   ,       . , , , /etc/init.d/uwsgi start ‚Äî   .  why?       uwsgi  docker. <br><br>   uwsgi  docker   ‚Äî      init  . <br><br> 1) /etc/init.d/uwsgi start   .   ,  , .       .      : <br><br><pre> <code class="hljs kotlin">start-stop-daemon --start --quiet \ --pidfile <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PIDFILE</span></span></span><span class="hljs-string">"</span></span> \ --exec <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$DAEMON</span></span></span><span class="hljs-string">"</span></span> \ --test &gt; /dev/<span class="hljs-literal"><span class="hljs-literal">null</span></span> \ &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>      ,            init-.    ,        /proc/{id}/exe.              0,  ,      &amp;&amp;          2 (return 2),        (  ).           14 : <a href="https://github.com/moby/moby/issues/6800">github.com/moby/moby/issues/6800</a> . <br><br> Workaround: <br><br>       ,      ,  . <br> a)    /usr/share/uwsgi/init/specific_daemon       --exec  --startas.   ( , ,     ,    )    startas    /proc/{id}/exe         pid. (https://chris-lamb.co.uk/posts/start-stop-daemon-exec-vs-startas) <br> b)     --cap-add=SYS_PTRACE.       . <br> )    init-. <br><br> 2)   /etc/init.d/uwsgi start     .      ( ?).       ,          .            ,               ,         . <br><br>     : <br><br> 1)      (    ): <br><pre> <code class="bash hljs">... stats = 0.0.0.0:9090 socket = 0.0.0.0:3031 pidfile = /run/uwsgi/pid socket = /run/uwsgi/socket ...</code> </pre> <br><br> 2)  Dockerfile: <br><br><pre> <code class="hljs perl">... COPY app.ini /etc/uwsgi/apps-enabled/app.ini RUN <span class="hljs-keyword"><span class="hljs-keyword">mkdir</span></span> /run/uwsgi &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">chown</span></span> www-data /run/uwsgi CMD [<span class="hljs-string"><span class="hljs-string">"/usr/bin/uwsgi"</span></span>, <span class="hljs-string"><span class="hljs-string">"--ini"</span></span>, <span class="hljs-string"><span class="hljs-string">"/etc/uwsgi/apps-enabled/app.ini"</span></span>]</code> </pre><br>           .1      .2,       pid\socket. <br><br>     community-edition      .        !      .            ‚Äî        ,      ,     . <br><br>    - . -        ‚Äî kubernetes\docker swarm.   kubernetes     helm.    ,       ;)‚Ä¶ <br><br><br> .   .        ,    .     . <br><br>   !     .           <a href="https://t.me/bykvaadm"></a>  . </div><p>Source: <a href="https://habr.com/ru/post/346634/">https://habr.com/ru/post/346634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346618/index.html">Correcting typos with context</a></li>
<li><a href="../346622/index.html">Examination of internal FPGA defects: we are looking for a black cat in a dark room</a></li>
<li><a href="../346628/index.html">Spring Security interrogation query path</a></li>
<li><a href="../346630/index.html">Events, processes and services: a modern approach to automating business processes</a></li>
<li><a href="../346632/index.html">Parsim memes in python: how to bypass the server lock</a></li>
<li><a href="../346636/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ297 (January 8 - 14, 2018)</a></li>
<li><a href="../346640/index.html">Studying the wget command with 12 examples</a></li>
<li><a href="../346642/index.html">PHP Digest 123 (January 1 - 14, 2018)</a></li>
<li><a href="../346644/index.html">Rust: "Back to the roots"</a></li>
<li><a href="../346646/index.html">Announcement of the conference Heisenbug 2018 Piter. Make Heisenbug, not war«É</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>