<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Annotation to "Effective Modern C ++" by Scott Myers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of months ago, Scott Meyers ( Scott Meyers ) has released a new book, Effective Modern C ++ . In recent years, he is undoubtedly the No. 1 wr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Annotation to "Effective Modern C ++" by Scott Myers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/069/615/2ef/0696152ef06e40cba11aa1eaba203f11.gif" align="left">  A couple of months ago, Scott Meyers ( <a href="http://www.aristeia.com/">Scott Meyers</a> ) has released a new book, <a href="http://shop.oreilly.com/product/0636920033707.do%3Fcmp%3Daf-code-books-video-product_cj_0636920033707_7708709">Effective Modern C ++</a> .  In recent years, he is undoubtedly the No. 1 writer ‚Äúabout this,‚Äù besides, he is a brilliant lecturer and each of his new books is simply doomed to be read by C ++ writers.  Moreover, I waited for just such a book for a long time, the C ++ 11 standard came out, C ++ 14 followed it, C ++ 17 is already seen ahead, the language is changing rapidly, but nowhere have the changes been described in general, the relationship between these are dangerous places and recommended patterns. <br><br>  Nevertheless, regularly looking through Habr, I did not find the publication about the new book, it seems I will have to write myself.  Of course, there will not be enough of me for a full translation, so I decided to make a brief squeeze, modestly calling it an annotation.  I also took the liberty to regroup the material, it seems to me that for a short retelling this order is better suited.  All code examples are taken directly from the book, occasionally with my additions. <br><a name="habracut"></a><br>  One warning: Myers <i>does not describe syntax</i> , it is assumed that the reader knows the keywords, how to write a lambda expression, etc.  So if someone decides to start learning C ++ 11/14 with this book, he will have to use additional material for reference.  However, this is not a problem, everything is googled in one click. <br><br><h4>  From C ++ 98 to C ++ 11/14.  Gallop on all new </h4><br>  <b>auto</b> - at first glance, just a huge spoon of syntactic sugar, which, however, can change if not the essence of the form of C ++ code.  It turns out that Straustrup proposed to introduce this keyword (definite, but useless in C) in the current sense as early as 1983, but abandoned this idea under the pressure of the C-community.  See how it changes the code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(It b, It e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(b != e) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;It&gt;::value_type value=*b; .... } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(It b, It e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(b != e) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value=*b; ... } }</code> </pre> <br>  The second example is not just shorter, it hides a completely unnecessary exact type of expression here * b, by the way, in strict accordance with the canons of the classical, still pre-template, OOP.  Moreover, in fact, the expression std :: iterator_traits &lt;It&gt; :: value_type is nothing more than a brilliant crutch, invented at the beginning of STL to determine the type of iterator resulting from dereference, the first option will work only with the type for which the specialization iterator_traits &lt;&gt; is defined, for the second, only operator * () is needed.  Down with crutches! <br><br>  Do not convince?  Here's another example, in my opinion, just deadly: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unorderd_map&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; p : m) { ... }</code> </pre><br>  This code is not compiled, <br><div class="spoiler">  <b class="spoiler_title">proof</b> <div class="spoiler_text">  auto1.cc:8: 8: error: std :: pair &lt;std :: basic_string &lt;int&gt;, int&gt; from &lt;std :: basic_string &lt;pair&gt; int&gt; <br></div></div>  , the fact is that the correct type for std :: unordered_map &lt;std :: string, int&gt; is std :: pair &lt; <b>const</b> std :: string, int&gt;, it is obvious that the key must be constant, but it is much easier to use <i>auto</i> than to keep exact type of expression in the head. <br>  A few more points that give rigor to the language: <br><br><pre> <code class="hljs ruby">int x1=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>  int x2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>    ! auto x3=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>  auto x4; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> !    std::vector&lt;int&gt; v; unsigned x5=v.size(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">5</span></span>   size_t,    auto x6=v.size(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">6</span></span>  int f(); int x7=f(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>     f() ? auto x8=f(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">8</span></span> </code> </pre><br>  As you can see from these examples, the systematic use of <i>auto</i> can save a lot of nerves when debugging. <br><br>  And finally, where it is simply impossible without <i>auto</i> , lambda expressions: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> derefUPLess= [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp; p1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp; p2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p1 &lt; *p2; };</code> </pre><br>  In this case, the exact type of derefUPLess is known only to the compiler, it simply cannot be stored in a variable without using <i>auto</i> .  Of course it is possible to write this: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp;)&gt; derefUPLess= [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp; p1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget&gt;&amp; p2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p1 &lt; *p2; };</code> </pre><br>  however, std :: function &lt;&gt; and lambda are <i>not of the same type</i> , it means that a constructor will be called, possibly with memory allocation on the heap, besides the call to std :: function &lt;&gt; is <i>guaranteed</i> more expensive than calling the lambda function directly. <br>  And finally - a fly in the ointment, <i>auto</i> works differently when initialized through braces: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x3{<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x4={<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre><br>  All of these expressions are completely equivalent, however: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x1=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x3{<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x4={<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre><br>  x1 and x2 will be of type <i>int</i> , but x3 and x4 will be of a different type, <i>std :: initializer_list &lt;int&gt;</i> .  As soon as <i>auto</i> encounters the {} initializer, it returns the internal C ++ type for such constructions - <i>std :: initializer_list &lt;&gt;</i> .  Why this is so, even Myers admits that he doesn‚Äôt know, much less I won‚Äôt guess. <br><br>  <b>decltype</b> - everything is more or less simple, this construct was added to make it more convenient to write templates, in particular, functions with a return type depending on the template parameter: <br><br><pre> <code class="hljs swift">template&lt;typename <span class="hljs-type"><span class="hljs-type">Container</span></span>, typename <span class="hljs-type"><span class="hljs-type">Index</span></span>&gt; auto access(<span class="hljs-type"><span class="hljs-type">Container</span></span>&amp; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, <span class="hljs-type"><span class="hljs-type">Index</span></span> i) -&gt; decltype(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[i]) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[i]; }</code> </pre><br>  Here <i>auto</i> simply indicates that the return type will be specified <i>after</i> the function name, and <i>decltype ()</i> determines the type of the return value, as a rule, a reference to the i-th element of the container, however, in the general case, exactly what returns c [i], whatever it is . <br>  <b>uniform initialization</b> - as the name implies, the new standard tried to introduce a universal way to initialize variables, and this is fine, for example, you can now write like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    sockaddr_in sa={AF_INET, htons(80), inet_addr("127.0.0.1")};</span></span></code> </pre><br>  Moreover, using braces you can even initialize non-static members of the class (regular brackets do not work): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Widget</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z{<span class="hljs-number"><span class="hljs-number">0</span></span>}; };</code> </pre><br>  It is also finally hiding evergreen rakes in the closet that were always lying under their feet, especially annoying template developers: <br><br><pre> <code class="hljs ruby">Widget w1(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Widget w2{}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         </code> </pre><br>  And one more step to the strictness of the language, the new initialization prevents the transformation of types with a loss of accuracy (narrowing conversion): <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>, b=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=a+b; <span class="hljs-comment"><span class="hljs-comment">// fine int y={a+b}; // error</span></span></code> </pre><br>  However ..., it still does not leave the feeling that something went wrong.  First, where curly brackets are involved, initialization always occurs through the internal type <i>std :: initializer_list &lt;&gt;</i> , but for some reason, if the class defines one of the constructors with this parameter, this constructor is <i>always preferred by the compiler</i> .  For example: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;); }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// calls ctor #1 Widget w2{0, 0}; // calls ctor #2 !?</span></span></code> </pre><br>  Contrary to all obviousness, in the second case, the compiler will ignore the ideally suitable constructor_1 and call constructor_2, converting int to double.  By the way, if you swap the int and double types in the class definition, the code will generally stop compiling because the conversion of {double, double} to std :: initializer_list &lt;int&gt; occurs with loss of precision. <br><br>  This conflict can occur with any code now, according to the rules of C ++ 11. <br>  std :: vector (10, 20) creates an object of 10 elements, whereas <br>  std :: vector {10, 20} creates an object of only two elements. <br>  From above, we will decorate all this with a branch of dill - for copy constructors and move constructors this rule does not work: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Widget&amp;); Widget(Widget&amp;&amp;); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; Widget w1{}; Widget w2{w1}; Widget w3{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(w1)};</code> </pre><br>  Literally following the letter of the law, one would expect the compiler to select a constructor with the std :: initializer_list parameter and the actual parameters will be converted via the int () operator, so no!  In this case (copy / move constructor) copy constructors are called. <br><br>  In general, the recommendation to always use one type of brackets, round or curly, does not work at all.  Myers advises to adhere to one method, applying another only where necessary, he himself leans towards parentheses, in which I agree with him.  There remains, however, a problem with templates, where what should be caused is determined by the parameters of the template ... Well, at least C ++ remains a boring language. <br><br>  <b>nullptr</b> - there's <b>nothing</b> even to talk about here, it is obvious that <i>NULL</i> as well as the value 0 <i>are not pointers</i> , which leads to numerous errors when calling overloaded functions and implementing templates.  In this case, <i>nullptr</i> is a <i>pointer</i> and does not lead to any errors. <br>  <b>alias declaration vs typedef</b> <br>  Instead of the usual types of announcements <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt; UPtrMapSS;</code> </pre><br>  It is proposed to use this design <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UPtrMapSS=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;;</code> </pre><br>  these two expressions are absolutely equivalent, but the story does not end there, synonyms (aliases) can be used as templates (alias templates) and this gives them additional flexibility <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyAllocList=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;T, MyAlloc&lt;T&gt;&gt;; MyAllocList&lt;Widget&gt; lw;</code> </pre><br>  In C ++ 98, to create such a construct, MyAllocList would have to be declared a template structure, declare the type inside it and use it like this: <br><pre> <code class="hljs scala"><span class="hljs-type"><span class="hljs-type">MyAllocList</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span>&gt;::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lw</span></span></span></span>;</code> </pre><br>  but the story continues.  If we use the type declared through <i>typedef</i> as a dependent type inside the template class, we have to use additional keywords <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MyAllocList&lt;T&gt;::type lw; ...</code> </pre><br>  in the new syntax everything is much simpler <br><pre> <code class="hljs ruby">template&lt;typename T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAllocList</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lw</span></span></span><span class="hljs-class">;</span></span> ...</code> </pre><br>  In general, metaprogramming promises to be much easier with this syntactic construction.  Moreover, starting from C ++ 14, appropriate synonyms are introduced in &lt;type_traits&gt;, that is, instead of the usual <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_const&lt;...&gt;::type <span class="hljs-comment"><span class="hljs-comment">//   remove_const_t&lt;...&gt;</span></span></code> </pre><br>  Using synonyms is an extremely useful habit that you should start cultivating in yourself right now.  At one time, <i>typedef</i> ruthlessly dealt with macros, we will not forget, we will not forgive, and we will repay him with the same coin. <br>  <b>scoped enums</b> is another step towards the inner harmony of the language.  The fact is that the classical enumerations ( <i>enums</i> ) were announced inside the block, but their visibility ( <i>scope</i> ) remained global. <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ black, white, red };</code> </pre><br>  Black, white and red are visible in the same block as Color, which causes conflicts and name space clogging.  New syntax: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ black, white, red }; <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-type"><span class="hljs-type">Color</span></span>::white;</code> </pre><br>  looks much more elegant.  Only one but - at the same time removed the automatic conversion of transfers to integer types. <br><pre> <code class="hljs ruby">int x=Color::red; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  int y=static_cast&lt;int&gt;(Color::white); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ok</code> </pre><br>  this certainly only adds to the severity of the language, but in the overwhelming majority of the code that I saw enums are somehow converted to <i>int</i> , at least for transfer to <i>switch</i> or output to <i>std :: cout</i> . <br>  <b>override, delete and default</b> are new useful words when declaring functions. <br>  <i>override</i> signals to the compiler that this virtual member function of a class must <i>override a</i> certain function of the base class and, if there is no suitable option, it will kindly inform us about the error.  Everyone must have come across a situation where a random typo or signature change turns a virtual function into an ordinary one, the most annoying thing is that everything compiles perfectly, but it works somehow wrong.  So, this will not happen again.  Strongly recommended for use. <br>  <i>delete</i> - is intended to replace the old (and beautiful) trick with the private declaration of the default constructor and the assignment operator.  Looks more consistent, but not only.  This trick can also be applied to free functions to prevent unwanted argument conversions. <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLucky</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLucky</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLucky</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLucky</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; isLucky(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error isLucky(true); // error isLucky(3.5); // error</span></span></code> </pre><br>  the same technique can be used for patterns <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre><br>  the last two declarations prohibit the generation of functions for some types of argument. <br>  <i>default</i> - this modifier <i>causes the</i> compiler to generate automatic class functions, and it really has to be used.  The automatically generated functions in C ++ 98 included a constructor without parameters, a destructor, a copy constructor and an assignment operator, all of which were created according to well-known rules if necessary.  In C ++ 11, a moving constructor and an assignment operator were added, but not only, the rules for creating automatic functions themselves have changed.  The logic is simple, the automatic destructor calls the destructors of the class members and the base classes in turn, the copy / move constructor calls the corresponding constructors of its members in turn, and so on.  However, if we suddenly decide to define any of these functions manually, then this reasonable behavior does not suit us and the compiler refuses to understand our motives, in this case the moving constructor and the assignment operator will not be automatically created.  Of course, this logic is also applicable to the copying pair, but it was decided [for now] to be left as it was for backward compatibility.  That is, in C ++ 11 it makes sense to write something like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Widget</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ~Widget() =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Widget&amp;) =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Widget(Widget&amp;&amp;) =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Widget&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Widget&amp;) =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Widget&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(Widget&amp;&amp;) =<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ... };</code> </pre><br>  If you later decide to define the destructor, nothing will change, otherwise the transfer functions would simply disappear.  The code would continue to compile, but the copying counterparts would be invoked. <br>  <b>noexept</b> - finally the standard recognized that the exception specification in C ++ 98 is inefficient, recognized its use as undesirable ( <i>deprecated</i> ) and put in place one big red flag - <i>noexcept</i> , which declares that the function never throws exceptions.  If an exception is still thrown, the program is guaranteed to end; in this case, unlike <i>throw ()</i> , even the stack will not necessarily be promoted.  The checkbox itself is left for efficiency reasons; not only does the stack not need to be kept ready for promotion, the code generated by the compiler itself may differ.  Here is an example: <br><pre> <code class="hljs cpp">Widget w; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; v; ... v.push_back(w);</code> </pre><br>  When a new element is added to a vector, sooner or later a situation arises when the entire internal buffer needs to be moved in memory, in C ++ 98 the elements are alternately <i>copied</i> .  In the new standard, it would be logical to <i>move the</i> elements of the vector, it is an order of magnitude more efficient, but there is one nuance ... If during the copying process any of the elements throw an exception, the new element will not naturally be inserted, but the vector itself will remain in a normal state.  If we <i>moved the</i> elements, some of them were already in the new buffer, some were still in the old one, and it is already impossible to restore the memory to a working state.  The output is simple, if in the Widget class the moving assignment operator is declared as <i>noexcept</i> , the objects will be moved, if not, they will be copied. <br><div class="spoiler">  <b class="spoiler_title">This concludes this protracted review of the new season.</b> <div class="spoiler_text">  I deliberately dropped a few items - <b>constexpr</b> , <b>std :: cbegin ()</b> , etc.  They are quite simple and there‚Äôs nothing to talk about.  What I would like to discuss is the thesis that constant member functions should be thread-safe, but this, on the contrary, goes beyond the simple addition to the syntax, maybe in the comments it will turn out. <br></div></div><br><br><h4>  Types, their inference and everything related </h4><br>  Type inference (type deduction) in C ++ 98 was used exclusively in the implementation of templates, the new standard added <i>universal references</i> , the <i>auto</i> and <i>decltype keywords</i> .  In most cases, deduction is intuitive, but conflicts happen and then understanding of the mechanisms of work is very helpful.  Take this pseudocode: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ParamType param)</span></span></span></span>; f(expr);</code> </pre><br>  The main thing here is that T and ParamType are in general two different types, for example, ParamType can be const T &amp;.  The exact type of T is derived from the implementation of the template from both the actual type of expr and the type of ParamType, several options are possible. <br><ul><li>  The simplest case is when ParamType is neither a pointer nor a link, then the expression is passed to the function by value, all links are removed from expr, const modifiers, the pure type remains <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T param)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cx=x; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; rx=x; f(x); <span class="hljs-comment"><span class="hljs-comment">//       param - int f(cx); f(rx);</span></span></code> </pre><br></li><li>  If ParamType is a pointer or a regular (non-universal) link, then when type T is deduced, the link is removed, but const / volatile modifiers are saved <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> f(T&amp; param); <span class="hljs-type"><span class="hljs-type">int</span></span> x=<span class="hljs-number"><span class="hljs-number">1</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> cx=x; const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; rx=x; f(x); //   - <span class="hljs-type"><span class="hljs-type">int</span></span>, param - <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; f(cx); //   - const <span class="hljs-type"><span class="hljs-type">int</span></span>, param - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; f(rx); //   - const <span class="hljs-type"><span class="hljs-type">int</span></span>, param - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;</code> </pre><br>  intuitively, everything is completely transparent, we pass the value by reference as indicated in the template, but save the read / write modifiers so as not to violate the rights of access to the object being transferred. <br></li><li>  If ParamType is a universal link, then the type of expression depends on the type of expr.  If this is an <i>lvalue,</i> then both T and ParamType are treated as a link, and if expr is <i>rvalue,</i> then the rules similar to the usual links apply: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> f(T&amp;&amp; param); <span class="hljs-type"><span class="hljs-type">int</span></span> x=<span class="hljs-number"><span class="hljs-number">1</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> cx=x; const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; rx=x; //    - lvalue f(x); //   - <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;, param - <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; f(cx); //   - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;, param - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; f(rx); //   - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;, param - const <span class="hljs-type"><span class="hljs-type">int</span></span>&amp; //  f(<span class="hljs-number"><span class="hljs-number">1</span></span>); //   - <span class="hljs-type"><span class="hljs-type">int</span></span>, param - <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;&amp;</code> </pre><br></li></ul><br>  For <i>auto</i> , the type inference rules are exactly the same; in this case, <i>auto</i> plays the role of the T parameter, with one exception that I have already mentioned, if <i>auto</i> sees the expression in curly brackets, then the type <i>std :: initializer_list</i> is output. <br>  In the case of <i>decltype, it is</i> <s>almost</s> always the type that was given to it, in the end it was for this very reason that it was invented.  However, one nuance does exist - <i>decltype</i> returns a link for all expressions other than just a name, that is: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x=<span class="hljs-number"><span class="hljs-number">1</span></span>; decltype(x); // x -,   <span class="hljs-type"><span class="hljs-type">int</span></span> decltype((x)); // (x) - ,   <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;</code> </pre><br>  but this is unlikely to affect anyone other than libraries actively using macros. <br><hr><br>  Re-read the written, something turns out a lot.  But the most interesting is still ahead, probably better to be divided into two posts.  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/248137/">https://habr.com/ru/post/248137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248121/index.html">Apple has blocked developer accounts in Crimea</a></li>
<li><a href="../248129/index.html">Art Feature Engineering in Machine Learning</a></li>
<li><a href="../248131/index.html">International isolation made Cuba an island of hackers</a></li>
<li><a href="../248133/index.html">Status + new hell of trolling on the Internet</a></li>
<li><a href="../248135/index.html">High DPI values ‚Äã‚Äãin Windows</a></li>
<li><a href="../248139/index.html">IO.js or old rake with new sauce</a></li>
<li><a href="../248145/index.html">SoC: we raise simple DMA on FPGA</a></li>
<li><a href="../248147/index.html">Tree - killer JSON, XML, YAML and their ilk</a></li>
<li><a href="../248149/index.html">2D lighting system for Unity3D running on a GPU</a></li>
<li><a href="../248153/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 1 of 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>