<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Clock Setting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Understanding the clocking system 
 In the last article, we learned how to create stable delays using a simple SysTick timer, and also a little plunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Clock Setting</h1><div class="post__text post__text-html js-mediator-article"><h4>  Understanding the clocking system </h4><br>  <a href="http://habrahabr.ru/post/255415/">In the last article,</a> we learned how to create stable delays using a simple SysTick timer, and also a little plunged into the interrupt operation mechanism.  Then we took as a postulate that by clocking the timer from the source of the HCLK - we get 8 MHz.  Now it's time to figure out where these numbers come from. <br><a name="habracut"></a><br>  After opening the documentation and making the transition to the ‚ÄúClock Signals MDR_RST_CLK‚Äù we can see such a table. <br><img src="https://habrastorage.org/files/b41/5d2/088/b415d2088f1f4df2a5386504eabd5f98.PNG"><br><blockquote>  Built-in RC HSI Generator <br>  The HSI generator generates a clock frequency of 8 MHz.  The generator automatically starts when the power of the UCC. <br></blockquote><br>  Thus, after switching on, the controller is clocked from HSI.  On the block diagram in blue, I highlighted a sequence that demonstrates frequency changes on each block.  By default, the frequency source selection module (MUX) is configured to receive with HSI.  With the frequency, nothing happens and it, through the HCLK (clocking line, combined with the SysTick timer) gets into the CPU_CLK without changes.  But the internal RS generator cannot be called a precise device.  Its frequency is very unstable.  For this purpose, an external 8 MHz quartz resonator is installed on the board.  But what is it called? <br><blockquote>  HSE external generator <br>  The HSE generator is designed to generate a clock frequency of 2..16 MHz using an external resonator.  The generator starts when a UCC power supply appears ... </blockquote><br>  Now we need to understand how to switch the controller from clocking from HSI to HSE.  Take another look at the block diagram.  In red, I indicated a logical representation of how the signal will travel from the external crystal to the core clock line and the HCLK. <br><img src="https://habrastorage.org/files/7b6/f73/38b/7b6f7338bfcc4014a68fe1a3250cdd5d.png"><br><br><h5>  Setting registers clocking. </h5><br>  Now that we have a figurative representation of how clocking ‚Äúmoves‚Äù, it's time to deal with clocking registers.  The diagram next to each block indicates the bits of certain registers, changing which you can change the "movement" and the clocking frequency.  These bits are in the register MDR_RST_CLK-&gt; CPU_CLOCK.  I marked in red the bits that need to be changed.  Blue can also be left as it is.  They are already installed in the correct position. <br><img src="https://habrastorage.org/files/e7d/718/25a/e7d71825ae5d48988feda961698c76c6.PNG"><br>  Next, we need to write define those bits, the values ‚Äã‚Äãof which we will change. <br><pre><code class="hljs lisp">#define HCLK_SEL(<span class="hljs-name"><span class="hljs-name">CPU_C3</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;8) #define CPU_C1_SEL(<span class="hljs-name"><span class="hljs-name">HSE</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;1)</code> </pre> <br>  Since all the other bits are zero, we can write to the register directly, without fear of erasing the old data.  The result is the following. <br><pre> <code class="hljs erlang-repl">RST_CLK-&gt;CPU_CLOCK = CPU_C1_SEL(HSE)|HCLK_SEL(CPU_C3);</code> </pre> <br>  It would seem that everything.  But if we sew it up, we get this. <br><img src="//habrastorage.org/files/c36/7ac/275/c367ac2751f14a4397284cbcb4744688.PNG"><br>  With the subsequent impossibility of debugging.  I immediately got into the documentation with error descriptions.  But this was not there.  As it turned out, I missed one important specific detail.  The description of the HSE said: <br><blockquote>  The HSE generator is designed to generate a clock frequency of 2..16 MHz using an external resonator.  The generator starts when a UCC power supply and an HSEON enable signal appear in the HS_CONTROL register. </blockquote><br>  Take a look at this register. <br><img src="//habrastorage.org/files/0d1/e20/eca/0d1e20eca8a74bb98938a854ff2c38ad.PNG"><br>  Let's write another 1 define and enable the permission bit. <br><pre> <code class="hljs lisp">#define HS_CONTROL(<span class="hljs-name"><span class="hljs-name">HSE_ON</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;0) RST_CLK-&gt;HS_CONTROL = HS_CONTROL(<span class="hljs-name"><span class="hljs-name">HSE_ON</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A small digression.</b> <div class="spoiler_text">  When I was looking for a mistake, I returned to the peripheral clocking page (discussed in the previous article about <a href="http://habrahabr.ru/post/255415/">SysTick</a> ), in which I found RST_CLK.  By default it is on, but still I have registered its inclusion before all manipulations with the quartz resonator. </div></div><br>  After all the additions, the function was as follows. <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HCLK_SEL(CPU_C3) (1&lt;&lt;8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPU_C1_SEL(HSE) (1&lt;&lt;1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCLK_EN(RST_CLK) (1&lt;&lt;4) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HS_CONTROL(HSE_ON) (1&lt;&lt;0) void HSE_Init (void) { RST_CLK-&gt;PER_CLOK |= PCLK_EN(RST_CLK); //     (  ). RST_CLK-&gt;HS_CONTROL = HS_CONTROL(HSE_ON) //  HSE . RST_CLK-&gt;CPU_CLOCK = CPU_C1_SEL(HSE)|HCLK_SEL(CPU_C3); // ""      HSE . }</span></span></code> </pre><br><h4>  The first "crutch". </h4><br>  At that moment, when I was looking for the error of starting HSE in the list of errors, I came across the next glitch. <br><img src="//habrastorage.org/files/0aa/12f/9d9/0aa12f9d94bc48ccbb1f0b87d4e90c30.PNG"><br>  I could not help but remember it, as I had planned to turn off the internal generator immediately after switching on the clock from the external quartz resonator.  This error is present in all revisions of the microcontroller.  So for her have to sculpt crutch.  I will say right away.  In my case, I never managed to disable HSI.  Despite the fact that I did everything as stated in the recommendations. <br>  We study the problem and the ways of the "solution" in more detail. <br><img src="//habrastorage.org/files/2f2/b1f/731/2f2b1f7313364adb823a7a1e17be1322.PNG"><br>  Here is the one mentioned registers. <br><img src="//habrastorage.org/files/f4e/68f/ce5/f4e68fce51984892ba0cf338d0e1e258.PNG"><br><img src="//habrastorage.org/files/b40/3e1/bd4/b403e1bd409c4d43bf7de37c84a91fa8.PNG"><br>  Let's write define for the necessary bits, as well as for clocking the RTC. <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REG_0F(HSI_ON) ~(1&lt;&lt;22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RTC_CS(ALRF) (1&lt;&lt;2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCLK(BKP) (1&lt;&lt;27)</span></span></code> </pre> <br>  And now we will make an attempt to implement it in practice. <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HCLK_SEL(CPU_C3) (1&lt;&lt;8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPU_C1_SEL(HSE) (1&lt;&lt;1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCLK_EN(RST_CLK) (1&lt;&lt;4) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HS_CONTROL(HSE_ON) (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REG_0F(HSI_ON) ~(1&lt;&lt;22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RTC_CS(ALRF) (1&lt;&lt;2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCLK(BKP) (1&lt;&lt;27) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPU_C2_SEL(CPU_C2_SEL) (1&lt;&lt;2) void HSE_Init (void) { RST_CLK-&gt;PER_CLOK |= PCLK_EN(RST_CLK); //     (  ). RST_CLK-&gt;HS_CONTROL = HS_CONTROL(HSE_ON) //  HSE . RST_CLK-&gt;CPU_CLOCK = CPU_C1_SEL(HSE)|HCLK_SEL(CPU_C3); // ""      HSE . RST_CLK-&gt;PER_CLOK |= PCLK(BKP); //   ( ). BKP-&gt;RTC_CS |= RTC_CS(ALRF); //   HSI. BKP-&gt;REG_0F = BKP-&gt;REG_0F&amp;(REG_0F(HSI_ON)); // HSI. }</span></span></code> </pre> <br>  We track the execution of the program.  This is the state of the registers before attempting to reset a bit. <br><img src="//habrastorage.org/files/a3e/632/4a0/a3e6324a08ba4b5c8ae0e514d77a7cbd.PNG"><br>  And this after. <br><img src="//habrastorage.org/files/7dc/1f4/23c/7dc1f423c6cd4fd6ac12619e5d1ea642.PNG"><br>  At first, I thought that I was wrong with the offset and the millet did not turn on the ALRF bit, but then I clicked on it in the menu on the right (direct sending by registers) and received nothing.  I thought that I had not correctly selected the clocking, but by clicking on several other cells I received a response.  Apparently, this method does not solve this problem.  When trying to turn off the generator by successively pressing ALRF and HSI_ON, we are finally disappointed in the very idea of ‚Äã‚Äãturning off the generator.  Well.  It does not interfere much at the initial stage.  But in the future it will be problematic.  Especially if you make a handheld device. <br><br><h5>  We receive 16 MHz. </h5><br>  We managed to force our controller to be clocked from an external quartz resonator, which gave us the opportunity to get more accurate time delays.  Now it's time to learn how to use the frequency multiplier.  In the description of our controller, it is said that it can be clocked with a frequency up to 80 MHz.  Let's try to write a function that will allow us to increase the clocking frequency by 2 times.  Take another look at the block diagram. <br><img src="//habrastorage.org/files/e41/6ba/661/e416ba661d414db5ba8f2b90c279d23c.PNG"><br>  Now, before the frequency "hits" on CPU_C2 on the CPU_C2 line, it passes through the CPU PLL.  There it is ‚Äúmultiplied‚Äù by some meaning.  Consider its registers in more detail. <br><img src="//habrastorage.org/files/490/fa8/d11/490fa8d11dd14af19ee7c4e99e807fa6.PNG"><br>  PLL does not require the clocking bit.  So you can immediately start setting up the register.  Again, write down the definitions we need. <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PLL_CONTROL_PLL_CPU_ON (1&lt;&lt;2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//PLL .</span></span></span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, the very function of the inclusion. <br><pre> <code class="hljs erlang-repl">#define PLL_CONTROL_PLL_CPU_ON (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) //PLL . void HSE_16Mhz_Init (void) //     <span class="hljs-string"><span class="hljs-string">" 2 "</span></span> . { RST_CLK-&gt;PLL_CONTROL = PLL_CONTROL_PLL_CPU_ON|(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>); // PLL,   <span class="hljs-number"><span class="hljs-number">2</span></span> . RST_CLK-&gt;HS_CONTROL = HS_CONTROL(HSE_ON); //  HSE . RST_CLK-&gt;CPU_CLOCK = CPU_C1_SEL(HSE)|HCLK_SEL(CPU_C3)|CPU_C2_SEL(CPU_C2_SEL) ; // <span class="hljs-string"><span class="hljs-string">" "</span></span>     HSE . }</code> </pre> <br>  Now we can add a function to the project. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { Init_SysTick(); <span class="hljs-comment"><span class="hljs-comment">//  . Led_init(); //  0  C  . PORTC-&gt;RXTX |= 1; Delay_ms (1000); PORTC-&gt;RXTX = 0; Delay_ms (1000); HSE_16Mhz_Init(); while (1) { PORTC-&gt;RXTX |= 1; Delay_ms (1000); PORTC-&gt;RXTX = 0; Delay_ms (1000); } }</span></span></code> </pre><br>  I want to note that I did not just leave 1 cycle of flashing the LED.  This is the so-called "rescue program."  If during the experiments something goes wrong, then after pressing RESET there will be a whole second to flash the MK with the corrected firmware. <br>  After flashing, the LED flashes 2 times from the internal quartz, and then 2 times faster from the external one. <br><br>  Now we optimize our code.  Using the function for 3 lines is stupid.  Moreover, 2 of them are repeated in the second function.  Therefore, I propose to make them define.  The first function appears to us in this form. <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_ON_Clock() RST_CLK-&gt;PER_CLOCK |= PCLK_EN(RST_CLK) //     (  ). #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HSE_Clock_ON() RST_CLK-&gt;HS_CONTROL = HS_CONTROL(HSE_ON) //  HSE . #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HSE_Clock_OffPLL() RST_CLK-&gt;CPU_CLOCK = CPU_C1_SEL(HSE)|HCLK_SEL(CPU_C3);// ""      HSE .</span></span></code> </pre> <br>  And from the second I propose to make a universal frequency switching function.  To do this, we remove the HSE setting from the previous function and add another PLL restart bit to the PLL_CONTROL register.  So that when a new value is received, immediately start clocking on it.  The function begins to have the following form. <br><pre> <code class="hljs erlang-repl">#define PLL_CONTROL_PLL_CPU_ON (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) //PLL . #define PLL_CONTROL_PLL_CPU_PLD (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>) //  PLL. void HSE_PLL (uint8_t PLL_multiply) //     <span class="hljs-string"><span class="hljs-string">" 2 "</span></span> . { RST_CLK-&gt;PLL_CONTROL = RST_CLK-&gt;PLL_CONTROL&amp;(~(<span class="hljs-number"><span class="hljs-number">0</span></span>xF&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>)); //  . RST_CLK-&gt;PLL_CONTROL |= PLL_CONTROL_PLL_CPU_ON|((PLL_multiply-<span class="hljs-number"><span class="hljs-number">1</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>)|PLL_CONTROL_PLL_CPU_PLD; // PLL     X ,     PLL. RST_CLK-&gt;CPU_CLOCK |= HCLK_SEL(CPU_C3)|CPU_C2_SEL(CPU_C2_SEL)|CPU_C1_SEL(HSE); // <span class="hljs-string"><span class="hljs-string">""</span></span>   PLL     HSE. }</code> </pre> <br>  Let's put it in our main program.  Which also put in order. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Block (<span class="hljs-type"><span class="hljs-type">void</span></span>) //  (). { PORTC-&gt;RXTX |= <span class="hljs-number"><span class="hljs-number">1</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); PORTC-&gt;RXTX = <span class="hljs-number"><span class="hljs-number">0</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-type"><span class="hljs-type">int</span></span> main (<span class="hljs-type"><span class="hljs-type">void</span></span>) { Init_SysTick(); //  . Led_init(); //  <span class="hljs-number"><span class="hljs-number">0</span></span>  C  . Block(); //  (). HSE_Clock_ON(); //  HSE . HSE_PLL(<span class="hljs-number"><span class="hljs-number">2</span></span>); //    <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { PORTC-&gt;RXTX |= <span class="hljs-number"><span class="hljs-number">1</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); PORTC-&gt;RXTX = <span class="hljs-number"><span class="hljs-number">0</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre> <br>  As a conclusion, we will write a program that, after each cycle, will change the multiplication factor, increasing its speed up to 10, receiving 80 MHz. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Block (<span class="hljs-type"><span class="hljs-type">void</span></span>) //  (). { PORTC-&gt;RXTX |= <span class="hljs-number"><span class="hljs-number">1</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); PORTC-&gt;RXTX = <span class="hljs-number"><span class="hljs-number">0</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-type"><span class="hljs-type">int</span></span> main (<span class="hljs-type"><span class="hljs-type">void</span></span>) { Init_SysTick(); //  . Led_init(); //  <span class="hljs-number"><span class="hljs-number">0</span></span>  C  . Block(); //  (). HSE_Clock_ON(); //  HSE . HSE_PLL(<span class="hljs-number"><span class="hljs-number">2</span></span>); //    <span class="hljs-number"><span class="hljs-number">2</span></span> uint8_t PLL_Data = <span class="hljs-number"><span class="hljs-number">1</span></span>; //   . <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { PORTC-&gt;RXTX |= <span class="hljs-number"><span class="hljs-number">1</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); PORTC-&gt;RXTX = <span class="hljs-number"><span class="hljs-number">0</span></span>; Delay_ms (<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PLL_Data&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>) PLL_Data++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PLL_Data=<span class="hljs-number"><span class="hljs-number">1</span></span>; //    -  .  -  . HSE_PLL(PLL_Data); }</code> </pre> <br>  Video of the program. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/jfXgCNbtrXc%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjI3igfMd473xevOTktHc0cwg0gfQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Recovery fees. </h4><br>  After the first unsuccessful experience with setting the clock frequency, the board stopped responding.  Since I did not provide for a defensive program (considering it unnecessary), I began to look for ways to implement it.  In the comments to one of the previous articles, <b>vertu77</b> suggested 3 ways to restore the board in case of incorrect port configuration. <br><blockquote>  If the JTAG port is still dead - what to do: <br>  1. Then another JTAG port may come in handy.  If it is not divorced on the board, you can solder only to the SW legs on another port (less fuss) <br>  2. Upload firmware via UART (regular bootloader) <br>  3. Use the features of the wired program - have time to flash a new fill after energizing before the first blink.  In the author's version, this is almost impossible.  In real programs, the program is often started from an internal oscillator, then external quartz is initialized.  If this uses an endless loop of waiting - you can unsolder the quartz and flash until the first blink. <br></blockquote><br>  But in my case, both JTAGs didn‚Äôt react (we started when trying to program the MK), there was no protection program, and the USART bootloader was very far away.  Yes, and did not want to spend too much time on recovery.  So the fourth recovery method was invented.  It is necessary to switch BOOT switches to EXT_ROM / JTAG_B mode, connect to JTAG_B and sew a code with firmware that contains a security program.  In my case, I just added a wait cycle of one second before tuning the quartz resonator.  So after each unsuccessful experience, it was enough to click on the RESET and have time to enter debug mode again. <br><br><div class="spoiler">  <b class="spoiler_title">List of previous articles.</b> <div class="spoiler_text">  1. <a href="http://habrahabr.ru/post/255199/">We turn from STM32F103 to K1986BE92QI.</a>  <a href="http://habrahabr.ru/post/255199/">Or the first acquaintance with the Russian microcontroller.</a> <br>  2. <a href="http://habrahabr.ru/post/255323/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255323/">Setup project in keil and flashing LED.</a> <br>  3. <a href="http://habrahabr.ru/post/255415/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255415/">System Timer (SysTick).</a> <br></div></div><br>  <a href="">Files to projects.</a> </div><p>Source: <a href="https://habr.com/ru/post/255479/">https://habr.com/ru/post/255479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255465/index.html">This watch writes time ...</a></li>
<li><a href="../255471/index.html">Software Configurable Networks and Network Virtualization: Reality Check</a></li>
<li><a href="../255473/index.html">Interactive tree menu</a></li>
<li><a href="../255475/index.html">As a student, a bug in Yandex.Music found</a></li>
<li><a href="../255477/index.html">Review System for Online Stores - Cackle Reviews</a></li>
<li><a href="../255483/index.html">Dissenting opinion: The JPMorgan algorithm will calculate unscrupulous traders before they incur losses.</a></li>
<li><a href="../255485/index.html">Drawing an ellipse at an arbitrary canvas angle on javascript</a></li>
<li><a href="../255487/index.html">Resource Management with Explicit Template Specializations</a></li>
<li><a href="../255489/index.html">Automatic resize of icons for mobile applications, or how Inkscape + bash make life easier</a></li>
<li><a href="../255493/index.html">Codex and TechExpert in all iPads of the country</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>