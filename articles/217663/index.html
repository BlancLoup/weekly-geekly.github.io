<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I tried to crack Bitcoin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently there was an article in which it was told about an attempt to outwit Bitcoin using a neural network. I went the other way, and I didn‚Äôt work ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I tried to crack Bitcoin</h1><div class="post__text post__text-html js-mediator-article">  Recently there was <a href="http://habrahabr.ru/post/217149/">an article</a> in which it was told about an attempt to outwit Bitcoin using a neural network.  I went the other way, and I didn‚Äôt work out of this practically useful result, but despite this, I don‚Äôt consider my experience a complete failure.  Firstly, I don‚Äôt think because it‚Äôs foolish to hope to just take and crack Bitcoin, and secondly, because the expected result was obtained, which means we can say that I did achieve some success.  And so, I decided to share the developments with the readers of Habr. <br><a name="habracut"></a><br><h4>  Idea </h4><br>  It is believed that some functions in the opposite direction do not work.  Wikipedia in the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">article</a> operates with such a thing as ‚Äúcomputational impossibility‚Äù.  In one of the <a href="http://habrahabr.ru/post/217149/">kamentov</a> , the function was given as an example. <br><br>  X = A MOD B <br><br>  Someone may say that this function is in the opposite direction unsolvable.  I believe that this function is very solvable, just in the opposite direction it gives an infinite number of pairs (A, B), if we know ‚ÄúB‚Äù, then the solution will be an infinite number of possible numbers ‚ÄúA‚Äù.  Not exactly what we would like, but we didn‚Äôt think we were in a fairy tale?  This is somewhat similar to pulling out one equation from the system of equations - each equation in the system gives a set, but in the system the intersection of these sets gives a small number of solutions.  Therefore, just as we do not separately solve each equation in the system of equations, it makes no sense to consider such functions in isolation from other functions that the cryptoalgorithm consists of.  Therefore, the elementary operations of the cryptoalgorithm cannot be viewed separately, and if you look at them as a system of equations, you can theoretically solve it.  And it turns out that, by analogy, you can count sha256 in the opposite direction; you just need to transfer the same idea of ‚Äã‚Äãworking with lists to bitwise operations.  But we will begin, of course, not with sha-256, but with trivial examples. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose we have bit variables a, b, c.  Suppose we also know that as a result of taking a &amp; b, we got 0, and the ‚Äúc‚Äù bit did not participate in the formula.  Let's try to "lose" this formula in the opposite direction.  We know that the AND operation gives us a total of zero if at least one of the operands arriving at its input is zero.  Thus, the possible values ‚Äã‚Äãof abc, as they are seen by the operand ‚Äúa‚Äù, can be represented by a list of one regesp 0 **.  Where the asterisk means 0 or 1. Possible values ‚Äã‚Äãof the abc variables, as they appear to the operand ‚Äúb‚Äù can be represented by a list from the regexp * 0 *.  We need the list because in large expressions of one regexp is not enough for us.  By regexp, I mean not a traditional regular expression, but a stripped-down version of it, in which an asterisk means any value of the corresponding bit. <br><br>  When we take a logical "And" over the lists coming to the inputs, we need to combine each incoming regexp to the right input with each incoming to the left.  In this task, it is simple for us - it enters only one regexp, so we combine them.  For "And", if you need to get 0 at the output - the left list is simply supplemented with the right one.  Schematically, I showed it in the picture in the form of a graph: <br><img src="https://habrastorage.org/getpro/habr/post_images/90b/f66/93a/90bf6693a93ea9b13282ded38df94ba6.gif"><br>  Explanation.  The result f is fed from below, to the exit, and rises in the direction opposite to the arrows - up, splitting at the nodes, until it comes to the final variable.  The final variable forms the list of possible values ‚Äã‚Äãof the variables (the one seen from the position of this variable) necessary to achieve the result.  For the variable "a" it is 0 **, for the variable "b" it is * 0 *.  In fact, these are all asterisks, but only one of them, in the variable position, is replaced by the incoming f.  Further, this list goes down the arrows, combining in nodes with other similar lists.  I added the variable "c" specifically to show that the variables not participating in the expression do not interfere with us, but go down in the original form.  At the exit, we received a list of two regexps.  Each regexp defines a set of possible values ‚Äã‚Äãthat, if desired, we can easily generate from this regexp.  This is the answer. <br><br>  Of course, if there are many elements in the list, we must somehow combine non-contradictory regexps and exclude duplicates, this moment is important, but optimizing, and therefore it is now irrelevant for understanding the idea.  About him will be lower. <br><br>  Now the same, but only for f = 1.  We get a = 1 **, b = * 1 *.  The rule of combining, if for ‚ÄúI‚Äù we need to get 1 at the output - it is more difficult  We must combine with the right and left side consistent regexps, while building a list of new regexps.  I got the following final rules: <br><img src="https://habrastorage.org/getpro/habr/post_images/5ac/de3/38d/5acde338d2b8617fcf71fa829d3e1859.gif"><br>  Regexps are viewed bit by bit.  Depending on the values ‚Äã‚Äãof the bits on the right and on the left, choose the most specific value, or discard this pair of regexp, if we meet bits that contradict each other. <br><br>  Having processed the entries according to this rule, we get: <br><img src="https://habrastorage.org/getpro/habr/post_images/bc9/eab/a1c/bc9eaba1cdd1a44c951fe901673af4f5.gif"><br><br>  I think the idea is clear.  For "OR" and "NOT" you can build similar rules: <br><img src="https://habrastorage.org/getpro/habr/post_images/467/be5/344/467be5344de3afbbd6828c3bd8d79775.gif"><br>  It also shows that for the "NOT" log, we operate not with lists of regexps, but from f itself, inverting it.  Lists of regexp through "NOT" pass without changes and without inversions. <br><br>  Thus, for sha256, we can construct a graph, break our message digest into bits, submit these bits to the outputs, and we will return a list of possible values ‚Äã‚Äãof the variables of the pre-image. <br><br><h4>  Optimization </h4><br>  There were no goals to optimize the algorithm as much as possible.  It is clear that working with bits through characters is wasteful, and you can greatly increase the speed of the algorithm if you shift it to C and assembler with bitwise operations.  However, there is one more way of optimization - minimization of the sizes of lists with which we operate.  When combining lists, duplicates and non-contradictory regexes often arise that need to be thrown back.  In addition, sometimes, two regexps can be combined into one new one, which in turn can be further optimized.  For example, 000100 and 001100 can be combined into 00 * 100, the rule of such a union is relatively easy to output - only changing one bit is permissible, it is only important that the newly created reexpx does not represent any unnecessary values ‚Äã‚Äãof variables.  Therefore, * 0 cannot be combined with 0 *, while receiving **, because ** represents 11, which neither the first nor the second regexp allowed. <br>  In addition, in the lists we will cache lists - we count them once for each f that came from below. <br><br><h4>  Experiment </h4><br>  I made the following assumptions <br>  - the original message is shorter than 56 bytes (for Bitcoin it could be assumed that this is the case, in fact, it is not difficult to refuse this simplification); <br>  - we know all the original message, except the first 8 bits. <br><br>  Of course, this is not a fountain, I understand that 8 unknown bits are small enough to pick them up by brute force, but the goal of the experiment was to test the method.  I got this way to find the letter T, knowing sha-256 from the phrase ‚ÄúThe quick brown fox jumps over the lazy dog‚Äù, and knowing all the letters of this phrase, except the letter T. The program should work for large unknowns, it will just work longer and will require more memory.  For this reason, it is impossible to consider all letters as unknown - there is not enough computing resources, which means there is no practical application.  Calculation of the letter T takes 82 seconds per 3GHz Phenom.  Of course, a direct enumeration of all unknown bits (256 values) would take a split second, so in this sense there is also no practical use for the program. <br><br>  It seems to me that there is a possible way of optimization, which is to invent a compact record of sets, but still the method will not work faster than brute force. <br><br>  Link to a project that finds the letter T: <a href="https://github.com/chabapok/sha256unroll">https://github.com/chabapok/sha256unroll</a> </div><p>Source: <a href="https://habr.com/ru/post/217663/">https://habr.com/ru/post/217663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217653/index.html">Moai SDK 1.5 - cross-platform 2D game engine</a></li>
<li><a href="../217655/index.html">Making ‚Äúlife‚Äù in Linux easier or automating process startup using cron</a></li>
<li><a href="../217657/index.html">Wi-Fi Controller Access Points on Mikrotik</a></li>
<li><a href="../217659/index.html">Forecast for the number of likes in the post. SNA Hackathon 2014</a></li>
<li><a href="../217661/index.html">Science fiction technology: Warp (Star Trek)</a></li>
<li><a href="../217665/index.html">National payment system and horse ass width</a></li>
<li><a href="../217667/index.html">Principles of successful IDM implementation. Business Cases</a></li>
<li><a href="../217669/index.html">TACACS + on Linux with Active Directory authentication</a></li>
<li><a href="../217671/index.html">Mysterious announcement from IBM</a></li>
<li><a href="../217675/index.html">BAKU 898D soldering station overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>