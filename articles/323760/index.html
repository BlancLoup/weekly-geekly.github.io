<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Invisible friends of your github repository</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Github is an indispensable tool, firmly embedded in the lives of almost every developer. 

 Although many of us use it all the time, not everyone know...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Invisible friends of your github repository</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5dd/9d1/fd4/5dd9d1fd4b59422cbcb4429277ab6369.png" alt="image"><br>  Github is an indispensable tool, firmly embedded in the lives of almost every developer. <br><br>  Although many of us use it all the time, not everyone knows that there are a large number of third-party (and free) services and tools that are tightly integrated with github and extend its functionality. <br><br>  In this article, we will focus mainly on tools running in the npm infrastructure.  For a complete list of services that integrate with github, see the <a href="https://github.com/integrations">github integrations directory</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Today in issue: </h2><br><ul><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">We configure continuous integration with travis ci</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">Configure test coverage reports with coveralls</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">Monitor dependency status with david</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">Configuring automatic updating of dependencies with greenkeeper</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">Improving commit messages with commitizen</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">We generate changelog and release notes with conventional-changelog</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/323760/">Manage tasks with zube</a> </li></ul><br><br><a name="habracut"></a><br>  Most of the services reviewed provide informational badges that can be added to the project page.  In order not to show the same image every time a badge is mentioned, we show it once at the beginning of the article: <br><br><img src="https://habrastorage.org/files/9df/83b/b03/9df83bb03e7f43bbb65c1dee63045e85.PNG" alt="image"><br><br>  We also need to write a few scripts.  To do this, we will use npm scripts, avoiding tools like grunt or gulp, so you don‚Äôt need to know the specific collectors. <br><br><div class="spoiler">  <b class="spoiler_title">Small lyrical digression about task runners</b> <div class="spoiler_text">  Not so long ago, several clever people (for example, the notorious <a href="https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8">Cory House</a> ) voiced the idea that it is not at all necessary to use tools like <a href="https://gruntjs.com/">grunt</a> or <a href="http://gulpjs.com/">gulp</a> to build a project.  In most cases, simple npm scripts are enough. <br><br>  We are convinced by personal experience that this thought is correct. <br><br>  If you build your project, for example, with the help of gulp, then for each tool used you have to look for (or write yourself) a plugin.  For example, to compile <a href="https://www.typescriptlang.org/">typescript</a> you need to use <a href="https://www.npmjs.com/package/gulp-typescript">gulp-typescript</a> , to run <a href="https://palantir.github.io/tslint/">tslint you</a> need <a href="https://www.npmjs.com/package/gulp-tslint">gulp-tslint</a> , to run <a href="https://github.com/TypeStrong/typedoc">typedoc</a> , you need <a href="https://www.npmjs.com/package/gulp-typedoc">gulp-typedoc</a> .  Well, and so on. <br><br>  Tools are periodically updated and sometimes you are really looking forward to the update.  It happens that plugins are updated with some delay.  And it happens that they are not updated at all. <br><br>  For example, the long-awaited release of typescript 2.x.  Not long to wait for tslint and typedoc updates.  But the new versions of plug-ins in no hurry to go.  As a result, the project was impossible to translate into a new version of typescript because of the old version of the gulp-plugin for the general auxiliary tool. <br><br>  In addition, plugins are additional dependencies in your package.json, and they often have more dependencies, and so on.  All this directly affects the installation time, for example, when starting the build in travis. <br><br>  In general, our experience has shown that if you rewrite the assembly to npm-scripts, then life becomes easier. <br><br>  And it's also very cool not to use tools that require global installation.  But this idea we will not discuss in detail and just share a link to a <a href="https://www.sitepoint.com/solve-global-npm-module-dependency-problem/">good article</a> for those interested. <br></div></div><br><br>  Live examples of the use of the described services can be viewed in our repositories of the <a href="https://github.com/eastbanctechru/e2e4">e2e4</a> library (simple options) or the angular-grid libraries <a href="https://github.com/eastbanctechru/right-angled">right-angled</a> (more interesting options). <br><br><a name="travis"></a><h2>  We configure continuous integration with travis ci </h2><br>  Let's start with the obvious - each project needs continuous integration.  Here <a href="https://travis-ci.org/">travis ci is</a> ready to help us. <br><br>  Setting up a build in travis is quite simple and consists of the following steps: <br><br><ol><li>  Login to travis using your github account. </li><li>  We indicate on the settings page which of our travis repositories should be monitored. </li><li>  Add the ".travis.yml" file to the root directory of the repository, which contains the environment settings and commands to start the build. </li></ol><br>  For example, like this: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">language</span></span>: node_js node_js: - "6" script: - npm run ci</code> </pre> <br><br>  So we tell travis that we need an environment with nodejs version 6. <br><br>  The build process consists of a single npm command that runs a script called ‚Äúci‚Äù from the ‚Äúscripts‚Äù section of the package.json file. <br><br>  In our case, this team takes turns running the lint project with <a href="https://palantir.github.io/tslint/">tslint</a> , building with <a href="https://www.typescriptlang.org/">typescript</a> , and running the tests with <a href="https://karma-runner.github.io/1.0/index.html">karma</a> .  If details are interesting to you, then it is possible to look at them in <a href="">package.json on github</a> . <br><br>  Also note that in the build commands we did not register ‚Äúnpm install‚Äù.  Travis himself understands that it is necessary to install the dependencies through npm and executes it. <br><br>  Moreover, if you use yarn, then travis will understand this, install <a href="https://yarnpkg.com/">yarn</a> and install the dependencies using it. <br><br>  In travis laid many similar patterns that save us from unnecessary actions. <br><br>  Now we execute the push file ‚Äú.travis.yml ', after which the first build will be executed.  The build process can be observed in real time on the travis page. <br><br><h4>  What else </h4><br><ul><li>  If you are interested in more complex scenarios or other platforms, we recommend that you look at the <a href="https://docs.travis-ci.com/">travis documentation</a> .  The quality of the documentation is impressive. </li><li>  In case the build ends in error, travis will write to you about this in the mail specified in your github account.  You can also configure integration with slack. </li><li>  When creating a tag, travis will report the result in the case of a successful build too. </li><li>  In addition to commit, travis runs a build for each pull request.  When the build is completed, the result information will be displayed on the pull request page.  After completing the merge, travis will start the build again and again report the result on the pull request page. </li></ul><br><img src="https://habrastorage.org/files/83f/e9a/501/83fe9a501be4416fb1043d034bd7aad2.png" alt="image"><br><br><ul><li>  You can add a special badge to the readme file that will display the current build status.  Concurrently, this is a link to information about the latest build in travis.  Using the badge, you can show your community that everything is fine with the build.  Or all bad.  In the second case, such a badge motivates well as soon as possible to correct the situation. </li><li>  For public repositories information about builds will be available to everyone.  They will not even need to log in to travis for this. </li><li>  And the last.  You cannot delete builds from history.  The maximum that can be done is to remove the log build.  For example, if you ‚Äúspotted‚Äù secret information in it.  But the build itself will remain in history forever. </li></ul><br><br><a name="coveralls"></a><br><h2>  Configure test coverage reports with coveralls </h2><br>  The next service we get to know is <a href="https://coveralls.io/">coveralls</a> . <br><br>  The general idea is that when you run tests, you generate a coverage report in the lcov format and send it to the coveralls service for analysis.  The service processes it and provides the following features: <br><br><ul><li>  You can add a badge with a percentage of test coverage to your readme.  So you tell your community that you are all serious. </li><li>  When creating pull request, coveralls add to pull request information about how test coverage has changed. </li></ul><br><img src="https://habrastorage.org/files/dd8/ceb/a32/dd8ceba325cf497f92b83808306a7e43.png" alt="image"><br><br><ul><li>  You can set the bounds of the percentage of test coverage.  And, if the changes in the pull request reduce the percentage of coverage below the specified value, then the pull request request ends in an error. </li><li>  The service integrates with ci-services, such as travis, stores the build history and allows you to view the test coverage dynamics from build to build.  For example, <a href="https://coveralls.io/github/eastbanctechru/right-angled">here are</a> stored reports for the right-angled library. </li></ul><br><br>  To connect coveralls to your project, you must perform the following steps: <br><br><ol><li>  Log in to coveralls with your github account. </li><li>  Select repositories for which you want to enable information collection. </li><li>  Install the npm <a href="https://www.npmjs.com/package/coveralls">coveralls</a> package into your repository. </li><li>  Adjust the generation of coverage reports when running the tests. <br><blockquote>  We will not consider how to generate reports on coverage in detail, because it all depends on what you write the tests on, what tools you use, and how the tests run.  Plus, for example, for typescript, there are no tools for generating coverage reports, since javascript, rather than typescript, is launched for execution.  And, if you want to watch the coverage of exactly typescript code, then you will need tools to remap the reports of js-code coverage back to the typescript code.  All this is unnecessary specificity, which we try to avoid in this article.  You can start exploring possible options from the coveralls npm-package page on github. </blockquote><br><br></li><li>  Add npm-script to transfer the generated report to the coveralls service. <br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"coveralls"</span></span>: <span class="hljs-string"><span class="hljs-string">"cat ./coverage/lcov.info | ./node_modules/.bin/coveralls"</span></span>, ... }</code> </pre> <br></li><li>  Run the added script after running the build in travis.  To do this, use the after_success section in the travis.yml file.  Now our travis.yml looks like this: <br><pre> <code class="hljs coffeescript">language: node_js node_js: - <span class="hljs-string"><span class="hljs-string">"6"</span></span> script: - <span class="hljs-built_in"><span class="hljs-built_in">npm</span></span> run ci after_success: - <span class="hljs-built_in"><span class="hljs-built_in">npm</span></span> run coveralls</code> </pre> <br></li></ol><br><br><h4>  What else </h4><br>  In addition to github, coveralls integrates with bitbucket and promises fast gitlab support.  It also supports integration with many services of integration integration and many development platforms. <br><br><a name="david"></a><br><h2>  Monitor dependency status with david </h2><br>  The <a href="https://david-dm.org/">david</a> dependency monitoring service will be the simplest one discussed in the article. <br><br>  The idea of ‚Äã‚Äãthe service is simple - we add to the project page a badge, which is an indicator of the status of project dependencies.  It is also a link to the project dependency analysis page. <br><br>  To connect to our project david, type in the browser address in the following pattern: <br><br><pre> <code class="javascript hljs">https:<span class="hljs-comment"><span class="hljs-comment">//david-dm.org/&lt; &gt;/&lt; &gt;</span></span></code> </pre> <br><br>  Depending on what types of dependencies are in your project, on the page that opens you will see the tabs ‚Äúdependencies‚Äù, ‚Äúdevdependencies‚Äù, ‚Äúpeer dependencies‚Äù and ‚Äúoptional dependencies‚Äù. <br><br>  Each tab contains a list of dependencies of a certain type and badge, by clicking on which you can copy the link in markdown or HTML format and place it in your readme file or on the project page in github pages. <br><br><h4>  What else </h4><br>  There is also a <a href="https://www.npmjs.com/package/david">david cli</a> utility designed to help update dependencies on your machine.  True, we have not been able to understand what its advantages are compared with the <a href="https://docs.npmjs.com/cli/outdated">npm outdated</a> and <a href="https://docs.npmjs.com/cli/update">npm update</a> built-in commands. <br><br><a name="greenkeeper"></a><br><h2>  Configuring automatic updating of dependencies with greenkeeper </h2><br>  The <a href="https://greenkeeper.io/">greenkeeper</a> service <a href="https://greenkeeper.io/">is</a> also designed to help us with the difficult task of updating dependencies, but it does so at a much higher level.  His task is to completely free us from work with dependencies. <br><br>  To connect greenkeeper to our project, you need to go to the greenkeeper page in the section <a href="https://github.com/integration/greenkeeper">public integrations on github</a> and install the application in the repository we need. <br><br>  In a minute, greenkeeper will create a pull request in which it will update all the dependencies of your project and add a readme badge that displays the status of greenkeeper. <br><br>  <i>Only if you make a merge of this pull request, will greenkeeper start monitoring your project.</i> <br><br>  Further, when new versions of dependencies appear, greenkeeper will create pull requests in which it will provide a detailed description of what has been updated and, if possible, provide a list of changes in the new version.  You just have to make a merge. <br><br><img src="https://habrastorage.org/files/d56/a5f/dc3/d56a5fdc35ec460682859640ee40b9a1.png" alt="image"><br><br>  Naturally, the greenkeeper connection only makes sense if you have an automatic build configured and there are tests with which you can at least nominally check that your project is in working condition after the upgrade.  Greenkeeper recognizes whether there are builds and tests in your repository, and writes a warning in the text of the pull request, if it does not detect one or the other. <br><br><h4>  What else </h4><br><ul><li>  After you close the pull request, greenkeeper will delete the branch created. </li><li>  If the updated dependencies release the following versions very quickly (which will be similar to the quick fix release), greenkeeper will create a new branch and write about it in the comments to the original pull request. </li><li>  You may notice that sometimes greenkeeper creates a branch, and immediately deletes it, without making a pull request.  So greenkeeper is valid if there is an update of dependencies that fit into the <a href="https://docs.npmjs.com/getting-started/semantic-versioning">version range</a> that you specified in package.json.  That is, this version of dependencies will get to you when reinstalling dependencies.  Greenkeeper in this way checks that even the version that falls in the version range does not break your build and after running it simply deletes the branch.  In case of an error, greenkeeper will create an issue. </li><li>  If you do not want greenkeeper to update certain dependencies in your project, then you can add the following section to your package.json file: <br><pre> <code class="hljs 1c"><span class="hljs-string"><span class="hljs-string">"greenkeeper"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ignore"</span></span>: [‚Äú‚Äù, ‚Äú‚Äù, ‚Äú‚Äù, ‚Äú<span class="hljs-keyword"><span class="hljs-keyword"></span></span> ‚Äù, ‚Äú‚Äù] }</code> </pre> <br></li><li>  You should also know that currently greenkeeper does not work with yarn.  There are ways to get around this problem, but it's hard to call them good.  All information on this issue can be viewed in the <a href="https://github.com/greenkeeperio/greenkeeper/issues/314">issue on github</a> . </li><li>  And the last moment.  It is possible that the project uses several dependencies that need to be updated simultaneously.  For example, <a href="https://www.npmjs.com/~angular">angular is</a> broken into modules, and chances are great that the project will need more than one module.  At the same time, it makes sense to update them all together.  Greenkeeper is not able to cope with this task. </li></ul><br><br><a name="commitizen"></a><br><h2>  Improving commit messages with commitizen </h2><br>  <a href="https://github.com/commitizen">Commitizen</a> is a whole set of tools that help in writing meaningful messages to commits. <br><br>  In addition to being more informative for people interested in your repository, using commitizen is another plus.  From the messages generated by commitizen, you can easily collect changelog and release notes.  And there are even utilities that analyze the history of commits and suggest what the next version number should be to comply with the <a href="http://semver.org/">semver</a> convention.  But more about that in the next section. <br><br>  And we begin with the simplest.  Install <a href="http://commitizen.github.io/cz-cli/">cz-cli</a> .  After installation, we can use the ‚Äúgit cz‚Äù command instead of ‚Äúgit commit‚Äù.  This command launches a wizard, which takes us through a series of questions about what we have changed in the current commit and generates a commit message <a href="">in a format</a> that is easily readable by humans and parsed by various tools. <br><br>  So: <br><ol><li>  Set commitizen globally: <br><pre> <code class="bash hljs">npm install commitizen -g</code> </pre> </li><li>  We make our commitizen friendly repository.  To do this, run the following command in the repository folder: <br><pre> <code class="bash hljs">commitizen init &lt; &gt; --save-dev --save-exact</code> </pre> </li></ol><br><br>  Instead of &lt;adapter name&gt;, you must specify <a href="https://www.npmjs.com/package/commitizen">one of the possible adapters</a> .  In the world of front end development, the most popular is the cz-conventional-changelog, the following <a href="">message notation developed by the angular team</a> <br><br>  This command will install the necessary dependencies, save them in the devDependencies section of the package.json file and prescribe the necessary settings there. <br><br><h4>  What else </h4><br><ul><li>  In addition to working through the command line, there are extensions for code editors.  For example, for <a href="https://github.com/KnisterPeter/vscode-commitizen">vscode</a> .  Perhaps it will be more convenient for you, although there are no fundamental differences from using ‚Äúgit cz‚Äù in the terminal of the same vscode. </li><li>  It is worth noting that the messages that git cz generates are easy to write yourself.  Some of our developers do this.  A full description of the format can be <a href="">found here</a> . </li><li>  You can <a href="https://github.com/commitizen/cz-cli">add a badge</a> to the readme page so that visitors to your repository know that you follow the commitizen convention. </li></ul><br><br><a name="cz"></a><br><h2>  We generate changelog and release notes with conventional-changelog </h2><br>  After we connect commitizen, we get another option - the ability to configure the automatic generation of changelog and release notes. <br><br>  It will help us in this <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a> . <br>  A conventional-changelog is a whole family of tools, with which you can build a release release using high-level tools using ready-made templates, or you can build from individual tools what you need specifically. <br><br>  The developers themselves recommend using the <a href="https://github.com/conventional-changelog/standard-version">standard-version</a> , which is a relatively high-level tool. <br><br>  Even higher level is <a href="https://github.com/semantic-release/semantic-release">semantic-release</a> .  This tool even makes push changes and publishes the version in npm. <br><br>  From our experience - having tried both options, we stopped at the use of lower-level tools. <br><br>  The reason for this choice is that standard-version, for example, does not push changes and does not generate a release description on github.  Adding such things to the release process, plus setting up via standard-version options for running the build, or generating documentation, together require configuration, which is comparable in complexity to manual setting up the publishing process based on the <a href="https://docs.npmjs.com/cli/version">npm version</a> command. <br><br>  Semantic-release, on the other hand, is trying to automate the process entirely and to use it you need a very disciplined approach to development.  The complexity of its settings is also comparable to the manual configuration of the process.  And the last.  Semantic-release does npm publish, which limits its use only for libraries distributed via npm, and you can publish versions not only for libraries. <br><br>  So, we will build the release process based on the npm version.  Also, when you run the script, version npm runs the preversion and postversion scripts, if any.  We will use both.  The release process will consist of the following steps: <br><br><h4>  Phase preversion: </h4><br><ol><li>  Cleaning directories with previous build results with <a href="https://www.npmjs.com/package/rimraf">rimraf</a> . </li><li>  <a href="https://palantir.github.io/tslint/">Tslint</a> run </li><li>  Compile typescript. </li><li>  Run tests with <a href="https://karma-runner.github.io/1.0/index.html">karma</a> . </li></ol><br>  Using the example of the <a href="">e2e4</a> repository, these steps are identical to the precommit executed in the hook, so we use the same script: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"preversion"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run precommit"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run rimraf -- esm coverage &amp;&amp; npm run clean:src &amp;&amp; npm run clean:tests &amp;&amp; npm run lint &amp;&amp; npm run build &amp;&amp; npm run test"</span></span> }</code> </pre><br><br><h4>  Phase version: </h4><br><ol><li>  Generate documentation for publication on github pages.  In our case, <a href="http://typedoc.org/">typedoc is</a> used for this.  Regarding github pages - recently it has become unnecessary to create a branch named gh-pages, you can simply <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/">specify the</a> folder of your project <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/">in the github settings</a> that will be used as a site.  By default, this is the ‚Äúdocs‚Äù folder.  Therefore, we simply generate the documentation in the docs folder. </li><li>  Add the generated documentation to git for commit. </li><li>  Supplement changelog.md with change information.  For this we will use <a href="https://www.npmjs.com/package/conventional-changelog-cli">conventional-changelog-cli</a> .  As parameters, we give it the file name and the convention for parsing messages.  In our case it is ‚Äúangular‚Äù. </li><li>  Add updated changelog for commit. </li><li>  Update the version in package.json and add it to the commit.  This npm will do for us. </li><li>  Generate a tag for the version and put a pre-release or latest tag on it, if necessary.  This npm will also do for us.  What label to put it will understand the version number, in accordance with the rules of <a href="http://semver.org/">semver</a> . </li></ol><br><br>  So, we get the following set of scripts: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs &amp;&amp; git add -A docs &amp;&amp; npm run changelog &amp;&amp; git add CHANGELOG.md"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"changelog"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run conventional-changelog -- -p angular -i CHANGELOG.md -s"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run rimraf -- docs &amp;&amp; typedoc --options typedoc.json src/"</span></span> }</code> </pre><br><br><h4>  Postversion phase: </h4><br><ol><li>  We push the modified package.json, changelog.md, documentation. </li><li>  We execute push created tag. </li><li>  We add the description of changes in github release.  To do this, use conventional-github-releaser, passing it as a parameter message notation.  In our case it is ‚Äúangular‚Äù.  Because you need the appropriate access rights to record information, you need to generate an access token, which conventional-github-releaser will use for authorization.  How this is done can be found in the project description. </li></ol><br><br>  Script for version: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"postversion"</span></span>: <span class="hljs-string"><span class="hljs-string">"git push &amp;&amp; git push --tags &amp;&amp; conventional-github-releaser -p angular"</span></span>, }</code> </pre><br><br>  Our release process is ready. <br><br>  Run the script with the command: <br><pre> <code class="bash hljs">npm version &lt;   major/minor/patch&gt;</code> </pre><br><br>  The generated release notes look like this: <br><br><img src="https://habrastorage.org/files/fb1/af8/672/fb1af867219e4b3983fcc9bfb3b90bf4.png" alt="image"><br><br>  The content in changelog.md is almost the same, so we will not list it. <br><br><h4>  What else </h4><br><ul><li>  You can use conventional-changelog tools not only with github.  Conventional-changelog-cli works with any git-repository, while conventional-github-releaser has a <a href="https://www.npmjs.com/package/conventional-gitlab-releaser">sister library for working with gitlab</a> . </li><li>  You may have wondered why posting the same information in two places.  Description of the release is convenient when the user is simply interested in the new version.  A changelog comes in the npm package and will come in handy when the user has already updated the version and needs the release information to make adjustments to the code according to breaking changes or to use the new library features.  And looking at this information directly in the code editor is more convenient than in the release description on github. </li></ul><br><br><a name="zube"></a><h2>  Manage tasks with zube </h2><br>  About the service <a href="https://zube.io/">zube.io</a> we will not talk a lot.  Each of us worked with task trackers and zube is not much different from many of them. <br><br>  We name only two of its advantages, because of which we decided to mention it in this article: <br><br><ol><li>  It is free for open source projects, which is rare for project management tools that integrate with github. </li><li>  zube allows you to combine tasks from several github repositories into one project and work with them simultaneously. </li></ol><br><br>  This concludes our review.  If you are aware of other interesting services or tools for working with github, please share your knowledge in the comments. <br><br>  Thank you for your attention. <br><br>  The cover image of the article is <a href="https://octodex.github.com/benevocats">the Benevocats</a> by cameronmcefee. </div><p>Source: <a href="https://habr.com/ru/post/323760/">https://habr.com/ru/post/323760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323748/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ253 (March 6 - 12, 2017)</a></li>
<li><a href="../323750/index.html">PHP Digest number 104 - interesting news, materials and tools (March 1 - 12, 2017)</a></li>
<li><a href="../323752/index.html">Holographic displays: then and now</a></li>
<li><a href="../323754/index.html">3CX technical support responds: Plug and Play auto-tuning of IP phones does not work</a></li>
<li><a href="../323756/index.html">How to get the maximum discount when buying IT equipment</a></li>
<li><a href="../323762/index.html">Internet of Things in archeology</a></li>
<li><a href="../323764/index.html">Via MVP to VIPER. Part One: MVP</a></li>
<li><a href="../323766/index.html">7 strategies to help you get rid of procrastination</a></li>
<li><a href="../323768/index.html">How IT professionals work. Pavel Klepinin, IT Director, NIPIGAZ Center</a></li>
<li><a href="../323770/index.html">Fast factorial calculation - PrimeSwing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>