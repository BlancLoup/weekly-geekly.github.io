<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As we did "narrative" - ‚Äã‚Äãa new format of publications in Yandex. Dzen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For two years, Yandex.Dzen learned to solve the problem of personalized content recommendations. Now Zen is not only an aggregator of articles and vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As we did "narrative" - ‚Äã‚Äãa new format of publications in Yandex. Dzen</h1><div class="post__text post__text-html js-mediator-article">  For two years, Yandex.Dzen learned to solve the problem of personalized content recommendations.  Now Zen is not only an aggregator of articles and videos from third-party Internet resources, but also a content platform.  In the summer of 2017, the publishers platform was launched, on which everyone can create publications, and upon reaching 7000 inspections - earn money from it.  You can read about the monetization system and other features of the platform <a href="https://zen.yandex.ru/media/zenmag">in Zen magazine</a> . <br><br>  Articles and videos are traditional types of content.  In order to attract authors to the platform and give them new tools to increase the audience, Zen decided to go beyond the usual formats.  One of the new formats was the narrative.  This is a set of cards, united by a common theme.  Internet users are less and less read, but still want to get interesting stories (so they, for example, watch TV shows, short videos and live broadcasts).  We created a format that helps authors tell consecutive short stories and entertain readers. <br><br><img src="https://habrastorage.org/webt/ae/qd/pl/aeqdplfxnhplgv053x5vp2gv8fg.png"><br><h5>  <sub><sup>Narratives of publishers and authors</sup></sub> </h5><br>  The card can contain text, links, images, video and GIF-animation.  A narrative can tell a story, give step-by-step instructions or a recipe, publish a list of useful books, describe the advantages and disadvantages of budget management approaches.  This is a format for authors who create interesting content, but do not write long texts. <br><a name="habracut"></a><br>  Basically, the format is focused on mobile phones, as people often consume information and entertainment content from mobile devices.  We added restrictions: the format should be capacious, but short, so the number of narrative cards is not infinite.  Each card contains a maximum of one video and one link, it allows you to keep the story consistently, without overloading the reader‚Äôs attention.  An interested person can go from the narrative to the author's site, read the expanded version of the material, but the content of the narrative should be enough to sort out the topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/ku/hx/k3/kuhxk35wirnvuyvbfv1fjrnakds.png"><br><h5>  <sub><sup>Example: narrative about narrative</sup></sub> </h5><br>  The closest analogue of narratives, stories on Instagram, is limited in time and shows only 24 hours.  This affects the content: the materials may not be related to a common theme, they are not informative, they are focused on social interaction and getting reactions from familiar people.  Despite the fact that we like stories, this format does not suit Zen.  Our publications are shown much longer and are recommended to the audience, often not belonging to one social or geographical group.  We built a format that combines the ease of microformat with the involvement and plot of the longrides. <br><br>  To enable users to create diverse and unique narratives, we needed to provide them with a special editor with tools for building and styling content ‚Äî like presentation software.  The editor had to tell the authors how to make the presentation visually appealing, report on format restrictions, and be easy to use.  Therefore, we added a view mode where the narrative is presented in the way that the readers will see it.  We did not limit the authors to the patterns of the arrangement of elements: all elements on the narrative card can be arbitrarily arranged.  In addition, we have developed a system of layers, which allows you to control the imposition of elements on each other. <br><br><img src="https://habrastorage.org/webt/_q/ol/s5/_qols5nbey92fjzjb86b01ehvxm.png"><br><h5>  <sub><sup>Narrative editor</sup></sub> </h5><br>  In the process of creating the editor, we are faced with a number of interesting technical problems.  This article is about how we solved them. <br><br><h2>  Stack used </h2><br>  The technological base consisted of React (for the editor), preact (for display), Redux, Draft.js (for text blocks), and flowtype.  The state is stored in a normalized form (see normalizr), which made it possible to quickly produce the most frequent operation - updating the properties of elements on the card.  For other actions (such as swapping cards, adding and removing blocks, etc.), the normalized state also shows better performance than regular data storage in the form of a tree of objects. <br><br><h2>  We make the card and blocks on the card responsive </h2><br>  The first task was to create an adaptive card that preserves the composition at any size.  On mobile platforms, the card tends to occupy the maximum area based on the aspect ratio, so its dimensions can vary greatly from device to device. <br><br>  Consequently: <br><br><ul><li>  The card retains the specified aspect ratio (we chose 44:75) for any screen size. </li><li>  The text on the card also keeps the same relative space occupied at any card size.  That is, the font size should be proportional to the size of the card. </li><li>  Blocks retain relative sizes and location for any card size. </li></ul><br>  Consider ways to implement these requirements. <br><br><h4>  How to keep the card aspect ratio? </h4><br>  At first, I wanted to use pure CSS.  And indeed, the network describes several ways that allow you to do this: <br><br><ul><li>  <a href="https://css-tricks.com/snippets/sass/maintain-aspect-ratio-mixin/">Dimensioning through padding</a> using the padding property specified in percent, since the relative value of the block width is taken.  This method did not fit, since it does not allow to ‚Äúenter‚Äù the card into the screen.  In other words, if the height of the card exceeds the height of the screen, the card will not decrease in height, keeping its proportions. </li><li>  <a href="https://stackoverflow.com/a/20593342/297939">Dimensioning by combining the height, width, max-height and max-width specified in vh and vw</a> allows you to achieve the desired effect.  However, the method is limited by the size of the screen.  In other words, when embedding cards in the layout, where the card will not occupy the whole screen (for example, in the editor), the aspect ratio will not be maintained. </li></ul><br>  Thus, the solution on pure CSS had to be abandoned, and as a result, the solution on JS was used, which turned out to be much more compact and understandable than the solution on CSS: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// @flow type Size = { width: number, height: number }; function getFittedSlideSize(container: Size, target: Size): Size { const targetAspectRatio = target.width / target.height; const containerAspectRatio = container.width / container.height; // if aspect ratio of target is "wider" then target's aspect ratio const fit = targetAspectRatio &gt; containerAspectRatio ? 'width' // fit by width, so target's width = container's width : 'height'; // fit by height, so target's height = container's height return { width: fit === 'width' ? containerWidth : Math.round(containerHeight * ( target.width / target.height)), height: fit === 'height' ? containerHeight : Math.round(containerWidth * (target.height / target.width)), }; }</span></span></code> </pre> <br>  It does not give a noticeable minus in the speed of rendering, there is a potential for acceleration.  For example, you can remove the alignment from the main JS bundle and execute it immediately after the HTML code of the cards.  Then the cards will be immediately displayed in the correct sizes. <br><br><img src="https://habrastorage.org/webt/t7/nv/s_/t7nvs_jruzmogl9fpmjq7f6xwry.jpeg"><br><h5>  <sub><sup>The proportions of the card are saved on any screen.</sup></sub> </h5><br><h4>  How to keep relative sizes of text elements? </h4><br>  To proportionally resize text elements within a slide, we did the following: <br><br><ol><li>  All dimensions in text elements are given in em. </li><li>  For a slide, the font size is set in px and calculated in the proportion obtained from the following positions: <br><br><ul><li>  Let the base width of the slide (BASE_WIDTH) be 320px. </li><li>  Let the base font size (BASE_FONT_SIZE) be equal to 16px for the base width of the slide. </li><li>  Then when you change the size of the slide, the new font size is calculated as follows: <br><br><pre>  const relativeFontSize = (BASE_FONT_SIZE * slideSize.width) / BASE_WIDTH; </pre></li></ul></li></ol><br>  Thus, setting the font size in em leads to an automatic recalculation of the font size of the elements. <br><br><h4>  How to make objects on the card keep their location and relative sizes? </h4><br>  To save the composition, the introduction of a relative coordinate system is best.  Thanks to the web platform, such a system is already there - this is the task of the size and location of the blocks in percent!  Indeed, whatever the size of the card in pixels, the size and location of objects, given in percent, allow them to change proportionally. <br><br>  It turns out that we have introduced a new coordinate system (‚Äúcard‚Äù) within each card with a visible area from 0 to 100% on each of the axes.  Now we need to learn how to recalculate all pixel dimensions as percentages.  This will be needed when we will: <br><br><ul><li>  Consider the size of objects, based on the knowledge of what are the sizes on one axis, and the original size.  For example, if we insert an image on a slide, we set the default 90 percent width and must calculate the height in percent. </li><li>  Move objects on the card. </li><li>  Change their size. </li></ul><br><h2>  Initializing objects with unknown dimensions </h2><br>  Now, having a "card" coordinate system, you can place blocks on a card, without worrying that their relative position will be distorted when the card is resized. <br><br>  Each block has a geometry property that describes the size and location of the block: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">geometry</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">width</span></span>: number, height?: number } }</code> </pre> <br>  If you add a block with a fixed aspect ratio (for example, a picture or video), the problem arises of recalculating the dimensions from the pixel coordinate system to the ‚Äúcard‚Äù one. <br><br>  For example, when adding a picture to a slide, the default is 90 percent width of an element in the ‚Äúcard‚Äù coordinate system.  Knowing the original dimensions of the image (Image.naturalWidth and Image.naturalHeight), the dimensions of the ‚Äúcard pixel‚Äù and the width of the image in the new coordinates, it is necessary to calculate the height (also in the new coordinates).  Having resorted to the knowledge of higher arithmetic, we derived the calculation function in the "card" coordinate system.  For example, you can calculate the height of the image: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRelativeHeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">natural: Size, container: Size, relativeWidth: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (natural.height / natural.width) * (container.width / container.height) * relativeWidth; }</code> </pre> <br>  Here natural is the size of the image in px, container is the size of the slide in px, relativeWidth is the size of the image on the slide in percent. <br><br><img src="https://habrastorage.org/webt/fk/cf/-h/fkcf-hfer4yevkaykyebfwvgqec.png"><br><br><h2>  Moving objects </h2><br>  When we mastered transfers to the ‚Äúcard‚Äù coordinate system, it became easy to realize the movement of an object.  The code that is responsible for this is something like this: <br><br><pre> <code class="javascript hljs">type Size = {<span class="hljs-attr"><span class="hljs-attr">width</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: number}; type Position = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: number}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NarrativeEditorElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... handleUpdatePosition = (e) =&gt; { // slide - DOM-,     const {slide} = this.props; if (!this.state.isMoving) { // this.ref ‚Äî DOM-   (,   ..) this.initialOffsetLeft = this.ref.offsetLeft; this.initialOffsetTop = this.ref.offsetTop; } const relativePosition = getRelative( {width: slide.offsetWidth, height: slide.offsetHeight}, {x: this.initialOffsetLeft + e.deltaX, y: this.initialOffsetTop + e.deltaY}, ); this.setState({ geometry: { ...this.state.geometry, x: relativePosition.x, y: relativePosition.y, }, isMoving: true, }); } // ... } function getRelative(slideSize: Size, position: Position) { return { x: 100 * position.x / slideSize.width, y: 100 * position.y / slideSize.height, }; }</span></span></code> </pre><br><h2>  4-point resizing </h2><br>  In any decent visual editor, you can resize the object by dragging the ‚Äúsquares‚Äù located at the corners of its borders.  We also had to implement this opportunity. <br><br><img src="https://habrastorage.org/webt/rv/_k/9a/rv_k9anksg7w-cpt08qm-6yhnwg.jpeg" width="200"><br><br>  It was not so easy to write a compact and clear code that handles the resizing of an object depending on the angle the user pulls.  Before ‚Äúcycling‚Äù our decision, we conducted a review of how this is done in popular libraries.  For example, the code in <a href="">jQuery UI</a> looks like this: <br><br><img src="https://habrastorage.org/webt/ph/xv/g7/phxvg7qiivylzayashus8zccd_k.png"><br><br>  The code looks compact, but it is not easy to understand: functions are not ‚Äúclean‚Äù, a large number of internal methods of the class and its properties are used, the context of the function execution is important (see apply). <br><br>  In our project, about the same code is written <a href="https://gist.github.com/DimitryDushkin/e2eb5d7cd7129c804cf0bfa7376809a3">as follows</a> .  Here the minimum size of the object and the optional restriction on the preservation of the aspect ratio (preserveAspectRatio) are also taken into account - this is important when resizing the video or image. <br><br>  Our code can not be called compact, but the function turned out to be ‚Äúclean‚Äù, and the structure of the solution itself is rectilinear. <br><br>  It would be great if you, dear readers, offered a version of the code that solves this problem.  I admit that there is a certain regularity, after understanding which the code becomes super-short and understandable. <br><br><h2>  The problem of inconsistent text rendering on different platforms </h2><br>  After a more or less extensive testing of the narrative began, we were surprised to find that in some cases the same text with the same font, size, and other attributes has a different number of lines on different platforms! <br><br>  For example, in Safari, when creating a narrative, a text block had 4 lines, but when viewing it in Chrome on Android, 3 lines were shown.  We have not figured out the exact reason for this behavior and blamed it on the features of text rendering engines on various platforms. <br><br>  We solved the problem by splitting text blocks into lines before publication.  And here, too, was an interesting place.  The first approach to defining strings was to wrap each character in a &lt;span&gt; and determine its position using getBoundingClientRect.  It worked quickly, and we didn‚Äôt notice for quite a long time the problem that this approach gave rise to.  Guess what problem is it? <br><br>  It turned out that many fonts, including <a href="https://habrahabr.ru/company/yandex/blog/282534/">Yandex Sans Text</a> , contain optimizations of the display of intersymbol distance for certain combinations of characters (kerning). <br><br><img src="https://habrastorage.org/webt/rn/yi/gh/rnyighl_-sukqchl5s2qoulmore.png"><br><h5>  <sub><sup>The font-kerning CSS property is set in the right column: none</sup></sub> </h5><br>  If each character is wrapped in a &lt;span&gt;, this optimization does not work!  It turns out that a string with the specified combinations, but without &lt;span&gt; tags around each character (that is, what the editor user sees it) may be shorter than with tags. <br><br>  This problem can be quickly resolved with the ancient CSS property of font-kerning: none, which simply disables these optimizations.  Most likely, most people viewing a narrative will not notice anything. <br><br>  But there must be a way to make everything beautiful!  And we found a solution in using the same ancient, but very useful Range API, which can provide information similar to getBoundingClientRect () for a given range of text selection.  Now we are working on this decision, and we hope that in the near future it will go to production. <br><br><h2>  Difficult substrate under text elements </h2><br>  Many authors used translucent images to increase the contrast of the font placed on top of the photo.  Others wrote to us with requests to add the corresponding function to the editor itself. <br><br>  Our designer, Anya, was surprised by the development of the choice of the most difficult version of the substrate geometry.  In addition to combining lines of similar length in one rectangle, the idea was to use the middle of a lowercase letter without detail elements (for example, ‚Äúa‚Äù or ‚Äúo‚Äù) as the axis of symmetry.  Such an implementation creates an enhanced ‚Äúcartoonish‚Äù effect of the resulting figures - they resemble speech bubbles in comics. <br><br><img src="https://habrastorage.org/webt/sx/rv/t_/sxrvt_qx_gqlh9t35cwxioxe3qw.png" height="278"><img src="https://habrastorage.org/webt/ni/wq/4-/niwq4-najqf1xk0p3--keom0azk.png" height="278"><br><h5>  <sub><sup>Algorithm and implementation of the substrate</sup></sub> </h5><br>  We had to draw the figures manually, using the dimensions of the lines calculated at the last stage.  They are implemented as closed svg-paths consisting of arcs of circles of the same radius and straight lines. <br><br>  Since none of the known technologies was suitable for solving the problem, we wrote our svg curve drawing algorithm, which is used for the cover. <br><br><h2>  Conclusion </h2><br>  Narrative is a new format, and it needs to be developed.  For better engagement in history, we will increase the area of ‚Äã‚Äãthe narrative card, add graphic elements and animations, support the use of gestures and the possibility of a seamless continuation of viewing similar narratives. <br><br>  Readers appreciate the quality of publications.  To make publishing better, we will tell the authors what the audience likes.  Some authors <a href="https://zen.yandex.ru/media/zenmag/kak-sdelat-krasivyi-i-populiarnyi-narrativ-sovety-the-village-kpru-vedomostei-i-womens-health-5a607545865165ef209d8846">have already shared</a> their observations and ways of creating good narratives. <br><br>  From a technical point of view, there are unresolved problems and room for optimization.  For example, in some embedded browsers on Android (usually in browsers from the vendor itself), when the system font is increased, setting the font size on a web page not below a certain threshold is forced.  In the case of a narrative, this, of course, breaks the composition. <br><br>  A native implementation of the narrative viewer on iOS and Android is planned, so we are exploring the possibility of simplifying the creation of such viewers.  It seems to us that one of the interesting ways is the ‚Äúscreenshots‚Äù of individual elements on the slide.  They would allow not to think about the correct font size: pictures, unlike text, vary very naturally in size due to the percentage "card" coordinate system.  In addition, we don‚Äôt need to load the Yandex font at all, it will not be necessary to drag the rather intricate algorithm for rendering the text substrate, etc. <br><br>  Finally, we plan to transfer video from streams (initially there was a good infrastructure for streaming video) to regular MP4 / WebM files: with short videos, this approach shows better compatibility and speed. <br><br><hr>  The article was prepared by Yandex.Dzena staff: Dmitry Dushkin and Vasily Gorbunov wrote about the frontend, Uliana Salo - about the design. </div><p>Source: <a href="https://habr.com/ru/post/349220/">https://habr.com/ru/post/349220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349208/index.html">Werewolf file: NES cartridge image and ZIP file in one</a></li>
<li><a href="../349212/index.html">Creating a dynamic tooltip in Angular2 + applications</a></li>
<li><a href="../349214/index.html">Smart contract trap in the network Ethereum</a></li>
<li><a href="../349216/index.html">Registration is now open for Raiffeisen Data_Cup</a></li>
<li><a href="../349218/index.html">YouTube fell? Or one percent problem</a></li>
<li><a href="../349222/index.html">Hakintosh: upgrading from macOS Sierra 10.12 to High Sierra 10.13</a></li>
<li><a href="../349224/index.html">PostgreSQL indexes - 10</a></li>
<li><a href="../349226/index.html">The blockchain program committee or how to fight off the ICO</a></li>
<li><a href="../349228/index.html">Unit tests when using Corutin in Android application</a></li>
<li><a href="../349230/index.html">How to make your code 80 times faster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>