<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating Bluetooth profiles in the BLE TI stack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, we set up development tools, tried to figure out how the code works, how to debug it, but did not write a single lin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating Bluetooth profiles in the BLE TI stack</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e06/4f3/da1/e064f3da123a4731be5f22ad5043e222.jpg"><br><br>  <a href="http://habrahabr.ru/company/intellectro/blog/246005/">In the first part of the article,</a> we set up development tools, tried to figure out how the code works, how to debug it, but did not write a single line of code.  Fix it in the second part.  Write your own BLE profile for CC2541. <br><br><a name="habracut"></a><br>  1. Statement of the problem 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose we need a profile for our device that will support the following functions: <br>  - setting and reading the values ‚Äã‚Äãof two PWM channels (from 0 to 255), <br>  - getting the state of pressing two buttons, <br>  - reading the state of one of these buttons. <br><br>  In fact, we need four profile characteristics - two responsible for the state of the PWM channels and two buttons that notify the state. <br><br>  2. UUID service and characteristics <br><br>  As mentioned in the <a href="http://habrahabr.ru/company/intellectro/blog/246005/">previous section</a> , the mere mortal cannot use 16-bit service addresses.  To do this, at least you need to be an Associated Member Bluetooth SIG.  In general, 128-bit UUID services are allocated for us.  To generate the UUID of our service, we will use <a href="http://famkruithof.net/uuid/uuidgen">this service</a> . <br><br>  We need five UUIDs - four for features and one for the service.  In order for the UUID to go in order, choose the algorithm "Time / node based".  After generation, we get something like this UUID set: <br><img src="https://habrastorage.org/files/7d7/a7b/50b/7d7a7b50b4fe428d92fece1369b7d243.jpg"><br><br>  Now everything is ready to start writing the profile code.  Let's call our HabrProfile profile and add it to the SimpleBLEPerepherial project. <br><br>  3. Creating a header file <br><br>  In the \ Projects \ Profiles folder of the stack, create the HabrProfile folder, and in it the habrprofile.h and habrprofile.c files <br>  Next, add the files to the project SimpleBLEPerepherial in the PROFILES folder. <br>  The header file should contain: <br>  -UUID profile and characteristics that were obtained by your <br>  -Naming of profile attributes (so that it is convenient to access them from the main program) <br>  -Advertise functions for working with characteristics and profile from an external program <br>  - Determination of the type of function callback callback profile <br><br><div class="spoiler">  <b class="spoiler_title">Contents of the habrprofile.h file</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HABR_UUID(uuid) 0x66, 0x9a, 0x0c, 0x20, 0x00, 0x08, 0xa9, 0xb4, 0xe4, 0x11, 0xd7, 0x85, uuid, 0x50 , 0x2e, 0x51 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_BUTTON1_STATE_ATTR 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_BUTTON2_STATE_ATTR 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_CHANNEL1_PWM_ATTR 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_CHANNEL2_PWM_ATTR 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_SERVICE_UUID 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_BUTTON1_STATE_UUID 0x11 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_BUTTON2_STATE_UUID 0x12 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_CHANNEL1_PWM_UUID 0x13 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_CHANNEL2_PWM_UUID 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HH_SERVICE 0x00000001 typedef void (*habrControlCB_t)( uint8 paramID ) ; typedef struct { habrControlCB_t pfnHabrCB; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Called when some att changed } HarbCBs_t; extern bStatus_t Habr_AddService(); extern bStatus_t Habr_RegisterAppCBs( HarbCBs_t *appCallbacks ); extern bStatus_t Habr_SetParameter( uint8 param, uint8 len, void *value ); extern bStatus_t Habr_GetParameter( uint8 param, void *value );</span></span></span></span></code> </pre> <br></div></div><br><br>  The first thing we encounter is that 15 bytes from our 16 UUIDs are the same.  Accordingly, it is reasonable to combine them into a common define, considering, however, the fact that the byte order in Bluetooth is big-endian, and in the UUID record we received is little endian.  Therefore, the record of bytes in Define is flipped. <br>  The AddService and RegisterAppCBs functions are used to register the profile in the stack and bind the program callback functions to the profile. <br>  The functions SetParameter and GetParameter are needed to control the values ‚Äã‚Äãof profile characteristics. <br>  In addition, we need to make handlers for setting events and reading variables over the protocol, but more on that later.  First, mark the profile table in the executable file. <br><br>  4. Table of services <br><br>  So, we have four characteristics, two of which can notify the user application of the change in the value of the characteristic.  As mentioned in the first part of the article, to initialize one variable to read or write, three entries in the device table are required, for a variable to be notified, four entries, that is, for all profile variables, we need 14 entries, adding an entry to them, declaring the profile, we get 15 entries . <br><br>  The most important thing now is to set the device table correctly. <br>  The first thing to do is to form the UUID of the profile and the characteristics into variables in the form: <br><pre> <code class="cpp hljs">CONST uint8 HhServUUID[ATT_UUID_SIZE] = { HABR_UUID(HH_SERVICE_UUID) };</code> </pre><br>  Next, we define variables / constants that will be responsible for the parameters of specific characteristics: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint8 hhButton1CharProps = GATT_PROP_NOTIFY; <span class="hljs-comment"><span class="hljs-comment">//     static uint8 hhButton1Value = 0x00; //    static gattCharCfg_t hhButton1Config[GATT_MAX_NUM_CONN]; //  -    NOTIFY static uint8 hhButton1UserDesc[]="Button 1 variable\0"; //  </span></span></code> </pre><br>  And we enter the characteristics in the gatt table of the device characteristics (an array of type gattAttribute_t) in the form: <br><pre> <code class="cpp hljs">{ gattAttrType_t type; <span class="hljs-comment"><span class="hljs-comment">//   handle    UUID . uint8 permissions; //    . uint16 handle; //    -  0. uint8* const pValue; //  ( 512 ). }</span></span></code> </pre><br>  This creates a little confusion.  On the one hand, we have a variable that defines the access rights to the characteristic (in the previous listing, GATT_PROP_NOTIFY).  On the other hand, there is an entry responsible for access rights to the attribute.  Let us clarify this difference in our example.  In our profile there is a notification from both buttons and there is a possibility to read the state of one of them (the second). <br>  Then for the first setting of the characteristic - GATT_PROP_NOTIFY, but no permission to read or write. <br>  For the second characteristic setting - GATT_PROP_NOTIFY |  GATT_PROP_READ, in addition, read permission must be declared in the GATT table of the device (otherwise a callback with a read request will not be called) - GATT_PERMIT_READ. <br><br>  In more detail - in the full attribute table: <br><br><div class="spoiler">  <b class="spoiler_title">Table of profile attributes, variables and variable declarations</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bcomdef.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"OSAL.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"linkdb.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"att.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gatt.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gatt_uuid.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gattservapp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"habrprofile.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"OSAL_Clock.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SERVAPP_NUM_ATTR_SUPPORTED 15 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UUID_SIZE 16 CONST uint8 hhServUUID[ATT_UUID_SIZE] = { HABR_UUID(HH_SERVICE_UUID) }; CONST uint8 hhButton1UUID[ATT_UUID_SIZE] = { HABR_UUID(HH_BUTTON1_STATE_UUID) }; CONST uint8 hhButton2UUID[ATT_UUID_SIZE] = { HABR_UUID(HH_BUTTON2_STATE_UUID) }; CONST uint8 hhPWM1UUID[ATT_UUID_SIZE] = { HABR_UUID(HH_CHANNEL1_PWM_UUID) }; CONST uint8 hhPWM2UUID[ATT_UUID_SIZE] = { HABR_UUID(HH_CHANNEL2_PWM_UUID) }; static HarbCBs_t *habrahabrAppCBs_t = NULL; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//attribute definitions static CONST gattAttrType_t hhService = {ATT_UUID_SIZE, hhServUUID}; static uint8 hhButton1CharProps = GATT_PROP_NOTIFY; static uint8 hhButton1Value = 0x00; static gattCharCfg_t hhButton1Config[GATT_MAX_NUM_CONN]; static uint8 hhButton1UserDesc[]="Button 1 variable\0"; static uint8 hhButton2CharProps = GATT_PROP_NOTIFY|GATT_PROP_READ; static uint8 hhButton2Value = 0x00; static gattCharCfg_t hhButton2Config[GATT_MAX_NUM_CONN]; static uint8 hhButton2UserDesc[]="Button 2 variable\0"; static uint8 hhPWM1CharProps = GATT_PROP_READ | GATT_PROP_WRITE; static uint8 hhPWM1Value = 0x00; static uint8 hhPWM1UserDesc[] = "PWM 1 variable\0"; static uint8 hhPWM2CharProps = GATT_PROP_READ | GATT_PROP_WRITE; static uint8 hhPWM2Value = 0x00; static uint8 hhPWM2UserDesc[] = "PWM 2 variable\0"; //attribute table static gattAttribute_t HabrProfileAttrTable[15]={ //Service { { ATT_BT_UUID_SIZE, primaryServiceUUID }, GATT_PERMIT_READ, 0, (uint8 *)&amp;hhServUUID }, //Button1 { { ATT_BT_UUID_SIZE, characterUUID }, GATT_PERMIT_READ, 0, &amp;hhButton1CharProps }, { {UUID_SIZE, hhButton1UUID }, 0, 0, (uint8 *)&amp;hhButton1Value }, { {ATT_BT_UUID_SIZE , clientCharCfgUUID}, GATT_PERMIT_READ | GATT_PERMIT_WRITE, 0, (uint8 *)hhButton1Config }, { { ATT_BT_UUID_SIZE, charUserDescUUID }, GATT_PERMIT_READ, 0, hhButton1UserDesc } , //Button2 { { ATT_BT_UUID_SIZE, characterUUID }, GATT_PERMIT_READ, 0, &amp;hhButton2CharProps }, { {UUID_SIZE, hhButton2UUID }, GATT_PERMIT_READ, 0, (uint8 *)&amp;hhButton2Value }, { {ATT_BT_UUID_SIZE , clientCharCfgUUID}, GATT_PERMIT_READ | GATT_PERMIT_WRITE, 0, (uint8 *)hhButton2Config }, { { ATT_BT_UUID_SIZE, charUserDescUUID }, GATT_PERMIT_READ, 0, hhButton2UserDesc } , //PWM channel 1 { { ATT_BT_UUID_SIZE, characterUUID }, GATT_PERMIT_READ, 0, &amp;hhPWM1CharProps }, { {UUID_SIZE, hhPWM1UUID }, GATT_PERMIT_READ | GATT_PERMIT_WRITE, 0, (uint8*)&amp;hhPWM1Value }, { { ATT_BT_UUID_SIZE, charUserDescUUID }, GATT_PERMIT_READ, 0, hhPWM1UserDesc } , //PWM channel 2 { { ATT_BT_UUID_SIZE, characterUUID }, GATT_PERMIT_READ, 0, &amp;hhPWM2CharProps }, { {UUID_SIZE, hhPWM2UUID }, GATT_PERMIT_READ | GATT_PERMIT_WRITE, 0, (uint8*)&amp;hhPWM2Value }, { { ATT_BT_UUID_SIZE, charUserDescUUID }, GATT_PERMIT_READ, 0, hhPWM2UserDesc } };</span></span></span></span></code> </pre><br></div></div><br><br>  5. Custom Functions <br><br>  The next step is to describe the functions called from the main program for: <br>  - profile registration, <br>  - the purpose of the callback function, <br>  - read variables <br>  - records of variables. <br><br>  To register a profile on the stack, you first need to declare profile callback functions ‚Äî just those functions that are called when an external event occurs ‚Äî a request to read or write a characteristic, as well as a function called when the connection status changes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_ReadAttrCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, gattAttribute_t *pAttr, uint8 *pValue, uint8 *pLen, uint16 offset, uint8 maxLen )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> bStatus_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_WriteAttrCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, gattAttribute_t *pAttr, uint8 *pValue, uint8 len, uint16 offset )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_HandleConnStatusCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, uint8 changeType )</span></span></span></span>; CONST gattServiceCBs_t HH_CBs = { hh_ReadAttrCB, <span class="hljs-comment"><span class="hljs-comment">// Read callback function pointer hh_WriteAttrCB, // Write callback function pointer NULL };</span></span></code> </pre><br><br>  Ok, now you can register the profile in the stack and check the correctness of the profile characteristics table.  In addition to directly calling GATTServApp_RegisterService, the function of registering a profile on the stack also involves registering a callback function when the connection status changes and initializing configuration variables (for those characteristics that should be notified): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">bStatus_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Habr_AddService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint8 status = SUCCESS; GATTServApp_InitCharCfg( INVALID_CONNHANDLE, hhButton1Config ); GATTServApp_InitCharCfg( INVALID_CONNHANDLE, hhButton2Config ); <span class="hljs-function"><span class="hljs-function">VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkDB_Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( hh_HandleConnStatusCB )</span></span></span></span>; status = GATTServApp_RegisterService(HabrProfileAttrTable, GATT_NUM_ATTRS(HabrProfileAttrTable), &amp;HH_CBs ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( status ); }</code> </pre><br><br>  Verify the attribute table.  To do this, in SimpleBLEPerepherial.c in the SimpleBLEPeripheral_Init function, call Habr_AddService, having previously added the header header (and not forgetting to add the path to the heading for the compiler, the line "$ PROJ_DIR $ \ .. \ .. \ Profiles \ HabrProfile").  Let us run through the debug board, connect to it via the BLE Device Monitor and check the resulting attribute table: <br><img src="https://habrastorage.org/files/c84/ecb/c59/c84ecbc599ae4a6a9fcfe50b30d22b7f.png"><br>  It is important to verify the UUID, profile composition.  If all is well, go ahead. <br><br>  I will omit the description of the function <br><br><div class="spoiler">  <b class="spoiler_title">Functions for reading and writing variables from a user application</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">bStatus_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Habr_RegisterAppCBs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( HarbCBs_t *appCallbacks )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( appCallbacks ) { habrahabrAppCBs_t = appCallbacks; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( SUCCESS ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( bleAlreadyInRequestedMode ); } } <span class="hljs-function"><span class="hljs-function">bStatus_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Habr_SetParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint8 param, uint8 len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *value )</span></span></span></span>{ bStatus_t ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( param ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_BUTTON1_STATE_ATTR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(len == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8)) { hhButton1Value = *((uint8*)value); GATTServApp_ProcessCharCfg (hhButton1Config, (uint8 *)&amp;hhButton1Value, FALSE, HabrProfileAttrTable ,GATT_NUM_ATTRS(HabrProfileAttrTable), INVALID_TASK_ID); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ ret = bleInvalidRange; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_BUTTON2_STATE_ATTR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(len == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8)) { hhButton2Value = *((uint8*)value); GATTServApp_ProcessCharCfg (hhButton2Config, (uint8 *)&amp;hhButton2Value, FALSE, HabrProfileAttrTable ,GATT_NUM_ATTRS(HabrProfileAttrTable), INVALID_TASK_ID); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ ret = bleInvalidRange; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_CHANNEL1_PWM_ATTR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(len == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8)) { hhPWM1Value = *((uint8*)value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ ret = bleInvalidRange; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_CHANNEL2_PWM_ATTR: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(len == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8)) { hhPWM2Value = *((uint8*)value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ ret = bleInvalidRange; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ret = INVALIDPARAMETER; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(ret); }</code> </pre><br></div></div><br><br>  I don‚Äôt see any reason to dwell on the callback registration function.  A little closer look at the function of writing and reading the values ‚Äã‚Äãof variables, and first of all the function of writing values ‚Äã‚Äãin the profile.  Here you should pay attention to the fact that it is necessary to make a call to GATTServApp_ProcessCharCfg - this function will provide the actual notification. <br><br>  Things are easy - add functions for handling stack events. <br>  6. BLE stack function callback <br><br>  As it was said above, the stack events will be handled by three functions - an attribute value read request callback, an attribute record read request callback, a connection status callback. <br>  Teaching a profile to give its characteristics to reading is very simple (especially in our case, when all characteristics are values ‚Äã‚Äãof the same type of uint8) - for this you need to make sure that we are dealing with the right characteristics.  The stack in response from the function receives three values ‚Äã‚Äã- status, pLen (so it is important to always set the exact value of pLen) and pValue.  All three values ‚Äã‚Äãare passed on and can be obtained by us at the receiving side. <br><br><div class="spoiler">  <b class="spoiler_title">Read service characteristics</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_ReadAttrCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, gattAttribute_t *pAttr, uint8 *pValue, uint8 *pLen, uint16 offset, uint8 maxLen )</span></span></span><span class="hljs-function"> </span></span>{ bStatus_t status = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( offset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( ATT_ERR_ATTR_NOT_LONG ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pAttr-&gt;type.len == ATT_UUID_SIZE ) { <span class="hljs-comment"><span class="hljs-comment">// 128-bit UUID uint8 uuid[ATT_UUID_SIZE]; osal_memcpy(uuid, pAttr-&gt;type.uuid, ATT_UUID_SIZE); if(osal_memcmp(uuid,hhPWM2UUID,ATT_UUID_SIZE)|| osal_memcmp(uuid,hhPWM1UUID,ATT_UUID_SIZE)|| osal_memcmp(uuid,hhButton2UUID,ATT_UUID_SIZE)|| osal_memcmp(uuid,hhButton1UUID,ATT_UUID_SIZE)) { *pLen = 1; pValue[0] = *pAttr-&gt;pValue; } } else { // 16-bit UUID *pLen = 0; status = ATT_ERR_INVALID_HANDLE; } return ( status ); } }</span></span></code> </pre><br></div></div><br><br>  At the same time, we check the reading of the characteristics - whether everything works correctly (by the way, we expect a read error for the variable of the first button): <br><img src="https://habrastorage.org/files/1c4/826/027/1c4826027cf94c6cb14706d63c6b3926.png"><br><br>  The variables are written to the profile in the same way, but in the reading function we grouped the variables ‚Äî here it is not advisable to do this, because I want the callback called by the profile to understand which particular characteristic has been changed.  This is achieved by defining the notify variable.  If it has been set, then this function will call the function in the user application with the notify parameter. <br>  In addition, in addition to processing the recording of the PWM values, this function turns on (and off) the notification, if the value for the attribute of the configuration of the reported characteristic has been recorded ‚Äî this is achieved by calling the GATTServApp_ProcessCCCWriteReq () function; <br><br><div class="spoiler">  <b class="spoiler_title">Record service characteristics</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> bStatus_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_WriteAttrCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, gattAttribute_t *pAttr, uint8 *pValue, uint8 len, uint16 offset )</span></span></span></span>{ bStatus_t status = SUCCESS; uint8 notify = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pAttr-&gt;type.len == ATT_UUID_SIZE ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 uuid[ATT_UUID_SIZE] = { HABR_UUID(pAttr-&gt;type.uuid[<span class="hljs-number"><span class="hljs-number">12</span></span>]) }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(osal_memcmp(uuid,hhPWM1UUID,ATT_UUID_SIZE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( offset == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( len != <span class="hljs-number"><span class="hljs-number">1</span></span> ){ status = ATT_ERR_INVALID_VALUE_SIZE; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { status = ATT_ERR_ATTR_NOT_LONG; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( status == SUCCESS ) { uint8 *pCurValue = (uint8 *)pAttr-&gt;pValue; *pCurValue = pValue[<span class="hljs-number"><span class="hljs-number">0</span></span>]; notify = HH_CHANNEL1_PWM_ATTR; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(osal_memcmp(uuid,hhPWM2UUID,ATT_UUID_SIZE)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( offset == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( len != <span class="hljs-number"><span class="hljs-number">1</span></span> ){ status = ATT_ERR_INVALID_VALUE_SIZE; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { status = ATT_ERR_ATTR_NOT_LONG; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( status == SUCCESS ) { uint8 *pCurValue = (uint8 *)pAttr-&gt;pValue; *pCurValue = pValue[<span class="hljs-number"><span class="hljs-number">0</span></span>]; notify = HH_CHANNEL2_PWM_ATTR; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAttr-&gt;type.len== ATT_BT_UUID_SIZE) { uint16 uuid= BUILD_UINT16(pAttr-&gt;type.uuid[<span class="hljs-number"><span class="hljs-number">0</span></span>],pAttr-&gt;type.uuid[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(uuid){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GATT_CLIENT_CHAR_CFG_UUID: status=GATTServApp_ProcessCCCWriteReq(connHandle, pAttr, pValue, len, offset, GATT_CLIENT_CFG_NOTIFY); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: status = ATT_ERR_ATTR_NOT_FOUND; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ status = ATT_ERR_INVALID_HANDLE; } <span class="hljs-comment"><span class="hljs-comment">// If an attribute changed then callback function to notify application of change if ( (notify != 0xFF) &amp;&amp; habrahabrAppCBs_t &amp;&amp; habrahabrAppCBs_t-&gt;pfnHabrCB ) habrahabrAppCBs_t-&gt;pfnHabrCB(notify); return ( status ); }</span></span></code> </pre><br></div></div><br><br>  Profile is almost ready.  The last thing to add to it is a function that disables the notification of variables when the connection is lost. <br><div class="spoiler">  <b class="spoiler_title">The function that turns off the notification when communication is lost</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hh_HandleConnStatusCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uint16 connHandle, uint8 changeType )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( connHandle != LOOPBACK_CONNHANDLE ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ( changeType == LINKDB_STATUS_UPDATE_REMOVED ) || ( ( changeType == LINKDB_STATUS_UPDATE_STATEFLAGS ) &amp;&amp; ( !linkDB_Up( connHandle ) ) ) ) { GATTServApp_InitCharCfg ( connHandle, hhButton1Config); GATTServApp_InitCharCfg ( connHandle, hhButton2Config); } } }</code> </pre><br></div></div><br>  Profile is ready!  Now make sure that it works correctly. <br><br>  7. Communication with user application <br><br>  Tear off from the periphery and make this scenario: <br>  When setting the value of the PWM1 channel, the same value is passed to us via the variable Button1.  In the same way, we associate PWM2 and Button2. <br>  For this we need in the file SimpleBLEPerepherial: <br>  - Announce the callback profile, <br>  - Register it in the profile, <br>  - Implement the algorithm. <br><br>  Let's start.  We will declare the actual callback and the structure that will be registered for the execution of the callback.  At first glance, such a record may seem too complicated, but if we need to build a profile with several callbacks (for example, if we want to add a notification about reading a variable), this approach will more than justify itself.  Anyway, all stack stackbacks are built this way. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">habrProfileCB</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8 paramID)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HarbCBs_t HabrProfCBStruct = { habrProfileCB <span class="hljs-comment"><span class="hljs-comment">// Characteristic value change callback };</span></span></code> </pre><br>  In the body of the SimpleBLEPeripheral_Init function, we register this structure in the profile: <br><pre> <code class="cpp hljs">Habr_AddService(); Habr_RegisterAppCBs(&amp;HabrProfCBStruct);</code> </pre><br><br>  In the hh_WriteAttrCB function, we have already implemented the transmission to the callback of information about which characteristic was written.  It is only a matter of processing this information now: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">habrProfileCB</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint8 paramID)</span></span></span></span>{ uint8 u8buffer; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(paramID){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_CHANNEL1_PWM_ATTR: Habr_GetParameter(HH_CHANNEL1_PWM_ATTR, &amp;u8buffer); Habr_SetParameter(HH_BUTTON1_STATE_ATTR, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8), &amp;u8buffer); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HH_CHANNEL2_PWM_ATTR: Habr_GetParameter(HH_CHANNEL2_PWM_ATTR, &amp;u8buffer); Habr_SetParameter(HH_BUTTON2_STATE_ATTR, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uint8), &amp;u8buffer); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Finally, check that everything works.  It really works - you can be sure of the console: <br><img src="https://habrastorage.org/files/b9e/1f3/534/b9e1f3534cb04d10b233160ee1647f71.png"><br>  Integration with the controller's periphery is suggested for the reader to do it yourself. <br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/246089/">https://habr.com/ru/post/246089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246073/index.html">Xenserver 6.2 installation on soft raid vs HP ProLiant DL160 Gen8</a></li>
<li><a href="../246075/index.html">Updates on vds.menu</a></li>
<li><a href="../246077/index.html">Ruby and Postgis Time Zone Service</a></li>
<li><a href="../246081/index.html">About slow programming</a></li>
<li><a href="../246087/index.html">.NEXT in Moscow: how hardcore .NET-conference conquered the capital</a></li>
<li><a href="../246091/index.html">Working groups in OpenCL 2.0. Heterogeneous working groups</a></li>
<li><a href="../246093/index.html">Hacker's guide to neural networks. Schemes of real values. Patterns in the "reverse" stream. Example "One neuron"</a></li>
<li><a href="../246095/index.html">Monitoring Methods in DWDM Systems (Part 1)</a></li>
<li><a href="../246097/index.html">The problem of the "7th of January"</a></li>
<li><a href="../246099/index.html">OpenStack, Docker and Web Terminal, or how we do interactive exercises for learning Linux.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>