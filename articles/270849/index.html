<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of solving a typical OOP problem in the Go language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, an eye-catching article with the same name about the Haskell language was caught. The author suggested to the reader to follow the thought o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An example of solving a typical OOP problem in the Go language</h1><div class="post__text post__text-html js-mediator-article">  Recently, an eye-catching <a href="http://habrahabr.ru/post/263575/">article with the same name</a> about the Haskell language was caught.  The author suggested to the reader to follow the thought of the programmer solving the typical OOP problem but in Haskell.  In addition to the obvious benefits of expanding the reader‚Äôs perception that OOP is not ‚Äúclasses‚Äù and ‚Äúinheritance,‚Äù such articles are useful for understanding how to properly use the language.  I suggest the reader to solve the same problem, but in the Go language, in which the PLO is also implemented unusually. <br><a name="habracut"></a><br><h4>  Task </h4><br>  So, the original task looked like this: there are graphic primitives (figures) with different properties, but the same actions can be performed on each figure.  Primitives should be able to give information about themselves in a certain format, which a certain function will output to some output, for simplicity of an example - to stdout.  However, some primitives may be variations of others. <br><br>  The information output format, for example, a rectangle and a circle, should be like this: <br><blockquote>  paint rectangle, rect {left = 10, top = 20, right = 600, bottom = 400} <br>  paint circle, radius = 150 and center = (50,300) <br></blockquote><br>  In addition, primitives need to be able to merge into a uniform list. <br><br><h4>  Decision </h4><br><h5>  Structures and properties </h5><br>  Let's start with the obvious - with the declaration of primitives and their properties.  Structures are responsible for properties in Go, so we simply declare the required fields for the Rectangle and Circle primitives: <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rectangle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Left, Right, Top, Bottom <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Circle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X, Y, Radius <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> }</code> </pre> <br>  In Go, abbreviated entries in one line are not much welcomed - it is better to take each field to a separate line, but for such a simple example this is forgivable.  The type int64 is selected as base.  In the future, if you really need speed optimizations, you can choose the type best, based on a real task, say uint16, or try to change the structure so that field alignment is effectively used in memory, but do not forget that premature optimization is evil.  You need to do this only if you really need it.  For now, feel free to choose int64. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will write the names of the fields and methods with a capital letter, since this is not a library, but an executable program, and visibility outside the package is not important for us (in Go the name with a capital letter is an analogue of public, with a small one - private). <br><br><h5>  Interfaces and behavior </h5><br>  Further, by the definition of the original task, the primitives must be able to give information about themselves in a certain format and give the value of the area of ‚Äã‚Äãthe primitive.  How do we do this in Go if we don't have classes and a ‚Äúnormal OOP‚Äù? <br><br>  Here in Go, one does not even have to guess, since the definition of ‚Äúproperties‚Äù and ‚Äúbehavior‚Äù is very clearly separated in language.  <b>Properties are structures, behavior is interfaces.</b>  This simple and powerful concept immediately gives us the answer to what to do next.  We define the necessary interface with the necessary methods: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Figure <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Say() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Square() <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre><br>  The choice of the interface name (Figure) is dictated here by the original example and task, but <a href="https://golang.org/doc/effective_go.html">usually in Go interfaces</a> , especially with one method, are called with the suffix -er - Reader, Painter, Stringer, and so on.  In theory, the name should help understand the purpose of the interface and reflect its behavior.  But in this case, the Figure fits rather well and describes the essence of the ‚Äúfigure‚Äù or ‚Äúgraphic primitive‚Äù. <br><br><h5>  Methods </h5><br>  Now, in order for the Rectangle and Circle types to become "figures", they must satisfy the Figure interface, that is, the Say and Square methods must be defined for them.  Let's write them: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Rectangle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"rectangle, Rect {left=%d,top=%d,right=%d,bottom=%d)"</span></span>, r.Left, r.Top, r.Right, r.Bottom) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r Rectangle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.Abs(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((r.Right - r.Left) * (r.Top - r.Bottom))) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"circle, radius=%d and centre=(%d,%d)"</span></span>, c.Radius, cX, cY) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.Pi * math.Pow(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(c.Radius), <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>  What you should pay attention to is the receiver of the method, which can be a value (as now - ‚Äúc Circle‚Äù), or it can be a pointer "(c * Circle)".  The general rule here is - if the method should change the value of c or if Circle is a tremendous structure that takes up a lot of space in memory - then use a pointer.  In other cases, it will be cheaper and more efficient to transfer the value as a receiver method. <br><br>  More experienced gophers will notice that the Say method is exactly the same as the standard <a href="https://golang.org/pkg/fmt/">Stringer</a> interface that is used in the standard library, including the fmt package.  Therefore, you can rename Say to String, remove this method from the Figure interface in general, and then simply transfer an object of this type in the fmt function for output, but for the time being we will leave it for clarity and similarity with the original solution. <br><br><h5>  Constructors </h5><br>  Actually, everything - now you can create a Rectangle or Circle structure, initialize its values, save it in a slice ( <a href="http://blog.golang.org/go-slices-usage-and-internals">dynamic array in Go</a> ) of type [] Figure, and pass functions to the Figure and calling the Say or Square methods for further work with our graphic primitives.  For example, like this: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { figures := []Figure{ NewRectangle(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>), NewCircle(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>), } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, figure := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> figures { fmt.Println(figure.Say()) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(left, top, right, bottom </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rectangle</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Rectangle{ Left: left, Top: top, Right: right, Bottom: bottom, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Circle</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Circle{ X: x, Y: y, Radius: radius, } }</code> </pre><br>  The NewRectangle and NewCircle methods are simply constructor functions that create new values ‚Äã‚Äãof the desired type by initializing them.  This is a common practice in Go, such constructors can often still return an error if the constructor does more complicated things, then the signature looks something like this: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, radius </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Circle, error)</span></span></span></span> {...}</code> </pre><br>  You can also find signatures with the prefix Must instead of New - MustCircle (x, y, radius int64) * Circle - this usually means that the function will throw out a panic, in case of an error. <br><br><h5>  Delve into the subject </h5><br>  The observant reader may notice that we put the type variables * Rectangle and * Circle (that is, the pointer to Rectangle and Circle pointer) into the array of figures ([] Figure), although we have defined the methods for the value, not for the pointer (func (with Circle) Say () string).  But this is the correct code, <a href="https://golang.org/doc/effective_go.html">so Go works with the receivers of the methods</a> , simplifying the programmers life - if the type implements the interface, then the ‚Äúpointer to this type‚Äù also implements it.  It's logical, isn't it?  But in order not to force the programmer to dereference the pointer once again, to say to the compiler ‚Äúcall method‚Äù - the Go compiler will do it himself.  But the reverse side - which is also obvious - this will not work.  If the interface method is implemented for a ‚Äúpointer to type‚Äù, then a method call from a non-pointer variable will return a compilation error. <br><br>  To call the Say method on each primitive, we simply go through the slice using the range keyword and type the output of the Say () method.  It is important to understand that each variable of the interface type Figure contains inside information about a "specific" type.  A figure in a loop is always a type of Figure, and, at the same time, either Rectangle or Circle.  This is true for all cases when you work with interface types, even with empty interfaces (}. <br><br><h4>  Complicate the code </h4><br>  Further, the author complicates the task by adding a new ‚Äúrounded rectangle‚Äù primitive - RoundRectangle.  This is, in essence, the same primitive Rectangle, but with the additional property ‚Äúrounding radius‚Äù.  At the same time, in order to avoid duplication of the code, we must somehow reuse the ready-made Rectangle code. <br><br>  Again, Go gives an absolutely clear answer, how to do it - there are no ‚Äúmultiple ways to do it‚Äù.  And this answer is embedding, or ‚Äúembedding‚Äù one type into another.  Like this: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RoundRectangle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rectangle RoundRadius <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> }</code> </pre><br>  We define a new type structure that already contains all the properties of the Rectangle type plus one new one - RoundRadius.  Moreover, RoundRectangle already <b>automatically satisfies the Figure interface</b> , since it is satisfied by the embedded Rectangle.  But we can override functions, and call functions of the built-in type directly, if necessary.  Here's what it looks like: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRoundRectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(left, top, right, bottom, round </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RoundRectangle</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;RoundRectangle{ *NewRectangle(left, top, right, bottom), round, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r RoundRectangle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"round rectangle, %s and roundRadius=%d"</span></span>, r.Rectangle.Say(), r.RoundRadius) }</code> </pre><br>  The type constructor uses the NewRectangle constructor, dereferencing the pointer (since we embed Rectangle, not the Rectangle pointer), and the Say method calls r.Rectangle.Say () so that the output is exactly the same as for Rectangle, without duplicating the code . <br><br>  <a href="https://golang.org/doc/effective_go.html">Embedding types</a> (embedding) in Go is a very powerful tool, you can even embed interfaces into interfaces, but for our task it is not necessary.  I suggest the reader to get acquainted with this on their own. <br><br>  Now just add a new primitive to the slice: <br><pre> <code class="go hljs">figures := []Figure{ NewRectangle(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>), NewCircle(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>), NewRoundRectangle(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), }</code> </pre><br>  As you can see, it was quite simple, we did not think about how to do it, we just used the necessary language tools for their very direct purpose.  This allowed, without losing too much time, simply and quickly implement what we need. <br><br><h4>  Final edits </h4><br>  Although this code is a synthetic example, I will describe a couple of points that I would do next.  First of all - I will write comments to all methods, even to designers.  The latter, of course, is not necessary, but I like the idea that it is enough to write one line at a time to get documentation for the entire package using go doc, even if it is not needed yet, and in general, this is not a library, but a program being started.  But, if in the future such code will be separated into a separate package library, we automatically receive a documented package.  Even for now, the descriptions are banal, but it's not difficult for me to spend 5 seconds writing one line of text, but there is a feeling of ‚Äúfullness‚Äù of the code, and the linters (go vet) will not swear, which is also nice. <br><br>  Further, it seems logical to place the code into several separate files - the interface definition and main () are left in main.go, and for each primitive and its functions create separate files - circle.go, rectangle.go and roundrectangle.go.  Interface description, however, can also be put in a separate file. <br><br>  The final touch will be a <a href="https://github.com/alecthomas/gometalinter">run</a> through <a href="https://github.com/alecthomas/gometalinter">GoMetaLinter</a> - this is a package that runs in parallel all the linters and static code analyzers that can catch and prompt a lot of things, allowing you to make the code even better, cleaner and more readable.  If gometalinter did not display any messages, great, the code is clean enough. <br><br><div class="spoiler">  <b class="spoiler_title">Full code here</b> <div class="spoiler_text">  main.go: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Figure describes graphical primitive, which can Say // own information and return it's Square. type Figure interface { Say() string Square() float64 } func main() { figures := []Figure{ NewRectangle(10, 20, 600, 400), NewCircle(50, 300, 150), NewRoundRectangle(30, 40, 500, 200, 5), } for _, figure := range figures { fmt.Println(figure.Say()) } }</span></span></code> </pre><br>  rectangle.go: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"math"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Rectangle defines graphical primitive for drawing rectangles. type Rectangle struct { Left, Right, Top, Bottom int64 } // NewRectangle inits new Rectangle. func NewRectangle(left, top, right, bottom int64) *Rectangle { return &amp;Rectangle{ Left: left, Top: top, Right: right, Bottom: bottom, } } // Say returns rectangle details in special format. Implements Figure. func (r Rectangle) Say() string { return fmt.Sprintf("rectangle, Rect {left=%d,top=%d,right=%d,bottom=%d)", r.Left, r.Top, r.Right, r.Bottom) } // Square returns square of the rectangle. Implements Figure. func (r Rectangle) Square() float64 { return math.Abs(float64((r.Right - r.Left) * (r.Top - r.Bottom))) }</span></span></code> </pre><br>  circle.go: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"math"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Circle defines graphical primitive for drawing circles. type Circle struct { X, Y, Radius int64 } // NewCircle inits new Circle. func NewCircle(x, y, radius int64) *Circle { return &amp;Circle{ X: x, Y: y, Radius: radius, } } // Say returns circle details in special format. Implements Figure. func (c Circle) Say() string { return fmt.Sprintf("circle, radius=%d and centre=(%d,%d)", c.Radius, cX, cY) } // Square returns square of the circle. Implements Figure. func (c Circle) Square() float64 { return math.Pi * math.Pow(float64(c.Radius), 2) }</span></span></code> </pre><br>  roundrectangle.go: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// RoundRectangle defines graphical primitive for drawing rounded rectangles. type RoundRectangle struct { Rectangle RoundRadius int64 } // NewRoundRectangle inits new Round Rectangle and underlying Rectangle. func NewRoundRectangle(left, top, right, bottom, round int64) *RoundRectangle { return &amp;RoundRectangle{ *NewRectangle(left, top, right, bottom), round, } } // Say returns round rectangle details in special format. Implements Figure. func (r RoundRectangle) Say() string { return fmt.Sprintf("round rectangle, %s and roundRadius=%d", r.Rectangle.Say(), r.RoundRadius) }</span></span></code> </pre><br></div></div><br><h4>  findings </h4><br>  I hope the article helped to follow the train of thought, to draw attention to some aspects of Go.  Go is just that - straightforward and not conducive to wasting time thinking about what features to solve this or that problem.  Its simplicity and minimalism is to provide just what is needed to solve practical problems.  No Existential Quantization, just a carefully selected set of building blocks in the spirit of the Unix philosophy. <br><br>  In addition, I hope, for beginners, it has become more clear how to implement OOP without classes and inheritance.  On this topic there are a <a href="http://habrahabr.ru/post/243593/">couple of</a> <a href="http://habrahabr.ru/post/225907/">articles</a> on Habr√© in which the PLO in Go is examined in more detail, and even a small historical excursion into what the PLO really is. <br><br>  And, of course, it would be interesting to see the continuation answers to the original article in other new and not very languages.  For example, I was terribly interested to ‚Äúpeep‚Äù at the thought flow in the original article, and I am more than sure that this is the best way to learn and master new things.  Special thanks to the author of the original material (@KolodeznyDiver). </div><p>Source: <a href="https://habr.com/ru/post/270849/">https://habr.com/ru/post/270849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270839/index.html">Class Requests at InterSystems Cach√©</a></li>
<li><a href="../270841/index.html">Cisco ipsec tunnel without using crypto map</a></li>
<li><a href="../270843/index.html">Digest of the game industry: October</a></li>
<li><a href="../270845/index.html">How to make an elephant out of a fly</a></li>
<li><a href="../270847/index.html">JS Programming Contest: Email Filters</a></li>
<li><a href="../270851/index.html">Moscow Python Meetup ‚Ññ30</a></li>
<li><a href="../270855/index.html">Development of 2D games on Windows, Mac OS, Linux and Android without programming. Part 2</a></li>
<li><a href="../270857/index.html">Semantic technologies are simple and accessible by the example of pedigrees.</a></li>
<li><a href="../270859/index.html">Facebook helps to find out if everything is good with your friends in case of emergency</a></li>
<li><a href="../270861/index.html">Parallel development of desktop and computer games: how things got upside down in different versions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>