<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our simplified OpenGL on Rust - part 3 (rasterizer)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue my cycle of articles about the simplified analogue of OpenGL on Rust, in which 2 articles have already been published: 


1. We write our s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our simplified OpenGL on Rust - part 3 (rasterizer)</h1><div class="post__text post__text-html js-mediator-article">  I continue my cycle of articles about the simplified analogue of OpenGL on Rust, in which 2 articles have already been published: <br><ol><li>  <a href="http://habrahabr.ru/post/261629/">We write our simplified OpenGL on Rust - part 1 (draw a line)</a> </li><li>  <a href="http://habrahabr.ru/post/261739/">We write our simplified OpenGL on Rust - part 2 (wire rendering)</a> </li></ol><br>  I remind you that the basis of my series of articles is <a href="http://habrahabr.ru/post/248153/">‚ÄúA Short Course in Computer Graphics‚Äù</a> from <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> .  In previous articles, I did not go very fast.  In fact, for one article of the course I got 2 articles.  This is due to the fact that in my articles I focus mainly on the nuances of working with Rust, and when you just learn a new language, you come across a lot of new nuances for you, rather than when you have been programming on it for some time.  I think further Rust will throw less rakes, and I will align the ratio of my articles to the articles of the original course. <br><br>  In the meantime, I traditionally caution that since I am not a professional in Rust or in 3D graphics, but I study these things right in the course of writing this article, there may be a lot of nonsense in it.  If you notice this, write a comment - I will correct the error.  And of course there will be a lot of personal impressions in the article, with which you may turn out to disagree.  Constructive criticism is welcome. <br><br><img src="https://habrastorage.org/files/14c/67b/78d/14c67b78dc8f41eeb0d96ad27b7d065d.png"><br>  <i>What we get on the basis of this article</i> <br><a name="habracut"></a><br><h2>  Draw a model with triangles </h2><br>  Everything was just like that and there is nothing to describe.  The code can be found in the corresponding <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/97639eedf95871b3de4e3c8a4efe3ca06ff3f6be">snapshot of the repository</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">But the picture that I got.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/728/d1a/2a6/728d1a2a600f41d7860abd51cdc42934.png"><br></div></div><br><h2>  Flat toning </h2><br>  Since the vector and scalar product operations are used for rendering the light, we will need to expand our good old Vector3D class with new operators.  After reading a little about <a href="https://doc.rust-lang.org/book/operators-and-overloading.html">operator overloading</a> in Rust and reviewing the <a href="https://doc.rust-lang.org/std/ops/">list of available overloads</a> , I didn‚Äôt bother to write the following code: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3D</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> z: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Vector3D { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>, z: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) -&gt; Vector3D { Vector3D { x: x, y: y, z: z, } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">norm</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z).sqrt(); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, l: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) -&gt; Vector3D { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>*(l/<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.norm()); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"({},{},{})"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z) } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D) -&gt; Vector3D { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z + other.z} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Sub <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D) -&gt; Vector3D { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x - other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y - other.y, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z - other.z} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Mul <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*other.x + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*other.y + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*other.z; } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Mul&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) -&gt; Vector3D { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x * other, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y * other, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z * other} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> BitXor <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitxor</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, v: Vector3D) -&gt; Vector3D { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*vz-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*vy, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*vx-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*vz, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*vy-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*vx} } }</code> </pre> <br>  Verdict: operator overloading in Rust is done elementary. <br>  However, there was a difficulty with copying and moving.  It turns out in Rust all types can be either relocatable or replicable.  If the type is relocatable, then calling a method that accepts a variable of this type will make it inaccessible for all subsequent calls in the code, since the ownership of the variable will transfer to the called function.  That is, such code will cause an error: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = Vector3D::new(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x*<span class="hljs-number"><span class="hljs-number">2.0</span></span>; do_something_else(x); <span class="hljs-comment"><span class="hljs-comment">// error!</span></span></code> </pre><br>  The ownership of the variable x was transferred to the multiplication function, the variable was moved to the local variable of the function and deleted after exiting the function, because we did not return it back.  Actually this type of error occurred to me in the function <code>normalized() <br></code> <code>normalized() <br></code>  , because there, as you can see, <code>self</code> both to the right and left of the multiplication operator.  That is, we are trying to move it 2 times in a row.  By default, all user structures in Rust are relocatable. <br>  There are two solutions: either to make the variable replicable by default, or to make our operator implementations accept the reference, not the value.  I chose the 2nd option.  To implement it, it is enough to write before declaring the structure <code>#[derive(Copy, Clone)]</code> .  This tells the compiler that our structure is copied and it can be copied by simple byte duplication.  Now in calls like the one above, a copy of the data will be sent to our operators, and the original will remain available after the call.  It looks difficult, but due to this additional complication the compiler does not allow me to write code with memory errors (for example, <a href="http://www.webopedia.com/TERM/U/use-after-free.html">Use After Free</a> ). <br><br>  By the way, it turns out that there are no optional parameters in Rust and they cannot even be emulated in the usual way - by writing a function with the same name but a different set of arguments.  This can be circumvented in part <a href="http://stackoverflow.com/a/24937775">using types</a> .  But the method is not suitable for all cases and, in my opinion, is somewhat overly verbose.  In general, types in Rast leave the impression of some unnecessary verbosity.  I don‚Äôt know if it could have been done differently, without adding overhead to the runtime and without violating protection against memory errors, but the current implementation causes a keen desire to use characters as little as possible. <br><br>  Further the code of drawing of model with lighting was written without special adventures. <br><br><div class="spoiler">  <b class="spoiler_title">That's what he drew us</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9f6/0e9/d24/9f60e9d2476c4161b0c171a873f0162f.png"><br></div></div><br>  And here is the corresponding <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/871db85dadd734d2009b7af22e9cb39647637ab5">snapshot of the repository</a> . <br><br><h2>  Z-buffer </h2><br>  When I started programming Z-buffer, I realized that I still needed it so that my Vector3D class could be either with integer coordinates or with real coordinates.  Rolling up his sleeves, he took up his rewriting using generalized types and types.  Here the heat also has gone.  Did I already say that types in Rust have complex syntax?  See for yourself the code: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Sub; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Mul; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::BitXor; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> num::traits::NumCast; <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3D</span></span></span></span>&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> x: T, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> y: T, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> z: T, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Vector3D&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(x: T, y: T, z: T) -&gt; Vector3D&lt;T&gt; { Vector3D { x: x, y: y, z: z, } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: NumCast&gt; Vector3D&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to</span></span></span></span>&lt;V: NumCast&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Vector3D&lt;V&gt; { Vector3D { x: NumCast::from(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x).unwrap(), y: NumCast::from(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y).unwrap(), z: NumCast::from(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z).unwrap(), } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Vector3D&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">norm</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z).sqrt(); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, l: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) -&gt; Vector3D&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>*(l/<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.norm()); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: fmt::Display&gt; fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"({},{},{})"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z) } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: Add&lt;Output = T&gt;&gt; Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D&lt;T&gt;) -&gt; Vector3D&lt;T&gt; { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z + other.z} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: Sub&lt;Output = T&gt;&gt; Sub <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D&lt;T&gt;) -&gt; Vector3D&lt;T&gt; { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x - other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y - other.y, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z - other.z} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: Mul&lt;Output = T&gt; + Add&lt;Output = T&gt;&gt; Mul <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = T; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Vector3D&lt;T&gt;) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*other.x + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*other.y + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*other.z; } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: Mul&lt;Output = T&gt; + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt; Mul&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: T) -&gt; Vector3D&lt;T&gt; { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x * other, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y * other, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z * other} } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: Mul&lt;Output = T&gt; + Sub&lt;Output = T&gt; + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt; BitXor <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vector3D&lt;T&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Vector3D&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitxor</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, v: Vector3D&lt;T&gt;) -&gt; Vector3D&lt;T&gt; { Vector3D { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*vz-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*vy, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z*vx-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*vz, z: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x*vy-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y*vx} } }</code> </pre><br>  Briefly explain what is here and why.  After the colon for T, bindings are written: what types (traits) should T realize. For example, in the case of BitXor operation, T, as you see, is obliged to implement multiplication, subtraction and copying.  With the first two it is clear, in the function code we multiply and subtract, it is logical that this should be valid with T. Why copy, you ask?  The case in the situation already described above is that we cannot reuse a variable that has been moved to another function.  Therefore, we need to either rewrite the arithmetic of <code>x: self.y*vz-self.z*vy, y: self.z*vx-self.x*vz, z: self.x*vy-self.y*vx</code> using links or make sure that T is copyable.  All elementary types in Rust allow copying.  In general, we don‚Äôt expect anyone to try to put lists or files in <i>x, y, z</i> or something else complicated, so we‚Äôll like the copy option.  ‚ÄúStop, and what is this even for <code>&lt;Output = T&gt;</code> ?‚Äù, The attentive reader will ask.  And it will be right, because without this record the code will not work.  The fact is that Rust does not guarantee that the result of addition or multiplication will be of the same type as the operands.  Therefore, we additionally specify here that we need T, which implements multiplication in such a way that the result of multiplication is also of type T. Is it difficult?  I warned you. <br><br>  Special mention deserves the method to (), which allows you to convert a vector of one type to another.  For example, real to integer.  As you can see here, any type that implements NumCast can be converted to any type that implements NumCast.  All primitive types in Rust implement it, so that we are completely painless (not counting the time spent in order to learn about this type) got the type conversion for our vector. <br>  The remaining modifications were not too complicated.  As a result, I received a code that you can see in the corresponding <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/7f21dfb959b99d31e2fac5b601afe547d588b08b">snapshot of the repository</a> . <br><br><div class="spoiler">  <b class="spoiler_title">And what a picture he draws</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a1c/9e7/dc1/a1c9e7dc12a84dfeac04f2d31428804c.png"><br></div></div><br><h2>  TGA-canvas </h2><br>  Since for texturing we need to be able to read TGA files, since it is in them that the textures are stored in the models of interest to us, then it is time to return to what I missed at the very beginning of the cycle - reading TGA files.  And since we are still learning to read them, then why not also make an alternative implementation of Canvas, which writes the result in the TGA.  Naturally for this you need to make the Canvas abstract, and then prepare 2 of its implementation: SdlCanvas and TgaCanvas.  In Java, I would have made a base class from which I inherited 2 others.  In Rust, this functionality is implemented using impurities.  See for yourself the code.  Here is the Canvas admixture itself: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canvas</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbuffer</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xsize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ysize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_enter</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.xsize() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> || y &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ysize() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.canvas()[x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>][y <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>] = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">triangle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p0: Vector3D&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p1: Vector3D&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p2: Vector3D&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, color: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br>  Here is the SdlCanvas: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SdlCanvas</span></span></span></span> { sdl_context: Sdl, renderer: Renderer, canvas: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;&gt;, zbuffer: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt;, xsize: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ysize: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Canvas <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SdlCanvas { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; SdlCanvas { <span class="hljs-comment"><span class="hljs-comment">//... SdlCanvas { sdl_context: sdl_context, renderer: renderer, canvas: vec![vec![0;y];x], zbuffer: vec![vec![std::i32::MIN; y]; x], xsize: x, ysize: y, } } fn show(&amp;mut self) { let mut texture = self.renderer.create_texture_streaming(PixelFormatEnum::RGB24, (self.xsize as u32, self.ysize as u32)).unwrap(); // ... self.renderer.present(); } fn wait_for_enter(&amp;mut self) { //... } fn canvas(&amp;mut self) -&gt; &amp;mut Vec&lt;Vec&lt;u32&gt;&gt;{ &amp;mut self.canvas } fn zbuffer(&amp;mut self) -&gt; &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;{ &amp;mut self.zbuffer } fn xsize(&amp;self) -&gt; usize{ self.xsize } fn ysize(&amp;self) -&gt; usize{ self.ysize } }</span></span></code> </pre><br>  In order not to complicate the understanding of the essence, I deleted a part of the code that has no direct relation to the impurities and their implementation, replacing it with <code>// ...</code>  Those interested can see the full code in the corresponding <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/ad7e6a4bd60cea968293ef0ae299d07ddf321c6d">snapshot of the repository</a> .  As you can see, this all looks a bit unusual, but in fact it is very similar to our usual inheritance and interfaces.  By code size is not even much different.  The only moment impurities do not allow to require the presence of any variables in the structures.  So we had to create getters for some of the variables we need in a universal implementation and in SdlCanvas, in turn, to implement them.  The <a href="http://rustbyexample.com/trait.html">corresponding article Rust by Example</a> greatly helped in the implementation of the above. <br>  Now actually to read the pictures.  The first difficulty was to read the header of the TGA file.  In the original <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> code, this is done in a fairly simple, elegant code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push,1) struct TGA_Header { char idlength; char colormaptype; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... short width; short height; char bitsperpixel; char imagedescriptor; }; #pragma pack(pop) // ... TGA_Header header; in.read((char *)&amp;header, sizeof(header));</span></span></span></span></code> </pre><br>  However, it is also clear that this code is rather low-level.  We simply read an array of bytes from a file and put it at the address of our structure, which is previously declared to correspond to how all this data is placed in the file header.  Before that, we wrote mostly at a fairly high level.  Well, it is time to check how it behaves when applied as a low-level language.  In general, after all the research, we got this code: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HEADERSIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 18 = sizeof(TgaHeader) #[repr(C, packed)] struct TgaHeader { idlength: i8, colormaptype: i8, // ... width: i16, height: i16, bitsperpixel: i8, imagedescriptor: i8, } // ... let mut file = File::open(&amp;path).unwrap(); let mut header_bytes: [u8; HEADERSIZE] = [0; HEADERSIZE]; file.read(&amp;mut header_bytes); let header = unsafe { mem::transmute::&lt;[u8; HEADERSIZE], TgaHeader&gt;(header_bytes) };</span></span></code> </pre><br>  The preprocessor directive in front of the structure sets its storage method.  Usually the structure fields in Rust (and in C ++, by the way, too) are aligned according to the architecture.  For example, on my computer, a structure containing i8 and i16 would take 4 bytes, not 3. Because i8 would be aligned to occupy one two-byte cell.  In C ++, this works similarly.  This was described in detail by <a href="https://habrahabr.ru/users/k06a/" class="user_link">k06a</a> in his <a href="http://habrahabr.ru/post/142662/">article on this topic</a> .  In order for the data in the structure to follow byte by byte, without gaps, we asked <code>#[repr(C, packed)]</code> .  Thus, our structure is now located in memory as it was located in the harsh, ancient times when the TGA was invented.  In addition, here we use unsafe code.  It is understandable, the interpretation in the area in memory as a kind of structure without any checks completely breaks the idea of ‚Äã‚Äãstatic typing.  Fortunately, this code will most often work.  (but not always, there are still all sorts of nuances with <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">byte order</a> ) And of course you also noticed that I set the size of the buffer as a constant.  What about sizeof, you ask?  Well, it is in Rust, but it is <a href="http://stackoverflow.com/questions/26976104/rust-declare-array-with-constant-expression">not calculated as a constant expression</a> , but is considered at runtime.  The size of the array should be known at the compilation stage.  These are the pies. <br><br>  Next is the most interesting.  When I tried to learn how to read simple TGB-files like RGBA (4 bytes per pixel) without RLE compression, there was some kind of mystique.  My program processed a simple <a href="">image in</a> general, producing such a mess: <br><br><img src="https://habrastorage.org/files/190/5f7/177/1905f7177ff4409ba02a696eaeb4a4f3.png"><br><br>  Here is a <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/f69d346445219ba2b8fd65eb0e258d2befcda7aa">snapshot of the code</a> at this stage.  If you are interested, you can try to find a mistake in it yourself before continuing further reading the article.  It is somewhere in the file reading function: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(path: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; TgaCanvas{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = Path::new(path); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = BufReader::new(File::open(&amp;path).unwrap()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> header_bytes: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; HEADERSIZE] = [<span class="hljs-number"><span class="hljs-number">0</span></span>; HEADERSIZE]; file.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> header_bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> header = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { mem::transmute::&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; HEADERSIZE], TgaHeader&gt;(header_bytes) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xsize = header.width <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ysize = header.height <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; debug!(<span class="hljs-string"><span class="hljs-string">"read header: width = {}, height = {}"</span></span>, xsize, ysize); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bytespp = header.bitsperpixel&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>; debug!(<span class="hljs-string"><span class="hljs-string">"bytes per pixel - {}"</span></span>, bytespp); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>;ysize];xsize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> iy <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..ysize{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ix <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..xsize{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bytespp == <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>]; file.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intensity = bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; canvas[ix][iy] = intensity + intensity*<span class="hljs-number"><span class="hljs-number">256</span></span> + intensity*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bytespp == <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>]; file.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes); canvas[ix][iy] = bytes[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + bytes[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span> + bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bytespp == <span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]; file.read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> bytes); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ix == <span class="hljs-number"><span class="hljs-number">0</span></span> { debug!(<span class="hljs-string"><span class="hljs-string">"{} {} {} {}"</span></span>, bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>], bytes[<span class="hljs-number"><span class="hljs-number">1</span></span>], bytes[<span class="hljs-number"><span class="hljs-number">2</span></span>], bytes[<span class="hljs-number"><span class="hljs-number">3</span></span>]); } canvas[ix][iy] = bytes[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + ((bytes[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>)) + ((bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//debug!("{}", canvas[ix][iy]); } } debug!("{}", canvas[0][iy]); } TgaCanvas { canvas: canvas, zbuffer: vec![vec![std::i32::MIN; ysize]; xsize], xsize: xsize, ysize: ysize, } }</span></span></code> </pre><br>  What really <code>BufReader::new(File::open(&amp;path).unwrap());</code> that if you replace <code>BufReader::new(File::open(&amp;path).unwrap());</code>  on just <code>File::open(&amp;path).unwrap();</code>  , the bug was not shown.  I even thought that this is a bug in BufReader, because in theory it should only provide buffering, without interfering with the byte stream. <br><br><div class="spoiler">  <b class="spoiler_title">What was the mistake</b> <div class="spoiler_text">  It turns out this is a bit unexpected behavior of the <a href="http://doc.rust-lang.org/nightly/std/io/trait.Read.html">function read</a> in the standard library.  read () does not guarantee that <code>buffer.len()</code> bytes will be read, although this is often the case.  But not always.  In BufReader, the buffer ends and it returns as many bytes as it is left in it and, meanwhile, starts filling the buffer in the background again.  If I got the point right.  As a result, at some point, I skipped a few bytes and then the image was damaged.  This behavior on the part of read () is documented, but, in my opinion, violates the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25B5%25D0%25BD%25D1%258C%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2583%25D0%25B4%25D0%25B8%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">principle of least surprise</a> .  Although only I can not read <b>all the</b> documentation for the methods used ... <br></div></div><br>  Next issue with TGA-files was closed quickly.  The code with the final version of TgaCanvas, as always, can be seen in the <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/1b73b489424ae494470a0479d78a3c06a4574c86">snapshot of the repository</a> . <br><br><h2>  Textures </h2><br>  The trouble came from no waiting.  It turns out that in Rust it is simply impossible to concatenate strings and return the result as str (this is a primitive type - a string).  Str simply does not have a concatenation method.  The String has it, <s>but you cannot convert the String to str later.</s>  <b>UPDATE:</b> Everything under the spoiler is not true.  Saved here just for history.  Thanks to <a href="https://habrahabr.ru/users/googolplex/" class="user_link">Googolplex</a> for explaining my mistake to me in my <a href="http://habrahabr.ru/post/262235/">comment</a> . <div class="spoiler">  <b class="spoiler_title">Old text that I wrote without understanding</b> <div class="spoiler_text">  <a href="https://doc.rust-lang.org/std/string/struct.String.html">The corresponding as_str () method</a> is unstable.  Which means that you cannot use it in stable releases of Rust.  Actually there is a reasonable solution - to transfer file names as String, but not str.  Something like <code>new(file_path: &amp;String) -&gt; Model</code> , but the problem here is that then you have to write in all calls not <code>Model::new("african_head.obj");</code>  , and <code>Model::new("african_head.obj".to_string());</code>  .  I was offended by the language for this perversion and decided, in turn, also to pervert.  Here is my concatenation code: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> texture_path_string = file_path.rsplitn(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>).last().unwrap().to_string() + <span class="hljs-string"><span class="hljs-string">"_diffuse.tga"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> texture_path_str = texture_path_string.split(<span class="hljs-string"><span class="hljs-string">"*"</span></span>).next().unwrap();</code> </pre><br>  First, the actual concatenation using the methods of the class String, and then comes the conversion of String to str.  How?  It turns out the split () method of the String returns an iterator to the str collection.  Here is such a nonsense.  Normally, for some reason, str cannot be obtained from String, but if you strongly pervert ... In general, the language is still damp, since you have to use such a creepy hack to simply convert String to str.  A contest for the cutest hack to convert String to str is announced.  Write your options in the comments.  (note: you cannot use unstable feature or unsafe code). <br><br></div></div>  Then everything is quite trivial.  The result is a code that you can see in the <a href="https://github.com/cepreu2github/rust-3d-renderer/tree/84ab7a53363194cb6a40c6c428fce1f796d8e572">repository slice</a> .  It displays just the very same picture that you could observe in the introduction to the article. <br><br><h2>  Afterword </h2><br>  I think this is the last article of the cycle.  Initially, I set myself two goals: to study Rust and figure out how modern 3D graphics work.  With 3D graphics, I have not finished yet, but Rust is no longer for me an unfamiliar language that was about one and a half months ago.  Most of the recent "discoveries" concerning the language are just small nuances.  I haven‚Äôt found anything fundamentally new to me for several weeks.  So, in fact, I have nothing to write about in articles.  I also plan to add perspective distortions for the renderer, camera movements, maybe Guro's tinting and draw the typewriter from the 1st article, so those interested can still continue to monitor my progress in the <a href="https://github.com/cepreu2github/rust-3d-renderer">corresponding repository</a> .  Thanks to everyone who reads.  And special thanks to those who give useful comments. </div><p>Source: <a href="https://habr.com/ru/post/262235/">https://habr.com/ru/post/262235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262221/index.html">Customize the build of a Flex 4.14 project using flexmojos 7. *</a></li>
<li><a href="../262225/index.html">Using Lisp in Production</a></li>
<li><a href="../262229/index.html">Geolocation plus mobile communications and the updated AltegroCloud API</a></li>
<li><a href="../262231/index.html">We test Jet9 - fault-tolerant hosting sites with geographic optimization</a></li>
<li><a href="../262233/index.html">VirtualBox 5.0 release</a></li>
<li><a href="../262239/index.html">Critical way of rendering web pages</a></li>
<li><a href="../262241/index.html">Raspberry Pi as Steam Idle Machine</a></li>
<li><a href="../262243/index.html">Data Access Object (DAO). Class level</a></li>
<li><a href="../262245/index.html">Side View: IEEE754 Standard</a></li>
<li><a href="../262247/index.html">Instructions: How to create bots in Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>