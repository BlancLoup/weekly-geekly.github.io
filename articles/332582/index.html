<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yet another tutorial: launch dotnet core docker application on Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One cloudy summer day, after visiting the section from Avito on RIT2017, it suddenly dawned on me that the HYIP about the docker had not stopped in a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yet another tutorial: launch dotnet core docker application on Linux</h1><div class="post__text post__text-html js-mediator-article"> <abbr title="Picture To Attract Attention"><img src="https://habrastorage.org/web/e8c/c2e/6a6/e8cc2e6a6af54b6b85b61727a989ad83.png"><br></abbr> <br>  One cloudy summer day, after visiting the section from Avito on RIT2017, it suddenly dawned on me that the HYIP about the docker had not stopped in a couple of years and it was time, finally, to master it.  Dotnet core + C # was chosen as the test subject for packaging, since it has long been interesting to see what it is like to develop in C # for Linux. <br><br>  <i><b>Warning reader: The</b></i> article is aimed at completely new to the docker / dotnet core and was written mostly as a reminder for yourself.  I was inspired by the first 3 parts of the <a href="https://docs.docker.com/get-started">Docker Get Started Guide</a> and <a href="http://blog.scottlogic.com/2016/09/05/hosting-netcore-on-linux-with-docker.html">some blog post on english</a> .  Who is good with English, you can read them right away and in general it will be very similar.  If after all of the above, you have not yet decided to continue reading, then welcome under cat. <br><a name="habracut"></a><br>  <b>Prerequisites</b> <br><br>  So, we will need Linux itself (in my case it was Ubuntu 16.04 under VirtualBox on Windows 10), <a href="https://www.microsoft.com/net/core">dotnet core</a> , <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/">docker</a> , and also <a href="https://docs.docker.com/compose/install/">docker compose</a> , so that it would be more convenient to lift several containers at once. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      No special installation problems should arise.  At least, I did not have those. <br><br><div class="spoiler">  <b class="spoiler_title">Choosing a development environment</b> <div class="spoiler_text">  Formally, you can write at least in notepad and debug through logs or console messages, but since  I am somewhat spoiled, I still wanted to get a normal debugging and, preferably, also a normal refactoring. <br><br>  From what can under Linux, for myself I tried the Visual Studio Code and JetBrains Rider. <br><br>  <i>Visual studio code</i> <br>  What can I say - it works.  It is possible to debug, the syntax is highlighted, but it‚Äôs all very simple - the impression is left that this is a notepad with debugging options. <br><br>  <i>Rider</i> <br>  In essence, Idea, crossed with Resharper, is simple and clear, if you have worked with any IDE from JetBrains before.  Until recently, debug did not work under linux, but in the latest EAP build it was returned.  In general, for me the choice in favor of Rider was unequivocal.  Thank you JetBrains for their cool products. <br></div></div><br>  <b>Create a project</b> <br><br>  For educational purposes, we despise the <i>Create Project</i> buttons of various IDEs and make all the handles through the console. <br><br>  1. Go to the directory of our future project <br>  2. We'll see for the sake of interest what patterns we can use. <br><br><pre><code class="hljs pgsql">dotnet <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">all</span></span></code> </pre> <br>  3. Create a WebApi project <br><br><pre> <code class="hljs cs">dotnet <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webapi</code> </pre> <br>  4. Tighten dependencies <br><br><pre> <code class="hljs sql">dotnet <span class="hljs-keyword"><span class="hljs-keyword">restore</span></span></code> </pre> <br>  5. Run our application <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dotnet</span></span> run</code> </pre> <br>  6. Open <code>http://localhost:5000/api/values</code> and enjoy the work of C # code on Linux <br><br>  <b>Preparing an application for dockerization</b> <br><br>  Go to <code>Program.cs</code> and add in the host setup <br><br><pre> <code class="hljs pgsql">.UseUrls("http://*:5000") // <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> port <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> network interfaces</code> </pre><br>  In the end, you should get something like <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebHostBuilder() .UseKestrel() .UseContentRoot(Directory.GetCurrentDirectory()) .UseUrls(<span class="hljs-string"><span class="hljs-string">"http://*:5000"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// listen on port 5000 on all network interfaces .UseStartup&lt;Startup&gt;() .Build(); host.Run(); }</span></span></code> </pre><br>  This is necessary so that we can turn to the application inside the container. <br>  By default, <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel">Kestrel</a> , on which our application runs, listens to <code>http://localhost:5000</code> .  The problem is that localhost is a loopback interface and, when running an application in a container, is available only inside the container. <br><br>  Accordingly, having dotted the dotnet core application with the default setting of the url you are listening, you can then wonder for a long time why port forwarding does not work, and re-read your docker file in search of errors. <br><br><div class="spoiler">  <b class="spoiler_title">And you can add some functionality to the application.</b> <div class="spoiler_text">  <b>Passing parameters to the application</b> <br><br>  When I run the container, I would like to be able to pass parameters to the application. <br>  A quick googling showed that if we can do without an exotic type of access to the configuration service from inside the container, then you can use parameter passing through environment variables or replacing the config file. <br><br>  Well, we will pass through variable environments. <br><br>  Let's go to <code>Startup.cs publicpublic Startup(IHostingEnvironment env)</code> and see that the <code>AddEnvironmentVariables()</code> method is called in our <code>ConfigurationBuilder</code> . <br><br>  Actually all - now you can inject parameters from environment variables anywhere through DI. <br><br>  <b>Instance ID</b> <br><br>  When the instance instance starts, we will generate a new Guid and stick it in the IoC container to distribute to the suffering.  It is necessary, for example, to analyze logs from several service instances running in parallel. <br><br>  Everything is also pretty trivial - in the <code>ConfigurationBuilder</code> call: <br><br><pre> <code class="hljs cs"> .AddInMemoryCollection(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"InstanseId"</span></span>, Guid.NewGuid().ToString()} })</code> </pre><br>  After these two steps, <code>public Startup(IHostingEnvironment env)</code> will look something like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Startup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IHostingEnvironment env</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder() .SetBasePath(env.ContentRootPath) .AddJsonFile(<span class="hljs-string"><span class="hljs-string">"appsettings.json"</span></span>, optional: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, reloadOnChange: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .AddJsonFile(<span class="hljs-string"><span class="hljs-string">$"appsettings.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{env.EnvironmentName}</span></span></span><span class="hljs-string">.json"</span></span>, optional: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .AddInMemoryCollection(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"InstanseId"</span></span>, Guid.NewGuid().ToString()} }) .AddEnvironmentVariables(); Configuration = builder.Build(); }</code> </pre><br>  <b>A little about DI</b> <br><br>  It did not seem to me at all somewhat intuitive.  I didn‚Äôt dig deep, but nonetheless I‚Äôll give below a small example of how to throw the instance Id that we set at the start, and something from the environment variables (for example, the MyTestParam variable) to the controller. <br><br>  The first step is to create a class of settings - the field names must match the names of the configuration parameters that we want to inject. <br><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ValuesControllerSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MyTestParam { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> InstanseId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Next, go to <code>Startup.cs</code> and make changes to <code>ConfigureServices(IServiceCollection services)</code> <br><br><pre> <code class="hljs pgsql"> // This <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> gets <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the runtime. Use this <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> services <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the container. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> ConfigureServices(IServiceCollection services) { //  Ionfiguration //    ValuesControllerSettings services.Configure&lt;ValuesControllerSettings&gt;(<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> framework services. services.AddMvc(); }</code> </pre><br>  And the last step is going to our experimental and only <code>ValuesController</code> created by the machine <code>ValuesController</code> and write the injection through the constructor. <br><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ValuesControllerSettings _settings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValuesController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOptions&lt;ValuesControllerSettings&gt; settings</span></span></span><span class="hljs-function">)</span></span> { _settings = settings.Value; }</code> </pre><br>  not forgetting to add <code>using Microsoft.Extensions.Options;</code>  .  For the test, we override the response of any method you like to Get to return the parameters acquired by the controller, run, check ‚Üí profit. <br></div></div><br>  <b>We collect and run a docker image</b> <br><br>  1. First of all, we will get the binaries of our application for publication.  To do this, open the terminal, go to the project directory and call: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dotnet</span></span> publish</code> </pre> <br>  More details about the team can be read <a href="https://docs.microsoft.com/ru-ru/dotnet/core/tools/dotnet-publish">here</a> . <br><br>  Running this command without add.  the arguments from the project directory will be added to the dll for publication in <code>./bin/Debug/[framework]/publish</code> <br><br>  2. Actually we will put this daddy in our docker-image. <br><br>  To do this, create in the <code>Dockerfile</code> project <code>Dockerfile</code> and write something like this there: <br><br><pre> <code class="hljs pgsql">#      <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> microsoft/dotnet:runtime #        CMD WORKDIR /testapp #      (, dockerfile     )    <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> /bin/<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>/netcoreapp1<span class="hljs-number"><span class="hljs-number">.1</span></span>/publish /testapp #     <span class="hljs-number"><span class="hljs-number">5000</span></span>,   Kestrel EXPOSE <span class="hljs-number"><span class="hljs-number">5000</span></span> #       CMD ["dotnet",".dll"]</code> </pre><br>  3. After the <code>Dockerfile</code> written, run: <br><br><pre> <code class="hljs perl">docker build -t <span class="hljs-keyword"><span class="hljs-keyword">my</span></span>-cool-service:<span class="hljs-number"><span class="hljs-number">1.0</span></span> .</code> </pre> <br>  Where <i>my-cool-service</i> is the image name, and <i>1.0</i> is the tag indicating the version of our application. <br><br>  4. Now we‚Äôll check that the image of our service is in the repository: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> images</code> </pre> <br>  5. And finally, run our image: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">run</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-p</span></span> 5000<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:5000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">my-cool-service</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1.0</span></span></code> </pre> <br>  6. Open <code>http://localhost:5000/api/values</code> and enjoy the work of C # code on Linux in docker <br><br><div class="spoiler">  <b class="spoiler_title">Useful commands for working with docker</b> <div class="spoiler_text">  <b>View images in the local repository</b> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> images</code> </pre> <br>  <b>View running containers</b> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> ps</code> </pre> <br>  <b>Run container in <a href="https://docs.docker.com/edge/engine/reference/run/">detached mode</a></b> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> run   -d</code> </pre> <br>  <b>Get container information</b> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">docker</span></span> inspect ___</code> </pre> <br>  <b>Stop container</b> <br><pre> <code class="hljs sql">docker <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> ___</code> </pre> <br>  <b>Delete all containers and all images</b> <br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> containers docker rm $(docker ps -a -q) # <span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> images docker rmi $(docker images -q)</code> </pre><br></div></div><br>  <b>Little docker-compose last</b> <br><br>  <a href="https://docs.docker.com/compose/overview/">docker-compose is</a> useful for running groups of related containers.  As an example, I will give the development of a new microservice: let us write service3, who wants to communicate with already written and documented service1 and service2.  Service1 and service2 for development purposes can be conveniently and quickly raised from the repository via <code>docker-compose</code> . <br><br>  Let's write a simple <code>docker-compose.yml</code> , which will lift the container of our application and the container with nginx (I don‚Äôt know why we might need it locally when developing, but for example it will do) and configure the latter as a reverse proxy for our application. <br><br><pre> <code class="hljs pgsql">#   docker-compose  <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-string"><span class="hljs-string">'3.3'</span></span> services: #    service1: container_name: service1_container #    image: my-cool-service:<span class="hljs-number"><span class="hljs-number">1.0</span></span> #  ,      environment: - MyTestParam=DBForService1 # nginx <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>-proxy: container_name: <span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>-proxy image: nginx #      nginx ports: - "777:80" #  nginx   volumes: - ./test_nginx.conf:/etc/nginx/conf.d/<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.conf</code> </pre><br>  <code>docker-compose</code> picks up the local network at startup between the services described in the docker-compose file and distributes the hostname according to the service names.  This allows such services to communicate conveniently with each other.  Let's use this property and write a simple configuration file for nginx <br><br><pre> <code class="hljs pgsql">upstream myapp1 { <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> service1:<span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           docker-compose */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> / { proxy_pass http://myapp1; } }</code> </pre><br>  Call: <br><br><pre> <code class="hljs">docker-compose up</code> </pre><br>  from the directory with <code>docker-compose.yml</code> and get nginx, as a reverse proxy for our application.  It is recommended to imagine that here instead of nginx something is really useful and necessary for you.  For example, a database when running tests. <br><br>  <b>Conclusion</b> <br><br>  We created a <code>dotnet core</code> application on Linux, learned how to build and run a docker image for it, and also learned a little about <code>docker-compose</code> . <br><br>  I hope that this article will help someone to save some time on the way to master docker and / or dotnet core. <br><br>  <i>A request to the readers:</i> if anyone has experience with the <code>dotnet core</code> in production on Linux (not necessarily in the docker, although the docker is especially interesting), please share your impressions of use in the comments.  It will be especially interesting to hear about real problems and how they were solved. </div><p>Source: <a href="https://habr.com/ru/post/332582/">https://habr.com/ru/post/332582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332570/index.html">Moya - how to stop worrying about the network part and start living</a></li>
<li><a href="../332572/index.html">Is it time to use CSS Grid Layout?</a></li>
<li><a href="../332574/index.html">AliveScript - a programming language for children 12+</a></li>
<li><a href="../332578/index.html">Vs interface</a></li>
<li><a href="../332580/index.html">Protecting your site with ZIP bombs</a></li>
<li><a href="../332584/index.html">Making an image recognition service using TensorFlow Serving</a></li>
<li><a href="../332586/index.html">Fix bugs in 1988 style</a></li>
<li><a href="../332588/index.html">How to create your own metro</a></li>
<li><a href="../332594/index.html">Let's Encrypt will start issuing wildcard certificates in January 2018</a></li>
<li><a href="../332596/index.html">We remove and deposit cash at an ATM using a smartphone. World's first</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>