<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What every C programmer should know about Undefined Behavior. Part 1/3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 2 
 Part 3 

 People sometimes ask why code compiled into LLVM sometimes generates SIGTRAP signals when optimization has been enabled. R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What every C programmer should know about Undefined Behavior. Part 1/3</h1><div class="post__text post__text-html js-mediator-article">  <b>Part 1</b> <br>  <a href="https://habrahabr.ru/post/341144/">Part 2</a> <br>  <a href="https://habrahabr.ru/post/341154/">Part 3</a> <br><br>  People sometimes ask why code compiled into LLVM sometimes generates SIGTRAP signals when optimization has been enabled.  Rummaging, they discover that Clang has generated the ‚Äúud2‚Äù instruction (X86 code is implied) - the same that is generated by __builtin_trap ().  This article discusses several issues regarding the indefinite behavior of C code and how LLVM handles it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/fm/kb/sifmkb_11ismyizm4kt5oe-vix4.jpeg" alt="image"></div><br>  In this article (the first of the three) we will try to explain some of these questions so that you can better understand the related compromises and difficulties, and perhaps explore a little more dark sides of C. We will find out that C is not a ‚Äúhigh-level assembler‚Äù how many experienced C programmers (especially those who are focused on low level) prefer to think, and that C ++ and Objective-C directly inherited many such problems. <br><a name="habracut"></a><br><h3>  Introduction to Undefined Behavior </h3><br>  In programming languages ‚Äã‚ÄãLLVM IR and C, there is the concept of "undefined behavior."  Undefined behavior is a broad topic with many nuances.  The best introduction to the topic I found is a post <a href="https://blog.regehr.org/archives/213">on John Regger's blog</a> .  The brief point of this beautiful article is that many things that seem meaningful in C actually have undefined behavior, and this is the source of many bugs in programs.  Moreover, each construct with undefined behavior in C has a license to implement (compile and execute) code that can format your hard drive and do <a href="http://www.catb.org/jargon/html/N/nasal-demons.html">even worse things</a> completely unexpectedly.  And again, I strongly recommend reading <a href="https://blog.regehr.org/archives/213">John‚Äôs article</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Undefined behavior exists in C-like languages ‚Äã‚Äãfor the reason that C developers wanted it to be an extremely effective low-level programming language.  As opposed to it, languages ‚Äã‚Äãlike Java (and many other ‚Äúsafe‚Äù programming languages) avoid unspecified behavior because they want safe and reproducible, implementation-independent behavior and are willing to sacrifice performance to achieve this goal.  Although none of this is your goal, if you program in C, you really need to understand what unspecified behavior is. <br><br>  Before you dive into the details, it is worth recalling that allows the compiler to achieve high performance on a large range of C-applications, despite the fact that there is no magic bullet.  At the highest level, the compiler generates fast code due to the fact that it: a) implements the basic compilation algorithms, such as allocation of registers, scheduling, etc .;  b) uses many tweaks (such as peephole optimization, loop conversion, etc.), and applies them when it is beneficial;  c) removes redundant abstractions (appearing as a result of using macros, etc.), makes inline functions, deletes temporary objects in C ++, etc .;  d) and does not spoil anything.  Although any of the optimizations may look trivial, saving just one iteration in a critical cycle can speed up the work, for example, the codec, by 10% and save 10% of the power consumed. <br><br><h3>  Advantages of uncertain behavior in C, examples </h3><br>  Before diving into the dark side of indefinite behavior and behavior and LLVM policies, when used as a C compiler, I think it would be useful to look at a few specific cases of undefined behavior, and talk about how performance is achieved in each of these cases. better than safe languages ‚Äã‚Äãlike java.  You can look at this as an optimization, which can be done by a class of indefinite behavior, or as a deliverance from redundancy, which would be required if this class of cases were defined.  Although the compiler can eliminate some of these redundancies in some cases, in order to do this in a general form (for each case), it may require solving the ‚Äústop problem‚Äù and many other interesting problems. <br><br>  It should also be noted that both Clang and GCC define certain instances of behavior that Standard C leaves undefined.  The cases that I will describe are undefined both in accordance with the standard and are considered as undefined by both compilers in the default settings. <br><br>  <b>Using an uninitialized variable</b> : a widely known source of problems in C programs, and there are many tools for catching such errors: from compiler warnings to static and dynamic analyzers.  This increases performance, since it does not require initialization by zero of all variables that fall within the scope (as Java does).  For most scalar variables, this is very small redundancy, but initializing arrays on the stack and heap allocated memory can be quite expensive, especially if this memory is then completely overwritten. <br><br>  <b>Signed integer overflow</b> : if the type 'int' overflows (for example), the result is undefined.  For example, "INT_MAX + 1" is not guaranteed to be equal to INT_MIN.  This behavior makes possible a whole class of optimizations that are important in some cases.  For example, knowing that INT_MAX + 1 is undefined allows you to replace ‚ÄúX + 1&gt; X‚Äù with ‚Äútrue‚Äù.  Knowing that multiplication "cannot" lead to overflow (because it would lead to undefined behavior) allows you to replace "X * 2/2" with "X".  Although these examples seem trivial, they are often found after inline functions or macro deployment.  A more important optimization occurs for "&lt;=" in this cycle: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= N; ++i) { ... }</code> </pre> <br>  In this loop, the compiler may assume that the number of loop iterations will be exactly N + 1, if ‚Äúi‚Äù is not determined during an overflow, which allows a wide range of optimizations to be undertaken.  On the other hand, if a variable should definitely ‚Äúwrap up‚Äù during an overflow, then the compiler must assume that such a cycle can be infinite (what happens if N equals INT_MAX) - which will not allow many loop optimizations to be done.  This is especially true for 64-bit platforms in which the ‚Äúint‚Äù is often used for loop variables. <br><br>  For unsigned variables, it doesn‚Äôt cost anything to guarantee overflow modulo 2 (wrapping), and you can always use it.  To make a certain overflow of sign numbers will be worth the loss of such optimizations (for example, the general symptom of the problem, tons of sign extensions inside loops in 64-bit targets).  Both Clang and GCC allow the "-fwrapv" flag, which causes the compiler to treat sign overflow as defined (except for dividing INT_MIN by -1). <br><br>  <b>Shift by an amount greater than the width of the variable</b> : The shift of uint32_t by 32 or more bits is undefined.  According to my guesswork, this happened because the shift operation on different CPUs is done differently: for example, X86 cuts the 32-bit amount of the shift to 5 bits (that is, the shift by 32 bits is the same as 0 bits ), but PowerPC cuts the 32-bit amount of the shift to 6 bits (and the result of the shift to 32 bits is zero).  Because of these hardware differences, the behavior is not fully defined in the C language (that is, a 32-bit shift on PowerPC can format your hard drive, it is not guaranteed to give zero as a result).  The cost of eliminating such ambiguous behavior is that the compiler must generate additional operations (such as 'and') for the variable shift, which would make this operation twice as expensive on common CPUs. <br><br>  <b>Dereferencing wild pointers and accessing beyond the array</b> : Dereferencing an arbitrary pointer (such as NULL, a pointer to unallocated memory, etc.) and accessing an array with an output beyond its borders is a common bug in C applications, and needs clarification.  To eliminate this source of undefined behavior, a range check must be performed when accessing an array, and the ABI must be modified so that the range information accompanies each pointer that can be used in address arithmetic.  It would be extremely expensive for many numerical and other applications, and would break binary compatibility with all existing C libraries. <br><br>  <b>NULL pointer</b> dereferencing: in contrast to popular opinion, null pointer dereferencing in C is undefined.  It is not defined as a call to the ‚Äútrap‚Äù command, and if you make a page mmap at address 0, this will not lead to access to that page.  This is a violation of the rule that prohibits dereferencing wild pointers and using NULL as a watchdog value.  NULL pointer dereferencing is vague and allows for a wide range of optimizations: in contrast, Java forbids the compiler to move side effects operations between objects that cannot be considered by the optimizer as guaranteed non-zero.  This significantly worsens planning and other optimizations.  In C-like languages, NULL dereferencing ambiguity allows a large number of scalar optimizations, and to improve the result of deploying macros and inline functions. <br><br>  If you are using an LLVM-based compiler, you can dereference the "volatile" pointer to null and get an emergency stop, if that is what you want, since read and write operations of volatile objects are generally not optimized.  Currently, there is no flag that allows an arbitrary read operation from a pointer to NULL to be considered as a valid operation or to allow arbitrary read operations from a pointer, which is known to be zero. <br><br>  <b>Violation type rules</b> : A case of undefined behavior is the conversion of int * to float * followed by dereference (accessing ‚Äúint‚Äù as if it were a ‚Äúfloat‚Äù).  The C language requires this type of conversion to occur through memcpy: the use of pointer conversion is incorrect and the results are not defined.  There are quite a few nuances in these rules, and I don‚Äôt want to dive into the details here (there are exceptions for char *, vectors have special properties, associations work differently, etc.).  This behavior makes it possible for Type-Based Alias ‚Äã‚ÄãAnalysis (TBAA), used in a wide range of memory accessibility optimizations in the compiler, and can significantly improve the performance of the generated code.  For example, this rule allows clang to optimize such a function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *P; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; ++i) P[i] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br>  in "memset (p, 0, 40000)".  This optimization also allows you to take out a lot of read operations per cycle, optimize general subexpressions, etc.  This class of undefined behavior can be disabled with the -fno-strict-aliasing flag, which disables analysis.  When the flag is set, Clang will compile this cycle into 10,000 4-byte write operations (which is many times slower), because it must assume that each of these write operations changes the value of P, as in the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ P = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;P; <span class="hljs-comment"><span class="hljs-comment">// cast causes TBAA violation in zero_array. zero_array(); }</span></span></code> </pre> <br>  Such a violation of typing is rather unusual, so the Committee for Standardization decided that a significant performance gain is worth unexpected results with ‚Äúreasonable‚Äù type conversions.  It is worth noting that Java takes advantage of the optimization of type conversions without such flaws, because it does not contain unsafe pointer pointers as such. <br><br>  In any case, I hope that this has given you an understanding of how whole classes of optimizations become possible due to indefinite behavior in C. Of course, there are many other cases, including violations of follow points, such as ‚Äúfoo (i, ++ i ), Contests in multi-threaded programs, access violations, division by zero, etc. <br><br>  In the next post, we will discuss why indefinite behavior in C is a rather frightening thing if performance is not your only goal.  In the last post of the loop, we‚Äôll talk about how LLVM and Clang handle unspecified behavior. </div><p>Source: <a href="https://habr.com/ru/post/341048/">https://habr.com/ru/post/341048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341030/index.html">What is the difference between cool networkers and performing in public? 5 qualities that can be envied</a></li>
<li><a href="../341034/index.html">Harm of small functions</a></li>
<li><a href="../341042/index.html">Choose a file system independent of the OS</a></li>
<li><a href="../341044/index.html">Firebase + Angular Universal = impossible possible</a></li>
<li><a href="../341046/index.html">Mars IS transition to a single IT service provider</a></li>
<li><a href="../341050/index.html">Full cycle of creating a character model for the game</a></li>
<li><a href="../341056/index.html">Who is a fullstack designer</a></li>
<li><a href="../341058/index.html">JAVA 9. What's new?</a></li>
<li><a href="../341060/index.html">UX design: 50 things you probably forgot to do</a></li>
<li><a href="../341064/index.html">We optimize PropertyDrawer under Unity3d</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>