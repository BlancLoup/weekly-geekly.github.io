<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proactive Oracle database performance optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first thing we encounter when we talk about proactive optimization is that we don‚Äôt know what needs to be optimized. "Do this, I do not know what....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proactive Oracle database performance optimization</h1><div class="post__text post__text-html js-mediator-article">  The first thing we encounter when we talk about proactive optimization is that we don‚Äôt know what needs to be optimized.  "Do this, I do not know what." <br><br><ul><li>  No classic algorithm. </li><li>  The problem has not yet arisen (unknown), and one can only guess where it may be. </li><li>  We need to find some potential weaknesses in the system. </li><li>  Try to optimize the work of requests in these places. </li></ul><br><h3>  The main objectives of proactive optimization <br></h3><br>  The main tasks of proactive optimization are different from the tasks of reactive optimization and are as follows: <br><br><ul><li>  getting rid of bottlenecks in the database; </li><li>  decrease in database consumption. </li></ul><br>  The last moment is the most important.  In the case of reactive optimization, we do not have the task of reducing the consumption of resources as a whole, but only the task of reducing the response time of the functionality to the acceptable limits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  If you work with combat servers, then you have a good idea of ‚Äã‚Äãwhat performance incidents mean.  You need to drop everything and quickly solve the problem.  RNKO "Payment Center" LLC works with many agents, and for them it is very important that such problems be as small as possible.  Alexander Makarov on HighLoad ++ Siberia told what was done to significantly reduce the number of performance incidents.  Proactive optimization came to the rescue.  And why and how it is produced on the combat server, read below. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>About Speaker:</strong> Alexander Makarov ( <a href="https://habr.com/users/al_ig_makarov/" class="user_link">AL_IG_Makarov</a> ) Lead Administrator of Oracle Database OOO NSC ‚ÄúPayment Center‚Äù.  Despite the position, the administration, as such, is extremely limited, the main tasks are related to the maintenance of the complex and its development, in particular, the solution of performance problems. <br><br><h1>  Is optimization of the combat database proactive? <br></h1><br>  First, let's look at the terms that this report means by the words ‚Äúproactive optimization of performance‚Äù.  Sometimes you can meet the point of view that proactive optimization is when the analysis of problem areas is carried out before the application is launched.  For example, we find out that some queries do not work optimally, because there is not enough index or an inefficient algorithm is used in the query, and this work is done on test servers. <br><br>  Nevertheless, we in RNKO did this project <strong>on combat servers</strong> .  Many times I have heard: ‚ÄúHow so?  You do it on a combat server - it means that this is not a proactive optimization of performance! ‚ÄùHere we must remember the approach that is cultivated in ITIL.  From the point of view of ITIL, we have: <br><br><ul><li>  performance incidents are what have already happened; </li><li>  measures we take to prevent performance incidents from happening. </li></ul><br>  In this sense, our actions are proactive.  Despite the fact that we are solving a problem on the combat server, the problem itself has not yet arisen: the incident did not occur, we did not run and did not try to solve this problem in some short time. <br><br>  So, in this report, proactiveity means precisely <strong>proactivity in the sense of ITIL</strong> , we solve the problem before a performance incident occurs. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Starting point <br></h1><br>  RNKO "Payment Center" serves 2 major systems: <br><br><ul><li>  RBS-Retail Bank; </li><li>  CFT Bank. </li></ul><br>  The nature of the load on these systems is mixed (DSS + OLTP): there is something that works very quickly, there are reports, there are average loads. <br><br>  We were faced with the fact that not very often, but with a certain frequency, there were performance incidents.  Those who work with combat servers, imagine what it is.  This means that you need to give up everything and quickly solve the problem, because at this time the client cannot receive the service, something either does not work at all, or works very slowly. <br><br>  Since a lot of agents and clients are tied to our organization, this is very important for us.  If we are not able to quickly eliminate performance incidents, then our customers will suffer in one way or another.  For example, they will not be able to replenish a card or make a transfer.  Therefore, we wondered what could be done to get rid of even these infrequent performance incidents.  To work in a mode when it is necessary to drop everything and solve a problem is not quite right.  We use sprints and make a work plan for the sprint.  The presence of performance incidents is also a deviation from the work plan. <br><br>  Need to do something with this! <br><br><h1>  Optimization approaches <br></h1><br>  We thought and came to understand the technology of proactive optimization.  But before I talk about proactive optimization, I must say a few words about classical reactive optimization. <br><br><h2>  Reactive optimization <br></h2><br>  The script is simple, there is a combat server on which something happened: they started a report, clients receive extracts, at this time the current activity on the database is going on, and suddenly someone decided to update some voluminous reference book.  The system starts to slow down.  At this point, the client comes in and says: ‚ÄúI cannot do this and that‚Äù - we need to find the reason why he cannot do this. <br><br>  <strong>Classic algorithm of actions:</strong> <br><br><ol><li>  Reproduce the problem. </li><li>  Localize the problem area. </li><li>  Optimize problem space. </li></ol><br>  Within the framework of the reactive approach, the main task is not so much to find the root cause itself and eliminate it as to make the system work normally.  Elimination of the root causes can be addressed later.  The main thing is to quickly restore the server to work so that the client can get the service. <br><br><h3>  The main objectives of reactive optimization <br></h3><br>  There are two main goals for reactive optimization: <br><br>  1. <strong>Reduce response time</strong> . <br><br>  An action, for example, the receipt of a report, statement, transaction, must be carried out for some regular time.  It is necessary to make so that the time of receiving the service returns to acceptable for the client borders.  Maybe the service is a little slower than usual, but for the client it is permissible.  Then we consider that the performance incident has been resolved, and we start working on the root cause. <br><br>  2. <strong>The increase in the number of processed objects per unit of time during batch processing</strong> . <br><br>  When there is a batch transaction processing, you need to reduce the processing time for one object from the batch. <br><br>  <strong>Pros of a reactive approach:</strong> <br><br>  ‚óè <em>A variety of tools and techniques</em> is the main plus of the reactive approach. <br><br>  We can use the monitoring tools to understand what the problem is: there is not enough CPU, threads, memory, or the disk system has slipped, or the logs are being slowly processed.  There are a lot of tools and techniques for studying the current performance problem in the Oracle database. <br><br>  ‚óè <em>Desired response time</em> is another plus point. <br><br>  In the course of such work, we bring the situation to the permissible response time, that is, we do not try to reduce it to the minimum value, but reach a certain value and after this action we finish, because we consider that we have reached acceptable limits. <br><br>  <strong>Cons reactive approach:</strong> <br><br><ul><li>  <em>Performance incidents remain</em> - this is the biggest disadvantage of the reactive approach, because we cannot always reach the root cause.  She could have stayed away somewhere and lay somewhere deeper, despite the fact that we achieved acceptable performance. </li></ul><br>  And how to work with performance incidents, if they have not happened yet?  Let's try to formulate how to conduct proactive optimization to prevent such situations. <br><br><h2>  Proactive optimization <br></h2><br>  The first thing that we face is that it is not known what needs to be optimized.  "Do this, I do not know what." <br><br><ul><li>  No classic algorithm. </li><li>  The problem has not yet arisen (unknown), and one can only guess where it may be. </li><li>  We need to find some potential weaknesses in the system. </li><li>  Try to optimize the work of requests in these places. </li></ul><br><h3>  The main objectives of proactive optimization <br></h3><br>  The main tasks of proactive optimization are different from the tasks of reactive optimization and are as follows: <br><br><ul><li>  getting rid of bottlenecks in the database; </li><li>  decrease in database consumption. </li></ul><br>  The last moment is the most important.  In the case of reactive optimization, we do not have the task of reducing the consumption of resources as a whole, but only the task of reducing the response time of the functionality to the acceptable limits. <br><br><h3>  How to find bottlenecks in the database? <br></h3><br>  When we begin to think about this problem, immediately there are many subtasks.  Need to hold: <br><br><ul><li>  load testing on the CPU; </li><li>  load testing by read / write; </li><li>  load testing by the number of active sessions; </li><li>  load testing on ... etc. </li></ul><br>  If we try to simulate these problems on the test complex, we can face the fact that the problem that has arisen on the test server has nothing to do with the combat one.  The reasons for this are many, starting with the fact that test servers are usually weaker.  It is good if there is an opportunity to make a test server an exact copy of the combat one, but this does not guarantee that the load will be reproduced in the same way, because you need to accurately reproduce user activity and many more different factors that affect the final load.  If you try to simulate this situation, then, by and large, no one guarantees that the exact same thing that happens on the battle server will be reproduced. <br><br>  If in one case the problem arose because the new registry came, then in the other it may arise due to the fact that the user launched a huge report doing a large sort, due to which the temporary tablespace (temporary tablespace) was filled, and consequence, the system began to slow down.  That is, the reasons may be different, and it is not always possible to predict them.  Therefore, <strong>we have abandoned attempts to search for bottlenecks on test servers</strong> almost from the very beginning.  We were repelled only from the combat server and from what was happening on it. <br><br>  What to do in this case?  Let's try to understand what resources in the first place, most likely, will be missed. <br><br><h3>  Reducing database resource consumption <br></h3><br>  Based on the industrial complexes we have at our disposal, the <strong>most frequent lack of resources is observed in disk readings and CPU</strong> .  Therefore, first of all, we will look for weak spots in these areas. <br><br>  The second important question: how to search for something? <br>  The question is very non-trivial.  We use Oracle Enterprise Edition with the Diagnostic Pack option and have found such a tool for ourselves - <b>AWR reports</b> (in other editions of Oracle, you can use <b>STATSPACK reports</b> ).  In PostgreSQL there is an analogue - pgstatspack, there is <a href="https://github.com/zubkov-andrei/pg_profile">pg_profile of</a> Andrei Zubkov.  The last product, as I understand it, appeared and began to develop only last year.  For MySQL, I could not find similar tools, but I am not a MySQL specialist. <br><br>  The approach itself is not tied to any particular kind of database.  If there is an opportunity to get information on the system load from some report, then using the methodology I‚Äôm going to talk about now, you can perform work on proactive optimization <strong>on any base</strong> . <br><br><h3>  <strong>Optimization of top 5 operations</strong> <br></h3><br>  The technology of proactive optimization that we have developed and use in the NSCA ‚ÄúPayment Center‚Äù consists of four stages. <br><br>  <strong>Step 1. Get the AWR report for the longest possible period.</strong> <br><br>  The longest period of time is needed to average the load on different days of the week, as sometimes it is very different.  For example, RBS-Retail Bank on Tuesday received registers for the last week, they begin to be processed, and all day we have a load above the average of about 2-3 times.  On other days, the load is less. <br><br>  If it is known that the system has some specificity - some days have more load, some days - less, then reports need to be received separately for these periods and work with them separately if we want to optimize specific time intervals .  If you need to optimize the overall situation on the server, you can get a large report for the month, and see what really consumes server resources. <br><br>  Sometimes there are very unexpected situations.  For example, in the case of CFT-Bank, a request that checks the report server queue may fall into the top-10.  Moreover, this request is official and does not execute any business logic, but only checks whether there is a report for execution or not. <br><br>  <strong>Stage 2. We look at sections:</strong> <br><br><ul><li>  SQL ordered by Elapsed Time - SQL queries sorted by execution time; </li><li>  SQL ordered by CPU Time - by CPU usage; </li><li>  SQL ordered by Gets - by logical reads; </li><li>  SQL ordered by Reads - for physical reads. </li></ul><br>  The remaining SQL sections of ordered by are examined as needed. <br><br>  <strong>Step 3. Determine the parent operations and queries dependent on them.</strong> <br><br>  The AWR report has separate sections where, depending on the version of Oracle, 15 or more top queries are shown in each of these sections.  But these Oracle queries are mixed in the AWR report. <br>  For example, there is a parent operation, inside it there can be 3 top queries.  Oracle in the AWR report will show both the parent operation and all these 3 queries.  Therefore, it is necessary to make an analysis of this list and see which operations specific requests belong to, group them. <br><br>  <strong>Stage 4. We optimize the top 5 operations.</strong> <br><br>  After such a grouping, the output is a list of operations from which you can choose the most difficult.  We are limited to 5 operations (not requests, but operations).  If the system is more complex, then you can take more. <br><br><h3>  Typical query design errors <br></h3><br>  During the application of this technique, we have compiled a small list of typical design errors.  Some errors are so simple that it seems that they can not be. <br><br>  ‚óè <strong>Missing index ‚Üí ‚Äã‚ÄãFull scan</strong> <br>  There are very incident cases, for example, with the absence of an index on the combat scheme.  We had a concrete example, when the query worked for a long time quickly without an index.  But there was a full scan, and as the size of the table gradually grew, the query began to work more slowly, and it took a little more time from quarter to quarter.  In the end, we paid attention to it and it turned out that the index is not there. <br><br>  ‚óè <strong>Large sample ‚Üí Full scan</strong> <br>  The second typical mistake is a large sample of data - a classic case of a full scan.  Everyone knows that a full scan should be used only when it is truly justified.  Sometimes there are cases when you get a full scan where you could do without it, for example, if you transfer the filtering conditions from the pl / sql-code to the query. <br><br>  ‚óè <strong>Inefficient index ‚Üí ‚Äã‚ÄãLong INDEX RANGE SCAN</strong> <br>  Perhaps this is even the most common mistake, about which for some reason they say very little, the so-called inefficient index (long index scan, long INDEX RANGE SCAN).  For example, we have a table by registry.  In the request, we are trying to find all the registries of this agent, and ultimately add some filtering condition, for example, for a certain period, or with a certain number, or a specific client.  In such situations, the index is usually built only across the "agent" field for reasons of universality of use.  The result is the following picture: in the first year of work, say, the agent had 100 entries in this table, next year there were 1,000, in a year there could be 10,000 entries.  Some time passes, these records become 100,000. Obviously, the request starts to work slowly, because not only the agent identifier itself should be added to the request, but also some additional filter, in this case by date.  Otherwise it will turn out that the sample size will increase from year to year as the number of registries for this agent grows.  This problem must be solved at the index level.  If the data becomes too much, then you should already think in the direction of partitioning. <br><br>  ‚óè <strong>Unnecessary distributive code branches</strong> <br>  This is also a curious case, but, nevertheless, it happens.  We look in the top queries, and we see there some strange queries.  We come to the developers and say: "We found some queries, let's look at it and see what can be done with this."  The developer thinks about it, then comes after a while and says: ‚ÄúIn your system, this branch of the code should not be.  You do not use this functionality. "  Then the developer recommends enabling some special settings to work around this section of code. <br><br><h3>  Examples from practice <br></h3><br>  Now I would like to consider two examples from our real practice.  When we deal with the top queries, of course, we first of all think that there must be something megatey, nontrivial, with complex operations.  In fact, this is not always the case.  Sometimes there are cases when very simple queries get to the top of operations. <br><br><h4>  Example 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  In this example, the query is from just two tables, and these are not heavy tables ‚Äî just a few million entries.  It would seem, what is easier?  However, the request hit the top. <br><br>  Let's try to figure out what's wrong with him. <br><br>  Below is a picture of Enterprise Manager Cloud Control - data on the statistics of this query (Oracle has such a tool).  It can be seen that there is a regular load on this request (the upper graph).  The number 1 on the side indicates that on average, no more than one session is working.  The green diagram shows that the <strong>query uses only the CPU</strong> , which is doubly interesting. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Let's try to figure out what is happening here? <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Above table with statistics on request.  Almost 700 thousand launches - this will not surprise anyone.  But the time interval from First Load Time December 15th to Last Load Time December 22nd (see previous image) is one week.  If you count the number of starts per second, it turns out that the <strong>request is on average every second</strong> . <br><br>  We look further.  Request execution time 0.93 seconds, i.e.  less than a second, that's wonderful.  You can be happy - the request is not heavy.  Nevertheless, he hit the top, it means consumes a lot of resources.  Where does it consume a lot of resources? <br><br>  The table has a line on logical reads.  We see that for one launch it requires almost 8 thousand blocks (usually 1 block is 8 KB).  It turns out that the request, working once per second, loads approximately 64 MB of data from memory.  Something is not right here, you need to understand. <br><br>  Let's see the plan: there is a full scan.  Well, let's go further. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  In the rnko_dep_reestr_in_oper table, there are only 5 million lines and their average line length is 150 bytes.  But it turned out that there is not enough index for the field that is connecting - the subquery connects to the request through the ean_rnko field, for which there is no index! <br><br>  Moreover, even if it appears, in fact, the situation will not be very good.  A long index scan will occur (long INDEX RANGE SCAN).  ean_rnko is an internal agent identifier.  Registers on the agent will accumulate, and every year the amount of data that this query will select will increase, and the query will slow down. <br><br>  <strong>Solution:</strong> create an index on the ean_rnko and date_reg fields, ask the developers to limit the scanning depth by date in this query.  Then you can at least to some extent guarantee that the query performance will remain approximately at the same boundaries, since the sample size will be limited to a fixed time interval and you will not need to read the entire table.  This is a very important point, look what happened. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  After optimization, the operating time was less than a hundredth of a second (it was 0.93), the number of blocks was on average 8.5 - less than 1000 times than it was. <br><br><h4>  Example 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  I started the story by saying that usually something difficult is expected in the top queries.  Above is an example of a ‚Äúcomplex‚Äù query that goes to one table (!), And it also hit the top of queries :) There is an index on the ID_PROCESSING field! <br>  There are 3 IS NULL conditions in this query, and, as we know, such conditions are not indexed (you cannot use the index in this case).  Plus, there are only two conditions of the equality type (by ID_PROCESSING and STATUS). <br><br>  Probably, a developer who would look at this request would first of all suggest making an index on ID_PROCESSING and STATUS.  But given the amount of data that will be selected (there will be a lot of them), this decision does not work. <br><br>  However, the request consumes a lot of resources, which means that you need to do something to make it work faster.  Let's try to understand the reasons. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  The above statistics are for 1 day, from which it can be seen that the query runs every 5 minutes.  The main resource consumption is CPU and disk read.  Below on the graph with the statistics of the number of launches of the request, it is clear that, in general, everything is fine - the number of launches does not change much over time - a fairly stable situation. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  And if you look further, it can be seen that the query's working time sometimes changes quite strongly - several times, which is already significant. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Let's understand further. <br><br>  Oracle Enterprise Manager has a SQL-Monitoring utility.  This utility can be viewed in real time consumption request resources. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Above report for problem query.  First of all, we should be interested in the fact that INDEX RANGE SCAN (bottom line) in the Actual Rows column shows 17 million lines.  Probably worth thinking about. <br><br>  If you look further at the implementation plan, it turns out that after the next paragraph of the plan, out of these 17 million lines, only 1705 remain. The question is, why was 17 million chosen?  In the final sample, approximately 0.01% remained, that is <strong>, the obviously ineffective, unnecessary work was performed</strong> .  Moreover, this work is done every 5 minutes.  Here is the problem!  Therefore, this query is in the top queries. <br><br>  Let's try to solve this non-trivial problem.  The index, which suggests itself in the first place, is ineffective, so you need to come up with something tricky and defeat the IS NULL conditions. <br><br><h4>  New index <br></h4><br>  We conferred with the developers, thought, and came to this solution: we made a functional index, in which there is an ID_PROCESSING column, which was equal to the query condition, and all the other fields included this function as arguments: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  This deterministic function, that is, on the same set of parameters, always produces the same answer.  We have made it so that this function actually produces always one value ‚Äî in this case, ‚ÄúU‚Äù.  When all of these conditions are met, a ‚ÄúU‚Äù is issued; when not, NULL.  Such a functional index makes it possible to effectively filter data. <br><br>  The application of this index led to the following result: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Here one column is one snapshot, they are made every half hour of the database operation.  We achieved our goal and this index turned out to be really effective.  Let's see the quantitative characteristics: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Average statistics for the request <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>BEFORE</strong> <br><br></td><td width="110">  <strong>AFTER</strong> <br><br></td></tr><tr><td width="174">  Elapsed Time, sec <br><br></td><td width="124">  143.21 <br><br></td><td width="110">  60.7 <br><br></td></tr><tr><td width="174">  CPU Time, sec <br><br></td><td width="124">  33.23 <br><br></td><td width="110">  45.38 <br><br></td></tr><tr><td width="174">  Buffer Gets, block <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Disk Reads, block <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br>  Operating time decreased 2.5 times, and resource consumption (Buffer Gets) - about 4. The number of data blocks read from the disk has decreased very significantly. <br><br><h3>  Results of applying proactive optimization <br></h3><br>  We got: <br><br><ul><li>  reducing the load on the database; </li><li>  increase the stability of the database; </li><li>  significant reduction in incidents of software performance. </li></ul><br>  <strong>Performance incidents decreased 10 times</strong> .  This is a subjective value, before the incidents occurred at the RBS-Retail Bank complex 1‚Äì2 times a month steadily, and now we have practically forgotten about them. <br><br>  Then the question arises - and where does software performance incidents?  We did not deal with them directly? <br><br>  Let's return to the last schedule.  If you remember, there was a full scan, it was required to store in memory a large number of blocks.  Since the request was executed regularly, all these blocks were stored in the Oracle cache.  In this case, it turns out that if a high load occurs in the database at this time, for example, someone will actively use the memory, a cache will be needed to store data blocks.  Thus, part of the data for our request will be pushed, and therefore, will have to do physical readings.  If you do physical readings, the query time will immediately increase enormously. <br><br>  Logical reading is working with memory, it happens quickly, and any access to the disk is slow (if you look at the time, milliseconds).  If you're lucky, and in the cache of the operating system or in the cache of the array there is this data, it will still be dozens of microseconds.  Reading from the cache of Oracle itself is much faster. <br><br>  When we got rid of the full scan, there was no need to keep such a large number of blocks in the cache (Buffer Cache).  When there is a shortage of these resources, the query is more or less stable.  No longer observed such large bursts, which were with the old index. <br><br>  <strong>Results on proactive optimization:</strong> <br><br><ul><li>  Initial query optimization should be performed on testing servers, look at how queries and their business logic work, so as not to do anything extra.  These works remain. </li><li>  But periodically, once every few months, it makes sense to remove the reports on the full load from the server, search for top queries and operations in the database and optimize them. </li></ul><br>  <strong>There are a lot of tools for obtaining statistical data in the Oracle database:</strong> <br><br><ul><li>  AWR Report (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (SQL Details); </li><li>  SQL Details Active Report (DBMS_PERF.report_sql); </li><li>  SQL Monitoring (tab in EMCC); </li><li>  SQL Monitoring Report (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Some of these tools work in the console, that is, they are not tied to Enterprise Manager. <br><br><div class="spoiler">  <b class="spoiler_title">Oracle Performance Examples for Statistical Data Collection</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  The upper chart shows how many sessions are working with this request. </li><li>  The left block shows where this request is launched from, in which modules it is located. </li><li>  Bottom left - information on the use of the shared-pool. </li><li>  The diagram on the right shows wait events that are in the system.  In this case, it is only the CPU. </li><li>  Bottom right - the most interesting - a plate with quality characteristics that are most important when analyzing performance problems. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring shows how it all looks in real time (where the green gear is spinning, the query is working now). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  The above is the internal contents of the SQL-Monitoring report.  It shows in real time which line of the query it performs and how many rows it reads (column Actual Rows).  In this case, INDEX RANGE SCAN has already read 5 million. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  SQL Monitoring Report text tool in which there is a piece of information (not all). <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonus: the</strong> specialists of NNKO ‚ÄúPayment Center‚Äù and CFT were well prepared for the conference in Novosibirsk, made several useful presentations, and also organized a real outbound radio.  Two days later, experts, speakers, and organizers visited the radio of the CFT radio.  You can move from the Siberian summer by including records, here are the links to the blocks: <a href="https://vk.com/itevents_cft%3Fw%3Dwall-87252699_315">Kubernetes: pros and cons</a> ;  <a href="https://vk.com/itevents_cft%3Fw%3Dwall-87252699_310">Data Science &amp; Machine Learning</a> ;  <a href="https://vk.com/itevents_cft%3Fw%3Dwall-87252699_317">DevOps</a> . <br><br><blockquote>  At HighLoad ++ in Moscow, which is already 8 and 9 November, there will be even more interesting.  The <a href="http://www.highload.ru/moscow/2018/schedule">program</a> includes reports on all aspects of work on high-loaded projects, master classes, meetings and events from <a href="http://www.highload.ru/moscow/2018/partners">partners</a> , who will share expert advice and find something to surprise.  We will definitely write and let you know about the most interesting things in the <a href="http://eepurl.com/VYVaf">mailing list</a> , <a href="http://eepurl.com/VYVaf">get</a> connected! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/428491/">https://habr.com/ru/post/428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428477/index.html">For those who choose a firewall</a></li>
<li><a href="../428481/index.html">Contracts in digital: a brief guide for non-lawyers</a></li>
<li><a href="../428485/index.html">People are most annoyed by irrelevant advertising and the use of gadgets in public</a></li>
<li><a href="../428487/index.html">How good Ruby on Rails is and how it speeds up development</a></li>
<li><a href="../428489/index.html">Subtleties and thick icons. Sketch pro, rendering features and game with thick lines</a></li>
<li><a href="../428493/index.html">Git subrepo</a></li>
<li><a href="../428495/index.html">How I did a football simulator for 13 years</a></li>
<li><a href="../428497/index.html">Customizable Noolite SUF-1-300 wireless dimmer</a></li>
<li><a href="../428499/index.html">Creepy blue giants can reveal the secrets of the evolution of stars</a></li>
<li><a href="../428501/index.html">DartUP: the first Russian-language conference on Dart and Flutter on December 1 in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>