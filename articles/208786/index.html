<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Packet crafting as it is</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Packetting or packet crafting is a technique that allows network engineers or pentesters to explore networks, check firewall rules and find vulnerabil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Packet crafting as it is</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/54a/ae8/263/54aae82630a275c10eb326c63e3fb3c5.jpg"><br><br>  Packetting or packet crafting is a technique that allows network engineers or pentesters to explore networks, check firewall rules and find vulnerabilities. <br>  This is usually done manually by sending packets to various devices on the network. <br>  The target could be a firewall, intrusion detection system (IDS), routers, and any other network members. <br>  Creating packages manually does not mean that you need to write code in any high-level programming language, you can use a ready-made tool, for example, Scapy. <br><br>  Scapy is one of the best, if not the best, tool for creating packages manually. <br>  The utility is written using the Python language, the author is Philippe Biondi. <br>  The utility of the utility is almost endless - it‚Äôs building packages, then sending them to the network, capturing packages, reading them from a previously saved dump, and exploring the network, and much more. <br>  All this can be done both online and by creating scripts. <br>  With Scapy, you can scan, trace, research, attack, and discover hosts on a network. <br>  Scapy provides an environment or even a framework similar to Wireshark, only without a nice graphical shell. <br>  The utility is developed for UNIX-like operating systems, but nevertheless, some manage to run it in the Windows environment. <br>  This utility can also interact with other programs: for visual decoding of packets, you can connect the same Wireshark, for drawing graphs - GnuPlot and Vpython. <br>  To work, you need superuser rights (root, UID 0), since this is a fairly low-level utility and works directly with the network card. <br>  And what is important, to work with this utility will not require deep knowledge of programming in Python. <br><a name="habracut"></a><br><h1>  Getting started </h1><br>  Official site of the project - <a href="http://www.secdev.org/projects/scapy/">www.secdev.org/projects/scapy</a> <br>  The installation can be done in various ways, for example <b>apt-get install <i>python-scapy</i></b> , in the case of Debian-based distributions. <br>  You can also just download the latest version from the developers site: <br> <code># cd /tmp <br> # wget scapy.net <br> # unzip scapy-latest.zip <br> # cd scapy-2.* <br> # sudo python setup.py install</code> <br>  After that, the launch takes place directly with the <b>scapy</b> command. <br>  The screen will display something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/7e8/ffc/548/7e8ffc54826d7b55af62175c8f008636.png"><br><br>  We see a standard prompt for input, all actions will be performed online. <br>  The output is a combination of <b>Ctrl + D</b> , or by typing the function <b>exit ()</b> . <br><br><h1>  We study the tool </h1><br>  In fact, Scapy is very different from the usual utilities.  It works in text mode, but any interaction is carried out not through the usual keys and command line parameters, but through the Python interpreter. <br>  Such an approach may initially seem somewhat inconvenient and unusual, but with time and with practice comes the understanding that this was the right decision and that it is really convenient. <br><br>  First, we will look at the supported protocols, for this we call the <b>ls ()</b> function. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/6b4/369/3906b436948d737126c4fbca81e8c9b0.png"><br><br>  More than 300 various protocols with which it is possible to work, including application like HTTP, transport TCP and UDP, network layer IPv4 and IPv6 and data link layer Ether (Ethernet), will fall out. <br>  It is important to pay attention to the register: most protocols are written in Scapy with capital letters. <br>  In order to examine in detail the fields of a specific protocol, you can call the <b>ls ()</b> function with the protocol specified: <b>ls (TCP)</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/2ee/096/bae2ee096274d9f9acfb3930873d9bd5.png"><br><br>  As a result, all fields that can be modified in the process of creating packages will be displayed.  The parentheses show the values ‚Äã‚Äãthat are used by default, you can see that the port of the sender is 20 (this is ftp-data) and the port of the receiver is 80 (this is naturally HTTP), the SYN flag is also set (flags = 2). <br><br>  For example, if we consider the data link layer (Ethernet), then there will be fewer opportunities: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/104/693/2dd/1046932dd7edef06eeb75648d1075090.png"><br><br>  In addition to the <b>ls ()</b> function, there is a useful <b>lsc ()</b> function that will output almost all the main Scapy functionality: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/714/aad/3cf/714aad3cfbf3c74bd89277b85b7f1c8e.png"><br><br>  In order to get more detailed information about each function, you can use <b>help ( <i>function_name</i> )</b> , for example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/969/a22/092/969a2209241b3075f486de820e374b03.png"><br><br>  We see something similar to the MAN page in Unix systems. <br>  To exit, you can use again the usual <b>Q</b> key in Linux. <br><br>  We looked at the protocols and functions, now you can get down to business - to the creation of packages. <br><br><h1>  Kraftim </h1><br>  You can create high-level packets at once (network and application), and Scapy will automatically add to the lower levels, or you can manually assemble them starting from the data link layer. <br>  Levels of the OSI model are separated by a forward slash (/). <br>  You need to pay attention to the fact that Scapy reads the package from the lower level on the left, to the higher one on the right.  At first, this may be a bit confusing, but after a little practice, everything will become quite familiar. <br>  By the way, in the terminology of Scapy, a network packet is divided into layers, and each layer is represented as an instance of an object. <br>  The assembled package in a simplified form may look like: <br> <code>Ether()/IP()/TCP()/‚ÄùApp Data‚Äù</code> <br>  In most cases, only the L3 level is used, giving Scapy the ability to independently fill the channel level, based on information from the OS. <br>  Changing the values ‚Äã‚Äãof the fields of each protocol, we change the standard values ‚Äã‚Äã(they are output by the <b>ls ()</b> function). <br><br>  Now create some simple package. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d43/fb8/999/d43fb8999fbe59d3c2165c6e6792f308.png"><br><br>  It's very simple: we specified the destination address, port, and in general, the load in the form of the word "TEST". <br>  The package itself was simply called a <i>packet</i> , we will see in great detail and deployed our newly created package: <br>  And now, having performed the familiar <b>ls (packet)</b> function: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6c/9ef/eb6/a6c9efeb67e21560b6145768cdda789d.png"><br><br>  The levels in it are separated by the characters "-". <br><br>  Instead of creating a package at once, you can create it in parts: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/918/053/34c/91805334c44bc1089998220458572afb.png"><br><br>  In this example, we created variables for each level of the OSI model. <br>  Letters and numbers can be used as variable names, while not forgetting the case. <br><br>  And now we collect everything in one package: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/4be/dad/7174bedad9a174545f6cd65b8a25e504.png"><br><br>  It is seen that the result will be similar. <br><br><h1>  Dive into the packages </h1><br>  We have already looked at the output of the <b>ls ()</b> function, but such detailed information about the package is not always needed. <br>  Simply enter the name of the variable and immediately see a brief summary: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/866/36b/95c/86636b95c85b716e7656ef5dcccd9ab9.png"><br><br>  You can also use the <b>summary ()</b> method: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/699/adf/850/699adf850645555f13a820109662e10e.png"><br><br>  If you need a little more information, then there is a <b>show ()</b> method: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0b/342/aee/d0b342aeed75f50f06b91e33b43b61f7.png"><br><br>  In addition, you can view any field by simply specifying it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29f/82f/55e/29f82f55e43f6dbb35e61babf85f6268.png"><br><br>  Of course, this only works if such fields are unique within the package. <br>  If, for example, we take the flags field, which is present in both TCP and IP, then we need to specify what we want to see.  Otherwise, Scapy will display the value of the first field found (IP flags in our example). <br>  Concretization occurs by specifying the protocol in square brackets: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/045/ca4/2e1045ca49fd88e753175360ad0e8161.png"><br><br>  By the way, by default, the set flags are displayed in digital format. <br>  If all control bits are included (set to 1), then we get a value of 255. In our case, the value 2 indicates that the SYN bit is set. <br><br>  But it is possible to display control bits in a symbolic display: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1b/183/55c/e1b18355cf34655ce3b7c58139a61fe9.png"><br><br>  As already mentioned, at any time you can simply change the value of any field: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/731/93c/78a/73193c78aa083b4113eaf3f425fb2bf8.png"><br><br>  And if the field is not unique, then you need to specify the protocol: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/b3c/6af/7c3b3c6afee62296bf1ce37448e510c1.png"><br><br>  The second way is to use the <b>payload</b> construction, which allows you to jump over one level (via L3 in our case): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b27/df8/12e/b27df812ee99b1430c44f94540c5e74c.png"><br><br>  Here we first look at the output of the layers above L3, then look at the value of the TCP flags and set a new value for them. <br>  By the way, you can even call payload several times, while climbing higher and higher: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32d/2fb/fe5/32d2fbfe5df091c5b8aeda31d47ac7ea.png"><br><br>  You can also look at the contents of the package in hexadecimal, for this there is a function <b>hexdump ()</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/6fe/2e8/5ce6fe2e8e71e1103393a3cf055f56ca.png"><br><br><h1>  We deal with addressing </h1><br>  Scapy also shows great flexibility in specifying the recipient's address. <br>  A lot of options - here the usual decimal form, and the domain name and CIDR notation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/148/5f5/c94/1485f5c94a733959d8994be206248054.png"><br><br>  In the latter case, the packet will be sent to each address in the subnet. <br><br>  A set of addresses can be set just by separating them with a comma, without forgetting the square brackets: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28e/084/710/28e084710cbcd6282c6c8e34586bb7e5.png"><br><br>  At this stage, the thought may arise: ‚ÄúWhat if you need to specify multiple ports?‚Äù. <br>  And here Scapy provides ample opportunities, you can specify both a range and just list a lot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d49/107/509/d49107509c8b1ef21186511d2a9869b6.png"><br><br>  I draw attention to the difference in brackets, in the case of a range they are round, and in the case of a set - square. <br>  And completing the conversation about specifying goals, consider the situation when you need to send multiple packets to multiple ports. <br>  In order to see which packages will be sent will have to use the <b>for</b> loop, do not forget that our programming language is Python. <br>  In fact, nothing complicated, everything is very logical: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/226/29b/b62/22629bb62b1ba8975484ded790eaac5d.png"><br><br>  First, we are already familiar with the creation of a package in which we specify the subnet and range of ports. <br>  Then, using a loop, we create a list where each element of the package structure is assigned to the variable ‚Äú <i>a</i> ‚Äù.  In Python, there are no arrays in the usual sense.  Instead, lists are used to store objects. <br>  We use the <b>for</b> loop to ‚Äúunpack‚Äù the entire structure and display it in such a visual form. <br><br><h1>  We send packages in a way </h1><br>  With the same scope and breadth, and sending packets: <br><ul><li>  <b>send ()</b> function - sends packets using the network (L3) level, without processing the responses in any way.  The principle is used - sent and forgotten; </li><li>  <b>sendp ()</b> function - sends packets using the channel (L2) layer, the specified parameters and Ethernet frame headers are taken into account.  The answers are still not expected and not processed; </li><li>  the <b>sr ()</b> function is similar to send (), the exception being that it is already waiting for response packets; </li><li>  <b>srp ()</b> function - sends and receives packets, L2 level </li><li>  <b>sr1 ()</b> function - sends the packet of the third level and takes only the first answer, many answers are not provided; </li><li>  The <b>srp1 ()</b> function is similar to sr1 (), only the channel level is already. </li></ul><br>  Each of these functions can be called without any additional parameters, simply by specifying the name of the variable containing the package. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/38f/e6b/35338fe6b0f2c5f5d88921e8a1906dfe.png"><br><br>  But at the same time there are many additional options that can sometimes be useful. <br>  For example, <i>timeout</i> - indicates how long (in seconds) you need to wait before receiving a reply packet, <i>retry</i> ‚Äî how many times you need to resend the packet if no response was received and one of the most useful options is <i>filter</i> , whose syntax is very similar to tcpdump. <br><br>  As a visual example, send a packet to the network: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca7/4ca/da4/ca74cada4179adfaa8f48015afeaa2cf.png"><br><br>  Here we use the function that, after sending, waits for a response, set a timeout of 0.1 seconds and filter the responses that fall under the specified rule. <br><br>  How to deal with response packets? <br>  You can take and assign a variable, which will contain the answer: <br><img src="https://habrastorage.org/getpro/habr/post_images/839/25f/250/83925f25055ddaad16fdee98e2fc18bc.png"><br><br>  And to look already in a usual way, simply causing a <i>response</i> variable. <br>  It can be seen that the answer is preserved in two versions - Results and Unanswered, results and no answer, respectively. <br>  By specifying the offset, only the necessary part of the response can be output: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08e/d76/9cf/08ed769cf743719edb0f78cdc5992fa0.png"><br><br>  Or detailed information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d09/459/d0a/d09459d0a3fda495bc7c15f93080c5df.png"><br><br>  If the packet was sent to the network without specifying a variable (for example, simply by the <b>sr ()</b> function), then by default the packet will be listed as the variable <b>"_"</b> (underscore). <br><br>  To get these packages from there, you can use the construction: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4d/5ae/0dd/c4d5ae0dd805d47fd884eedd9f106321.png"><br><br>  At the same time, different results will be saved in two different variables ( <i>res</i> and <i>unans</i> ). <br><br>  More detailed output is achieved again by specifying the offset: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/861/bad/9dc/861bad9dcdbcf6e01b52bf95a068ea71.png"><br><br><h1>  We catch return packets </h1><br>  Now consider the situation if there are a lot of packets in response. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f90/512/c9b/f90512c9b8fd5ba2d7b6f0d61dc1e41b.png"><br><br>  What we saw was, in fact, the most port scanning. <br><br>  Open ports will be with SA (SYN / ACK) flags, for example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d89/cdb/6e2/d89cdb6e22970cd0aaf3d705b0875376.png"><br><br>  We look exactly at the package by number, the account traditionally starts from scratch. <br><br>  You can go ahead and unpack this result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/079/e5e/ba5079e5e7963bea2faff22fa6be4751.png"><br><br>  Here we retrieved the sent packet (at number 21) and the response to it from the result. <br>  But this is only one package, but what if you need to process all the packages? <br>  In this case, you will have to re-access the for loop: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/614/85e/778/61485e77823f2b84a4f897085deeff1b.png"><br><br>  We take and break each element of the <i>res</i> list into parts <i>a</i> and <i>b</i> .  Then we cut off part <i>‚Äúa‚Äù</i> , filling it all into the <i>‚Äúallsent‚Äù</i> list. <br>  Similarly, create a list <i>allrec</i> , just leave another part. <br>  All this, of course, is good, but I would like to get a list of open and closed ports in a more convenient way. <br>  Once again, we look at the list of <i>res</i> , and more precisely at the res [0] element, which consists of two parts: the packet that we sent res [0] [0], and the answer, which was received by res [0] [1]. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/915/f4b/b9e/915f4bb9ef850c428c995971255f5b34.png"><br><br>  In response, you can find three parts - the IP header (res [0] [1] [0]), the TCP header (res [0] [1] [1]) and the data itself (res [0] [1] [2 ]). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34a/fc9/334/34afc9334e162966ec31f5448613b403.png"><br><br>  We use the <b>for</b> loop to extract each element res [N] into the variable <i>"a"</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26d/877/d01/26d877d015a5507df6e362e7ea2e3589.png"><br><br>  Now the variable "a" contains the result for each package.  In other words, "a" is ans [N]. <br>  It only remains for us to check the values ‚Äã‚Äãof a [1] [1], which will mean res [N] [1] [1] in the TCP header. <br>  To be even more precise, a value of 18 is required, which means the SYN-ACK flags are set. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3a/314/af2/c3a314af292c90f022289e1ead92ff2b.png"><br><br>  In cases where this condition works, we will also deduce the port of the sender from the TCP header: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f5/6c1/71b/1f56c171b58a4500d02da7bca7352167.png"><br><br>  As a result, we get the result in the form of a list of open ports. <br>  All of the above constructions are recruited at once, it is also important to pay attention to the indents (usually 4 spaces). <br><br>  <b>We just manually wrote a simple port scanner, no more and no less.</b> <br><br><div class="spoiler">  <b class="spoiler_title">Listing 1 Port scanner</b> <div class="spoiler_text"><blockquote>  &gt;&gt;&gt; packet = IP (dst = "192.168.10.10") / TCP (dport = (1,100), flags = "S")) <br><br>  &gt;&gt;&gt; res, unans = sr (packet, timeout = 10) <br><br>  &gt;&gt;&gt; for a in res: <br>  ... if a [1] [1] .flags == 18: <br>  ... print a [1] .sport <br></blockquote><br></div></div><br><br><h1>  Sniffer and vice versa </h1><br>  Scapy also includes a small sniffer, for which the <b>sniff ()</b> function is responsible. <br>  Naturally, you can use filters with it (similar to tcpdump filters), the <i>filter</i> parameter is responsible for this, you can also limit the number of packets using the <i>count</i> parameter. <br>  As always, the call <b>help (sniff)</b> will display quite detailed information on this function. <br>  We should not forget that this is a greatly simplified sniffer, and one should not expect a good speed from it. <br>  The standard combination of <b>Ctrl + C</b> interrupts the process of capturing traffic and displays the result. <br>  Like any undefined variable, the result will fall into <b>"_"</b> . <br>  Having executed the <b>summary ()</b> method, you can see the statistics on captured packets: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aba/7c4/919/aba7c4919710d22dd0002bcb3dd3075a.png"><br><br>  Instead of capturing traffic from the network, you can read it from a previously saved dump (pcap file). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc2/c40/116/fc2c40116ab0552b5453066031207e0b.png"><br><br>  In addition, you can, and vice versa, write captured packets to a file using the <b>wrpcap ()</b> function: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ef/dcb/e39/5efdcbe39ecbebf1ecc673716fc32041.png"><br><br>  And completing the sniffing theme, you can call Wireshark directly from the Scapy interface, for this you can use the <b>wireshark ()</b> function of the same name. <br><br>  Details about Wireshark can be in my previous article at <a href="http://linkmeup.ru/blog/115.html">http://linkmeup.ru/blog/115.html</a> . <br><br><h1>  Automation </h1><br>  Everything that we considered happened directly online. <br>  But, naturally, many things can be automated by writing scripts. <br>  To do this, at the beginning of the script you will need to specify: <br> <code>#!/usr/bin/python</code> <br>  Familiar for Linux users, shebang.  (http://en.wikipedia.org/wiki/Shebang_(Unix)) <br> <code>from scapy.all import *</code> <br>  Import all Scapy functionality. <br>  After that, you can write the necessary functions. <br>  It is important to indent when writing loops in scripts, otherwise error messages will appear and the script will not work. <br>  We will also consider connecting additional modules to Scapy using the example of OSPF. <br>  Initially, Scapy does not know how to work with the OSPF protocol. <br>  If you execute <b>load_contrib ('ospf')</b> , then there will be an error message: <i>"ERROR: No module named contrib.ospf"</i> . <br>  First, download the module, you can take it <a href="http://bb.secdev.org/scapy/src/61a9c1abd5873a0c2cdf807030ab744355b61d5c/scapy/contrib/ospf.py">here</a> . <br>  Then you need to create a <i>contrib</i> directory: <br> <code># mkdir /usr/lib/python2.7/dist-packages/scapy/contrib</code> <br>  And move the module to the newly created directory: <br> <code># cp ospf.py /usr/lib/python2.7/dist-packages/scapy/contrib/</code> <br>  Now, if you go into Scapy and view the list of connected third-party modules (for this, you guessed it, the <b>list_contrib ()</b> function <b>answers</b> ): <br><blockquote>  &gt;&gt;&gt; list_contrib () <br>  ospf: OSPF status = loads <br>  &gt;&gt;&gt; <br></blockquote><br>  It would seem that everything is ready, but it was not there. <br>  On another attempt to load the ospf module: <br>  <b>&gt;&gt;&gt; load_contrib ('ospf')</b> , we get the same error <i>‚ÄúERROR: No module named contrib.ospf‚Äù</i> <br>  In order for the module to work finally, it remains to create an initialization script (empty file): <br> <code>touch /usr/lib/python2.7/dist-packages/scapy/contrib/__init__.py</code> <br>  After that, you can already create packages for OSPF. <br><br><h1>  Create a three-step TCP connection </h1><br>  To do this, you will need to catch the SYN / ACK response, extract the TCP sequence number from it, increment the value by one and, in fact, put the resulting value in the acknowledgment number field. <br>  Not an easy task at first glance, but Scapy can handle it too. <br>  First, consider what we need in order for everything to be successful. <br><br>  1) Send the SYN to the receiving party: <br><ul><li>  collect IP header, do not forget about the address of the sender and recipient; </li><li>  collect a TCP header in which you will need to specify the TCP ports of the sender and destination, set TCP flags (SYN bits) and generate ISN (Initial Sequence Number). </li></ul><br>  2) Catch the return packet: <br><ul><li>  save the answer; </li><li>  extract TCP sequence number from it and increase this value by one. </li></ul><br>  3) Create an acknowledgment (ACK) to the received response packet: <br><ul><li>  collect an IP header containing the same sender and recipient addresses as in the case of a SYN packet; </li><li>  collect the TCP header with the same port numbers as in the SYN segment, but set the ACK flag, increase the ISN value by one and set the acknowledgment to the extracted and enlarged, in the second step, sequence number. </li></ul><br><br>  In order to make it even clearer, let us consider in more detail, using arbitrarily taken values. <br>  For example, the connection went like this: <br><blockquote>  192.168.10.200 1024&gt; 192.168.10.50 80 flags = SYN seq = 12345 <br>  192.168.10.50 80&gt; 192.168.10.200 1024 flags = SYN, ACK seq = 9998 ack = 12346 <br>  192.168.10.200 1024&gt; 192.168.10.50 80 flags = ACK seq = 12346 ack = 9999 <br></blockquote><br>  What ultimately needed to be done. <br><br>  1) Send the SYN to the receiving party: <br><ul><li>  collect the IP header in which you specify 192.168.10.200 and 192.168.10.50 as the sender as the sender; </li><li>  collect TCP header with source port (source) 1024 and destination port (destination) 80. Also set the SYN flag and generate an ISN equal to 12345. </li></ul><br>  2) Catch the return packet: <br><ul><li>  save the answer; </li><li>  extract TCP sequence number (9998) from it and increase this value by one, we get 9999. </li></ul><br>  3) Create an acknowledgment (ACK) to the received response packet: <br><ul><li>  collect the IP header in which you specify 192.168.10.200 and 192.168.10.50 as the sender as the sender; </li><li>  collect a TCP header with the same source and destination ports (1024 and 80, respectively), set the ACK flag, increase the ISN by one (12346) and set the acknowledgment to the increased value of the caught seq number (9999). </li></ul><br>  Let's start collecting the package: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d6/376/b8f/1d6376b8f1ff2df28b03f8fc7764bd31.png"><br><br>  Everything should be familiar here: the package is assembled in two parts, encapsulating TCP into IP. <br><br>  Now, remembering that we will need to intercept the answer, extract the sequence number from there and increment by one, we do: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a24/2a9/fa2/a242a9fa2099a0818c5c6c32d7371c2d.png"><br><br>  The following happens - the function <b>sr1</b> sends the previously created packet to the network, and the first response <i>received</i> is placed in the <i>SYNACK</i> variable. <br>  And then, using the <i>SYNACK.seq</i> construction, we retrieve the TCP sequence number, increment it by one and save it in the variable <i>my_ack</i> . <br><br>  Moving on: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/194/372/76b19437264ecca6262adfdc19751005.png"><br><br>  Create a new TCP header and call it ACK.  It sets another flag (A - ACK) and increases the value of the sequence number. <br>  In addition, the <i>my_ack</i> variable is specified as an acknowledgment. <br>  Then the assembled packet is thrown onto the network with the <b>send</b> command (remember that this is an L3 command that does not even listen to what will come in response). <br>  If everything was done correctly, then the classic TCP connection took place. <br>  It remains only to create a TCP segment without any flags and also send it to the network. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/910/756/79d/91075679d09f6b6c8814d59b1439e40e.png"><br><br>  As you can see, we once again created an instance of the TCP header (this time, calling it PUSH), without flags and with all the other familiar values. <br>  After that, we added some data using the <i>data</i> variable, and sent it to the network using the same <b>send</b> function. <br>  And accordingly, the recipient will have to receive a confirmation of this segment. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 2 TCP connection</b> <div class="spoiler_text"><blockquote>  &gt;&gt;&gt; ip = IP (src = "192.168.10.200", dst = "192.168.10.50") <br>  &gt;&gt;&gt; SYN = TCP (sport = 1024, dport = 80, flags = "S", seq = 12345) <br>  &gt;&gt;&gt; packet = ip / SYN <br>  &gt;&gt;&gt; SYNACK = sr1 (packet) <br>  &gt;&gt;&gt; my_ack = SYNACK.seq + 1 <br>  &gt;&gt;&gt; ACK = TCP (sport = 1024, dport = 80, flags = "A", seq = 12346, ack = my + ack) <br>  &gt;&gt;&gt; send (ip / ACK) <br></blockquote><br></div></div><br><br>  But there are several pitfalls. <br>  If you look at this exchange in Wireshark, you can see that before our ACK packet left, an RST was suddenly sent: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/825/e9e/720/825e9e7206ad9e87efbf56d8151708fd.png"><br><br>  The fact is that Scapy runs past the OS TCP / IP stack.  This means that the OS is not aware that Scapy sends any packets. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, the OS will not expect the appearance of SYN / ACK packets. </font><font style="vertical-align: inherit;">And, therefore, the connection will be immediately reset. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, this is not the result that we need. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One solution to this problem will be to use the packet filter functionality, in particular iptables, which will be able to block outgoing RST packets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, as follows: </font></font><br> <code># iptables -A OUTPUT -p tcp -d 192.168.10.50 -s 192.168.10.200 --dport 80 --tcp-flags RST RST -j DROP</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execution of this design will lead to the fact that all outgoing packets with a destination address 192.168.10.50 and the sender address 192.168.10.200 on port 80, with the RST flag set will be discarded. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Packages will still be generated by the OS, but they just will not fly out of its limits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, nothing will stop Scapy from doing a full TCP session:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/458/9c4/1f24589c4d7c56316958cb7f80f7317d.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We continue research </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using Scapy, you can find hosts on the network, among the specified set of addresses: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d94/efa/3d6/d94efa3d6096898ce47165e3d40fe018.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, we use the ICMP protocol and use the familiar trick to divide the received responses. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce1/594/207/ce1594207d3658a5d1fbcfdd13ea0799.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By default, the 8th type for ICMP is set, this is the classic ping request. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delving into the subject of information security, we will try to determine the OS version using Scapy and nmap. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/97e/0c7/b9e/97e0c7b9eb4d20d6de757d1c0d713822.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, consider what has been done. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, an external module was connected, in this case nmap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we check that we have a file (nmap-os-fingerprints) with fingerprints of various operating systems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we run the definition of the remote operating system directly, the </font><b><font style="vertical-align: inherit;">nmap_fp</font></b><font style="vertical-align: inherit;"> function is responsible for this </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where as parameters besides the target itself, you can also specify open (oport) and closed (cport) ports. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correctly specified ports will help greatly improve the accuracy of the OS definition.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualize the packages </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All the time we looked at the textual output, in some places there was a pseudo-graphic, but Scapy can also display some of the results graphically. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see what is offered to us. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest is the method of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversations ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a3/775/b14/6a3775b14bc05897485215c7fcfd871a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When it is executed, the ImageMagick window will start, which will show the scheme of our exchange of packages, not so hot, but quite clearly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method is probably best suited for visualizing traffic dumps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second way is to build 2D graphs, and then export them to a pdf-file. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b93/746/aed/b93746aed63f97a825539f341fefdb21.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdfdump ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is already responsible for this </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results look like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bef/93a/a4d/bef93aa4d67614cbfaa7a0b8be93651d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, quite well. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the function</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graph ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> again opens the ImageMagick window, but with a detailed drawing: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/98a/a1f/5a3/98aa1f5a3832f9ee92a4b41ad77d8b7e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we see the result of the trace, with a detailed display of autonomous systems and other visualization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, completing the topic of visualization, and with it the article, let's look at the 3D display of the track. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will require VPython and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trace3D ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e5/94e/394/9e594e394123645e8ce242895db2cb20.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the track from the previous graph. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But sometimes there are such options: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/575/689/3a3575689d52a5be7a3d64af48da66b0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this example, several targets were traced at once, using several (80, 443) tcp ports. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Left-clicking on any object will result in the appearance of an IP address above it, and left-click while holding the CTRL key will display more detailed information ‚Äî ports, as in this case.</font></font><br><br><h1>  Epilogue </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have considered only a small part of the Scapy utility, but this is already impressive. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The possibilities that are provided are really very big. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article is intended to arouse interest in the reader in the study of network protocols, and is not an exhaustive guide to the tool Scapy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The author does not bear responsibility for the use of this utility for any illegal purposes. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/3da/30b/ab43da30b1c0ff047ea139ab2a9a66b4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of writing this article, materials </font></font><a href="http://www.sans.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the SANS Institute</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://www.secdev.org/projects/scapy/doc/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official project documentation were used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/208786/">https://habr.com/ru/post/208786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208774/index.html">Why do we all need SAT and all these P-NPs (part two)</a></li>
<li><a href="../208778/index.html">HHVM, Nginx and PHP (as well as Laravel)</a></li>
<li><a href="../208780/index.html">Real Time Operating Systems for Beginners</a></li>
<li><a href="../208782/index.html">SoftEther VPN - an advanced multi-protocol VPN server and client</a></li>
<li><a href="../208784/index.html">How a good piece of hardware was made excellent - an overview of EMC VNX storage systems</a></li>
<li><a href="../208788/index.html">Seamless splitting and splicing video with DirectShow</a></li>
<li><a href="../208792/index.html">Data Virtualization in WPF</a></li>
<li><a href="../208796/index.html">Domestic MOOC provider - Universarium</a></li>
<li><a href="../208798/index.html">Google Glass as a regular tool for data center employees</a></li>
<li><a href="../208800/index.html">Apple App Store. Get ERN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>