<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use Audio API to create vocoder</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we learned a little about the capabilities of the Audio API and wrote a simple signal visualizer. Now it is time to dig deeper an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use Audio API to create vocoder</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/64f/fbb/f1f/64ffbbf1faedabff3c30213958bc21de.png" align="left">  In the <a href="http://habrahabr.ru/post/210422/">last article,</a> we learned a little about the capabilities of the Audio API and wrote a simple signal visualizer.  Now it is time to dig deeper and try out new API chips.  But we need a goal to which we will strive, and in this case our goal will be to make fun of the incoming signal and its characteristics.  In other words, we will write a small <a href="http://ru.wikipedia.org/wiki/%25C2%25EE%25EA%25EE%25E4%25E5%25F0">vocoder</a> . <br><br>  Since the final code turned out to be quite large, the article will cover the most important and interesting fragments from the point of view of the Audio API.  The final result, of course, you can look at the <a href="http://phalcon.demosite.pro/vokoder/">demo</a> . <br><br><a name="habracut"></a><br><h2>  Selection of signal source </h2><br>  So Audio API supports three types of signal source: <br><ol><li>  Source created using audio tag </li><li>  Audio buffer </li><li>  External audio stream (stream) (microphone or any other audio stream, including external) </li></ol><br>  In the <a href="http://phalcon.demosite.pro/vokoder/">demo example</a> , all three types of source are implemented, as well as the ability to switch between them.  We will consider, perhaps, the most interesting of them, namely the external audio stream from the microphone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to reach our source, we first need to obtain the user's permission and capture the audio stream.  And what do you think, we do not have to fence tons of code for this, but just use one function called <b>getUserMedia</b> .  This magic f-I takes three arguments: <br><ol><li>  The type of data to which access is requested.  It is an object of the form - <pre><code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">video</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">audio</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}</code> </pre> </li><li>  The multimedia data capture function, which receives a captured stream as an argument. <br></li><li>  The error handling function occurred during the capture. <br></li></ol><br>  So, taking into account various specifications of browsers, our initialization function will look like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, w = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, context = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, dest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, source = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = w.AudioContext || w.webkitAudioContext; navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; <span class="hljs-comment"><span class="hljs-comment">//  context = new audioContext(); //   dest = context.destination; var bufferLoader = new BufferLoader(context, ["effects/reverb.wav"], function (buffers) { navigator.getMedia({ audio: true }, function (striam) { //       source = context.createMediaStreamSource(striam); }, function (e) { alert(e); }); }); bufferLoader.load(); } catch (e) { alert (e.message); } };</span></span></code> </pre><br><br>  Consider what happens here.  At the beginning we create the audioContext for our page (what it is described in the <a href="http://habrahabr.ru/post/210422/">previous article</a> ), then we see a new function <b>BufferLoader</b> .  It is engaged in using XHR2 to pull external audio files and carefully store them in the buffer.  In our case, we need it to tighten one audio effect, which will be described below.  This function is not standard and we will have to write it. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    var BufferLoader = function (context, urlList, callback) { this.context = context; this.urlList = urlList; this.onload = callback; this.bufferList = new Array(); this.loadCount = 0; }; BufferLoader.prototype.load = function () { for (var i = 0; i &lt; this.urlList.length; ++i) { this.loadBuffer(this.urlList[i], i); } }; BufferLoader.prototype.loadBuffer = function (url, index) { var request = new XMLHttpRequest(); request.open("GET", url, true); request.responseType = "arraybuffer"; var loader = this; request.onload = function () { loader.context.decodeAudioData( request.response, function (buffer) { if (!buffer) { alert('error decoding file data: ' + url); return; } loader.bufferList[index] = buffer; if (++loader.loadCount == loader.urlList.length) { loader.onload(loader.bufferList); } }, function (error) { console.error('decodeAudioData error', error); } ); } request.onerror = function () { alert('BufferLoader: XHR error'); } request.send(); };</span></span></code> </pre><br>  After loading the effect, we capture the audio stream and, if the user allows it, we will need to associate the captured signal with our audio context.  For this we will use the <b>createMediaStreamSource function</b> .  Now our input signal is at our complete disposal and, believe me, we make fun of it notably over it. <br><br><h2>  Signal processing and change </h2><br>  The time has come for us to write a function that will ruthlessly mock the input stream.  Consider the methods we will use: <br><ul><li>  <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/GainNode">createGain</a></b> - This method allows you to amplify our signal.  It has one <b>gain</b> parameter - <b>gain</b> value </li><li>  <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/ConvolverNode">createConvolver</a></b> - This method allows the convolution of signals (addition).  The method has two parameters <b>buffer</b> - the impulse characteristic with which the input signal is added is written here.  In our case, this is the external file that was mentioned above.  We will use this method in order to obtain the effect of a gradual decrease in the intensity of sound during its multiple reflections.  In fact, this is not a trivial task, and to solve it, it will be necessary to make not frail calculations, but we cheat and use the ready impulse response, which is full on the Internet.  The second parameter, <b>normalize</b> , indicates whether the impulse response can be scaled. </li><li>  <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/DynamicsCompressorNode">createDynamicsCompressor</a></b> - Implements the effect of audio signal compression.  In other words, compression allows you to make a narrower difference between the quietest and loudest sounds.  The method has the following parameters: <b>threshold</b> (Threshold level, determines the value above which the compressor starts to attenuate the signal), <b>ratio</b> (determines the intensity of signal attenuation), <b>attack</b> (this is the time that elapses between the threshold value and the moment the compressor starts up. Experiments with this parameter allow to obtain special effects, for example, possible to make the sound of the bass drum noticeably sharper), <b>release</b> (the time that elapses between how the input signal level has fallen below the threshold and the moment when the compressor ceases  attenuate the signal. </li></ul><br>  We use these methods and distribute our f-th transformation: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AudioModulation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffers, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> am = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  var sourceGain = context.createGain(); sourceGain.gain.value = 2; //        var sourceConvolver = context.createConvolver(); sourceConvolver.buffer = buffers[0]; //   var sourceCompressor = context.createDynamicsCompressor(); sourceCompressor.threshold.value = -18.2; sourceCompressor.ratio.value = 4; //    source.connect(sourceGain); sourceGain.connect(sourceConvolver); sourceConvolver.connect(sourceCompressor); //   sourceCompressor.connect(dest); }</span></span></code> </pre><br><br>  All values, such as loudness or the value from which the compression starts, can be tied to the user interface for changes in real time, as is done in the demo.  As a result of passing the signal through our function, we get a slightly enhanced version with an echo effect (as if you were talking with a bucket on your head or in a helmet).  But we will not get a fundamentally new sound at the output yet, which means that we are moving on.  The next step we will try to implement the effect of ring modulation. <br><br><h4>  Ring modulation </h4><br>  Ring modulation is an audio effect that was very popular in the ‚Äúshaggy‚Äù years and was used to create voices of all kinds of monsters and robots.  The essence of this effect is that we have two signals, one is called a carrier and is a synthesized signal of arbitrary frequency, and the second is a modulating signal, and these signals are multiplied.  As a result, we get a new signal with distortion and metallic notes.  To implement this miracle, consider the following methods: <br><ul><li>  <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/OscillatorNode">createOscillator</a></b> - This method allows you to generate signals of arbitrary frequency and shape.  It has three parameters: <b>type</b> (waveform: 1 - sine wave, 2 - rectangular, 3 - saw, 4 - triangular), <b>frequency</b> (signal frequency), <b>detune</b> (detuning - frequency deviation. Each octave consists of 1200 cents, and each the semitone consists of 100 cents. By specifying the offset of 1200, you can go up one octave, and having specified the offset of ‚Äì1200 one octave down.) </li><li>  <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/BiquadFilterNode">createBiquadFilter</a></b> - The method allows to implement frequency filtering.  The method has four parameters: <b>frequency</b> (the frequency on which the filter is based), <b>gain</b> (level of frequency gain), <b>Q</b> ( <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25B1%25D1%2580%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">Q</a> ), <br>  <b>type</b> - types of filtering that are supported out of the box: <br><ol><li>  lowpass - lowpass filter (cuts off anything higher than the selected frequency) </li><li>  highpass - high-pass filter (cuts everything below the selected frequency) </li><li>  bandpass - bandpass filter (passes only a certain frequency band) </li><li>  lowshelf - shelf at low frequencies (means that anything below the selected frequency is amplified or weakened), </li><li>  highshelf - shelf at high frequencies (means that everything that is higher than the selected frequency is amplified or weakened) </li><li>  peaking - narrowband peak filter (amplifies a certain frequency, the popular name is ‚Äúfilter bell‚Äù), </li><li>  notch - notch filter (weakens a certain frequency, the popular name is ‚Äúfilter-plug‚Äù), </li><li>  allpass is a filter that passes all frequencies of a signal with equal gain, but changes the phase of the signal.  This happens when the change in the frequency transmission delay.  Usually such a filter is described by one parameter - the frequency at which the phase shift reaches 90 ¬∞. <br></li></ol><br></li></ul><br>  Well, this is enough for us to realize our plans.  As a result, the Fm AudioModulation will be transformed into: <br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AudioModulation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffers, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> am = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  var sourceGain = context.createGain(); sourceGain.gain.value = 2; //        var sourceConvolver = context.createConvolver(); sourceConvolver.buffer = buffers[0]; //   var sourceCompressor = context.createDynamicsCompressor(); sourceCompressor.threshold.value = -18.2; sourceCompressor.ratio.value = 4; //    source.connect(sourceGain); sourceGain.connect(sourceConvolver); sourceConvolver.connect(sourceCompressor); //  var ringGain = this.ringModulation(); sourceCompressor.connect(ringGain); //   ringGain.connect(dest); } AudioModulation.prototype.ringModulation = function () { //,   var ringGain = context.createGain(); ringGain.gain.value = 1; //  ringCarrier = context.createOscillator(); //     40 ringCarrier.type = ringCarrier.SINE; ringCarrier.frequency.value = 40; //    ringCarrier.detune.value = 600; // ,      10 var ngHigpass = context.createBiquadFilter(); ngHigpass.type = ngHigpass.HIGHPASS; ngHigpass.frequency.value = 10; //    ,        ringCarrier.connect(ngHigpass); ngHigpass.connect(ringGain.gain); return ringGain; };</span></span></code> </pre><br></div></div><br>  Well, it is quite another thing, after all this we will get a rather disguised "robotic signal", but as they say, there is not a lot of good, and therefore we will add an equalizer to all of this magnificence for manual tuning of various frequencies, but to realize it will be with the help of the already known f- <b>createBiquadFilter</b> with the type highshelf. <br><br><h4>  Frequency filtering </h4><br>  First, create an array with the settings for which we will build the filters: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filters = [{<span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">40</span></span>},{<span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>},....,{<span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">16000</span></span>}];</code> </pre><br>  The parameters in it are gain level and frequency.  Now the function that creates filters: <br><pre> <code class="javascript hljs">AudioModulation.prototype.setFilters = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fil = [{ <span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">40</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">gain</span></span>: <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-attr"><span class="hljs-attr">frequency</span></span>: <span class="hljs-number"><span class="hljs-number">16000</span></span>}], out = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ln = fil.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ln; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loc = fil[i], currFilter = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; currFilter = context.createBiquadFilter(); currFilter.type = currFilter.HIGHSHELF; currFilter.gain.value = loc.gain; currFilter.Q.value = <span class="hljs-number"><span class="hljs-number">1</span></span>; currFilter.frequency.value = loc.frequency; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!out) { source.connect(currFilter); out = currFilter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { out.connect(currFilter); out = currFilter; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out; };</code> </pre><br>  As a result, the f-I transformation will take the form: <br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AudioModulation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffers, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> am = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  var sourceGain = context.createGain(); sourceGain.gain.value = 2; //        var sourceConvolver = context.createConvolver(); sourceConvolver.buffer = buffers[0]; //   var sourceCompressor = context.createDynamicsCompressor(); sourceCompressor.threshold.value = -18.2; sourceCompressor.ratio.value = 4; //    source.connect(sourceGain); sourceGain.connect(sourceConvolver); sourceConvolver.connect(sourceCompressor); //  var ringGain = this.ringModulation(); sourceCompressor.connect(ringGain); //  var outFilters = this.setFilters(sourceCompressor); //   outFilters.connect(dest); } //  AudioModulation.prototype.ringModulation = function () { //,   var ringGain = context.createGain(); ringGain.gain.value = 1; //  ringCarrier = context.createOscillator(); //     40 ringCarrier.type = ringCarrier.SINE; ringCarrier.frequency.value = 40; //    ringCarrier.detune.value = 600; // ,      10 var ngHigpass = context.createBiquadFilter(); ngHigpass.type = ngHigpass.HIGHPASS; ngHigpass.frequency.value = 10; //    ,        ringCarrier.connect(ngHigpass); ngHigpass.connect(ringGain.gain); return ringGain; }; // AudioModulation.prototype.setFilters = function (source) { var fil = [{ gain: 1, frequency: 40 }, { gain: 3, frequency: 120 }, { gain: -2, frequency: 16000}], out = null, ln = fil.length; while (ln--) { var loc = fil[ln], currFilter = null; currFilter = context.createBiquadFilter(); currFilter.type = currFilter.HIGHSHELF; currFilter.gain.value = loc.gain; currFilter.Q.value = 1; currFilter.frequency.value = loc.frequency; if (!out) { source.connect(currFilter); out = currFilter; } else { out.connect(currFilter); out = currFilter; } } return out; };</span></span></code> </pre><br></div></div><br>  Well, now we have a full-fledged equalizer and can amplify or weaken any frequency in the signal.  And if we were "lalkami", then we would stop at what was achieved and with a calm conscience tormented the microphone while playing with the settings, but we want more.  And here we will, so to speak, add a cherry to the cake - we will try to realize an effect called <b>pitch shifter</b> . <br><br><h4>  Change the key </h4><br>  The essence of the effect is that a copy of it is added to the signal, which lags behind the main tone by any interval within two octaves up or down.  This is a very fashionable effect and its implementation is damn complicated, so we will make, so to speak, a simplified version. <br>  In order to start working on this effect, we will need an interface that would allow us to receive signal data that we could change. <br>  To create it, we will use the <a href="http://www.dsplib.ru/content/dft/dft.html">Discrete Fourier Transform</a> (or, to be more precise, its kind of <a href="http://www.dsplib.ru/content/win/win.html">window Fourier Transform</a> ) and the method known to us from the previous article, <b><a href="http://docs.webplatform.org/wiki/apis/webaudio/ScriptProcessorNode">createScriptProcessor</a></b> .  It takes three parameters: <b>buffer</b> (the size of the frame or data window that is selected from the signal per unit of time), <b>numberOfInputChannels</b> (number of input channels), <b>numberOfOutputChannels</b> (number of output channels).  The result of calling this method is to create an interface object that we need.  The resulting object has its own event <b>onaudioprocess</b> , which works every time a new sample of data from the signal occurs.  In total, the conversion of our signal will look like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentGrainSize = <span class="hljs-number"><span class="hljs-number">512</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentOverLap = <span class="hljs-number"><span class="hljs-number">0.50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentShiftRatio = <span class="hljs-number"><span class="hljs-number">0.77</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = context.createScriptProcessor(currentGrainSize, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       -   (     ) node.grainWindow = hannWindow(currentGrainSize); // ,        node.buffer = new Float32Array(currentGrainSize* 2); node.onaudioprocess = function (event) { //  var input = event.inputBuffer.getChannelData(0); //  output = event.outputBuffer.getChannelData(0), ln = input.length; for (i = 0; i &lt; ln; i++) { //    input[i] *= this.grainWindow[i]; //     this.buffer[i] = this.buffer[i + currentGrainSize]; //   this.buffer[i + currentGrainSize] = 0.0; } //   var grainData = new Float32Array(currentGrainSize * 2); for (var i = 0, j = 0.0; i &lt; currentGrainSize; i++, j += currentShiftRatio) { var index = Math.floor(j) % currentGrainSize; var a = input[index]; var b = input[(index + 1) % currentGrainSize]; grainData[i] += linearInterpolation(a, b, j % 1.0) * this.grainWindow[i]; } //  for (i = 0; i &lt; currentGrainSize; i += Math.round(currentGrainSize * (1 - currentOverLap))) { for (j = 0; j &lt;= currentGrainSize; j++) { this.buffer[i + j] += grainData[j]; } } //      for (i = 0; i &lt; currentGrainSize; i++) { output[i] = this.buffer[i]; } }</span></span></code> </pre><br>  Now, using the parameters of step and overlap, we can get the effect of accelerating or slowing down pronunciation.  For calculations, we will need to implement the f-and <b>hannWindow</b> (F- <b>ih</b> calculation of the window Hanna) and <b>linearInterpolation</b> (f-i linear interpolation).  The final version of our conversion will be as follows: <br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AudioModulation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffers, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> am = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, currentGrainSize = <span class="hljs-number"><span class="hljs-number">512</span></span>, currentOverLap = <span class="hljs-number"><span class="hljs-number">0.50</span></span>, currentShiftRatio = <span class="hljs-number"><span class="hljs-number">0.77</span></span>, node = context.createScriptProcessor(currentGrainSize, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  var sourceGain = context.createGain(); sourceGain.gain.value = 2; //        var sourceConvolver = context.createConvolver(); sourceConvolver.buffer = buffers[0]; //   var sourceCompressor = context.createDynamicsCompressor(); sourceCompressor.threshold.value = -18.2; sourceCompressor.ratio.value = 4; //    source.connect(sourceGain); sourceGain.connect(sourceConvolver); sourceConvolver.connect(sourceCompressor); //  var ringGain = this.ringModulation(); sourceCompressor.connect(ringGain); //  var outFilters = this.setFilters(sourceCompressor); //   outFilters.connect(dest); //       -   (     ) node.grainWindow = this.hannWindow(currentGrainSize); // ,        node.buffer = new Float32Array(currentGrainSize* 2); node.onaudioprocess = function (event) { //  var input = event.inputBuffer.getChannelData(0); //  output = event.outputBuffer.getChannelData(0), ln = input.length; for (i = 0; i &lt; ln; i++) { //    input[i] *= this.grainWindow[i]; //     this.buffer[i] = this.buffer[i + currentGrainSize]; //   this.buffer[i + currentGrainSize] = 0.0; } //   var grainData = new Float32Array(currentGrainSize * 2); for (var i = 0, j = 0.0; i &lt; currentGrainSize; i++, j += currentShiftRatio) { var index = Math.floor(j) % currentGrainSize; var a = input[index]; var b = input[(index + 1) % currentGrainSize]; grainData[i] += am.linearInterpolation(a, b, j % 1.0) * this.grainWindow[i]; } //  for (i = 0; i &lt; currentGrainSize; i += Math.round(currentGrainSize * (1 - currentOverLap))) { for (j = 0; j &lt;= currentGrainSize; j++) { this.buffer[i + j] += grainData[j]; } } //      for (i = 0; i &lt; currentGrainSize; i++) { output[i] = this.buffer[i]; } } } AudioModulation.prototype.hannWindow = function (length) { var window = new Float32Array(length); for (var i = 0; i &lt; length; i++) { window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1))); } return window; }; AudioModulation.prototype.linearInterpolation = function (a, b, t) { return a + (b - a) * t; }; //  AudioModulation.prototype.ringModulation = function () { //,   var ringGain = context.createGain(); ringGain.gain.value = 1; //  ringCarrier = context.createOscillator(); //     40 ringCarrier.type = ringCarrier.SINE; ringCarrier.frequency.value = 40; //    ringCarrier.detune.value = 600; // ,      10 var ngHigpass = context.createBiquadFilter(); ngHigpass.type = ngHigpass.HIGHPASS; ngHigpass.frequency.value = 10; //    ,        ringCarrier.connect(ngHigpass); ngHigpass.connect(ringGain.gain); return ringGain; }; // AudioModulation.prototype.setFilters = function (source) { var fil = [{ gain: 1, frequency: 40 }, { gain: 3, frequency: 120 }, { gain: -2, frequency: 16000}], out = null, ln = fil.length; while (ln--) { var loc = fil[ln], currFilter = null; currFilter = context.createBiquadFilter(); currFilter.type = currFilter.HIGHSHELF; currFilter.gain.value = loc.gain; currFilter.Q.value = 1; currFilter.frequency.value = loc.frequency; if (!out) { source.connect(currFilter); out = currFilter; } else { out.connect(currFilter); out = currFilter; } } return out; };</span></span></code> </pre><br></div></div><br>  Well, now, with a clear conscience, we can enjoy the work done.  Of course, you can not stop there and, for example, add a spectrum visualizer, some fashionable effect like <a href="http://en.wikipedia.org/wiki/Phaser_(effect)">Phaser</a> , but this is up to you.  Now, digging deeper into the Audio API, it becomes clear that thanks to the mechanisms that are now available to developers, it is possible to implement almost any effects and audio signal processing.  You are limited only by your imagination. <br>  You can see the final version with a different signal source with a control interface here: <br><ul><li>  <a href="http://phalcon.demosite.pro/vokoder/">Demo</a> </li><li>  <a href="https://github.com/abaddonGIT/captureVoice">Github</a> code </li></ul><br><h4>  Useful literature and sources: </h4><br><ul><li>  <a href="http://docs.webplatform.org/wiki/apis/webaudio">docs.webplatform.org/wiki/apis/webaudio</a> </li><li>  <a href="http://www.w3.org/TR/2011/WD-webaudio-20111215/">www.w3.org/TR/2011/WD-webaudio-20111215</a> </li><li>  <a href="http://www.dsplib.ru/content/win/win.html">www.dsplib.ru/content/win/win.html</a> </li><li>  <a href="http://www.studfiles.ru/dir/cat32/subj116/file1543/view2417.html">www.studfiles.ru/dir/cat32/subj116/file1543 / view2417.html</a> </li><li>  <a href="http://chimera.labs.oreilly.com/books/1234000001552/ch04.html">chimera.labs.oreilly.com/books/1234000001552/ch04.html#s04_2</a> </li><li>  <a href="http://analogiu.ru/6/6-5-2.html">analogiu.ru/6/6-5-2.html</a> </li><li>  <a href="http://www.html5rocks.com/ru/tutorials/getusermedia/intro/">www.html5rocks.com/ru/tutorials/getusermedia/intro</a> </li><li>  <a href="http://html5.by/blog/audio/">html5.by/blog/audio</a> </li><li>  <a href="https://sites.google.com/site/mikescoderama/pitch-shifting">sites.google.com/site/mikescoderama/pitch-shifting</a> </li></ul><br>  PS Testing was conducted in Chrome and Opera browsers, so that everything will work optimally in them.  In the rest, various errors may appear (which I will try to eliminate in a timely manner).  In IE, you can not even look. </div><p>Source: <a href="https://habr.com/ru/post/211905/">https://habr.com/ru/post/211905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211889/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ95 (February 2 - 8, 2014)</a></li>
<li><a href="../211891/index.html">Unfulfilled hopes: what was planned and what happened in the program ‚ÄúSpace Shuttle‚Äù</a></li>
<li><a href="../211893/index.html">Homemade curtain drive</a></li>
<li><a href="../211899/index.html">Features of MVP implementation for Windows Forms</a></li>
<li><a href="../211903/index.html">This is our world</a></li>
<li><a href="../211909/index.html">Forwarding a video card to a guest OS from a KVM hypervisor using VFIO technology</a></li>
<li><a href="../211911/index.html">Watch the Olympics using IPTV</a></li>
<li><a href="../211913/index.html">Screw ActiveRecord to the site</a></li>
<li><a href="../211915/index.html">Virtualization with OpenVZ</a></li>
<li><a href="../211917/index.html">Data backup with btrfs and LVM bash scripts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>