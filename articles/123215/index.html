<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automation through integration. Promotional version. UPD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Upd : added skinshots. 

 The Software Engineering Forum 2011 took place in Minsk on May 19-20. We gave a talk ‚ÄúA New Test Automation Level‚Äù, or the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automation through integration. Promotional version. UPD</h1><div class="post__text post__text-html js-mediator-article">  <b>Upd</b> : added skinshots. <br><br>  The Software Engineering Forum 2011 took place in Minsk on May 19-20. We gave a talk ‚ÄúA New Test Automation Level‚Äù, or the alternative long version - ‚ÄúAutomation automation‚Äù of automated testing through the integration of test tools.  In it, we opened up three main questions: <br><ol><li>  The levels of test automation in the organization. </li><li>  The main points that you should pay attention to test automation (based on your own experience and the experience of colleagues, as well as the results of surveys). </li><li>  Prototype solution for automated test management (based on the internal development of Octopus). </li></ol><br>  Under the cut - the content of the report, a link to the promotional version of Octopus.  Long post. <a name="habracut"></a><br><br><h4>  1. Levels of test automation </h4><br>  Based on our own experience in introducing automated tests, on the experience of colleagues from other companies with whom we spoke during the QA conferences, as well as on the data of our surveys, we identified three main stages through which the company passes on the way to test automation. <br><img src="https://habrastorage.org/storage1/bd46db84/e7418a07/58a1b221/0727fd9b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  A. Stage of origin (I) </h6><br>  Along with manual testing, companies are starting to use: <br>  - scripts that copy the setup of the test product, install it and partially test it; <br>  - tests written in any development environment of automatic tests. <br><br>  <i>Stage Characteristics</i> <br><ul><li>  Actions associated with automated testing are performed manually (running scripts and tests, working with virtual machines, etc.). </li><li>  The lack of a clear organization of test storage (as a rule, tests are stored on the tester's machine, used only by them, that is, they are not reusable and adaptable to changes in the tested interfaces). </li><li>  There is no systematization of test launches and control over their execution (they can run tests, but they can also forget). </li><li>  Between testers and developers there is no information flow about the status of the build test. </li><li>  As a rule, there is no complete confidence in the tests.  However, tests and scripts significantly release the tester's resource. </li></ul><br>  This stage is peculiar to, first of all, companies with short-term projects, which is why they simply do not have time to bring automated testing to a new level.  At this stage, there are also organizations that only implement automated tests in their software quality control processes, and small firms that do not clearly describe the testing processes. <br><br><h6>  B. Conscious Stage (I + II) </h6><br>  Along with the automation of the tests themselves, some part of the process is also automated. <br><br>  <i>Stage Characteristics</i> <br><ul><li>  Organization of centralized storage and reuse of tests (function library) appears. </li><li>  The naming convention for automatic tests comes into force. </li><li>  Most actions are automated: running tests, starting / stopping virtual machines (in the case of using virtualization), copying the necessary configuration files to a test machine, etc. </li><li>  The quality of the tests themselves is improved. </li><li>  Running tests are systematized and automated with the release of each product assembly. </li><li>  Clearly defined behavior in the processing of test results - the creation / closure of bugs. </li></ul><br>  This is one of the most popular stages.  It is typical for companies that have established the testing process as such and are working on medium-term and long-term projects.  Those.  we are talking about organizations that need to conduct regression testing of the product. <br><br><h6>  C. Advanced level (I + II + III) </h6><br>  Stage "automation of automated testing."  Tautology is used intentionally to express the idea that <i><b>all</b></i> operations of the automated testing cycle are carried out without the tester's participation - from preparing the environment and running tests on the released build to registering errors in the bug-tracking system (BTS - bug tracking system) create reports.  As a rule, this is achieved with the help of scripts and configuration files, and they are less often invested in the development of an integrated automated test management system. <br><br>  <i>Stage Characteristics</i> <br><ul><li>  All operations associated with running autotests are ‚Äúautomated‚Äù: environment configuration, virtual machine startup, execution tests, bug registration, reporting creation. </li><li>  The creation of errors (if appropriate, the closure of corrected ones) in the control system occurs automatically according to all the rules adopted by the company, with the appointment of a responsible person and filling in the specified fields in the BTS. </li><li>  Various "gadgets" to increase the efficiency of testing: the creation of groups of tests to run simultaneously, grouping virtual machines according to certain criteria (Axis, installed programs, localization, etc.). </li><li>  Single interface for parameterization of test execution (rarely found). </li></ul><br>  First of all, companies developing complex software products with wide functionality, with medium and long-term projects, and acutely feeling the problem of lack of high-quality and timely regression testing, strive to achieve this stage. <br>  About 12.5% ‚Äã‚Äãof respondents to <a href="http://habrahabr.ru/blogs/testing/120981/">our survey, conducted among Habrozhiteley,</a> said that their company is at this stage. <br>  Unfortunately, there is no way to clarify how automated test-based parameterization takes place through a single UI, using config files, etc.  The idea to ask such a question came after more than 100 answers had been received, and there was no point in adding it.  But we included it in an English-language <a href="http://www.surveymonkey.com/s/automated_testing">survey for members of QA-communities on LinkedIn</a> (see chart below). <br><br>  The above classification is the result of our experience, and does not claim to be the only correct one.  I wonder how your vision <s>does not</s> coincide with ours? <br><br><h5>  Some lyrics, or difficulties with regression testing </h5><br>  It is no secret that regular regression testing of new builds ensures consistently high quality of the final product.  But due to limited resources, regression testing is often neglected, or it is not fully implemented. <br>  Five years ago, our company was faced with this problem.  The number of errors found on the customer‚Äôs side has exceeded all standards of decency.  The product is a complex desktop system for the automotive industry, consisting of many agents, modules and components.  Every month, the application acquired new features, and the testers managed to check the new functionality and only some part of the old one.  Despite the close cooperation between developers and testers, the system ‚Äúfell‚Äù in places where no one expected. <br>  It became obvious that the testing processes must be brought to a new level. <br>  Began to facilitate the work of autotests, scripts and batch files.  This allowed regression testing to be carried out faster and in greater volume.  However, the introduction of automated testing hid a lot of problems that we did not anticipate initially.  In fact, we briefly touched on some of them in the description of the stages of automation, but now we will consider more thoroughly. <br><br><h4>  2. Problems in the way of test automation </h4><br><h6>  <i>A. Incomplete automation</i> </h6><br>  The expression "automated testing" is to some extent conditional.  Often, the tester performs many tasks manually: prepares the environment, uploads a new version of the product, drags configuration files, runs autotests on different Axes, registers defects in the BTS, etc.  This is easy, but time consuming, and also increases the likelihood of errors due to the human factor. <br><img src="https://habrastorage.org/storage1/53499635/682f6592/75da0d41/1fa0d17d.png"><br><br>  Sometimes the loss of time can be significant.  For example, in the case of Data Driven tests, where every single result is important, so the number of bugs that need to be entered into the defect control system can be huge.  On average, an experienced specialist creates a bug in BTS with filling in all the required fields a little more than 1 minute, closing - about 15 seconds (*).  These labor-intensive activities have low added value, and the time spent on their execution can be more effectively utilized by exploiting the testers' intellectual potential, for example, writing new tests. <br><br>  <i>(*) The measurements were carried out under the following conditions:</i> <i><br></i>  <i>1. Defect control systems - MS TFS, Mantis, Bugzilla.</i> <i><br></i>  <i>2. Experimenters: 2 testers with 4 years of experience.</i> <i><br></i>  <i>During the experiment, 10 bugs were created with the following required fields:</i> <i><br></i>  <i>MS TFS: Title, AssignTo, Iteration, Area, Tester, FoundIn, Severity.</i> <i><br></i>  <i>Mantis: Category, Summary, Description, Platform, OS, Severity.</i> <i><br></i>  <i>Bugzilla: Component, Version, Summary, Description, Severity, Assignee.</i> <i><br></i>  <i>The time spent opening a BTS was also taken into account.</i> <br><br><h6>  <i>B. Lack of a convenient and flexible test management tool</i> </h6><br>  Even if the company is at an advanced stage of test automation, they rarely have a common interface for managing all tasks related to automated testing.  Most often, parameterization occurs through config files (50% of respondents), which are often not validated.  As a result, the number of errors increases and the effectiveness of automated testing as a whole decreases. <br>  LinkedIn user survey results: <br><img src="https://habrastorage.org/storage1/29437779/19e6e5ba/2445187e/a19d87ed.png"><br><br><h6>  <i>C. Extensibility and Scalability of the Architecture</i> </h6><br>  Often, when starting to develop an automated testing management system, a company focuses on the tools that are currently used, without providing for scalability and scalability of the system. <br>  The disadvantages of this approach are obvious.  If the company has updated the BTS version or decided to add a new type of virtualization servers, or starts using new types of tests, you will have to invest significant resources in customizing the system and integrating it with new tools. <br>  A similar situation develops when the scalability is not embedded in the system architecture: as the product acquires functionality, the number of automatic tests increases, and a rational distribution of virtualization resources is required.  Building a pool of virtual servers leads to an increase in efforts to support the test automation system and manage individual elements. <br><br><h6>  <i>D. Lack of cumulative reporting uniform format</i> </h6><br>  As a rule, each type of test (for example, written in Visual Studio, HP QTP, etc.) provides a report on the results in its own (native) format, and in order for it to be viewed by the project manager or customer, they must have the appropriate software installed.  Although some automated test development environments allow you to export these results, for example, to HTML reports that anyone can see, they all differ in shape and structure, which complicates the perception of information.  In addition, after running the necessary tests on virtual or physical machines, we receive several packs of reports, each of which must be viewed separately. <br>  The word ‚Äúcumulative‚Äù means the accumulation of results as you pass the tests in a single document.  Thus, a ‚Äúcumulative report in a single format‚Äù means the creation of a single general report that is constantly updated as new test results become available and ensures the relevance of the information. <br><br>  <i>An example of a common HTML report for all tests</i> <br><img src="https://habrastorage.org/storage1/130ab8b9/d55d595e/3c154cbe/775280d8.png"><br><br><h6>  <i>E. Trouble-free process</i> </h6><br>  A system that controls automated testing is essentially a pipeline.  New assemblies for testing are sent to the input, and the output is the result in the form of generated bugs and reports.  Developing such a system, we are faced with the problem of lack of protection from the "fool".  That is, if one of the tests was written with an error, it could be executed by the system indefinitely and loaded the resource as a virtual or real machine, thereby preventing the tests in the execution queue from being expensive.  This problem can be solved in different ways;  we implemented the "timeout kill" feature (interrupting the execution of long-running commands). <br><br><h6>  <i>F. Insufficient system logging</i> </h6><br>  The lack of logging complicates the process of debugging errors.  Often, only some parts of the test automation system have logs, for example, only tests.  At the same time, there is no recording of virtual machine events, creating bugs, reports, etc.  This makes the system opaque and difficult to track its operations and reduces the efficiency of the process as a whole. <br><br><h5>  3. Solution for automated test management </h5><br>  Considering the moments about which we ‚Äúmade bumps‚Äù and described above, we gradually, step by step, developed a system that would autonomously control the entire automated testing cycle 24 hours a day - from preparing the environment and running tests to registering defects and creating reports. <br>  It is worth emphasizing separately that this is not about creating your own bug-tracking system or scripting environment.  The solution is an integrator that combines already existing test tools into a single system with a common interface.  The test toolkit means different software for testing and managing projects: build system, version control system, bug tracking system, virtualization system and test development environment. <br>  Initially, we studied the basic interactions of testers with each of these tools, then the APIs of the latter.  Finally, they were integrated all together under a common UI, which allows you to conveniently and quickly configure the system in accordance with the rules and processes existing in the company. <br>  The main development of the management system, which was later called Octopussy in honor of 8 main features, was completed 1.5-2 years ago. Since then, we have not had a headache about the lack of resources for regression testing, and the quality of the produced software has significantly increased.  In effect, it feels like we additionally hired 5 testers. <br>  We customize the automated testing process using 5 tabs: Builds, Machines, Manual Start, Queue, Log.  On each tab, the setting of the corresponding elements is fully implemented, and the Log allows you to monitor what is happening in every corner of the system. <br><br>  <i>Screenshots examples</i> <br>  Tabs "builds" <br><img src="https://habrastorage.org/storage1/125e1be8/3e826b95/5b2986ae/ac8d4d78.png"><br><br>  The ‚ÄúCars‚Äù tab <br><img src="https://habrastorage.org/storage1/a59a2a26/5dd47de2/2916661f/978fc4fa.png"><br><br>  Tab "Queue" <br><img src="https://habrastorage.org/storage1/0686332d/3c503159/2d0eee9d/c34fc3df.png"><br><br><h6>  The main features of the Octopus control system </h6><br>  1. Starts virtual machines (VM) in the case of virtualization when testing. <br>  2. Prepares the test environment: copies configuration files and autotests to the testing machine, installs the product. <br>  3. Puts successful builds into the testing queue according to the build priority. <br>  4. Runs automated tests / test groups on a schedule or on an event of a successful release of the assembly. <br>  5. Tests on ‚Äúclean‚Äù VMs, certain snapshots and on physical machines. <br>  6. Registers detected errors in BTS, fills in fields assigned by the tester (for example, Title, Assigned to, State, Description, Found in, Reviewer / Tester, Severity, etc.). <br>  7. Closes fixed bugs, if allowed by the operator. <br>  8. Generates a general report for all passed tests in HTML. <br>  The tester loads the automatic tests into the database of the integrated system, once sets its settings for a specific project, and it independently tests each new product build in non-stop mode. <br>  In this video (3 min.), It is shown how the system automatically starts testing the assembled build. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/NgLDrQPAB2Y%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhhaBbrn34HegRXvhswhZDAThobDHg" frameborder="0" allowfullscreen=""></iframe><br><br><h6>  Octopus system structure </h6><br>  The solution consists of three modules: <br>  <b>The automatic test manager</b> is a server component that controls the entire system. <br>  <i>Implementation technology:</i> Windows Service in C # for the .NET Framework v3.5 platform. <br>  <i>Resource Consumption:</i> <br>  CPU: practically does not load <br>  RAM: ~ 50 MB <br>  Network: at the start and completion of tasks it is fully occupied - the environment is downloaded to the virtual machine and the results are received <br><br>  <b>Automatic Test Launch Agent</b> - a module that directly runs tests on builds on a virtual or physical testing machine, sets up an environment, and sends a file with test results to the Automatic Test Manager. <br>  <i>Implementation technology:</i> console application in C ++. <br>  <i>Resource Consumption:</i> <br>  CPU: not used during test execution <br>  RAM: ~ 7 MB <br><br>  <b>The Automated Testing Control Panel</b> is the client part providing the Octopus user interface.  Through it, you can conduct a comprehensive setup of test execution, manage resources (virtual machines), view the current test execution status and event log, and, if necessary, manually start and stop tests. <br>  <i>Implementation technology:</i> desktop and web application on C # under the Microsoft Silverlight platform. <br>  <i>Resource Consumption:</i> <br>  Size: ~ 0.5 MB <br>  RAM: ~ 30 MB <br><br><h6>  System requirements </h6><br>  OS: Windows XP / Vista / 7, Windows Server 2003/2008 <br>  CPU: 1.0 GHz <br>  RAM: 512 MB <br>  Hard Drive: 4 MB <br><br>  As the system developed as a project for internal needs, we initially integrated it with the testing products used in our company. <br>  When the thought came that, probably, a similar system might be useful to someone else, the list was expanded to include free software. <br><br>  At the moment the list looks like this: <br><br>  <b>Virtualization systems:</b> VMware Server 2.0 *, Hyper-V. <br>  <b>Build Systems:</b> CruiseControl.NET *, Microsoft Team Foundation Server 2008/2010. <br>  <b>Version Control Systems:</b> SVN *, Microsoft Team Foundation Server 2008/2010. <br>  <b>Error control systems:</b> Mantis Bug Tracker *, Bugzilla *, Microsoft Team Foundation Server 2008/2010. <br>  <b>Test development environments:</b> AutoIt *, Microsoft Visual Studio, HP QTP. <br>  <i>(*) - free software.</i> <br><br>  The system is customized for commercial and free with open API.  In the near future - to ‚Äúscrew‚Äù the bug-tracking system Jira. <br><br><h5>  Free promotional version </h5><br>  We made a free promotional version of the Octopus application based on free software.  We chose freeware, so that if desired, everyone can try it in action. <br>  More information on this page: <a href="http://www.appsys.net/Octopus/Download/Ru">www.appsys.net/Octopus/Download/Ru</a> . <br>  Waiting for your questions and comments. </div><p>Source: <a href="https://habr.com/ru/post/123215/">https://habr.com/ru/post/123215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123208/index.html">Please finally shoot these tags!</a></li>
<li><a href="../123209/index.html">Court and EMS</a></li>
<li><a href="../123210/index.html">Opera Extension: Radio</a></li>
<li><a href="../123213/index.html">Ricoh bought Pentax</a></li>
<li><a href="../123214/index.html">Inviter: how to remove topics with 1500+ comments about invites</a></li>
<li><a href="../123216/index.html">More about Python descriptors</a></li>
<li><a href="../123217/index.html">Competition from iLab: prize - Playbook!</a></li>
<li><a href="../123219/index.html">One-two-three-four-five, I am going to present</a></li>
<li><a href="../123220/index.html">The play "Developing a multiplayer online game." Part 1: Architecture</a></li>
<li><a href="../123221/index.html">Solaris Container (zone). Creation and administration. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>