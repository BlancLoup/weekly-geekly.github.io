<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write really tested code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is test code? What rules should be followed to write it? How to start writing such code if the code base is not ready for this? 

 An article wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write really tested code</h1><div class="post__text post__text-html js-mediator-article">  What is test code?  What rules should be followed to write it?  How to start writing such code if the code base is not ready for this? <br><br>  An article with a large number of code examples and illustrations, based on Anton‚Äôs speech at the <a href="https://mobiusconf.com/">Mobius 2017</a> conference in St. Petersburg.  Anton is a developer of Android applications in Juno, and in his work touches on a variety of related technologies.  This report is not about Android and not about Kotlin, it is about testing in general, about ideas that lie above the platform and above the language and that can be adapted to any context. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/c5ExGryXXos" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Why do we need tests? </h2><br>  First you need to decide on why we are writing or want to write tests for your code.  There can be several reasons: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  To gain confidence in the code; <br></li><li>  For the preparation of documentation; <br></li><li>  To sleep well after refactoring; <br></li><li>  To write code faster; <br></li><li>  To show off to colleagues. <br></li></ul><br>  And, perhaps, the most important reason is <i>that the project can live and develop for a long time</i> (that is, change).  Development refers to adding new features, correcting errors, and refactoring. <br><br>  As our code base grows, the chances of making a mistake increase because the base becomes more complex.  And when it goes into production, the cost of the error increases.  As a result, there is often a fear of modifications, which is very difficult to fight. <br><br>  Here are two global tasks that we solve when we write a long-lived project: <br><br><ul><li>  Managing the complexity of the system, that is, how to make the system as simple as possible for a given business requirements; <br></li><li>  Testing system (today we are talking about this). <br></li></ul><br><h2>  What is test code? </h2><br>  What can go wrong when trying to write a test?  Often the system just is not ready for this.  It can be so connected with the adjacent parts that we cannot set any input parameters to check that everything is working correctly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0da/465/d170da465bf055e438e041492498c868.png"><br><br>  To avoid such situations, you need to write the code correctly, that is, to make it testable. <br><br>  What is test code?  To answer this question, you first need to understand what a test is.  Let's say there is a system that needs to be tested (SUT - System Under Test).  Testing is the transfer of some input data and validation of the results for expected ones.  The tested code means that we have full control over the input and output parameters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/620/247/879/62024787926370dc977161cbe4fa1bc8.png"><br><h2>  Three rules for writing test code </h2><br><br>  To make the code testable, it is important to adhere to three rules.  Let's look at each of them in detail in the examples. <br><br><h3>  Rule 1. Pass arguments and return values ‚Äã‚Äãexplicitly. </h3><br>  Let's look at testing a function (a certain function in vacuum, which takes N arguments and returns a certain number of values): <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Arg</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">Arg</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[N]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>ÀÉ (<span class="hljs-selector-tag"><span class="hljs-selector-tag">R</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">R</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[L]</span></span>)</code> </pre> <br>  And there is a function that is not clean: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextItemDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String { GLOBAL_VARIABLE++ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$prefix</span></span></span><span class="hljs-string">: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$GLOBAL_VARIABLE</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Consider the inputs here.  First, the prefix, which is passed as an argument.  Also the input is the value of the global variable, because it also affects the result of the function.  The result of the function is the return value (string), as well as an increase in the global variable.  This is the way out. <br><br>  Schematically, it looks like the figure below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ca/c17/e6b/5cac17e6b357325d7930703c483d2b18.png"><br><br>  We have inputs (explicit and implicit) and outputs (explicit and implicit).  To make a pure function from such a function, it is necessary to remove the implicit inputs and outputs.  In this case, it is controlled by testing.  For example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, itemIndex: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$prefix</span></span></span><span class="hljs-string">: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$itemIndex</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  In other words, it is easy to test a function if all its inputs and outputs are passed explicitly, that is, through a list of arguments and return values. <br><br><h3>  Rule 2. Pass dependencies explicitly </h3><br>  In order to understand the second rule, I suggest thinking of the module as a function.  Suppose a module is a function whose call is extended in time, that is, part of the input parameters are transferred at some time, part in the next line, part after some time-out, then some other part and t .d  And the same with exits: part now, part later, etc. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">M</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">In</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">In</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[N]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>ÀÉ (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Out</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">Out</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[L]</span></span>)</code> </pre><br>  How could the ins and outs of such a function module look like?  Let's try first to look at the code, and then we will do a more general picture: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String <span class="hljs-comment"><span class="hljs-comment">//input ){}</span></span></code> </pre><br>  The very fact of calling such a class constructor is the input of our function, and passing a string to the output is obviously also an input.  The fact of calling some method of our class will also be the input of the function, because our result will depend on whether the method is called or not. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String <span class="hljs-comment"><span class="hljs-comment">// input ){ fun doSomething() { // input // ‚Ä¶ } }</span></span></code> </pre><br>  Getting some value from an explicit dependency is also an input.  I call a dependency explicit if it was passed through a module API before use. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Module</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Explicit</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class"> ){ fun doSomething() { // input val explicit = dependency.getCurrentState() //input // ‚Ä¶ } }</span></span></code> </pre><br>  Getting some input from an implicit dependency is also an input. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Module</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Explicit</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class"> ){ fun doSomething() { // input val explicit = dependency.getCurrentState() //input val implicit = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Implicit</span></span></span><span class="hljs-class">.getCurrentState() //input // ‚Ä¶ } }</span></span></code> </pre><br>  Let's go to the exits.  Returning a value from a field is a way out.  Modifying this value is the output of the function, since we can then test it from the outside. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>( ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-string"><span class="hljs-string">"Some state"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { state = <span class="hljs-string"><span class="hljs-string">"New state"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output // ‚Ä¶ } }</span></span></code> </pre><br>  Modification of some external state is also the way out.  It can be explicit, like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Explicit</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dependency</span></span></span><span class="hljs-class"> )</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-string"><span class="hljs-string">"Some State"</span></span> fun doSomething() { state = <span class="hljs-string"><span class="hljs-string">"New State"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output dependency.setCurrentState("New state") //output // ‚Ä¶ } }</span></span></code> </pre><br>  Or implicit, like this: <br><br><pre> <code class="hljs lua">class Module( val dependency: Explicit // dependency ){ var state = <span class="hljs-string"><span class="hljs-string">"Some state"</span></span> fun doSomething() { state = <span class="hljs-string"><span class="hljs-string">"New state"</span></span> // <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> dependency.setCurrentState(<span class="hljs-string"><span class="hljs-string">"New state"</span></span>) //<span class="hljs-built_in"><span class="hljs-built_in">output</span></span> Implicit.setCurrentState(<span class="hljs-string"><span class="hljs-string">"New state"</span></span>) //<span class="hljs-built_in"><span class="hljs-built_in">input</span></span> // ‚Ä¶ } }</code> </pre><br>  Now let's summarize. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], ‚Ä¶ , <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[N]</code> </pre><br>  The inputs of such a function module can be: <br><br><ul><li>  Interactions with the module API and its dependency API; <br></li><li>  The values ‚Äã‚Äãthat we convey in them; <br></li><li>  The order in which we did these interactions; <br></li><li>  The time between these interactions. <br></li></ul><br>  Approximately the same with exits: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], ‚Ä¶ , <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>[N]</code> </pre><br>  The outputs of the function module can be: <br><br><ul><li>  Interactions with the module API and its dependency API; <br></li><li>  The values ‚Äã‚Äãthat we convey in them; <br></li><li>  The order in which we did these interactions; <br></li><li>  The time between these interactions; <br></li><li>  Modification of a certain state of the module, which can then be observed, obtained from outside. <br></li></ul><br>  If we define a module in this way, then we see that the process of testing a module, that is, a test written for this module, is a call to this function and validation of results.  That is what we write in the given and when blocks (if we use the given and the annotation), this is the process of calling functions, and then the process of validating the results. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c5/756/08c/8c575608c40324c3419d22121a81a550.png"><br><br>  Thus, a module becomes simple for testing if all its inputs and outputs are passed either through the module API, or through the API of its explicit dependencies. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">M</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">In</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">In</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[N]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>ÀÉ (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Out</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, ... , <span class="hljs-selector-tag"><span class="hljs-selector-tag">Out</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[L]</span></span>)</code> </pre><br><h3>  Rule 3. Control dependency substitutability in tests </h3><br>  Even with explicit arguments and explicit dependencies, we still do not get complete control, and here's why. <br><br>  For example, in the module there is an explicit dependency.  The module does nothing but multiply it by three and write to some field. <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Module(<span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Explicit</span></span>) { val tripled = <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>.getValue() }</code> </pre><br>  We write a test for it: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>(explicit: Explicit) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tripled = <span class="hljs-number"><span class="hljs-number">3</span></span> * explicit.getValue() } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testValueGetsTripled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre><br>  Somehow we prepare our module, take the value of the Tripled field from it, write it to the result, expect it to be 15, and check that 15 equals the result: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>(explicit: Explicit) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tripled = <span class="hljs-number"><span class="hljs-number">3</span></span> * explicit.getValue() } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testValueGetsTripled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// prepare Explicit dependency val result = Module( ??? ).tripled val expected = 15 assertThat(result).isEqualTo(expected) }</span></span></code> </pre><br>  The biggest question is, how do we prepare our obvious dependency in order to say that it returns the top five and we need to get 15 as a result?  It strongly depends on what the apparent dependence is. <br><br>  If an obvious dependency is a singleton, then in tests we cannot say to him: ‚ÄúReturn the top five!‚Äù, Because the code is already written, and we cannot modify the code in the tests. <br><br><pre> <code class="hljs lua">// <span class="hljs-string"><span class="hljs-string">'object'</span></span> stands <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Singleton <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Kotlin object Explicit { fun getValue(): Int = ... }</code> </pre><br>  Accordingly, the test does not work for us - we cannot transfer there a normal dependency. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> stands <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Singleton <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Kotlin object Explicit { fun getValue(): Int = ... } @Test fun testValueGetsTripled() { val result = Module( ??? ).tripled val expected = <span class="hljs-number"><span class="hljs-number">15</span></span> assertThat(result).isEqualTo(expected) }</code> </pre><br>  The same with final classes - we cannot modify their behavior. <br><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">Classes</span></span> are final by <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> in <span class="hljs-type"><span class="hljs-type">Kotlin</span></span> <span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">Explicit</span></span> { fun getValue(): <span class="hljs-type"><span class="hljs-type">Int</span></span> = ... } @<span class="hljs-type"><span class="hljs-type">Test</span></span> fun testValueGetsTripled() { val result = <span class="hljs-type"><span class="hljs-type">Module</span></span>( ??? ).tripled val expected = 15 assertThat(<span class="hljs-title"><span class="hljs-title">result</span></span>).isEqualTo(<span class="hljs-title"><span class="hljs-title">expected</span></span>) }</code> </pre><br>  The last and good case, when an explicit dependency is an interface that has some implementation: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Explicit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Explicit { override fun getValue</span></span></span></span>(): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = ... } }</code> </pre><br>  Then we can already prepare this interface in the test, create a test implementation that will return the top five, and finally pass it to our module class and run the test. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testValueGetsTripled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mockedExplicit = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Explicit { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = Module(mockedExplicit).tripled <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expected = <span class="hljs-number"><span class="hljs-number">15</span></span> assertThat(result).isEqualTo(expected) }</code> </pre><br>  Sometimes functions are private, and here you need to look at what a private implementation is, and make sure that there are no implicit dependencies in it, that nothing comes from singletons, or from some implicit places.  And then, in principle, there should be no problems in order to test the code through a public API.  That is, if the public API fully describes the inputs and outputs (there are no others), then the public API is enough de facto. <br><br><h2>  Three rules for writing test code in practice </h2><br>  It's hard for me to imagine the code under test without some kind of architecture, so I‚Äôll use MVP as an example.  There is a user interface, a View layer, models where business logic is conditionally assembled, a layer of platform adapters (designed to isolate models from the API), as well as platform APIs and third-party APIs that are not related to the user interface. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fc/9b8/cd4/5fc9b8cd49a126937f572ea9544e0b8c.png"><br><br>  We test here Model and Presenter, because they are completely isolated from the platform. <br><br><h3>  What are the obvious inputs and outputs </h3><br>  We have a class and a variety of explicit inputs: a line at the input, lambda, Observable, method call, as well as all the same, made through an explicit dependency. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleInputs</span></span></span></span>( input: String, inputLambda: () -&gt; String, inputObservable: Observable&lt;String&gt;, dependency: Explicit ) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someField = dependency.getInput() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { } }</code> </pre><br>  The situation with exits is very similar.  The output can be the return of a value from a method, the return of a value through a lambda, through the Observable, and through an explicit dependency: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleOutputs</span></span></span></span>( outputLambda: (String) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, dependency: Explicit ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputObservable = Observable.just(<span class="hljs-string"><span class="hljs-string">"Output"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"Output"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>{ outputLambda(<span class="hljs-string"><span class="hljs-string">"Output"</span></span>) dependency.passOutput(<span class="hljs-string"><span class="hljs-string">"Output"</span></span>) } }</code> </pre><br><h3>  What implicit inputs and outputs look like and how to convert them to explicit </h3><br>  Implicit inputs and outputs can be: <br><br><ol><li>  Singletons </li><li>  Random number generators </li><li>  File system and other storage </li><li>  Time </li><li>  Formatting and locale </li></ol><br>  Now about each of them in more detail. <br><br><h3>  Singletons </h3><br>  We can not modify the behavior of singletons in tests. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-type"><span class="hljs-type">Implicit</span></span>.getCurrentState() }</code> </pre><br>  Therefore, they need to endure as an obvious dependence: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">dependency: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Explicit</span></span></span></span></span><span class="hljs-class">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = dependency.getCurrentState() }</code> </pre><br><h3>  Random number generators </h3><br>  In the example below, we do not call singleton, but create an object of the class random.  But here he is already jerking inside some static methods that we cannot influence in any way (for example, the current time). <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fileName = <span class="hljs-string"><span class="hljs-string">"some-file</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Random().nextInt()}</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Therefore, such services that we do not control, it makes sense to make the interfaces that we could control. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span></span>(rng: Rng) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fileName = <span class="hljs-string"><span class="hljs-string">"some-file</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Random(rng.nextInt()}</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br><h3>  File system and other storage </h3><br>  We have a certain module which initializes storage.  All he does is create a file in some way. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { File(path).createNewFile() } }</code> </pre><br>  But this API is very cunning: it returns true when successful, and false if it contains the same file.  And we, for example, need not just to create a file, but also to understand: whether it was created or not, and if not, for what reason.  Accordingly, we create a typed error and want to return it to the output.  Or, if there is no error, return null. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: FileCreationError? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File(path).createNewFile()) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileCreationError.Exists } } }</code> </pre><br>  In addition, this API throws two exceptions.  We fetch them and, again, return typed errors. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: FileCreationError? = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File(path).createNewFile()) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileCreationError.Exists } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: SecurityException) { FileCreationError.Security(e) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { FileCreationError.Other(e) } }</code> </pre><br>  Ok, processed.  And now we want to test.  The problem is that creating a file is a thing that has side effects (that is, it creates a file in the file system).  Therefore, we need to either somehow prepare the file system, or make everything that has side effects behind the interfaces. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fileCreator: FileCreator){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: FileCreationError? = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileCreator.createNewFile(path)) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileCreationError.Exists } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: SecurityException) { FileCreationError.Security(e) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { FileCreationError.Other(e) } }</code> </pre><br><h3>  Time </h3><br>  It is not immediately obvious that this is the entrance, but we have already figured out above that this is so. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Module { private val nowTime = <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>.TimeMillis() private val nowDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>() // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> other <span class="hljs-type"><span class="hljs-type">time</span></span>/<span class="hljs-type"><span class="hljs-type">date</span></span> APIs }</code> </pre><br>  For example, in the module there is a logic that waits for half a minute.  If you plan to write a test for it, you do not want the test to wait half a minute, because all unit tests should take a total of half a minute.  We want to be able to control time, so, again, all the work over time makes sense for the interface, so that it is one point in the system, and you would understand how you work with time and if necessary could turn the time forward or even backward. .  Then you can, say, test how your module behaves if you change the clock. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Module (<span class="hljs-type"><span class="hljs-type">time</span></span>: TimeProvider) { private val nowTime = <span class="hljs-type"><span class="hljs-type">time</span></span>.nowMillis() private val nowDate = <span class="hljs-type"><span class="hljs-type">time</span></span>.nowDate() // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> other <span class="hljs-type"><span class="hljs-type">time</span></span>/<span class="hljs-type"><span class="hljs-type">date</span></span> APIs }</code> </pre><br><h3>  Formatting and locale </h3><br>  This is the most insidious implicit input.  Say, a regular Presenter takes some time stamp, formats it according to a strictly defined template (no AM or PM, no commas, everything seems to be specified) and stores in the field: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTimePresenter(<span class="hljs-type"><span class="hljs-type">timestamp</span></span>: Long) { val formattedTimestamp = SimpleDateFormat("yyyy-MM-dd HH:mm").format(<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) }</code> </pre><br>  We write a test for it.  We don‚Äôt want to think about what it is like in a formatted form, it‚Äôs easier for us to launch a module on it, see what it outputs to us, and write it here. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTimePresenter</span></span></span></span>(timestamp: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formattedTimestamp = SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm"</span></span>).format(timestamp) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mobiusConfStart = <span class="hljs-number"><span class="hljs-number">1492758000L</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expected = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> = MyTimePresenter(timestamp).formattedTimeStamp assertThat(<span class="hljs-keyword"><span class="hljs-keyword">actual</span></span>).isEqualTo(expected) }</code> </pre><br>  We saw that Mobius begins on April 21 at 10 am: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTimePresenter</span></span></span></span>(timestamp: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formattedTimestamp = SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm"</span></span>) .format(timestamp) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mobiusConfStart = <span class="hljs-number"><span class="hljs-number">1492758000L</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expected = <span class="hljs-string"><span class="hljs-string">"2017-04-21 10:00"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> = MyTimePresenter(timestamp).formattedTimeStamp assertThat(<span class="hljs-keyword"><span class="hljs-keyword">actual</span></span>).isEqualTo(expected) }</code> </pre><br>  Ok, we start it on the local machine, everything works: <br><br><pre> <code class="hljs cs">&gt;&gt; `actual <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> dev machine` = <span class="hljs-string"><span class="hljs-string">"2017-04-21 10:00"</span></span> <span class="hljs-comment"><span class="hljs-comment">// UTC +3</span></span></code> </pre><br>  We run it on CI, and for some reason there Mobius starts at 7. <br><br><pre> <code class="hljs cs">&gt;&gt; `actual <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> CI` = <span class="hljs-string"><span class="hljs-string">"2017-04-21 07:00"</span></span> <span class="hljs-comment"><span class="hljs-comment">// UTC</span></span></code> </pre><br>  CI is a different time zone.  It is in the UTC + 0 time zone and, accordingly, time is formatted differently there, because SimpleDateFormat uses the default time zone.  In the tests, we did not redefine it, respectively, in CI servers that are at zero GMT, we have another way out.  And this insidious all the entrances that are associated with the location, including: <br><br><ul><li>  Currency <br></li><li>  Number format <br></li><li>  Timezone <br></li><li>  Localee <br></li></ul><br><h3>  How to mock dependencies in tests </h3><br>  They say that there is no ‚Äúsilver bullet‚Äù, but it seems to me that it is relative to mocking.  Because interfaces work everywhere.  If you hid your implementation behind the interface, you can be sure that you can replace it in the tests, because the interfaces are replaced. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span></span>(): MyService { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestService</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyService { override fun doSomething</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mockService = mock&lt;MYService&gt;()</code> </pre><br>  Interfaces even sometimes help to do something with singletons.  Let's say the project has a singleton, which is a GodObject.  You can not disassemble it into several separate modules at once, but you want to slowly introduce some kind of DI, some kind of testability.  To do this, you can create an interface that will repeat the public API of this singleton or a part of the public API and make it so that the singleton implements this interface.  And instead of using a singleton in the module, you can pass this interface as an explicit dependency.  Outside, of course, it will be the transfer of the same GetInstance, but inside you will already be working with a clean interface.  This can be an intermediate step, until everything is switched to modules and DI. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Implicit: StateProvider { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"State"</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeModule</span></span></span></span>(stateProvider: StateProvider) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = StateProvider.getCurrentState() } }</code> </pre><br>  There are, of course, other alternatives.  I said above that you cannot mock final classes, static methods, singletons.  Of course, you can mock them: there is Mockito2 for final-classes, there is a PowerMock for final-classes, static-methods, singltons, but there are a number of problems with them: <br><br><ul><li>  They most often signal problems with design (this applies mainly to PowerMock) <br></li><li>  They may stop working at some point, for example, on the 1501 test, so it‚Äôs best to immediately think about an architecture suitable for testing and not use such frameworks. <br></li></ul><br><h3>  Abstraction from the platform and why it is needed </h3><br>  Abstraction occurs on the View layer and on the layer of platform adapters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f5/31e/43b/4f531e43bdbbeaf38c8b72482026a26b.png"><br><h3>  Abstraction on the View layer </h3><br>  The View layer is the isolation of the UI framework from the Presenter module.  There are two main approaches: <br><br><ul><li>  When Activity implements the View interface itself; <br></li><li>  When View is a separate class. <br></li></ul><br>  Let's first look at the first option: Activity implements the View.  Then we have a certain trivial Presenter, which accepts the view interface as input and calls some method on it. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashPresenter</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView</span></span></span><span class="hljs-class">) { init { view.showLoading() } }</span></span></code> </pre><br>  We have a trivial View interface: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre><br>  And we have an Activity, in which there is an input in the form of the onCreate method, and there is an implementation of the SplashView interface, which already implements directly in the platform way what it needs to do, for example, display some progress. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView { override fun onCreate</span></span></span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { findViewById(R.id.progress).show() } }</code> </pre><br>  Accordingly, we do Presenter as follows: we create in OnCreate and, as View, we pass this.  So many do, quite a valid option: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView { override fun onCreate</span></span></span></span>() { SplashPresenter(view = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { findViewById(R.id.progress).show() } }</code> </pre><br>  There is a second option - View as a separate class.  Here, Presenter is exactly the same, the interface is exactly the same, but the implementation is a separate class that is not related to Activity. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashPresenter</span></span></span></span>(view: SplashView) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { view.showLoading() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView { override fun showLoading</span></span></span></span>() { } } } }</code> </pre><br>  Accordingly, in order to enable it to work with platform components, a platform view is transmitted to it at the input.  And there he is already doing everything he needs. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewRoot: View) : SplashView { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { viewRoot.findViewById(R.id.progress).show() } } }</code> </pre><br>  In this case, the Activity is a little off.  That is, instead of organizing the interface in it, it remains to get this platform view and create SplashPresenter, where a separate class is created as a View. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView</span></span></span><span class="hljs-class"> { override fun onCreate() { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Platform</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">View</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> val rootView: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">View</span></span></span><span class="hljs-class"> = ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashPresenter</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Impl(rootView)</span></span></span><span class="hljs-class"> ) } }</span></span></code> </pre><br>  In fact, from the point of view of testing, these two approaches are the same, because we still work from the interface.  We create a mock View, create a Presenter to which we pass it, and check that a method is called. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingIsShown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mockedView = mock&lt;SplashView&gt;() SplashPresenter(mockedView) verify (mockedView).showLoading() }</code> </pre><br>  The only difference is how you look at the roles of the Activity and View.  If it seems to you that the role of the View is large enough not to mix it with other roles of the Activity, then putting it into a separate class is a good idea. <br><br><h3>  Platform Wrappers layer abstraction </h3><br>  Now what concerns abstraction from the platform on the layer of platform adapters.  Platform wrappers are an isolation of the Model layer.  The problem is that behind this layer on the platform side there is a third-party platform API and API, and we cannot generally modify them, because they come in different forms.  They can come as static methods, as singltons, as final-classes and as non-final-classes.  In the first three cases, we cannot influence their implementation; we cannot replace their behavior in tests.  And only if they are not final-classes, can we somehow influence their behavior in tests. <br><br>  Therefore, instead of using such APIs directly, it may make sense to create a wrapper.  This is where the API is used directly: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-type"><span class="hljs-type">ThirdParty</span></span>.doSomething() } }</code> </pre><br>  Instead of doing so, we create a wrapper, which in the most trivial case does nothing but pass the methods of our third-party API. <br><br><pre> <code class="hljs pgsql">interface <span class="hljs-keyword"><span class="hljs-keyword">Wrapper</span></span> { fun doSomething() <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Impl: <span class="hljs-keyword"><span class="hljs-keyword">Wrapper</span></span> { override fun doSomething() { ThirdParty.doSomething()     } } }</code> </pre><br>  We received a wrapper with the implementation, hid it behind the interface and, accordingly, in the module we already call the Wrapper, which comes as an obvious dependency. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Module(<span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Wrapper</span></span>) { init { <span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span>.doSomething() } }</code> </pre><br>  In addition to guaranteed testability, this gives the following: <br><br><ul><li>  The ability to use user-friendly design instead of binding to the design of platform APIs; <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reducing the complexity of the input parameter (Single Responsibility instead of God Object); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Easier API change if necessary (without rewriting the entire codebase). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiple static calls can be Design Smell, but it strongly depends on what is in these static calls. </font><font style="vertical-align: inherit;">We mean that static calls are pure functions. </font><font style="vertical-align: inherit;">If they change global variables, then this is Smell. </font><font style="vertical-align: inherit;">If nothing hypercomplex occurs in them and you are ready to cover the functionality of this static method in each place of its use with tests for the entire module where it is called, then this is not Smell, but finding a balance. </font><font style="vertical-align: inherit;">And the rules can and should be retreated.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to resources </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android has IDs for strings and other resources. </font><font style="vertical-align: inherit;">Sometimes in presenters or in other places we need to have access to something that depends on the platform. </font><font style="vertical-align: inherit;">The question is how to abstract it, because the R-class comes from the framework.</font></font><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashPresenter</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplashView</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Resources</span></span></span><span class="hljs-class">) { init { view.setTitle(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getString</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">welcome</span></span></span><span class="hljs-class">)) view.showLoading() } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resources are already our interface, this is not the Android interface, but we are transferring to it all the same end ID ID. </font><font style="vertical-align: inherit;">And note that, in fact, this is just an end id:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashPresenter</span></span></span></span>(view: SplashView, resources: Resources) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { view.setTitle(resources.getString(R.string.welcome)) view.showLoading() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resources</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there are already questions of taste, is it enough for you that this ID has come to verify that everything behaves correctly. </font><font style="vertical-align: inherit;">Usually it is enough.</font></font><br><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> welcome=<span class="hljs-number"><span class="hljs-number">0x7f050000</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my opinion, it makes sense to work more deeply with this only if you are doing some kind of cross-platform logic. </font><font style="vertical-align: inherit;">There, the mechanism of access to resources will be different for iOS and Android, and already guaranteed to isolate it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What is the implementation detail </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a module, it has an input. </font><font style="vertical-align: inherit;">He internally from this input counted some state, recorded in the field.</font></font><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeModule</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) { val state = calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> private fun calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> complex computation for $input" }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything is good, we wrote a test for it, and then we got another module, in which there is a very similar logic. </font></font><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeModule</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) { val state = calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> private fun calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> complex computation for $input" } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnotherModule</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) { val state = calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> private fun calculateInitialState(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> = "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> complex computation for $input" }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accordingly, we see that this is a repetition of the same code, we make this logic for calculating the initial state somewhere in a separate place and cover it with a test. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SomeModule(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>: String) { val state = calculateInitialState(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) // Pure private fun calculateInitialState(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>: String): String = "Some complex computation for $input" } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> StateCalculator { fun calculateInitialState(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>: String): String = "Some complex computation for $input" }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But how, then, do we write tests for both modules? </font><font style="vertical-align: inherit;">In both of them, we need to check the calculateInitialState function if it is a conditional part of the implementation. </font><font style="vertical-align: inherit;">If this is a rather complicated thing, then it may make sense to put it out as an explicit dependency and pass it on as an interface.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeModule</span></span></span></span>(input: String, stateCalculator: StateCalculator){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = stateCalculator.calculateInitialState(input) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateCalculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateInitialState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateCalculator { override fun calculateInitialState</span></span></span></span>(input: String): String = <span class="hljs-string"><span class="hljs-string">"Some complex computation for </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$input</span></span></span><span class="hljs-string">"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This does not always make sense, since with this approach we can simply verify that the calculateInitialState method was called with such a parameter. </font><font style="vertical-align: inherit;">The same applies to the internal classes, extension-functions (if we talk about Kotlin), static-functions, that is, everything that is an implementation part and can be jerked from several places.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to start if our codebase is not ready yet </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is logical to start with models, that is, with no dependencies (these are either models without dependencies or platform wrappers). </font><font style="vertical-align: inherit;">We wrote enough of them, and then, using them as dependencies, we build models that take them as inputs, and so we gradually build our global dependency graph. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/df7/13a/a3fdf713ab3d4f619f0f071050d18965.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks something like the instructions for drawing an owl from a comic beginner's guide. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/36f/ae7/fa5/36fae7fa58a027ac8a09d8336c3ca02d.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, you will receive the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everything that was implicit (singltons) will become explicit (will be transmitted via DI); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you will gain control and understanding of the initialization process; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> models will be easy to test. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have done all this qualitatively, we can take some kind of entry point from the framework (Activity, service, broadcast receiver ...), create some kind of wrapper around it (in the case of Activity it can be View), take our dependency graph which we did earlier and create a presenter. </font><font style="vertical-align: inherit;">All dependencies are already satisfied, and we can create a Presenter, passing them to the input via DI. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/c11/4eb/b5cc114eb1c361cb816b30627099913b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we have done all this, we can go up the testing pyramid for integration tests.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/043/bd3/f7e/043bd3f7e6fd84e176edbab8b0415319.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we take the layers, where we are strictly insulated from the platform (wrapper and View), and replace them with test implementations. </font><font style="vertical-align: inherit;">After that, we can integrate testing everything that is between them (and this is sometimes useful).</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfb/30f/4bd/dfb30f4bda2cd882fef6a26fac5836c7.png"><br><br><h2>  Instead of conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, I want to quote Joshua Bloch‚Äôs famous quotation: ‚ÄúLearning the art of programming, like most other disciplines, consists of learning the rules at the first stage and learning how to break them - at the second.‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above it was stated exactly the rules. </font><font style="vertical-align: inherit;">The important part here is to understand how they work. </font><font style="vertical-align: inherit;">And if you need to break the rules, it must be a conscious decision. </font><font style="vertical-align: inherit;">You should know what the consequences may be due to a violation of the rules. </font><font style="vertical-align: inherit;">If you decide to break the rule, you must consciously accept the consequences. </font><font style="vertical-align: inherit;">If you can not put up with the consequences, you must not consciously violate them.</font></font><br><br><hr><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If mobile development is your main profile, you will certainly be interested in these reports at our November </font></font><a href="https://mobiusconf.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius 2017 Moscow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference </font><font style="vertical-align: inherit;">:</font></font><br><br><ul><li> <a href="https://mobiusconf.com/2017/msk/talks/7ewhxk5ohg28asgu6scqw8/"> :     </a> ( , EPAM Systems) <br></li><li> <a href="https://mobiusconf.com/2017/msk/talks/2bu0yhbp3kqui0eyu08u84/">      </a> ( , ) <br></li><li> <a href="https://mobiusconf.com/2017/msk/talks/3kone5kcgeeeeaiu2iaqi6/">Crash  Android NDK</a> ( , Akvelon) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/341944/">https://habr.com/ru/post/341944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341930/index.html">We instantiate java.lang.Class</a></li>
<li><a href="../341932/index.html">Briefly about software development methodologies: Waterfall, Lean and Feature Driven Development</a></li>
<li><a href="../341934/index.html">UX Writer: The Anatomy of a Unicorn</a></li>
<li><a href="../341936/index.html">Mobile marketing: discrepancies in installation statistics</a></li>
<li><a href="../341938/index.html">US Securities and Exchange Commission attack: stolen data can be used for insider trading</a></li>
<li><a href="../341946/index.html">JTAG to every home: full access via USB</a></li>
<li><a href="../341950/index.html">Sharing shared assemblies between processes and domains in IIS</a></li>
<li><a href="../341952/index.html">ZeroNights 2017 program</a></li>
<li><a href="../341954/index.html">The rules of English that violate your foreign colleagues</a></li>
<li><a href="../341956/index.html">Motivation system: carrot front or rear carrot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>