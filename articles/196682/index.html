<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We attach the spatial index to the unsuspecting OpenSource database.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I always liked it when the headline clearly says what will happen next, for example, ‚ÄúTexas Chainsaw Massacre‚Äù. Therefore, under the cut, we really wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We attach the spatial index to the unsuspecting OpenSource database.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/b37/8b6/2d8/b378b62d8c490b812df3236d0626c1bc.png" alt="image"><br>  I always liked it when the headline clearly says what will happen next, for example, ‚ÄúTexas Chainsaw Massacre‚Äù.  Therefore, under the cut, we really will add spatial search to the database, in which it was not originally. <br><a name="habracut"></a><br>  <b>Introductory</b> <br>  Let's try to do without common words about the importance and usefulness of spatial search. <br>  When asked why it was impossible to take an open DBMS with an already built-in spatial search, the answer would be: ‚Äúif you want to do something well, do it yourself‚Äù (C).  But seriously, we will try to show that most practical spatial problems can be solved on a completely ordinary desktop without overvoltage and special expenses. <br><br>  As the experimental DBMS, we will use the open edition of <a href="http://virtuoso.openlinksw.com/dataspace/doc/dav/wiki/Main/">OpenLink Virtuoso</a> .  Spatial indexing is available in its paid version, but this is a completely different story.  Why this particular DBMS?  The author likes it.  Fast, easy, powerful.  Copied-launched-everything works.  We will use only standard means, no C-plugins or special assemblies, only an official assembly and a text editor. <br><br>  <b>Index type</b> <br>  We will index the points using a pixel-code (block) index. <br>  What is the pixel-code index?  This is a compromise version of the sweeping curve, allowing you to work with non-point objects in a 2-dimensional search space.  Let's unite in this class all the methods that: <br><ul><li>  Somehow divide the search space into blocks </li><li>  All blocks are numbered. </li><li>  Each indexed object is assigned one or more block numbers in which it is located. </li><li>  When searching, the extent is split into blocks, and for each block or continuous chain of blocks from a regular integer index (B-tree), all the objects that belong to them are obtained. </li></ul><br>  The most well-known methods are: <br><ul><li>  Good old Igloo (or other <a href="http://habrahabr.ru/post/186564/">sweeping curve</a> ) of limited accuracy.  The space is cut by a grid, the step of which (usually) is the characteristic size of the object being indexed.  The cells are numbered X ... xY ... yZ ... z ... i.e.  gluing the cell numbers to the normals. </li><li>  <a href="http://healpix.jpl.nasa.gov/">HEALPix</a> .  The name is derived from the Hierarchical Equal Area iso-Latitude Pixelisation.  This method is intended for splitting a spherical surface in order to avoid the main Igloo deficiency - a different area under the cells at different latitudes.  The sphere is divided into 12 equal-sized sections, each of which is further hierarchically divided into 4 sub-sections.  The illustration for this method is in the header of the article. </li><li>  Hierarchical Triangular Mesh ( <a href="http://taltos.pha.jhu.edu/htm">HTM</a> ) .This is a sequential approximation to a sphere using triangles, starting with 8 starting points, each of which is hierarchically divided into 4 sub-triangles <img src="https://habrastorage.org/storage3/4d0/d5d/aff/4d0d5daffab7938ac89db3156bc025c5.png" alt="image"></li><li>  One of the most well-known block index schemes is GRID.  Spatial data are considered as a special case of a multidimensional index.  Wherein: <br><ol><li>  the space is cut into pieces using the grille </li><li>  the resulting cells are numbered in some way </li><li>  data trapped in a specific cell is stored together </li><li>  attribute values ‚Äã‚Äãare converted to cell numbers along the axes using a ‚Äúdirectory‚Äù, it is assumed that it is small and is located in memory </li><li>  if the ‚Äúdirectory‚Äù is large, it is divided into levels a la tree </li><li>  when changing, the lattice can adapt, cells or columns split or, conversely, merge </li></ol>  A 3-tier GRID based on Z-order is used by DB2, a 4-tier GRID based on a variant of the Hilbert curve <a href="http://msdn.microsoft.com/en-us/library/bb964712.aspx">used</a> in MS SQLServer 2008 <br></li></ul><br>  With all the drawbacks, the main one of which, perhaps, is non-adaptability, the need to customize the index for a specific task, block indexes also have advantages: simplicity and omnivorousness.  In essence, this is an ordinary tree with an additional semantic load.  We somehow convert the geometry into numbers when indexing and in the same way we get the keys to search in the index. <br>  In this paper, we will use the line scan (+1 <a href="https://habrahabr.ru/users/ystein/" class="user_link">ystein</a> ) because of the simplicity: the coordinates in the number can be cheaply converted by means of PL / SQL.  Using HTM or the Hilbert curve without involving C-plugins would be difficult. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Data type</b> <br>  Why point?  As already noted, Block indices are just the same as indexing.  At the same time, the rasterizer for points is trivial, and for polygons it would have to be written, and this is completely irrelevant for the disclosure of the topic. <br><br>  <b>Actually the data</b> <br>  Without further ado, <br><ul><li>  put the points on the nodes of the lattice 4000x4000 with the beginning in (0,0) and step 1. </li><li>  get a square of 16 million points. </li><li>  cell block index we take for 10X10, </li><li>  thus, we have 400x400 cells each with 100 points. </li></ul>  For the index, it is not important how the points are located inside the cell, and such regularity will allow us to control the correctness of the results. <br><br>  To generate the data, we will use the following <a href="http://gnuwin32.sourceforge.net/packages/gawk.htm">AWK</a> script (let‚Äôs be 'data.awk'): <br><pre><code class="php hljs">BEGIN { cnt = <span class="hljs-number"><span class="hljs-number">1</span></span>; sz = <span class="hljs-number"><span class="hljs-number">4000</span></span>; <span class="hljs-comment"><span class="hljs-comment"># Set the checkpoint interval to 100 hours -- enough to complete most of experiments. print"checkpoint_interval (6000);"; print"SET AUTOCOMMIT MANUAL;"; for (i=0; i &lt; sz; i++) { for (j=0; j &lt; sz; j++) { print "insert into \"xxx\".\"YYY\".\"_POINTS\""; print " (\"oid_\",\"x_\", \"y_\") values ("cnt","i","j");"; cnt++; } print"commit work;" } print"checkpoint;" print"checkpoint_interval (60);"; exit; }</span></span></code> </pre> <br><br>  <b>Server</b> <br><ul><li>  Take the official <a href="http://virtuoso.openlinksw.com/dataspace/doc/dav/wiki/Main/VOSDownload">build</a> from the company website. <br>  The author used the latest version 7.0.0 (x86_64), but it does not matter, you can take any other. </li><li>  Install, if not, <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D14632">Microsoft Visual C ++ 2010 Redistributable Package (x64)</a> </li><li>  Select the directory for the experiments and copy libeay32.dll, ssleay32.dll, isql.exe, virtuoso-t.exe from the archive bin and virtuoso.ini from the archive database </li><li>  We start the server using 'start virtuoso-t.exe + foreground', allow the firewall to open ports </li><li>  We test server availability with the command 'isql localhost: 1111 dba dba'.  After establishing the connection, enter, for example.  'select 1;'  and make sure the server is alive. </li></ul><br><br>  <b>Data schema</b> <br>  First, create a table of points, nothing more: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-string"><span class="hljs-string">"YYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span> ( <span class="hljs-string"><span class="hljs-string">"oid_"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-string"><span class="hljs-string">"x_"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>, <span class="hljs-string"><span class="hljs-string">"y_"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (<span class="hljs-string"><span class="hljs-string">"oid_"</span></span>) );</code> </pre><br>  Now the actual index: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx"</span></span> ( <span class="hljs-string"><span class="hljs-string">"node_"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-string"><span class="hljs-string">"oid_"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (<span class="hljs-string"><span class="hljs-string">"node_"</span></span>, <span class="hljs-string"><span class="hljs-string">"oid_"</span></span>) );</code> </pre>  where node_ is the space cell identifier.  Note that, although the index is created as a table, both fields are present in the primary key and, therefore, are packed in a tree. <br><br>  Configure index options: <br><pre> <code class="sql hljs">registry_set ('__spx_startx', '0'); registry_set ('__spx_starty', '0'); registry_set ('__spx_nx', '4000'); registry_set ('__spx_ny', '4000'); registry_set ('__spx_stepx', '10'); registry_set ('__spx_stepy', '10');</code> </pre><br>  The system function registry_set allows you to write string name / value pairs to the system registry ‚Äî it is much faster than keeping them in auxiliary table and is still covered in transactions. <br><br>  Write trigger: <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-string"><span class="hljs-string">"xxx_YYY__POINTS_insert_trigger"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">referencing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> n { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> nx, ny <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; nx := atoi (registry_get ('__spx_nx')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> startx, starty <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>; startx := atof (registry_get ('__spx_startx')); starty := atof (registry_get ('__spx_starty')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> stepx, stepy <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>; stepx := atof (registry_get ('__spx_stepx')); stepy := atof (registry_get ('__spx_stepy')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> sx, sy <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; sx := floor ((n.x_ - startx)/stepx); sy := floor ((n.y_ - starty)/stepy); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> ixf <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; ixf := (nx / stepx) * sy + sx; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx"</span></span> (<span class="hljs-string"><span class="hljs-string">"oid_"</span></span>,<span class="hljs-string"><span class="hljs-string">"node_"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (n.oid_,ixf); };</code> </pre><br>  We put all this in, for example, 'sch.sql' and execute it by <pre> <code class="bash hljs">isql.exe localhost:1111 dba dba &lt;sch.sql</code> </pre><br>  <b>Data loading</b> <br>  Once the circuit is ready, you can fill in the data. <br><pre> <code class="bash hljs">gawk -f data.awk | isql.exe localhost:1111 dba dba &gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> 2&gt;errlog</code> </pre>  It took the author 45 minutes (~ 6000 per second) on the Intel i7-3612QM 2.1GHz with 8Gb of memory. <br>  The memory size occupied by the server was about 1 Gb, the size of the database on the disk was 540Mb, i.e.  ~ 34 bytes per point and its index. <br>  Now we need to make sure that the result is correct, we enter in isql <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx"</span></span>;</code> </pre>  Both requests must give out 16,000,000. <br><br>  As a guideline, you can use the data published <a href="http://www.star.le.ac.uk/~cgp/P2-22.pdf">here</a> : <br><img src="http://habrastorage.org/storage3/2a1/669/d6b/2a1669d6bf0a5ba0914bcadaf08c0aee.png" alt="image">  . <br>  They are received on PostgreSQL (Linux), 2.2GHz Xeon. <br>  On the one hand, the data was obtained 9 years ago.  On the other hand, in this case disk operations are a bottleneck, and random disk access has not accelerated much over the past period. <br>  And <a href="http://www.adass.org/adass/proceedings/adass00/P2-07/">here</a> we can learn that the time of spatial indexing is commensurate with the time of filling the actual data. <br>  It should be noted that filling data with subsequent indexing occurs (for obvious reasons) much faster than indexing on the fly.  But we will be more interested in indexing on the fly because  for practical purposes, a spatial database is more interesting, rather than a spatial search system. <br><br>  And yet, it should be noted that when filling in spatial data, the order of their filling is very important. <br>  Both in this paper and in the aforementioned order, the point feeding was perfect (or close to it) in terms of spatial index.  If the data is mixed, the performance will fall quite dramatically, regardless of the selected DBMS. <br>  If the data arrives arbitrarily, it can be recommended to accumulate them in a settling tank, as it overflows, sort and fill with portions. <br><br>  <b>We are developing a search</b> <br>  To do this, we use such a remarkable feature of Virtuoso, as a procedural view. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx_enum_items_in_box"</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> minx <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> miny <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> maxx <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> maxy <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> nx, ny <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; nx := atoi (registry_get ('__spx_nx')); ny := atoi (registry_get ('__spx_ny')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> startx, starty <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>; startx := atof (registry_get ('__spx_startx')); starty := atof (registry_get ('__spx_starty')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> stepx, stepy <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">precision</span></span>; stepx := atof (registry_get ('__spx_stepx')); stepy := atof (registry_get ('__spx_stepy')); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> sx, sy, fx, fy <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; sx := floor ((minx - startx)/stepx); fx := floor (1 + (maxx - startx - 1)/stepx); sy := floor ((miny - starty)/stepy); fy := floor (1 + (maxy - starty - 1)/stepy); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> mulx, muly <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; mulx := nx / stepx; muly := ny / stepy; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; res := dict_new (); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> cnt <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; for (<span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> iy <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, iy := sy; iy &lt; fy; iy := iy + 1) { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> ixf, ixt <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; ixf := mulx * iy + sx; ixt := mulx * iy + fx; for <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">"node_"</span></span>, <span class="hljs-string"><span class="hljs-string">"oid_"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-string"><span class="hljs-string">"node_"</span></span> &gt;= ixf <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">"node_"</span></span> &lt; ixt <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { dict_put (res, <span class="hljs-string"><span class="hljs-string">"oid_"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cnt := cnt + 1; } } <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> arr <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; arr := dict_list_keys (res, 1); gvector_digit_sort (arr, 1, 0, 1); result_names(sx); foreach (integer oid in arr) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"v_POINTS_spx_enum_items_in_box"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS_spx_enum_items_in_box"</span></span> (minx, miny, maxx, maxy) (<span class="hljs-string"><span class="hljs-string">"oid"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>);</code> </pre>  In essence, this procedure is very simple, it finds out which cells in the block index the search extent falls into and makes a sub-request for each line of these cells, writes record identifiers to the hash map, eliminating duplicates and giving the resulting set of identifiers as a result. <br>  How to use the spatial index?  For example: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*), <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(x.x_), <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(x.y_) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x, <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"v_POINTS_spx_enum_items_in_box"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.minx = <span class="hljs-number"><span class="hljs-number">91.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.miny = <span class="hljs-number"><span class="hljs-number">228.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.maxx = <span class="hljs-number"><span class="hljs-number">139.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.maxy = <span class="hljs-number"><span class="hljs-number">295.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.<span class="hljs-string"><span class="hljs-string">"oid_"</span></span> = a.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.x_ &gt;= <span class="hljs-number"><span class="hljs-number">91.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.x_ &lt; <span class="hljs-number"><span class="hljs-number">139.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.y_ &gt;= <span class="hljs-number"><span class="hljs-number">228.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.y_ &lt; <span class="hljs-number"><span class="hljs-number">295.</span></span>;</code> </pre>  Here is the join between the table of points and the synthetic recordset from the procedural view by identifiers.  Here the procedural view plays the role of a coarse filter that works up to the cell.  Therefore, in the last line we placed a thin filter. <br>  Expected Result: <br><ul><li>  Number: (139 - 91) * (295 - 228) = 3216 </li><li>  Average over X: (139 + 91 - 1) / 2 = 114.5 (-1 since the right border is excluded) </li><li>  Y average: (295 + 228 - 1) / 2 = 261 (...) </li></ul>  This is how we performed a spatial search with one query within a single transaction. <br><br>  <b>Benchmark</b> <br>  To prepare the request flow, use the following script on AWK: <br><pre> <code class="php hljs">BEGIN { srand(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; j++) { startx = int(rand() * <span class="hljs-number"><span class="hljs-number">3900</span></span>); finx = int(startx + rand() * <span class="hljs-number"><span class="hljs-number">100</span></span>); starty = int(rand() * <span class="hljs-number"><span class="hljs-number">3900</span></span>); finy = int(starty + rand() * <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"select count(*), avg(x.x_), avg(x.y_) from"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"\"xxx\".\"YYY\".\"_POINTS\" as x, "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"\"xxx\".\"YYY\".\"v_POINTS_spx_enum_items_in_box\" as a"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"where a.minx = "</span></span>startx<span class="hljs-string"><span class="hljs-string">". and a.miny = "</span></span>starty<span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" and a.maxx = "</span></span>finx<span class="hljs-string"><span class="hljs-string">". and a.maxy = "</span></span>finy<span class="hljs-string"><span class="hljs-string">". and"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"x.\"oid_\" = a.oid and x.x_ &gt;= "</span></span>startx<span class="hljs-string"><span class="hljs-string">". and x.x_ &lt; "</span></span>finx<span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" and x.y_ &gt;= "</span></span>starty<span class="hljs-string"><span class="hljs-string">". and x.y_ &lt; "</span></span>finy<span class="hljs-string"><span class="hljs-string">".;"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre>  As you can see, it turns out 10,000 requests in random places of random size (0 ... 100).  Let's prepare 4 such sets and we will execute three series of tests - we start one isql with tests, 2 in parallel and 4 in parallel.  On the eight-core processor, there is no more parallelizing.  Measure performance. <br><ul><li>  1 stream: 151 sec = ~ 66 requests per second per stream </li><li>  2 threads: 159 sec = ~ 63 ... </li><li>  4 threads: 182 sec = ~ 55 ... </li></ul><br>  You can try to compare these times with those obtained by the spinal cord by means of two ordinary indices - x_ &amp; y_.  We index the table for these fields and run a similar series of tests with queries like <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*), <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(x.x_), <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(x.y_) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"xxx"</span></span>.<span class="hljs-string"><span class="hljs-string">"YYY"</span></span>.<span class="hljs-string"><span class="hljs-string">"_POINTS"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x.x_ &gt;= <span class="hljs-number"><span class="hljs-number">91.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.x_ &lt; <span class="hljs-number"><span class="hljs-number">139.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.y_ &gt;= <span class="hljs-number"><span class="hljs-number">228.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.y_ &lt; <span class="hljs-number"><span class="hljs-number">295.</span></span>;</code> </pre>  The result is as follows: a series of 10,000 requests is executed in 417 seconds, we have 24 requests per second. <br><br>  <b>Conclusion</b> <br>  The presented method has a number of drawbacks, the main of which, as already noted, is the need to tune it for a specific task.  Its performance is highly dependent on the settings, which can no longer be changed after creating the index.  However, this is true for most spatial indices in general. <br><br>  But even this index written on the knee gives a decent performance.  In addition, since we completely control the process, on this basis it is possible to make more complex structures, for example, multi-table indexes, which are difficult to build using standard methods.  But more about that next time. </div><p>Source: <a href="https://habr.com/ru/post/196682/">https://habr.com/ru/post/196682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196666/index.html">The arbitration court ruled that the Federal Drug Control Service may deprive a domain name of anyone for posting drug information on the site. ‚Ññ139-–§–ó (on protection of children) - not a hindrance</a></li>
<li><a href="../196668/index.html">Creating cross-browser visualization of audio</a></li>
<li><a href="../196670/index.html">Google Maps doubled Rybinsk Reservoir</a></li>
<li><a href="../196672/index.html">Steal-kill, write-swing</a></li>
<li><a href="../196676/index.html">We write our JSON parser (with polka dots and pearl buttons)</a></li>
<li><a href="../196684/index.html">Samsung is the most active advertiser on the "pirated" sites of Ukraine</a></li>
<li><a href="../196688/index.html">Instead of a review IBM ThinkPad 755CD - restorer notes</a></li>
<li><a href="../196690/index.html">Google has to delete eight ‚Äúpirated‚Äù links per second</a></li>
<li><a href="../196692/index.html">Tips & tricks for MySQL Developers. Work with SQL</a></li>
<li><a href="../196694/index.html">Getting ready for Friday: luminous drinks from the TRON bar: Legacy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>