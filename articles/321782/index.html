<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple technology for classifying recognized pages of business documents based on the Template Matching method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The classification task is well known: it is required to assign an arbitrary object from a certain sample to one or several classes from a predetermin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple technology for classifying recognized pages of business documents based on the Template Matching method</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/f24/642/434/f246424346dc476ca3ac0e12a32c9ab4.jpg" alt="image"></p><br><p>  The classification task is well known: it is required to assign an arbitrary object from a certain sample to one or several classes from a predetermined set of classes. </p><a name="habracut"></a><br><p>  <strong>1. Statement of the problem</strong> </p><br><p>  The classification algorithm can be built on the basis of machine learning, using some training selection of objects, about which it is known which classes they belong to. </p><br><p>  Also well known is the Template Matching method, which consists in preparing templates for all possible classes.  The decision on whether a test object belongs to a certain class is carried out by the criterion of the minimum (maximum) of a certain function of matching an object and its template (in [1] an object is considered - images of characters).  This method is one of the simplest for understanding and its own implementation. In essence, it is necessary to solve the problem of representing an object with a certain pattern and choosing a matching function. </p><br><p>  Consider the task of classifying recognized pages of business documents.  Business documents used in document management, including in the exchange of documents between organizations, have a certain standardization, they can be both unstructured and structured.  In banks or insurance companies, documents such as a power of attorney, a contract, a card with samples of signatures and seals, a charter, a contract, an invoice (invoice in English), registration certificates, etc. are often required.  When creating and maintaining electronic archives, paper documents are digitized, and digital images of pages (page scans) can be recognized and analyzed.  One of the tasks of the analysis is to classify the image of the page, consisting in checking the ownership of the image of the page to a particular class.  Such a need arises in the control of images of documents attached by the user as electronic copies. </p><br><p>  To analyze the information contained in the image of the document (in particular, the classification), you can use arbitrary text recognition programs (OCR).  Currently, one of the most popular solutions is OCR Tesseract, for example, in the thesis [2] this OCR was chosen to recognize the body of archival documents for the following reasons: the possibility of free distribution, as well as the presentation of recognition results in the HOCR format (HTML OCR) information about the coordinates of the recognized words. </p><br><p>  OCR Tesseract, depending on the degree of text noise and its own abilities, can recognize page images successfully or unsuccessfully.  Systematic failure can be associated with the objective difficulties of recognizing certain classes of documents, for example, passports of a citizen of the Russian Federation, the recognition program of which was described by us in another article [3].  Typical OCR Tesseract errors can be divided into several types: </p><br><ul><li>  E <sub>1</sub> : total failure to recognize the page, to the extent that not a single word is recognized; </li><li>  E <sub>2</sub> : the number of errors is so great that a person cannot understand the document from its textual representation in the HOCR format (for example, see the illustration above - it shows a real example of unsuccessful recognition of the ‚ÄúCertificate of registration in the IMNS‚Äù using OCR Tesseract version 3.04.00); </li><li>  E <sub>3</sub> : the page structure is incorrectly recognized, for example, when adjacent text fragments as a result were separated by a considerable distance; </li><li>  E <sub>4</sub> : the presence of a small number of errors, when in the majority of incorrectly recognized words there are 1-2 errors. </li></ul><br><p>  In this article we will consider the classification of pages only of such documents that are widely recognized by OCR Tesseract, under the assumption that errors like E <sub>3</sub> and E <sub>4 are</sub> likely to occur. </p><br><p>  Consider another task of classifying images of document pages.  In the existing set of multipage image files, each of which contains pages of one or several documents, it is necessary to determine the boundaries of each of the available documents and assign the found documents to one of the previously known classes.  The received portions of the pages are stored in the electronic archive as separate documents. </p><br><p>  Next, we will talk about a simple method of classifying pages of documents based not on matching with pre-prepared class templates.  The method allows to process single-page and multi-page documents, it allows to take into account some errors of OCR recognition. </p><br><p>  <strong>2. Description of patterns and pattern matching</strong> </p><br><p>  We suggest creating class templates based on keywords and a combination of several keywords. </p><br><p>  The model of an unstructured document in the form of a structure over a set of keywords is fairly well known.  For example, see the document model descriptions as </p><br><ul><li>  vector model or "bag of words", i.e.  multiset of words included in the document [4], </li><li>  language model that takes into account the word order (taking into account the probability of occurrence of a sequence of words) [5], </li><li>  a thematic model using themes consisting of sets of words [6, 7]. </li></ul><br><p>  We will describe an approach to creating templates using the mechanisms listed above and taking into account errors and features of recognition. </p><br><p>  The basic signs will be recognized <em>words</em> in the form of symbols of the word and its properties: </p><br><p>  W = ( <em>T</em> ( <em>W</em> ), <em>m</em> <sub>1</sub> ( <em>W</em> ), <em>m</em> <sub>2</sub> ( <em>W</em> ), <em>m</em> <sub>3</sub> ( <em>W</em> ), <em>m</em> <sub>4</sub> ( <em>W</em> ), <em>m</em> <sub>5</sub> ( <em>W</em> ), <em>m</em> <sub>6</sub> ( <em>W</em> )), </p><br><p>  where <em>T</em> ( <em>W</em> ) is the <em>core of the word</em> , that is, the sequence of characters and characters "?"  and "‚àó", the latter are used to specify a set of words, for example, "‚àó ab? c" defines a set of words with an arbitrary number of characters, with the last characters ab? c, in the place of "?"  arbitrary character may be present. </p><br><p>  <em>m</em> <sub>1</sub> ( <em>W</em> ) is the distance threshold when <em>comparing</em> two words <em>T</em> ( <em>W</em> ) and <em>W <sub>r</sub></em> .  To compare two words, it is necessary to choose a metric (distance function), we used the Levenshtein distance [8] or a simplified function, which takes into account only the number of operations of replacing one character with another.  In the latter case, the distance <em>d</em> ( <em>T</em> ( <em>W</em> ), <em>W <sub>r</sub></em> ) is calculated only for words of the same length, for words with signs "?"  the corresponding characters are not involved in the comparison, and for words with the signs "‚àó" the necessary substrings are compared.  If <em>d</em> ( <em>T</em> ( <em>W</em> ), <em>W <sub>r</sub></em> ) &lt; <em>m</em> <sub>2</sub> ( <em>W</em> ), then the words are identical, otherwise - different.  In the simplest case, <em>m</em> <sub>2</sub> ( <em>W</em> ) is the maximum number of replacement operations during the transformation of <em>T</em> ( <em>W</em> ) to <em>W <sub>r</sub></em> . </p><br><p>  <em>m</em> <sub>2</sub> ( <em>W</em> ) - restriction on the length of the word <em>W <sub>r</sub></em> when comparing <em>T</em> ( <em>W</em> ) and <em>W <sub>r</sub></em> makes sense for words containing "‚àó". </p><br><p>  <em>m</em> <sub>3</sub> ( <em>W</em> ) - case-sensitive feature (case sensitive / insensitive) when comparing characters. </p><br><p>  <em>m</em> <sub>4</sub> ( <em>W</em> ) is a <em>rectangle of a word</em> , consisting of coordinates in the range [0,1], used to check whether a word falls into the specified rectangle. </p><br><p>  <em>m</em> <sub>5</sub> ( <em>W</em> ) - a sign of <em>negation of the word</em> , indicating that the given word should not be in the text.  With the help of <em>m</em> <sub>5</sub> ( <em>W</em> ), it is possible to organize a check of both the presence and absence of the word <em>W</em> in the text. </p><br><p>  <em>m</em> <sub>6</sub> ( <em>W</em> ) - will be described below. </p><br><p>  When searching for the word <em>T</em> ( <em>W</em> ) in the text of the recognized document <em>T,</em> we check the truth of the condition </p><br><p>  ‚àÉ <em>W <sub>r</sub></em> ‚àà <em>T</em> : <em>d</em> ( <em>T</em> ( <em>W</em> ), <em>W <sub>r</sub></em> ) &lt; <em>m</em> <sub>2</sub> ( <em>W</em> ) ( <em>F</em> ( <em>W <sub>r</sub></em> ) ‚à© <em>m</em> <sub>4</sub> ( <em>W</em> ) = <em>F</em> ( <em>W <sub>r</sub></em> )) </p><br><p>  where <em>F</em> ( <em>W <sub>r</sub></em> ) is the rectangle of the word <em>W <sub>r</sub></em> , that is, the coordinates of the word extracted from the recognition results in the HOCR format, are abscissas and ordinates normalized to the width and height of the original image.  When comparing, the parameter <em>m</em> <sub>3</sub> ( <em>W</em> ) is used.  Generally speaking, several words { <em>W <sub>r</sub></em> } can be found that are identical to the keyword <em>T</em> ( <em>W</em> ). </p><br><p>  For the case <em>m</em> <sub>5</sub> ( <em>W</em> ) = 0, we define the predicate P ( <em>W</em> , <em>T</em> ) = 1 if in the text of the recognized document <em>T</em> at least one word is found identical to the word <em>W</em> , and P ( <em>W</em> , <em>T</em> ) = 0 if the text does not found one word identical to the word <em>w</em> .  If the word had the sign <em>m</em> <sub>5</sub> ( <em>W</em> ) = 1, then P ( <em>W</em> , <em>T</em> ) = 0, if in the text of the recognized document <em>T</em> at least one word is found identical to the word <em>W</em> , and P ( <em>W</em> , <em>T</em> ) = 1, if No words were found in the text that are identical to the word <em>W.</em> </p><br><p>  We also need estimates of <em>d</em> ( <em>T</em> ( <em>W</em> ), <em>W <sub>r</sub></em> ) words identical to the word <em>T</em> ( <em>W</em> ). </p><br><p>  Next, we define the <em>placement of words</em> as an ordered set of words <em>R</em> = <em>W</em> <sub>1</sub> , <em>W</em> <sub>2</sub> , ..., for which the presence of each word in the recognized document <em>T</em> is checked: </p><br><p>  P ( <em>W</em> <sub>1</sub> , <em>T</em> ) ‚àß P ( <em>W</em> <sub>r</sub> , <em>T</em> ) ‚àß ... (1) </p><br><p>  and additionally for each pair of words <em>W</em> <sub><em>i</em></sub> and <em>W</em> <sub><em>i</em> +1</sub> the condition is checked </p><br><p>  <em>r</em> ( <em>W</em> <sub><em>i</em> +1</sub> ) - <em>r</em> ( <em>W</em> <sub><em>i</em></sub> ) &lt; <em>m</em> <sub>5</sub> ( <em>W</em> ), (2) </p><br><p>  where the function <em>r</em> ( <em>W</em> ) gives the number of the word <em>W</em> in the text <em>T</em> ordered by the OCR mechanisms.  That is, the parameter <em>m</em> <sub>r6</sub> ( <em>W</em> ) determines the distance between adjacent words in the arrangement, for <em>m</em> <sub>r</sub> ( <em>W</em> <sub><em>i</em> +1</sub> ) = ‚àû, condition (2) is not checked, but only the order of the words is checked. </p><br><p>  For placement of <em>R,</em> <em>m</em> <sub>7</sub> ( <em>R</em> ) can be specified - an allocation rectangle, the meaning of which is similar to a rectangle of a word, it is checked whether the words <em>T</em> <sub>1</sub> , <em>W</em> <sub>2</sub> ..., completely found in the text <em>T</em> , are contained in rectangle <em>m</em> <sub>6</sub> ( <em>R</em> ). </p><br><p>  The fulfillment of conditions (1), (2) and the conditions for checking compliance with the frame <em>m</em> <sub>7</sub> ( <em>R</em> ) of a rectangle determines the predicate of the location belonging to the text <em>R to the</em> text <em>T</em> : P ( <em>R</em> , <em>T</em> ) = 1.  In the simplest case, the placement may consist of one single word, in the general case, in order to calculate P ( <em>R</em> , <em>T</em> ), it is necessary to search for sets that are identical to the words <em>W</em> <sub>1</sub> , <em>W</em> <sub>2</sub> .... </p><br><p>  We define the estimate <em>d</em> ( <em>R</em> , <em>T</em> ) of placement as the minimum of the estimates of the words: min ( <em>d</em> ( <em>W</em> <sub>1</sub> , <em>T</em> ), <em>d</em> ( <em>W</em> <sub>2</sub> , <em>T</em> ), ...). </p><br><p>  Now we define a <em>combination</em> as a set of placements <em>S</em> = <em>R</em> <sub>1</sub> , <em>R</em> <sub>2</sub> , ..., for which the presence of each of the placements in the recognized document <em>T</em> is checked: </p><br><p>  P ( <em>R</em> <sub>1</sub> , <em>T</em> ) ‚àß P ( <em>R</em> <sub>2</sub> , <em>T</em> ) ‚àß ... (3) </p><br><p>  The placement procedure is not important.  In addition to condition (3), a comparison of the rectangles of all words from the combination with the <em>m</em> <sub>8</sub> ( <em>S</em> ) combination rectangle can be added.  These conditions determine the membership predicate of the <em>S</em> combination to the text <em>T</em> : P ( <em>S</em> , <em>T</em> ) = 1. </p><br><p>  We estimate the combination <em>d</em> ( <em>S</em> , <em>T</em> ) as the minimum of the estimates of the allocations included in the combination: min ( <em>d</em> ( <em>R</em> <sub>1</sub> , <em>T</em> ), <em>d</em> ( <em>R</em> <sub>2</sub> , <em>T</em> ), ...). </p><br><p>  And finally, we define the <em>pattern M</em> as the set of combinations <em>S</em> <sub>1</sub> , <em>S</em> <sub>2</sub> , ..., for which the pattern belongs to the recognized text <em>T is</em> set by checking the expression </p><br><p>  P ( <em>M</em> , <em>T</em> ) = P ( <em>S</em> <sub>1</sub> , <em>T</em> ) ‚à® P ( <em>S</em> <sub>2</sub> , <em>T</em> ) ‚à® ... (4) </p><br><p>  In addition to condition (4), a comparison of the rectangles of all the words of the pattern with the <em>m</em> <sub>8</sub> ( <em>M</em> ) combination rectangle can be added. </p><br><p>  We estimate the <em>d</em> ( <em>M</em> , <em>T</em> ) of the pattern as the maximum of the combinations that are included in the pattern: max ( <em>d</em> ( <em>S</em> <sub>1</sub> , <em>T</em> ), <em>d</em> ( <em>S</em> <sub>2</sub> , <em>T</em> ), ...). </p><br><p>  To the existing comparisons of the template with the recognized text, we add checks for the compliance of some text properties (the number of characters on the page <em>m</em> <sub>9</sub> ( <em>T</em> ), the number of columns of text <em>m</em> <sub>10</sub> ( <em>T</em> )) with similar properties of the template <em>m</em> <sub>9</sub> ( <em>M</em> ), <em>m</em> <sub>10</sub> ( <em>M</em> ). </p><br><p>  If for <em>n</em> classes the set of templates <em>M</em> <sub>1</sub> , ..., <em>M</em> <sub><em>n is</em></sub> ready, then the task of checking compliance with class <em>M</em> <sub><em>i of the</em></sub> recognized document page <em>T</em> is reduced to calculating the distance <em>d</em> ( <em>M</em> <sub><em>i</em></sub> , <em>T</em> ) using the scheme outlined and comparing this distance with the previously known threshold <em>d</em> <sub>1</sub> .  If max ( <em>M</em> <sub><em>i</em></sub> ) &lt; <em>d</em> <sub>1 is</sub> true, then the document <em>T</em> corresponds to class <em>i</em> . </p><br><p>  Explain the need to use the elements of the proposed templates. </p><br><p>  Simple single errors of the form E <sub>4</sub> , often appearing in a word, can be ignored with the help of the signs "?"  and "‚àó" in a word mask.  To control the length of a word including the "‚àó" sign, the parameter <em>m</em> <sub>2</sub> can be used, for example, the keywords "CONTRACT", "Contracts" can be described by the kernel "CONTRACT ‚àó" with the restriction <em>m</em> <sub>2</sub> = 8, which excludes from consideration words like "contractual capacity".  The core "? AGREEMENT" allows you to not distinguish between the words "AGREEMENT" and "AGREEMENT". </p><br><p>  The threshold <em>m</em> <sub>1</sub> can be used to require a complete match of a keyword and a word from the text, for example, when <em>m</em> <sub>1</sub> = 0, the kernel "CONTRACT" when searching in the text does not allow the choice of the words "AGREEMENT" or "DOGOOR", differing in one character replacement operation. </p><br><p>  The parameter <em>m</em> <sub>3</sub> also allows you to ignore character case recognition errors. </p><br><p>  The word rectangle (placement, combination, pattern) <em>m</em> <sub>4</sub> provides a partial description in the document structure template by extracting keywords from the specified areas of the document image.  Of course, the very borders of the rectangles cannot be specified precisely, due to the variability of the parts of the documents. </p><br><p>  Errors of the <em>E</em> <sub>3 type</sub> , that is, an incorrectly recognized page structure, can sometimes be ignored by the placement settings.  Placement naturally describes a phrase or several adjacent words.  In the case of splitting a text column into two columns due to recognition errors, the described placement will be found if you do not specify the distance between words <em>m</em> <sub>6</sub> . </p><br><p>  The ability to check both the presence and absence of words, set by the parameter <em>m</em> <sub>5</sub> , allows you to create templates for similar documents, dividing them using keywords that are present in one class of documents and present in another. </p><br><p>  The explanations show the usefulness of the described template scheme for the classification of texts recognized with errors.  The described scheme is simple in the sense that creating a template in some cases is a simple matter, and the template itself is intuitive.  For example, the document "Non-Residential Premises Rental Agreement" can be described with the following pattern: </p><br><ul><li>  keywords: </li></ul><br><p><img src="https://habrastorage.org/files/524/ebb/080/524ebb0805654b7f80151663f50c76c5.gif" alt="image"></p><br><ul><li>  placements: <em>R</em> <sub>1</sub> = <em>W</em> <sub>1</sub> , <em>R</em> <sub>2</sub> = <em>W</em> <sub>2</sub> &amp; <em>W</em> <sub>3</sub> &amp; <em>W</em> <sub>4</sub> , <em>R</em> <sub>3</sub> = <em>W</em> <sub>2</sub> &amp; <em>W</em> <sub>5</sub> &amp; <em>W</em> <sub>6</sub> , <em>R</em> <sub>4</sub> = <em>W</em> <sub>7</sub> &amp; <em>W</em> <sub>8</sub> &amp; <em>W</em> <sub>9</sub> &amp; <em>W</em> <sub>10</sub> , all frames there are no placements, </li><li>  combinations: <em>S</em> <sub>1</sub> = <em>R</em> <sub>1</sub> ‚àß <em>R</em> <sub>2</sub> , <em>S</em> <sub>2</sub> = <em>R</em> <sub>1</sub> &amp; <em>R</em> <sub>3</sub> , <em>S</em> <sub>3</sub> = <em>R</em> <sub>3</sub> , all combinations have no frames, </li><li>  pattern: <em>M</em> = <em>S</em> <sub>1</sub> &amp; <em>S</em> <sub>2</sub> &amp; <em>S</em> <sub>3</sub> , the pattern has a frame <em>m</em> <sub>8</sub> ( <em>M</em> ) = {(0.0.0.0), (0.3,0.9)}. </li></ul><br><p> The task of choosing the best class is solved by calculating the distances <em>d</em> ( <em>M</em> <sub>1</sub> , <em>T</em> ), ..., <em>d</em> ( <em>M</em> <sub><em>n</em></sub> , <em>T</em> ), discarding such classes <em>M</em> <sub><em>j</em></sub> , which is true <em>d</em> ( <em>M</em> <sub><em>j</em></sub> , <em>T</em> )&gt; <em>d</em> <sub>1</sub> , by ordering the resulting set in ascending order ( in essence, we want to choose one or several classes with a minimum penalty for not matching a template to a text) and saving one or several alternatives <em>d</em> ( <em>M</em> <sub><em>i</em> 1</sub> , <em>T</em> ), <em>d</em> ( <em>M</em> <sub><em>i</em> 2</sub> , <em>T</em> ), ....  That is, in the best way, the text <em>T</em> corresponds to the class <em>i</em> 1, and the other classes <em>i</em> 2, ... are ordered by distance.  Conflict resolution <em>d</em> ( <em>M</em> <sub><em>i</em> 1</sub> , <em>T</em> ) = <em>d</em> ( <em>M</em> <sub><em>i</em> 2</sub> , <em>T</em> ) in the simplest case, to conduct, abandoning the classification, in some cases, the conflict is eliminated by using additional features <em>m</em> <sub>9</sub> , <em>m</em> <sub>10</sub> . </p><br><p>  <strong>3. Forming templates (training)</strong> </p><br><p>  Obviously, the described pattern matching method is simple, but a certain complexity is present in the process of pattern formation, that is, in training. </p><br><p>  Consider the process of forming templates on a real example for the flow of documents 45 classes.  We prepared templates in several stages, focusing on keywords on the first page of multipage documents. </p><br><p>  <u>Stage 1.</u> At the beginning we looked at many <em>reference documents</em> .  For each class, several samples of ideal documents were prepared, in the recognition results of which there were no errors.  Textual representations of these documents were converted into word bags, i.e.  in multisets of words from which <em>stop words</em> were removed (short words, full name, numerical data, dates, etc.).  Then, using simple reusable algorithms from these multisets, single words and phrases of several words were found, inherent in one of the classes.  The focus was on characteristic words from the headings and titles of sections of the document.  Thus, it was composed of several locations, well separating one class from the other.  Thus, we searched for the core of keywords, and the remaining parameters were set by default.  Immediately, several problem classes were identified, for example, the first page of documents of the Charter class could be represented by a single key word of the Charter, which is often found in other documents, for example, in documents of the Contract class.  To eliminate this problem, we used two methods: </p><br><ul><li>  the use of words that should not appear on the first page of documents of the ‚ÄúCharter‚Äù class, </li><li>  the use of the attribute <em>m</em> <sub>9</sub> ( <em>T</em> ) - the number of characters on the page - which well distinguished the pages of documents of the "Charter" class. </li></ul><br><p>  <u>Stage 2.</u> Further, despite some imperfections of the classification with the resulting templates, we moved on to a sample of documents consisting of 50-100 samples of <em>real documents</em> (single-page and multi-page), the recognition of which gave a wide range of errors of all types of  <sub>1</sub> -  <sub>4</sub> .  Error analysis revealed a number of pages that required modifying the templates, and pages that could not be classified by our technology (primarily due to the large number of recognition errors).  Modification of templates was reduced to the search for new placements and combinations, the search for words that should not appear in the document, as well as the choice of parameters for keywords, first of all, rectangles <em>m</em> <sub>4</sub> and distances between words <em>m</em> <sub>6</sub> .  The analysis of the classification results was carried out according to the following criteria: </p><br><p><img src="https://habrastorage.org/files/c23/a07/60d/c23a0760d1dd46a9a80eb254d10a73a7.jpg" alt="image"></p><br><p>  Correctly classified pages are estimated by <em>accuracy</em> ( <em>n</em> <sub>1</sub> + <em>m</em> <sub>2</sub> ) / ( <em>n</em> <sub>1</sub> + <em>n</em> <sub>2</sub> + <em>n</em> <sub>3</sub> + <em>m</em> <sub>1</sub> + <em>m</em> <sub>2</sub> ), errors of false classification - as ( <em>n</em> <sub>2</sub> + <em>m</em> <sub>2</sub> ) / ( <em>n</em> <sub>1</sub> + <em>n</em> <sub>2</sub> + <em>n</em> <sub>3</sub> + <em>m</em> <sub>1</sub> + <em>m</em> <sub>2</sub> ), and refusals to classify as ( <em>n</em> <sub>3</sub> ) / ( <em>n</em> <sub>1</sub> + <em>n</em> <sub>2</sub> + <em>n</em> <sub>3</sub> + <em>m</em> <sub>1</sub> + <em>m</em> <sub>2</sub> ). </p><br><p>  The most unpleasant classification error is the false classification of a non-first (intermediate and last) page of a multi-page document.  This is explained by the subsequent storage of a multi-page document in the form of several parts and the need for correction that requires searching for the missing part of the document.  For the classification of non-first pages, the described method was used, using intermediate and last page templates.  The remaining classification errors (incorrect classification of the first page of a multi-page document or a single page of a single-page document) are corrected by simply replacing the class using the directory. </p><br><p>  <u>Stage 3.</u> The first two stages are based on the <em>use of rules</em> (the actual templates) to be assigned to a particular class.  For high-volume samples (3000‚Äì30000 samples of each class), <em>machine learning is</em> possible, for example, using the well-known method of constructing a binary decision tree CART (Classification and Regression Trees [9]).  The initial data for learning are descriptions of the keywords known in the previous stages in the form of the core and features.  On these signs several trees were built, for each class, according to the strategy one against all.  If some document in the classification process was not recognized by one of the trees, a classification failure is generated.  Of the known features of the CART method, we note the need for a sufficiently large amount of the training sample for stable learning.  Because of this, we will not present the classification results obtained using the CART method, although in general they are superior to the classification results obtained through training in stages 1 and 2. </p><br><p>  <strong>4. Experiments</strong> </p><br><p>  For the experiments, two test sets were used: </p><br><ul><li>  containing images of documents of medium and poor quality of digitization, selected for the learning stage (884 pages), </li><li>  containing images of documents of average quality of digitization, obtained regardless of the stage of training (3014 pages). </li></ul><br><p>  The results of the classification are presented below in two tables: </p><br><p><img src="https://habrastorage.org/files/684/b8c/ef4/684b8cef4cff4b6f915b926d8a405b31.jpg" alt="image"></p><br><p>  It is clear from the above tables that the classification technology described by us gives an accuracy of 0.86 - 0.95, while a false classification does not exceed 0.01, the remaining errors relate to the refusals of classification.  That is, the proposed method does not always work, but rarely offers the wrong class. </p><br><p>  The speed of implemented classification (Release build using Microsoft Visual Studio 2013) is quite large: 3000 recognized pages are processed in about 1 minute on an Intel¬Æ Core (TM) i7-4790 computer CPU 3.60 GHz, 16.0 GB, Windows 7 prof 64-bit .  However, the actual OCR Tesseract recognition required for the HOCR source file takes several seconds. </p><br><p>  To reduce the proportion of pages left unclassified, the following possible steps are necessary: </p><br><ul><li>  the use of binarization methods, which remove the background on contaminated documents and documents with a complex background, </li><li>  use of other OCR, </li><li>  the use of more efficient methods of classification based on the search for keywords, for example, the CART method described above. </li></ul><br><p>  <strong>Conclusion</strong> </p><br><p>  The described classification technology was used in the projects implemented by Smart Engines for input and analysis of the flow of scanned documents. </p><br><p>  The described technology is easy to understand and self-implementation for solving similar problems. </p><br><h4 id="spisok-poleznyh-istochnikov">  List of useful sources </h4><br><ol><li>  Gonzalez R., Woods R. Digital Image Processing.  M: Technosphere, 2005. 1070 p. </li><li>  Smirnov SV. TECHNOLOGY AND SYSTEM OF AUTOMATIC CORRECTION OF RESULTS IN RECOGNITION OF ARCHIVAL DOCUMENTS.  Thesis for the degree of candidate of technical sciences, SPT :, 2015. - 130 p. </li><li>  "Recognition of the Passport of the Russian Federation on a mobile phone" ( <a href="https://habrahabr.ru/company/smartengines/blog/252703/">https://habrahabr.ru/company/smartengines/blog/252703/</a> ) </li><li>  Martin D., Jurafsky D. Speech and Language Processing.  Language recognition, computational language and language recognition.  Pearson Prentice Hall, 2009. - 988 p. </li><li>  Wonder JM, Croft WB Proc.  Conference on Research and Development in Information Retrieval.  ACM.  1998. - P. 275‚Äì281. </li><li>  Indexing by Latent Semantic Analysis / S. Deerwester [et al.] // Journal of the American Society for Information Science.  1990. - V. 41, ‚Ññ 6. - P. 391. </li><li>  Chernyak EL. DEVELOPMENT OF COMPUTING METHODS OF TEXT ANALYSIS USING ANNOTATED SUFFIX TREES.  Thesis for the degree of candidate of technical sciences, M :, 2016. - 124 with </li><li>  Levenshtein V.I.  Binary codes with correction of fallouts, insertions and substitutions of symbols, - Moscow: Reports of the Academy of Sciences of the USSR, v.163.4, 1965. - 845-848 p. </li><li>  Breiman L., Friedman JH, Olshen RA, &amp; Stone CJ Classification and regression trees.  Monterey // CA: Wadsworth &amp; Brooks / Cole Advanced Books &amp; Software, 1984. - 368 p. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/321782/">https://habr.com/ru/post/321782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321770/index.html">Speed ‚Äã‚Äãreading How to quickly absorb information, knowing the structure of the text</a></li>
<li><a href="../321772/index.html">Virtual Quest Rakes, Part One: Game Design, Developers, Slam Choice</a></li>
<li><a href="../321776/index.html">Simplify working with Russian texts in Sublime Text 3 + Vintage</a></li>
<li><a href="../321778/index.html">Reduction with the use of "regulators": the task of satisfiability</a></li>
<li><a href="../321780/index.html">Offers and verticals in traffic arbitration</a></li>
<li><a href="../321784/index.html">VR rendering and optimization</a></li>
<li><a href="../321786/index.html">Minimalism in game design: examples, tips and ideas. Part one</a></li>
<li><a href="../321788/index.html">From multichannel to omnicanality</a></li>
<li><a href="../321790/index.html">Reverse engineering messages Protocol Buffers</a></li>
<li><a href="../321792/index.html">Test Pass Library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>