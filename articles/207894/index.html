<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interview with Bj√∂rn Stroustrup about C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few hours remained until New Year 2014, in which, among other things, all of us were promised a new standard C ++ 14. However, it will not be a larg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interview with Bj√∂rn Stroustrup about C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/de5/1e8/b80/de51e8b8089eb68899bb3ac76563768c.jpg" alt="image" align="left"><br>  A few hours remained until New Year 2014, in which, among other things, all of us were promised a new standard C ++ 14.  However, it will not be a large independent update, but only a refinement of C ++ 11, a bug fix that will give the current version of the language a complete look.  Against this background, <b>William Wong</b> (from <i>William Wong</i> ) from <a href="http://electronicdesign.com/">electronicdesign.com</a> has interviewed <i>Bjarne</i> <b>Straustrup</b> (dat. <i>Bjarne Stroustrup</i> ), the creator of C ++.  The conversation touched on several topics: from the history of C ++ development and the features of the C ++ 11 standard to the problem of learning this programming language. <br><br>  Some of the terms and concepts from this interview I previously met exclusively in the English version (for example, the word embedded in the context of IT), and I was not always able to find a generally accepted translation in which I would not be sure myself.  In these and other ambiguous cases, I indicated the English version of the term in brackets or left it completely untranslated. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the end of the article are links and my notes.  The owners of this resource kindly allowed me to translate this interview and publish the translation in Habr√©, but insisted that I specify the source in a certain way.  Do not blame me.  Immediately after the link is the actual translation. <br><br>  <b>Electronic Design, October 29, 2013, <a href="http://electronicdesign.com/dev-tools/interview-bjarne-stroustrup-discusses-c">electronicdesign.com/dev-tools/interview-bjarne-stroustrup-discusses-c</a></b> <br><br><a name="b_1"></a><br>  To date, the programming languages ‚Äã‚ÄãC and C ++ are the most popular in the field of embedded (embedded) systems, as well as in the tasks of building platforms for third-party applications.  The author of C ++ is Bjorn Straustrup.  He still takes an active part in developing the standards of this programming language, including the latter - C ++ 11.  He wrote a lot about this language in his books, for example, in <a href="https://habr.com/ru/post/207894/">‚ÄúProgramming: Principles and Practice using C ++‚Äù</a> .  Bj√∂rn Straustrup has kindly agreed to answer a few questions about the C ++ language itself and its design. <br><br>  <b>How did you come to develop C ++?</b> <br><br>  I worked on a project that would allow the Unix kernel to be split into several parts, executed by a multiprocessor or a high-performance local network.  And I needed a tool that would allow working with the hardware, providing good performance for system programming tasks, and could also be used to work on a system with a complex architecture.  However, at that time (1979-1980), none of the existing programming languages ‚Äã‚Äãdid not satisfy all three conditions at once.  So I decided to add to C the concept of classes - like the one that was in Simula.  At first, I implemented checks and transformations of function arguments (later they became function prototypes), constructors, destructors, as well as the simplest inheritance.  The first version of the C ++ language was called ‚ÄúC with Classes‚Äù.  By the way, it is curious that for the simplest support of generic programming, it used macros.  Later I realized that this approach does not provide proper scalability, and instead of macros I added templates. <br><br>  I improved the architecture and implementation of the C ++ language over the next few years, until its commercial release in 1985.  At that time, the performance and speed of accessing the hardware were very important characteristics, just like today.  I found it necessary to implement in C ++ all the features of the C language, and to make them equally effective.  For example, in the early stages I found that the structures used to implement the copy constructor occupied 3% more memory than in C. I decided that this should not be so, and by the end of the week I fixed everything.  So that programmers do not have to abandon classes without losing any CPU time, inline functions were also added.  In general, I was sure that the tools used should be not only expressive, but also effective enough to be used in the applications with the highest requirements. <br><a name="b_2"></a><br>  <b>What did you strive for when developing the C ++ language?</b> <br><br>  In addition, C ++ could work with the hardware at least as effectively as C did. In addition, the concept of abstractions seemed to me to be very important, which would allow programmers to express their wildest ideas without any time or memory leaks, which they would most likely encounter in self-realization. <br><br>  This requirement entails the use of <a href="https://habr.com/ru/post/207894/">strong static typing</a> , as opposed to weak typing in C. <br><br>  C ++ language was developed for people who are engaged in programming seriously, that is, for professionals in their field.  It can be used - and is used - by newbies, but often this leads to different misunderstandings and complaints that not everyone can learn to program in C ++ and that there are things that are very difficult to implement in this language.  Of course, there is no universal programming language for everything and everyone, C ++ was never created like this.  However, this language is very effective in those areas for which it was developed, such as system programming or programming programs with severe limitations on computer resources.  C ++ has no equal where its power is really needed, and I don‚Äôt care much that you can write a simple JavaScript or Ruby web application instead.  C ++ is not inherently intended for solving problems of medium complexity, with weak requirements for program performance and reliability, as well as it is not intended for use by not very experienced programmers with moderate development skills.  Of course, it can be used in such conditions and today it is widely practiced, but there are many other programming languages ‚Äã‚Äãthat would be suitable for this much better. <br><a name="b_3"></a><br>  About the key principles that I adhered to when developing C ++, I spoke in my book <a href="https://habr.com/ru/post/207894/">‚ÄúThe Design and Implementation of C ++‚Äù</a> and in two articles written for the conference ‚ÄúHistory Of Programming Languages‚Äù.  In short, I set the following goals: <br><br><ul><li>  efficient support for data abstraction.  Code using abstractions should not allow any overhead in comparison with code without using it, </li><li>  Principles of interaction of the C ++ language and its compiler with the computer should be as similar as possible to those of C, </li><li>  significant code flexibility that can be achieved using abstractions, as well as </li><li>  code reliability, which is achieved using strong static typing. </li></ul><br><br>  If in general, C ++ is designed to help in writing high-quality program code.  Professional programmers in real life are faced with complex tasks, and this programming language greatly simplifies their lives. <br><br>  Although, of course, it will not be possible to achieve all these goals at once, and C ++ is not perfect.  However, despite countless attempts to create a language instead, C ++, with its strict design, remains the best solution for a wide variety of practical tasks. <br><br>  <b>You have been involved in the development of the C ++ standard from the very beginning.</b>  <b>Has it changed much over time?</b>  <b>Who develops new standards?</b> <b><br></b> <br><br>  It is hard to say.  The development of a formal standard is a very difficult and, as a rule, dreary business.  They are engaged in people with great experience, but they are all specialists in completely different areas of programming, and each has its own vision of the standard.  So it can be difficult and time consuming to come to a common opinion, but this is necessary: ‚Äã‚Äãit‚Äôs impossible to satisfy all the requirements at once, and it is impossible to force programmers to use fundamentally new tools.  Progress occurs only when supplements are included in the standard, the importance of which is generally recognized.  You can not take part in the committee and at the same time constantly get hung up on the little things.  You need to be able to see the whole picture and come to a common opinion with the rest.  According to my calculations, the committee includes about a hundred organizations and, maybe, more than three hundred actual developers.  This is two to three times more than before.  Only at the last meetings attended by about a hundred people. <br><br>  In 2014, we plan to release a new standard, C ++ 14.  It will contain minimal innovations, as well as a few corrections, the majority of the committee has already voted for their necessity.  I expect that in 2014 everyone will already use C ++ 14, and after that we plan to release C ++ 17 in 2017.  But this update will be much more significant, so it‚Äôs difficult to judge the timing. <br><br>  The ISO C ++ Standards Development Committee itself does not have any resources, be it money or full-time developers.  It is completely based on the means of its members.  For example, to be a member of the committee, they pay $ 1,200 annually.  Anyone can declare that, they say, in C ++ there is no normal library for creating graphical interfaces or normal support for task parallelism.  Yes, we know.  Than to complain, it would be better to help bring these tasks to mind.  We have very few application programmers, and often it turns out that innovations are created in favor of the interests of one particular developer. <br><br>  <b>Many programmers in the development of embedded systems prefer to use C, because it is simpler than C ++, and is more suitable for developing for hardware.</b>  <b>Is C ++ complexity really a stumbling block for developing embedded systems?</b> <b><br></b> <br><br>  Not at all.  If you adhere to C-style programming, C ++ will be just as easy as C, and it is also suitable for developing for hardware.  And surely C ++ is much more efficient than C. I have never seen such a program in C ++, which could be rewritten in C so that it will have less code, it will be more productive, it will be better accompanied - in general, it will be more efficient .  I do not believe that this is possible. <br><br>  The myth that ‚ÄúC is better than C ++‚Äù confuses so many novice programmers.  So, for example, when they encounter problems, they constantly try to invent something and use completely non-trivial things, rather than using simple and powerful tools.  In the end, they get a very complex and confusing code, which, due to their delusions, they take for reference.  This whole situation just amazes me.  If a person takes on something, and he is constantly told that it is very difficult and useless, then he will not succeed in anything.  The only intelligible reason that, as I know, use pure C, not C ++, is the limited capabilities of a particular platform. <br><br>  However, students and generally newcomers to learning C ++ cannot be blamed, because their mistakes often originate in the process of mastering a university programming course.  One day, ten years ago, I happened to lead him among freshmen.  I looked into the textbooks - and I was just amazed: instead of clear and easy-to-use C ++ constructions, the books at the beginning considered a bunch of different, unobvious trivia of the C language, and the C ++ tools were presented as something very complicated.  This did not discourage only those who wanted to seriously engage in programming. <br><br>  Seriously, tell me: are vectors from the standard library more complicated than arrays from C?  Or, for example, why are students being taught the <code>qsort()</code> function, although <code>sort()</code> both more efficient and more versatile?  C ++ has more strict typing than C, due to which object code is processed faster. <br><br>  Even in textbooks, C ++ is often described as a failed attempt to create a pure object-oriented programming language.  Such a statement is usually illustrated by a whole sheet of code in which virtually the entire architecture is broken down into an intricate hierarchy of classes inherited from each other.  The result is a completely unrelated character for C ++.  Such code is more like a Java program, and, sadly, it usually works slowly. <br><br>  I also do not like C ++ the way the authors of those textbooks represent it.  In response, I wrote my book for students and self-taught teachers - ‚ÄúProgramming: Principles and Practice using C ++‚Äù.  For her study of programming experience is not required, but it caused interest among experienced developers.  Only if you just need a review of C ++ 11, then this book will be quite large.  For this purpose, I would recommend the book A Tour of C ++.  It describes all the key points of ISO C ++ and the standard library of just 180 pages.  The C ++ 11 standard is fully supported by the Clang and GCC compilers, partly by Microsoft C ++ and many others, although I'm afraid it may not work correctly on less popular platforms. <br><a name="b_4"></a><br><br>  <b>In C ++ 11, there were many innovations, including lambda expressions and support for multi-threaded programming.</b>  <b>Do you think they were in demand?</b> <b><br></b> <br><br>  To work with streams, I constantly had to use third-party libraries.  They were good, but for the last fifteen years I have wanted to add support for flows to the standard, which we have finally achieved.  From the point of view of parallel programming, the key innovations of C ++ 11 consist in the <a href="https://habr.com/ru/post/207894/">organization of memory</a> (which, by the way, was borrowed for the C language), as well as the portability of multi-threaded programs.  However, if you are programming at the level of flows and barriers, then the most important for you may be type safety (type safety): no more macros or <code>void**</code> are required to separate and transfer data between threads.  However, for someone, tools for lock-free programming are also important. <br><br>  As for lambda expressions, I have been working for about ten years on implementing them in C ++, which would be more beneficial than harmful.  Third-party libraries typically suffer performance.  We also managed to achieve lambda expressions of performance comparable to the <code>for</code> loop.  I will give an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;v.size(); ++i) sum += v[i]; <span class="hljs-comment"><span class="hljs-comment">// array style</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = v.begin(); p!=v.end(); ++p) sum += *p; <span class="hljs-comment"><span class="hljs-comment">// pointer style</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; for_each(v.begin(),v.end(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d) { sum += d; }); <span class="hljs-comment"><span class="hljs-comment">// algorithm style</span></span></code> </pre><br><br>  These three code points do the same thing and work with the same performance.  You can choose between them based on considerations of programming style, maintainability, and so on. <br><br>  I would use lambda expressions in just a few cases.  In this, for example: <br><br><pre> <code class="cpp hljs">sort(v, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a&gt;b; }); <span class="hljs-comment"><span class="hljs-comment">// sort in reverse order</span></span></code> </pre><br><br>  Lambda expressions are a new and quite powerful tool.  The catch is that programmers like to use such things literally everywhere, until they understand how this will turn out in the future.  For example, it seems to me that it is better to declare the function and functional objects separately.  The desired operation will then have its own name, which can be easily called from different parts of the program. <br><br>  Also lambda expressions open up a lot of room for writing code.  This is probably not the place to teach you C ++ 11, but let me give you one example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Value_type&lt;C&gt;*&gt; find_all(C&amp; cont, V v) <span class="hljs-comment"><span class="hljs-comment">// find all occurrences of v in cont { vector&lt;Value_type&lt;C&gt;*&gt; res; for (auto&amp; x : cont) if (x==v) res.push_back(&amp;x); return res; }</span></span></code> </pre><br><br>  In this code, I applied several new things to C ++.  The <code>for</code> loop, for example, here reads ‚Äúfor all <code>x</code> from <code>cont</code> ‚Äù and makes it easier to <code>cont</code> through the container <code>cont</code> .  The <code>auto&amp; x</code> declaration indicates that <code>x</code> should be a reference to the type of elements of the initializing container, in this case the type of elements <code>cont</code> .  This loop collects the addresses of all occurrences of <code>v</code> in <code>cont</code> and adds them to the vector of <code>res</code> pointers.  So these constructs are no more than syntactic sugar, although they are very convenient. <br><br><a name="b_5"></a><br>  The essential innovation lies in <code>return</code> : note that I returned the vector by value.  In C ++ 98, this return statement would create a copy of <code>res</code> , but in fact it can be large and consist of thousands of elements.  In terms of performance, this would be very imprudent.  And in C ++ 11, vectors have a so-called <a href="https://habr.com/ru/post/207894/">move constructor</a> , which instead of copying, ‚Äúborrows‚Äù the res representation (in essence, only three pointers) for use at the place where the <code>find_all()</code> function is <code>find_all()</code> , and the vector itself leaves empty.  After doing a <code>return</code> we can never use <code>res</code> again.  Thus, returning a vector by value will cost a maximum of six assignments, regardless of the size of the vector. <br><br>  Displacement constructors are a fairly simple tool.  It is available to every programmer, and, moreover, is implemented in all container classes of the standard library.  This allows you to easily return large objects from functions and not to break your head once more over memory management. <br><br>  You can <code>find_all()</code> function as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m {<span class="hljs-string"><span class="hljs-string">"Mary had a little lamb"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p : find_all(m,<span class="hljs-string"><span class="hljs-string">'a'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// p is a char* if (*p!='a') cerr &lt;&lt; "string bug!\n"; vector&lt;string&gt; v {"Mary‚Äù, ‚Äúlamb", ‚ÄúMary‚Äù, ‚Äúmary‚Äù, ‚Äúwolf‚Äù}; for (const auto p : find_all(v,‚ÄùMary‚Äù)) // p is a string* if (*p!=‚ÄùMary‚Äù) cerr &lt;&lt; "vector&lt;string&gt; bug!\n"; }</span></span></code> </pre><br><br>  Try to write the same code without applying the templates and innovations of C ++ 11 and compare the results. <br><br><a name="b_6"></a><br>  On this subject, I recommend reading ‚ÄúA Tour of C ++‚Äù, for details, refer to the fourth edition of the book <a href="https://habr.com/ru/post/207894/">‚ÄúThe C ++ Programming Language‚Äù</a> . <br><br>  <b>What are some common mistakes that modern C ++ programmers have?</b> <br><br>  For some reason, they often think that they have to choose between effective and elegant code.  They either limit themselves to the low-level capabilities of the language (for the sake of "efficiency"), or they build a huge architecture "for all occasions" (assuming such code is very elegant).  In my opinion, the ideal is a combination of maximum efficiency and the most optimal architecture.  This happens when the solution of the programmer in the most optimal way satisfies the conditions of the problem, but this, of course, is not always possible.  It is rarely possible to achieve this at the first attempt, but it happens quite often, as far as possible for the ideal. <br><br>  Before giving up on C ++ features like classes or templates, first try to consider their basic use and practice.  A reasonable choice will lead you much further than the steps taken at random.  Don't commit yourself to building huge class hierarchies or writing intricate meta-code with templates: some of the most powerful features of C ++ are very simple.  The best way to write effective code is to not complicate it unnecessarily. <br><br>  <b>What do you like to do in your free time?</b> <br><br>  I am interested to travel to different places.  I also like to go jogging.  I also take a great interest in photography, I like listening to music and reading - artistic and historical literature.  I try to spend time with my family and friends.  Of course, programming also sometimes gives me a lot of fun, but the question must not be about work.  I like to do research, build complex software systems.  As someone said, "I can not believe that I still pay for it!" <br><br><h5>  Translator's notes </h5><br><br><ol><li><a name="1_book_principles"></a>  "Programming.  Principles and practice of using C ++ "in the translation of Dmitry Klyushin, publishing house" Williams. "  <a href="https://habr.com/ru/post/207894/">backwards</a> </li><li><a name="2_types"></a>  About typing, see the article <a href="http://habrahabr.ru/post/161205/">Literacy on typing in programming languages</a> .  <a href="https://habr.com/ru/post/207894/">backwards</a> </li><li><a name="3_book_design"></a>  Probably, here we still mean the book ‚ÄúThe Design and Evolution of C ++‚Äù - ‚ÄúDesign and Evolution of C ++‚Äù in the translation of the publishing house ‚ÄúPeter‚Äù.  <a href="https://habr.com/ru/post/207894/">backwards</a> </li><li><a name="4_memory"></a>  The C ++ 11 memory model is discussed in detail in the <a href="http://habrahabr.ru/company/ifree/blog/197520/">Lock-free data structure</a> article <a href="http://habrahabr.ru/company/ifree/blog/197520/">.</a>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Basics: Memory model</a> .  <a href="https://habr.com/ru/post/207894/">backwards</a> </li><li><a name="5_move"></a>  A brief overview of move semantics in C ++ 11 is provided in the article <a href="http://habrahabr.ru/post/174019/">Move semantics in C ++ 11 and STL containers</a> .  <a href="https://habr.com/ru/post/207894/">backwards</a> </li><li>  In general, the key innovations of C ++ 11 (including the aforementioned) are highlighted in the article <a href="http://habrahabr.ru/post/182920/">Ten C ++ 11 Features that every C ++ developer should use</a> . </li><li><a name="6_book_cpp"></a>  In the Russian translation of Nikolai Martynov, the publishing house Binom, the book is called the C ++ Programming Language, but I could only find the re-release of the bearded, irrelevant edition of 2001.  I did not find any other translations at all.  <a href="https://habr.com/ru/post/207894/">backwards</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/207894/">https://habr.com/ru/post/207894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207874/index.html">Happy New Year!</a></li>
<li><a href="../207884/index.html">Library for client side caching</a></li>
<li><a href="../207888/index.html">Outsourcing plus backsourcing minus problems</a></li>
<li><a href="../207890/index.html">Optimization of function calls from workers (web-workers)</a></li>
<li><a href="../207892/index.html">BITcommander - your next file manager</a></li>
<li><a href="../207896/index.html">Finding missing keys in yaml files</a></li>
<li><a href="../207898/index.html">12 security levels in Windows Phone 8 using the example of Lumia 1520</a></li>
<li><a href="../207900/index.html">To girls: five reasons to marry an IT person and five reasons to think about it before</a></li>
<li><a href="../207902/index.html">Intuitive and easy-to-use user interface (GUI) layout for communicators and tablet PCs</a></li>
<li><a href="../207904/index.html">Spine - first steps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>