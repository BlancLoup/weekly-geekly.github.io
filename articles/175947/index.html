<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous API and Deferred object in detail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most modern programming languages ‚Äã‚Äãallow the use of asynchronously executed blocks of code. Along with the flexibility gained by using the asynchrono...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous API and Deferred object in detail</h1><div class="post__text post__text-html js-mediator-article">  Most modern programming languages ‚Äã‚Äãallow the use of asynchronously executed blocks of code.  Along with the flexibility gained by using the asynchronous approach, the one who has risked applying it also gets code that is more difficult to understand and maintain.  However, any complication that programmers encounter, as a rule, finds a practical solution in the form of a new approach or an increase in the level of abstraction.  In the case of asynchronous programming, this means is an object of the type <b>pending result</b> or <b>deferred</b> (English <i>deferred</i> - deferred, delayed). <br><br>  The article will cover basic approaches to returning asynchronous results, callback functions, deferred objects, and their capabilities.  Examples in the JavaScript language will be given, and a typical deferred object will be parsed.  The article will be useful to programmers who begin to comprehend asynchronous programming, as well as those familiar with it, but not owning the deferred object. <br><a name="habracut"></a><br><h2>  Synchronous and asynchronous calls </h2><br>  Any function can be described in synchronous and asynchronous form.  Suppose we have a <code>calc</code> function that performs some calculation. <br><br>  In the case of the usual, "synchronous" approach, the result of the calculation will be transmitted through the return value, that is, the result will be available <i>immediately</i> after the function is executed, and can be used in another calculation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = calc(); another_calc(result * <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  The code is executed strictly sequentially, the result obtained on one line can be used on the next.  This is reminiscent of the proof of the theorem, when subsequent statements logically follow from previous ones. <br><br>  In the case of an asynchronous call, we cannot get the result in place.  By calling the <code>calc</code> function, we only point out the need to perform a calculation and get its result.  In this case, the next line will begin to run without waiting for the previous one.  Nevertheless, we somehow need to get the result, and here a callback comes to the rescue - a function that will be called by the system upon the arrival of the result of the calculation.  The result will be passed to this function as an argument. <br><br><pre> <code class="javascript hljs">calc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ another_calc(result * <span class="hljs-number"><span class="hljs-number">2</span></span>); }); no_cares_about_result();</code> </pre><br>  The example shows that the function now has a signature: <code>calc(callback)</code> , and <code>callback</code> takes the result as the first parameter. <br><br>  Since <code>calc</code> is performed asynchronously, the <code>no_cares_about_result</code> function <code>no_cares_about_result</code> not access its result, and, generally speaking, it can be executed earlier than callback (if we are talking specifically about JavaScript, if the function being called is truly asynchronous, instead of taking data from the cache, for example it is guaranteed that it will always be executed after the execution of the calling code, that is, the remaining code will always be executed before the callback (this will be discussed below). <br><br>  Agree, such a code has already become somewhat more difficult for perception, with the same semantic load as its ‚Äústraight-line‚Äù synchronous analogue.  What is the benefit of using the asynchronous approach?  First of all - in the rational use of system resources.  For example, if <code>calc</code> is a time-consuming calculation that can be time consuming, or uses some external resource, the use of which imposes a certain delay, then with a synchronous approach, all subsequent code will be forced to wait for the result and will not be executed until <code>calc</code> executed.  Using the asynchronous approach, you can explicitly specify which part of the code depends on a certain result, and which part is indifferent to the result.  In the example, <code>no_cares_about_result</code> does not explicitly use the result, and therefore it does not need to expect it.  The part of the code inside the callback will be executed only after receiving the result. <br><br>  Generally speaking, most of the APIs, by their nature, are asynchronous, but can mimic as synchronous: access to remote resources, queries to the database, even the file API is asynchronous.  If the API ‚Äúpretends‚Äù to be synchronous, then the success of such ‚Äúpretense‚Äù is associated with delays in the result: the lower the delay, the better.  The same file API, working with the local machine, shows small delays and is often implemented as synchronous.  Work with remote resources and access to the database is increasingly being implemented asynchronously. <br><br><h2>  Multi-level calls </h2><br>  The difficulties of the asynchronous approach become more noticeable when it is necessary not only to make an asynchronous call, but, having received its result, to do something with it and use it in another asynchronous call.  Obviously, the synchronous approach in several consecutively executed lines of code does not fit here: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = calc_one(); result = calc_two(result * <span class="hljs-number"><span class="hljs-number">2</span></span>); result = calc_three(result + <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// using result</span></span></code> </pre><br>  The code will take the following form: <br><br><pre> <code class="javascript hljs">calc_one(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ calc_two(result * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ calc_three(result + <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// using result }); }); });</span></span></code> </pre><br>  Firstly, this code has become ‚Äúmulti-level‚Äù, although, in its actions it is similar to synchronous.  Secondly, in the signatures of the functions <code>calc_two</code> , <code>calc_three</code> <i>input parameters</i> and the callback are mixed, which, in essence, is the place where the <i>result</i> is returned, that is, the output parameter.  Thirdly, each function may fail with an error and the result will not be obtained. <br><br>  This code can be simplified by defining callback functions separately and passing them by name, however, this is not a solution to all problems.  This requires a new level of abstraction, namely, we can abstract <i>an asynchronous result</i> to abstraction. <br><br><h2>  Asynchronous result </h2><br>  What is such a result?  In essence, this is an object containing information that the result will ever come or has already arrived.  The result is subscribed to through the same callback, but now it is encapsulated in this object and does not oblige asynchronous functions to implement callbacks as input parameters. <br><br>  In essence, the result object requires three things: to implement the ability to subscribe to the result, the ability to indicate the arrival of the result (this will be used by the asynchronous function itself, not the API client), and the storage of this result. <br><br>  An important distinctive feature of such an object is also the specificity of its states.  Such an object can be in two states: 1) there is no result and 2) there is a result.  Moreover, the transition is possible only from the first state to the second.  When the result is obtained, it is no longer possible to go into a state of its absence or a state with a different result. <br><br>  Consider the following simple interface for this object: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deferred</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  The <code>on</code> method accepts callback.  Callback will be called as soon as the result is available and will be passed as a parameter.  Here is a complete analogy with the usual callback passed as a parameter.  At the time of registration of the kollbek, the object can be in the state with the result and without.  If there is no result yet, the callback will be called upon his arrival.  In case the result is already there, the callback will be called immediately.  In both cases, the callback is called once and gets the result. <br><br>  The <code>resolve</code> method allows you to translate (split) an object into a state with a result and specify this result.  This method is <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B4%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">idempotent</a> , that is, repeated calls to <code>resolve</code> will not change the object.  Upon transition to the state with the result, all registered callbacks will be called, and all callbacks that will be registered <i>after the</i> call to <code>resolve</code> will be called up instantly.  In both cases (registration before and after calling <code>resolve</code> ), callbacks will get the result, due to the fact that the object stores it. <br><br>  The object with this behavior is called <b>deferred</b> (and also known as <i>promise</i> and <i>future</i> ).  It has several advantages over simple callbacks: <br><br>  1. Abstraction of the asynchronous function from the result: now each asynchronous function is not required to provide callback parameters.  Subscription to the result remains for the client code.  For example, you can don‚Äôt subscribe to the result at all if we don‚Äôt need it (similar to passing the noop function as a callback).  The asynchronous function interface becomes cleaner: it has only significant input parameters, it becomes possible to more reliably use functions with an indefinite number of parameters, an options parameter, and so on. <br>  2. Abstraction from the state of the result: the client of the code does not need to check the current state of the result, he simply signs the handler and does not think about whether the result has arrived or not. <br>  3. The possibility of multiple subscriptions: you can sign more than one handler and they will all be called when the result arrives.  In a scheme with callbacks, we would have to create a function that calls a group of functions, for example. <br>  4. A number of additional amenities, including, for example, the ‚Äúalgebra‚Äù of deferred objects, which allows you to define relationships between them, run them in a chain or after the successful completion of a group of such objects. <br><br>  Consider the following example.  Let there be an asynchronous function <code>getData(id, onSuccess)</code> , which takes two parameters: the id of some element that we want to receive and the callback to get the result.  A typical usage code would look like this: <br><br><pre> <code class="javascript hljs">getData(id, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do some actions with item });</span></span></code> </pre><br>  Rewrite it using <code>Deferred</code> .  The function now has a signature <code>getData(id)</code> and is used as follows: <br><br><pre> <code class="javascript hljs">getData(id).on(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do some actions with item });</span></span></code> </pre><br>  In this case, the code is practically not complicated; rather, the approach has simply changed.  The result is now passed through the return value of the function as a deferred.  However, as will become noticeable further, in more complex cases the use of deferred gives some advantage in the readability of the code. <br><br><h2>  Error processing </h2><br>  A reasonable question would be about handling errors when using such objects.  In synchronous code, an exception mechanism is widely used, which in case of an error allows to transfer control to higher blocks of code, where all errors can be caught and processed, without complicating the ‚Äúlocal‚Äù code, freeing the programmer from having to write checks for every code. <br>  In asynchronous code (and in any scheme with callbacks), there is some difficulty in using exceptions, because an exception will come asynchronously, as well as the result, and therefore it cannot be easily caught by framing the asynchronous function call in <code>try</code> .  If we consider an error, then in fact, this is only a different result of the function (negative, we can say, but also a result), with the object of error (exception) being the return value. <br><br>  Such a result, as well as a successful one, is realized in the form of a kollbek (sometimes called <i>errback</i> , a game of words from <i>error</i> and <i>back</i> ). <br><br>  Let's strengthen our learning object <code>Deferred</code> so that it can provide a subscription separately for success and for failure, namely, rework the methods <code>on</code> and <code>resolve</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, callback</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  As a first parameter, you can pass the value of an enumerated type with two values, for example, <code>E_SUCCESS</code> , <code>E_ERROR</code> .  For readability, we will use simple string values ‚Äã‚Äãin the examples: 'success', 'error'.  Also, we will strengthen this method, obliging it to return <b>the</b> <code>Deferred</code> object <b>itself</b> .  This will allow the use of subscription chains (very specific to JavaScript). <br><br>  The <code>resolve</code> method changes accordingly: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, result</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  The first parameter is the state to which the <code>Deferred</code> (error, success) object should go, and the second is the result.  The rule of states still extends to such a modified object: after transition to the state with the result, the object cannot change its state to another.  This means that if an object has passed, for example, to the state of success, then all the handlers registered for the error will never work, and vice versa. <br><br>  So, let our <code>getData</code> function may end up with some error (no data, incorrect input data, failure, etc.). <br>  The code will look like this: <br><br><pre> <code class="javascript hljs">getData(id) .on(<span class="hljs-string"><span class="hljs-string">'success'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do some actions with item }) .on('error', function (err_code) { // deal with error });</span></span></code> </pre><br>  Consider a more realistic example, namely, take the typical <a href="http://nodejs.org/api/fs.html">fs.readFile</a> method from the Node.js standard library.  This method is used to read the file.  At the beginning of the article it was mentioned that almost any function can be written either in synchronous or in asynchronous style.  In the standard library Node.js file API is defined in <b>both</b> styles, each function has its own synchronous equivalent. <br><br>  For example, we use the asynchronous version of readFile and adapt it to use Deferred. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFileDeferred</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Deferred; fs.readFile(filename, options, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { result.resolve(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, err); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.resolve(<span class="hljs-string"><span class="hljs-string">'success'</span></span>, data); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Such a function is somewhat easier to use, because it allows you to register functions for success and for error separately. <br><br>  The described functionality is quite enough for the overwhelming majority of cases, but deferred has more potential, as will be discussed below. <br><br><h2>  Advanced features of Deferred objects </h2><br>  1. Unlimited number of result options.  In the example, a <code>Deferred</code> object was used with two possible results: success and error.  Nothing prevents the use of any other (custom) options.  Fortunately, we used the string value as a state, this allows us to define any set of results without changing any enumerated type. <br>  2. Ability to subscribe to <b>all</b> variants of the result.  This can be used for all sorts of generalized handlers (this has the most meaning, along with paragraph 1.). <br>  3. Creating a sub-object promise.  From the interface of the <code>Deferred</code> object, it is clear that the client code has access to the <code>resolve</code> method, although, in fact, it only needs the ability to subscribe.  The essence of this improvement is the introduction of the <code>promise</code> method, which returns a ‚Äúsubset‚Äù of the <code>Deferred</code> object, from which only a subscription is available, but not a result setting. <br>  4. Passing state from one deferred to another, optionally, subjecting the result to a transform.  This is very useful for multi-level calls. <br>  5. Creating deferred, which depends on the result of a set of other deferred.  The essence of this improvement is to subscribe to the result of a group of asynchronous operations. <br>  Suppose we need to read two files and do something interesting with both.  We use our <code>readFileDeferred</code> function for this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r1 = readFileDeferred(<span class="hljs-string"><span class="hljs-string">'./session.data'</span></span>), r2 = readFileDeferred(<span class="hljs-string"><span class="hljs-string">'./data/user.data'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r3 = Deferred.all(r1, r2); r3.on(<span class="hljs-string"><span class="hljs-string">'success'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">session, user</span></span></span><span class="hljs-function">) </span></span>{ session = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(session); user = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(user); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'All data recieved'</span></span>, session, user); }).on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err_code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'Error occured'</span></span>, err_code); });</code> </pre><br>  <code>Deferred.all</code> creates a new <code>Deferred</code> object that will go to the success state if <b>all</b> the arguments passed go to this state.  In doing so, he will also get the results of all deferred as arguments.  If <b>at least one</b> argument goes to the error state, then the result of <code>Deferred.all</code> will also go to this state, and get the result of the argument that has passed to the error state as the result. <br><br><h2>  Features deferred in javascript </h2><br>  It is worth noting that in JavaScript there is no multithreading.  If a callback has been set by <code>setInterval</code> / <code>setTimeout</code> or by events, it cannot interrupt the execution of the current code, or run in parallel with it.  This means that even if the result of the asynchronous function comes instantly, it will still be obtained only after the completion of the current code. <br><br>  In JavaScript, functions can be called with any number of parameters, as well as with any context.  This allows you to send as many parameters to callbacks as needed.  For example, if an asynchronous function returns a pair of values <code>(X, Y)</code> , then they can be passed as an object with two fields, or a list with two values ‚Äã‚Äã(an improvised analogue of a tuple), or you can use the first two arguments of the callback for this purpose. <br><br>  Calling a callback in this case can take the following form: <br><pre> <code class="javascript hljs">callback.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, X, Y);</code> </pre><br>  JavaScript uses links, and memory release is controlled by the garbage collector.  The deferred object is needed both inside the asynchronous function (to signal the arrival of the result), and outside (to get the result), in languages ‚Äã‚Äãwith more strict models of working with memory, care should be taken to properly handle the lifetime of such an object. <br><br><h2>  Existing deferred </h2><br>  1. In jQuery, there is a <code>$.Deferred</code> object ( <a href="http://api.jquery.com/category/deferred-object/">documentation</a> ).  Supports subscription to success, error, also supports progress-notifications: intermediate events generated before the arrival of the result;  you can transfer the state to another Deferred ( <code>then</code> method), you can register Deferred according to the result of the Deferred list ( <code>$.when</code> ), you can create a <code>promise</code> . <br>  All library ajax methods return a promise of such an object. <br>  2. The <a href="https://github.com/kriskowal/q">q</a> library implements deferred objects, it is possible to make chains of asynchronous functions, you can register deferred by the result of the deferred list. <br>  3. The <a href="https://github.com/caolan/async">async.js</a> library allows <a href="https://github.com/caolan/async">you</a> to apply filter / map / reduce on asynchronous calls, create chains and groups of asynchronous calls. <br>  4. The <a href="https://github.com/cujojs/when">when.js</a> library also allows the use of deferred. <br>  5. The Dojo Toolkit contains a Deferred object ( <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">documentation</a> ). <br>  6. In the fraternal Python language, in the event-driven framework <a href="http://twistedmatrix.com/trac/">Twisted</a> there is a Deferred object ( <a href="http://twistedmatrix.com/documents/12.3.0/api/twisted.internet.defer.Deferred.html">documentation</a> ).  This implementation is very old and can claim the right to be the founder of the idea of ‚Äã‚Äãpending results. <br>  Supports subscription to success, error, and both results.  You can pause an object. <br>  7. Overcome with interest in Deferred, I wrote my own version of this object ( <a href="">documentation</a> , <a href="">source code</a> , <a href="">tests</a> ).  A number of features described in this article are supported. <br><br>  That's all, thank you for your attention. </div><p>Source: <a href="https://habr.com/ru/post/175947/">https://habr.com/ru/post/175947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175935/index.html">Features when intercepting method calls using __call () and __callStatic () in PHP</a></li>
<li><a href="../175937/index.html">Work with Avaya Aura Communication Manager using the OSSI protocol</a></li>
<li><a href="../175939/index.html">A new security hole in MegaFon allows hacking subscriber accounts</a></li>
<li><a href="../175941/index.html">Brainwave Authentication</a></li>
<li><a href="../175943/index.html">Koans gita</a></li>
<li><a href="../175949/index.html">SCS in the server or the tale of how I first laid a lot of cable</a></li>
<li><a href="../175951/index.html">How to disable the service in "Megaphone": a guide to the "Service Guide"</a></li>
<li><a href="../175953/index.html">Tin nanocrystals increase battery power</a></li>
<li><a href="../175955/index.html">iconBIT NetTAB ULTRA NT-0704M: Good configuration for little money in an unusual version</a></li>
<li><a href="../175959/index.html">Fleeting malware</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>