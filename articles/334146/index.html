<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple family budget tracker with AWS SES, Lambda and DynamoDB (and Route53)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to control the family budget? 





 I have always had difficulty accurately following the budget, especially now that all purchases are made on a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple family budget tracker with AWS SES, Lambda and DynamoDB (and Route53)</h1><div class="post__text post__text-html js-mediator-article"><h1 id="kak-kontrolirovat-semeynyy-byudzhet">  How to control the family budget? </h1><br><p><img src="https://habrastorage.org/web/bf2/aae/864/bf2aae864802463c950195fb97214785.jpg" alt="image"></p><br><p>  I have always had difficulty accurately following the budget, especially now that all purchases are made on a credit card.  The reason is simple - there is no bundle of money in front of your eyes, which is gradually shrinking, and at some point you realize that there is nothing more to spend.  If the majority of purchases are paid by credit card, then the only way to find out how much money is left or how much is spent is to go to the Internet bank or mobile bank, or use financial aggregators, for example, Mint, which also need to go and check the balance.  This is possible, but it requires discipline, and when not only you pay with the same card, it is difficult to establish it. </p><br><p>  I thought that I would be satisfied with the option if I would receive a notification every day about how much money I still had this month.  That is, I would set a budget for the month, and something would count my expenses and send a report on the state of the budget every day. </p><a name="habracut"></a><br><p>  The most obvious option is to use the bank's API or go to its Internet bank programmatically using some kind of headless browser.  Unfortunately, access to the API of my bank is paid, and going to the Internet bank is problematic due to two-factor authentication.  However, there is another option.  Almost all banks today send alerts to each transaction, informing when, how much and where the transaction took place.  It is the information that is needed to maintain the budget.  It remains to figure out how to handle it. </p><br><p>  My bank can send alerts to your mobile phone and email.  The option with a mobile phone was not considered due to the complexity of processing SMS messages.  The e-mail version looks very tempting, software processing of e-mails could have been done decades ago.  But now in my home only the laptop is not always turned on, which means we will automate the budget somewhere in the cloud, for example, AWS. </p><br><h1 id="chto-nam-ponadobitsya-v-aws">  What do we need in AWS? </h1><br><p>  There are many services in AWS, but we need only three: to receive and send emails ‚Äî SES, to process them ‚Äî Lambda, and to store the DynamoDB result.  Plus, a couple of auxiliary for the bundle - SNS, Kinesis, CloudWatch.  This is not the only way to handle messages: instead of Lambda, you can use EC2, instead of DynamoDB, you can store data in RDS (MySQL, PostgreSQL, Oracle, ...), and you can even write a simple script on your small server on Perl and BerkleyDB. </p><br><p>  What does the whole treatment look like in general?  A transaction letter arrives, we record the date, amount and place of payment in the database, and once a day we send a letter with the balance for the given month.  The whole architecture is a bit more complicated and looks like this: </p><br><p><img src="https://habrastorage.org/web/db5/e1c/7bf/db5e1c7bfcb945f1926e58fc73b31677.png"></p><br><ol><li>  A letter arrives at SES. </li><li>  SES sends an email to the SNS topic. </li><li>  The ProcessCharge Lambda function is triggered by the arrival of a letter via SNS, parses the letter and writes transaction data to the DynamoDB table Transactions. </li><li>  The Lambda function UpdateSummary works as a trigger after writing to the Transactions table and updates the current state of the budget in the Summary table. </li></ol><br><p>  Consider these steps in more detail. </p><br><h1 id="poluchenie-pisma">  Receiving a letter </h1><br><p>  Simple Email Service, also known as SES, is a service for receiving and sending emails.  When you receive a letter, you can specify which action should be performed: save the letter in S3, call the Lambda function, send the letter to the SNS and others.  To receive letters, you need to bind your domain, namely, specify the SES server in the MX domain record.  I didn‚Äôt have my own domain at that time, and I decided that it was a good reason to register it using another AWS service Route 53. I also acted in the same place in Route 53. </p><br><p>  When a domain is bound to SES, verification is required.  To do this, SES asks to add some records to the DNS zone (MX and TXT), and then checks their presence.  If the domain is hosted in Route 53, then all this is done automatically.  When the domain is verified, you can proceed to setting up rules for receiving mail.  My only rule is very simple: all emails coming to the ccalert @ address of our domain should be sent to the SNS topic ccalerts: </p><br><pre><code class="hljs ruby">aws&gt; ses describe-receipt-rule --rule-set-name <span class="hljs-string"><span class="hljs-string">"ccalerts"</span></span> --rule-name <span class="hljs-string"><span class="hljs-string">"ccalert"</span></span> { <span class="hljs-string"><span class="hljs-string">"Rule"</span></span>: { <span class="hljs-string"><span class="hljs-string">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ccalert"</span></span>, <span class="hljs-string"><span class="hljs-string">"Recipients"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"ccalert@=censored=‚Äù ], "</span></span>Enabled<span class="hljs-string"><span class="hljs-string">": true, "</span></span>ScanEnabled<span class="hljs-string"><span class="hljs-string">": true, "</span></span>Actions<span class="hljs-string"><span class="hljs-string">": [ { "</span></span>SNSAction<span class="hljs-string"><span class="hljs-string">": { "</span></span>TopicArn<span class="hljs-string"><span class="hljs-string">": "</span></span><span class="hljs-symbol"><span class="hljs-symbol">arn:</span></span><span class="hljs-symbol"><span class="hljs-symbol">aws:</span></span><span class="hljs-symbol"><span class="hljs-symbol">sns:</span></span>us-west-<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span>=censored=<span class="hljs-symbol"><span class="hljs-symbol">:ccalerts</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">", "</span></span></span><span class="hljs-symbol">Encoding</span><span class="hljs-string"><span class="hljs-symbol"><span class="hljs-string">": "</span></span></span><span class="hljs-symbol">UTF-</span></span><span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-string"><span class="hljs-string">" } } ], "</span></span>TlsPolicy<span class="hljs-string"><span class="hljs-string">": "</span></span>Optional<span class="hljs-string"><span class="hljs-string">" } }</span></span></code> </pre> <br><h1 id="obrabotka-pisma">  Letter processing </h1><br><p>  When a new letter is published to the SNS topic, the Lambda function ProcessCharge is called.  She needs to do two actions - parse the letter and save the data to the database. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> boto3 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event, context)</span></span></span><span class="hljs-function">:</span></span> message = json.loads(event[<span class="hljs-string"><span class="hljs-string">'Records'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'Sns'</span></span>][<span class="hljs-string"><span class="hljs-string">'Message'</span></span>]) print(<span class="hljs-string"><span class="hljs-string">"Processing email {}"</span></span>.format(message[<span class="hljs-string"><span class="hljs-string">'mail'</span></span>])) content = message[<span class="hljs-string"><span class="hljs-string">'content'</span></span>] trn = parse_content(content) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> trn <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Transaction: %s"</span></span> % trn) process_transaction(trn)</code> </pre> <br><p>  The parse_content () method is responsible for parsing: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_content</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content)</span></span></span><span class="hljs-function">:</span></span> content = content.replace(<span class="hljs-string"><span class="hljs-string">"=\r\n"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) match = re.search(<span class="hljs-string"><span class="hljs-string">r'A charge of \(\$USD\) (\d+\.\d+) at (.+?) has been authorized on (\d+/\d+/\d+ \d+:\d+:\d+ \S{2} \S+?)\.'</span></span>, content, re.M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match: print(<span class="hljs-string"><span class="hljs-string">"Matched %s"</span></span> % match.group(<span class="hljs-number"><span class="hljs-number">0</span></span>)) date = match.group(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment"># replace time zone with hour offset because Python can't parse it date = date.replace("EDT", "-0400") date = date.replace("EST", "-0500") dt = datetime.strptime(date, "%m/%d/%Y %I:%M:%S %p %z") return {'billed': match.group(1), 'merchant': match.group(2), 'datetime': dt.isoformat()} else: print("Didn't match") return None</span></span></code> </pre> <br><p>  In it, we remove unnecessary characters and use a regular expression to check whether the letter contains information about the transaction, and if so, break it into parts.  The text sought is as follows: </p><br><blockquote>  A charge of ($ USD) 100.00 at Amazon.com has been authorized on 07/19/2017 1:55:52 PM EDT. </blockquote><p>  Unfortunately, the standard Python library knows few time zones, and EDT (Eastern Daylight Time) is not among them.  Therefore, we replace the EDT with the numerical designation -0400, and do the same for the main time zone, EST.  After that, we can parse the date and time of the transaction, and convert it to the standard ISO 8601 format supported by DynamoDB. </p><br><p>  The method returns a hash table with the transaction amount, store name and date with time.  This data is passed to the process_transaction method: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trn)</span></span></span><span class="hljs-function">:</span></span> ddb = boto3.client(<span class="hljs-string"><span class="hljs-string">'dynamodb'</span></span>) trn_id = uuid.uuid4().hex ddb.put_item( TableName=<span class="hljs-string"><span class="hljs-string">'Transactions'</span></span>, Item={ <span class="hljs-string"><span class="hljs-string">'id'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: trn_id}, <span class="hljs-string"><span class="hljs-string">'datetime'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: trn[<span class="hljs-string"><span class="hljs-string">'datetime'</span></span>]}, <span class="hljs-string"><span class="hljs-string">'merchant'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: trn[<span class="hljs-string"><span class="hljs-string">'merchant'</span></span>]}, <span class="hljs-string"><span class="hljs-string">'billed'</span></span>: {<span class="hljs-string"><span class="hljs-string">'N'</span></span>: trn[<span class="hljs-string"><span class="hljs-string">'billed'</span></span>]} })</code> </pre> <br><p>  In it, we store data in the Transactions table, generating a unique transaction identifier. </p><br><p><img src="https://habrastorage.org/web/5b5/91a/920/5b591a9202bb4e279b11156c11c091b8.png"></p><br><h1 id="obnovlenie-byudzheta">  Budget update </h1><br><p>  I would like to dwell here in more detail, namely on the moment how the budget is monitored.  We define for ourselves several values: </p><br><ul><li>  budget - the size of the budget for the month; </li><li>  total - the amount of spending per month; </li><li>  available - balance, (buget - total); </li></ul><br><p>  At any time we want to know all these values.  This can be done in two ways: </p><br><ol><li>  Every time you need to know the state of the budget, transactions are summarized to get total, then available = (budget - total). </li><li>  Each time a new transaction is recorded, the total is updated.  When you need to know the state of the budget, is available = (budget - total). </li></ol><br><p>  Both approaches have pros and cons, and the choice is highly dependent on the requirements and limitations of the system.  The first approach is good because it does not denormalize the data, keeping the amount of transactions separately.  On the other hand, with him the amount must be calculated with each request.  For my volumes this will not be a problem, but in my case I have a limitation caused by DynamoDB.  To calculate the sum of N transactions, you need to read N records, which means to spend N read capacity units.  Obviously, this is not a very scalable solution, which will cause difficulties (or high cost) even with several dozen transactions. </p><br><p>  When using the second approach, the total is updated after each transaction and is always relevant, which avoids the summation of all transactions.  I found this approach more rational in my case.  Implement it, again, in different ways: </p><br><ol><li>  Update total after each transaction is recorded in the same ProcessCharge Lambda function. </li><li>  Update total in a trigger after adding a new item to the Transactions table. </li></ol><br><p>  Updating in a trigger is more practical, including in terms of multithreading, so I created the Lambda function UpdateSummary: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> boto3 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event, context)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> record <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event[<span class="hljs-string"><span class="hljs-string">'Records'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> record[<span class="hljs-string"><span class="hljs-string">'eventName'</span></span>] != <span class="hljs-string"><span class="hljs-string">'INSERT'</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Unsupported event {}"</span></span>.format(record)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trn = record[<span class="hljs-string"><span class="hljs-string">'dynamodb'</span></span>][<span class="hljs-string"><span class="hljs-string">'NewImage'</span></span>] print(trn) process_transaction(trn)</code> </pre> <br><p>  We are only interested in the event of adding elements to the table, all others are ignored. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trn)</span></span></span><span class="hljs-function">:</span></span> period = get_period(trn) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> period <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> billed = trn[<span class="hljs-string"><span class="hljs-string">'billed'</span></span>][<span class="hljs-string"><span class="hljs-string">'N'</span></span>] <span class="hljs-comment"><span class="hljs-comment"># update total for current period update_total(period, billed) print("Transaction processed")</span></span></code> </pre> <br><p>  In process_transaction (), we calculate the period, in the form year-month, to which the transaction relates, and call the update method total. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_period</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trn)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-comment"><span class="hljs-comment"># python cannot parse -04:00, it needs -0400 dt = trn['datetime']['S'].replace("-04:00", "-0400") dt = dt.replace("-05:00", "-0500") dt = dt.replace("-07:00", "-0700") dt = datetime.strptime(dt, "%Y-%m-%dT%H:%M:%S%z") return dt.strftime("%Y-%m") except ValueError as err: print("Cannot parse date {}: {}".format(trn['datetime']['S'], err)) return None</span></span></code> </pre> <br><p>  This code is very far from perfect, and the interesting feature of Python played the role that it cannot parse the date / time with the time zone in the -HH: MM format, which conforms to the ISO 8601 standard, and which Python itself generated (code above , in the parse_content ()) method.  Therefore, I simply replace the time zones I need with the -HHMM format that it understands.  It was possible to use a third-party library and make it more beautiful, I will leave it for the future.  Perhaps my bad knowledge of Python still affects me - this project is my first development experience on it. </p><br><p>  Total update: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_total</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(period, billed)</span></span></span><span class="hljs-function">:</span></span> ddb = boto3.client(<span class="hljs-string"><span class="hljs-string">'dynamodb'</span></span>) response = load_summary(ddb, period) print(<span class="hljs-string"><span class="hljs-string">"Summary: {}"</span></span>.format(response)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'Item'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: create_summary(ddb, period, billed) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: total = response[<span class="hljs-string"><span class="hljs-string">'Item'</span></span>][<span class="hljs-string"><span class="hljs-string">'total'</span></span>][<span class="hljs-string"><span class="hljs-string">'N'</span></span>] update_summary(ddb, period, total, billed)</code> </pre> <br><p>  In this method, we load the summary for the current period using the load_summary () method, the total in which we need to update.  If the bulletin does not already exist, we create it in the create_summary () method, if it exists, update to update_summary (). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_summary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ddb, period)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Loading summary for period {}"</span></span>.format(period)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ddb.get_item( TableName = <span class="hljs-string"><span class="hljs-string">'Summary'</span></span>, Key = { <span class="hljs-string"><span class="hljs-string">'period'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: period} }, ConsistentRead = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> )</code> </pre> <br><p>  Since the update of the report can be made from several streams, we use consistent read, which is more expensive, but guarantees that we will get the last recorded value. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_summary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ddb, period, total)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Creating summary for period {} with total {}"</span></span>.format(period, total)) ddb.put_item( TableName = <span class="hljs-string"><span class="hljs-string">'Summary'</span></span>, Item = { <span class="hljs-string"><span class="hljs-string">'period'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: period}, <span class="hljs-string"><span class="hljs-string">'total'</span></span>: {<span class="hljs-string"><span class="hljs-string">'N'</span></span>: total}, <span class="hljs-string"><span class="hljs-string">'budget'</span></span>: {<span class="hljs-string"><span class="hljs-string">'N'</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>} }, ConditionExpression = <span class="hljs-string"><span class="hljs-string">'attribute_not_exists(period)'</span></span> )</code> </pre> <br><p>  When creating a new bulletin, for the same reason that it is possible to record from multiple streams, conditional notation is used, <em>ConditionExpression = 'attribute_not_exists (period)'</em> , which will save the new summary only if it does not exist.  Thus, if someone managed to create a summary in the interval, when we tried to load it into load_summary () and it was not there, and when we tried to create it in create_summary (), our call to put_item () will end with the exception and the entire Lambda function will be restarted. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_summary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ddb, period, total, billed)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Updating summary for period {} with total {} for billed {}"</span></span>.format(period, total, billed)) ddb.update_item( TableName = <span class="hljs-string"><span class="hljs-string">'Summary'</span></span>, Key = { <span class="hljs-string"><span class="hljs-string">'period'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: period} }, UpdateExpression = <span class="hljs-string"><span class="hljs-string">'SET #total = #total + :billed'</span></span>, ConditionExpression = <span class="hljs-string"><span class="hljs-string">'#total = :total'</span></span>, ExpressionAttributeValues = { <span class="hljs-string"><span class="hljs-string">':billed'</span></span>: {<span class="hljs-string"><span class="hljs-string">'N'</span></span>: billed}, <span class="hljs-string"><span class="hljs-string">':total'</span></span>: {<span class="hljs-string"><span class="hljs-string">'N'</span></span>: total} }, <span class="hljs-comment"><span class="hljs-comment"># total is a reserved word so we create an alias #total to use it in expression ExpressionAttributeNames = { '#total': 'total' } )</span></span></code> </pre> <br><p>  Updating the total value in a summary is done inside DynamoDB: </p><br><blockquote>  UpdateExpression = 'SET #total = #total +: billed' </blockquote><p>  Most likely, this is enough for a safe update, but I decided to act conservatively and added the condition that the record should occur only if the report was not updated in another stream, and it still contains the value that we have: </p><br><blockquote>  ConditionExpression = '#total =: total', </blockquote><p>  Since total is a keyword for DynamoDB, to use it in DynamoDB expressions, you need to create a synonym: </p><br><blockquote>  ExpressionAttributeNames = { <br>  '#total': 'total' <br>  } </blockquote><p>  This completes the transaction processing and budget update process: </p><br><table><thead><tr><th>  period </th><th>  budget </th><th>  total </th></tr></thead><tbody><tr><td>  2017-07 </td><td>  1000 </td><td>  500 </td></tr></tbody></table><br><h1 id="otpravka-uvedomleniya-o-sostoyanii-byudzheta">  Sending budget notifications </h1><br><p>  The last part of the system - notification of the state of the budget.  As I wrote at the very beginning, it is enough for me to receive a notification once a day, which I implemented.  However, nothing prevents to notify after each transaction, or after some threshold values ‚Äã‚Äãof expenses / balance.  The architecture of sending an e-mail notification is quite simple and looks like this: </p><br><p><img src="https://habrastorage.org/web/f5e/3d6/834/f5e3d68344e0453a934a15c1c5f896fc.png"></p><br><ol><li>  The CloudWatch Timer timer is triggered once a day and calls the DailyNotification Lambda function. </li><li>  DailyNotification loads data from the DynamoDB Summary table and calls SES to send an email. </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> boto3 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event, context)</span></span></span><span class="hljs-function">:</span></span> ddb = boto3.client(<span class="hljs-string"><span class="hljs-string">'dynamodb'</span></span>) current_date = date.today() print(<span class="hljs-string"><span class="hljs-string">"Preparing daily notification for {}"</span></span>.format(current_date.isoformat())) period = current_date.strftime(<span class="hljs-string"><span class="hljs-string">"%Y-%m"</span></span>) response = load_summary(ddb, period) print(<span class="hljs-string"><span class="hljs-string">"Summary: {}"</span></span>.format(response)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'Item'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: print(<span class="hljs-string"><span class="hljs-string">"No summary available for period {}"</span></span>.format(period)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summary = response[<span class="hljs-string"><span class="hljs-string">'Item'</span></span>] total = summary[<span class="hljs-string"><span class="hljs-string">'total'</span></span>][<span class="hljs-string"><span class="hljs-string">'N'</span></span>] budget = summary[<span class="hljs-string"><span class="hljs-string">'budget'</span></span>][<span class="hljs-string"><span class="hljs-string">'N'</span></span>] send_email(total, budget) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_summary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ddb, period)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Loading summary for period {}"</span></span>.format(period)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ddb.get_item( TableName = <span class="hljs-string"><span class="hljs-string">'Summary'</span></span>, Key = { <span class="hljs-string"><span class="hljs-string">'period'</span></span>: {<span class="hljs-string"><span class="hljs-string">'S'</span></span>: period} }, ConsistentRead = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> )</code> </pre> <br><p>  First we try to load a summary for the current period, and if it‚Äôs not, then we‚Äôll finish.  If there is - we prepare and send the letter: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_email</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(total, budget)</span></span></span><span class="hljs-function">:</span></span> sender = <span class="hljs-string"><span class="hljs-string">"Our Budget &lt;ccalert@==censored==&gt;"</span></span> recipients = [‚Äú==censored==‚Äú] charset = <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span> available = float(budget) - float(total) today = date.today().strftime(<span class="hljs-string"><span class="hljs-string">"%Y-%m-%d"</span></span>) message = <span class="hljs-string"><span class="hljs-string">''' As of {0}, available funds are ${1:.2f}. This month budget is ${2:.2f}, spendings so far totals ${3:.2f}. More details coming soon!'''</span></span> subject = <span class="hljs-string"><span class="hljs-string">"How are we doing?"</span></span> textbody = message.format(today, float(available), float(budget), float(total)) print(<span class="hljs-string"><span class="hljs-string">"Sending email: {}"</span></span>.format(textbody)) client = boto3.client(<span class="hljs-string"><span class="hljs-string">'ses'</span></span>, region_name = <span class="hljs-string"><span class="hljs-string">'us-west-2'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response = client.send_email( Destination = { <span class="hljs-string"><span class="hljs-string">'ToAddresses'</span></span>: recipients }, Message = { <span class="hljs-string"><span class="hljs-string">'Body'</span></span>: { <span class="hljs-string"><span class="hljs-string">'Text'</span></span>: { <span class="hljs-string"><span class="hljs-string">'Charset'</span></span>: charset, <span class="hljs-string"><span class="hljs-string">'Data'</span></span>: textbody, }, }, <span class="hljs-string"><span class="hljs-string">'Subject'</span></span>: { <span class="hljs-string"><span class="hljs-string">'Charset'</span></span>: charset, <span class="hljs-string"><span class="hljs-string">'Data'</span></span>: subject, }, }, Source = sender, ) <span class="hljs-comment"><span class="hljs-comment"># Display an error if something goes wrong. except Exception as e: print("Couldn't send email: {}".format(e)) else: print("Email sent!")</span></span></code> </pre> <br><h1 id="itog">  Total </h1><br><p>  That's all.  Now, after each transaction, the incoming letter is processed and the budget is updated, and a letter is sent once a day with a budget status notification.  I still have plans to add functionality, for example, the classification of expenses by category, and the inclusion of a list of recent transactions in the notification, if you get something worthwhile - I will share in another article.  If there are any questions, comments or edits - wait in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334146/">https://habr.com/ru/post/334146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334136/index.html">Random forest vs neural network: who will better cope with the task of recognizing gender in speech (part 1)</a></li>
<li><a href="../334138/index.html">Work with servlets for dummies. GET / POST</a></li>
<li><a href="../334140/index.html">Kubernetes success stories in production. Part 1: 4200 pods and TessMaster on eBay</a></li>
<li><a href="../334142/index.html">Quick removal of spaces from strings on ARM processors - alternative analysis</a></li>
<li><a href="../334144/index.html">Virtual machine backup and freeze / thaw scripts InterSystems Cach√©</a></li>
<li><a href="../334148/index.html">Enjoy! Isolate authentication server in open source</a></li>
<li><a href="../334150/index.html">Welcome to Tarantool Meetup August 10th</a></li>
<li><a href="../334152/index.html">Innovations of the main Russian Robotic Olympiad in the official video</a></li>
<li><a href="../334154/index.html">Experience of using FPGA boards DE10-Standard and DMA PL330</a></li>
<li><a href="../334156/index.html">Cpp ‚ù§Ô∏è Mobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>