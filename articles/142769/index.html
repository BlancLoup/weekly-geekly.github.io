<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Menu for Yi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I decided to sit down and deal with Yi , a text editor like Vim and Emacs, but written in Haskell. Included is even a Vim and Emacs simulati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Menu for Yi</h1><div class="post__text post__text-html js-mediator-article">  Recently, I decided to sit down and deal with <a href="http://www.haskell.org/haskellwiki/Yi">Yi</a> , a text editor like Vim and Emacs, but written in Haskell.  Included is even a Vim and Emacs simulation. <br>  Due to the lack of experience with Vim or Emacs, only Cua-simulation came to me.  Hotkeev there is little, but they are familiar to me.  So I decided to start with it and write the setting for myself. <br>  In ordinary graphic editors, it seems to me a convenient way to use the menu.  You press alt, a menu opens, where each element has a letter underlined, clicking which we will select this element. <br>  Thus, it is not necessary to memorize all the commands at once, but you can start using, peeping in the menu, gradually bringing it to automatism. <br>  I decided to screw something like this in Yi. <br><br><img src="https://habrastorage.org/storage2/fb6/abf/599/fb6abf5997cebc181277fafff7300f4b.png" alt="image"><br><a name="habracut"></a><br><br><h4>  Customize simple hotkeys </h4><br>  First you need to figure out how Yi works?  The easiest way to understand this, if you look at the already prepared bindings, such as <a href="http://hackage.haskell.org/packages/archive/yi/0.6.5.0/doc/html/src/Yi-Keymap-Cua.html">Cua</a> .  It is trimmed, and much more primitive than Vim and Emacs binding analogs, but for our purposes (to write our own) is the very thing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, let's pay attention to how hotkeys are set at all.  This can be seen from the main function. <br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">keymap</span></span> :: <span class="hljs-type"><span class="hljs-type">KeymapSet</span></span> keymap = portableKeymap ctrl <span class="hljs-comment"><span class="hljs-comment">-- | Introduce a keymap that is compatible with both windows and osx, -- by parameterising the event modifier required for commands portableKeymap :: (Event -&gt; Event) -&gt; KeymapSet portableKeymap cmd = modelessKeymapSet $ selfInsertKeymap &lt;|&gt; move &lt;|&gt; select &lt;|&gt; rect &lt;|&gt; other cmd</span></span></code> </pre> <br>  Different options for binding are combined with the help of the operator &lt;|&gt;.  Let's look further at the other cmd: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">other</span></span> cmd = choice [ spec <span class="hljs-type"><span class="hljs-type">KBS</span></span> ?&gt;&gt;! deleteSel bdeleteB, spec <span class="hljs-type"><span class="hljs-type">KDel</span></span> ?&gt;&gt;! deleteSel (deleteN <span class="hljs-number"><span class="hljs-number">1</span></span>), spec <span class="hljs-type"><span class="hljs-type">KEnter</span></span> ?&gt;&gt;! replaceSel <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, cmd (char 'q') ?&gt;&gt;! askQuitEditor, cmd (char 'f') ?&gt;&gt; isearchKeymap <span class="hljs-type"><span class="hljs-type">Forward</span></span>, cmd (char 'x') ?&gt;&gt;! cut, cmd (char 'c') ?&gt;&gt;! copy, cmd (char 'v') ?&gt;&gt;! paste, cmd (spec <span class="hljs-type"><span class="hljs-type">KIns</span></span>) ?&gt;&gt;! copy, shift (spec <span class="hljs-type"><span class="hljs-type">KIns</span></span>) ?&gt;&gt;! paste, cmd (char 'z') ?&gt;&gt;! undoB, cmd (char 'y') ?&gt;&gt;! redoB, cmd (char 's') ?&gt;&gt;! fwriteE, cmd (char 'o') ?&gt;&gt;! findFile, cmd (char '/') ?&gt;&gt;! withModeB modeToggleCommentSelection, cmd (char ']') ?&gt;&gt;! autoIndentB <span class="hljs-type"><span class="hljs-type">IncreaseOnly</span></span>, cmd (char '[') ?&gt;&gt;! autoIndentB <span class="hljs-type"><span class="hljs-type">DecreaseOnly</span></span> ]</code> </pre><br>  As you can see, on the left is the key combination, on the right is the action.  Those.  when you click cmd (char 'c') (by default cmd - ctrl) - we get copy, the code of which is also plain. <br><br>  I copied these definitions to me and decided to start editing them in order to build some sort of menu. <br><h4>  How to make a menu? </h4><br>  To decide how to implement the menu, you should go to the <a href="http://hackage.haskell.org/package/yi">documentation modules</a> .  Everything is structured quite comfortably, and the <a href="http://hackage.haskell.org/packages/archive/yi/0.6.5.0/doc/html/Yi-MiniBuffer.html">Yi.MiniBuffer</a> module catches the <a href="http://hackage.haskell.org/packages/archive/yi/0.6.5.0/doc/html/Yi-MiniBuffer.html">eye</a> .  Apparently, this is what we need.  There is a function <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">spawnMinibufferE</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">KeymapEndo</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">EditorM</span></span> <span class="hljs-type"><span class="hljs-type">BufferRef</span></span></code> </pre><br>  which accepts output text and a function that puts its bindings on the keys.  Those.  what we need.  In the line we will display the menu items, in the binders we will catch the selection of menu items by keys. <br><br>  To begin, create a type convenient for describing the menu.  The menu consists of a list of items, each of which either opens a submenu or is an action.  So we write: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Menu type Menu = [MenuItem] -- | Menu utem data MenuItem = MenuAction String (MenuContext -&gt; Char -&gt; Keymap) | SubMenu String Menu -- | Menu action context data MenuContext = MenuContext { parentBuffer :: BufferRef }</span></span></code> </pre><br>  The SubMenu variant contains the title and submenus, the MenuAction option is the title and the function that will create the necessary bindings. <br>  MenuContext is some context that is passed to actions (as long as there is only the source buffer from which the menu was called, this was needed to implement the Save button), Char is the button that the menu needs to be called upon pressing. <br><br>  Since the type is recursive, for it you can simply define a convolution, so that later, using it, launch the menu: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Fold menu item foldItem :: (String -&gt; (MenuContext -&gt; Char -&gt; Keymap) -&gt; a) -&gt; (String -&gt; [a] -&gt; a) -&gt; MenuItem -&gt; a foldItem mA sM (MenuAction title act) = mA title act foldItem mA sM (SubMenu title sm) = sM title (map (foldItem mA sM) sm) -- | Fold menu foldMenu :: (String -&gt; (MenuContext -&gt; Char -&gt; Keymap) -&gt; a) -&gt; (String -&gt; [a] -&gt; a) -&gt; Menu -&gt; [a] foldMenu mA sM = map (foldItem mA sM)</span></span></code> </pre><br><br>  We also need functions that will more conveniently create menu items for us.  SubMenu is easy to create, SubMenu "File" ..., but MenuAction is harder to use.  Therefore, we define several functions that will take action (the same as to the right of? &gt;&gt;! In binding).  I will give the code of two of them: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Action on item action_ :: (YiAction ax, Show x) =&gt; String -&gt; a -&gt; MenuItem action_ title act = action title (const act) -- | Action on item with context action :: (YiAction ax, Show x) =&gt; String -&gt; (MenuContext -&gt; a) -&gt; MenuItem action title act = MenuAction title act' where act' ctx c = char c ?&gt;&gt;! (do withEditor closeBufferAndWindowE runAction $ makeAction (act ctx))</span></span></code> </pre><br>  Here we create a MenuItem, which when clicked on the corresponding button (char c) will close the menu and invoke the action that we need. <br><br>  And finally, let's write the menu display function. <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Start menu action startMenu :: Menu -&gt; EditorM () startMenu m = do --  ,   ctx &lt;- fmap MenuContext (gets currentBuffer) startMenu' ctx m where --  ,      (, ) startMenu' ctx = showMenu . foldMenu onItem onSub where showMenu :: [(String, Maybe Keymap)] -&gt; EditorM () --   ‚Äî      ,    showMenu is = void $ spawnMinibufferE menuItems (const (subMap is)) where menuItems = (intercalate " " (map fst is)) --    ‚Äî --   +    ,   onItem title act = (title, fmap (act ctx) (menuEvent title)) where --    ‚Äî --  +  ,        onSub title is = (title, fmap subMenu (menuEvent title)) where --  'c'        subMenu c = char c ?&gt;&gt;! closeBufferAndWindowE &gt;&gt; showMenu is --        Esc,        subMap is = choice $ closeMenu : mapMaybe snd is where closeMenu = spec KEsc ?&gt;&gt;! closeBufferAndWindowE</span></span></code> </pre><br>  The full code can be found <a href="">here</a> . <br><br><h4>  Create a menu </h4><br>  Now it‚Äôs worth creating some menus, sticking to a button and starting to be checked. <br>  First, I wrote a large spreading menu, stuffing in there what I came across with a cursory view of various modules in Yi.  When I noticed that, for example, I often go to the submenu View - Windows, I decided to just bring this menu to a separate hotkey. <br>  Now you can split the window not only by a long combination of VWS, but also just by Ctrl-W - S. <br><br>  Here is the code for the main menu and submenus of Windows: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Main menu mainMenu :: Menu mainMenu = [ menu "File" [ action_ "Quit" askQuitEditor, action "Save" (fwriteBufferE . parentBuffer)], menu "Edit" [ action_ "Auto complete" wordComplete, action_ "Completion" completeWordB], menu "Tools" [ menu "Ghci" ghciMenu], menu "View" [ menu "Windows" windowsMenu, menu "Tabs" tabsMenu, menu "Buffers" buffersMenu, menu "Layout" [ action_ "Next" layoutManagersNextE, action_ "Previous" layoutManagersPreviousE]]] -- | Windows menu windowsMenu :: Menu windowsMenu = [ action_ "Next" nextWinE, action_ "Previous" prevWinE, action_ "Split" splitE, action_ "sWap" swapWinWithFirstE, action_ "Close" tryCloseE, action_ "cLose-all-but-this" closeOtherE]</span></span></code> </pre><br>  The entire menu can be viewed <a href="">here</a> . <br><br><h4>  Result </h4><br>  We register the main menu and submenu for various combinations. <br><img src="https://habrastorage.org/storage2/69f/747/be4/69f747be44cd4086189f1c24470646cb.png"><br>  We use! <br><img src="https://habrastorage.org/storage2/a79/a9e/f34/a79a9ef3419217a5ec343ed3ca4b0c33.png"><br><br><h4>  Results </h4><br>  After the implementation, I screwed some built-in simplest autocompet, then the GHCi interpreter.  The hlint tool is in turn (it analyzes the code and suggests where it can be replaced with the use of a standard function, where something is written and so on) and so on. <br><br>  All code is available on <a href="https://github.com/mvoidex/yi-voidex">GitHub</a> . <br><br><h6>  Update </h6><br>  Somewhat embarrassed by the presence of the three functions <code>actionB</code> , <code>actionE</code> and <code>actionY</code> .  However, they can be replaced by <code>runAction . makeAction</code> <code>runAction . makeAction</code> <br>  <i>Fixed for a single action</i> </div><p>Source: <a href="https://habr.com/ru/post/142769/">https://habr.com/ru/post/142769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142759/index.html">Runetology (144): Founder of Dnevnik.ru Gabriel Levy</a></li>
<li><a href="../142762/index.html">Adobe & HTML</a></li>
<li><a href="../142763/index.html">Planetary Resources, Google and Cameron - and we will carry platinum from asteroids!</a></li>
<li><a href="../142764/index.html">Magento 1.7.0.0 released</a></li>
<li><a href="../142765/index.html">Tab "Everything" on April 23 - view questions and answers without reloading pages</a></li>
<li><a href="../142770/index.html">Passengers of the Petersburg Metro will be able to pay for travel over the Internet</a></li>
<li><a href="../142771/index.html">Prototyping for Finishing in Adobe Fireworks</a></li>
<li><a href="../142772/index.html">When you do not need to listen to users when designing an interface</a></li>
<li><a href="../142773/index.html">When leaving, do not forget the number</a></li>
<li><a href="../142774/index.html">Build a cloud, asynchronous and scalable web application with SignalR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>