<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Secure cleaning of private data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Often, the program must store private data. For example: passwords, keys and their derivatives. Very often after using this data, it is necessary to c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Secure cleaning of private data</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a47/a38/5ee/a47a385eefc6de47ed417adef4e082ff.png" align="left"><br>  Often, the program must store private data.  For example: passwords, keys and their derivatives.  Very often after using this data, it is necessary to clear the memory of their tracks so that the attacker could not access them.  This post will discuss why you cannot use the <i>memset ()</i> function for this purpose. <br><a name="habracut"></a><br><h2>  memset () </h2><br>  Perhaps you have already read <a href="https://habrahabr.ru/company/abbyy/blog/127259/">an article</a> describing the vulnerability of programs using <a href="https://msdn.microsoft.com/en-us/library/aa246471(v%3Dvs.60).aspx"><i>memset ()</i></a> for mashing memory.  But it does not fully disclose all possible cases of misuse of <i>memset ()</i> .  Problems will arise not only with clearing buffers created on the stack, but also with buffers allocated in dynamic memory. <br><br><h2>  Stack </h2><br>  First consider the case of the above article using a variable created on the stack. <br><br>  Write the code that works with the password: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;functional&gt; #include &lt;iostream&gt; //  struct PrivateData { size_t m_hash; char m_pswd[100]; }; // -    void doSmth(PrivateData&amp; data) { std::string s(data.m_pswd); std::hash&lt;std::string&gt; hash_fn; data.m_hash = hash_fn(s); } //      int funcPswd() { PrivateData data; std::cin &gt;&gt; data.m_pswd; doSmth(data); memset(&amp;data, 0, sizeof(PrivateData)); return 1; } int main() { funcPswd(); return 0; }</span></span></span></span></code> </pre> <br>  The example is rather arbitrary, it is completely synthetic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we build a debug version and execute such code under the debugger (I used Visual Studio 2015), we will see that everything is in order.  Password and calculated hash are erased after use. <br><br>  Let's look at the assembler code under the Visual Studio debugger: <br><pre> <code class="cpp hljs">.... doSmth(data); <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072BF lea rcx,[data] <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072<span class="hljs-function"><span class="hljs-function">C3 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">30153Ch)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;data, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(PrivateData))</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072C8 mov r8d,<span class="hljs-number"><span class="hljs-number">70</span></span>h <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072CE xor edx,edx <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072D0 lea rcx,[data] <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072<span class="hljs-function"><span class="hljs-function">D4 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memset</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">301352h)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> 1</span></span>; <span class="hljs-number"><span class="hljs-number">000000013F</span></span>3072D9 mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> ....</code> </pre> <br>  We observe a call to our <i>memset ()</i> function, which will clear private data after use. <br><br>  It would seem that this can be completed, but no, let's try to collect a release version with code optimization.  Let's see in the debugger what we did: <br><pre> <code class="cpp hljs">.... <span class="hljs-number"><span class="hljs-number">000000013F</span></span>7A1035 call <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; (<span class="hljs-number"><span class="hljs-number">013F</span></span>7A18B0h) <span class="hljs-number"><span class="hljs-number">000000013F</span></span>7A103A lea rcx,[rsp+<span class="hljs-number"><span class="hljs-number">20</span></span>h] <span class="hljs-number"><span class="hljs-number">000000013F</span></span>7<span class="hljs-function"><span class="hljs-function">A103F call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">7A1170h)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> 0</span></span>; <span class="hljs-number"><span class="hljs-number">000000013F</span></span>7A1044 xor eax,eax ....</code> </pre> <br>  As you can see, all the instructions corresponding to the <i>memset ()</i> function call have been removed.  The compiler decided that it makes no sense to call the function clearing the data, since they are no longer used.  This is not a bug, but a legitimate compiler action.  From the point of view of the language, the <i>memset ()</i> call is not needed, since the buffer is not used further.  And if so, removing the <i>memset ()</i> call will not affect the behavior of the program.  Accordingly, our private data is not removed from memory, which is very bad. <br><br><h2>  A pile </h2><br>  And now let's dive deeper.  Let's check what will happen to the data that will be placed in dynamic memory using the <i>malloc</i> function or the <i>new</i> operator. <br><br>  Modify our code to work with <i>malloc</i> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;functional&gt; #include &lt;iostream&gt; struct PrivateData { size_t m_hash; char m_pswd[100]; }; void doSmth(PrivateData&amp; data) { std::string s(data.m_pswd); std::hash&lt;std::string&gt; hash_fn; data.m_hash = hash_fn(s); } int funcPswd() { PrivateData* data = (PrivateData*)malloc(sizeof(PrivateData)); std::cin &gt;&gt; data-&gt;m_pswd; doSmth(*data); memset(data, 0, sizeof(PrivateData)); free(data); return 1; } int main() { funcPswd(); return 0; }</span></span></span></span></code> </pre> <br>  We will check the release version, as in the Debug all calls are in their places.  After compilation in Visual Studio 2015, we will see the assembler code: <br><pre> <code class="cpp hljs">.... <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB1021 mov rcx, qword ptr [__imp_std::<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> (<span class="hljs-number"><span class="hljs-number">013F</span></span>BB30D8h)] <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB1028 mov rbx,rax <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB102B lea rdx,[rax+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB102F call <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; (<span class="hljs-number"><span class="hljs-number">013F</span></span>BB18B0h) <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB1034 mov rcx,rbx <span class="hljs-number"><span class="hljs-number">000000013F</span></span><span class="hljs-function"><span class="hljs-function">BB1037 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">BB1170h)</span></span></span><span class="hljs-function"> 000000013FBB103C xor edx,edx 000000013FBB103E mov rcx,rbx 000000013FBB1041 lea r8d,[rdx+70h] 000000013FBB1045 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memset</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">BB2A2Eh)</span></span></span><span class="hljs-function"> 000000013FBB104A mov rcx,rbx 000000013FBB104D call qword ptr [__</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_free</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">BB3170h)</span></span></span><span class="hljs-function">] </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> 0</span></span>; <span class="hljs-number"><span class="hljs-number">000000013F</span></span>BB1053 xor eax,eax ....</code> </pre> <br>  As you can see, in this case, Visual Studio is fine, our data cleaning works.  But let's see what other compilers will do.  Let's try to use <b>gcc</b> version 5.2.1 and <b>clang</b> version 3.7.0. <br><br>  For <b>gcc</b> and <b>clang,</b> I modified the source code a bit, adding a listing of the contents in the allocated memory before the clearing and after clearing the memory was added.  I printed the contents of the pointer after the release of memory.  In real programs, this cannot be done, since it is completely unknown how the program will behave in this case.  But for the experiment, I allowed myself such a liberty. <br><pre> <code class="cpp hljs">.... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"string.h"</span></span></span><span class="hljs-meta"> .... size_t len = strlen(data-&gt;m_pswd); for (int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; len; ++i) printf("%c", data-&gt;m_pswd[i]); printf("| %zu \n", data-&gt;m_hash); memset(data, 0, sizeof(PrivateData)); free(data); for (int i = 0; i &lt; len; ++i) printf("%c", data-&gt;m_pswd[i]); printf("| %zu \n", data-&gt;m_hash); ....</span></span></span></span></code> </pre> <br>  So, the assembler code fragment created by the <b>gcc</b> compiler: <br><pre> <code class="cpp hljs">movq (%r12), %rsi movl $.LC2, %edi xorl %eax, %eax call <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> movq %r12, %rdi call <span class="hljs-built_in"><span class="hljs-built_in">free</span></span></code> </pre> <br>  Immediately after the printout of the content ( <i>printf</i> ), we see the call to the function <i>free ()</i> , and the call to the function <i>memset () is</i> deleted.  If we execute the code and enter an arbitrary password (for example, ‚ÄúMyTopSecret‚Äù), we will get the following output on the screen: <br><br>  MyTopSecret |  7882334103340833743 <br><br>  MyTopSecret |  0 <br><br>  Hash has changed.  Apparently this is a side effect of the memory manager.  Our secret password "MyTopSecret", remained in the inviolable form in the memory. <br><br>  Now let's check for <b>clang</b> : <br><pre> <code class="cpp hljs">movq (%r14), %rsi movl $.L.str<span class="hljs-number"><span class="hljs-number">.1</span></span>, %edi xorl %eax, %eax callq <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> movq %r14, %rdi callq <span class="hljs-built_in"><span class="hljs-built_in">free</span></span></code> </pre> <br>  Observe a similar picture, the <i>memset ()</i> call is deleted.  The output to the screen looks the same way: <br><br>  MyTopSecret |  7882334103340833743 <br><br>  MyTopSecret |  0 <br><br>  In this case, both <b>gcc</b> and <b>clang</b> decided to optimize the code.  Since the memory is released after the <i>memset ()</i> function call, the compilers consider this call unnecessary and delete it. <br><br>  As it turned out, compilers, when optimized, remove the <i>memset ()</i> call when using the application‚Äôs stack and dynamic memory. <br><br>  And finally, we‚Äôll check how compilers behave when allocating memory with <i>new</i> . <br><br>  Once again we modify the code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include "string.h" struct PrivateData { size_t m_hash; char m_pswd[100]; }; void doSmth(PrivateData&amp; data) { std::string s(data.m_pswd); std::hash&lt;std::string&gt; hash_fn; data.m_hash = hash_fn(s); } int funcPswd() { PrivateData* data = new PrivateData(); std::cin &gt;&gt; data-&gt;m_pswd; doSmth(*data); memset(data, 0, sizeof(PrivateData)); delete data; return 1; } int main() { funcPswd(); return 0; }</span></span></span></span></code> </pre> <br>  Visual Studio conscientiously cleans the memory: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000013F</span></span><span class="hljs-function"><span class="hljs-function">EB1044 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">EB1180h)</span></span></span><span class="hljs-function"> 000000013FEB1049 xor edx,edx 000000013FEB104B mov rcx,rbx 000000013FEB104E lea r8d,[rdx+70h] 000000013FEB1052 call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memset</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">EB2A3Eh)</span></span></span><span class="hljs-function"> 000000013FEB1057 mov edx,70h 000000013FEB105C mov rcx,rbx 000000013FEB105F call </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">013F</span></span></span></span><span class="hljs-function"><span class="hljs-params">EB1BA8h)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> 0</span></span>; <span class="hljs-number"><span class="hljs-number">000000013F</span></span>EB1064 xor eax,eax</code> </pre> <br>  The <b>gcc</b> compiler in this case also decided to leave the code to clear the memory: <br><pre> <code class="cpp hljs">call <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> movq %r13, %rdi movq %rbp, %rcx xorl %eax, %eax andq $<span class="hljs-number"><span class="hljs-number">-8</span></span>, %rdi movq $<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(%rbp) movq $<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">104</span></span>(%rbp) subq %rdi, %rcx addl $<span class="hljs-number"><span class="hljs-number">112</span></span>, %ecx shrl $<span class="hljs-number"><span class="hljs-number">3</span></span>, %ecx rep stosq movq %rbp, %rdi call _ZdlPv</code> </pre> <br>  The output on the screen has changed accordingly, our data has been deleted: <br><br>  MyTopSecret |  7882334103340833743 <br><br>  |  0 <br><br>  But <b>clang</b> decided to optimize our code again and cut out the ‚Äúunnecessary‚Äù function: <br><pre> <code class="cpp hljs">movq (%r14), %rsi movl $.L.str<span class="hljs-number"><span class="hljs-number">.1</span></span>, %edi xorl %eax, %eax callq <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> movq %r14, %rdi callq _ZdlPv</code> </pre> <br>  Print the contents of the memory: <br><br>  MyTopSecret |  7882334103340833743 <br><br>  MyTopSecret |  0 <br><br>  The password remained in the memory and wait for it to be stolen. <br><br>  Let's sum up.  As a result of our experiment, it turned out that the compiler, by optimizing the code, can remove the <i>memset ()</i> function call when using any memory, both stack and dynamic.  Although Visual Studio did not delete <i>memset ()</i> calls when using dynamic memory, you can‚Äôt count on this in any case.  Perhaps when using other compilation flags, the effect will manifest itself.  From our little research, it follows that you cannot rely on the <i>memset ()</i> function to clear private data. <br><br>  How to clean private data correctly? <br><br>  You should use specialized memory cleaning functions that cannot be deleted by the compiler during code optimization. <br><br>  In Visual Studio, for example, you can use <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff562768%2528v%3Dvs.85%2529.aspx"><i>RtlSecureZeroMemory</i></a> .  Starting from C11, there is a <a href="http://en.cppreference.com/w/c/string/byte/memset"><i>memset_s</i></a> function.  If necessary, you can create your own safe function.  There are many examples on the Internet how to do it.  Here are some of the options. <br><br>  Option <a href="https://www.securecoding.cert.org/confluence/display/c/MSC06-C.%2BBeware%2Bof%2Bcompiler%2Boptimizations">N1</a> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> memset_s(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v, <span class="hljs-keyword"><span class="hljs-keyword">rsize_t</span></span> smax, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">rsize_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smax &gt; RSIZE_MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; smax) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = v; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (smax-- &amp;&amp; n--) { *p++ = c; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Option <a href="http://stackoverflow.com/a/13299459/965097">N2</a> . <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secure_zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = s; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Some go further and make a function that fills the array with pseudo-random values ‚Äã‚Äãand at the same time work different times to make it difficult for attacks related to time measurement.  Their implementation can also be found on the Internet. <br><br><h2>  Conclusion </h2><br>  The PVS-Studio static analyzer is able to find such errors.  It signals a problem situation using the <a href="http://www.viva64.com/ru/d/0208/">V597</a> diagnostic.  This article is written as an extended description of why this diagnosis is important.  Unfortunately, many programmers believe that the analyzer ‚Äúfights‚Äù on their code and in fact there is no problem.  After all, the programmer sees the <i>memset ()</i> function call in the debugger, forgetting that this is a debug version. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0388/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Roman Fomichev.  <a href="http://www.viva64.com/en/b/0388/">Safe Clearing of Private Data</a> . </div><p>Source: <a href="https://habr.com/ru/post/281072/">https://habr.com/ru/post/281072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281062/index.html">Release DBMS InterSystems Cach√© 2016.1</a></li>
<li><a href="../281064/index.html">Microsoft ‚ô• Open Source - the opening of a site dedicated to the history of friendship</a></li>
<li><a href="../281066/index.html">Metric recommendation system imhonet.ru</a></li>
<li><a href="../281068/index.html">OpenStack implementation and where to go next?</a></li>
<li><a href="../281070/index.html">Process Monitor or how to make the software work as user</a></li>
<li><a href="../281074/index.html">What's new in the Azure cloud after Build? Announcement Handbook</a></li>
<li><a href="../281076/index.html">Computer, no pain - Vulnerability Checklist</a></li>
<li><a href="../281078/index.html">PHDays online contests: battle for invites</a></li>
<li><a href="../281082/index.html">Matrix KVM Switching: Solution Comparison</a></li>
<li><a href="../281086/index.html">Planning computing resources and server selection for RUVDS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>