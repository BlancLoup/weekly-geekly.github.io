<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Errorx - library for working with errors in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is Errorx and how it is useful 


 Errorx is a library for working with errors in Go. It provides tools for solving problems related to the error...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Errorx - library for working with errors in Go</h1><div class="post__text post__text-html js-mediator-article"><h1 id="chto-takoe-errorx-i-chem-on-polezen">  What is Errorx and how it is useful </h1><br><p>  <a href="https://github.com/joomcode/errorx">Errorx</a> is a library for working with errors in Go.  It provides tools for solving problems related to the error mechanism in large projects, and a single syntax for working with them. </p><br><p><img src="https://habrastorage.org/webt/wq/c2/aw/wqc2awx3pmke-loujb4ea0yngya.jpeg" alt="image"></p><br><p>  Most Joom server components are written on Go since the company was founded.  This choice justified itself at the initial stages of development and the life of the service, and in the light of <a href="">announcements</a> about the prospects for Go 2, we are sure that we will not regret it in the future.  One of the main virtues of Go is simplicity, and an approach to error shows this principle as nothing else.  Not every project reaches a sufficient scale so that the capabilities of the standard library become lacking, prompting them to look for their own solutions in this area.  We happened to go through some evolution in approaches to working with errors, and the errorx library reflects the result of this evolution.  We are convinced that it can be useful to many - including those who are not yet experiencing severe discomfort in working with errors on their projects. </p><a name="habracut"></a><br><h2 id="oshibki-v-go">  Errors in go </h2><br><p>  Before turning to the story of errorx, you should make some explanations.  In the end, what is wrong with the errors? </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Very simple, isn't it?  In practice, an implementation often does not really bring with it anything but a string description of the error.  Such minimalism is associated with the approach that a mistake does not necessarily mean something ‚Äúexceptional‚Äù.  The most commonly used errors.New () from the standard library is true to this idea: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;errorString{text} }</code> </pre> <br><p>  If we recall that errors in the language have no special status and are common objects, the question arises: what is the peculiarity of working with them? </p><br><p>  Errors are <a href="https://golang.org/doc/faq">not exceptions</a> .  It‚Äôs no secret that many people who get acquainted with Go encounter this distinction with some resistance.  There are many publications, both explaining and supporting, and criticizing the approach chosen in Go.  Anyway, errors in Go serve many purposes, and at least one of them is exactly the same as exceptions in some other languages: troubleshooting.  As a consequence, it is natural to expect from them the same expressive power, even if the approach and syntax associated with their use is very different. </p><br><h3 id="chto-ne-tak">  What's wrong? </h3><br><p>  Many projects use errors in Go, as they are, and do not have the slightest difficulty in this.  However, as the complexity of the system grows, a number of problems begin to manifest themselves, which attract attention even in the absence of high expectations.  A good illustration is a similar line in the log of your service: </p><br><p> <code>Error: duplicate key</code> </p> <br><p>  Here, the first problem immediately becomes obvious: if you do not take care of this on purpose, then it is almost impossible to understand what went wrong in any large system, just by the original message.  This post lacks the details and broader context of the problem.  This is a programmer's mistake, but it happens too often to be neglected.  The code dedicated to the "positive" branches of the control graph, in practice, always deserves more attention and is better covered with tests than the "negative" code associated with interruption of execution or external problems.  How often the <code>if err != nil {return err}</code> mantra is repeated in Go programs makes this mistake even more likely. </p><br><p>  As a small digression, consider the following example: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyToUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Data, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ids</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserID</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { users, err := m.LoadUsers(ids) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionData []*Data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, user := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> users { data, err := action(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ok, err := m.validateData(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Error(<span class="hljs-string"><span class="hljs-string">"Validation failed for %v"</span></span>, data) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } actionData = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(actionData, data) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Apply(actionData) }</code> </pre> <br><p>  How quickly did you see an error in this code?  But it was done at least once, probably, by any Go programmer.  Hint: error in the <code>if err != nil { return nil }</code> expression <code>if err != nil { return nil }</code> . </p><br><p>  If we go back to the problem with a vague message in the log, then in this situation, of course, everyone also happened.  Starting to correct the error handling code already at the moment of the onset of the problem is very unpleasant;  besides, according to the source data from the log, it is not at all clear from which side to start the search for that part of the code, which, in fact, needs to be improved.  This may seem to be a far-fetched complexity for projects that are small in code size and number of external dependencies.  However, for large-scale projects this is a completely real and painful problem. </p><br><p>  Suppose a programmer with a bitter experience wants to add context to the error in advance, which he returns.  The naive way to do this is something like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"failed to insert user %s: %v"</span></span>, u.Name, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Got better.  The broader context is still unclear, but now it‚Äôs much easier to find at least the code in which the error occurred.  However, having solved one problem, we inadvertently created another.  The error created here kept the diagnostic message original, but everything else, including its type and additional content, was lost. </p><br><p>  To see how dangerous it is, consider the following code in the database driver: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrDuplicateKey = errors.New(<span class="hljs-string"><span class="hljs-string">"duplicate key"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// returns ErrDuplicateKey if a unique constraint is violated by insert } func IsDuplicateKeyError(err error) bool { return err == ErrDuplicateKey }</span></span></code> </pre> <br><p>  Now the <code>IsDuplicateKeyError()</code> check is destroyed, although at the moment when we added our text to the error, we had no intention to change its semantics.  This, in turn, will break the code that relies on this check: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := InsertUser(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db.IsDuplicateKeyError(err) { <span class="hljs-comment"><span class="hljs-comment">// find existing user, handle conflict } else { return err } }</span></span></code> </pre> <br><p>  If we want to get smarter and add our own type of error, which will store the original error and be able to return it, say, through the <code>Cause() error</code> method, we will also solve the problem only in part. </p><br><ol><li>  Now, in the place of error handling, you need to know that the true reason lies in <code>Cause()</code> </li><li>  There is no way to teach external libraries this knowledge, and the helper functions written in them will be useless. </li><li>  Our implementation can expect <code>Cause()</code> return the immediate cause of the error (or nil if there is none), while the implementation in another library will expect the method to return the non-nil root cause;  lack of standard means or a generally accepted contract faces very unpleasant surprises </li></ol><br><p>  However, this partial solution is used in many error libraries, including, to some extent, ours.  In Go 2, there are plans to popularize this approach ‚Äî if that happens, it should be easier to deal with the problems described above. </p><br><h2 id="errorx">  Errorx </h2><br><p>  Below we will talk about what solutions errorx offers, but first we will try to formulate the considerations that underlie the library. </p><br><ul><li>  <strong>Diagnostics is more important than saving resources.</strong>  The performance of creating and displaying errors is important.  However, they represent a negative, not a positive way, and in most cases serve as a signal about the problem, therefore the presence of diagnostic information in error is even more important. </li><li>  <strong>Stack trace by default.</strong>  In order for the error to go away with the fullness of the diagnosis, it should not take effort.  On the contrary, it is precisely to exclude part of the information (for the sake of brevity or for reasons of performance) that additional actions may be required. </li><li>  <strong>Error semantics.</strong>  There should be a simple and reliable way to check the meaning of the error: its type, type, properties. </li><li>  <strong>Ease of addition.</strong>  Adding diagnostic information to a passing error should be simple, and it should not destroy the verification of its semantics. </li><li>  <strong>Simplicity.</strong>  Error code is often and routinely written, so the syntax for basic manipulations with them should be simple and concise.  This reduces the number of bugs and makes it easier to read. </li><li>  <strong>Less is more.</strong>  The comprehensibility and uniformity of the code is more important than the optional features and possibilities for expansion (which, perhaps, no one will take advantage of). </li><li>  <strong>Error semantics are part of the API.</strong>  Errors that require separate handling in the calling code are de facto part of the package's public API.  There is no need to try to hide it or make it less obvious, but you can make the processing more convenient, and the external dependencies - less fragile. </li><li>  <strong>Most errors are opaque.</strong>  The more types of errors for the external user are indistinguishable from each other, the better.  The loading of the API by the types of errors that require special handling, as well as the loading of the errors themselves with the data necessary for processing them - a design defect that should be avoided. </li></ul><br><p>  The most difficult for us was the question of extensibility: should errorx provide primitives for institutions of arbitrarily different user-defined error types, or an implementation that allows you to get everything you need from the box?  We chose the second option.  First, errorx solves a quite practical problem - and our experience of using it shows that for this purpose it is better to have a solution, and not spare parts for its creation.  Secondly, the consideration of simplicity is very important: since less attention is paid to errors, the code should be designed to prevent a bug in working with them was more difficult.  Practice has shown that for this it is important that all such code looks and works the same. </p><br><h4 id="tldr-po-osnovnym-ficham-biblioteki">  TL; DR by main features of the library: </h4><br><ul><li>  Stack trace creation in all errors by default </li><li>  Type checks on errors, several varieties </li><li>  Ability to add information to an existing error without breaking anything </li><li>  Manage type visibility if you want to hide the original reason from caller </li><li>  The mechanism for generalizing error handling code (type hierarchy, traits) </li><li>  Custom error dynamic properties </li><li>  Standard error types </li><li>  Syntax utilities to improve readability of error handling code </li></ul><br><h3 id="vvedenie">  Introduction </h3><br><p>  If we rework the example we analyzed above using errorx, we get the following: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( DBErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"db"</span></span>) ErrDuplicateKey = DBErrors.NewType(<span class="hljs-string"><span class="hljs-string">"duplicate_key"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return ErrDuplicateKey.New("violated constraint %s", details) } func IsDuplicateKeyError(err error) bool { return errorx.IsOfType(err, ErrDuplicateKey) }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to insert user %s"</span></span>, u.Name) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  The calling code using <code>IsDuplicateKeyError()</code> will not change at all. </p><br><p>  What has changed in this example? </p><br><ul><li>  <code>ErrDuplicateKey</code> become a type, not an error instance;  checking for it is resistant to copying an error, there is no fragile dependence on exact equality </li><li>  Appeared namespace for database errors;  there are likely to be other errors in it, and such a grouping is useful for readability and in some cases can be used in code </li><li>  Insert returns a new error for each call: <br><ul><li>  The error contains more details;  this, of course, is possible without errorx, but it is impossible if the same error instance is returned each time, which was previously required for <code>IsDuplicateKeyError()</code> </li><li>  These errors can carry a different stack trace, which is useful because  not for all calls to the Insert function, such a situation is valid </li></ul></li><li>  <code>InsertUser()</code> complements the text of the error, but applies the original error, which is saved in its entirety for subsequent operations </li><li>  <code>IsDuplicateKeyError()</code> now works: it cannot be spoiled by copying an error, nor as many layers of Decorate () as you like </li></ul><br><p>  It is not necessary to always follow exactly this pattern: </p><br><ul><li>  The type of error is not always unique: the same types can be used in many places. </li><li>  If desired, the stack trace collection can be disabled, and also not create a new error every time, but return the same one as in the original example;  These are the so-called sentinel errors, and we do not recommend their use, but this can be useful if the error is used only as a marker in the code and you want to save on the creation of objects. </li><li>  There is a way to make the <code>errorx.IsOfType(err, ErrDuplicateKey)</code> stop working if you want to hide the root cause semantics from others' eyes </li><li>  For the actual type checking there are other ways besides the comparison for the exact type. </li></ul><br><p>  <a href="https://godoc.org/github.com/joomcode/errorx">Godoc</a> contains detailed information about all this.  Below we take a little more detail on the main features, which is enough for everyday work. </p><br><h3 id="tipy">  Types </h3><br><p>  Any errorx error belongs to some type.  Type matters, because  inherited error properties can be passed through it;  it is through him or his traits that, if necessary, semantic checking will be done.  In addition, the expressive type name complements the error message and may in some cases replace it. </p><br><pre> <code class="go hljs">AuthErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"auth"</span></span>) ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>)</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ErrInvalidToken.NewWithNoMessage()</code> </pre> <br><p>  The error message will contain <code>auth.invalid_token</code> .  The error declaration would look different: </p><br><pre> <code class="go hljs">ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>).ApplyModifiers(errorx.TypeModifierOmitStackTrace)</code> </pre> <br><p>  In this variant, using the type modifier, the stack trace collection is disabled.  The error has marker semantics: its type is given to the external user of the service, and the call stack in the logs would not be useful, since  This is not a problem to be repaired. </p><br><p>  Here you can say that errors have a dual nature in several aspects.  The contents of the error are used both for diagnostics and, sometimes, as information for an external user: an API client, a library user, etc.  The error code is used both as a means of communicating the semantics of the incident, and as a mechanism for transferring control.  When using error types, this should be borne in mind. </p><br><h3 id="sozdanie-oshibki">  Making a mistake </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyType.New(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>)</code> </pre> <br><p>  It‚Äôs completely unnecessary to create your own type for every mistake.  Any project can have its own general-purpose error package, and some set comes as part of the common namespace along with errorx.  It contains errors that, in most cases, do not involve processing in the code and are suitable for "exceptional" situations when something went wrong. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IllegalArgument.New(<span class="hljs-string"><span class="hljs-string">"negative value %d"</span></span>, value)</code> </pre> <br><p>  In a typical case, the call chain is arranged so that the error is created at the very end of the chain, and is processed at the very beginning.  In Go, it is not without reason that it is considered bad form to handle an error twice, that is, for example, to write an error to the log and return it higher up the stack.  You can, however, add information to the error itself before giving it away: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to upload '%s' to '%s'"</span></span>, filename, location)</code> </pre> <br><p>  The text added to the error will appear in the log, but it does not hurt to check the type of the original error. </p><br><p>  Sometimes a reverse need arises: whatever the nature of the error, the external user of the package should not know it.  If he got the opportunity, he could create a fragile dependence on a part of the implementation. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.ErrBadRequest.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to load user data"</span></span>)</code> </pre> <br><p>  An important difference that makes Wrap the preferred alternative to New is that the original error is fully reflected in the logs.  And, in particular, it will bring with it a useful initial call stack. </p><br><p>  Another useful technique that allows you to save all possible information about the call stack looks like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.EnhanceStackTrace(err, <span class="hljs-string"><span class="hljs-string">"operation fail"</span></span>)</code> </pre> <br><p>  If the original error came from another gorutina, the result of such a call will contain the stack trace of both gorutins, which unusually increases its usefulness.  The need to make such a call is clearly determined by performance issues: this case is relatively rare, and ergonomics, which would detect it itself, would slow down the usual Wrap, where it is not required at all. </p><br><p>  <a href="https://godoc.org/github.com/joomcode/errorx">Godoc</a> contains more information and also describes additional features such as DecorateMany. </p><br><h3 id="obrabotka-oshibok">  Error processing </h3><br><p>  Best of all, if error handling comes down to the following: </p><br><pre> <code class="go hljs">log.Error(<span class="hljs-string"><span class="hljs-string">"Error: %+v"</span></span>, err)</code> </pre> <br><p>  The less an error is required to do, except how to print it to the log on the system layer of the project, the better.  In reality, this is sometimes not enough, and you have to do this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errorx.IsOfType(err, MyType) { <span class="hljs-comment"><span class="hljs-comment">/* handle */</span></span> }</code> </pre> <br><p>  This check will succeed both on the <code>MyType</code> type error and on its child types, and it is resistant to <code>errorx.Decorate()</code> .  Here, however, there is a direct relationship to the type of error, which is quite normal within the package, but it can be frustrating if used outside of it.  In some cases, the type of such an error is part of a stable external API, and sometimes we would like to replace this check with a property check, rather than the exact type of error. </p><br><p>  In classic Go errors, this would be done through an interface, the type cast on which would serve as an indicator of the type of error.  Errorx types do not support this extension, but you can use the <code>Trait</code> mechanism instead.  For example: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTemporary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HasTrait(err, Temporary()) }</code> </pre> <br><p>  This errorx built-in function checks if an error has a standard <code>Temporary</code> property, i.e.  whether it is temporary.  Marking error types with traits is the responsibility of the source of the error, and through them it can transmit a useful signal without making specific internal types part of the external API. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IgnoreWithTrait(err, errorx.NotFound())</code> </pre> <br><p>  This syntax is useful when a particular kind of error is needed to interrupt the control flow, but should not be passed to the calling function. </p><br><p>  Despite the abundance of processing tools, not all of which are listed here, it is important to remember that working with errors should remain as simple as possible.  An example of the rules that we try to follow: </p><br><ul><li>  The code that received the error should always log it in its entirety;  if some of the information is redundant, let the error-generating code take care of it </li><li>  You can never use an error text or the result of the <code>Error()</code> function to process it in code;  only type / trait checks are suitable for this, or type assertion in case of non-errorx errors </li><li>  User code should not break if some kind of error is not processed in a special way, even if such processing is possible and gives it additional features. </li><li>  Errors that are checked by properties are better than the so-called sentinel errors, since  such checks are less fragile </li></ul><br><h3 id="vne-errorx">  Beyond errorx </h3><br><p>  Here we described what is available to the library user out of the box, but in Joom the penetration of the code associated with errors is very large.  The logging module explicitly accepts errors in its signature and is engaged in printing them in order to exclude the possibility of incorrect formatting, as well as retrieving from the error chain the optionally available contextual information.  The module responsible for panic-safe work with gorutiny unpacks an error if it arrives along with panic, and also knows how to present panic using the error syntax without losing the original stack trace.  Some of this, perhaps, we will also publish. </p><br><h2 id="voprosy-sovmestimosti">  Compatibility issues </h2><br><p>  Despite the fact that we are very pleased with the way errorx allows us to work with errors, the situation with the library code devoted to this topic is far from ideal.  We at Joom solve quite specific practical problems with the help of errorx, but from the point of view of the Go ecosystem, it would be preferable to have this entire set of tools in the standard library.  An error, the source of which actually or potentially belongs to another paradigm, has to be regarded as alien, i.e.  potentially not carrying information in the form as is customary in the project. </p><br><p>  However, some things were done in such a way as not to conflict with other existing solutions. </p><br><p>  The <code>'%+v'</code> format is used to print an error along with stack trace, if present.  This is the de facto standard in the Go ecosystem and is even included in the draft design for Go 2. </p><br><p>  <code>Cause() error</code>  errorx ,  ,   ,    Causer,       errorx      Wrap(). </p><br><h2 id="buduschee">  Future </h2><br><p>  <a href=""></a>   ,    Go 2,      .  <a href="">   </a>       . </p><br><p> ,    errorx     Go 1.      ,    Go 2,     .       ,            ,        errorx. </p><br><p> Check-handle      ,   errorx , a <code>Unwrap() error</code>       <code>Wrap()</code>  errorx (.. ,        ,    <code>Wrap</code> ),    .     ,      ,  . </p><br><p>     design draft   Go 2,    <code>errorx.Is()</code>  <code>errorx.As()</code>   ,      errors   . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>   ,   ,   ,    -      ,        .      ,      API     :  ,   ,       .  1.0      ,           Joom. ,  -       . </p><br><p> : <a href="https://github.com/joomcode/errorx">https://github.com/joomcode/errorx</a> </p><br><p>   ,    ! </p><br><p><img src="https://habrastorage.org/webt/nk/hv/el/nkhvelss5upmybktmbpy68ozo_a.jpeg" alt="image"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/429690/">https://habr.com/ru/post/429690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429680/index.html">MIT course "Computer Systems Security". Lecture 17: User Authentication, Part 1</a></li>
<li><a href="../429682/index.html">MIT course "Computer Systems Security". Lecture 17: User Authentication, Part 2</a></li>
<li><a href="../429684/index.html">Firebase Summit 2018: A Brief Summary</a></li>
<li><a href="../429686/index.html">MIT course "Computer Systems Security". Lecture 17: User Authentication, Part 3</a></li>
<li><a href="../429688/index.html">How to create a hero in which they will believe</a></li>
<li><a href="../429692/index.html">Optimization of event handling in Angular</a></li>
<li><a href="../429694/index.html">Mail.Ru called "absurd" a rating of sites from "Yandex" and demands to remove its brands from it</a></li>
<li><a href="../429696/index.html">Video reports from MOSDROID # 13 Aluminum</a></li>
<li><a href="../429698/index.html">How to work with Lebedev Studio: the experience of Tutu.ru</a></li>
<li><a href="../429700/index.html">Definition of numbers by ear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>