<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>REST API Design for High Performance Systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexander Lebedev expresses all the non-triviality of the REST API design. This is a transcript of the Highload ++ 2016 report. 

 Hello everybody! 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>REST API Design for High Performance Systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e4c/47a/ea6/e4c47aea64654856b0e6fcf9bbf74acc.jpg"><br><br>  <i>Alexander Lebedev expresses all the non-triviality of the REST API design.</i>  <i>This is a transcript of the <a href="http://www.highload.ru/">Highload ++</a> 2016 report.</i> <br><br>  Hello everybody! <br><blockquote>  Raise the hand of those who are frontend developer in this room?  Who is a mobile developer?  Who is the backend developer? </blockquote>  Backend developers are most in this room now, which is joyful.  Secondly, almost everyone woke up.  Wonderful news. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  A few words about yourself </h3><br>  Who am i?  What do you do? <br><br>  I am a frontend team lead of the company "New Cloud Technologies".  For the last 5 years, I have written a web front-end that works with the REST API and which should work fast for the user.  I want to share experiences about what API should be, which allow to achieve this. <br><br>  Despite the fact that I will be telling from the front end, the principles - they are common more or less for everyone.  I hope both backend developers and mobile application developers will also find useful things in this story. <br><a name="habracut"></a><br><h3>  A few words on why it is important to have a good API for fast applications. </h3><br>  <b>First is performance from the client‚Äôs point of view.</b>  That is, not from the point of view of supporting us with one million customers who came at the same time ‚Äî but from the point of view that for each of them the application worked quickly.  A little later, I will illustrate a case in this report, when changes in the API made it possible to speed up the data acquisition on the client about 20 times and allowed the unfortunate users to turn into satisfied users. <br><br>  <b>Secondly - in my practice there was a case when, after a very short period of time, I had to write the same practically functional to two different systems.</b>  One had a convenient API, another had an awkward API.  How do you think the complexity of writing this functionality was different?  For the first version - 4 times.  That is, with a convenient API, we wrote the first version in two weeks, with an uncomfortable one in two months.  The cost of ownership, the cost of support, the cost of adding something new - it also differed significantly. <br><br>  If you do not design your REST API, then you can‚Äôt guarantee that you will not be on the wrong side of this range.  Therefore, I want the approach to the REST API to be reasonable. <br><br>  Today I will talk about simple things, because they are more or less universal - they apply to almost all projects.  How to properly complex cases require a separate analysis, they are specific to each project, and therefore not so interesting in terms of the exchange of experience. <br><br>  <i>Simple things are interesting to almost everyone.</i> <br><br>  Let's start by looking at the situation as a whole.  In what environment is there a REST API that we need to do well? <br><br>  <b>In cases with which I have worked, the following generalization can be made:</b> <br><br><img src="https://habrastorage.org/files/3a2/7b4/774/3a27b4774c6042a0986a1e5256e3b031.jpg"><br><br>  We have a certain backend - conditionally, from the point of view of the frontend, it is one.  In fact, everything is difficult there.  Probably, everyone saw a caricature, where a mermaid acts as a front end, and a horrible sea monster as a backend.  This may also work about.  It is important that we have a single backend in terms of the front - we have a single API, there are several clients for it. <br><br>  A fairly typical case: we have a web, and we have the two most popular mobile platforms.  What can you immediately learn from this picture?  One backend, several clients.  This means that many times in the API design code there will be choices where to take the complexity.  Either a little more work to do on the back end, or a little more work to do on the front. <br><br>  It should be understood that in such a situation, the work at the front will be multiplied by 3. Each product will have to contain the same logic.  It will also be necessary to apply additional efforts not even in the course of development, but in the course of further testing and maintenance, so that this logic does not disperse and remains the same on all clients. <br><br>  It should be understood that the assignment of some kind of logic to the frontend is expensive and should have its own reasons, it should not be done "just like that."  I would also like to note that the API in this picture is also single, not without purpose. <br><br>  As a rule, if we say that we want to develop efficiently and we want to make the application fast, we really want to, despite the fact that there can be a zoo of systems on the backend (enterprise integration of half a dozen systems with different protocols, with different APIs).  From the point of view of communicating with the front-end, it should be a single API, preferably built on the same principles, and which can be changed more or less completely. <br><br>  If this is not the case, then it becomes much more difficult to talk about some meaningful API design, the number of decisions increases, and we have to say: ‚Äúwell, we have to, these are limitations.‚Äù  It would be desirable, that in this situation it was not necessary to fall.  It would be desirable, that we could, at least from the point of view of what API we provide for client applications, to control it all. <br><br>  <b>One more thing - let's add people to this scheme.</b> <br><br><img src="https://habrastorage.org/files/c76/4c2/75f/c764c275f00c4d369a8a04889cf12691.jpg"><br><br><h3>  What we do </h3><br>  It turns out we have one or several backend teams, one or several front-end teams.  You have to understand that if we want to have a good API, it is in the public domain.  All teams work with him.  This means that API decisions should preferably be made not in one team, but jointly.  The most important thing is that decisions should be made in the interests of all these teams. <br><br>  If I, like the frontend lead, in order to implement some functionality on the web, invent an API and go to negotiate with the backend developers to implement it - I must take into account not only the interests of the web, not only the interests of the backend, but also the interests of mobile teams.  Only in this case will not have to painfully alter. <br><br>  Or I must immediately clearly understand that I am doing some kind of temporary prototype, which then will need to cover the range from which we collect the requirements, including the rest of the teams and redoing them.  If I understand this, then we can proceed from the interests of a separate team.  Otherwise, it is necessary to proceed from the interests of the system as a whole.  All these people have to work together for the API to be good. <br><br>  In such conditions, I managed to ensure that the API was convenient - that it was convenient for him to write a good frontend. <br><br>  Let's talk a little bit about general ideas before we get into the specifics. <br><br><h3>  Three basic principles that you want to highlight </h3><br>  What I have already said a little about the human key for technical solutions is also important.  Technical decisions on API should be made on the basis of their entire system, and not on the basis of the vision of any particular part of it. <br><br>  Yes. This is hard.  Yes, it requires some additional information when you need to do it right now, but it pays off. <br><br>  Secondly, performance measurement is more important than its optimization. <br><br>  What does it mean?  Until you start measuring how fast your frontend is working, how fast your backend is working, it's too early for you to optimize them.  Because, almost always - in this case the wrong thing will be optimized.  I'll talk about a couple of such cases later. <br><br>  Finally, the fact that I have already touched the edge.  Complex cases - they are unique for each project. <br><br>  Simple principles are more or less universal, so I want to tell you about a few simple mistakes, some of which are learned through personal experience.  These errors can not repeat almost any project. <br><br>  A small section on how to measure performance.  In fact, this is a very serious topic - there is a lot of hotel literature on it, a lot of hotel materials, as well as specialists who deal only with this. <br><br><h3>  What am i going to tell </h3><br>  I'm going to tell you where to start, if you have nothing at all.  Some cheap and angry recipes that will help you start changing the performance of the web front end and start measuring the performance of the backend so that you can start to speed them up.  If you already have something, great.  Most likely it is better than what I propose. <br><br>  <b>Backend performance.</b> <br><br>  We measure through what clients work with - through the REST API.  It is desirable to recreate more or less exactly how the user works with this API. <br><br>  We measure UI performance through automated frontend testing.  That is, in each case we measure not some internal elements - we measure the very interface with which the next layer works. <br><br>  <b>That is, REST API for the backend and UI for the user.</b> <br><br><h3>  What you need to understand to measure </h3><br>  First, the closer our environment to what will work in production - the more accurate our numbers.  It is very important that we have data similar to the real ones. <br><br>  It often happens when we develop, we don‚Äôt have any test data at all.  The developer creates something on his machine - usually one entry to cover each scenario that was thought of during the analysis and it turns out 5-10 entries.  All is well. <br><br>  And then it turns out that real users work with 500 entries, in the same interface, in the same system.  Brakes and problems start.  Or the developer creates 500 entries, but they are all the same and created by the script.  With uneven real-life data, all kinds of anomalies can begin. <br><br>  If you have data from a production, the best test data - we take a sample of data from a production, we remove from there all sensitive information that is the private property of specific customers.  On this we develop, on this we test.  If we can do this, then this is great, because we don‚Äôt need to think about what this data should be. <br><br>  If we still have an early stage in the life of the system and we can‚Äôt do that, we have to guess how the users will use the system, how much data is there, what kind of data.  Typically, these proposals will be very different from real life, but they are still 100 times better than the ‚Äúthat grew, it grew‚Äù approach. <br><br>  Then, the number of users.  Here we are talking about backend, because the user is usually alone at the front end.  There is a temptation when we test the performance, to let a small number of users with very intensive requests.  We say: ‚Äú100 thousand people will come to us, they will make new requests on average every 20 seconds. <br>  Let's replace it with 100 bots that will make new requests every 20 milliseconds. ‚Äù <br><br>  It would seem that the total load will be the same.  However, it immediately turns out that in this case we almost always measure not the system performance, but the performance of the cache somewhere on the server, or the performance of the database cache, or the performance of the application server cache.  We can get numbers that are much better than real life.  It is desirable that the number of users - the number of simultaneous sessions, was also close to what we expect in real life. <br><br><h3>  How users work with the system </h3><br>  It is important that we estimate how many times each element will be used during the middle session.  I had a case where we implemented a load testing script simply by writing a script that touches all the important parts of the system, once in a while.  That is, a person enters, uses each important function once and exits. <br><br>  And it turned out that we have the two slowest points.  We began to heroically optimize.  If we thought or looked at the statistics that weren't at that time, we would know that the first slowest point is used in 30% of the sessions, and the second slowest point is used in 5% of the sessions. <br><br>  This, first of all, would allow us to optimize them in different ways.  Where 30% is more important.  And secondly, it would allow to draw attention to the fact that there is a functional, which, despite the fact that it does not work so slowly, is always used. <br><br>  If a session starts with logging into the system and viewing a dashboard, then the performance of this input and the performance of this dashboard feel 100% of the users on their skin. <br><br>  Therefore, even if these are not the slowest places, it still makes sense to optimize them.  Therefore, it is important to think about how the system will be perceived by a typical user, and not what functionality we have or what functionality we should check for performance. <br><br>  <b>On the back end - how can we measure the performance of the REST API?</b> <br><br>  The approach that I personally used, which works quite well as a first approximation, is that we should have a use case.  We have no use case, we write them. <br><br>  We estimate the percentage of use of system functions in each session.  We shift it to requests to the REST API.  We are convinced that we have data similar to the real ones for test users.  We write scripts that generate them.  Then we unload all this into JMeter or any other tool that allows us to arrange trips to the REST API with a large number of concurrent users and test.  As a first decision, nothing complicated. <br><br>  <b>For the frontend - all about the same degree of oak.</b> <br><br><img src="https://habrastorage.org/files/dbb/109/00a/dbb10900a69e42618102444486ab4743.jpg"><br><br>  We type the key places in the code, calls of console functions that consider time, we output to the console, everything is enough for the developer. <br><br>  He can run the debug build, see how long a particular piece of time has been displayed, how long it has been between different user actions - all is well. <br><br>  If we want to do this automatically we write the Selenium script.  For Selenium, the console functions are not very similar - a primitive wrapper is written there that takes exactly the time of windows.performance.now () and transfers it to some global object, from where it can be picked up later.  In this case, we can drive the same scenario on different versions and track how our system performance changes over time. <br><br>  <b>Now I want to go to the main part - recipes, known from personal experience.</b> <br><br><h3>  How to and how not to do the API </h3><br><br>  Let's start with one rather curious case: I said that at the API level, you can optimize the processing speed by 20 times. <br>  Now I will show how exactly this scenario was arranged. <br><br><img src="https://habrastorage.org/files/d9b/506/2b2/d9b5062b20114e0384dc9c89748a05f0.jpg"><br><br>  We have a backend.  It aggregates the data of their three different systems and shows them to the user.  In normal life, the response time looks like this: <br><br><img src="https://habrastorage.org/files/b3b/755/432/b3b7554322fc46bd93541b3aec1c3ee8.jpg"><br><br>  Three parallel queries are leaving - the backend aggregates them.  Time in seconds.  Everywhere the answer is less than a second.  100 milliseconds are added for paralleling the aggregation request.  We give the data to the frontend and everyone is happy. <br><br>  <b>It would seem that all is well, what can go wrong?</b> <br><br><img src="https://habrastorage.org/files/c18/f42/acb/c18f42acb35c4827a631053f35ae9c10.jpg"><br><br>  One of the systems suddenly dies - moreover, it dies in a very pernicious way, when instead of immediately answering honestly that the system is not available - it hangs on a timeout. <br><br>  This happens in those days when the load on the system as a whole is when we have the most users.  Users happily see that their loading spinner does not disappear, they press F5, we send new requests, everything is bad. <br><br><h3>  What we did in this case </h3><br>  The first thing we did was lower timeouts.  It became like this: <br><br><img src="https://habrastorage.org/files/01b/78e/11d/01b78e11d80b4e86bd94318019c5d886.jpg"><br><br>  Users began to wait on average for their answers, but still they were very unhappy.  Because 15 seconds, where there used to be one - it is extremely difficult.  The problem was rolling.  System C worked at normal speed, then lay down, then worked again. <br><br>  Timeouts below this figure could not be reduced, because there were situations when she normally answered seconds 10-12.  It was rare. <br><br>  But if we lowered the timeout, we would start to make unhappy also the users who fell into this tail of response time. <br><br>  The first decision in the forehead was made on the same day.  It improved the situation, but still it remained bad.  What was the right global solution? <br><br>  We did this: <br><br><img src="https://habrastorage.org/files/e05/886/8c0/e058868c0f744ae394982f78f2972739.jpg"><br><br>  Through the REST API, the requests were written in which it was written: the client transferred data from which system it wants to receive, three requests went in parallel, the data were aggregated on the client.  It turned out that those 80% of users who had enough data from System A and B to work - they were happy.  Those users (20%) to whom data from System C were also needed ‚Äî they continued to suffer.  But the suffering of 20% is much better than the suffering of absolutely everyone. <br><br><h3>  What ideas would you like to illustrate with this case? </h3><br>  This is the case when it was possible for all to accelerate very much. <br><br>  First, optimization, often - this is an extra job, this is code degradation.  From the point of view of complexity, it is clear that it is more difficult to aggregate data on the frontend - you need to do parallel queries, you need to handle errors, you need to propagate the business of data aggregation to all our frontends. <br><br>  In the case when we work with a heavy scenario, where performance is critical for the user, this is sometimes necessary.  That is why it is so important to measure performance, because if such heroism begins to be performed in any place where it will be a little slower, you can spend a lot of effort in vain.  <b>That was the first thought.</b> <br><br>  <b>The second thought.</b>  There is a remarkable principle of encapsulation, which says that "we must hide the insignificant details behind the API and not show them to the client." <br><br>  If we want a fast system, we should not encapsulate the cost of operations.  In a situation where we have an abstract API that returns only all the data at once and it can only do it very expensively and we want to have a fast client.  We had to break the principle of encapsulation in this place and make it so that we had the opportunity to send cheap requests and the possibility of an expensive request.  These were different parameters of the same call. <br><br>  <b>I want to tell you a few thoughts about the use of Pagination, about the pros / cons, experience gained.</b> <br><br>  In the era of web 1.0, there were a lot of places where you could see interfaces that show 10-20-50 records and an endless list of pages: search engines, forums, whatever. <br><br>  Unfortunately, this thing crawled into a very large number of APIs.  Why "Unfortunately?  Despite the fact that the solution is old and proven, everyone is more or less aware of how to work with him, there are problems that I want to talk about. <br><br>  First, remember the Yandex screen, which says that there were 500 thousand results in 0.5 seconds. <br><br><img src="https://habrastorage.org/files/597/548/99a/59754899aa02498b98a489d1a1695c5d.jpg"><br><br>  Figures from the air - I'm sure Yandex is faster. <br><br>  One of the cases I saw when, in order to display the first page, data sampling cost 120 milliseconds - and counting the total amount of data that fall into the search criteria cost 450 milliseconds.  Attention question: for the user, the truth is that all the results are n - is it 4 times more important than the first page data? <br><br>  <b>Almost always not.</b>  It would be desirable that if the data is not very important for the user, then their receipt was either as cheap as possible, or this data should be excluded from the interface. <br><br>  Here you can significantly improve this case by refusing to show the total number of results - you can write a lot of results.  Suppose there was a case when we were approximately in such a situation, instead of writing that ‚Äú100 results out of 1200 are shown‚Äù began to write that ‚Äúthe total number of results is more than 100, please specify the search criteria if you want to see something else‚Äù . <br><br>  This is not the case with all systems, so measure before changing anything. <br><br><h3>  What other problems are there </h3><br>  From the point of view of usability, even when we don‚Äôt go to the server for the next page - all the same, in well-built user interfaces it‚Äôs not often that the user needs to go somewhere far behind the data. <br><br>  For example, going to the second page of Google and Yandex, for me personally, comes only from despair, when I searched, did not find it, tried to formulate differently, did not find it either, tried the third, fourth option - and here I can already climb on the second page of these search options, but I do not remember when I last did it. <br><br>  <i>Who in the last month ever went to the second page of Google or Yandex?</i>  Quite a lot of people. <br><br>  In any case, the first or second page.  It may be necessary to simply show more data at once, but there is no reason why your user in a normally made interface might need to walk, let's say on page 50.  There are issues with usability in pagination. <br><br>  Another very painful problem.  <b>What will you do if the data set in the sample has changed between the page requests?</b> <br><br>  This is especially true for applications that do not have such a reliable network or frequent offline. <br><br>  On mobile at all hard.  On the web, which is honed under the possibility of working offline, is also not easy.  There begins a very curly and peculiar logic on how we can invalidate the data of the previous pages - what should we do if the data of the first page is partially shown on the second, how to sew these pages.  It's complicated. <br><br>  There are many articles on how to do it and the solution is.  I just want to warn you that if you are going in this direction - know this problem and appreciate in advance what will be its solution.  It is rather unpleasant. <br><br>  In all cases where I had to work, we usually either refused pagination at the design stage, or made a rough prototype, and then reworked it for something.  It was possible to get away from the problem before they began to deal with it. <br><br><h3>  Let's sum up </h3><br>  I would like to say that pagination, especially in the form of endless scrolling, is quite appropriate in some situations.  For example, we make some kind of news feed.  VKontakte tape, where the user shakes it from top to bottom and reads it for entertainment purposes, without trying to find something specific - this is just one of those cases where page-by-page loading, with endless scrolling, will work wonderfully. <br><br>  If you have some kind of business interface and there we are not talking about the flow of events - but this is about finding objects with which you need to interact, objects of more or less long-term living.  Most likely there is another UI solution that allows you not to have these problems with the API and which allows you to make a more convenient interface. <br><br>  Want to go in the direction of pagination?  Think about what the choice of the total number of elements will cost and whether it is possible to do without them.  And think about how to deal with synchronization issues that change between data pages. <br><br>  <b>Let's talk about the next problem - it is very simple.</b> <br><br>  We have 10 interface elements that we show to the user: <br><br><img src="https://habrastorage.org/files/8d5/0ff/871/8d50ff87147a4a6c83a65a2f27b84f1c.jpg"><br><br>  In the normal case, we will make 1 request, get all the data, show. <br><br>  <b>What happens when we don't think?</b> <br><br>  We will make 1 request for the list, then go down separately for each element of the list, this data on the client will die, we will show. <br><br>  The problem is very old - it came from SQL databases, perhaps, it also existed somewhere before SQL.  It continues to exist now. <br><br>  <b>There are two very simple reasons why this happens.</b> <br><br>  Either we did the API and did not think about what the interface would be and therefore did not include enough data in the API, or when we were doing the interface, we didn‚Äôt think what data the API could give us and included too much.  Solutions are also pretty simple. <br><br>  We either add data to the request and learn to get what we need to show with a single request, or we remove some data on individual objects either in the details page, or make some right panel where you select an element and load it to you. data. <br><br>  There are no cases when it makes sense to work like this and lists to make more than one request for data. <br><br>  Let's imagine that we have added a lot of data.  We will immediately encounter the following problem: <br><br><img src="https://habrastorage.org/files/807/874/4c7/8078744c73954a1193bf988b8faf290d.jpg"><br><br>  We have a list.  To display it, we need one amount of data, but we actually load 10 times more.  Why it happens? <br><br>  Very often, an API is designed according to the principle that we give the lists exactly the same object representations as with a detailed query.  We have some page details of the object on 10 screens, with a bunch of attributes and we get all this in one request.  In the list of objects we use the same view.  What is bad? <br><br>  The fact that such a request may be more expensive and the fact that we download a lot of data over the network, which is especially important for all mobile applications. <br><br><h3>  How I personally fought with it </h3><br>  An API is made that allows you to give two versions for each object of this type: short and full.  The list request to the API gives short versions and this is enough for us to draw the interface.  For the details page we request the full. <br><br>  Here it is important that in each object there is a sign of whether it represents a multiple or full version.  Because if we have a lot of optional fields, the business logic, by definition, ‚Äúdo we already have a full version of the object or need to request it‚Äù can become quite curly.  This is not necessary. <br><br>  You just need a field that you can check. <br><br>  <b>Let's talk about how to cache?</b> <br><br>  In general, for the ecosystem I described: backend, REST API, frontend.  There are three levels of caching.  Something is caching the server, something can be caching at the HTTP level, something can be cached on the client. <br><br>  From the point of view of the developer's frontend, there is no server cache.  It's just some kind of tricky magic that server developers use to make the backend work quickly. <br><br>  <b>Let's talk about what we can influence.</b> <br><br>  HTTP cache  What is he good at? <br><br>  It is good in that it is an old generally accepted standard that everyone knows, which almost all clients implement.  We get a ready implementation on both the client and the server, without having to write any code.  The most that can be required is to tweak something. <br><br><h3>  What is the problem </h3><br>  The HTTP cache is quite limited, in the sense that there are standards, and if your case is not provided for, then excuse me, you will not do it.  It should be done programmatically in this case. <br><br>  Another feature.  Data invalidation in the HTTP cache occurs through a server request, which can somewhat slow down work, especially on mobile networks.  In principle, when you have your own cache, you do not have this problem. <br><br>  A number of keywords that you need to know about the operation of the HTTP cache.  I don't have much time.  Just say - read the specification, everything is there. <br><br>  Pro client cache.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He has the pros / cons exactly the opposite. </font><font style="vertical-align: inherit;">This is the fastest response time, the most flexible cache - but it must be written. </font><font style="vertical-align: inherit;">You need to write it in such a way that it works more or less the same way on all of your customers. </font><font style="vertical-align: inherit;">In addition - there is no finished specification, where everything is written, you need to invent something.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> General recommendation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the HTTP cache is appropriate for your script, use it ‚Äî if not, cache it on the client with a clear understanding that these are some additional costs. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some simple client caching methods that you personally had to use.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything that can be calculated by a pure function can be cached with a set of arguments and used as a key to the calculated value. In Lodash there is a memoize () function, very convenient, I recommend it to everyone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next - there is an opportunity at the transport level. That is, you have some kind of library that makes REST requests and provides you with a data abstraction layer. There is an opportunity at its level to write a cache, in the background, add the data into memory or local storage, and next time you do not need to walk behind them if they are there.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I do not recommend doing this, because in my experience it turned out that we essentially duplicate the HTTP cache and write additional code ourselves, without any advantages - but having a lot of problems, bugs, incompatibility of cache versions, problems with disability and a lot of other charms . At the same time, such a cache, if it is transparent and is made at the transport level, it does not give anything relative to HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A self-made software cache that allows you to ask if it has data, allows you to disable something ‚Äî a good thing. It requires some effort in implementation, but allows you to do everything very flexibly.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the thing I highly recommend. This is an in-memory database - when your data is not just randomly scattered in the frontend application, but there is some kind of single storage that ensures you have only one copy of all the data and that allows you to write some simple queries. Also very convenient. It also works well as a caching strategy. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few words about how to invalidate the client cache.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, the usual TTL. Each record has a lifetime, time is over - the record is rotting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can raise web sockets and listen to server events. But we must remember that this web socket may fall off, and we will not know about it immediately.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally - you can listen to some interface things to listen to. </font><font style="vertical-align: inherit;">For example, if we paid for our mobile phone from a card in a web bank, probably, a cache in which the balance of this card is stored can be invalidated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such things also allow you to disable the client cache. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One thing to remember: all this is unreliable! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True data live only on the server! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not try to play master replication when developing front-end applications. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This produces a lot of problems. </font><font style="vertical-align: inherit;">Remember that the data on the server - and your life will become easier.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few simple things that did not fall into other points. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What hinders faster front-end in terms of API? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependence of requests, when we cannot send the next request without results from the previous one. That is, in the place where we could send three requests in parallel - we are forced to get the result from the first one, process it, from them we collect the url of the second request, send, process it, collect the url of the third request, send, process it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We got triple latency - where there could be a single. Out of the blue. Do not do this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data in any format other than JSON. Immediately I say that this applies only to the web - on mobile applications, everything can be more complicated. There is no reason to use non-JSON data in the REST API on the web.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, some things when we break the HTTP caching semantics. </font><font style="vertical-align: inherit;">For example, we have the same resource has several different addresses in different sessions, so caching does not work for us. </font><font style="vertical-align: inherit;">If this is not all, then we do not have a number of simple problems and can spend more time to make our application better.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's summarize </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to make an API good?</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good API is designed by all teams using and developing it. </font><font style="vertical-align: inherit;">Given their common interests.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We first measure the speed of the application, and then is engaged in optimization. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We allow to do through the API not only expensive - abstract requests, but also cheap concrete ones. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We design the data structure of the API based on the structure of the UI so that there is enough data, but not much unnecessary. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We correctly use caches and we do not make some simple mistakes, which I told about. </font></font></li></ul><br>  That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ask questions? </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/U-nFJEPW8wE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/323010/">https://habr.com/ru/post/323010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322998/index.html">Free ASP.NET Core Training Courses at the Microsoft Virtual Academy</a></li>
<li><a href="../323002/index.html">Five reasons why you have to learn English</a></li>
<li><a href="../323004/index.html">Preview RamblerElixir # 2</a></li>
<li><a href="../323006/index.html">A simple way to create an IoT application for monitoring remote servers on the IBM Bluemix platform</a></li>
<li><a href="../323008/index.html">How to use maven to work with libraries that are not in maven</a></li>
<li><a href="../323012/index.html">Meet Kotlin 1.1: javascript, cortina and more</a></li>
<li><a href="../323014/index.html">Installation and use of the virtual network lab EVE-NG with Ansible. First experience</a></li>
<li><a href="../323016/index.html">Multi-generation Intel processor performance comparison</a></li>
<li><a href="../323018/index.html">Objectives for sharing knowledge in an IT company</a></li>
<li><a href="../323020/index.html">Trends and prospects for the mobile application market: let's talk about money</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>