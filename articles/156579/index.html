<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We collect and make run the budget hexapod</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a lot to be done before we get to this picture: 



 Dropping rozkazni about how exactly I came up with the idea to build a hexapod (these we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We collect and make run the budget hexapod</h1><div class="post__text post__text-html js-mediator-article"> There is a lot to be done before we get to this picture: <br><br><img src="https://habrastorage.org/storage2/55e/f85/f65/55ef85f6531451eaefd7bf6beec21ace.jpg"><br><br>  Dropping rozkazni about how exactly I came up with the idea to build a hexapod (these were tons of videos on YouTube), I‚Äôll go straight to the process of selecting items.  It was January 2012.  I immediately knew what I want from my robot, and what I do not.  I wanted: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - each leg should have 3 degrees of freedom - 3dof (3 dimensions of freedom).  Because the simpler version of 2dof - does not give such an insect sensation, and 4dof - unnecessarily, 3dof allows you to freely move the tip of the foot in 3D space; <br>  - 6 legs;  again, this is no longer 4 (then the robot clumsily jumps), but also not 8, like spiders and already excessively; <br>  - small; <br>  - cheap; <br>  - minimum boards and connections; <br><br>  Post big. <br><a name="habracut"></a><br>  The first of course was to choose a motherboard for the crumbs.  A lot of good and bad had time to read about Arduino by then.  But it was him who looked like the main option.  It‚Äôs time to solder controllers yourself, but to take more advanced boards with ARM cpu, for example, it‚Äôs expensive, and to figure out how to program them, how to work with PWM outputs, etc.  And arduin: IDE launched, code hit, upload clicked - and hello, it is already blinking.  Beauty!  ;) <br><br>  At first I began to look at arduino mega and clones, because  number of PWM outputs, which can be serviced by the servos they had plenty.  Let me remind you that for 3dof hexapod you need 3 * 6 = 18 servov, and separate control channels.  But then I found the real Yazh among the arduino mega, this is a board from Dagu, called Red Back Spider Controller.  <a href="http://www.ebay.com/itm/Dagu-48Servo-Red-Back-Spider-Controller-Arduino-Mega-/140813195925%3Fpt%3DUK_Computing_Other_Computing_Networking%26hash%3Ditem20c91eda95">Here it is on ebay.</a> <br><br>  It offers all of its outputs in the form of ready-made 3 pins (ground, power, signal), and power distribution.  The power of the controller itself is stabilized, and it goes to the dviglov connectors as is (UPD: not as it is, but also stabilized 5 volts. And apparently untied with the power supply of the controller, since they do not interfere with the operation of the controller 18 at the same time).  This allows you to simply apply 7-30 volts of sufficient power to the power terminal (the feeder from the eee pc 901 for 12V and 3A turned out to be sufficient for buzzing with all 18 servami) and not fooling around with separate power supply of logic and dviglov.  Also, this will allow in the future to easily put all this monster on a pack of Li-Po batteries at 7.4 volts.  And with all this, from a software point of view, this is the usual arduino mega, compatible with software and libs, and even with hardware (except for shilds that are installed directly on the original mega - they will not roll).  True, the price is even higher than the original mega, but all the other advantages outweighed it. <br><br>  Next servos.  On ebay, on request, micro servo has many different ones.  I took the most powerful of the smallest and cheapest, weighing 9 grams, with plastic gearboxes.  If you take the lots where they are sent in bundles - it turns out cheaper.  I took 3 packs of 6, it seems, and less than $ 2 came out.  Looking ahead, I would say that I regret that I did not spend more and did not take servos with metal gears and ball bearings.  These plastic ones had quite noticeable backlashes, and a characteristic crunch with excessive force when the gears slip.  Because of the backlash - kinematics is quite difficult to adjust accurately (yes it turned out to be the hardest). <br><br>  That's actually all that I ordered, with the delivery it came out about $ 100.  Batteries and transmitters / receivers for control and radio control - left for later.  Because I have a radio-controlled machine and it is not interesting, and what really interested me is legs!  The video of smoothly walking hexapods on YouTube was <a href="http://www.youtube.com/watch%3Fv%3DGDaNkff5Yyg">fascinating</a> , I watched it, revised it, and each time tears rolled down my cheeks, and I choked out a ‚ÄúI want!‚Äù Wheezing.  I do not want to order such a finished piece, but I want to do something myself! <br><br>  While waiting for the order, I read how educated people enliven their creations.  Of course, <a href="http://freespace.virgin.net/hugo.elias/models/m_ik.htm">inverse kinematics</a> immediately surfaced ( <a href="http://www.gamedev.ru/code/articles/%3Fid%3D4182">translation</a> ).  If we say simply and immediately about the spherical "limbs", then the direct kinematics is when the angles of the hinges are fed to the input, and at the output we have a model of finiteness in space, and the coordinates of the extreme point of the limb.  Inverse kinematics - obviously works the other way around - the coordinates of the extreme point of the limb arrive at the entrance, where we need to reach, and at the exit we get the angles that need to be rotated to make this possible.  Servos just get to the entrance of the angular position in which they need to turn (one signal wire, encoded <a href="http://arduino.ru/Tutorial/PWM">PWM / PWM</a> ). <br><br>  Started writing.  I started with what I read about: think over the implementation of IC using the method described <a href="http://freespace.virgin.net/hugo.elias/models/m_ik.htm">there</a> .  But it quickly came to the feeling that for my case it was overly complex.  Moreover, it is both cumbersome to implement and computationally very complicated - the calculation is iterative.  And I have 6 legs, for each of which you need to consider IR, and only 16 MHz is not the smartest AVR architecture.  But only 3 degrees of freedom.  And it is easy to guess that it is possible to reach an arbitrary point in the ‚Äúreach area‚Äù only in one way.  The decision is already ripe in the head. <br><br>  But here came February and the parcel - one from China, the other from UK.  First of all, of course, I just played around with the Arduino board - I blinked the LED and populated the speaker connected to it.  Then he started selling the actual IC, already in the gland.  For which he built a prototype of the legs from the materials at hand (rather soft plastic, which is easy to cut with scissors, screws and nozzles are all from servo sets).  Terminator fixed this leg directly to the Arduin board.  You can consider how the budget made articulations. <br><br><img src="https://habrastorage.org/storage2/998/d95/ec7/998d95ec7ae7a5029ffbb27338748e64.jpg"><br><br><img src="https://habrastorage.org/storage2/3fb/a57/498/3fba57498471cb5cb036fb055471f899.jpg"><br><br>  I admired this case and dreamed that if I based on this robot in the future, solder a terminator who will declare war on humanity, then John Connor and Schwarzenegger will return to me here in the past and will select this prototype and melt it in Orodruin.  But nobody returned, didn‚Äôt take anything away, and I calmly continued. <br><br>  It turned out that IC does not need to be afraid at all, in my case it all boiled down to banal geometry-trigonometry.  To make it easier to turn to the joints, turned to Wikipedia and read about insects.  They have special names for limb elements: <br><br><img src="https://habrastorage.org/storage2/eaf/4d3/c21/eaf4d3c2148efb1f8ed4f7468b31b0b2.jpg"><br><br>  The Russian also has its own and very interesting names for this, but ‚Äúwash‚Äù, ‚Äúswivel‚Äù, ‚Äúshin‚Äù, etc., being in the code, would not let me fall asleep.  Therefore, I left the names Coxa, Femur, Tibia to 3 limbs and corresponding servas.  From the prototype of the legs above it is clear that I don‚Äôt even have a separate part for coxa.  These are just two servos held together with rubber bands.  Femur - implemented with a strip of plastic, to which servo arms are attached to both sides.  Thus, the last remaining servodvik is the beginning of tibia, for which an additional piece of plastic is bolted to it. <br><br>  Launched the editor, without thinking, created the file Leg.h, and in it the class Leg.  Well, a bunch of auxiliary dregs.) Let there be a point A (ax, ay, az) in space to which you need to reach.  Then the top view looks like this: <br><br><img src="https://habrastorage.org/storage2/809/ece/576/809ece576c98ea5387b9e180c564742e.png"><br><br>  In the figure, I immediately showed a method for calculating the first angle ‚Äî this is the angle of rotation of the servo that controls Coxa, which rotates the entire limb in the horizontal plane.  On the diagram, red immediately indicates the variables used in the code (not all).  Not very mathematically, but convenient.  It can be seen that the angle of interest is elementary.  First, primaryCoxaAngle is simply the angle (0; A) to the X axis (which is equivalent to the angle of point A in polar coordinates).  But the diagram shows that in this case the leg itself is not located at this angle.  The reason is that the axis of rotation coxa is not on the ‚Äúfoot line‚Äù - I don‚Äôt know how to say it correctly.  It is not in the plane in which the other 2 joints rotate and the tip of the foot is located, here.  This can be easily compensated by considering additionalCoxaAngle (how to count it - I don‚Äôt even bother to stop, well, after all, they were still at school, right?). <br><br>  So, we have the first piece of code, it's the insides of the reach (Point &amp; dest) method: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hDist = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( sqr(dest.x - _cStart.x) + sqr(dest.y - _cStart.y) ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> additionalCoxaAngle = hDist == <span class="hljs-number"><span class="hljs-number">0.0</span></span> ? DONT_MOVE : <span class="hljs-built_in"><span class="hljs-built_in">asin</span></span>( _cFemurOffset / hDist ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> primaryCoxaAngle = polarAngle(dest.x - _cStart.x, dest.y - _cStart.y, _thirdQuarterFix); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cAngle = hDist == <span class="hljs-number"><span class="hljs-number">0.0</span></span> ? DONT_MOVE : primaryCoxaAngle - additionalCoxaAngle - _cStartAngle;</code> </pre> <br><br>  Here dest is the point where you need to go, _cStart is the coordinates of the anchor point (and center of rotation) coxa, in hDist we consider the distance from _cStart to dest in the horizontal plane.  DONT_MOVE is just a flag, meaning that coxa does not need to be rotated anywhere, but left in its current position (since dest is somewhere right on the axis of rotation coxa is rare, but it happens).  Here cAngle is the angle by which the servo will need to deviate from its starting angle (which is in the middle of its operating range).  It can be seen that _cStartAngle is also used - this is the angle in the space that the servo is rotated devalt for during installation.  About _thirdQuarterFix I will tell later if I will not forget. <br><br>  Then everything becomes even easier.  We just need to look at the ‚Äúleg line‚Äù plane mentioned above: <br><br><img src="https://habrastorage.org/storage2/7d6/d6d/c6c/7d6d6dc6c8937a451b9e84c3777435b0.png"><br><br>  At the same time, the task is suddenly reduced to finding the intersection point of 2 circles.  One is at the point where our femur is ‚Äúgrowing‚Äù, the second is the point where we need to reach (with already local 2d coordinates).  The radii of the circles are the lengths of femur and tibia, respectively.  If the circles intersect, then a joint can be positioned in one of the 2 points.  We always choose the top so that the ‚Äúknees‚Äù of the monster are arched upwards, not downwards.  If you do not intersect, then we will not reach the target point.  A little more code, the transition to the plane is done elementarily, only a couple of pitfalls are still taken into account and documented in the commentary so that I do not break my head afterwards, disassembling the code.  For simplicity, in this local coordinate ‚Äúplane of the leg‚Äù I chose the point where the femur grows: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Moving to local Coxa-Femur-target coordinate system // Note the case when hDist &lt;= _cFemurOffset. This is for the blind zone. // We never can't reach the point that is nearer to the _cStart then // femur offset (_fStartFarOffset) float localDestX = hDist &lt;= _cFemurOffset ? - _fStartFarOffset : sqrt(sqr(hDist) - sqr(_cFemurOffset)) - _fStartFarOffset; float localDestY = dest.z - _fStartZOffset; // Check reachability float localDistSqr = sqr(localDestX) + sqr(localDestY); if (localDistSqr &gt; sqr(_fLength + _tLenght)) { log("Can't reach!"); return false; }</span></span></code> </pre><br><br>  Now localDestX and localDestY are the coordinates of the target point.  All that remains is to find the intersection point of the circles with the centers at (0,0) and (localDestX, localDestY), and the radii _fLength and _tLength (respectively, the length of femur and the length of tibia).  The schoolchild will cope with this too, but here I made quite a few mistakes, so to check myself and in general, anyone could check what kind of dumb formulas I had, I left links to sources where this elementary geometric problem is cleared and cleared: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Find joint as circle intersect ( equations from http://e-maxx.ru/algo/circles_intersection &amp; http://e-maxx.ru/algo/circle_line_intersection ) float A = -2 * localDestX; float B = -2 * localDestY; float C = sqr(localDestX) + sqr(localDestY) + sqr(_fLength) - sqr(_tLenght); float X0 = -A * C / (sqr(A) + sqr(B)); float Y0 = -B * C / (sqr(A) + sqr(B)); float D = sqrt( sqr(_fLength) - (sqr(C) / (sqr(A) + sqr(B))) ); float mult = sqrt ( sqr(D) / (sqr(A) + sqr(B))); float ax, ay, bx, by; ax = X0 + B * mult; bx = X0 - B * mult; ay = Y0 - A * mult; by = Y0 + A * mult; // Select solution on top as joint float jointLocalX = (ax &gt; bx) ? ax : bx; float jointLocalY = (ax &gt; bx) ? ay : by;</span></span></code> </pre><br><br>  Everything, there is still a little bit - from the coordinates obtained, calculate the proper angles for the femur and tibia servs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> primaryFemurAngle = polarAngle(jointLocalX, jointLocalY, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fAngle = primaryFemurAngle - _fStartAngle; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> primaryTibiaAngle = polarAngle(localDestX - jointLocalX, localDestY - jointLocalY, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tAngle = (primaryTibiaAngle - fAngle) - _tStartAngle;</code> </pre><br><br>  Again elementary - angular coordinates and all.  I hope the naming of the variables should already be clear, for example, _fStartAngle is the femur start angle, the angle to which the femur is defaulted.  And the last line of the reach () method (he said let's go and waved his hand): <br><br><pre> <code class="cpp hljs">move(cAngle, fAngle, tAngle);</code> </pre><br><br>  The move method directly gives commands to the servas.  In fact, it still had to add all sorts of things in it to protect against bad angles (at which the servo cannot turn, but will try), as well as for other legs that are radically located and / or directed to other sides.  But in the meantime, we are working with only one paw. <br>  These pieces are the final code, which is far from perfect, and surely it can be significantly improved.  But it works!  Without ever going beyond the school course of geometry-trigonometry, we implemented a fully functional inverse kinematics for 3dof legs!  Yes, and we get the solution immediately for one iteration.  For this to work, the foot needed to be carefully measured, and the class configured with the data obtained.  including angular, which is the most difficult to measure on the finished product.  Maybe if designing in an autocade and making beautiful renders would be easier with measuring angles, but I had neither the time nor the desire to engage in this pathos. <br><br>  February has just begun, and the video with the foot was already ready.  To check the IR, I forced the foot to describe all sorts of figures in space (for this it was necessary to consistently call reach, bypassing points on a rectangle, or a circle, the code is dull and dull, therefore I do not quote (and having finished the experiments with a circle around the primitives, I cut it out) ): <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/8dowIFg5mzc%3Ffeature%3Doembed&amp;xid=17259,1500003,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhhVnwi1FkolCepS5K60gI3B3rQqzg" frameborder="0" allowfullscreen=""></iframe><br><br>  Then it was necessary to finish playing with this hand-made article, on one foot you could not jump far (although such a robot would come out really interesting).  But I need a hexapod.  Went to the nearest flea market to look for plexiglass.  I found 2 excellent pieces - one 3 mm thick (just for the body, I thought), another 2 mm and blue (excellent limbs, in tone with servo drives).  After another couple of weeks, I carved out an evening to make something out of it.  Made sketches on paper.  tried on - like everything is OK, then it's up to the hacksaw. <br><br><img src="https://habrastorage.org/storage2/9ad/929/f25/9ad929f25c03bd4f84ba4ae5c8895520.jpg"><br><br><img src="https://habrastorage.org/storage2/e01/7f2/12a/e017f212a24a60c8568191fc0fb32d59.jpg"><br><br><img src="https://habrastorage.org/storage2/00f/a01/6e5/00fa016e5c724072ef243ad03af93464.jpg"><br><br><img src="https://habrastorage.org/storage2/215/36a/221/21536a221dd6af8063e0d49a5f4188be.jpg"><br><br><img src="https://habrastorage.org/storage2/400/d58/f5c/400d58f5cb134928c9126d4ee808c0a6.jpg"><br><br><img src="https://habrastorage.org/storage2/44a/5d9/909/44a5d990915efa1ec387a3325ab4348d.jpg"><br><br><img src="https://habrastorage.org/storage2/7f7/5c7/e73/7f75c7e7375de2d53c416ccefe26abdf.jpg"><br><br><img src="https://habrastorage.org/storage2/db3/040/504/db3040504f2a073e5a4e324087cd4f48.jpg"><br><br><img src="https://habrastorage.org/storage2/9d3/2a4/df6/9d32a4df62d2e19b6852d31fc5073585.jpg"><br><br><img src="https://habrastorage.org/storage2/cdd/5b1/53f/cdd5b153f0a7b1916a0c70cc242b4849.jpg"><br><br>  And here it is, a monster overseas, sheshilapoe.  When I tested one leg, I fed this business with some kind of left-side feeder from an external screw.  Enough.  But to feed 6 legs from him was already scary.  So I hung up my hands for a while, thinking that I still needed to get a suitable feeder.  But it turned out to be much simpler, I already mentioned above - the eee pc 901 feeder came up. Well and good. <br><br>  Debugging the work of 6 legs was even more difficult than writing the engine of one foot.  Half of the legs were mirrored relative to the other.  In addition, all are directed in different directions.  In general, I configured and configured everything for a very long time, and it didn‚Äôt really inspire me, because  there were no convenient debugging tools, the most I could count on was logging to Serial.  And that one worked normally from the main * .ino file, and from the connected Leg.h - the necessary object was no longer seen.  Turn up the crutches for the log (facepalm).  In time, I will refactor.  And then spring came, the cycle season was open in full force, and I threw my six-pet pet in the closet.  So it was all summer and the warm part of autumn. <br><br>  But it started to rain, it became cold, and the hexapod was removed.  His legs were debugged, including the very _thirdQuarterFix was introduced for the polarAngle calculation function.  The problem was that 2 legs (left middle and left back) moved so that most of the time were in the third quarter: <br><br><img src="https://habrastorage.org/storage2/3a6/5ed/50c/3a65ed50cef8c8c3b1cba76bde9ea8ba.gif"><br><br>  And polarAngle was naive for me - it returned angles from pi to pi, relative to the X axis. And if sometimes one of these 2 legs needed to turn in the 2nd quarter, then the polarAngle value jumped from pi to pi what actually negatively influenced the further calculation.  Fixed a crutch - for these 2 legs the polarAngle is considered "different."  I‚Äôm ashamed, I‚Äôm ashamed of the code, but the whole project is proof of concept, the only purpose of which is just to understand, can I put together a realistic hexpod or not.  Because the code should work, and right now.  And then refactoring - re-factoring. <br><br>  Having coped with the 3rd quarter, I started pedaling the step patterns.  For this, I introduced the default point in the Leg class, i.e.  in which the leg is located when the robot is standing quietly and evenly.  This point can be tuned, the main thing is that all the legs are on the same z coordinate (so that the legs are actually physically on the same plane, Leg has the lowest level tuneRestAngles ()).  And within the same Z coordinates, they can be moved almost as desired.  Almost - because the range of motion is not infinite, and so as not to go beyond this range when walking - the default position of the legs tried to be placed somewhere closer to the center of this range. <br><br>  The code here in the text is no longer cited, it is too elementary, and at the end I will cite links to the full version of all sorts - at the same time I will learn to use github. <br><br>  The sequence of the step chose a simple one - 3 legs on the ground, 3 - are rearranged in the air.  Thus, the coordinates of the legs relative to their default position can be divided into 2 groups.  For these two groups, I turned the step in the loop (see the walk () function in Buggy.ino).  As a result, each leg calculated its own individual coordinate, based on its default coordinates. <br><br>  And he went!  But so far only forward.  He put gum on his feet so that he did not slide on linoleum so much.  And rushed to shoot it on video to show friends. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/H7arGk8GDtA%3Ffeature%3Doembed&amp;xid=17259,1500003,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhg2K3B-lr6MmiqLDeQrhEsM0O5udQ" frameborder="0" allowfullscreen=""></iframe><br><br>  To a-poda, of course, far away.  But I haven‚Äôt finished yet.) I pidalced another evening - and added the ability to move in any direction (but not turning the body.)).  Plus, for smoothing between movements, added a function (smoothTo ()), which gently moves the legs (lifting up, again in 2 groups, one of which is always below, the creature stands on it while the other rises and moves) to a new position.  It is necessary that the creature does not jerk sharply with their feet, changing the direction of movement (oh, this feature is not enough for many game characters of the past years).  And he quickly ran in any direction - sideways, diagonally: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Mjfm94Jf5uo%3Ffeature%3Doembed&amp;xid=17259,1500003,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhhyLBNY5pbJWa7CBHDYGLB9hu-BDA" frameborder="0" allowfullscreen=""></iframe><br><br>  Both grand files of sorts can be viewed <a href="https://github.com/poconoco/buggybug/tree/20d2be0e75c462da5a1bd209cffff45559b22b80/Buggy">here</a> .  I give a link to a specific revision, at the time of this writing.  Since in the future everything can be very different. <br><br>  The results that so far can be highlighted: <br><br>  - to rivet the hexapod itself is a workable thing; <br>  - write him the kinematics himself from scratch - also quite capable of any (the developer); <br>  - the budget may be minimal, the only thing that really needs to be spent is the servos;  and so, if there is a soldering iron, then you can do with any microcontroller;  the more convenient, the more expensive, however; <br>  - it is better not to save on servah, but the cheapest ones work; <br>  - I have not experienced such a pleasure from programming since I was 9 when I first saw the zx spectrum computer circle and learned how to write the first programs for it;  it's so cool when your code doesn't just work somewhere and shows something to someone, but runs right in front of you and scares the cat. <br><br>  There are more advanced algorithms ahead for smooth body movement, and of course, wireless controls and batteries, of course. </div><p>Source: <a href="https://habr.com/ru/post/156579/">https://habr.com/ru/post/156579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../156565/index.html">Amazon Criticizes iPad mini on Home Page</a></li>
<li><a href="../156567/index.html">"Simple Business 2012." Customer Relationship Management. Practical conference in the format "developer-client" was held</a></li>
<li><a href="../156571/index.html">Code visualization</a></li>
<li><a href="../156573/index.html">As I wrote skad. Part four</a></li>
<li><a href="../156575/index.html">Course lectures "Startup". Peter Thiel. Stanford 2012. Session 4</a></li>
<li><a href="../156581/index.html">Check the balance of the phone in the console</a></li>
<li><a href="../156583/index.html">Nokia is no longer among the Top 5 smartphone manufacturers</a></li>
<li><a href="../156585/index.html">Multitouch technology</a></li>
<li><a href="../156587/index.html">EGPU assembly experience and its interaction with a laptop</a></li>
<li><a href="../156589/index.html">Download images in the background. JavaScript module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>