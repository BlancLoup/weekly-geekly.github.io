<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel SGX Extensions Tutorial. Part 7, revision of the enclave</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the seventh part of a series of educational materials on the Intel Software Guard Extensions (Intel SGX) extensions , we will return to work with t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel SGX Extensions Tutorial. Part 7, revision of the enclave</h1><div class="post__text post__text-html js-mediator-article">  In the seventh part of a series of educational materials on the <a href="https://software.intel.com/en-us/sgx">Intel Software Guard Extensions (Intel SGX) extensions</a> , we will return to work with the enclave and modify it a little to make it easier and more efficient.  We will look at how proxy functions transfer data between an unprotected memory area and an enclave, and also talk about one of the advanced features of the <a href="https://software.intel.com/sites/products/sgx-sdk-users-guide-windows/Content/Enclave%2520Definition%2520Language%2520File%2520Syntax.htm">Enclave Definition Language (EDL)</a> syntax. <br><br><img src="https://habrastorage.org/files/a54/601/490/a54601490ee945778f8a098729253275.jpg"><br><br>  Source code is provided with this part of the series.  In this part, we migrated the application to the Intel SGX SDK version 1.7, and also use Microsoft Visual Studio * Professional 2015 as the development environment. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Proxy functions</font> </h2><br>  When creating an enclave using the Intel SGX SDK, the interface to the enclave is specified in EDL.  The EDL indicates which functions are enclave calls (ECALL, enclave functions) and which are external calls (OCALL, calls directed from inside the enclave to untrusted functions). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When building a project, the Edger8r tool, included in the Intel SGX SDK, analyzes the EDL file and creates a sequence of proxy functions.  These proxy functions are wrappers around real functions defined in the EDL language.  Each call to ECALL and OCALL receives a pair of proxy functions: the trusted half and the untrusted half.  The trusted functions are placed in <i>EnclaveProject_t.h</i> and <i>EnclaveProjct_t.c</i> and added to the Autogenerated Files folder of the enclave project.  Untrusted functions are placed in <i>EnclaveProject_u.h</i> and <i>EnclaveProject_u.c</i> and added to the project's Autogenerated Files folder, which will interact with the enclave. <br><br>  Your program does not call ECALL and OCALL functions directly, it calls proxy functions.  If you need to call ECALL, you should call an untrusted proxy function for this ECALL, which, in turn, calls the trusted proxy function inside the enclave.  Then this proxy function calls the ‚Äúreal‚Äù ECALL function, and the returned value is passed to the untrusted function.  This sequence is shown in Fig.  1. If you want to call OCALL, the reverse sequence is used: you should call the trusted proxy function for OCALL, which calls the untrusted proxy function outside the enclave, which, in turn, calls the "real" OCALL function. <br><br><img src="https://habrastorage.org/files/e83/264/a62/e83264a62c3447f190c31fe5bc8821f5.png"><br>  <i>Figure 1. Proxy functions for ECALL</i> <br><br>  Proxy functions are responsible for performing the following actions. <br><ul><li>  Data transfer to and from the enclave </li><li>  Putting the return value of this ECALL or OCALL function in the address referenced by the pointer parameter </li><li>  Return the success or failure status of the ECALL or OCALL function itself as the value of <i>sgx_status_t</i> </li></ul><br>  It follows that each ECALL or OCALL may have two return values.  The first is the success of the call to the ECALL or OCALL function itself (that is, we were able to successfully enter or exit the enclave), the second is the return value of the function that is called inside ECALL or OCALL. <br>  The syntax of the functions ECALL <i>ve_lock ()</i> and <i>ve_unlock ()</i> in the EDL language in the enclave of our Tutorial Password Manager application is shown below: <br><br><pre><code class="cpp hljs">enclave { trusted { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_lock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_unlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([in, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span></span>; } }</code> </pre> <br>  But the prototypes of untrusted proxy functions created by the Edger8r tool. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">sgx_status_t</span></span> ve_lock(<span class="hljs-keyword"><span class="hljs-keyword">sgx_enclave_id_t</span></span> eid); <span class="hljs-keyword"><span class="hljs-keyword">sgx_status_t</span></span> ve_unlock(<span class="hljs-keyword"><span class="hljs-keyword">sgx_enclave_id_t</span></span> eid, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* retval, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* password);</code> </pre> <br>  Note that additional arguments have been added to the parameter list of each function, and functions now return the type <i>sgx_status_t</i> . <br><br>  Both proxy functions require an enclave identifier, which is transmitted with the first <i>eid</i> parameter.  The <i>ve_lock ()</i> function has no parameters and does not return a value, so no further changes are required.  The <i>ve_unlock ()</i> function, by contrast, uses parameters and returns a value.  The second argument of the proxy function is a pointer to the address where the value returned by the present function <i>ve_unlock ()</i> in the enclave will be stored.  In our case, an int is returned.  Then follows the parameter of the present function char * password. <br><br><h2>  <font color="#0071c5">Data transfer</font> </h2><br>  The untrusted part of the application does not have access to the memory of the enclave.  It cannot read and write data to these protected memory pages.  Because of this, certain difficulties arise when the parameters of functions include pointers.  Most of the problems are related to OCALL, since the memory allocated inside the enclave is not available for OCALL.  However, there may be difficulties with ECALL calls.  The memory of the enclave is allocated in the application's memory space; therefore, the memory pages of the enclave may be adjacent to unprotected memory pages.  If you pass into the enclave a pointer to an untrusted area of ‚Äã‚Äãmemory, and then do not perform proper checking of the boundaries in the enclave, you can inadvertently cross the enclave border while reading or writing to the memory in the ECALL function. <br><br>  To solve this problem, the Intel SGX SDK suggests copying the contents of the data buffers to and from enclaves, and the ECALL and OCALL functions should work with these copies of the original memory buffers.  When transmitting a pointer to an enclave, you must specify in the EDL language which direction the buffer to which the pointer refers is sent: to the call, from the call or in both directions;  then the buffer size is indicated.  The proxy functions created in the Edger8r program use this information to verify that the specified address range does not intersect with the enclave boundary;  copy the data to the enclave or from the enclave according to the indicated direction, and then replace the original pointer with a pointer to a copy of the buffer. <br><br>  This is a slow but safe approach to transferring data and pointers between unprotected memory and enclave memory.  However, this approach has certain disadvantages, due to which in some cases it becomes undesirable. <br><ul><li>  Low speed, as each memory buffer is checked and copied. </li><li>  To store copies of data buffers, additional heap space is required in the enclave. </li><li>  The EDL syntax is too complex. </li></ul><br>  In addition, there are cases where you only need to pass the raw pointer to ECALL and to OCALL without using it inside the enclave, for example, if you pass the pointer to the callback function directly to OCALL.  In this case, as such, there is no data buffer; there is only the address of the pointer itself, and the data transfer functions created in Edger8r will prevent them. <br><br><h2>  <font color="#0071c5">Solution: user_check</font> </h2><br>  The good news is that the EDL language supports the transfer of the pointer address to ECALL or to OCALL without checking the boundaries and without copying the data buffer.  If you specify the user_check parameter, the Edger8r program passes the pointer without any additional actions, based on the fact that the developer himself took care of checking the boundaries of the address.  By specifying <i>user_check</i> , you essentially increase performance by reducing some of the security. <br><br>  The pointer with the <i>user_check</i> parameter <i>has</i> no direction ( <i>in</i> or <i>out</i> ), because the buffer does not copy.  If you specify both <i>user_check</i> and <i>in</i> or <i>out</i> , an error will occur during compilation.  Also, the <i>count</i> and <i>size</i> parameters are not specified. <br><br>  In the Tutorial Password Manager application, the <i>user_check</i> parameter <i>is</i> best used in ECALL functions that load and store encrypted password stores.  Our <a href="https://habrahabr.ru/company/intel/blog/317510/">project limits</a> set the limit of the storage itself, but in general such mass read and write operations greatly benefit in speed if the enclave is allowed to work directly with untrusted memory. <br><br>  The original EDL syntax of ve_load_vault () and ve_get_vault () functions looks like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_load_vault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([in, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_get_vault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([out, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre> <br>  If to rewrite them, having specified <i>user_check</i> , the following will turn out. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_load_vault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([user_check] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_get_vault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([user_check] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><br>  Note that the len parameter is removed from <i>ve_load_vault ()</i> .  If we recall the <a href="https://habrahabr.ru/company/intel/blog/318628/">fourth part of</a> this series of articles, there was a problem with this function: despite the fact that the storage length was stored as a variable in the enclave, the proxy functions did not have access to it.  In order for ECALL's proxy functions to copy the incoming data buffer, we needed to specify the length in the EDL in order for the Edger8r program to receive information about the buffer size.  If you use the <i>user_check</i> parameter, then this problem disappears because there is no buffer copy operation.  The enclave can read data directly from untrusted memory and can use its own internal variable to determine how many bytes need to be read. <br><br>  At the same time, we still specify the length as a parameter to the <i>ve_get_vault ()</i> function.  This is a security check, its purpose is to avoid accidental buffer overflow when receiving encrypted storage from the enclave. <br><br><h2>  <font color="#0071c5">Let's sum up</font> </h2><br>  EDL has three options for passing pointers to ECALL or OCALL: <i>in</i> , <i>out,</i> and <i>user_check</i> .  They are described in table 1. <br><table><tbody><tr><th width="120">  Qualifier / Direction </th><th>  ECALL </th><th>  OCALL </th></tr><tr><td>  in </td><td>  The buffer is copied from the application to the enclave.  Changes will only affect the buffer inside the enclave. </td><td>  The buffer is copied from the enclave to the application.  Changes will only affect the buffer outside the enclave. </td></tr><tr><td>  out </td><td>  The buffer will be allocated inside the enclave and initialized with zero values.  It will be copied to the original buffer when the ECALL exits. </td><td>  The buffer will be allocated outside the enclave and initialized with zero values.  This untrusted buffer will be copied to the original buffer when the OCALL exits. </td></tr><tr><td>  in, out </td><td>  Data is copied back and forth. </td><td>  Data is copied back and forth. </td></tr><tr><td>  user_check </td><td>  The pointer is not checked.  The raw address is transmitted. </td><td>  The pointer is not checked.  The raw address is transmitted. </td></tr></tbody></table>  <i>Table 1. Pointer qualifiers and their values ‚Äã‚Äãin ECALL and OCALL.</i> <br><br>  If you use direction indicators, the data buffer referenced by the pointer will be copied, and you must also specify the size so that Edger8r can determine how many bytes are in the buffer.  If you specify <i>user_check</i> , then only the raw pointer is passed to ECALL or OCALL without any changes. <br><br><h2>  <font color="#0071c5">Code example</font> </h2><br>  <a href="https://software.intel.com/protected-download/676750/704116">The sample code</a> for this article has been updated: it is designed to be built with the Intel SGX SDK version 1.7 using Microsoft Visual Studio 2015. This code should work with the Intel SGX SDK version 1.6 and Visual Studio 2013, but we recommend updating the Intel SGX SDK to the latest version. <br><br><h2>  <font color="#0071c5">In further releases</font> </h2><br>  In the eighth part of this series, we will add support for power events.  Follow the news! </div><p>Source: <a href="https://habr.com/ru/post/324384/">https://habr.com/ru/post/324384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324374/index.html">CEPH for pumping</a></li>
<li><a href="../324376/index.html">Exceptions in Windows x64. How it works. Part 3</a></li>
<li><a href="../324378/index.html">We bring business to the international market in 5 minutes</a></li>
<li><a href="../324380/index.html">Hard Prioritization</a></li>
<li><a href="../324382/index.html">Fine Rust state machines</a></li>
<li><a href="../324388/index.html">React + mobx path from scratch. Mobx + react, side view</a></li>
<li><a href="../324394/index.html">Are commodity aggregators good?</a></li>
<li><a href="../324396/index.html">Check Point Security CheckUP - Free network security audit. Part 1</a></li>
<li><a href="../324398/index.html">Biometrics: the art of recognition. Perspectives of biometric systems on the example of the Id-Me platform from the company RecFaces</a></li>
<li><a href="../324400/index.html">NSUserDefaults in practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>