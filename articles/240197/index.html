<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to speed up the container: we tune OpenVZ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenVZ is an OpenSource implementation of container virtualization technology for the Linux kernel, which allows you to run on one system with the Ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to speed up the container: we tune OpenVZ</h1><div class="post__text post__text-html js-mediator-article"><img width="250" height="166" src="https://habrastorage.org/getpro/habr/post_images/97b/196/724/97b1967242cd6cd45756de9c5926f8dc.jpg" alt="image" align="left"><br>  OpenVZ is an OpenSource implementation of container virtualization technology for the Linux kernel, which allows you to run on one system with the OpenVZ core a lot of virtual environments with various Linux distributions inside.  Due to its features (container virtualization is at the kernel level, not iron) for a number of performance indicators - density, elasticity, requirements for RAM size, response speed, etc.  - It works better than other virtualization technologies.  For example, <a href="http://openvz.org/Performance">here</a> you can see OpenVZ performance comparisons with traditional hypervisor virtualization systems.  But besides this, there are a lot of tweaking options in Linux and OpenVZ. <br>  In this article, we will look at non-trivial options for configuring OpenVZ core containers that can improve the performance of the entire OpenVZ system. <br><a name="habracut"></a><br><h2>  <b>General settings</b> </h2><br><img width="200" height="50" src="https://habrastorage.org/files/b19/bd9/f71/b19bd9f71abf44179d6c625f1ae5e0a9.png" alt="image" align="left">  The main settings affecting the performance of containers are the limits on memory and processor consumption.  In most cases, increasing the amount of allocated memory and processors helps to improve the performance of containers for custom applications, such as, for example, your web server or database server. <br><br>  To set a global limit on the physical memory allocated to the container, it is enough to specify the option --ram, for example: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --ram 4G --save</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Very often, lowering the limits in a container results in a failure to allocate memory in one place or another in the kernel or application, so when using containers, it is extremely useful to monitor the contents of the / proc / user_beancounters file.  Nonzero values ‚Äã‚Äãin the failcnt column mean that some of the limits are too small and you need to either reduce the working set in the container (for example, reduce the number of apache threads or the postgresql server), or increase the memory limit using the --ram option.  For convenient monitoring of the / proc / user_beancounters file, you can use the vzubc utility, which allows you, for example, to watch only meters that are close to failcnt, or to update the readings with a periodicity (top-like mode).  Read more about the vzubc utility <a href="http://openvz.livejournal.com/42146.html">here</a> . <br><br>  In addition to setting a limit on physical memory, it is recommended to set a limit on the size of the swap for the container.  To adjust the size of the swap container, use the --swap option of the vzctl command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --ram 4G --swap 8G --save</span></span></code> </pre> <br><br>  The sum of the --ram and --swap values ‚Äã‚Äãis the maximum amount of memory the container can use.  After reaching the --ram container limit, the memory pages belonging to the container processes will be pushed into the so-called ‚Äúvirtual swap (VSwap)‚Äù.  At the same time, real disk I / O will not occur, and container performance will be artificially understated to create the effect of real swapping. <br><br>  When configuring containers, it is recommended that the sum of ram + swap for all containers does not exceed the sum of ram + swap per host node.  To check the settings, you can use the vzoversell utility. <br><br>  To control the maximum number of available processors for a container, you need to use the --cpus option, for example: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --cpus 4 --save</span></span></code> </pre> <br><br>  When creating a new container, the number of processors for this container is not limited, and it will use all possible CPU resources of the server.  Therefore, for systems with multiple containers, it makes sense to set a limit on the number of processors of each container in accordance with the tasks assigned to them.  It can also sometimes be useful to limit CPUs in percentages (or in megahertz) using the --cpulimit option, as well as manage weights, that is, container priorities, using the --cpuunits option. <br><br><h2>  <b>Memory overcommit</b> </h2><br>  The OpenVZ kernel allows you to allocate to all containers a total more memory than the full amount of physical memory available on the host.  This situation is called memory overcommit and in this case the kernel will manage the memory dynamically, balancing it between containers, because the memory allowed by the containers will not necessarily be in demand and the kernel can manage it at its discretion.  When overcommitting from memory, the kernel will effectively manage various caches (page cache, dentry cache) and try to reduce them in containers in proportion to the established memory limit.  For example, if you want to isolate from each other the services of some high-load web site consisting of a front-end, back-end and database for the sake of improving security, then you can put them in separate containers, but at the same time select the most accessible on the host amount of memory, for example: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --ram 128G --save # vzctl set 101 --ram 128G --save # vzctl set 102 --ram 128G --save</span></span></code> </pre> <br><br>  In this case, from the point of view of memory management, the situation will not differ from the one when your services were running on the same host and memory balancing will still be as efficient as possible.  You do not need to think about which of the containers you need to put more memory - in the front-end container for a larger page cache for static data of the web site, or in a container with a database for a larger cache of the database itself.  The kernel will balance everything automatically. <br><br>  Although overcommit allows the kernel to balance memory between containers as efficiently as possible, it also has certain unpleasant properties.  When the total amount of allocated anonymous memory, that is, the total working set for all processes of all containers approaches the total memory size in the host, when a process or kernel tries to allocate a new memory, a global exception ‚Äúout of memory‚Äù may occur and the OOM-killer will kill one of the processes in the system.  To check whether such exceptions happened on a host or in a container, you can use the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># dmesg | grep oom [3715841.990200] 645043 (postmaster) invoked oom-killer in ub 600 generation 0 gfp 0x2005a [3715842.557102] oom-killer in ub 600 generation 0 ends: task died</span></span></code> </pre> <br><br>  At the same time it is important to note that the OOM-killer will kill the process not necessarily in the same container in which it tried to allocate memory.  To control the behavior of OOM-killer, use the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --oomguarpages 2G --save</span></span></code> </pre> <br><br>  allowing to set a limit that guarantees the inviolability of container processes within a given limit.  Therefore, for containers in which vital services are running, you can set this limit equal to the memory limit. <br><br><h2>  <b>Processor overcommit</b> </h2><br>  Just as in the case of memory, the overcommit on processors allows you to allocate to containers a total number of processors exceeding the total number of logical processors on a host.  And just like in the case of memory, the overcommit on processors allows you to achieve the most effective overall system performance.  For example, in the case of the same web server, ‚Äúdecomposed‚Äù into three containers for the front end, back end and database, you can also set an unlimited number of CPUs for each container and achieve the maximum total system performance.  Again, the kernel itself will determine which processes from which containers to allocate processor time. <br><br>  Unlike memory, a processor is an ‚Äúelastic‚Äù resource, that is, a shortage of CPUs does not lead to any exceptions or errors in the system, except for slowing down some active processes.  Therefore, the use of overcommit on processors is a safer trick for overclocking a system than an overcommit from memory.  The only negative effect of overcommittee on processors is a possible violation of the principle of honesty allocation of processor time for containers, which can be bad, for example, for VPS hosting customers who may receive less paid processor time.  To preserve the fair allocation of processor time, it is necessary to set the ‚Äúweight‚Äù of containers, in accordance with the paid processor time, using the --cpuunits option of the vzctl command (read more <a href="https://openvz.org/Resource_shortage">here</a> ). <br><br><h2>  <b>Container optimization on NUMA hosts</b> </h2><br>  In the case of launching containers on a host with NUMA (Non-Uniform Memory Access), it is possible that container processes are executed on one NUMA node, and some (or all of the memory) of these processes have been allocated on another NUMA node.  In this case, each memory access will be slower than the memory access of the local NUMA node and the deceleration rate will depend on the distance between the nodes.  The Linux kernel will try to avoid such a situation, but to ensure that the container is executed on the local NUMA node, you can set up for each CPU mask container that will limit the set of processors that are allowed to execute container processes. <br><br>  You can view the NUMA nodes available on the host using the numactl command: <br><br><pre>  # numactl -H
 available: 2 nodes (0-1)
 node 0 cpus: 0 1 2 3
 node 0 size: 16351 MB
 node 0 free: 1444 MB
 node 1 cpus: 4 5 6 7
 node 1 size: 16384 MB
 node 1 free: 10602 MB
 node distances:
 node 0 1
   0: 10 21
   1: 21 10 </pre><br><br>  In this example, there are two NUMA nodes on the host, each with 4 processor cores and 16GB of memory. <br><br>  To set the limit on the set of processors for the container, use the vzctl command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vzctl set 100 --cpumask 0-3 --save # vzctl set 101 --cpumask 4-7 --save</span></span></code> </pre> <br><br>  In this example, we allowed container 100 to execute only on processors from 0 to 3, and container 101 - from 4 to 7. At the same time, you need to understand that if a process from, for example, container 100 has already allocated memory on a NUMA node 1 then every access to this memory will be slower than access to local memory.  Therefore, it is recommended to restart the containers after these commands are executed. <br><br>  It is worth noting that in the new release of vzctl 4.8, the option --nodemask appeared, which allows you to attach a container to a specific NUMA node without specifying the list of processors of this node, but by operating only with the NUMA number. <br><br>  It should be borne in mind that this approach will limit the ability of the process scheduler to balance the load between the processors of the system, which in the case of a large overcommit on the processors can lead to slower work. <br><br><h2>  <b>Controlling the behavior of fsync in containers</b> </h2><br>  As you know, to ensure that the data is written to disk, the application must execute the fsync () system call on each modified file.  This system call will write the file data from the write-back cache to the disk and initiate a flush of the data from the disk cache to permanent non-volatile media.  At the same time, even if the application writes data to the disk, bypassing the write-back cache (the so-called Direct I / O), this system call is still necessary to ensure that the data from the disk‚Äôs cache is reset. <br><br>  Frequent execution of the fsync () system call can significantly slow down the operation of the disk subsystem.  The average hard disk is capable of 30-50 syncs / sec. <br><br>  It is often known that for all or part of the containers such strict guarantees of data recording are not needed, and the loss of a part of data in the event of a hardware failure is not critical.  For such cases, the OpenVZ kernel provides the ability to ignore fsync () / fdatasync () / sync () requests for all or part of containers.  You can configure the behavior of the kernel using the / proc / sys / fs / fsync-enable file.  Possible values ‚Äã‚Äãof this file in case of setting to host node (global settings): <br><br><pre>   0 (FSYNC_NEVER) fsync () / fdatasync () / sync () requests from containers are ignored
   1 (FSYNC_ALWAYS) fsync () / fdatasync () / sync () requests from containers work as usual, 
                         data of all inodes on all file systems of the host machine will be recorded
   2 (FSYNC_FILTERED) fsync () / fdatasync () requests from containers work as usual
                         sync () requests from containers affect only container files (default value)
</pre><br><br>  Possible values ‚Äã‚Äãof this file in case of setting inside a specific container: <br><br><pre>   0 fsync () / fdatasync () / sync () requests from this container are ignored 
   2 use global settings set to host node (default value)
</pre><br><br>  Despite the fact that these settings can significantly speed up the server disk subsystem, you need to use them carefully and selectively, because  disabling fsync () may result in data loss in the event of a hardware failure. <br><br><h2>  <b>Controlling Direct I / O Behavior in Containers</b> </h2><br>  By default, writing to all files opened without the O_DIRECT flag is done via the write-back cache.  This not only reduces the latency (timeout) of writing data to disk for the application (the write () system call completes as soon as the data is copied to the write-back cache, not waiting for the actual writing to disk), but also allows the core I / O scheduler more efficiently allocate disk resources between processes, grouping I / O requests from applications. <br><br>  At the same time, certain categories of applications, for example, databases, effectively manage the recording of their data themselves, performing large sequential I / O requests.  Therefore, such applications often open files with the O_DIRECT flag, which tells the kernel to write data to such a file, bypassing the write-back cache, directly from the memory of the user application.  In the case of one database running on a host, this approach is more efficient than writing through the cache, since I / O requests from the database are already optimally aligned and there is no need for additional copying of memory from the user application to the write-back cache. <br><br>  In the case of multiple containers with databases on the same host, this assumption is wrong, since the I / O scheduler in the Linux kernel cannot optimally allocate disk resources between applications using Direct I / O.  Therefore, the default OpenVZ Direct I / O for containers is turned off, and all data is written via the write-back cache.  This introduces a small overhead in the form of additional copying of memory from the user application to the write-back cache, while allowing the kernel I / O scheduler to more efficiently allocate disk resources. <br><br>  If you know in advance that there will be no such situation on the host, you can avoid additional overhead and allow Direct I / O to be used by all or part of the containers.  You can configure the kernel behavior using the / proc / sys / fs / odirect_enable file.  Possible values ‚Äã‚Äãof this file in case of setting to host node (global settings): <br><br><pre>   0 flag O_DIRECT is ignored for containers, the whole record occurs via write-back cache (default value)
   1 flag O_DIRECT in containers works as usual
</pre><br><br>  Possible values ‚Äã‚Äãof this file in case of setting inside a specific container: <br><br><pre>   0 the O_DIRECT flag is ignored for this container, the entire record occurs via the write-back cache
   1 O_DIRECT flag for this container works as usual
   2 use global settings (default)
</pre><br><br><h2>  <b>Conclusion</b> </h2><br>  In general, the Linux kernel in general, and OpenVZ in particular, provide a large number of features for fine-tuning performance for specific user tasks.  OpenVZ-based virtualization allows for the highest possible performance through flexible resource management and various settings.  In this article, we have resulted in only a small part of container-specific settings.  In particular, I didn‚Äôt write about the three parameters CPUUNITS / CPULIMIT / CPUS and how all three influence each other.  But I am ready to explain this and much more in the comments. <br>  For more information, read the vzctl man page and a lot of resources on the Internet, for example, openvz.livejournal.com. </div><p>Source: <a href="https://habr.com/ru/post/240197/">https://habr.com/ru/post/240197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240183/index.html">Small Hello World for a small microcontroller - at 24 bytes (and someone else's decision at 12 bytes)</a></li>
<li><a href="../240185/index.html">Empowering Tween Animations in NGUI</a></li>
<li><a href="../240187/index.html">Official Symfony Best Practices Guide</a></li>
<li><a href="../240193/index.html">Where to find an incentive, or how we went to the Microsoft hackathon</a></li>
<li><a href="../240195/index.html">Geek competition: how we did it (part 1)</a></li>
<li><a href="../240199/index.html">Opera Developer Bookmark Sync</a></li>
<li><a href="../240201/index.html">New Wi-Fi for the Internet of Things (Part 1)</a></li>
<li><a href="../240203/index.html">Substitution Benefit Criterion and Dynamic Profiling</a></li>
<li><a href="../240207/index.html">Print outsourcing: how to save on printing with active paper workflow</a></li>
<li><a href="../240209/index.html">Latent semantic analysis: implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>