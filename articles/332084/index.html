<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with heterogeneous containers with C ++ 17</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Recently, a lot has been said about C ++ 17, especially with the advent of the national standardization working group in Russia. In the open...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with heterogeneous containers with C ++ 17</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  Recently, a lot has been said about C ++ 17, especially with the advent of the national standardization working group in Russia.  In the open spaces of the network, without any problems, you can find short examples of using the latest C ++ standard.  Everything is good, but there is no really extensive transition to new standards.  Therefore, we can observe a picture in which any library requiring a minimum of 14 standards is already considered modern after the fact. <br><br>  In this publication, we will develop a small library (3 functions ( <b>apply</b> , <b>filter</b> , <b>reduce</b> ) and one as ‚Äúhomework‚Äù ( <b>map</b> :))) for convenient work with heterogeneous containers in runtime (heterogeneity due to std :: variant of 17 standard). <br><br>  From the new, in addition to the new library types, let's taste the <i>fold expressions</i> and quite a bit of <i>structured binding</i> <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  First, a small introduction to the topic of heterogeneous containers.  As you know, there are no real heterogeneous containers working in runtime on c ++.  We have <b>std :: tuple</b> at our disposal, the traces of which almost completely disappear in runtime (not pay for what you don't use) and ... well, everything.  Everything else is just the building blocks for building your own library <s>bikes</s> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The building blocks, allowing to make a heterogeneous container, two are <b>std :: any</b> and <b>std :: variant</b> .  The first does not remember the type, so its use is very limited.  <b>std :: variant</b> remembers the type and is able to match functors to the current type using <b>std :: visit</b> (implemented by <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%252B%252B-v3/include/std/variant">generating a table of methods</a> and subsequent transitions on it).  The implementation is truly magical, and magic is the only thing that will help to do what is impossible at first glance :) (of course it is possible, because <s>everything is possible</s> with c ++).  Inside the <b>std :: variant</b> contains not so much overhead, transferring the boost version to the standard, the developers took care of the performance (relative to what it was).  Summarizing, we take <b>std :: variant</b> as a container of types and base unit of a heterogeneous container. <br><br><h2>  Disclaimer </h2><br>  I warn in advance about the maximum compactness of the code.  It is not worthless to copy it without thinking, it was as much as possible lightweight for quick understanding.  There are no namespaces, link forwarding and whatnot. <br><br>  I also do not pretend to be unique, for sure there are similar good libraries :) <br><br><h2>  Start </h2><br>  For easier understanding and testing of functions let's take a simple example.  To do this, we emulate the usual polymorphic structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Circle. "</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Radius: "</span></span> &lt;&lt; radius &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span> * radius * radius; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> radius; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Square. Side: "</span></span> &lt;&lt; side &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> side * side; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> side; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EquilateralTriangle</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EquilateralTriangle. Side: "</span></span> &lt;&lt; side &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span>) * (side * side); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> side; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Shape = variant&lt;Circle, Square, EquilateralTriangle&gt;;</code> </pre> <br>  Also for comparison we will keep in mind its simple polymorphic analogue: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Shape() {}; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> :</span></span> Shape { Circle(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) : radius(val) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Circle. "</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Radius: "</span></span> &lt;&lt; radius &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.14</span></span> * radius * radius; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> radius; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> Shape { Square(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) : side(val) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Square. Side: "</span></span> &lt;&lt; side &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> side * side; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> side; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EquilateralTriangle</span></span></span><span class="hljs-class"> :</span></span> Shape { EquilateralTriangle(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) : side(val) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EquilateralTriangle. Side: "</span></span> &lt;&lt; side &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span>) * (side * side); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> side; };</code> </pre><br>  Let's create a vector and try using standard means to achieve polymorphic behavior.  Let's iterate over the vector and call the <i>Print</i> function. <br><br>  First, let's take a dynamic analog (on virtual functions).  As you can think, we have no problems with dynamic polymorphism: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape*&gt; shapes; shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Square(<span class="hljs-number"><span class="hljs-number">8.2</span></span>)); shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle(<span class="hljs-number"><span class="hljs-number">3.1</span></span>)); shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Square(<span class="hljs-number"><span class="hljs-number">1.8</span></span>)); shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EquilateralTriangle(<span class="hljs-number"><span class="hljs-number">10.4</span></span>)); shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle(<span class="hljs-number"><span class="hljs-number">5.7</span></span>)); shapes.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Square(<span class="hljs-number"><span class="hljs-number">2.9</span></span>));</code> </pre><br>  However, it does not look very modern.  Bare new calls do not inspire confidence.  Rewrite: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt;&gt; shapes; shapes.emplace_back(make_shared&lt;Square&gt;(<span class="hljs-number"><span class="hljs-number">8.2</span></span>)); shapes.emplace_back(make_shared&lt;Circle&gt;(<span class="hljs-number"><span class="hljs-number">3.1</span></span>)); shapes.emplace_back(make_shared&lt;Square&gt;(<span class="hljs-number"><span class="hljs-number">1.8</span></span>)); shapes.emplace_back(make_shared&lt;EquilateralTriangle&gt;(<span class="hljs-number"><span class="hljs-number">10.4</span></span>)); shapes.emplace_back(make_shared&lt;Circle&gt;(<span class="hljs-number"><span class="hljs-number">5.7</span></span>)); shapes.emplace_back(make_shared&lt;Square&gt;(<span class="hljs-number"><span class="hljs-number">2.9</span></span>));</code> </pre><br>  Now it looks better.  However, for a beginner, the clarity in the code clearly did not increase.  But let's not breed holivar, let's fulfill our task: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape: shapes) { shape-&gt;Print(); } <span class="hljs-comment"><span class="hljs-comment">// : // Square. Side: 8.2 // Circle. Radius: 3.1 // Square. Side: 1.8 // EquilateralTriangle. Side: 10.4 // Circle. Radius: 5.7 // Square. Side: 2.9</span></span></code> </pre><br>  We will also try to implement similar behavior for a heterogeneous container: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; shapes; shapes.emplace_back(EquilateralTriangle { <span class="hljs-number"><span class="hljs-number">5.6</span></span> }); shapes.emplace_back(Square { <span class="hljs-number"><span class="hljs-number">8.2</span></span> }); shapes.emplace_back(Circle { <span class="hljs-number"><span class="hljs-number">3.1</span></span> }); shapes.emplace_back(Square { <span class="hljs-number"><span class="hljs-number">1.8</span></span> }); shapes.emplace_back(EquilateralTriangle { <span class="hljs-number"><span class="hljs-number">10.4</span></span> }); shapes.emplace_back(Circle { <span class="hljs-number"><span class="hljs-number">5.7</span></span> }); shapes.emplace_back(Square { <span class="hljs-number"><span class="hljs-number">2.9</span></span> });</code> </pre><br>  There are already no pointers.  No problem, you can work with objects on the stack.  Also, instead of a costructor, you can use <i>aggregate initialization</i> for as ‚Äúsimple‚Äù types. <br><br>  However, just to iterate and call the function will not succeed.  Let's try to do this with the tools provided by the std :: variant.  For this we have the function <b>std :: visit</b> , we also need to create a class of functors. <br><br>  Everything will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Circle&amp; c)</span></span></span><span class="hljs-function"> </span></span>{ c.Print(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Square&amp; c)</span></span></span><span class="hljs-function"> </span></span>{ c.Print(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EquilateralTriangle&amp; c)</span></span></span><span class="hljs-function"> </span></span>{ c.Print(); } }; ... ... ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Shape&amp; shape: shapes) { visit(Visitor{}, shape); }</code> </pre><br>  The conclusion is the same.  You can also emulate the same behavior with constexpr if.  Here is someone who likes more. <br><br>  Acquainted with the functionality that the standard library provides us with, we will try to simplify a bit the work with heterogeneous sequences. <br><br>  We implement the most frequent and comprehensive functions: <b>apply</b> , <b>filter</b> , <b>reduce</b> . <br><br><h2>  Step 1 </h2><br>  To begin with, simplify your task.  The first step is quite primitive - it has been described more than once. <br>  Take the variadic templates, the inheritance mechanism, and the knowledge that lambda functions are deployed into ordinary structures - functors.  We follow the set of freebies and create a function that will help us derive the template types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Func &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> :</span></span> Func... { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Func::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()...; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_visitor</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">...) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> &lt; Func... &gt;;</span></span></code> </pre><br>  Now, instead of creating classes with functors, we can use a set of lambdas that will match according to their signatures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Shape&amp; shape: shapes) { visit(make_visitor( [](Circle&amp; c) { c.Print(); }, [](Square&amp; c) { c.Print(); }, [](EquilateralTriangle&amp; c) { c.Print(); } ), shape); }</code> </pre><br>  We can also use type inference with a generic parameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Shape&amp; shape: shapes) { visit(make_visitor([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; c) { c.Print(); }), shape); }</code> </pre><br>  It turned out quite nice and fairly short. <br><br><h2>  Apply </h2><br>  It remains to put everything together and get the <b>apply</b> function for heterogeneous sequences: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputSentinelIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Callable &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIter beg, InputSentinelIter end, Callable... funcs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> _it = beg; _it != end; ++_it) visit(make_visitor(funcs...), *_it); };</code> </pre><br>  Is done.  The shown technique does not pretend to be new, any developer who somehow worked with boost :: variant has long implemented something similar for itself <a href="http://en.cppreference.com/w/cpp/utility/variant/visit">http://en.cppreference.com/w/cpp/utility/variant/visit</a> , <a href="https://habrahabr.ru/post/270689/">https: // habrahabr .ru / post / 270689 /</a> ). <br><br>  Now we can use the function like this: <br><br><pre> <code class="cpp hljs">apply(shapes.begin(), shapes.end(), [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; shape) { shape.Print(); });</code> </pre><br>  or <br><br><pre> <code class="cpp hljs">apply(shapes.begin(), shapes.end(), [] (Circle&amp; shape) { shape.Print(); }, [] (Square&amp; shape) { shape.Print(); }, [] (EquilateralTriangle&amp; shape) { shape.Print(); });</code> </pre><br>  As you can see, it turned out pretty nepokho.  However, if we pass the functors not for all types that are in the <b>std :: variant</b> , we get a compilation error.  To avoid this, in the likeness of <i>SFINAE, we</i> make a functor with elipsis, which will be called in the absence of any other alternative, and in the order of the call it will be the most recent version. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputSentinelIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Callable &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIter beg, InputSentinelIter end, Callable... funcs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> _it = beg; _it != end; ++_it) visit(make_visitor(funcs..., [](...){}), *_it); };</code> </pre><br>  Now we can pass the functors not for all types, for the absent, the empty lambda will be called: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      Circle apply(shapes.begin(), shapes.end(), [] (Circle&amp; shape) { shape.Print(); });</span></span></code> </pre><br>  For a good example, just show you how to do this using dynamic polymorphism: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      Circle for_each(shapes.begin(), shapes.end(), [] (shared_ptr&lt;Shape&gt; shape) { if (dynamic_pointer_cast&lt;Circle&gt;(shape)) shape-&gt;Print(); });</span></span></code> </pre><br>  Far from the most pleasant view. <br><br><h2>  Filter </h2><br>  By analogy, we will make the <b>filter</b> function.  Sense loading practically does not differ except that the lambda, having elipsis in the signature has to return value like bool.  We assume that if we have not passed a functor processing some particular type, then we do not want to see its instances in the filtered container. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputSentinelIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Callable &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIter beg, InputSentinelIter end, OutputIter out, Callable... funcs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> _it = beg; _it != end; ++_it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visit(make_visitor(funcs..., [] (...) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }), *_it)) *out++ = *_it; } };</code> </pre><br>  You can use the implemented function as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; filtered; filter(shapes.begin(), shapes.end(), back_inserter(filtered), [] (Circle&amp; c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.radius &gt; <span class="hljs-number"><span class="hljs-number">4.</span></span>; }, [] (Square&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.side &lt; <span class="hljs-number"><span class="hljs-number">5.</span></span>; }); apply(filtered.begin(), filtered.end(), [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; shape) { shape.Print(); }); <span class="hljs-comment"><span class="hljs-comment">// : // Square. Side: 1.8 // Circle. Radius: 5.7 // Square. Side: 2.9</span></span></code> </pre><br>  Analogue implemented using dynamic polymorphism: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt;&gt; filtered; copy_if(shapes.begin(), shapes.end(), back_inserter(filtered), [] (<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> circle = dynamic_pointer_cast&lt;Circle&gt;(shape)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circle-&gt;radius &gt; <span class="hljs-number"><span class="hljs-number">4.</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> square = dynamic_pointer_cast&lt;Square&gt;(shape)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> square-&gt;side &lt; <span class="hljs-number"><span class="hljs-number">5.</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }); for_each(filtered.begin(), filtered.end(), [](<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape) { shape-&gt;Print(); }); <span class="hljs-comment"><span class="hljs-comment">// : // Square. Side: 1.8 // Circle. Radius: 5.7 // Square. Side: 2.9</span></span></code> </pre><br><h2>  Reduce </h2><br>  It remains to implement <b>reduce</b> (analog <b>std :: accumulate</b> ) and <b>map</b> (analog <b>std :: transform</b> ).  The implementation of these functions is somewhat more complicated than it was with the <b>apply</b> and <b>filter</b> .  To reduce, we use functors with two parameters (the value of the battery and the object itself).  In order to implement a similar behavior, you can partially apply the lambda functions in such a way that the functions of one argument remain for the <b>std :: variant</b> .  There is no beautiful solution for c ++ for partial application, a quick way is to capture the necessary context with the help of another lambda.  Considering that we are working not with one lambda, but with the <i>variadic pack</i> , the code swells up and starts to be poorly readable.  Processing of variadics using <i>fold expressions</i> saves us.  Veterans know what crutches they used to fold lists of types earlier. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputSentinelIter, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Callable &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reduce</span></span></span><span class="hljs-class"> &lt; InputIter, InputSentinelIter, AccType, false, Callable... &gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIter beg, InputSentinelIter end, AccType initial_acc, Callable... funcs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> _it = beg; _it != end; ++_it) { initial_acc = visit(utility::make_overloaded_from_tup( tup_funcs(initial_acc, funcs...), make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Callable)&gt;{}, [&amp;initial_acc] (...) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_acc; } ), *_it); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_acc; } };</code> </pre><br>  In order to do something similar, it was decided to use the good old tuple ( <b>std :: tuple</b> ).  Processing its elements is not too complicated, at any time you can write your own.  And so, I create a lambda tuple, which is transformed into a new tuple by wrapping each lambda into another with the capture of the value of the battery.  Benefit transformation of the tuple, using the new standard, is written relatively easily: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>... I &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuple_transform_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple&lt;Types...&gt; t, Func func, index_sequence&lt;I...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_tuple(func(get&lt;I&gt;(t)...)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuple_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple&lt;Types...&gt; t, Func f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple_transform_impl(t, f make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Types)&gt;{}); }</code> </pre><br>  In order to create a comprehensive lyabda, I need to know the type of the second argument of the incoming lambda.  With the help of helper'ov, found on the Internet, you can skip lambda to the structure, having a call operator and by the match to get the desired type. <br><br>  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Ret, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; A _sec_arg_hlpr(Ret (Func::*)(_, A, Rest...)); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_argument = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(_sec_arg_hlpr(&amp;Func::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AccType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Callable &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tup_funcs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AccType initial_acc, Callable... funcs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple_transform(tuple&lt;Callable...&gt;{ funcs... }, [&amp;initial_acc](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [&amp;initial_acc, &amp;func] (second_argument&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(func)&gt; arg) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(initial_acc, arg); }; }); }</code> </pre><br>  Everything is good, but these wonders do not work with generic functions, the types of input arguments of which we cannot get by definition.  Therefore, using <i>tag dispatching</i> and creating a simple treit to test the function, we create our own implementation for this case. <br>  Summarizing, we obtain for <b>reduce the</b> following possibilities for use: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ShapeCountT = tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = reduce(shapes.begin(), shapes.end(), ShapeCountT{}, [] (ShapeCountT acc, Circle&amp; item) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [cir, sq, tr] = acc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_tuple(++cir, sq, tr); }, [] (ShapeCountT acc, Square&amp; item) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [cir, sq, tr] = acc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_tuple(cir, ++sq, tr); }, [] (ShapeCountT acc, EquilateralTriangle&amp; item) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [cir, sq, tr] = acc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_tuple(cir, sq, ++tr); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [cir, sq, tr] = result; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Circle count: "</span></span> &lt;&lt; cir &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\tSquare count: "</span></span> &lt;&lt; sq &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\tTriangle count: "</span></span> &lt;&lt; tr &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : // Circle count: 2 Square count: 3 Triangle count: 2</span></span></code> </pre><br>  The <b>map</b> function is implemented on the basis of similar ideas, omitting the description of its implementation and the implementation itself.  To train your meta skills, I propose to implement it yourself :) <br><br><h2>  What's next? </h2><br>  A bit of error.  Take a step aside and see a similar message: <br><br><div class="spoiler">  <b class="spoiler_title">Error screen</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/f62/592/21d/f6259221d4db4e7da4ffcca72d4c2e88.png"><br></div></div><br>  The text of this error cannot be disassembled, even if you use a very simple code (the error lies in the incorrect use of the generic parameter of the functor).  Imagine what happens if you use the classes much more difficult than the ones presented. <br><br>  There are several approaches, how you can elegantly or not really say about the true nature of the error. <br>  Next time we dilute what is written with Concepts TS from gcc-7.1. <br><br>  Summarizing, we can say that such an approach can be very useful for working with libraries that have had to use <i>TypeErasure</i> techniques, for template classes with different specializations, for primitive emulation of polymorphism, ... <br><br>  How would you add / use this functionality?  Write in the comments, it will be interesting to read <br><br>  The above code is available <a href="https://github.com/JegernOUTT/PolymorphismTests">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/332084/">https://habr.com/ru/post/332084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332074/index.html">Autoencoders in Keras, Part 6: VAE + GAN</a></li>
<li><a href="../332076/index.html">Dynamic instrumentation is not easy, but trivial *: we write yet another instrumentation for American Fuzzy Lop</a></li>
<li><a href="../332078/index.html">Classifying Text with Java Neural Network</a></li>
<li><a href="../332080/index.html">Hackers and exchanges: how to attack the sphere of finance</a></li>
<li><a href="../332082/index.html">Integration of 1C with DLL using Python</a></li>
<li><a href="../332086/index.html">Automatic application deployment with Maven and Wildfly</a></li>
<li><a href="../332088/index.html">Tasks with interviews. Three adequate tasks to "think"</a></li>
<li><a href="../332090/index.html">ReactJS - my understanding of testing</a></li>
<li><a href="../332092/index.html">Nelder-Mead optimization method. Python implementation example</a></li>
<li><a href="../332094/index.html">Creating a blog engine with Phoenix and Elixir / Part 9. Channels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>