<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32F1—Ö—Ö - we continue treatment for arduine dependence with the help of LCD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. In my last article, I reviewed the use of the excellent STM32F1xx microcontrollers using the example of servo contro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32F1—Ö—Ö - we continue treatment for arduine dependence with the help of LCD</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear habrovchane.  In my last <a href="http://habrahabr.ru/blogs/controllers/123791/">article,</a> I reviewed the use of the excellent STM32F1xx microcontrollers using the example of servo control.  In this article, we turn to a more interesting question - the management of color graphic LCD-display.  In addition to the standard work with the display, I will try to highlight the issues of using the features of STM32F microcontrollers to effectively address this issue.  So, let's begin. <br><a name="habracut"></a><br>  A small addition to the introduction - this article was started more than six months ago, but then I had to stop (first the defense of my graduation project, then a lot of urgent projects at work), and the time was found only now.  Therefore, it turned out now, of course, not quite the same as I imagined at the beginning, some of the code and graphic material would be lost - but still, I tried to finish it, and I hope that it will be interesting for you. <br><br><h4>  Iron </h4><br>  First of all, about the gland.  The core of the system, as well as last time, will be the <a href="http://www.terraelectronica.ru/catalog_info.php%3FID%3D1001%26CODE%3D573571%26Name%3DSTM32VLDISCOVERY%26Razdel%3D%25CE%25F2%25EB%25E0%25E4%25EE%25F7%25ED%25FB%25E5%2520%25E8%2520%25EE%25F6%25E5%25ED%25EE%25F7%25ED%25FB%25E5%2520%25EF%25EB%25E0%25F2%25FB%2520%25E8%2520%25ED%25E0%25E1%25EE%25F0%25FB%2520%25E4%25EB%25FF%2520%25F1%25E5%25EC%25E5%25E9%25F1%25F2%25E2%25E0%2520STM32%2520(Cortex-M3)%26TableName%3Dclass_19_2_40_4_6">STM32VLDISCOVERY</a> debugging board, which can be purchased for 300r.  We will assemble the circuit on a breadboard to solder less.  However, unlike last time, we still have to solder, and quite a specific one - we will have to solder to a flexible-rigid printed circuit board at the back of the display (to put it simply, to a film with contacts).  But more about that later.  The 3.3V power supply is on the debug board, so all we need in addition is the display itself and a 10-20 volt power supply for its illumination. <br>  It is time to consider the part for which everything, in fact, was started - the display. <br>  In fact, the options available to the developer at home, quite a lot. <br>  At the time of writing this article, I considered displays from mobile phones to be the most affordable option, since they are relatively easy to buy, many are controlled by SPI and are quite cheap.  Actually, this article is devoted to one of such displays. <br>  However, after I spent some time on e-bay, I came to the conclusion that the best option is, after all, the purchase of a separate display for your needs. <br>  First, you can find pretty cheap models, such as, for example, this display: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/e13/f91/8e0/e13f918e075168c335df218f4bd222c6.jpg" alt="image"><br>  <a href="http://www.ebay.com/itm/1-8-TFT-Color-LCD-Display-Module-SPI-interface-/280645844606%3Fpt%3DBI_Electrical_Equipment_Tools%26hash%3Ditem4157cbbe7e">1-8-TFT-Color-LCD-Display-Module-SPI-interface</a> <br><br>  Secondly, if you pay a little more, you can get a complete display module and don‚Äôt waste time soldering uncomfortable connectors: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/f76/e06/1a4/f76e061a4021a207108de83d6023c2b2.jpg" alt="image"><br>  <a href="http://www.ebay.com/itm/1-8-TFT-LCD-module-TF-Card-socket-break-out-arduino-/270866804157%3Fpt%3DBI_Electrical_Equipment_Tools%26hash%3Ditem3f10eb6dbd">1-8-TFT-LCD-module-TF-Card-socket-break-out-arduino</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thirdly, some display modules are altogether beyond all praise - <br><img src="https://habrastorage.org/getpro/geektimes/post_images/706/47f/4bb/70647f4bbc56e2def2dddb1f89168212.jpg" alt="image"><br>  <a href="http://www.ebay.com/itm/2-4inch-TFT-LCD-module-touch-panel-SD-card-cage-/270569308217%3Fpt%3DBI_Electrical_Equipment_Tools%26hash%3Ditem3eff300039">2-4inch-TFT-LCD-module-touch-panel-SD-card-cage</a> <br><br>  For 18 bucks, we get a fully finished display module, which includes a 320x240 display with a controller, which has full documentation (note that the display controllers from many mobile phones are very difficult to find documentation), a resistive touchscreen with a controller (that is, it is already connected , you can immediately request the coordinates by SPI), a convenient connector, and - as a bonus appendage - a slot for micro-SD. <br>  Also on board is a boost converter to power the backlight. <br>  Therefore, at the moment, I, of course, consider displays with e-bay the most convenient and correct option. <br><br>  Finally, the last option that I would like to point out, these are such amusing devices: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/b5b/684/1ef/b5b6841ef4f3d16d34c21fd22be75b61.jpg" alt="image"><br>  <a href="http://www.dealextreme.com/p/1-5-lcd-rechargeable-digital-usb-photo-frame-keychain-107-picture-memory-storage-21304">1-5-lcd-rechargeable-digital-usb-photo-frame-keychain</a> <br>  This miracle of Chinese technology is a miniature digital photo frame.  As it turned out, several foreign enthusiasts were already digging in its depths, and found out that they are being built on the ST2203U 6502-compatible microcontroller, whose firmware is fixed during production, so we are not interested.  On the other hand, in less than 200p we get a 128x128 STN LCD display (most of them are built on the PCF8833 controller), a flash memory chip, a lithium-ion battery with a charge controller circuit and a handy case for its device. <br><br>  And yet, let‚Äôs dwell on the first option, that is, the display from a mobile phone. <br>  According to information taken from the Internet, from small color LCD displays, displays from Nokia HZ and Siemens S (K) 65 are popular.  There is quite a lot of information on the first display, but it is inferior to displays from Siemens in image quality, resolution, and most importantly - in response time, which makes it almost unsuitable for playing animation.  And you and I are not interested in displaying static pictures, right?  The second display, according to data from the Internet, provides us with a resolution of 132 x 176 pixels and a response time sufficient to display the animation.  However, unfortunately, I had no opportunity to compare these two displays - because  I hung around the old Siemens SK65, the choice was clearly made in favor of it. <br>  The first rake lies in wait for us when buying the display itself.  The fact is that Siemens installs in its S65 displays on the controllers of three different manufacturers, LS020xxx, LPH88xxxx, L2F50xxx. <br><br><img src="http://www.superkranz.de/christian/S65_Display/pics/display_LS_small.jpg" alt="image"><br><br><img src="http://www.superkranz.de/christian/S65_Display/pics/display_LPH_small.jpg" alt="image"><br><br><img src="http://www.superkranz.de/christian/S65_Display/pics/epson_display_small.jpg" alt="image"><br><br>  About the third, I have not heard anything at all, on the second there is an official datasheet, but it seems that this controller is much less common. <br>  But first, the LS020xxx is the controller that most often stands on mobiles, and my SK65 was no exception. <br>  It would seem that everything is fine, but here lies one unpleasant fact: there is no datasheet on the controller.  Thus, it is necessary to develop without an official document, in which commands and registers would be described.  But not everything is so bad - the craftsmen conducted a reverse engineering session and determined the basics of interaction with the display, and there is a lot of information about it on the Internet. <br>  Consider the display in more detail. <br><br><h4>  Display LS020xxx </h4><br><br><img src="http://avrhobby.ru/images/stories/ls020.jpg" alt="image"><br><br>  The first thing that catches your eye is a very convenient contact pads, which are much easier to solder to than the smaller connectors on most displays.  True, they are located on a flex-rigid printed circuit board, which, if carelessly applied, can be melted with a soldering iron, so that when soldering we set the temperature of the soldering iron to a smaller one. <br>  Total display has 10 contacts: <br><br><ol><li> RS command / data switch signal </li><li>  RESET - display reset signal </li><li>  CS - SPI device select signal </li><li>  CLK - SPI Clock </li><li>  DAT - MOSI SPI signal </li><li>  2.9V and 1.8V - display power </li><li>  LED +, LED_GND - power and ground circuit lighting </li><li>  GND is the display ground. </li></ol><br><br>  The LED + and LED_GND contacts are powered by the display backlight, which can be from 10 to 20 volts.  This power is supplied to 3 LEDs, the current through them is regulated by the controller schematics, so that one or two 9V batteries without current-limiting resistors can be connected to them fearlessly.  I connected two series-connected, slightly hooked, crowns, receiving a voltage of about 17V. <br>  The 1V8, 2V9 and GND pins provide power to the display circuits.  What is interesting, in many wiring diagrams, you can see the pin 1V8 is not connected at all.  In all other schemes, the pins 1V8 and 2V9 are connected together and connected to the source 3.3V.  This connection turned out to be quite workable, so we will do it. <br>  Pins CS, DAT, CLK show us a trivial SPI interface without a return wire.  This fact can not but rejoice, because  even on AVRs, there is a hardware SPI controller, and STMs are rich to the periphery of this kind - there are two of these controllers in the low-end models, 4 are high in the older ones, so one of the SPIs can be selected entirely for communication with the display. <br>  The RS and RESET pins are two additional control signals for the display.  The first, being in the active level (log 0), indicates that we are transmitting commands to the display, and in the inactive (log 1) data.  RESET, as the name implies, is designed to reset the controller. <br>  Now we need to connect the display to our debug board using the layout.  For this, I selected a cable with a 10-pin IDC connector. <br><br><img src="https://habrastorage.org/storage2/cd9/56d/075/cd956d0757607023d360320bf1f73b60.jpg"><br><br>  I realized my tactical blunder when the cable was already soldered - the fact is that the horizontal sockets on the breadboard are interconnected, so the rows of the connector are shorted.  Anyway, I didn‚Äôt have another connector anyway, so I had to make amendments in the form of ‚Äúlegs‚Äù of wire - because  The layout consists of three independent sections, by connecting a connector on the border of sections, it was possible to avoid a short circuit. <br><br>  Those who will repeat my experiments still advise you to take a single-row 10-pin connector, problems will be less.  After the cable is crimped, it should be soldered to the contacts of the display - I remind you that the film on which the contacts are located does not like long-term exposure to high temperature, so we try to solder quickly and clearly. <br>  After soldering, place the connector on the breadboard and begin to connect with jumpers to the controller.  The power supply pins of the backlight are immediately diverted to hell, we plug the connector in there from the crown and forget about them.  Whoever has a 10-20V power supply is even better, you do not have to constantly disconnect the batteries in order to save energy. <br><br>  Next, the SPI interface is connected.  The debug board in the prototype was installed only by hanging the horizontal pins (for the reason for the jumper already described), which fortunately were few.  However, among them was the SPI2 interface, so that only the first one remained at our disposal.  However, it should not upset us greatly, because  we are not going to connect anything to it yet.  Therefore we connect CLK with pin PA7, DAT - with pin PA5.  We will pull the CS with handles in accordance with the logic of operation, as well as the RS with the RESET - therefore, we will output these three signals where it is convenient for us.  I chose pins PA2, PA3, PA4.  You end up with something like this: <br><br><img src="https://habrastorage.org/storage2/758/be8/2a1/758be82a1ad1b497caf3c58e1f93d188.jpg"><br><br>  By the way, a small offtopic: after I connected everything, I issued a test 10 KHz meander to one of the pins.  And this is what the oscilloscope showed: <br><br><img src="https://habrastorage.org/storage1/89b377ed/f3e83bd4/201616b8/d567ece8.jpg" alt="image"><br><br>  Channel 2, marked in blue, is connected to the pin itself.  But channel 1 (yellow) is connected to the adjacent output.  See these beautiful exhibitors with an amplitude of almost 100mV?  All these jumpers on the breadboard give a rather weak capacitive coupling between the pins.  Which is typical, if the debug board is pulled out of the layout, the effect is practically absent: <br><br><img src="https://habrastorage.org/storage1/4f74c106/648ef8fd/eabd50bd/d3aebdff.jpg" alt="image"><br><br>  Therefore, when designing a device, be careful: the layout makes its own specifics, which must be considered.  High-frequency circuits to collect on it is almost impossible. <br><br>  After connecting the display, we take out the multimeter and carefully check the assembly, ringing all the signals, so as not to sin on the firmware when you have the postings. <br>  If everything is connected correctly, run Cale and proceed to the next part. <br><br><h4>  Code </h4><br>  As I already mentioned, I returned to writing the article many months after, in fact, experimenting with the display, so part of the code was lost.  But I tried to restore important points from memory.  However, the interaction with the display is very trivial and should not cause difficulties. <br>  So, at the moment we need to have a display fully connected to the breadboard and running Cale with the project created. <br><br>  We begin with a simple display of images.  Since our task now is to deal with the display, we will not philosophize slyly and screw up the download from the cards, reading the file systems, etc.  - just place the image as raw 16-bit RGB values ‚Äã‚Äãin the controller's flash memory.  To do this, I recommend to jot down a program in a convenient programming language that will translate a standard bmp file into a record like <br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Picture[] = {<span class="hljs-number"><span class="hljs-number">0x0000</span></span>, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, ‚Ä¶, <span class="hljs-number"><span class="hljs-number">0x0000</span></span>};</code> </pre> <br>  Since the resolution of our display is 132 x 176 pixels, each of which takes 2 bytes, the full picture will take up 46,464 bytes in memory, that is, a little more than 45 KB. <br>  Fortunately, 500 KB of flash STMki allow us to save the image in its raw form, and not even one. <br><br>  Now go to the display programming.  Most of all it looks like black magic, because we don‚Äôt have datasheets for the controller, but there are instructions from those who reverse that immediately give a ‚Äúspell‚Äù as a sequence of bytes, without explaining why it is.  If you are not satisfied with this approach, then the best solution would be to purchase any of the displays I mentioned from the e-bay, to which a complete set of documentation goes. <br><br>  So, spells. <br>  The display is initialized with the following sequence (very sensitive to pauses!): <br><br><ol><li>  Log level 0 to the RESET line and hold it for about 5 ms </li><li>  We give the first spell to the display, which is such a block of bytes: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Init1[<span class="hljs-number"><span class="hljs-number">12</span></span>]={<span class="hljs-number"><span class="hljs-number">0xFDFD</span></span>,<span class="hljs-number"><span class="hljs-number">0xFDFD</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0xEE04</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B04</span></span>,<span class="hljs-number"><span class="hljs-number">0xFEFE</span></span>,<span class="hljs-number"><span class="hljs-number">0xFEFE</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF90</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A04</span></span>,<span class="hljs-number"><span class="hljs-number">0x7F3F</span></span>,<span class="hljs-number"><span class="hljs-number">0xEE04</span></span>,<span class="hljs-number"><span class="hljs-number">0x4306</span></span>}</code> </pre> <br>  Replacing Init1 [9] = 0x7F3F with 0x7F1F, we can initialize the display in 256 color mode - but since  16-bit color is still more interesting, let's focus on the original version. <br>  After this block bytes must wait 7 ms. </li><li>  We issue a block byte <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Init2[<span class="hljs-number"><span class="hljs-number">20</span></span>]={<span class="hljs-number"><span class="hljs-number">0xEF90</span></span>,<span class="hljs-number"><span class="hljs-number">0x0983</span></span>,<span class="hljs-number"><span class="hljs-number">0x0800</span></span>,<span class="hljs-number"><span class="hljs-number">0x0BAF</span></span>,<span class="hljs-number"><span class="hljs-number">0x0A00</span></span>, <span class="hljs-number"><span class="hljs-number">0x0500</span></span>,<span class="hljs-number"><span class="hljs-number">0x0600</span></span>,<span class="hljs-number"><span class="hljs-number">0x0700</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0xEE0C</span></span>, <span class="hljs-number"><span class="hljs-number">0xEF90</span></span>,<span class="hljs-number"><span class="hljs-number">0x0080</span></span>,<span class="hljs-number"><span class="hljs-number">0xEFB0</span></span>,<span class="hljs-number"><span class="hljs-number">0x4902</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>, <span class="hljs-number"><span class="hljs-number">0x7F01</span></span>,<span class="hljs-number"><span class="hljs-number">0xE181</span></span>,<span class="hljs-number"><span class="hljs-number">0xE202</span></span>,<span class="hljs-number"><span class="hljs-number">0xE276</span></span>,<span class="hljs-number"><span class="hljs-number">0xE183</span></span>}</code> </pre> <br>  And wait 50 ms </li><li>  Kastuem last spell in the form of two bytes <pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Init3[<span class="hljs-number"><span class="hljs-number">2</span></span>]={<span class="hljs-number"><span class="hljs-number">0x8001</span></span>}</code> </pre>  and wait 5 ms. </li></ol><br><br>  After that, a multi-colored garbage should appear on the display, meaning that the initialization was successful. <br>  So, we will try to implement it all, incidentally remembering how to work with the periphery in STMke. <br>  I decided to try bit-banding at the same time, for which I immediately announced three pointers: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *Reset = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)<span class="hljs-number"><span class="hljs-number">0x42210184</span></span>, *CS = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)<span class="hljs-number"><span class="hljs-number">0x42210188</span></span>, *RS = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*)<span class="hljs-number"><span class="hljs-number">0x4221018C</span></span>;</code> </pre><br>  For those who do not remember about this wonderful technique, bit-banding is a very useful feature, representing the mapping of each bit of the IO-registers and RAM in the dvd somewhere in the STMki address space.  Since the address space is 32-bit, that is, 4 gigabytes, and actually much less involved, the developers decided to spend a few meters to link bits from the IO or RAM (bit-band alias region) with dvords in the bit-band region . <br>  It works simply - let's say we want to manage the pin of CS, which corresponds to PA2.  The level of the signal on it is controlled by bit number 2 of the <b>GPIOA-&gt; ODR</b> register. <br>  Let's use the formula from datasheet: <br><br>  bit_word_addr = bit_band_base + (byte_offset x 32) + (bit_number √ó 4) <br><br>  bit_word_addr is the address of the bit band to be calculated. <br>  bit_band_base for our processor, according to the datasheet, is declared in the header as <br><br><pre> <code class="hljs lisp">#define PERIPH_BB_BASE ((<span class="hljs-name"><span class="hljs-name">uint32_t</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>x42000000)</code> </pre><br>  byte_offset - offset to the desired register, in this case, to GPIOA-&gt; ODR, from the beginning of the bit-band alias region. <br>  Since the address of <b>GPIOA-&gt; ODR</b> is 0x4001080, and the beginning of the peripheral bit-band alias of the region is declared as <br><br><pre> <code class="hljs lisp">#define PERIPH_BASE ((<span class="hljs-name"><span class="hljs-name">uint32_t</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>x40000000)</code> </pre><br>  That offset will be 0x4001080-0x40000000 = 0x1080C <br>  And finally, the number of the bit of interest to us is 2. Combining it all together we get <br>  * CS = 0x42000000 + (0x1080C) * 32 + 2 * 4 = 0x42000000 + 210180 + 8 = 0x42210188 <br><br>  Now, by writing a nonzero value at this address, we set the bit associated with this memory cell to 1, and writing zero to 0. <br><br>  Three blocks of bytes have already been announced, we will initialize the periphery: <br><br><pre> <code class="hljs erlang-repl">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN; GPIOA-&gt;CRL |=GPIO_CRL_MODE1; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF1; GPIOA-&gt;CRL |=GPIO_CRL_MODE2; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF2; GPIOA-&gt;CRL |=GPIO_CRL_MODE3; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF3; GPIOA-&gt;CRL |=GPIO_CRL_MODE5; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF5; GPIOA-&gt;CRL |=GPIO_CRL_CNF5_1; *Reset=<span class="hljs-number"><span class="hljs-number">1</span></span>; *CS=<span class="hljs-number"><span class="hljs-number">1</span></span>; *RS=<span class="hljs-number"><span class="hljs-number">1</span></span>; GPIOA-&gt;CRL |=GPIO_CRL_MODE7; GPIOA-&gt;CRL &amp;=~GPIO_CRL_CNF7_0; GPIOA-&gt;CRL |=GPIO_CRL_CNF7_1; SPI1-&gt;CR1 &amp;= ~SPI_CR1_BR_2; SPI1-&gt;CR1 |= SPI_CR1_DFF; SPI1-&gt;CR1 |= SPI_CR1_MSTR|SPI_CR1_SPE;</code> </pre><br>  Everything is simple - we set Reset, CS, RS to exit under the control of our program, <br>  CLK and MOSI - output controlled by the periphery, that is, in this case, the controller SPI. <br>  SPI is tuned to the Fclk / 8 frequency and data sending by 16-bit words instead of bytes. <br>  You should also describe the functions of delay and synchronous sending by SPI, which, due to their triviality, I will not give here, except for the prototypes: <br><br><pre> <code class="hljs lisp">__INLINE void Delay_ms(<span class="hljs-name"><span class="hljs-name">uint32_t</span></span> us) __INLINE void SendSPI(<span class="hljs-name"><span class="hljs-name">uint16_t</span></span> Data)</code> </pre><br>  Their implementation is extremely simple - the delay is implemented by a normal cycle, synchronous sending via SPI - sending a byte to the SPI data register (SPI1-&gt; DR = Data;) and waiting in the cycle until the SPI_SR_BSY flag disappears from the SPI1-&gt; SR status . <br><br>  Further we carry out our magic sequence: <br><br><pre> <code class="hljs matlab">*Reset=<span class="hljs-number"><span class="hljs-number">0</span></span>; *CS=<span class="hljs-number"><span class="hljs-number">0</span></span>; Delay_ms(<span class="hljs-number"><span class="hljs-number">5</span></span>); *Reset=<span class="hljs-number"><span class="hljs-number">1</span></span>; Delay_ms(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(Init1[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); Delay_ms(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">20</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(Init2[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); Delay_ms(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(Init3[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); Delay_ms(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br>  Now it's time to learn new spells.  So: <br>  The command {0xEF90, 0x05OR, 0x06XX, 0x07YY} - displays graphic information on the screen, where the OR byte indicates the orientation of the screen when outputting and can be equal to 0x04 in the case of horizontal and 0x00 in the case of vertical - pixels will be filled in this direction.  Bytes XX and YY indicate the position of the lower left corner of the rectangle.  The upper right corner will always be equal to the pixel (175, 131). <br>  Then you should submit bytes of graphic information in the format on which the display was initialized.  In this case - 16-bit Word of the form 5-6-5 (RGB) <br><br>  To display information in a limited area, the command is used in a slightly modified form: <br>  {0xEF90, 0x05OR, 0x08X1,0x09X2,0x0AY1,0x0BY2}, where X1, Y1 are the coordinates of the lower left corner of the output area, X2, Y2 are the coordinates of the upper right corner. <br><br>  Thus, filling the entire screen with black will look like this: <br><br><pre> <code class="hljs matlab">SendSPI(<span class="hljs-number"><span class="hljs-number">0xEF90</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0504</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0600</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0700</span></span>); *RS=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">132</span></span>*<span class="hljs-number"><span class="hljs-number">176</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(<span class="hljs-number"><span class="hljs-number">0x0000</span></span>); *RS=<span class="hljs-number"><span class="hljs-number">1</span></span>; *CS=<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Well, now we will finally display our picture! <br><br><pre> <code class="hljs matlab">SendSPI(<span class="hljs-number"><span class="hljs-number">0xEF90</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0504</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0600</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0700</span></span>); *RS=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">132</span></span>*<span class="hljs-number"><span class="hljs-number">176</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(Picture[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); *RS=<span class="hljs-number"><span class="hljs-number">1</span></span>; *CS=<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  If everything is done correctly, then we should get the following result: <br><img src="http://habrastorage.org/storage2/03e/d11/15a/03ed1115a0350399ea0544f3d83f6f2a.jpg"><br>  <i>Mirrored marine as it tells us: remember the order of the output pixels!</i> <br><br>  Finishing work with the display is recommended not by simply turning off the power, but by the following sequence of commands: <br><br><pre> <code class="hljs matlab">uint16_t Power[<span class="hljs-number"><span class="hljs-number">26</span></span>]={<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0x7E04</span></span>,<span class="hljs-number"><span class="hljs-number">0xEFB0</span></span>,<span class="hljs-number"><span class="hljs-number">0x5A48</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0x7F01</span></span>,<span class="hljs-number"><span class="hljs-number">0xEFB0</span></span>,<span class="hljs-number"><span class="hljs-number">0x64FF</span></span>,<span class="hljs-number"><span class="hljs-number">0x6500</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0x7F01</span></span>,<span class="hljs-number"><span class="hljs-number">0xE262</span></span>,<span class="hljs-number"><span class="hljs-number">0xE202</span></span>,<span class="hljs-number"><span class="hljs-number">0xEFB0</span></span>,<span class="hljs-number"><span class="hljs-number">0xBC02</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0x7F01</span></span>,<span class="hljs-number"><span class="hljs-number">0xE200</span></span>,<span class="hljs-number"><span class="hljs-number">0x8000</span></span>,<span class="hljs-number"><span class="hljs-number">0xE204</span></span>,<span class="hljs-number"><span class="hljs-number">0xE200</span></span>,<span class="hljs-number"><span class="hljs-number">0xE100</span></span>,<span class="hljs-number"><span class="hljs-number">0xEFB0</span></span>,<span class="hljs-number"><span class="hljs-number">0xBC00</span></span>,<span class="hljs-number"><span class="hljs-number">0xEF00</span></span>,<span class="hljs-number"><span class="hljs-number">0x7F01</span></span>}; *RS=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">26</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) SendSPI(Power[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); *CS=<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br>  On this, in principle, it would be possible to finish, but in fact, ahead of us the most interesting is waiting for us! <br><br><h4>  Using the features of the architecture STM32F1xx to optimize the display on the screen </h4><br>  So, we brought to the screen a picture from memory.  This is already a good achievement and a wide field for activity, but ... We could do the same thing easily on the notorious Arduin.  And our goal is to recover from arduino dependence and understand which tasks are best solved by other methods.  Let's think: what is the current implementation limiting us to? <br>  The answer is obvious - if we want to render the animation, then most of the time we will be spinning in a cycle of displaying graphical information.  Since the screen resolution is 132x176 pixels, each of which is described by two bytes, we need to display 371,712 bits on the SPI bus.  Each bit is output with a frequency of eight times less than the clock, that is, we need to spend 2,973,696 cycles to output one frame.  Having a 75 MHz STMK on hand is perhaps not so critical - albeit unpleasant, but for 16 MHz AVRki is a disaster at all. <br>  But fortunately, in the STM architecture there is a block that in such situations makes our life look like a fairy tale.  This is a direct memory access unit, that is, a DMA. <br>  It allows data transfer without the use of the controller core between the following points: <br><ul><li>  Memory memory </li><li>  Memory Peripherals </li><li>  Peripherals-Memory. </li></ul><br>  Quite a word, let's actually see what it gives us! <br>  First, add the necessary code to the initialization of the peripherals: <br><br><pre> <code class="hljs erlang-repl">DMA1_Channel3-&gt;CPAR = (uint32_t)(&amp;SPI1-&gt;DR); DMA1_Channel3-&gt;CNDTR = <span class="hljs-number"><span class="hljs-number">1560</span></span>; DMA1_Channel3-&gt;CCR |= DMA_CCR3_PL_0; DMA1_Channel3-&gt;CCR |= DMA_CCR3_PSIZE_0; DMA1_Channel3-&gt;CCR |= DMA_CCR3_MSIZE_0; DMA1_Channel3-&gt;CCR |= DMA_CCR3_DIR; DMA1_Channel3-&gt;CCR |= DMA_CCR3_MINC; DMA1_Channel3-&gt;CCR |= DMA_CCR3_EN;</code> </pre><br>  Here we set the address where the data will be written (it is equal to the SPI data register address), set the number of 16-bit words for transmission to be 1560 (my frames are 30x52 pixels in size), the average transmission priority is <br>  the size of the receiver and the source - in this case, both of them are 16 bits, the direction of transmission (from memory to the periphery), set the pointer autoincrement to the memory, and enable DMA. <br>  After that we should prepare several frames in the same format as the const uint16_t Picture [] described earlier. <br>  For this, I prepared 12 headers frame01.h ... frame12.h, and combined the data from them into <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* Video[]={frame1,frame2,frame3,frame4,frame5,frame6,frame7,frame8,frame9,frame10,frame11,frame12};</code> </pre><br>  We also introduce a frame counter variable. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uint8_t</span></span> FrameCnt=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  It remains quite a bit - in the initialization we tune the system timer to the frame rate we need, <br><br><pre> <code class="hljs lisp">SysTick_Config(<span class="hljs-name"><span class="hljs-name">SystemCoreClock/50000</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  It remains to describe the timer interrupt handler: <br><br><pre> <code class="hljs php">void SysTick_Handler() { *CS=<span class="hljs-number"><span class="hljs-number">0</span></span>; FrameCnt++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FrameCnt&gt;<span class="hljs-number"><span class="hljs-number">11</span></span>) FrameCnt=<span class="hljs-number"><span class="hljs-number">0</span></span>; SPI1-&gt;CR2 &amp;= ~SPI_CR2_TXDMAEN; DMA1_Channel3-&gt;CCR &amp;=~DMA_CCR3_EN; *RS=<span class="hljs-number"><span class="hljs-number">1</span></span>; *CS=<span class="hljs-number"><span class="hljs-number">0</span></span>; SendSPI(<span class="hljs-number"><span class="hljs-number">0xEF90</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0504</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0A00</span></span>+<span class="hljs-number"><span class="hljs-number">70</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0800</span></span>+<span class="hljs-number"><span class="hljs-number">50</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0B1D</span></span>+<span class="hljs-number"><span class="hljs-number">70</span></span>); SendSPI(<span class="hljs-number"><span class="hljs-number">0x0933</span></span>+<span class="hljs-number"><span class="hljs-number">50</span></span>); *RS=<span class="hljs-number"><span class="hljs-number">0</span></span>; DMA1_Channel3-&gt;CMAR = (uint32_t)Video[FrameCnt]; DMA1_Channel3-&gt;CNDTR = <span class="hljs-number"><span class="hljs-number">1560</span></span>; DMA1_Channel3-&gt;CCR |= DMA_CCR3_EN; SPI1-&gt;CR2 |= SPI_CR2_TXDMAEN; }</code> </pre><br>  Here we calculate the number of our next frame, after which we disable the DMA transmission for a while.  This is necessary to transfer the display commands to the graphics output. <br>  In this case, small pictures are displayed, not full screen, because  simply not enough memory controller.  If you screw here reading from any SD-card, then it is quite possible to twist the full-screen video. <br><br>  After the commands are transmitted, we set up the address of the source of the graphics ‚Äî one of the frames, the pointers to which are stored in Video [], set the size of the transmitted block and enable DMA. <br><br>  Everything!  Now our program spends no more than a few tens of cycles on the output of graphics every 50 ms, the same ones that go on processing a timer interrupt - after the interrupt is processed, DMA starts sending data to the SPI register without our participation!  Thus, we can safely do our work in the main cycle, prepare the next frame, or short-cut any objects without worrying about the output of graphics. <br>  If everything is done correctly, we get the following: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/kuO0sLa9IKc%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhh79I8PVijVe4xl5DG9aUPCHtB50Q" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Conclusion </h4><br>  What have we achieved? <br>  First of all, we learned to work with such interesting peripherals as a color graphic display.  This in itself is not bad and can be useful in projects. <br>  But the main thing is that we have learned how to use the DMA block, which opens up the widest possibilities, compared to the soft data transfer on controllers that do not have such a block. <br><br>  As for the displays, I would like to add the following: on e-bay I found a debug board, which I would call without question an excellent and necessary developer tool on STM32.  It is sold here: <a href="http://www.ebay.com/itm/280580644330%3FssPageName%3DSTRK:MEWNX:IT%26_trksid%3Dp3984.m1439.l2649">Mini-STM32</a> <br><img src="http://i910.photobucket.com/albums/ac304/electronicslee/lcd_module/stm32_24lcd.jpg" alt="image"><br><br>  For 45 bucks we get an incredibly convenient and powerful tool, which includes the STM32F103VET microcontroller, with hardware USB, a static memory controller, which at times facilitates work with the display and the hardware controller of SD cards.  The display itself, with a resolution of 320x240 and a resistive touchscreen installed on it, a touchscreen controller, a boost converter for powering the backlight.  All necessary binding for USB.  RS-232 with converter.  And the battery that feeds the controller's back-up registers. <br>  Also, on additional request, for $ 28 in the order will add a convenient programmer, clone J-LINK, which, according to my feelings, is much more stable than the one that is built into the debug for 300r. <br><br>  In general, I highly recommend to anyone who is going to engage in STMs to purchase a kit from this debug board and programmer.  I will write subsequent articles using the Mini-STM32 as the main tool. <br>  Since at the moment I am working with very interesting radio modules, the next article will most likely be about them. <br><br><h4>  Links </h4><br>  Understanding the display, I used the following materials: <br>  <a href="http://www.juras-projects.org/eng/lcd.php">http://www.juras-projects.org/eng/lcd.php</a> <br>  <a href="http://avrhobby.ru/index.php%3Foption%3Dcom_content%26view%3Darticle%26id%3D71:-rgb-1%26catid%3D42:rgb-%26Itemid%3D71">http://avrhobby.ru/index.php?option=com_content&amp;view=article&amp;id=71:-rgb-1&amp;catid=42:rgb-&amp;Itemid=71</a> </div><p>Source: <a href="https://habr.com/ru/post/139384/">https://habr.com/ru/post/139384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139376/index.html">MariO - release</a></li>
<li><a href="../139379/index.html">We write plugins for Android</a></li>
<li><a href="../139380/index.html">Research through functional testing</a></li>
<li><a href="../139382/index.html">Picasaweb API Authorization. We get a constant token</a></li>
<li><a href="../139383/index.html">Django micro</a></li>
<li><a href="../139385/index.html">Remote Follow Focus on Arduino</a></li>
<li><a href="../139386/index.html">Customize graphite + virtualenv + collectd</a></li>
<li><a href="../139387/index.html">Mercedes made a "transparent" car (LED and video camera)</a></li>
<li><a href="../139388/index.html">ikSelect - the perfect plugin for styling selektov</a></li>
<li><a href="../139390/index.html">Audio chat for 5 days</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>