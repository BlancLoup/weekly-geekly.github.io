<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of c ++ tuples implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Impressed by the excellent article on Variadic Templates from the respected FlexFerrum, he decided to practice metaprogramming and write his own imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of c ++ tuples implementation</h1><div class="post__text post__text-html js-mediator-article"> Impressed by the excellent <a href="http://habrahabr.ru/post/101430/">article</a> on <code>Variadic Templates</code> from the respected <a href="https://habrahabr.ru/users/flexferrum/" class="user_link">FlexFerrum, he</a> decided to practice metaprogramming and write his own implementation of a data structure called <code>Tuple</code> (Tuple) using templates with a variable number of arguments.  For those who are not familiar, a tuple is a data structure that stores data of different types simultaneously.  In our particular case, this will be a template class that stores data of the types that were passed to it as template parameters (taking into account the order). <br><br>  It is assumed that the reader is already familiar with the above article, when describing the development process, I will build on it. <br><a name="habracut"></a><br><h5>  Data storage </h5><br>  The first problem we face is the principle of data storage.  The FlexFerrum article proposed a class implementation, which is essentially a superposition of functions that are passed as template parameters.  To save pointers to functions, a model of multiple inheritance from the <code>DataHolder</code> class was <code>DataHolder</code> , which stores in itself what it was parameterized with: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataHolder</span></span></span><span class="hljs-class"> {</span></span> T m_data; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Op, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ‚Ä¶ F&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DataHolder&lt;F&gt; ‚Ä¶ { <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will go a little different way with you and build a chain of inheritance, and in the end we will look at what benefits we have from this. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tuple&lt;REST ...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Tuple(); Tuple(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp; _p1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> REST &amp; ... _rest); <span class="hljs-comment"><span class="hljs-comment">/// returns elements count inline constexpr static unsigned int Count() { return mIndex + 1; } // ... protected: private: T mMember = T(); static constexpr unsigned int mIndex = TupleSuper::Count(); } //   template &lt;class T&gt; class Tuple { public: Tuple(); Tuple(const T &amp; _p1); /// returns elements count inline constexpr static unsigned int Count() { return mIndex + 1; } // ... protected: private: T mMember = T(); static constexpr unsigned int mIndex = 0; }</span></span></code> </pre><br><br>  The implementation of the constructors should be obvious: we initialize the field of the current class and call the base class constructor with the remaining arguments. <br><br><h5>  Set / Get methods </h5><br>  The next step is the implementation of setters and getters for class data fields.  Methods that receive and record at once all fields are simple to implement and are not given here.  Much more interesting is the situation, say, with a getter that takes a numeric index of a field as a template argument.  To implement it, we need some auxiliary class that will allow us to index <code>Tuple</code> types in our inheritance chain as follows: type with index 0 is the lowest descendant, with index 1 is its immediate ancestor, etc.  by induction.  When transferring too many numbers, we should receive an error at compile time.  You can make such a class by defining a terminating specialization for index 0, and a more general definition for index N by specifying with index N is 1. We will define the <code>tuple</code> itself as <code>using</code> (or <code>typedef</code> ) in the inside of our ‚Äúindexer‚Äù.  Let's call our class plainly <code>TupleIndexer</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleIndexer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TupleIndexerDeeper = TupleIndexer&lt;INDEX - <span class="hljs-number"><span class="hljs-number">1</span></span>, REST ...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TupleType = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TupleIndexerDeeper::TupleType; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleIndexer</span></span></span><span class="hljs-class">&lt;0, T, REST ...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TupleType = Tuple&lt;T, REST ...&gt;; };</code> </pre><br><br>  Further we will use the fact that we did not use multiple inheritance, but built a chain of classes.  We will bring the current class <code>Tuple</code> to <code>Tuple</code> , calculated by index through <code>static_cast</code> .  To calculate the return value from the <code>Get</code> method, we will create a synonym for the left-most field in our <code>Tuple</code> and retrieve it from the <code>Tuple</code> obtained by the index. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tuple&lt;REST ...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LeftMemberType = T; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MemberTypeIndexed = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple::TupleIndexer&lt;INDEX, T, REST ...&gt;::TupleType::LeftMemberType; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TupleTypeIndexed = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple::TupleIndexer&lt;INDEX, T, REST ...&gt;::TupleType; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemberTypeIndexed&lt;INDEX&gt; &amp; Get() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }; template &lt;class T, class ... REST&gt; template &lt;unsigned int INDEX&gt; inline const typename Tuple&lt;T, REST ...&gt;::template MemberTypeIndexed&lt;INDEX&gt; &amp; Tuple&lt;T, REST ...&gt;::Get() const { return static_cast&lt;const TupleTypeIndexed&lt;INDEX&gt; *&gt;(this)-&gt;mMember; }</span></span></code> </pre><br><br>  The setter implementation is not shown because  it is identical to the getter.  Unfortunately, a full-fledged iteration over the index in this tuple is impossible (is it necessary?), Since  we need to know the type of the return value. <br><br><h5>  Subuple </h5><br>  The next stage that I would like to describe is the addition of the possibility of creating a tuple from some combination of other fields.  The simplest option is a template method that accepts a variable number of indices by which the fields will be taken and transferred to the constructor of the new <code>Tuple</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tuple&lt;REST ...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LeftMemberType = T; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MemberTypeIndexed = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple::TupleIndexer&lt;INDEX, T, REST ...&gt;::TupleType::LeftMemberType; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SubTupleTypeIndexed = Tuple&lt;MemberTypeIndexed&lt;INDICES&gt; ...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> SubTupleTypeIndexed&lt;INDICES ...&gt; MakeTuple() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple&lt;MemberTypeIndexed&lt;INDICES&gt; ...&gt;(Get&lt;INDICES&gt;() ...); } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br><br>  But this is not enough for us.  We implement a template method that accepts a range of indices and returns <code>Tuple</code> specific types with indices from a specified range.  Those: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> SubTupleTypeRanged&lt;A, B&gt; MakeSubTuple() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>;</code> </pre><br><br>  As you might have guessed, we need another auxiliary class that will allow us to calculate the type of <code>Tuple</code> returned by a range, not by an index.  To do this, we use a technique similar to the method from the FlexFerrum article.  Let's create a class that takes a range as template parameters (A and B) and stores a synonym for a certain class specified by indices from A to B. That class, in turn, will calculate for us the <code>Tuple</code> type.  Names for our classes will choose <code>Range</code> and <code>Indices</code> accordingly. <br><br>  An implementation of the <code>Indices</code> class that stores the appropriate type of <code>Tuple</code> template: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Indices</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubTupleType</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class">&lt;typename Tuple&lt;T, REST ...&gt;::template MemberTypeIndexed&lt;INDICES&gt; ...&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: };</code> </pre><br><br>  The implementation of the actual range: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> RangeLesser = Range&lt;A, B + (A &lt; B ? - <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IndicesExtendable = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RangeLesser::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> IndicesExtendable&lt;B, INDICES ...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Indices = IndicesExtendable&lt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> INDEX&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class">&lt;INDEX, INDEX&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IndicesExtendable = tuple::Indices&lt;INDEX, INDICES ...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Indices = IndicesExtendable&lt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: };</code> </pre><br><br>  In this case, the terminating branch is a range with equal beginning and end (length = 0).  The range with the length N determines the <code>IndicesExtendable</code> pattern through the <code>IndicesExtendable</code> pattern from the range with the length N - 1. Speaking in simpler language, we gradually tighten the range to a point with a step of one.  If you observe the type inference process in the opposite direction, then at each iteration of the range expansion a new synonym for the <code>IndicesExtendable</code> template <code>IndicesExtendable</code> added by adding a new template parameter ‚Äî another index to the synonym IndicesExtendable template from the previous iteration.  Thus <code>Range&lt;1, 4&gt;</code> will contain <code>Indices = Indices&lt;1, 2, 3, 4&gt;</code> .  This range class also works for the opposite case - <code>Range&lt;4, 1&gt;</code> .  This will give the type <code>Indices&lt;4, 3, 2, 1&gt;</code> . <br><br>  Another detail is connected with the fact that in the <code>MakeSubTuple</code> method we need to somehow call the constructor call with the correct fields as arguments.  You can do this by adding another <code>MakeTuple</code> method that takes <code>Indices</code> as a parameter.  This is another way to specify the template method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ... INDICES&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> SubTupleTypeIndexed&lt;INDICES ...&gt; MakeTuple(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Indices&lt;INDICES ...&gt; &amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>;</code> </pre><br><br>  The implementation of this method is similar to the first.  In the body of the method, the parameter is simply ignored.  Now we can make a call without passing template parameters: <br><br><pre> <code class="cpp hljs">t.MakeTuple(Indices&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;) <span class="hljs-comment"><span class="hljs-comment">//  ,   t.MakeTuple&lt;1, 2, 3&gt;()</span></span></code> </pre><br><br>  Now we are ready and we can go directly to the implementation of the <code>MakeSubTuple</code> method.  Simply we get the Indices we need from the Range, instantiate it on the stack or as a static variable and pass it to the advanced <code>MakeTuple</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REST</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tuple&lt;REST ...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SubTupleTypeRanged = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&lt;A, B&gt;::Indices::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> SubTupleType&lt;T, REST ...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> SubTupleTypeRanged&lt;A, B&gt; MakeSubTuple() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MakeTuple(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&lt;A, B&gt;::Indices()); } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br><br>  There are thoughts about implementing another <code>MakeTuple</code> method that accepts a variable number of template parameter types (specified <code>Indices</code> or <code>Range</code> , otherwise it is an error at the compilation stage).  The returned values ‚Äã‚Äãof this method are clearer by example: <br><br>  <code>Tuple&lt;char, int, double, float&gt;::MakeTuple&lt;Indices&lt;3, 3&gt;, Range&lt;0, 1&gt;, Indices&lt;2&gt;&gt;</code> will return <code>Tuple&lt;float, float, char, int, double&gt;</code> <br><br>  Two methods <code>MakeTuple</code> can be combined into one, giving the parameter a default value.  Hardly instantiating an empty class on the stack gives at least some significant overhead, so you should not worry about performance in this case. <br><br><h5>  Bonus </h5><br>  In addition, I would like to describe another quite interesting method - <code>Invoke</code> .  It takes as a parameter everything to which you can apply the function call operator with the parameters corresponding to the fields of our <code>Tuple</code> .  Our apparatus for working with <code>Tuple</code> already sufficiently developed to implement such a method without entering additional entities.  One BUT - in order not to concretize the method with field indexes to pass to the function / functor / lambda / etc, we will have to use the same trick again as in the case of <code>MakeSubTuple</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CALLABLE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INDICES</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoke</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CALLABLE</span></span></span><span class="hljs-class"> &amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Indices</span></span></span><span class="hljs-class">&lt;INDICES ...&gt; &amp;) {</span></span> _function(Get&lt;INDICES&gt;()...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CALLABLE</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoke</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CALLABLE</span></span></span><span class="hljs-class"> &amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">) {</span></span> Invoke(_function, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, mIndex&gt;::Indices()); }</code> </pre><br><br>  What is remarkable about this method?  And the fact that with it our <code>Tuple</code> class turns into a kind of core for the <code>Bind</code> class.  We give his announcement for completeness: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (ARGS ...)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Tuple = tuple::Tuple&lt;ARGS ...&gt;; Bind(Function _function, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ARGS &amp; ... _args): mFunction(_function), mTuple(_args ...) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mTuple.Invoke(mFunction); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Function mFunction; Tuple mTuple; };</code> </pre><br><br>  Of course, it does not take into account that <code>CALLABLE</code> may have a return type, but the solution to this problem is beyond the scope of this article. <br><br><h5>  Summary </h5><br>  In summary, I would like to note that all the methods of the <code>Tuple</code> class turned out to be quite fast, because  no calculations are used in runtime. <br><br>  <code>Variadic Templates</code> allow you to implement a tuple in a very compressed number of lines of code.  The only problem with duplication of code arises in the termination specialization of the <code><code>Tuple - Tuple.        ,      , ,       .        Get  .      <code>Get</code> .              . <br> <br>                .    <code>Get&lt;2&gt;</code>  <code>Tuple&lt;int, char&gt;</code> ,        ,          <code>Tuple</code> .     "" ,   ,     ,        <code>static_assert</code> . <br> <br>              <code>Tuple</code> ,    <code>Tuple&lt;char, double, member1, member2&gt;</code> ,     <code><code>Get  ,   .    , ..         C</code> ,        .    <code>Tuple</code>           .         ,      <code>compile time</code>      , ,   <code>Serialize</code>  .          <code>Tuple</code> . <br> <br>         .  <code>Tuple&lt;int, char, double&gt;</code>         <code>Tuple&lt;char, double&gt;</code>  <code><code>Tuple.         .         Tuple</code> ,    ,   , ,  , - ,         ,              . <br> <br>   <code>Tuple</code>   <a href="https://github.com/edvorg/tuple">github</a> . <br> <br>          readme,     . <br>        -    ,  ,  <code>append</code> , etc. <br>          . <br> <br>      main.cpp   ,    . <br> <br>  : <br> <a href="http://en.wikipedia.org/wiki/Variadic_template">en.wikipedia.org/wiki/Variadic_template</a> <br> <a href="http://habrahabr.ru/post/101430/">habrahabr.ru/post/101430</a></code></code></code></code> class <code><code>Tuple - Tuple.        ,      , ,       .        Get  .      <code>Get</code> .              . <br> <br>                .    <code>Get&lt;2&gt;</code>  <code>Tuple&lt;int, char&gt;</code> ,        ,          <code>Tuple</code> .     "" ,   ,     ,        <code>static_assert</code> . <br> <br>              <code>Tuple</code> ,    <code>Tuple&lt;char, double, member1, member2&gt;</code> ,     <code><code>Get  ,   .    , ..         C</code> ,        .    <code>Tuple</code>           .         ,      <code>compile time</code>      , ,   <code>Serialize</code>  .          <code>Tuple</code> . <br> <br>         .  <code>Tuple&lt;int, char, double&gt;</code>         <code>Tuple&lt;char, double&gt;</code>  <code><code>Tuple.         .         Tuple</code> ,    ,   , ,  , - ,         ,              . <br> <br>   <code>Tuple</code>   <a href="https://github.com/edvorg/tuple">github</a> . <br> <br>          readme,     . <br>        -    ,  ,  <code>append</code> , etc. <br>          . <br> <br>      main.cpp   ,    . <br> <br>  : <br> <a href="http://en.wikipedia.org/wiki/Variadic_template">en.wikipedia.org/wiki/Variadic_template</a> <br> <a href="http://habrahabr.ru/post/101430/">habrahabr.ru/post/101430</a></code></code></code></code> <code><code>Tuple - Tuple.        ,      , ,       .        Get</code>  .      <code>Get</code> .              . <br> <br>                .    <code>Get&lt;2&gt;</code>  <code>Tuple&lt;int, char&gt;</code> ,        ,          <code>Tuple</code> .     "" ,   ,     ,        <code>static_assert</code> . <br> <br>              <code>Tuple</code> ,    <code>Tuple&lt;char, double, member1, member2&gt;</code> ,     <code><code>Get  ,   .    , ..         C</code> ,        .    <code>Tuple</code>           .         ,      <code>compile time</code>      , ,   <code>Serialize</code>  .          <code>Tuple</code> . <br> <br>         .  <code>Tuple&lt;int, char, double&gt;</code>         <code>Tuple&lt;char, double&gt;</code>  <code><code>Tuple.         .         Tuple</code> ,    ,   , ,  , - ,         ,              . <br> <br>   <code>Tuple</code>   <a href="https://github.com/edvorg/tuple">github</a> . <br> <br>          readme,     . <br>        -    ,  ,  <code>append</code> , etc. <br>          . <br> <br>      main.cpp   ,    . <br> <br>  : <br> <a href="http://en.wikipedia.org/wiki/Variadic_template">en.wikipedia.org/wiki/Variadic_template</a> <br> <a href="http://habrahabr.ru/post/101430/">habrahabr.ru/post/101430</a></code></code></code> </div><p>Source: <a href="https://habr.com/ru/post/179153/">https://habr.com/ru/post/179153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../179141/index.html">Why is the work not an apartment?</a></li>
<li><a href="../179143/index.html">Away Builder. Or our proud Varyag does not surrender to the enemy.</a></li>
<li><a href="../179145/index.html">Boris is a small but reliable REPL for php</a></li>
<li><a href="../179149/index.html">MikroTik - quick setup of the access point</a></li>
<li><a href="../179151/index.html">Nexenta operating experience, or 2 months later</a></li>
<li><a href="../179155/index.html">A little more about migrations. PHP version</a></li>
<li><a href="../179159/index.html">xdebug in the hands of the administrator</a></li>
<li><a href="../179161/index.html">Diablo III's economy has been destroyed by integer overflow</a></li>
<li><a href="../179163/index.html">DevConf contest - dedicated to the Victory Day!</a></li>
<li><a href="../179167/index.html">Introducing GStreamer: Data Sources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>