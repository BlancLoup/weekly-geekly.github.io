<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Self-made drive emulator for Amiga</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have preserved Amiga computers at home. But here floppy disks for them were not preserved by everyone. This problem can be solved by assembling a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Self-made drive emulator for Amiga</h1><div class="post__text post__text-html js-mediator-article">  Many have preserved Amiga computers at home.  But here floppy disks for them were not preserved by everyone.  This problem can be solved by assembling a drive emulator.  On how to make such a drive emulator for the Amiga, I will discuss in this article. <br><a name="habracut"></a><br>  I thought for a long time where to place this article - here or on geektimes.  On the one hand, it concerns the development of microcontrollers, and on the other hand, it will focus on developing a device for a very old computer, the topic of which is geektimes.  However, geektimes describe the devices themselves and the programming for them on their API, but here, after all, the device is assembled on an almost modern element base. <br><br>  Some of the houses still have Amiga computers, someone could just give up such a computer (like me), and someone specifically bought it.  And sometimes it happens that there is a computer, but there is no hard drive on it (for example, I don‚Äôt have it on the Amiga 500), but I want to run something on it.  Messing with floppy disks (which can only be written to a PC using special devices) is not an option.  So people choose drive emulators.  Now they offer quite a lot, but a few years ago there were almost no such devices.  As far as I know, the first Amiga drive emulator made tnt23.  It was possible, of course, to buy an emulator from him, but I still wanted to try my hand at creating my own, especially since in trying to start this computer at that time I had already created a simple device for recording floppy disks, and the overall format of the diskette is not represented by  The described article was once written for Dogma magazine, but did not get into the issue of this magazine because it was simply forgotten about it.  However, I know there are amizhniki here and I think it will be interesting for them to read how you can make your own drive emulator.  Perhaps this information will push someone to create their device, much more perfect.  So, let's begin. <br><br>  The drive emulator described below is fairly simple to assemble and does not contain any parts in short supply.  The problem can only arise with the search for 30 SIMM contact modules with a capacity of 1 MB.  However, such modules were widely distributed and, most likely, they can be found on the radio market.  At Juno in St. Petersburg, they certainly were. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      List of parts for assembly: <br><div style="text-align:center;"><img src="https://habrastorage.org/web/62e/aed/084/62eaed084b0846688fa2c2e4944e24a1.bmp"></div><br>  The brand of capacitors, diodes, resistors, choke, buttons and SD card holder used does not matter.  Diodes are required with a voltage drop at a junction of at least 0.5 V. The display may be with other letter indices. <br><br>  The emulator is connected to the external drive connector and allows you to play the selected image of a floppy disk.  Floppy images are stored in the root directory on an SD card with the FAT16 file system.  The files are created by a special ADF file converter program and are byte data of a standard 80 track floppy disk encoded with MFM encoding.  No headers such files do not contain.  Due to the simplified circuit design, the emulator does not have the hardware ability to switch the drive lines to the Z-state, depending on whether drive A or B is selected. This means that all Amiga drives need to be hardware disabled during operation with the emulator.  However, the ability to recognize the address of the drive is theoretically provided by software - this requires that the microcontroller recognizes the address and translates the outputs to the Z-state if the address does not match the desired one.  Lines for reading the address of the drive on the diagram are provided, but this possibility is not implemented programmatically. <br><br> <a href=""><img src="https://habrastorage.org/web/17d/c49/95d/17dc4995ddb1420986e55fb5c730ad75.GIF"></a>  <i>Emulator scheme (in the archive it is in full quality).</i> <br><br><img src="https://habrastorage.org/web/425/70b/513/42570b5139eb4768ad7d842dfffb01e2.JPG"><br>  <i>The appearance of the emulator from the display.</i> <br><br>  Circuitry emulator consists of two parts.  Each part is based on an Atmega16 microcontroller.  The first part of the microcontroller is engaged in displaying information on the display, processing buttons, reading information from an SD card using hardware SPI, forming part of the drive lines.  The microcontroller of the second part deals with the regeneration of the dynamic memory and forms the remaining signals of the drive lines.  Both parts exchange information on the SPI bus.  For the D2 controller, the SPI bus is used to communicate with the D3 software, while the D3 uses hardware SPI. <br><br>  Let us consider in more detail the purpose of the elements.  Chip D1 provides power to the SD card with a voltage of 3.3 V. Diodes VD1-VD6 reduce the voltage of the SPI lines from 5 to 3.3 V. Resistors R1-R6 and R8-R9 attract the lines to ground.  RC-chains R7-C3 and R11-C5 form the initial reset signal of microcontrollers.  Elements Z1, C1 and C2 provide 16 MHz generation on the first microcontroller (D2).  The second microcontroller (D3) operates in the external synchronization mode from the clock generator of the first microcontroller.  Resistor R10 controls the contrast of the image on the display.  Elements L1 and C4 provide power supply voltage filtering. <br><br>  The hardware part of the drive emulator is assembled on a 220x125 mm board.  Printing one-sided, performed by any available method, for example, LUT.  On the opposite side of the board, you need to put a number of jumpers with wire (indicated by the blue tracks in the enclosed PCB file in Sprint Layout 4.0 format). <br><br>  The software part of the emulator consists of two programs for microcontrollers.  The program for the microcontroller D2 is in the folder MK1, and for the microcontroller D3, respectively, in the folder MK2.  After the microcontrollers are flashed with the appropriate HEX file in any way possible (including, for firmware, you can use the ‚Äúfive wires to the computer LPT port‚Äù scheme together with the Uniprof programmer program), you need to set the FUSE bits of the controller configuration.  Using these bits, you need to disable JTAG in both controllers, switch D2 to clocking from an external 16 MHz crystal, switch on D2 for increased signal amplitude from the output oscillator (CKOPT bit), and switch D3 to clocking from an external source.  If your programmer does not have its own clock, the controllers will not be available for programming after this operation.  In order for them to become programmable again, you need to connect any external generator with a frequency of several hundred kilohertz to the XTAL1 controllers.  Be sure to read them from the controller before modifying the FUSE bits.  Note that different programmers interpret the on and off bit differently. <br><br>  The emulator does not require adjustment after assembly.  However, perhaps not all SIMM 30 PIN modules will work with it correctly.  For this purpose, in the emulator menu there is an item ‚ÄúMEMORY TESTING‚Äù. <br><br>  To facilitate understanding of the operation of the emulator software, you need to know the following.  On a standard diskette, Amiga stores recorded data on 80 tracks on both sides.  Each track consists of 11 sectors of 512 bytes.  Therefore, the total data volume of a floppy disk is 901120 bytes.  This is the volume of ADF-files of floppy images.  This file does not contain headers, and the data inside is simply listed as follows: (track 0, side 0), (track 0, side 1), (track 1, side 0), (track 1, side 1) ... (track 79, side 0), (track 79, side 1).  Each track is a record of 11 sectors of 512 bytes, starting from sector 0.  To emulate a floppy disk such a file in its pure form is not suitable.  The fact is that the ADF file stores only useful data without any overhead information and without modulation.  Consider how the modulation of the signal in the Amiga computer. <br><br>  Any drive is nothing more than an analog tape recorder.  It does not encode the recorded data.  You select a track and modulate the current (and, therefore, the magnetic field strength) through the drive head to record information.  When playing in places where the magnetic field strength has changed, the drive reads a short pulse.  Amiga uses when writing to floppy disks modified frequency modulation, the so-called MFM (Modified Frequency Modulation).  With this modulation method, the change in current through the coil depends not only on the value of the bit being written, but also on the value of the previous bits, as shown in the table below.  In the ‚Äúcoded‚Äù column, R means a change in magnetization (giving a pulse to a disk drive), and N means that the magnetization does not change.  Further, in order to write the MFM file in binary format, we take R equal to 1, and N equal to 0. Two bits of magnetization change are written to the MFM file for one data bit.  Thus, the data size of the MFM file compared to the ADF file will be doubled.  But you can't just convert ADF to MFM.  Amiga uses its own format for writing to floppy disks, which need to be taken into account. <br><br><img src="https://habrastorage.org/web/5a9/f9e/d75/5a9f9ed756864197be522528799c3e43.PNG"><br><br>  We agree on the track number to name the track number on one of the disc sides (i.e. the track number varies from 0 to 79), and the track number to ((2 * track number) + disc side number).  The track number varies from 0 to 159, the disk side number varies from 0 to 1, the sector number changes from 0 to 11. <br><br>  In Amiga format, each track contains: <br><br><ol><li>  The initial gap (128 bytes of MFM code 0x00). </li><li>  The data of 11 sectors is 544 bytes per sector. </li><li>  End gap (704 bytes of MFM code 0x00) </li></ol><br>  Each sector contains: <br><br><ol><li>  Marker start sector. </li><li>  Sector ID (4 bytes: 0xFF, track number, sector number, sector offset. Sector offset is calculated as 11 minus the sector number on the track.) </li><li>  Sector label (16 bytes 0x00). </li><li>  Header checksum (4 bytes). </li><li>  Checksum data (4 bytes). </li><li>  Sector data (512 bytes). </li></ol><br>  The identifier and sector data are encoded by permuting the bits.  For the identifier, 4 bytes are taken and bits are swapped.  The odd bits come first (the numbering of the bits, as usual, with 0) ‚Äîit will be 2 bytes.  Then come the even bits - just 2 bytes.  The table illustrates the above.  The top line is the standard order of bits (numbers in the cells), the bottom is the result of the permutation. <br><br><img src="https://habrastorage.org/web/33c/646/232/33c646232f984185a4adbceea23f383c.PNG"><br><br>  Sector data is grouped by 2 bytes, and the permutation occurs within this pair in the same way: <br><img src="https://habrastorage.org/web/d91/95c/42a/d9195c42af1d41f689b7dfcec2459af1.PNG"><br><br>  The checksum is an exclusive OR (XOR) operation of all bytes of sector data or a header (taking into account the permutation of bits!), Grouped in 2 bytes.  The checksum itself is not subject to permutation of bits.  Although the field for the checksum is 4 bytes, the checksum itself will be two bytes. <br><br>  In addition to the 544 bytes of data encoded using MFM coding, each sector contains a special data start marker.  A marker is a combination of zeros and ones that cannot be obtained with MFM coding.  Such a combination is the combination 01000100100010010100010010001001 before recording of which 4 bytes are written with the combination 10101010. The first byte of the combination 10101010 depends on the previous bit issued by the MFM coding.  If the last sector bit issued was 1, then this byte will be 01000100, and if there was 0, then 10101010. <br><br>  Given all the above, the floppy disk track in MFM format looks like this: <br><br><ol><li>  Initial clearance: 128 bytes 00000000. </li><li>  Marker start data sector: <br><br>  10101010 (this byte depends on the last bit written and maybe 01000100) <br>  10101010 <br>  10101010 <br>  10101010 <br><br>  01000100 <br>  10001001 <br>  01000100 <br>  10001001 </li><li>  Sector data without marker: 1080 bytes per sector. </li><li>  Repeat from step 2 for all 11 sectors. </li><li>  End clearance: 704 bytes 00000000. </li></ol><br>  Total, each track in the MFM-coding takes (1080 + 8) * 11 + 128 + 704 = 12800 bytes of code.  If now this code is output to the data line from the drive, taking into account the temporary sweep of the track, then Amiga will be able to read the data of this track. <br><br>  The problem is that the data pulse duration is from 0.15 to 0.8 Œºs.  In this emulator, a pulse duration of 0.5 ¬µs is selected.  This means that at a frequency of 16 MHz, we will have 32 clocks per bit of the MFM code.  During these 32 clock cycles, the microcontroller D3 must regenerate the dynamic memory, read the MFM code byte, issue a magnetization change bit on the drive line.  To meet the 32 clock cycles, this part of the program is written in assembler and strictly aligned with the bars.  The byte read and memory regeneration operations are separated in time.  This means that as long as the MFM coding byte is issued, for each bit there are 32 clocks and for each output bit it is strictly defined what operations we are performing in these 32 clocks.  For example, when issuing bit 0, we can set a dynamic memory string (RAS signal).  When issuing bit 1, we can set the dynamic memory column (CAS signal).  When issuing bit 2, we read the next data byte issued.  And so on.  This way, the entire floppy image is issued. <br><br>  Actually, that‚Äôs the simplest drive emulator. <br><br>  Emulator video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rgatUnn2jgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://yadi.sk/d/lAWc0YBW3JzwFM">Archive</a> with printed circuit boards, firmware, diagrams and programs. </div><p>Source: <a href="https://habr.com/ru/post/330668/">https://habr.com/ru/post/330668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330658/index.html">How to make a beautiful avatar? New social media marketing</a></li>
<li><a href="../330660/index.html">Attention! Hackers have begun to use the SambaCry vulnerability to crack Linux systems</a></li>
<li><a href="../330662/index.html">Approaches to versioning database changes</a></li>
<li><a href="../330664/index.html">It was in the evening. An autoscale load-balanced web service using the example of Bitrix in the Google Cloud Platform</a></li>
<li><a href="../330666/index.html">Internet Magnets 5 - Lighthouses and Messages (Personal, Public, and Updates)</a></li>
<li><a href="../330670/index.html">Configuring Reverse Proxy Apache (Debian 8) with automatic issue of Let's Encrypt</a></li>
<li><a href="../330672/index.html">Making a dragon bot in Google Chrome</a></li>
<li><a href="../330674/index.html">Introducing 3CX Phone System V15.5</a></li>
<li><a href="../330676/index.html">Client-server step-by-step, from single-threaded to multi-threaded (Client-Server step by step)</a></li>
<li><a href="../330678/index.html">SPL programming language - an example of solving a problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>