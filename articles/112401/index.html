<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exposing font rasterization algorithms (1/2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An attempt to improve the rasterization algorithms of fonts, using only publicly available information. 

 From translator 
 The first time I ran into...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exposing font rasterization algorithms (1/2)</h1><div class="post__text post__text-html js-mediator-article">  <i>An attempt to improve the rasterization algorithms of fonts, using only publicly available information.</i> <br><br><h3>  From translator </h3><br>  The first time I ran into this article was in 2008.  Since then, I have repeatedly thought about the translation (as the best material on the topic is not found), and suddenly a link to the original <a href="http://habrahabr.ru/blogs/browsers/69442/">surfaced on Habr√©</a> in the discussion of the topic <a href="http://habrahabr.ru/blogs/browsers/69442/">"Font smoothing, anti-aliasing, and sub-pixel rendering</a> . <a href="http://habrahabr.ru/blogs/browsers/69442/">"</a>  This was the decisive factor (once the material is referred to, it means that someone needs it), and the work was finally completed. <br><a name="habracut"></a><br>  Some terms used have no generally accepted Russian counterparts.  I will translate anti-aliasing as anti-aliasing (as Wikipedia thinks, and I tend to agree with it), hinting as <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B3">hinting</a> (hinting, in my opinion, is not too melodious and not at all common word), and rendering as <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">rasterization</a> (as applied to fonts this term seems to me more appropriate than tracing from English; ‚Äúdrawing‚Äù is, in my opinion, a very general concept). <br><br>  For those who have not previously been interested in the topic of on-screen typography, it will be useful to read the above links before reading the article, and to understand what all these terms mean. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article was published in 2007, and the latest version of Windows, referred to in it - Vista.  Nevertheless, most of the article is relevant to this day: in Windows 7, font rasterization mechanisms are not far from Vista, and the tendency to transfer interfaces to the web platform added rasterization differences in different operating systems to rasterization differences in different browsers.  So, in my opinion, the ideas given in the article do not lose their relevance until now. <br><br>  I did not translate the texts in the screenshots: on the one hand, I did not have the technical ability to prepare correct images, on the other hand, the texts on them in no way affect the meaning of the article. <br><br>  I traditionally try to convert units to metric ones, except for those generally accepted in the Russian IT industry, such as DPI.  In addition, I translate the names, but leave the English names of the companies and their products. <br><br>  I would be grateful for any additions or corrections of the translation.  For obvious errors and typos, please write private messages - we will not clutter up comments.  Thank. <br><br><h3>  Introduction </h3><br>  Joel Spolsky in his article <a href="http://www.joelonsoftware.com/items/2007/06/12.html">‚ÄúFont Smoothing and Sub-Pixel Rendering‚Äù</a> [1] ( <i><a href="https://habrahabr.ru/post/18291/">the same article in an earlier translation on Habr√©</a> , approx. Translation</i> ) compares text rasterization methods in Microsoft and Apple products, and makes a guess why Windows users do not like Safari.  He explains this by saying that the text in Safari looks overly blurry.  I want to go further and summarize my own experience on this issue.  I am not an expert in digital typography, however, I have something to say.  At a minimum, some of my ideas can be useful to the GNU / Linux community. <br><br>  Jeff Atwood in his post <a href="http://www.codinghorror.com/blog/archives/000885.html">"Rasterization of fonts: stick to the grid of pixels"</a> [5] writes: <br><br><blockquote>  ‚ÄúI don‚Äôt understand why Apple sacrifices the present to the future.  Why we can not use hinting at low resolutions, while respecting the accuracy of rasterization at high?  Binding fonts to the grid of pixels is likely to be irrelevant when everyone can enjoy a great picture on the screen of his monitor with a resolution of 200 DPI.  But as long as this wonderful time has not come, snapping to the grid of pixels uniquely makes the text much more readable for those who live in the present. ‚Äù </blockquote><br>  I would answer this way: as long as Microsoft adheres to its aggressive hinting policy, monitors with a resolution of more than 100 DPI simply do not appear.  Through the efforts of Microsoft, we just can‚Äôt break out of the vicious circle. <br><br>  Jeff does not approve the rasterization method used in Apple products.  He is not very cute to me either.  But maybe Apple‚Äôs mission is to bring closer the era of 200 DPI monitors?  Well, my bar is even higher, I want 300 DPI.  According to my feelings, even 200 DPI is not enough to completely abandon the hinting.  However, in this article I will try to highlight Apple‚Äôs strategy as well.  The article may seem long and boring, but I feel the need to carefully and thoroughly analyze the situation. <br><br>  To add a little bit of intrigue, I'll look ahead and show you some examples. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3a/8f7/740/c3a8f7740b8e8560e2377ab72a72b8cd.png"><br><br>  Looks blurry?  But pay attention to the size of the text.  And keep in mind that it remains perfectly readable, smooth and at the same time clear.  And at the same time, the shape of the characters is fully preserved (using the ‚ÄúArial‚Äù headset). <br><br>  Ok, how about this example? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78d/1ce/933/78d1ce9335be838c153f7102bcd51ebf.png"><br><br>  Looks too heavy?  No problem, we can make it brighter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a3/49f/7fd/2a349f7fd8dc3a95ae1dd1f4bbdd0f85.png"><br><br>  And a couple more examples: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b16/6a0/039/b166a0039f0454f5f51b5681bb3679f7.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a9/170/0b9/2a91700b90cf72851f048192d250c4a2.png"><br><br>  This is a Georgia font.  Please note that the shape of the characters in both cases is perfectly preserved, just in the second example, the text is intentionally made more ‚Äúheavy‚Äù. <br><br>  But it was just a demonstration, this is the main idea of ‚Äã‚Äãthis article: we can refuse to snap to the pixel grid horizontally!  From this point on, you can use the horizontal positioning accuracy of the text in 1/256 pixels!  You can move the text horizontally to any fractional value, while maintaining the beautiful appearance of the text!  This "little thing" really means a lot.  How about this: <br><ul><li>  You can apply subpixel kerning without worrying about adding an extra blur. </li><li>  You can freely scale the text as you like, with an absolute guarantee of preserving the proportions and the absence of text falling outside the boundaries of graphic elements. </li><li>  You can be sure that the calculated width of the text will always correspond to the image on the screen and on paper. </li><li>  You can apply interesting vector effects, such as ‚Äúartificial bold‚Äù or ‚Äúartificial italics‚Äù, without risking a blurred text. </li></ul><br>  Sounds like something impossible?  Well, here is another example. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/669/fbb/64d/669fbb64d506958a75bfbbd74836b7bf.png"><br><br>  Look carefully.  Have you noticed anything strange?  Each row is shifted to the right by one tenth of a pixel, so that as a result, by the 30th row, the offset smoothly accumulates, and is already three pixels.  I think you can imagine what this example would look like if we used the classic snap to the grid of pixels. <br><br>  If you have no idea, here is an example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/070/12b/f6a/07012bf6a5a35d9c43613743193b851e.png"><br><br>  The most amazing thing is that there is nothing fantastically complicated!  There is nothing even to patent.  All the information that I used is available publicly and / or logically derived from what we know about the currently used font rasterization algorithms.  You just need common sense and some engineering flair.  So let's go.  You can download the demo program with all the sources at the end of this article and play with it, but first, please show some patience to read this rather long story to the end. <br><br><h3>  Microsoft, Apple, Adobe and FontFocus </h3><br>  I'll start with a pretty hard statement.  Microsoft played a cruel joke with the rest of the world.  The way to rasterize fonts in Windows XP is a bad taste with a complete lack of engineering culture.  The text in XP looks clear and attractive, but it is completely wrong. <br><br>  A little test.  Imagine that we have one line of text typed in a Times New Roman headset and printed in high resolution (say, exactly 1000 DPI).  This line takes on paper 87% of a given distance (suppose, 12.7 cm).  Now we need to get a proportional image in low resolution, say, in 100 DPI so that our 12.7 cm corresponds to exactly 500 pixels.  Is there a way in Windows to display text that occupies exactly 87% of 500 pixels?  Not!  This is evident from the screenshots below.  They are removed with Windows XP, ‚ÄúDisplay properties -&gt; Options -&gt; Advanced -&gt; General -&gt; Scale (dots per inch) -&gt; Special settings ...‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/407/6d4/43f/4076d443f7d17014546a9a90f2401fe7.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/423/758/34b/42375834ba2aa8eac8ff62411914b219.png"><br><br>  They ( <i>Microsoft. Approx. Transl.</i> ) Sacrificed the honor of engineers for the sake of money, which led to a lack of technical progress ( <i>in increasing the resolution of monitors, approx. Transl.</i> ) For many years.  They use excessively aggressive hinting, which not only distorts the shape of the characters, but also accumulates a significant error ( <i>in horizontal coordinates, approx. Transl.</i> ) Throughout the entire line.  As a result, fonts cannot be considered freely scalable, they only look scalable, but in reality this is not the case.  This fact has affected the computer monitors industry.  Can you imagine Windows XP on a monitor with a resolution of 600 DPI?  Say 8000x6000 pixels?  I can not, and not only because of the raster pictograms, but mainly because of the terrible scaling of the text.  If you change the resolution in the properties of the screen, some dialog boxes in programs will inevitably be displayed incorrectly.  Accordingly, what is the motivation to produce high-resolution monitors? <br><br>  You might argue that software designers should take into account different font sizes.  I would agree with you if it were not for one small detail.  Creating 100% correct dialog boxes is monstrously tedious.  In Windows Vista, free scaling is implemented much better, but the situation has already developed, and it will take a long time before it is corrected.  In other words, we cannot freely scale dialog boxes. <br><br>  Some time ago I worked for Johnson &amp; Johnson (hi Dimitris Agrafiotis and other colleagues) and I had to design complex dialog boxes for the .Net WinForms platform.  By default, something like "Tahoma, 10pt" was used for any static or editable text.  But I constantly had to worry about some extra free space at the end of each line of text, because after changing the resolution, the text did not regularly fit into the allotted space, and it was absolutely impossible to use forms.  So if you are worried about proportional scaling, you have to arrange your forms in a terrible way, leaving a large amount of free space in reserve.  Another way is to tightly bind the size of the text to the pixels.  That is, use something like ‚ÄúTahoma 14px‚Äù ( <i>note, px, not pt. Comment. Transl.</i> ).  It means a lot.  This means that your software can not be used at high resolutions.  No matter how well Windows Vista supports text scaling: anyway, trouble has already happened.  There is a huge amount of software that relies on a fixed resolution and this does not allow monitor manufacturers to develop high-resolution screens.  There is no motivation!  You should not blame me and many other software developers and designers.  Blame Microsoft for their brutal hinting, which leads to unpredictable creeping of text on graphic elements. <br><br>  Yes, in Windows Vista using WPF, everything becomes freely scalable.  It's a good news.  The bad news is that you still can't use high resolutions.  The problems are described in detail by Long Zeng and Jim Matthews: <br>  Long Zheng, Windows Vista DPI scaling: my vista is bigger than your vista. <br>  <a href="http://www.istartedsomething.com/20061211/vista-dpi-scaling/">www.istartedsomething.com/20061211/vista-dpi-scaling</a> <br>  Jim Mathies, XP Style DPI Scaling. <br>  <a href="http://www.mathies.com/weblog/%3Fp%3D908">www.mathies.com/weblog/?p=908</a> <br><br><h4>  Microsoft and Adobe: subpixel positioning and kerning </h4><br>  In Microsoft Word, which is built on the principle of WYSIWYG, it is important to preserve the correctness of the markup at any resolution.  This means that the markup must be freely scalable, and it is truly scalable.  But let me do a little investigation.  Below is the text as it looks in Microsoft Word from the Office 2003 package. It makes no sense to read this text, just take a look at it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b32/936/c1c/b32936c1cdaa2fa644cc7457d6e42373.png"><br><br>  And compare with how it looks in Adobe Acrobat Reader: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a79/7f8/aeb/a797f8aebeb37109b3876945bf27e12d.png"><br><br>  You can better feel the difference if you download both images and switch between them in some program that supports the slideshow (I use nice and free <a href="http://www.irfanview.com/">IrfanView</a> ).  The text in Adobe Acrobat looks more evenly, besides, it is much closer to what we see on the printer.  The text in MS Word looks clearer, but in general it is uglier.  Why?  Because of the kerning curve.  It looks like they refuse to kerning at all at low resolutions (and 96 DPI is very little).  Snapping glyphs to pixels ultimately results in randomly scattered spaces that look just awful.  There is only one way to make the text look better - use horizontal sub-pixel positioning.  This is a physical law closely related to <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%259A%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B0">the Kotelnikov theorem</a> (in the English-language literature, the Nyquist ‚Äì Shannon theorem or the reading theorem), which says: <br><br><blockquote>  If an analog signal has a limited spectrum, then it can be recovered unambiguously and without loss in its discrete readings taken at a frequency of strictly more than twice the maximum frequency of the spectrum. </blockquote><br>  In our case, the signal spectrum we mean the sampling rate.  In practice, this means that you cannot correctly display a set of vertical lines at the same time clearly and at equal intervals as long as the intervals are multiples of pixels.  Either the distance between the lines will jump, or some lines will look blurry.  There is no other choice, period. <br><br>  Pierre Arnaud demonstrated this in a more <a href="http://article.gmane.org/gmane.comp.graphics.agg/3597">understandable way</a> : <br><br><blockquote>  Suppose you need to display a glyph for the character ‚Äúi‚Äù, which will be exactly 2.4 pixels wide.  If you are using hinting, you will most likely get an image 2 pixels wide at the output.  Suppose we have a space equal to four pixels. <br>  Now imagine that you need to print "iiiiiiiiii" (glyph "i" 10 times).  This will give us the word, which occupies 20 pixels on the screen, but the typographical position should move by 24 pixels.  You will have to add 4 pixels to the subsequent space, actually doubling its size.  It will look quite strange on the screen.  Even worse, the ‚Äúi‚Äù glyph really takes 2.6 pixels, and the hinter decides to stretch it to 3 pixels.  In this case, you will occupy 30 pixels on the screen, although the typographical position should have shifted by 26 pixels.  In this case, you will get an error of -4 pixels, and compensation for this error will completely eat the subsequent space. <br><br>  Another attempt might be to position the glyphs ‚Äúi‚Äù rounding their typographical positions.  As a result of this approach, we would get the following coordinates along the x axis (in the case of a 2.4-pixel glyph width): <br><br><pre> x = 0 ----&gt; 0 error = 0 width = 2
 x = 2.4 -&gt; 2 error = -0.4 width = 3
 x = 4.8 -&gt; 5 error = +0.2 width = 2
 x = 7.2 -&gt; 7 error = -0.2 width = 3
 x = 9.6 -&gt; 10 error = +0.4 width = 2
</pre><br>  The result will be terrible: <br><br><pre> . *. * .. *. * .. *
 ............
 . *. * .. *. * .. *
 . *. * .. *. * .. *
 . *. * .. *. * .. *
 . *. * .. *. * .. *
</pre><br>  You get the idea ... The intervals between the glyphs ‚Äúi‚Äù become variable. </blockquote><br>  Yes, they are.  This is exactly what is happening in Microsoft Word. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/fd5/70f/9e2fd570f5017e0093923dbc6121fcb9.png"><br><br>  Thus, Microsoft does not allow sub-pixel positioning, while Adobe does.  This means that the same glyphs in different positions can produce different actual displays on the screen.  This is clearly visible in the word ‚Äúinstitutions‚Äù, marked with a red box in the examples above. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e31/dcf/824/e31dcf8242dfbadf0c0db8f0ca7c4b7b.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/408/ef4/186/408ef418668c7b4c99bdc58a46d2ae3a.png"><br><br>  Take a look at the Adobe's glyphs ‚Äúi‚Äù, ‚Äún‚Äù, ‚Äús‚Äù, ‚Äút‚Äù.  There are at least two different versions of their display in different positions.  That is why the text in Adobe looks more uniform, but at the same time more blurred. <br><br>  Now, if you type the same word ‚Äúinstitutions‚Äù in WordPad, the result will be different (and it will look much better).  So why does he look so bad in MS Word?  Only because of visual inaccuracies in positioning.  The TextOut () function, which, apparently, is used in WordPad, does not care about it, but MS Word is forced (in <i>order to maintain the correct markup when scaling, approx. Transl.</i> ).  I‚Äôm not sure one hundred percent, but I can assume that the MS Word developers are calculating the displacement of the glyphs at high resolutions with non-sorted glyphs.  There is only one way to do this, using the documented Win32 API, to call GetGlyphOutline () with a greatly increased affinity matrix so that the resulting glyph fits into a rectangle of 1024x1024 or so.  Direct use of this technique gives exactly the same result as TextOut ().  It looks good, but it accumulates a tangible error throughout a line of text (larger than the size of one character over just one word!). <br><br>  In the case of dialog boxes, it seems to me, they decided that it was acceptable not to keep the exact width of the text.  Why?  Because otherwise, captions, menus, dialog boxes and the like would not look so tempting.  There would be the same problem with randomly scattered kerning, which would obviously harm the sales of their software.  So, nice and sharp text in dialog boxes contributes to business, but accumulates significant inaccuracy in the width of text, which makes it impossible to change the size of dialog boxes, and this, in turn, forces manufacturers to produce monitors with 96 DPI - as a result we have a vicious circle which eventually turned into a great profanation. <br><br>  From a purely engineering point of view, there should be a reasonable compromise between text clarity and functionality.  The problem is that Microsoft has focused on the glamorous design, while completely ignoring the functional part.  Paradox: at a resolution of 300 DPI you don‚Äôt need hinting at all, besides, the text becomes freely scalable (and at a resolution of 600 DPI and higher you don‚Äôt even need anti-aliasing), but you cannot use your software at 300 DPI because calculated at best at 100 DPI!  Here is the price that the whole world pays for glamorous design.  This price is too high, just incredibly high. <br><br>  Despite this, another 5 (five!) Years ago it was technically possible to have freely scalable forms and dialog boxes.  All we needed was to allow a certain degree of blur, very small, not as high as in Mac OS X. Rather, as in Adobe products.  Windows users do not like Safari for too vague output.  I partially agree with them, with the exception of blind denial of any other rasterization methods, except those used in Windows.  This is just reckless fanaticism.  It is like saying ‚ÄúI don‚Äôt care about resolution, let Windows look like I‚Äôm used to, even at 96 DPI forever, even if you need to stop technical progress.‚Äù  Can such a view be considered reasonable? <br><br>  I am not agitating in favor of Apple, since I, too, am not happy with the rasterization of Apple.  In my opinion, it really looks overly blurred.  It seems that they use something like an auto quoting algorithm, which blurs horizontal strokes, but in fact does not provide any advantages.  In fact, their hinting also looks crooked, especially for sans-serif fonts, as if they specifically shifted clear text by 0.2 ... 0.5 pixels.  That is why Windows users do not like Safari so much.  But at the same time, many of them gladly use the Adobe Acrobat Reader and are satisfied.  This is because the text in it looks acceptable (not perfect, but acceptable for Windows fans).  At the same time, it remains freely scalable!  Just try to load any document and smoothly increase or decrease it.  The markup of the text remains correct, and at the same time kerning also.  So I would call the Adobe rendering method the best because their trade-off looks very close to optimal. <br><br><h4>  Subpixel positioning with ClearType: is it possible? </h4><br>  Jeff Atwood [5] <a href="http://www.codinghorror.com/blog/archives/000885.html">unequivocally speaks</a> in favor of strict binding to the pixel grid.  I have my own opinion.  I agree to reckon with the pixel grid, but only along the Y axis. For X, it is preferable to use sub-pixel positioning.  At the same time, we sacrifice harshness (but only slightly), but we gain complete freedom. <br><br>  The irony is that Microsoft already has subpixel positioning in hinting glyphs.  The funny thing is: it is clearly visible on the pages of Jeff with the font that he uses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/6c9/1c1/ec16c91c17761a4de1edf82ff5942570.png"><br><br>  Look carefully: the word ‚Äúcommon‚Äù, highlighted in red, as well as the letter ‚Äúm‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95a/ff5/a6a/95aff5a6a19ca254de042568ed5696bf.png"><br><br>  See, the three vertical ‚Äúm‚Äù strokes are different!  Despite this, in the original text they look quite clear and attractive.  What does it mean?  Much.  This means that with ClearType it is possible to use positioning with an accuracy of 1/3 pixel.  So why do they attach glyphs to pixels ?!  I do not understand this.  Accuracy of 1/3 pixel would be enough for accurate kerning and at the same time clear text!  Well, if I have not convinced you yet, I will demonstrate in details.  I took a screenshot of a line of text from Microsoft Word.  He looked like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/657/5ba/47a/6575ba47ad004088913037d3f565a08c.png"><br><br>  Then, using simple software manipulations, I converted the colors to a bitmap that allows three values ‚Äã‚Äãof each color: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95a/b12/93f/95ab1293fc789e8e89dc51c8592c6e24.png"><br><br>  And then I produced the ‚Äúalpha blending‚Äù of this map in the RGB color model, perceiving each color channel as a separate gray pixel.  I did this 12 times with an offset of 1 gray pixel, getting 1/3 pixel offset in RGB.  See what happened: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4eb/69f/bf0/4eb69fbf09524ac8dd2f279aa5b4d5f1.png"><br><br>  But this is subpixel positioning!  You can easily verify this: 4 extra pixels have accumulated over 12 lines, while the clarity of the characters has not suffered.  Well, the lines are slightly different, but you have to look at them very closely in order to notice this (I note that my eyesight is one and I don‚Äôt wear glasses).  Believe me, this is a very low price for the freedom of accurate sub-pixel positioning!  So it works.  It is quite possible.  Why don't you use subpixel positioning, dear Microsoft, answer!  No answer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb3/4c9/fe2/cb34c9fe2fa598181fa2e54f249df1e9.png"><br>  By the way, is there any sub-pixel positioning in Windows Vista?  Looks like no.  In any case, I could not find a single example where the same glyph would be rasterized into different sets of pixels in different positions.  You see, they slightly increased the default font size (for 96 DPI), but, more noticeably, they increased the inter-character spacing so that incorrect positioning was less conspicuous.  This is good, but what about more accurate forms of characters?  I have to admit that the digital typography situation has not improved much since the release of Vista.  And we can hardly expect that it will change in the near future. <br><br>  Another big question is the name "Microsoft ClearType Font Collection".  Why do they call it the ClearType font collection?  Is this technology tied to specific fonts?  Then, again, this technology gives the impression of a very highly specialized local solution, so it cannot be successfully applied to absolutely any font.  Below I will demonstrate how using the FreeType autochinter you can get an honest, universal and font-independent rasterization method.  All you need is vector glyph curves.  Nothing else. <br><br><h4>  The way that FontFocus aligns the pixel grid </h4><br>  Jeff, among other things, refers to the <a href="http://artofcode.com/fontfocus">documentation for FontFocus</a> [4].  With all due respect, I have to disagree with her. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cad/5b5/8f2/cad5b58f2ec7810a04ed3c514e09c69d.png"><br>  They align the strokes by pixels, while ignoring the vertical hinting.  You see, the characters ‚ÄúT‚Äù, ‚ÄúW‚Äù, ‚ÄúC‚Äù and ‚Äúg‚Äù are very blurred.  In addition, the "W" looks heavier than the rest. <br><br>  In my opinion, it looks pretty careless.  The implication is that this is Times New Roman.  Seem to be?  No, more like a primitive raster font.  So what's the point?  Wouldn't it be easier once to save the font as a bitmap and use it at low resolutions?  What is the point of smoothing if we can afford to distort the shape of the signs?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it seems that the text has ‚Äúspots‚Äù, as if it was written in ink on a soft napkin: most of the strokes are correct, but in some places they are smeared. In any case, the problem is the same: either you refuse the correct markup, or you get a kerning curve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I want to mention Safari again. I can not say with complete certainty, but it seems that Mac OS also does not use subpixel kerning, which ultimately leads to the problems I wrote above, criticizing the approach of Microsoft. The Safari method is much closer to getting the correct markup while maintaining the correct positioning of the characters, but it looks like they are also tightly tying the characters to the pixels, and no matter how blurry the result is. So what is their policy? Specially use rasterization, which (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at low resolutions - approx. </font><font style="vertical-align: inherit;">trans. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) gives a very blurry text, only so that people buy screens with higher resolution? </font><font style="vertical-align: inherit;">Foul play! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below you will see how to achieve a pleasant and correct display of the text, and, most interestingly, as a result of very simple manipulations. </font><font style="vertical-align: inherit;">I used </font></font><a href="http://freetype.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the FreeType</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font><a href="http://freetype.org/"><font style="vertical-align: inherit;">library</font></a><font style="vertical-align: inherit;"> and the GetGlyphOutline () function from the Win32 API. </font><font style="vertical-align: inherit;">In other words, such a rasterization scheme is possible both in Windows and Linux, and, of course, in Mac OS, in which FreeType also compiles perfectly. </font><font style="vertical-align: inherit;">In addition, I found out that the FreeType autochinter works quite correctly if you use it the way I did (under normal conditions, the result of its work cannot be called acceptable). </font><font style="vertical-align: inherit;">But first, I‚Äôll talk about the situation in the Linux world.</font></font><br><br> <a href="http://habrahabr.ru/blogs/typography/112400/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continued ...</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/112401/">https://habr.com/ru/post/112401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112393/index.html">Who will take a pack of tickets, he will receive a water pump!</a></li>
<li><a href="../112394/index.html">Monoids and their applications: monoidal calculations in trees</a></li>
<li><a href="../112396/index.html">The creators of Pirate Bay are planning to launch Music Bay</a></li>
<li><a href="../112399/index.html">‚ÄúWhen ideas are worth something‚Äù or what if the scheme is ‚Äúflipped‚Äù?</a></li>
<li><a href="../112400/index.html">Exposing rasterization algorithms fonts (2/2)</a></li>
<li><a href="../112402/index.html">The fastest settings for PHP scripts</a></li>
<li><a href="../112404/index.html">Universal solution for printing on network printers under Windows 7 / Vista / 2003/2008</a></li>
<li><a href="../112405/index.html">50 start-up meetings</a></li>
<li><a href="../112407/index.html">A couple of new templates</a></li>
<li><a href="../112408/index.html">Site frame in one click</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>