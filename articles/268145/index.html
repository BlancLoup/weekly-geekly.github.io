<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network system calls. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We ended the previous part of the discussion on such an optimistic note: "In a similar way, we can change the behavior of any Linux system call." And ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network system calls. Part 3</h1><div class="post__text post__text-html js-mediator-article">  We ended the <a href="http://habrahabr.ru/post/267773/">previous part of the discussion</a> on such an optimistic note: "In a similar way, we can change the behavior of any Linux system call."  And here I was a goof - any ... yes, not any.  The exception is (can be) a group of network system calls that work with BSD sockets.  When you encounter this artifact for the first time, it is pretty puzzling. <br><a name="habracut"></a><br><h1>  How does a socket call occur? </h1><br>  To clarify the picture, we use the notes of one of the direct developers of the Linux network subsystem: <br>  <a href="http://isomerica.net/~dpn/socketcall1.pdf">Network systems calls on Linux</a> (2008).  I will briefly retell its main content (in the part of interest to us) to whom it is not interesting to use the original. <br><br>  When BSD sockets support was added to the Linux kernel, the developers decided to add them all 17 (currently 20) socket calls at the same time, and added one additional <b>level of indirection</b> for these calls.  For the entire group of these calls, one new, rarely mentioned, system call has been introduced (see man socketcall (2)): <br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socketcall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> call, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *args )</span></span></span></span>;</code> </pre> <br>  Where: <br>  - call ‚Äî the numerical number of the network call (SYS_CONNECT, SYS_ACCEPT ... we will see them soon); <br>  - args - pointer of 6-element array (parameter block), in which all parameters of any of the system calls of this group (network) are sequentially packed, without distinguishing their type (reduced to unsigned long); <br><br>  But such a macro in the kernel (&lt;net / socket.c&gt;), in which how many parameters are actually used for each of the socket calls, depending on its number (in the range from 1 to 20): <br><pre> <code class="hljs vala"><span class="hljs-comment"><span class="hljs-comment">/* Argument list sizes for sys_socketcall */</span></span> #define AL(x) ((x) * sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsigned <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> nargs[ <span class="hljs-number"><span class="hljs-number">21</span></span> ] = { AL(<span class="hljs-number"><span class="hljs-number">0</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">2</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>), AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">4</span></span>),AL(<span class="hljs-number"><span class="hljs-number">4</span></span>),AL(<span class="hljs-number"><span class="hljs-number">4</span></span>),AL(<span class="hljs-number"><span class="hljs-number">6</span></span>), AL(<span class="hljs-number"><span class="hljs-number">6</span></span>),AL(<span class="hljs-number"><span class="hljs-number">2</span></span>),AL(<span class="hljs-number"><span class="hljs-number">5</span></span>),AL(<span class="hljs-number"><span class="hljs-number">5</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>),AL(<span class="hljs-number"><span class="hljs-number">3</span></span>), AL(<span class="hljs-number"><span class="hljs-number">4</span></span>),AL(<span class="hljs-number"><span class="hljs-number">5</span></span>),AL(<span class="hljs-number"><span class="hljs-number">4</span></span>) }; #undef AL</code> </pre><br>  (Moreover, narg [0] <b>is not used at all</b> , because its dimension and 21.) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The number of the socket call to the kernel space (int 0x80 or sysenter) is passed in the eax register.  We can see the values ‚Äã‚Äãof these constants themselves in user space headers (&lt;linux / net.h&gt;): <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_SOCKET 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_socket(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_BIND 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_bind(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_CONNECT 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_connect(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_LISTEN 4 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_listen(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_ACCEPT 5 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_accept(2) */</span></span></span><span class="hljs-meta"> ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_SENDMSG 16 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_sendmsg(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_RECVMSG 17 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_recvmsg(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_ACCEPT4 18 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_accept4(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_RECVMMSG 19 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_recvmmsg(2) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYS_SENDMMSG 20 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sys_sendmmsg(2) */</span></span></span></span></code> </pre><br>  Actually, the processing scheme by this point should already be clear: <br>  - the required number of parameters of the system call is packed into the unsigned long array, the largest number of parameters (6) for SYS_SENDTO = 11 (nargs [11]): <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> sendto( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sockfd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct sockaddr *dest_addr, <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> addrlen );</code> </pre><br>  - the address of the generated array is transmitted by the 2nd parameter of the system call, the first parameter is the number of the socket call (for example, SYS_SENDTO); <br>  - all socket calls are processed by a single kernel handler sys_socketcall () (__NR_socketcall = 102); <br>  - the processor first copies from the user space an array of parameter values, and then, depending on eax, copies from the user space the following and data areas indicated (possibly) by the pointer values ‚Äã‚Äãfrom this parameter array. <br><br>  Some new architectures (as in the original) do not use such an indirect method of calling, but use the same implementation for these calls as for all other system calls.  So it is implemented, in particular, for X86_64 and ARM.  Thus, even 64-bit and 32-bit (emulated in the X86_64 system) applications will run according to a different scheme.  But let's not get distracted by this ... <br><br>  To make sure that the service of socket calls in 32 and 64 bit systems is carried out in different ways, you can, if in the user space application directory (C header files of the C language, &lt;i386-linux-gnu / asm&gt;), consider, for comparison, determine a set of system calls for 32 and 64 bit modes: <br><pre> <code class="bash hljs">$ cat unistd_32.h | grep socketcall <span class="hljs-comment"><span class="hljs-comment">#define __NR_socketcall 102 $ cat unistd_32.h | grep connect</span></span></code> </pre><br><pre> <code class="bash hljs">$ cat unistd_64.h | grep socketcall $ cat unistd_64.h | grep connect <span class="hljs-comment"><span class="hljs-comment">#define __NR_connect 42</span></span></code> </pre><br>  In a 32-bit system, there is a sys_socketcall () call, but there are no calls for each of the 20 socket calls.  Conversely, in a 64-bit system there is no system call such as sys_socketcall (), but there is a complete set of system calls for each of the 20 socket calls. <br><br>  The author himself notes in conclusion, as an assessment, he writes the following: <i>This technique seems rather ugly at first glance, when compared with modern methods of object-oriented programming, but there is also a certain simplicity in it.</i>  <i>It also stores data in a compact way, which improves cache hit rate.</i>  <i>The only problem is that the sample must be made manually, which means that it is easy to shoot yourself in the foot.</i> <br><br><h1>  Implementation </h1><br>  The possibility of intercepting network system calls will be illustrated on the layout of a distributed firewall (to simplify it as much as possible).  At one time, this idea was very much worn, as a firewall implementation for large and extra-large networks (especially in Cisco environments).  There are many publications on this topic, for example, two of them that give a complete picture of what is understood as a distributed firewall: <a href="https://www1.cs.columbia.edu/~smb/papers/ccs-df.pdf">Implementing a Distributed Firewall</a> and <br>  <a href="http://repository.lib.ncsu.edu/ir/bitstream/1840.16/7122/1/etd.pdf">Automated Implementation of Stateful Firewalls in Linux</a> . <br><br>  The proposal is to control not all TCP / IP traffic at the level of IP packets, but to implement the rules on each extra-large network host only for the TCP protocol and only at the time of establishing the connection.  Only 2 system calls get under control: accept () and connect ().  A deeper discussion of a distributed firewall would take us very far away from our goals ... let's look only at how we could control these network calls. <br><br>  As an illustration of the implementation of the interception of socket calls, a module of such a network filter was implemented in the kernel for accept () and connect () calls.  This module is made in the most simplified (truncated) implementation: as parameters, the module receives an IP address (deny parameter) and TCP port (port parameter) as parameters, connections with which should be denied (and one more additional parameter debug - diagnostic output level) . <br><br>  <b>Note:</b> In the tested version, the forbidden IP addresses and TCP ports were allowed to be multiple, stored in a cyclic list of type struct list_head (as is common in the kernel), and were placed (or deleted) by a separate application ‚Äî the user space policy daemon.  The filter is in the kernel and should function in some similar way, but this is too cumbersome for an article describing the principle, especially since it is not the firewall principle, but the principle of working with network system calls.  With all the simplifications, the code is still too big, so I will tag it under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">So, the code of the example module:</b> <div class="spoiler_text"><pre> <code class="hljs dos">static int debug = <span class="hljs-number"><span class="hljs-number">0</span></span>; // debug output level: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> module_param( debug, uint, <span class="hljs-number"><span class="hljs-number">0</span></span> ); static char* deny; // string parameter: denied IPv4 module_param( deny, charp, <span class="hljs-number"><span class="hljs-number">0</span></span> ); static int port = <span class="hljs-number"><span class="hljs-number">0</span></span>; // denied port module_param( port, int, <span class="hljs-number"><span class="hljs-number">0</span></span> ); static void **taddr; // table sys_call_table address u32 ipdeny; // denied IP #include "<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>.c" #include "CR0.c" inline char* in4_ntoa( uint32_t ip ) { // mapping IP to a string static char saddr[ MAX_ADDR_LEN ]; sprintf( saddr, "<span class="hljs-variable"><span class="hljs-variable">%d.%</span></span>d.<span class="hljs-variable"><span class="hljs-variable">%d.%</span></span>d", ( ip &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span> ) &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xFF, ( ip &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> ) &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xFF, ( ip &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> ) &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xFF, ( ip ) &amp; <span class="hljs-number"><span class="hljs-number">0</span></span>xFF ); return saddr; } asmlinkage long (*old_sys_socketcall) ( int <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>, unsigned long __user *args ); asmlinkage long new_sys_socketcall( int <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>, unsigned long __user *args ) { #define PARMS <span class="hljs-number"><span class="hljs-number">3</span></span> static unsigned long a[ PARMS ]; // accept() and connect() have the same number of parameters <span class="hljs-number"><span class="hljs-number">3</span></span> static struct sockaddr sa; // ----------- nested functions are a GCC extension --------- long get_addr( void ) { const unsigned int len = PARMS * sizeof( unsigned long ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( copy_from_user( a, args, len ) ) return -EFAULT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( copy_from_user( &amp;sa, (struct sockaddr __user*)a[ <span class="hljs-number"><span class="hljs-number">1</span></span> ], sizeof( struct sockaddr ) ) ) return -EFAULT; return <span class="hljs-number"><span class="hljs-number">0</span></span>; } // ---------------------------------------------------------- long ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SYS_ACCEPT == <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ) { // accept() before syscall long err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( err = get_addr() ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) return err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( AF_INET == sa.sa_family ) { // only IPv4 struct sockaddr_in *usin = (struct sockaddr_in *)&amp;sa; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ntohs( usin-&gt;sin_port ) == port ) { LOG( "accept from denied port %d\n", ntohs( usin-&gt;sin_port ) ); return -EIO; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SYS_CONNECT == <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ) { // connect() before syscall long err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( err = get_addr() ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) return err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( AF_INET == sa.sa_family ) { // only IPv4 struct sockaddr_in *usin = (struct sockaddr_in *)&amp;sa; DEB( "connect to <span class="hljs-variable"><span class="hljs-variable">%s:%</span></span>d\n", in4_ntoa( ntohl( usin-&gt;sin_addr.s_addr ) ), ntohs( usin-&gt;sin_port ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( deny != NULL &amp;&amp; ntohl( usin-&gt;sin_addr.s_addr ) == ipdeny ) || ( port != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ntohs( usin-&gt;sin_port ) == port ) ) { LOG( "connect to <span class="hljs-variable"><span class="hljs-variable">%s:%</span></span>d denied\n", in4_ntoa( ntohl( usin-&gt;sin_addr.s_addr ) ), ntohs( usin-&gt;sin_port ) ); return -EACCES; } } } ret = old_sys_socketcall( <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>, args ); // retranslate to original sys_socketcall() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SYS_ACCEPT == <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ) { // accepr() after syscall long err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( err = get_addr() ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) return err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( AF_INET == sa.sa_family ) { // only IPv4 struct sockaddr_in *usin = (struct sockaddr_in *)&amp;sa; DEB( "accept from <span class="hljs-variable"><span class="hljs-variable">%s:%</span></span>d\n", in4_ntoa( ntohl( usin-&gt;sin_addr.s_addr ) ), ntohs( usin-&gt;sin_port ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( deny != NULL &amp;&amp; ntohl( usin-&gt;sin_addr.s_addr ) == ipdeny ) || ( port != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ntohs( usin-&gt;sin_port ) == port ) ) { LOG( "accept from <span class="hljs-variable"><span class="hljs-variable">%s:%</span></span>d denied\n", in4_ntoa( ntohl( usin-&gt;sin_addr.s_addr ) ), ntohs( usin-&gt;sin_port ) ); return -EACCES; } } } return ret; } static int __init init( void ) { void *waddr; // ----------- nested functions are a GCC extension --------- int pos_in_table( const char *symbol ) { // position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table (__NR_*) const int last = __NR_process_vm_writev; // near last syscall <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> i386 int n; waddr = find_sym( symbol ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == waddr ) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt;= last; n++ ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( taddr[ n ] == waddr ) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; return n &lt;= last ? n : -<span class="hljs-number"><span class="hljs-number">1</span></span>; } // -------------------------------------------------------- void show_in_table( char *symb ) { // <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> info about symbol waddr = find_sym( symb ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == waddr ) { DEB( "symbol %s <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kernel\n", symb ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { int n = pos_in_table( symb ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) DEB( "symbol %s address = %p, position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table = %d\n", symb, waddr, n ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> DEB( "symbol %s address = %p, <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table\n", symb, waddr ); } } // -------------------------------------------------------- ipdeny = ntohl( deny != NULL ? in_aton( deny ) : in_aton( "<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>" ) ); LOG( "denied IP: %s\n", deny != NULL ? in4_ntoa( ipdeny ) : "no" ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( port != <span class="hljs-number"><span class="hljs-number">0</span></span> ) LOG( "denied TCP port: %d\n", port ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == ( taddr = find_sym( "sys_call_table" ) ) ) { ERR( "sys_call_table <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found\n" ); return -EINVAL; } DEB( "sys_call_table address = %p\n", taddr ); show_in_table( "sys_accept" ); show_in_table( "sys_connect" ); show_in_table( "sys_socketcall" ); // only diagnostic old_sys_socketcall = (void*)taddr[ __NR_socketcall ]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == ( waddr = find_sym( "sys_socketcall" ) ) ) { // sys_socketcall <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exported ERR( "sys_socketcall <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found\n" ); return -EINVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( old_sys_socketcall != waddr ) { // reinsurance! ERR( "Oooops! I don't understand: addresses <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> equal\n" ); return -EINVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( debug ) show_cr0(); rw_enable(); taddr[ __NR_socketcall ] = new_sys_socketcall; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( debug ) show_cr0(); rw_disable(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( debug ) show_cr0(); LOG( "install new sys_socketcall handler: %p\n", &amp;new_sys_socketcall ); return <span class="hljs-number"><span class="hljs-number">0</span></span>; } static void __exit <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>( void ) { LOG( "sys_socketcall handler before unload: %p\n", (void*)taddr[ __NR_socketcall ] ); rw_enable(); taddr[ __NR_socketcall ] = old_sys_socketcall; rw_disable(); LOG( "<span class="hljs-built_in"><span class="hljs-built_in">restore</span></span> old sys_socketcall handler: %p\n", (void*)taddr[ __NR_socketcall ] ); return; } module_init( init ); module_exit( <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> );</code> </pre><br></div></div><br>  The code is simplified as much as possible, such things as the LOG (), ERR () diagnostic macros have already been shown, in part, in the previous sections.  The find () function has also been discussed.  To write to the write-protected area of ‚Äã‚Äãthe sys_call_table table, there are at least 3-4 alternatives, all of which were called and referenced in the discussions in the previous part.  Protection against unloading the module during the maintenance of system calls, by incrementing the module's reference counter, is also not shown (it was called in the previous part).  All these details are present in the codes of the attached archive.  In addition, the codes in the archive are copiously peppered with comments containing extracts from the kernel sources, indicating the files in the kernel code tree - this suggests the required data structures. <br><br>  And yet, with all the simplifications, the code remains cumbersome enough (not complicated, but cumbersome).  But it is possible and not to delve into the actual code, the sequence of processing the modified network system calls as follows: <br><br><ul><li>  take control (change handler) of the sys_socketcall () system call; </li><li>  if the calling code (1st sys_socketcall () parameter) is SYS_ACCEPT or SYS_CONNECT, then copy the 3-element array of unsigned long parameters from the user space (in general, 6 elements, for SYS_SENDMSG, for example); </li><li>  The 2nd element of the array (corresponding to the 2nd accept () or connect () parameter), although it looks like an unsigned long is a pointer to a struct sockaddr in the user address space, with the second step of accessing the parameters, copy the structure from the user address space; </li><li>  the structure contains the IP address and TCP port parameters, if they fall into the banned list - return the error code and cancel the operation, if not - call the original system call handler; </li><li>  for all other (18, not SYS_ACCEPT and SYS_CONNECT) socket calls, we simply transit the call to the original sys_socketcall (); </li><li>  requests that are not related to the IPv4 protocol without modification are transferred to the network stack; </li></ul><br>  Some additional complexity is created by the fact that the call to accept () has to be checked twice: <br><ul><li>  TCP port number before the original system call, when the server starts listening on an unattached socket; </li><li>  IP address of the source after the connection is established for the socket, after returning from the function of the original system call; </li></ul><br>  How does it look at work?  Something like this: <br><pre> <code class="bash hljs">$ sudo insmod fwnet.ko deny=192.168.56.101 port=10000 debug=1 $ lsmod | head -n2 Module Size Used by fwnet 13116 0 $ dmesg | tail -n10 [ 786.609568] ! denied IP: 192.168.56.101 [ 786.609572] ! denied TCP port: 10000 [ 786.613047] ! sys_call_table address = c15b4000 [ 786.636336] ! symbol sys_accept address = c149a070, not found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table [ 786.656437] ! symbol sys_connect address = c149a0a0, not found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table [ 786.661444] ! symbol sys_socketcall address = c149acd0, position <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys_call_table = 102 [ 786.663994] ! CR0 = 8005003b [ 786.664090] ! CR0 = 8004003b [ 786.664096] ! CR0 = 8005003b [ 786.664100] ! install new sys_socketcall handler: e1ad50d0</code> </pre><br>  Naturally, in order to observe the operation of the kernel network filter in action, we need a TCP client and server (for example, ncat).  But for detailed testing, a special relay server (tcpserv) and a client (tcpcli) were prepared.  Apart from some little things, sharpened for this work, they do not represent anything special and will not be considered here (but they are in the attached archive). <br>  Here are some of the attempts to establish prohibited TCP connections: <br><br>  - Starting the server listening on the forbidden port: <br><pre> <code class="bash hljs">$ ./tcpserv -v -p10000 listening on the TCP port 10000 denied TCP port: Input/output error $ dmesg | tail -n5 ... [11213.888556] ! accept before: port = 10000 [11213.888562] ! accept from denied port 10000</code> </pre><br>  - Attempt to connect a client to a forbidden port: <br><pre> <code class="dos hljs">$ ./tcpcli -v -h <span class="hljs-number"><span class="hljs-number">127</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> -p <span class="hljs-number"><span class="hljs-number">10000</span></span> client: can't connect to server: Permission denied $ dmesg | tail -n5 ... [<span class="hljs-number"><span class="hljs-number">10984</span></span>.<span class="hljs-number"><span class="hljs-number">082051</span></span>] ! connect to <span class="hljs-number"><span class="hljs-number">127</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10000</span></span> [<span class="hljs-number"><span class="hljs-number">10984</span></span>.<span class="hljs-number"><span class="hljs-number">082060</span></span>] ! connect to <span class="hljs-number"><span class="hljs-number">127</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10000</span></span> denied [<span class="hljs-number"><span class="hljs-number">11166</span></span>.<span class="hljs-number"><span class="hljs-number">236948</span></span>] ! connect to <span class="hljs-number"><span class="hljs-number">127</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span> ...</code> </pre><br>  Well and so on - the task provides a wide and exciting field for experimentation ... <br><br>  (Here in the protocol, the address to DNS on port 53 is specifically stored and shown at the same time. In the same way, during the filtering experiments, you can observe many connections to TCP port 80 - all the time HTTP traffic goes without disruption). <br><br>  It is important that after unloading the module, the system is restored to its original state: <br><pre> <code class="bash hljs">$ sudo rmmod fwnet $ dmesg | grep \! | tail -n2 [ 2890.602419] ! sys_socketcall handler before unload: e1ad50d0 [ 2890.602439] ! restore old sys_socketcall handler: c149acd0</code> </pre><br><h1>  Discussion </h1><br>  So, somewhat fictional, the handling of network system calls is carried out in Linux ... at least in 32-bit implementations.  When you first encounter these system calls, the way they work is somewhat discouraging. <br><br>  This part of the discussion turned out to be drawn out and boring, but such an artifact as this is how the system calls work - you need to know and take it into account. <br><br>  A small code archive (and an extensive test log) for experiments can be found <a href="https://yadi.sk/d/ojCxnDuKjVpKG">here</a> or <a href="https://drive.google.com/file/d/0B__cqmYoRw_6aExZa3VHLUE4a0U/view%3Fusp%3Dsharing">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/268145/">https://habr.com/ru/post/268145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268131/index.html">Mono and OS MSVS</a></li>
<li><a href="../268135/index.html">About safety UEFI, part six</a></li>
<li><a href="../268137/index.html">Good luck in the digital age! Or turn on the paranoid and check the protection of their data</a></li>
<li><a href="../268141/index.html">Non-constant constant expressions</a></li>
<li><a href="../268143/index.html">Android Studio 1.4 available</a></li>
<li><a href="../268151/index.html">Aero Framework - WPF new breath. Rise above MVVM</a></li>
<li><a href="../268153/index.html">Development and publication of asset in the Unity Asset Store</a></li>
<li><a href="../268155/index.html">About Garbage Collector, Unity and weak links</a></li>
<li><a href="../268159/index.html">40 key information technology concepts accessible and understandable</a></li>
<li><a href="../268161/index.html">How to write highly available code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>