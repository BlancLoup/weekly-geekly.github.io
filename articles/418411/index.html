<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Browser Network Shooter on Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The development of multiplayer games is difficult for many reasons: their hosting can be expensive, the structure is not obvious, and the implementati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Browser Network Shooter on Node.js</h1><div class="post__text post__text-html js-mediator-article">  The development of multiplayer games is difficult for many reasons: their hosting can be expensive, the structure is not obvious, and the implementation is difficult.  In this tutorial, I will try to help you overcome the last barrier. <br><br>  This article is intended for developers who can create games and are familiar with JavaScript, but who have never written multiplayer online games before.  Having completed this tutorial, you will master the implementation of the basic network components in your game and will be able to develop it into something more!  Here is what we will create: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/220/340/e9a22034098ab10a84721a48615a1476.png"></div><br>  Play in the finished game <a href="https://tutsplus-pirate-shooter.glitch.me/">here</a> !  When you press the W or "up" keys, the ship approaches the cursor; when you click the mouse, it shoots.  <em>(If no one is online, then to check how multiplayer works, open two browser windows on one computer, or one of them on the phone,).</em>  If you want to run the game locally, the full source code is uploaded to <a href="https://github.com/tutsplus/tutsplus-glitch-multiplayer" rel="external">GitHub</a> . <br><a name="habracut"></a><br>  When creating the game, I used graphics resources from <a href="https://kenney.nl/assets/pirate-pack" rel="external">Kenney's Pirate Pack</a> and the <a href="http://phaser.io/" rel="external">Phaser</a> game framework.  In this tutorial, you are assigned the role of a network programmer.  The starting point will be a fully functional single-player version of the game, and our task will be to write a server on Node.js using <a href="https://socket.io/">Socket.io</a> for the network part.  In order not to overload the tutorial, I will focus on the parts related to the multiplayer, and skip the concepts related to Phaser and Node.js. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You do not need to configure anything locally, because we will create this game entirely in the browser on the site <a href="https://glitch.com/">Glitch.com</a> !  Glitch is a great tool for building web applications, including backend, databases and everything else.  It is great for prototyping, learning, and collaboration, and I‚Äôm very happy to introduce you to its capabilities in this tutorial. <br><br>  Let's get started. <br><br><h2>  1. Preparation </h2><br>  I posted a draft of the project on <a href="https://glitch.com/edit/" rel="external">Glitch.com</a> . <br><br>  Interface Tips: You can launch an application preview by clicking on the <strong>Show</strong> button (top left). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/8b6/4dd/ac28b64dd9c37370872ad6a913b10078.png"></div><br>  The vertical sidebar on the left contains all the application files.  To edit this application you need to create its "remix".  So we will create a copy of it in our account (or "fork" in the git jargon).  Click on the <strong>Remix this</strong> button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/88f/6e4/f7188f6e4b66e9b9801d04c7891d42dd.png"></div><br>  At this stage, you are editing the application under an anonymous account.  To save your work, you can log in (top right). <br><br>  Now, before moving on, it is important for you to get acquainted with the game, in which we will add a multiplayer mode.  Look at <strong>index.html</strong> .  It has three important functions that you need to know about: <code>preload</code> (line 99), <code>create</code> (line 115) and <code>GameLoop</code> (line 142), as well as the player's object (line 35). <br><br>  If you prefer to learn by practicing, then make sure that you understand the work of the game by completing the following tasks: <br><br><ul><li>  Increase the size of the world <em>(line 29)</em> - <em>note that there is a separate world size for the in-game world and a window size for the page canvas itself</em> . </li><li>  Make it so that you could move forward with the help of the "space" <em>(line 53).</em> </li><li>  Change the player‚Äôs ship type <em>(line 129).</em> </li><li>  Slow the movement of shells <em>(line 155).</em> </li></ul><br><h3>  Install Socket.io </h3><br>  Socket.io is a library for managing real-time communications inside the browser using <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a> (instead of using protocols like UDP, which are used to create classic multiplayer games).  In addition, the library has backup ways to ensure operation, even when WebSockets are not supported.  That is, it deals with messaging protocols and allows the use of a convenient event-based messaging system. <br><br>  The first thing we need to do is install the Socket.io module.  In Glitch, you can do this by going to the <strong>package.json</strong> file, and then either by entering the required module in the dependencies, or by clicking <strong>Add package</strong> and entering "socket.io". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/41f/005/d9441f0059e23044aa69f6f8750c81bb.png"></div><br>  Now is the right time to figure out the server logs.  Click the <strong>Logs</strong> button on the left to open the server log.  You should see that it installs Socket.io with all its dependencies.  This is where you need to look for all the errors and output data of the server code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/6e1/58c/7db6e158c6e48d0d91f70344eaf51af7.png"></div><br>  Now let's go to <strong>server.js</strong> .  This is where our server code is located.  So far there is only some basic boilerplate-code for serving our HTML.  Add a line to the top of the file to enable Socket.io: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(http); <span class="hljs-comment"><span class="hljs-comment">//     http</span></span></code> </pre> <br>  Now we also need to enable Socket.io in the client, so let's go back to <strong>index.html</strong> and add the following lines inside the <code>&lt;head&gt;</code> tag: <br><br><pre> <code class="javascript hljs">&lt;!--    Socket.io --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/socket.io/socket.io.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  <em>Note: Socket.io automatically handles client library uploading along this path, so this line works even if your folders do not have the /socket.io/ directory.</em> <br><br>  Socket.io is now included in the project and ready to go! <br><br><h2>  2. Recognition and spawning of players </h2><br>  Our first real step is to accept connections on the server and create new players in the client. <br><br><h3>  Accepting server connections </h3><br>  Add this code to the bottom of <strong>server.js</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); })</span></span></code> </pre> <br>  So we ask Socket.io to listen to all <code>connection</code> events that automatically occur when a client connects.  The library creates a new <code>socket</code> object for each client, where <code>socket.id</code> is the unique identifier for this client. <br><br>  To check that it works, return to the client ( <strong>index.html</strong> ) and add this line to the <strong>create</strong> function somewhere: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = io(); <span class="hljs-comment"><span class="hljs-comment">//    'connection'  </span></span></code> </pre> <br>  If you start the game and look at the server log (click on the <strong>Logs</strong> button), then you will see that the server has registered this connection event! <br><br>  Now when you connect a new player, we expect that he will give us information about his condition.  In our case, we need to know at least <strong>x</strong> , <strong>y</strong> and <strong>angle</strong> in order to correctly create it at the desired point. <br><br>  The <code>connection</code> event was a built-in event triggered by Socket.io.  We can listen to any self-defined events.  I will call my event <code>new-player</code> , and expect the client to send it as soon as it connects with its position information.  It will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); }) })</span></span></code> </pre> <br>  If you run this code, then while in the server log you will not see anything, because we have not yet told the client to generate this event <code>new-player</code> .  But let's pretend for a minute that we have already done this and continue working on the server.  What should happen after getting the location of a new joining player? <br><br>  We can send a message to all <em>other</em> connected players so that they know that a new player has appeared.  Socket.io has a convenient function for this: <br><br><pre> <code class="javascript hljs">socket.broadcast.emit(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,state_data);</code> </pre> <br>  When you call <code>socket.emit</code> message is simply sent to that one client.  When you call <code>socket.broadcast.emit</code> it is sent to every client connected to the server, except for the one on whose socket this function was called. <br><br>  The <code>io.emit</code> function sends a message to every client connected to the server with no exceptions.  In our scheme, we do not need this, because if we receive a message from the server requesting the creation of our own ship, we will have a duplicate sprite, because we have already created our own ship when the game starts.  <a href="https://gist.github.com/OmarShehata/a67499b29c65c8b84f74760652890bd8">Here is a handy tip</a> on the different kinds of messaging features that we will use in this tutorial. <br><br>  The server code should now look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); socket.broadcast.emit('create-player',state_data); }) })</span></span></code> </pre> <br>  That is, each time a player connects, we expect him to send us a message with his location data, and we send this data to all other players so that they can create his sprite. <br><br><h3>  Spawn in the client </h3><br>  Now, to complete this cycle, we need to perform two actions in the client: <br><br><ol><li>  Generate a message with the data of our location after the connection. </li><li>  Play <code>create-player</code> events and create a player at this point. </li></ol><br>  To perform the first action after creating the player in the <strong>create</strong> function (approximately on line 135), we can generate a message containing the location data we need to send: <br><br><pre> <code class="javascript hljs">socket.emit(<span class="hljs-string"><span class="hljs-string">'new-player'</span></span>,{<span class="hljs-attr"><span class="hljs-attr">x</span></span>:player.sprite.x,<span class="hljs-attr"><span class="hljs-attr">y</span></span>:player.sprite.y,<span class="hljs-attr"><span class="hljs-attr">angle</span></span>:player.sprite.rotation})</code> </pre> <br>  We do not need to worry about serializing the data being sent.  You can transfer them to any type of object, and Socket.io itself will process it for us. <br><br>  Before proceeding further, we will <em>test the operation of the code</em> .  We should see a similar message in the server logs: <br><br><pre> <code class="javascript hljs">New player has state: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">728.8180247836519</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">261.9979387913289</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Now we know that our server receives an alert when a new player is connected and correctly reads its location data! <br><br>  Next, we want to listen to requests to create a new player.  We can place this code immediately after generating the message, it should look like this: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CreateShip -      ,     CreateShip(1,state.x,state.y,state.angle) })</span></span></code> </pre> <br>  Now <em>test the code</em> .  Open two windows with the game and make sure that it works. <br><br>  You should see that after opening two clients, the first client has two ships created, and the second has just one. <br><br><blockquote>  Task: can you figure out why this happened?  Or how can you fix it?  Step through the client / server logic we wrote and try to debug it. </blockquote><br>  I hope you tried to figure it out on your own!  The following happens: when the first player connects, the server sends a <code>create-player</code> event to all other players, but there are not yet any players who can receive it.  After connecting the second player, the server sends its messages again, and the first player receives it and correctly creates the sprite, while the second player missed the message of the first player. <br><br>  That is, the problem is that the second player connects to the game later and he needs to know the state of the game.  We must inform all new connecting players that players already exist (as well as other events that have occurred in the world) so that they can navigate.  Before we get to the solution of this problem, I have a brief warning. <br><br><h3>  Game Status Synchronization Warning </h3><br>  There are two approaches to the implementation of synchronization of all players.  The first is to send the network a minimum amount of information about the changes.  That is, each time a new player connects, we will send all other players only information about this new player (and this new player will send a list of all other players in the world), and after it is turned off, we inform all players that this particular player has disconnected. <br><br>  The second approach is to transfer the entire state of the game.  In this case, we simply send everybody a complete list of all the players every time you connect or disconnect. <br><br>  The first approach is better in that it minimizes the amount of information transmitted over the network, but it can be very difficult to implement it, and it has the possibility of players getting out of sync.  The second ensures that players will always be synchronized, but in each message you will have to send more data. <br><br>  In our case, instead of trying to send messages when a player connects to create it and when disconnected to delete it, as well as when moving to update its position, we can combine it all into one common <code>update</code> event.  This update event will always send every player's position to all customers.  This is what the server should do.  The client‚Äôs task is to keep the world consistent with the resulting state. <br><br>  To implement such a scheme, I will do the following: <br><br><ol><li>  I will keep a dictionary of players, the key of which will be their ID, and the value will be their location data. </li><li>  Add a player to this dictionary when it is connected and send an update event. </li><li>  Delete a player from this dictionary when it is disabled and send an update event. </li></ol><br>  You can try to implement this system yourself, because these actions are quite simple ( <a href="https://gist.github.com/OmarShehata/a67499b29c65c8b84f74760652890bd8" rel="external">my function tip</a> may be useful here).  Here is what a complete implementation might look like: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    // 1 -      / var players = {}; io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); // 2 -      players[socket.id] = state_data; //    io.emit('update-players',players); }) socket.on('disconnect',function(){ // 3-       delete players[socket.id]; //    }) })</span></span></code> </pre> <br>  The client side is a bit more complicated.  On the one hand, now we should only care about the <code>update-players</code> event, but on the other hand, we should consider creating new ships if the server sends more ships than we know, or deleting if there are too many of them. <br><br>  Here is how I handle this event in the client: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     // : -         other_players = {} socket.on('update-players',function(players_data){ var players_found = {}; //        for(var id in players_data){ //      if(other_players[id] == undefined &amp;&amp; id != socket.id){ // ,      var data = players_data[id]; var p = CreateShip(1,data.x,data.y,data.angle); other_players[id] = p; console.log("Created new player at (" + data.x + ", " + data.y + ")"); } players_found[id] = true; //     if(id != socket.id){ other_players[id].x = players_data[id].x; //  ,    ,      other_players[id].y = players_data[id].y; other_players[id].rotation = players_data[id].angle; } } //       for(var id in other_players){ if(!players_found[id]){ other_players[id].destroy(); delete other_players[id]; } } })</span></span></code> </pre> <br>  On the client side, I store the ships in the <code>other_players</code> dictionary, which I simply defined at the top of the script (it is not shown here).  Since the server sends player data to all players, I have to add a check so that the client does not create an extra sprite for itself.  (If you have problems with structuring, here is the <a href="https://gist.github.com/OmarShehata/be545682831d2397b621858f7d1b8833" rel="external">full code</a> , which should be in index.html at the moment). <br><br>  Now let's <em>test the code</em> .  You should be able to create multiple clients and see the correct number of ships created in the correct positions! <br><br><h2>  3. Synchronization of ship positions </h2><br>  Here begins a very interesting part.  We want to synchronize ship positions on all clients.  This will show the simplicity of the structure that we have created at the moment.  We already have an update event that can synchronize the locations of all ships.  We need to do the following: <br><br><ol><li>  Get the client to generate a message each time it moves to a new position. </li><li>  Teach the server to listen to this move message and update the item with the player's data in the <code>players</code> dictionary. </li><li>  Generate update event for all clients. </li></ol><br>  And that should be enough!  Now it's your turn to try to implement it yourself. <br><br>  If you are completely confused and you need a hint, then look at the <a href="https://glitch.com/edit/">finished project</a> . <br><br><h3>  A note on minimizing network data </h3><br>  The most straightforward method of implementation is to update the positions of all players each time they receive a move event from <em>any</em> player.  It is great if players always get the latest information immediately after it appears, but the number of messages transmitted over the network can easily grow to hundreds per frame.  Imagine that you have 10 players, each of whom send a message about the movement in each frame.  The server should send them back to all 10 players.  This is already 100 messages per frame! <br><br>  It will be better to do this: wait until the server receives all messages from all players, and then send all players a big update containing all the information.  Thus, we will reduce the number of transmitted messages to the number of users present in the game (instead of the square of this number).  The problem here is that all users will experience the same delay as the player with the slowest connection. <br><br>  Another solution is to send the server updates at a constant frequency, regardless of the number of messages received from the player.  A common standard is to update the server about 30 times per second. <br><br>  However, when choosing the structure of your server, you should estimate the number of messages transmitted in each frame at the early stages of game development. <br><br><h2>  4. Synchronization of shells </h2><br>  We are almost done!  The last serious part is to synchronize the shells over the network.  We can implement it the same way we synchronized the players: <br><br><ul><li>  Each client sends the position of all its shells in each frame. </li><li>  The server redirects them to each player. </li></ul><br>  But there is a problem. <br><br><h3>  Cheating Protection </h3><br>  If you redirect everything that the client sends as the true positions of the shells, the player will be able to cheat easily by modifying his client and giving you false data, such as shells teleporting to the positions of the ships.  You can easily check this yourself by downloading the web page, changing the code in JavaScript and opening it again.  And this is a problem not only for browser games.  In general, we can never trust the data coming from the user. <br><br>  To partially cope with this problem, we will try to use a different scheme: <br><br><ul><li>  The client generates a message on the fired projectile with its position and direction. </li><li>  The server simulates the movement of shells. </li><li>  The server updates the data of each client, passing the position of all the shells. </li><li>  Clients render shells in positions received from the server. </li></ul><br>  Thus, the client is responsible for the position of the projectile, but not for its speed and not for its further movement.  The client can change the position of the shells for himself, but this does not change what other customers see. <br><br>  To implement this scheme, we will add a message generation when fired.  I will no longer create the sprite myself, because its existence and location will be entirely determined by the server.  Now our new projectile shot at <strong>index.html</strong> will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){ var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20; var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20; /*    ,       ,       var bullet = {}; bullet.speed_x = speed_x; bullet.speed_y = speed_y; bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet'); bullet_array.push(bullet); */ this.shot = true; //  ,     socket.emit('shoot-bullet',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y}) }</span></span></code> </pre> <br>  Also now we can comment out the entire code snippet that updates the shells in the client: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,         //   for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.sprite.x += bullet.speed_x; bullet.sprite.y += bullet.speed_y; //  ,       if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){ bullet.sprite.destroy(); bullet_array.splice(i,1); i--; } } */</span></span></code> </pre> <br>  Finally, we need to force the client to listen to the updates of the shells.  I decided to implement it the same way as with the players, that is, the server simply sends an array of all the positions of the shells in an event called <code>bullets-update</code> , and the client creates or destroys the shells to maintain synchronization.  Here is what it looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     socket.on('bullets-update',function(server_bullet_array){ //     ,   for(var i=0;i&lt;server_bullet_array.length;i++){ if(bullet_array[i] == undefined){ bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet'); } else { //      ! bullet_array[i].x = server_bullet_array[i].x; bullet_array[i].y = server_bullet_array[i].y; } } //    ,   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){ bullet_array[i].destroy(); bullet_array.splice(i,1); i--; } })</span></span></code> </pre> <br>   ,     .   ,    ,          ,      ,      <a href="https://glitch.com/edit/" rel="external"> </a> . <br><br>   server.js      .       ,    : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bullet_array = []; <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   shoot-bullet        socket.on('shoot-bullet',function(data){ if(players[socket.id] == undefined) return; var new_bullet = data; data.owner_id = socket.id; //    id  bullet_array.push(new_bullet); });</span></span></code> </pre> <br>     60   : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   60       function ServerGameLoop(){ for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.x += bullet.speed_x; bullet.y += bullet.speed_y; // ,       if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){ bullet_array.splice(i,1); i--; } } } setInterval(ServerGameLoop, 16);</span></span></code> </pre> <br>    ‚Äî     -    (     for): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,    io.emit("bullets-update",bullet_array);</span></span></code> </pre> <br>      !    ,    ,       . ,      ,     ,      . ,      ,   ,        ,     ,   ,    . <br><br><h2> 5.    </h2><br>    ,   . ,        ,     ,      ( ).      ,       . <br><br>   ‚Äî    ,   ,      .       ,    .   : <br><br><ul><li> ,      -   . </li><li>     ,   -   . </li><li>           . </li></ul><br>      .       ,    -  0: <br><br><pre> <code class="javascript hljs">player.sprite.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>         (    ).      ,      -      - : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> other_players){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other_players[id].alpha &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ other_players[id].alpha += (<span class="hljs-number"><span class="hljs-number">1</span></span> - other_players[id].alpha) * <span class="hljs-number"><span class="hljs-number">0.16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other_players[id].alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br>        ,        (          ). <br><br> ,                   ,    ,      .      ,    . <br><br><h2> 6.   </h2><br>        ,    .       !     ,   -   ! <br><br>   ,       .   ,      ,      : <br><br><ul><li>       ,       . </li><li>   ,     .      ,      . </li></ul><br>            .       ,        ,    ,      . <br><br>     .  ,        ,      :    .    ‚Äî   .  ,     ,   -     .   ,   ,   ,      . <br><br>          ,        . <br><br>       .       update,       ,     : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     if(id != socket.id){ other_players[id].target_x = players_data[id].x; //  ,    ,     other_players[id].target_y = players_data[id].y; other_players[id].target_rotation = players_data[id].angle; }</span></span></code> </pre> <br>    update (   )               : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      for(var id in other_players){ var p = other_players[id]; if(p.target_x != undefined){ px += (p.target_x - px) * 0.16; py += (p.target_y - py) * 0.16; //  ,    /  var angle = p.target_rotation; var dir = (angle - p.rotation) / (Math.PI * 2); dir -= Math.round(dir); dir = dir * Math.PI * 2; p.rotation += dir * 0.16; } }</span></span></code> </pre> <br>  ,      30   ,         60 fps   -  ! <br><br><h2>  Conclusion </h2><br>    .  :  ,       ,    ,       .       -. <br><br>   ,     ,           .     ,    . <br><br> ,  ,        .   ‚Äî        (        ).         ‚Äî        .         ,         , , ,      . <br><br>       ‚Äî  ,      .        ,     ,   ,       .            .         .         . <br><br>        Glitch,             (Advanced Options)    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/d6b/dba/c62d6bdba51311a7a0d8976c37dbe6fb.png"></div></div><p>Source: <a href="https://habr.com/ru/post/418411/">https://habr.com/ru/post/418411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418399/index.html">On the wave of Selectel FM</a></li>
<li><a href="../418401/index.html">How I did not become you: a post of love for sysadmins</a></li>
<li><a href="../418403/index.html">FPGA Accelerator Programming Example</a></li>
<li><a href="../418405/index.html">The principle of the inverted pyramid in analytics. We build a clear dashboard</a></li>
<li><a href="../418407/index.html">Cloud mining Hashflare closed. Money does not return</a></li>
<li><a href="../418415/index.html">Telegram introduced its own Passport service to verify and authorize users.</a></li>
<li><a href="../418417/index.html">Apollo: 9 months - normal flight</a></li>
<li><a href="../418419/index.html">How Dodo Pizza solves business problems with machine learning</a></li>
<li><a href="../418421/index.html">The best reports about machine learning with ICML 2018 according to the version of Yandex employees</a></li>
<li><a href="../418423/index.html">Smart home: a new dimension of comfort and commitment to excellence. Part one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>