<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Cypress UDB PSoC Controllers to Reduce the Number of Interrupts in a 3D Printer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the comments to the translation of the company documentation on UDB, it was correctly noted that merely dry facts do not contribute to the understa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Cypress UDB PSoC Controllers to Reduce the Number of Interrupts in a 3D Printer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/8h/et/xb/8hetxbp_jjuad07ws86ov24ch-c.jpeg"><br><br>  In the comments to the translation of the <a href="https://habr.com/post/432764/">company documentation on UDB,</a> it was correctly noted that merely dry facts do not contribute to the understanding of the material.  But there are dry facts in that document.  To dilute them with practice, let's digress from the translation.  Let's turn this block in our hands and see what and how it can be achieved in a practical plane. <br><a name="habracut"></a><br><h2>  Long introduction </h2><br>  This article is the second part of the planned trilogy.  The first part is located <a href="https://habr.com/post/429882/">here</a> (Management of RGB LEDs via the UDB unit of PSoC microcontrollers manufactured by Cypress). <br><br>  In addition to the use of Cypress's UDB PSoC controllers, where various interfaces are implemented on them, it would be interesting to test how these blocks can make life easier for programmers by offloading the CPU from various resource-intensive tasks.  But in order to clarify what I am going to do, I‚Äôll have to write an extensive preface. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the fall of 2015, I bought a brand new 3D printer MZ3D, and by the spring of 2016 I was tired of it, as its stepper motors rattle.  The times were wild, we survived as best we could, so the only solution then was to switch from 1/16 to 1/32 microstep.  Correspondence with the plant showed that this is not possible on the Arduino.  As it turned out, there was a limitation in the ‚Äúfirmware‚Äù of those years, with the frequency of steps above 10 KHz it was not an honest step to take, but two virtual ones, otherwise the system simply did not have enough time to process all the ‚Äústep‚Äù interrupts.  There was only one way out - drag and drop everything onto the ARM platform.  It was to drag and not download, since no ready-made ARM solutions were found at that time either.  For a couple of weeks I transferred all this to the STM32F4, the sound of the engines became more pleasant, the issue was resolved. <br><br>  Then we started developing an OS in our company, and at meetings I had to argue for a long time that a typical approach to interrupt handling is not always acceptable in speed, appealing just to that typical, but very voracious case.  The arguments on this topic are published in my article on interrupts in the OS <a href="https://habr.com/post/340032/">here</a> (Overview of a Russian RTOS, part 8. Work with interruptions).  In general, the problem has lingered in my head for a long time: frequent auxiliary interrupts servicing one subsystem slow down everything else.  The simple powering of the CPU, of course, fixes the problem, but does not bring Deep Moral Satisfaction that everything is done correctly. <br><br>  Periodically, I returned to this issue in a purely theoretical sense.  For example, once the thought crept into my head that instead of using an expensive controller, you can take three STM32F103C8T6, for which a ready-made layout costs 110 rubles, including delivery, and the chip itself is cheaper.  In one of them only make the engine control function.  Let him spend all his computing power on this function.  A couple of the rest (maybe even one) solves other tasks (processing commands, working with PWM, maintaining temperature, etc.) in a calm atmosphere.  This solution also has a huge side plus - the total number of outputs from several controllers is simply huge.  On one STM32, I had to play solitaire for a long time, which leg to which to assign.  Although the legs of the timer outputs and the ADC legs of the ARMs are assigned more flexibly than the old controllers (one output of the hardware unit can reach one of several physical legs), but when you unwrap that solitaire, you realize that flexibility may not be enough.  If there are many controllers, the selection increases.  On the one that serves stepper motors, in general, we simply assign all the legs as digital outputs.  The rest also have where to turn. <br><br>  One problem with this approach is how to synchronize these controllers?  In theory, the MAX RTOS contains everything you need.  The command handler generates a list of tasks for moving heads.  Periodically, he modifies them (coordinating the acceleration with the newly arrived tasks).  So the memory for the driver and the performer should be shared.  The MAX RTOS contains functionality for organizing such shared memory.  I described it <a href="https://habr.com/post/339498/">here</a> (Overview of one Russian RTOS, part 7. Means of data exchange between tasks).  But in practice, everything spoils one thing: the maintenance of stepper motors is a time-critical type of task.  The slightest delay, and we get plastic flows for a 3D printer, for other CNC machines - well, for example, incorrectly cut threads.  Any communication through serial interfaces is not the fastest.  Plus - time for arbitration and other official needs.  And it turns out that the entire gain from the removal of the functional from the main processor goes to overhead.  Of course, I took advantage of my official position: I went and discussed this issue with the developers of this subsystem.  Alas.  They said that there is synchronization without any special overhead in the OS, but for equipment that supports the corresponding tires.  Now, if I take the TigerShark architecture as a basis, the OS will organize everything without any overheads.  Only controllers made according to this architecture are several times more expensive than the entire 3D printer I wanted to put it all into.  In general, again unacceptable. <br><br>  We approach the finale of the prolonged entry.  Someone will say that I‚Äôm still looking for a prince on a white horse.  You can take and do everything without the OS, and here I am considering all sorts of options ... You can, you can, but when the practical problem ‚ÄúTired of listening to the rumble of the printer‚Äù arose, it was quickly eliminated.  Everything.  She is no more.  Moreover, since then, new stepper motor drivers have appeared, which generally solve that problem in a completely different way (they get 1/16 microstep, and give 1/256 outward).  And in this introduction, I describe exactly what ‚ÄúThere is no <b>beautiful</b> solution to the problem of frequent interruptions.‚Äù  Ugly decision made long ago.  I did not want to waste time trying to check other ugly solutions.  They just scrolled through the head. <br><br>  But when I dealt with the UDB blocks, it seemed to me that the problem could be solved beautifully and dramatically.  You can simply divert the interrupt processing from the software to the firmware level, leaving the computational part of the core processor.  No need for additional controllers!  Everything is placed on the same crystal!  So, we proceed. <br><br><h2>  Spherical horse in a vacuum </h2><br>  In this article, the focus will be on working with UDB itself.  If I talked about linking to a specific ‚Äúfirmware‚Äù, I could fairly indicate that I was wrong with the hub.  What is it for GeekTimes.  Therefore, UDB is primary, and stepper motors are simply a beautiful thing to illustrate.  In this part, I generally make a spherical horse in a vacuum.  He will have practical flaws, which I will fix in the second part.  But by repeating my actions, readers will be able to master the methodology for developing firmware for UDB. <br><br>  So.  How does the stepper motor control mechanism work?  There is a task that queues the segments that the head must pass at a linear rate.  So far I will pretend that I don‚Äôt remember about accelerations at the beginning and end of the segment.  Just the head must pass.  New segments are tailing the queue.  Based on the recording from the head, a separate task sends <b>STEP</b> signals to all active engines. <br><br>  Let the printer have a maximum head speed of 200 mm / s.  Let 200 steps be required for 1 millimeter of movement (this figure corresponds to a real MZ3D-256C printer with a 1/32 microstep).  Then the pulses must be applied with a frequency of up to 200 * 200 = 40000 Hz = 40 KHz.  It is with such a frequency that a task sending step pulses can be called.  It must programmatically generate the pulses themselves, and also calculate, after what period of time the next activating interrupt should be triggered. <br><br>  I remember a joke about Kolobok and the Three Heroes, where Kolobok consistently greeted the Heroes, then successively asked them questions and received answers.  Then he consistently said goodbye to them.  Well, and then he met the Thirty Three Heroes.  The processor is in the role of a bun, and stepper motors are in the role of the Athletes.  It is clear that in the presence of a large number of UDB blocks, it is possible to parallelize the work with the engines, entrusting the maintenance of each engine to its own unit.  And since we have segments, during which the engines will walk evenly, let's try to make the hardware work with such transactions, and not with each step. <br><br>  What information is required in order for a spherical horse in vacuum to step through a linear section? <br><br><ul><li>  The number of steps. </li><li>  The time period between steps. </li></ul><br>  Two parameters.  In UDB there are just two batteries and two registers of parameters D0 and D1.  It seems that everything is realizable.  Let us estimate only the digit capacity that these registers should have. <br><br>  First the number of steps.  If there are 8 digits, then in one cycle of operation the UDB printer will be able to move the head of the Cartesian printer by a little more than 1 mm (200 microsteps).  Not much.  If the bit width is 16 bits, then the number of steps will be already 65536. This is 65536/200 = 327 millimeters.  For most models is acceptable.  For Core, Delta and others need to be estimated, but in general - for a full stroke, the segment can be divided into several parts.  They will not be so much (two, well, a maximum of three). <br><br>  Now is the period.  Let the clock frequency be 48 MHz.  48000000/65536 = 732.  That is, the minimum permissible frequency that can be obtained using a 16-bit divider is 732 Hz.  Too much.  In the Marlin Firmware, the minimum is 120 Hz (which roughly corresponds to 8 MHz, divided by the same constant 65536).  We'll have to do registers 24 bit.  Then the minimum frequency will be equal to 48000000 / (2 ^ 24) = 48000000/16777216 = 2.861 Hz. <br><br>  Good.  Enough of the boring theory!  Go to practice!  Launch PSoC Creator and select File-&gt; New-&gt; Project: <br><br><img src="https://habrastorage.org/webt/tk/9t/bj/tk9tbjfppfjemih3s-ydrk54lfc.png"><br><br>  Next, I chose the layout I had, from which the environment would take basic information about the controller used and its settings: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  I already feel ready to create a project from scratch, so I choose <b>Empty Schematic</b> : <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Give the working environment the name <b>PSoC3DTest</b> : <br><br><img src="https://habrastorage.org/webt/rr/0u/pd/rr0updtyevaseusbwel37v76bgc.png"><br><br>  And here it is, the finished project! <br><br><img src="https://habrastorage.org/webt/fw/0s/xu/fw0sxucryznmujjsvr5ockarrjc.png"><br><br>  The first thing I want to do is create my own UDB based component.  Therefore, as noted in the last article, I need to switch to the <b>Components</b> tab: <br><br><img src="https://habrastorage.org/webt/oa/o8/s5/oao8s5whrsdn9xsnophfoaom_n4.png"><br><br>  Click the right button on the project and select <b>Add Component Item</b> : <br><br><img src="https://habrastorage.org/webt/zq/kt/hu/zqkthur3pa19fpcrq4kcrmdac_y.png"><br><br>  We say that we need to add a <b>UDB Document</b> , change the name to <b>StepperController</b> and click on <b>Create New</b> : <br><br><img src="https://habrastorage.org/webt/tz/v8/qk/tzv8qkfqumypnq3ctjeh9moitpc.png"><br><br>  The component appeared in the tree, plus - the editor of this component opened: <br><br><img src="https://habrastorage.org/webt/yo/4g/np/yo4gnpvs5fuewpovam09lbq3zmw.png"><br><br>  Place the Datapath block on the form: <br><br><img src="https://habrastorage.org/webt/nx/1o/bl/nx1oblbig1eqyqat0yj-evlvwo0.png"><br><br>  Having selected this block, we go to its properties and change the bit width from 8 to 24. The remaining parameters can be left unchanged. <br><br><img src="https://habrastorage.org/webt/1e/oq/rf/1eoqrfsjz5uh1fj2mopwtmf5vao.png"><br><br>  So that all blocks (for all engines) start at the same time, I will start the start signal outside (I will add the <b>Start</b> input).  Outputs: I'll exit <b>Step</b> directly, in order to be able to submit it to the driver for the stepping motor, as well as <b>Out_Idle</b> .  On this signal, the processor will be able to determine that at the moment the unit has finished its work.  The names of the circuits matching these inputs and outputs are visible in the figure. <br><br><img src="https://habrastorage.org/webt/sx/xq/gv/sxxqgvsyvpyr_jvzdblaf_l1soc.png"><br><br>  Before talking about the logic of the automaton, I will describe one more purely engineering problem: the task of the duration of the impulse <b>Step</b> .  The documentation for the DRV8825 driver requires that the width of this pulse be at least 1.9 Œºs.  Other drivers are less demanding on its width.  As already noted in the theoretical part, the existing registers are already occupied by specifying the step duration and the number of steps.  Whatever one may say, a seven-bit counter should be placed on the circuit.  We call it the one-shot, which sets the step pulse.  With a frequency of 48 MHz to ensure a duration of 1.9 Œºs, this counter must count at least 91.2 steps.  Round up to 92. Any value greater than this will be no less.  It turns out the following setting: <br><br><img src="https://habrastorage.org/webt/6w/k9/em/6wk9emz-qedseywswmgk24bdjqe.png"><br><br>  Counter Name <b>SingleVibrator</b> .  It is never reset, so the <b>Reset</b> input is always connected to zero, it considers when the machine (described just below) is in the One state, it is loaded in all other states (at first I selected specific machine states, but it turned out that with this tricky method , much less PLD resources are required, and the result is the same).  The load value is equal to 92 decimal. However, a good editor will immediately replace this value with a hexadecimal value: <br><br><img src="https://habrastorage.org/webt/qt/h0/nv/qth0nvcbb_8m7qty2mj1zpde2m4.png"><br><br>  When the counter counted to zero, it will report it to the chain with the name <b>One_Finished</b> .  With the counter - everything. <br><br>  What our machine will need status flags?  I did it like this (remember, to set them, you need to double-click on the list of outputs in Datapath): <br><br><img src="https://habrastorage.org/webt/mk/oo/z_/mkooz_ywbi5vnaenpgfqo98p580.png"><br><br><img src="https://habrastorage.org/webt/br/u9/rz/bru9rzw4kk4ja4j6ehutvm7od14.png"><br><br>  I will use the battery A0 as a pulse width counter, so when its value reaches zero, the flag, which I named <b>Pulse_Finished</b> , will be <b>set</b> .  Battery A1 will have me counting pulses.  Therefore, its zeroing will cock the flag <b>Process_Finished</b> . <br><br>  We build the transition graph of the automaton: <br><br><img src="https://habrastorage.org/webt/bv/rr/cv/bvrrcv0pgjs9fvadt08iyqaj92i.png"><br><br>  The variable that sets its state is called <b>State</b> .  We immediately assign this variable to the address of the instruction address of the ALU.  I first forgot to do it, so for a long time I could not understand why my machine does not work.  Double click on the block of inputs in Datapath: <br><br><img src="https://habrastorage.org/webt/zl/z2/e0/zlz2e0tvkl11wc5ot0id4vsdnh4.png"><br><br>  And compare: <br><br><img src="https://habrastorage.org/webt/1e/sp/q1/1espq1co36mt063kgyvig-kzhsw.png"><br><br>  We begin to deal with the transition graph and the associated ALU instructions. <br><br>  Let's start with the <b>Idle</b> state.  It is quite saturated in its actions. <br><br>  Firstly, the value of data registers D0 and D1 are constantly placed in batteries A0 and A1, respectively: <br><br><img src="https://habrastorage.org/webt/hz/8p/c-/hz8pc-lydhvzq3cnvsg2jw2qcem.png"><br><br>  From this record, the keen eye will see all that is needed.  Since we still do not have an eye on the eye, double click on the record and see the same, but more: <br><br><img src="https://habrastorage.org/webt/yu/yy/qe/yuyyqemtvqbcsp25mbud7y3y1mu.png"><br><br>  The main value here is the filling of the battery A1, the pulse counter.  When the program enters the value of D1, it will immediately fall into A1.  The program will not have time to start the process until the next clock cycle.  This value is checked to form an exit condition from this state, that is, it is not filled anywhere else. <br><br>  Now we look at what is being done at the level of the transition graph: <br><br><img src="https://habrastorage.org/webt/97/p-/2d/97p-2dwdvbxyb_tpi-xaqjdhuck.png"><br><br>  The auxiliary <b>Start_Prev</b> trigger allows <b>you</b> to catch a positive differential at the <b>Start</b> input by organizing a delay line for 1 clock cycle.  It will always be the state of the <b>Start</b> input, which was on the previous clock.  Some people are more accustomed to see this in Verilog: <br><br><img src="https://habrastorage.org/webt/mm/pc/vw/mmpcvwuturlr5nieqnkgieml_tm.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text</b> <div class="spoiler_text"><pre><code class="plaintext hljs">always @ (posedge clock) begin : Idle_state_logic case(State) Idle : begin Start_Prev &lt;= (Start); IsIdle &lt;= (1); if (( Start&amp;(!Start_Prev)&amp;(!Process_Finished) ) == 1'b1) begin State &lt;= One ; end end</code> </pre> <br></div></div><br>  Accordingly, the condition <b>Start &amp; (! Start_Prev) is</b> true only when there was a positive drop in the <b>Start</b> line between the bars. <br><br>  In addition, when the machine is in this state, the <b>IsIdle</b> output translates to a single state, informing the external environment that the unit is passive.  With this approach, fewer PLD resources are spent than if the output is a <b>State == Idle</b> construct. <br><br>  When a drop in the <b>Start</b> signal comes from the external environment and a non-zero value is found in the battery A1, the machine will exit the <b>Idle</b> state.  If zero is entered in A1, the engine does not participate in the development of this segment, so the differential on the <b>Start</b> line is ignored.  This applies to an unused extruder.  For a number of printers, the motor along the Z axis is also quite rarely used. Let me remind you how a condition is formed that reveals a zero value in A1 (and a non-zero one is its inversion): <br><br><img src="https://habrastorage.org/webt/ez/kk/up/ezkkuprcmblrfjx22av9dlfu5bc.png"><br><br>  Next, the machine enters the <b>One</b> state: <br><br><img src="https://habrastorage.org/webt/zr/qc/cm/zrqccmzwghfncwcqyfekuhawmcg.png"><br><br>  In this state, the output of <b>Step</b> is set to 1. A step pulse is applied to the driver.  In addition, the <b>IsIdle</b> trigger value is <b>reset</b> .  The external environment is informed that the block is in the active phase. <br><br>  The exit from this state is made by the <b>One_Finished</b> signal, which will be cocked into the unit when the seven-bit counter counts to zero.  Let me remind you that the <b>One_Finished</b> signal <b>is</b> generated by this counter: <br><br><img src="https://habrastorage.org/webt/ls/yp/re/lsypreow8ydou_tqhrls8us-qem.png"><br><br>  While the machine is in this state, the ALU loads into the battery A0 (defining the pulse duration) the value from the register D0.  Let me show you only a brief record of this: <br><br><img src="https://habrastorage.org/webt/am/b_/fa/amb_faw1o-9vsgframn5iswseas.png"><br><br>  The loaded value will be used in the following state.  Being in it, the machine generates a delay, which sets the pulse duration: <br><br><img src="https://habrastorage.org/webt/hh/eb/kf/hhebkfiwmsmnnrtkf17w2wqby8o.png"><br><br>  <b>Step</b> output is reset to zero.  Battery A0 decreases, as indicated by the following brief entry: <br><br><img src="https://habrastorage.org/webt/bb/63/dk/bb63dkglkjd8_7wn1s2by22_hym.png"><br><br>  And if you double-click on it - the full entry: <br><br><img src="https://habrastorage.org/webt/-8/6d/ry/-86dryefyslh1qsvlo4ggkdojhg.png"><br><br>  When the value of A0 reaches zero, the flag Pules_Finished is raised, and the machine goes into the <b>Decrement</b> state: <br><br><img src="https://habrastorage.org/webt/6k/sw/yv/6kswyvakmiszucfe1cx49pjcyig.png"><br><br>  In this state, the value of the battery A1, which determines the number of pulses, decreases in the ALU: <br><br><img src="https://habrastorage.org/webt/ci/9r/1e/ci9r1ervyzj1gyma_tpj4uxnzfq.png"><br><br>  Full record option: <br><br><img src="https://habrastorage.org/webt/l9/dk/hy/l9dkhy0a6bb2bqpzgmzgtox7clk.png"><br><br>  Depending on the result, the transition occurs either to the next pulse or to the <b>Idle</b> state.  Double-click on the status to see the transitions based on priorities: <br><br><img src="https://habrastorage.org/webt/jm/r-/7n/jmr-7nle2advdfl95fn8hnkid0i.png"><br><br>  Actually, with UDB everything.  Now we make the corresponding symbol.  To do this, right-click on the editor and select <b>Generate Symbol</b> : <br><br><img src="https://habrastorage.org/webt/j6/j3/qc/j6j3qcgoye9-2gac8fgowordfx8.png"><br><br>  Go to the project diagram: <br><br><img src="https://habrastorage.org/webt/ab/hb/l4/abhbl4ocjtfgw8r4vjfo8nfs05c.png"><br><br>  And we introduce a circuit in which there are a certain number of these controllers.  I chose five (three axes plus two extruders).  Printers with a large number of extruders will not be considered cheap.  They can and FPGA put.  Along the way, to see the real complexity, I threw a USB-UART block (for receiving data from a computer or the same Raspberry Pi) and a real UART (it will provide communication with a cheap Wi-Fi ESP8266 module or, say, an intelligent display that can send GCODE via UART).  Shima and others did not add, since their complexity is approximately clear, but to the real system is still far away.  It turned out something like this: <br><br><img src="https://habrastorage.org/webt/he/a6/ok/hea6okfr7irbrzjwm-bze2xlfxy.png"><br><br>  The control register generates a trigger that goes to all blocks at the same time.  In addition, the signals that are static during the formation of a segment are also let out of it.  I collected all the <b>Idle</b> outputs by an ‚ÄúI‚Äù and fed in to the interrupt input.  Interruption I appointed on the positive front.  If at least one engine has started operation, the interrupt input will be reset.  At the end of the last engine, it will be cocked, which will inform the processor of readiness for the next segment.  Now adjust the frequencies by double clicking on the element of the <b>Clocks</b> tree: <br><br><img src="https://habrastorage.org/webt/zy/yf/kl/zyyfklrmcfz5kmg-59qmzgdztug.png"><br><br>  In the table that appears, double-click on the <b>PLL_OUT</b> element: <br><br><img src="https://habrastorage.org/webt/8z/m0/r1/8zm0r10tu28rjatkhmo1h0skp80.png"><br><br>  Fill in the table somehow (I have not yet understood the rules for setting this table well enough, that is why I use the term ‚ÄúSomething like this‚Äù): <br><br><img src="https://habrastorage.org/webt/se/55/ps/se55ps9rti9fyvyguffgxdx0f0i.png"><br><br>  Now double click on the line <b>Clock_1</b> : <br><br><img src="https://habrastorage.org/webt/vn/py/px/vnpypxluipgeeme1fyf9icn9tu4.png"><br><br>  Set the clock frequency of UDB blocks to 48 MHz: <br><br><img src="https://habrastorage.org/webt/8z/sk/ik/8zskik6rpyovzo7ryqrxjeptinm.png"><br><br>  Since the project is experimental, there is no point in making an API to it.  But to consolidate the material studied in the last article, go back to the Components tab and for the StepperController project, right-click through Add Component Item and first add the header file, and then the C source code file: <br><br><img src="https://habrastorage.org/webt/3i/bg/zk/3ibgzkq8nugwau5lszhe9ikudxi.png"><br><br><img src="https://habrastorage.org/webt/bm/k3/iw/bmk3iwh-aouvspv20g7_1bgi3wq.png"><br><br>  Purely superficially show those two functions of initialization and the start of the segment, which I added.  The rest can be seen in the example for the article. <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start } void `$INSTANCE_NAME`_PrepareStep(int nSteps,int duration) { CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D0_PTR, duration&gt;92?duration-92:0); CY_SET_XTND_REG24(`$INSTANCE_NAME`_Datapath_1_D1_PTR, nSteps&gt;1?nSteps-1:0); }</code> </pre><br>  I replaced the name of the <b>main.c</b> file with <b>main.cpp</b> to check that the development environment will normally respond to the use of C ++, because the Marlin ‚Äúfirmware‚Äù is object-oriented.  Predictably showered errors that were predictably eliminated by the addition of a regular thing: <br><br><img src="https://habrastorage.org/webt/5m/mn/cd/5mmncdgxig9oxchcekaofuv1k9y.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "project.h" }</code> </pre><br></div></div><br>  For the global engine launch, I made this function (it is very rough, but for experiments with a spherical horse in vacuum, it will come down; with experiments, development time is more important than beauty): <br><pre> <code class="plaintext hljs">void StartSteppers() { Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (1); Stepper_Control_Reg_Write (0); }</code> </pre><br>  She cocks the <b>Start</b> signal, just in case, for three clock cycles at once, then drops it again. <br><br>  Well, and proceed to the experiments.  First, we simply step through the X and Y engines (in the example, the first group of calls initializes all the controllers, the second sets up the X and Y controllers for the required number of steps and starts the process): <br><br><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); StepperController_X_PrepareStep (10,1000); //    StepperController_Y_PrepareStep (50,500); StartSteppers(); //   for(;;) { } }</code> </pre><br>  We look at the result: <br><br><img src="https://habrastorage.org/webt/6x/io/v7/6xiov7g15a-ksl1_6kw7vkko0dc.png"><br><br>  Check the duration of the positive impulse: <br><br><img src="https://habrastorage.org/webt/ay/hk/jy/ayhkjyjphl4-pearn7zi3hnnknc.png"><br><br>  That's right.  Finally, check how well the interrupt works.  Add a global counter variable: <br><br><pre> <code class="plaintext hljs">static int nStep=0;</code> </pre><br>  This variable in the <b>main</b> function is assigned to one, and in the function of the interrupt handler increases.  The interrupt handler will only work once, purely for verification.  I made him like this: <br><br><pre> <code class="plaintext hljs">extern "C" { CY_ISR(StepperFinished) { if (nStep == 1) { StepperController_X_PrepareStep (5,500); StartSteppers(); nStep += 1; } } }</code> </pre><br>  And I added literally two lines to the <b>main</b> function: enabling interrupts and assigning this variable itself.  And I assign already, when the machines started.  Otherwise, a false interrupt request arrived.  To fight with him now there is no special reason.  The project is experimental. <br><br><img src="https://habrastorage.org/webt/kb/v2/dm/kbv2dmk2s6cg9nzc9fjzypg5uyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int main(void) { CyGlobalIntEnable; /* Enable global interrupts. */ isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); /* Place your initialization/startup code here (eg MyInst_Start()) */ StepperController_X_PrepareStep (10,1000); StepperController_Y_PrepareStep (20,500); StartSteppers(); nStep = 1; for(;;) { } }</code> </pre><br></div></div><br>  Check the result (in the second step, only the X engine should work, and the steps should be twice as rare): <br><br><img src="https://habrastorage.org/webt/0q/vi/iq/0qviiqvpko6m9i7o9tub3gmnqhw.png"><br><br>  That's right. <br><br><h2>  Conclusion </h2><br>  In general, it is already clear that the UDB blocks can be used not only to set fast hardware functions, but also to remove logic from the software to the firmware level.  Unfortunately, the volume of the article turned out so large that it is not possible to finish the review and get an unequivocal answer, whether there are enough UDB opportunities for the final solution of the task or not.  So far, only a spherical horse in a vacuum is ready, whose actions are in principle very similar to those required, but a corrosive reader who is familiar with the theory of control of stepper motors will find a lot of flaws in it.  The presented block does not support acceleration, without which the work of a real stepping motor is impossible.  Rather, it supports, but at this stage a high interrupt rate will be required, and everything was intended to avoid this. <br><br>  The accuracy of setting the frequency of the presented block is far from acceptable.  In particular, it will provide a pulse frequency of 40,000 Hz with a divider of 1,200 and 3,996 Hz with a divider of 1201. Intermediate frequencies between these two values ‚Äã‚Äãare unattainable on this unit. <br><br>  Perhaps there are some other disadvantages in it.  But eliminating them by checking whether there are enough resources for UDB will be dealt with in the next article. <br><br>  In the meantime, readers have received, among other things, a real example of creating a block based on UDB from scratch.  The test project, which turned out when writing this article, <a href="https://yadi.sk/d/5nKcYhlldrHicA">you can take here</a> . </div><p>Source: <a href="https://habr.com/ru/post/433800/">https://habr.com/ru/post/433800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433730/index.html">Optimization of relational databases without downtime on the example of the most loaded database in Badoo</a></li>
<li><a href="../433790/index.html">Advanced multi-stage build templates</a></li>
<li><a href="../433792/index.html">Shell scripts in Ansible</a></li>
<li><a href="../433796/index.html">How Homo Sapiens conquered the world. Communication and Negotiation Skills</a></li>
<li><a href="../433798/index.html">HomeKit and ioBroker Let's be friends houses</a></li>
<li><a href="../433802/index.html">How and why we won the Big Data track at the Urban Tech Challenge</a></li>
<li><a href="../433804/index.html">Mixture Density Networks</a></li>
<li><a href="../433806/index.html">When an online archive forgets</a></li>
<li><a href="../433808/index.html">5 most frequent mistakes that programmers make at the interview</a></li>
<li><a href="../433810/index.html">Problem-oriented approach to projects in Internet marketing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>