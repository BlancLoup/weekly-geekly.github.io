<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood at Dictionary and ConcurrentDictionary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, I decided that I wanted to know more details about multithreading in .NET and that I had paid undue attention to this in the past. Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood at Dictionary and ConcurrentDictionary</h1><div class="post__text post__text-html js-mediator-article">  Some time ago, I decided that I wanted to know more details about multithreading in .NET and that I had paid undue attention to this in the past.  There is a great deal of information on this topic (I chose <a href="http://albahari.com/threading/">this section of the book ‚ÄúC # in a nutshell‚Äù</a> as the starting point), but as it turned out, only a small part of the resources try to explain something in detail. <br><br>  Each master should know his tools, and what can be used more often collections?  Therefore, I decided to make a small review of multi-threaded collections and start with <a href="http://msdn.microsoft.com/ru-ru/library/dd287191.aspx">ConcurrentDictionary</a> (a quick overview has already been met <a href="http://habrahabr.ru/company/scout/blog/156125/">here</a> , but there is very little of it).  Actually, I was somewhat surprised that there is still no such article for .NET (but <a href="http://habrahabr.ru/post/132884/">enough</a> for <a href="http://habrahabr.ru/company/luxoft/blog/157273/">Java</a> ). <br><br>  So let's go. <br><a name="habracut"></a><br>  If you are already familiar with the Dictionary itself, you can skip the next section. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>What is a Dictionary &lt;TKey, TValue&gt;?</b> </h4><br>  Dictionary is an implementation of the standard <a href="http://en.wikipedia.org/wiki/Hashtable">Hashtable</a> . <br>  Here the following functions are interesting: <br><br><h5>  Initialization </h5><br>  Initialization occurs either during creation (if the initial size of the collection is transferred), or when the first element is added, and the nearest prime number (3) is selected as the size.  This creates 2 internal collections - <b>int [] buckets</b> and <b>Entry [] entries</b> .  The first will contain the indexes of the elements in the second collection, and she, in turn, the elements themselves in this form: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Entry { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TKey key; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br><h5>  Adding items </h5><br>  When an item is added, the hashcode of its key is calculated and then the basket index to which it will be added modulo the size of the collection: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucketNum = (hashcode &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>) % capacity;</code> </pre><br>  It will look something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/d99/fb2/a66/d99fb2a660e3ce1ce3986ddc6221f6a3.png"><br>  Then it is checked whether there is already such a key in the collection, if it does, then the Add operation will throw an exception, and assignment by index will simply replace the element with a new one.  If the maximum dictionary size is reached, an expansion occurs (a new size is selected by the nearest prime number). <br>  The complexity of the operation, respectively - O (n). <br><br>  If a collision occurs (that is, there is already an item in the bucketNum index from the index), then the new item is added to the collection, its index is stored in the basket, and the index of the old item is in its next field. <br><img src="https://habrastorage.org/getpro/habr/post_images/cd4/b8e/9df/cd4b8e9df53932e4e74f3b115ff9d757.png"><br>  Thus we get a <a href="http://en.wikipedia.org/wiki/Linked_list">unidirectional linked list</a> .  This collision resolution mechanism is called <b>chaining</b> .  If, when adding an element, the number of collisions is large (more than 100 in the current version), then when the collection is <i>expanded</i> , an <i>overhanging</i> operation <i>occurs</i> , before the execution of which a new hashcode is randomly selected. <br>  The difficulty of adding O (1) or O (n) in the event of a collision. <br><br><h5>  Deleting items </h5><br>  When deleting elements, we overwrite its contents with default values, change the next pointers of other elements when necessary, and store the index of this element in the freeList internal field, and the old value in the next field.  Thus, when adding a new element, we can reuse such free cells: <br><img src="https://habrastorage.org/getpro/habr/post_images/95f/afc/531/95fafc5319ed3e30bc5a4cf13e25c5d2.png"><br><br>  The difficulty is again O (1) or O (n) in the event of a collision. <br><br><h5>  Other </h5><br>  It is also worth noting 2 points: <br>  1) When cleaning the dictionary, its internal size does not change.  That is, potentially, you just waste a place. <br>  2) GetEnumerator simply returns an iterator over the entires collection (O (1) complexity).  If you just added items, they will return in the same order.  However, if you deleted elements and added new ones, the order will change accordingly, so you should not rely on it (especially since in future versions of the framework this may change). <br><br><h4>  <b>So what about ConcurrentDictionary?</b> </h4><br>  It would seem that there are 2 solutions in the forehead to ensure thread-safety - to wrap all calls to the dictionary in locks or to wrap all its methods in them.  However, for obvious reasons, this solution will be slow - the delays added by lock, and the restriction on 1 stream that could work with the collection does not add speed. <br><br>  Microsoft went a more optimal way and Dictionary got used to some changes.  So, thanks to the internal structure of the dictionary and its baskets, blocking is carried out by them, using the method <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBucketAndLockNo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hashcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bucketNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lockNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bucketCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lockCount</span></span></span><span class="hljs-function">)</span></span> { bucketNo = (hashcode &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>) % bucketCount; lockNo = bucketNo % lockCount; }</code> </pre><br>  At the same time, a regular dictionary could not work with this scheme, because all baskets use the same array of entries, so baskets began to be a regular single linked list: <b>volatile Entry [] m_buckets</b> (the field is declared as volitale to provide non-blocking synchronization in a situation when one thread tries to perform some operation, and the other at this moment changes the size of the collection). <br><br>  As a result, the baskets began to look like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/f64/411/2d0/f644112d0bcc2618c60743d037090d1b.png"><br><br>  <b>lockNo</b> is an index in a new array that contains synchronization objects ‚Äî <b>object [] m_locks</b> .  Its use allows different threads to change different baskets at the same time.  The size of this collection depends on the parameter <b>ConcurrencyLevel</b> which can be specified through the constructor.  It defines the approximate number of threads that will simultaneously work with the collection (by default, this is the number of processors * 4).  The higher this value, the easier it will be to write operations, but operations that require complete blocking of the entire collection ( <b>Resize, ToArray, Count, IsEmpty, Keys, Values, CopyTo, Clear</b> ) will also become much more expensive.  Also, this parameter determines how many elements of the collection fall on one lock (as the ratio of the number of baskets to the size of this collection) and when there are more elements than necessary - the collection expands, because otherwise the search for an element requires not O (1), but already O (n) by traversing linked lists.  To slightly reduce the number of initial extensions of the collection, the initial size of the dictionary is no longer 3, but 31. <br><br>  All operations acquired the form: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeBacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TKey key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Node[] buckets = m_buckets; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucketNo, lockNo; GetBucketAndLockNo(m_comparer.GetHashCode(key), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> bucketNo, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> lockNo, buckets.Length); <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (m_locks[lockNo]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buckets != m_buckets) { <span class="hljs-comment"><span class="hljs-comment">// Race condition.    ,    . continue; } Node node = m_buckets[bucketNo]; //    . } } }</span></span></code> </pre><br>  When you add a new item, you have to bypass the entire linked list just to determine if there is such a key already and if not, add it.  Similarly, when deleting - first you need to find the node that is to be deleted. <br><br>  However, for some operations, locking is not necessary in principle - these are <b>TryGetValue, GetEnumerator, ContainsKey and indexing</b> .  Why?  Because all changes in the size of the baskets are visible due to the fact that the field is volatile, any additions or changes to the elements occur by creating a new element and replacing it with the old one, and deleting is done simply by replacing the pointer to the next node. <br><br><h5>  Other </h5><br>  1) Unlike the usual Dictionary, a call to the <b>Clear</b> method resets the size of the collection to its default value. <br>  2) <b>GetEnumerator</b> - can return old values ‚Äã‚Äãin case changes were made by another thread after calling the method and how the iterator passed this element.  In the article mentioned at the beginning it was noted that <br><blockquote>  it is better to use dictionary.Select (x =&gt; x.Value) .ToArray () than dictionary.Values.ToArray () </blockquote>  And this is not quite true - instead of ‚Äúbetter,‚Äù there should be ‚Äúfaster‚Äù - due to the absence of locks, but we must take into account that these approaches <b>can</b> return different data. <br><br>  Thanks for attention. <br><br>  The article used: <br>  1. <a href="https://www.simple-talk.com/blogs/2011/09/16/the-net-dictionary/">The .NET Dictionary</a> <br>  2. <a href="https://www.simple-talk.com/blogs/2012/02/22/inside-the-concurrent-collections-concurrentdictionary/">Inside the Concurrent Collections: ConcurrentDictionary</a> <br>  3. <a href="http://www.albahari.com/threading/part5.aspx">Concurrent Collections</a> <br>  4. .NET Reflector </div><p>Source: <a href="https://habr.com/ru/post/198104/">https://habr.com/ru/post/198104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198094/index.html">Time management: a simple experiment</a></li>
<li><a href="../198096/index.html">IB far and wide on ZeroNights</a></li>
<li><a href="../198098/index.html">Write Back in MS SQL Server Analysis Service cubes</a></li>
<li><a href="../198100/index.html">ActiveRecord and transaction rollback in Yii</a></li>
<li><a href="../198102/index.html">We control the webcam with the joystick</a></li>
<li><a href="../198106/index.html">Old, kind ‚ÄúThe Matrix‚Äù or visualizer for matrix version one</a></li>
<li><a href="../198108/index.html">ICMP port knocking in OpenWRT</a></li>
<li><a href="../198110/index.html">Install pyload as standalone rocking for ReadyNAS DUO v2</a></li>
<li><a href="../198112/index.html">Translation of the book ‚ÄúAvailable 3D printing for science, education and sustainable development‚Äù (Low-cost 3D Printing for Science, Education and Sustainable Development), 2013</a></li>
<li><a href="../198114/index.html">Impractical triage - meaningless and merciless</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>