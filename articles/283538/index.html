<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We compile an audiobook base for easy filtering.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Surely many of you are familiar with the problem of tired eyes due to long work at the computer. Unfortunately, because of this, you have to li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We compile an audiobook base for easy filtering.</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Surely many of you are familiar with the problem of tired eyes due to long work at the computer.  Unfortunately, because of this, you have to limit yourself to other activities.  One of them is reading books.  In this regard, I have been listening to audiobooks for almost 5 years now almost every day.  During this time, I learned in parallel to do something and delve into the essence of voice acting.  Now I even listen to books in the gym!  Imagine how convenient it is: an hour's journey on foot to and from + a half hour of exercise.  The average book in the area of ‚Äã‚Äã10-15 hours of recording. <br><br>  Over time, more and more often there was a problem of choosing the material.  After all, the reader plays a rather big role.  Often there is a situation when someone advises a book (or in the same article on the habre in the reading room), but the audio version is not corny.  I tried to solve all these problems with a separate site.  Now there are a couple of quite large and well-known audiobooks where you can listen to them directly online.  Such sites have a rather weak book filter.  And, in fact, are purely a directory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dda/a6e/566/ddaa6e56690f4ceab16edeb1eff1032f.jpg"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  A source of information </h2><br>  For all the time, I noticed that the root tracker is one of the largest repositories of audio books.  If a book exists in this format, then it is almost certainly in handouts.  Many readers even manually make releases of torrents.  The first task was the complete synchronization of all available audiobooks from the roottracker. <br><br><h2>  Book selection </h2><br>  The next goal was to create a broad filter for the selection of the book.  Convenient filters will help change the approach to the choice of books.  If earlier you simply found an option for yourself, and then searched for its audiobook (which could not be), then now you exclude the first item and search in the database for as much as possible all existing books.  Specifically, now I managed to make the following set of filters: <br><ul><li>  Semantic global search in the entire database for all text fields </li><li>  Sorting (asc / desc) by date of torrent creation, number of views (on the site), rating (from external sources), number of downloads (according to the rutracker), and at random </li><li>  Filter by author of work, author of voice acting, genres, and the ability to exclude books that you have marked as ‚Äúread‚Äù </li><li>  Ability to subscribe to authors of books or voice.  Yes Yes!  You can choose the artist you like and subscribe to all his updates.  For example, I monitor all the books of Igor Knyazev </li></ul><br><a name="habracut"></a><br><h2>  Rutracker base </h2><br>  So, the first point is the analysis of rutraker publications and the formation of the base.  For storage I chose MongoDB.  First, ideally for a heap of not particularly related data, and second, ideally proved to be in terms of performance.  In general, it‚Äôs very simple to develop a website with a simple ‚Äúforwarding‚Äù json from UI to the base and takes minimal time.  By the way, in MongoDB 3.2 added the left outer join. <br>  The main difficulty was the unification of information.  Rutreker, though, forces him to arrange distributions (for which he thanks), but all the same for 10 years (exactly so much time has passed since the publication of the first audiobook), the format is different.  I had to open different sections at random and collect possible options. <br><br>  The parser script is written in Python, the mechanize library is used to emulate the browser, and the BeautifulSoup is used to work with the DOM. <br>  A method that returns an object that maximizes the behavior of a regular browser.  The second method receives the browser object, authorizes on the root-tracker and returns this very object, within which the authorization cookies are already stored. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBrowser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> br = mechanize.Browser() cj = cookielib.LWPCookieJar() br.set_cookiejar(cj) br.set_handle_equiv(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) br.set_handle_gzip(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) br.set_handle_redirect(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) br.set_handle_referer(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) br.set_handle_robots(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) br.set_handle_refresh(mechanize._http.HTTPRefreshProcessor(), max_time=<span class="hljs-number"><span class="hljs-number">1</span></span>) br.addheaders = [ (<span class="hljs-string"><span class="hljs-string">'User-agent'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2327.5 Safari/537.36'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Accept-Encoding'</span></span>, <span class="hljs-string"><span class="hljs-string">'gzip, deflate, sdch'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Accept-Language'</span></span>, <span class="hljs-string"><span class="hljs-string">'ru,en;q=0.8'</span></span>), ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> br <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rutrackerAuth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> params = {<span class="hljs-string"><span class="hljs-string">u'login_username'</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span>, <span class="hljs-string"><span class="hljs-string">u'login_password'</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span>, <span class="hljs-string"><span class="hljs-string">u'login'</span></span> : <span class="hljs-string"><span class="hljs-string">''</span></span>} data = urllib.urlencode(params) url = <span class="hljs-string"><span class="hljs-string">'http://rutracker.org/forum/login.php'</span></span> browser = getBrowser() browser.open(url, data) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> browser</code> </pre> <br><br>  By itself, data collection looks like a set of regular expressions in different variations: <br><br><pre> <code class="python hljs">yearRegex = <span class="hljs-string"><span class="hljs-string">r' .*(\d{4}?)'</span></span> result[<span class="hljs-string"><span class="hljs-string">'year'</span></span>] = int(re.search(yearRegex, descContent, re.IGNORECASE).group(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#     ,       timeData = soupHandle.find('div', {'id' : 'tor-reged'}).find('span').encode_contents() import locale locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8') result['creationTime'] = datetime.datetime.strptime(timeData, u'[ %d-%b-%y %H:%M ]')</span></span></code> </pre><br><br>  It is very important to use BULK queries in mongo, so that the parser does not load the base inserts with single inserts.  Fortunately, all this is done very simply: <br><br><pre> <code class="python hljs">BULK = tableHandle.initialize_unordered_bulk_op() <span class="hljs-comment"><span class="hljs-comment"># ... BULK.find({'_id' : book['_id']}).upsert().update({'$set' : result}) BULK.execute()</span></span></code> </pre><br>  The slug field is generated by the slugify package (pip install slugify). <br><br>  Here is a list of all the fields for each of the books, which I eventually collected: <br><img src="https://habrastorage.org/files/385/5e2/f77/3855e2f77da64af0986fdab0f25175c6.png"><br><br>  Immediately, we do not forget to create an index for all fields that will be sorted or filtered: <br><br><img src="https://habrastorage.org/files/d83/52c/e0c/d8352ce0c6684d54b427d0c333b2ed7d.png"><br><br>  This will slow down the insertion time, but will greatly speed the selection.  Database synchronization occurs once a day, so the second option for the site is preferable. <br><br>  Data loading occurs on all sub-forums audiobooks: <br><br><pre> <code class="python hljs">forums = [ {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'1036'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'400'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'574'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2387'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2388'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'695'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'399'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'402'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'490'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'499'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2325'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2342'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'530'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2152'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'403'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'716'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'id'</span></span> : <span class="hljs-string"><span class="hljs-string">'2165'</span></span>} ] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(pagesCount): url = <span class="hljs-string"><span class="hljs-string">'http://rutracker.org/forum/viewforum.php?f='</span></span>+forum[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]+<span class="hljs-string"><span class="hljs-string">'&amp;start='</span></span> + str(i*<span class="hljs-number"><span class="hljs-number">50</span></span>) + <span class="hljs-string"><span class="hljs-string">'&amp;sort=2&amp;order=1'</span></span></code> </pre><br><br><h2>  Base normalization </h2><br>  We downloaded the data, but there is a problem: there is no accuracy in the specified data.  Someone will write ‚ÄúV.  Gerasimov ", someone" Vyacheslav Gerasimov. "  In one place will indicate the full or alternative title of the work.  Also, the question arose in obtaining an independent evaluation of the work.  Googled a couple of book titles and looked at issuing the first sites.  One of them turned out to be fantlab.ru, which builds a rating by the votes of users, has a rather impressive database of books, contains a full description of the genre and subgenres of books, the exact name of the author and the work. <br><img src="https://habrastorage.org/files/769/8f0/080/7698f0080bed4711a432fc61ed022c56.png"><br><br><h3>  The name of the author, the name of the book </h3><br>  Absolutely all the information from the screenshot is parsed and entered into the database.  All fields are manually checked by members of the fantlab community.  Everything is perfect, but there is one problem: how to link distribution with a rutreker and a specific record with fantlab?  In the distributions do not indicate separately the name of the work.  Sometimes even the author is incorrectly written (or not indicated).  In fact, a complete source of information is the title.  All the pain can be seen in the following screenshot distributions: <br><img src="https://habrastorage.org/files/3fa/446/6bd/3fa4466bd1c04c0389fed7da5b34f987.png"><br><br>  Needless to say, even excluding all the text in angle brackets, the built-in search for fantlab does not cope and does not find anything.  I found a way out, though not quite elegant: phantomjs (selenium) + google. <br><br>  I have quite a few projects using this bundle, so the customized headless browser and basic scripts for selenium were ready for use.  In fact, I took the title from the rutracker, added the prefix "fantlab" to it and googled it.  The first result, which was matched to the address of the work, was parsed.  I‚Äôll leave a couple of comments about phantomjs: memory flows very strongly.  I have long done for myself a couple of "crutches" that allow the process to live for months on the server and not fall due to lack of memory: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resourceRequestedLogic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> driver.execute(<span class="hljs-string"><span class="hljs-string">'executePhantomScript'</span></span>, {<span class="hljs-string"><span class="hljs-string">'script'</span></span>: <span class="hljs-string"><span class="hljs-string">''' var page = this; page.onResourceRequested = function(request, networkRequest) { if (/\.(jpg|jpeg|png|gif|tif|tiff|mov|css)/i.test(request.url)) { //console.log('Final with css! Suppressing image: ' + request.url); networkRequest.abort(); return; } } '''</span></span>, <span class="hljs-string"><span class="hljs-string">'args'</span></span>: []})</code> </pre><br><br>  This function is performed at the time of the request of a resource and checks it by the mask of media files.  All images and videos are excluded.  Those.  they are not even loaded into memory.  The second function forcibly resets the cache.  You need to call on the timer once in ~ hour: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearDriverCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> driver.execute(<span class="hljs-string"><span class="hljs-string">'executePhantomScript'</span></span>, {<span class="hljs-string"><span class="hljs-string">'script'</span></span>: <span class="hljs-string"><span class="hljs-string">''' var page = this; page.clearMemoryCache(); '''</span></span>, <span class="hljs-string"><span class="hljs-string">'args'</span></span>: []})</code> </pre><br><br>  Open Google and drive any text into the search field to change the UI (to get the result of the issue).  All further requests will occur on the same page. <br><pre> <code class="python hljs">driver.get(<span class="hljs-string"><span class="hljs-string">'http://google.ru'</span></span>) driver.find_element_by_css_selector(<span class="hljs-string"><span class="hljs-string">'input[type="text"]'</span></span>).send_keys(<span class="hljs-string"><span class="hljs-string">u"  fantlab"</span></span>) driver.find_element_by_css_selector(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).click()</code> </pre><br><br>  Since the requests are all ayaksovye, we need to manually check the fact of loading.  In selenium, there are some methods for this that wait until a certain element appears on the page. <br><pre> <code class="python hljs">count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: count += <span class="hljs-number"><span class="hljs-number">1</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> count &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: link = driver.find_element_by_css_selector(<span class="hljs-string"><span class="hljs-string">'a[href*="fantlab.ru/work"]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link.get_attribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre><br><br><h3>  Genres </h3><br>  The next step: bringing to one type all the names of the authors and all genres.  In some distributions they wrote ‚Äúhorror‚Äù, in others ‚Äúhorrors‚Äù.  This is where the pymorphy2 library came to the rescue: it allows you to get the initial form of the word. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#        fullGenre = fullGenre.replace('/', ',').replace(';', ',').replace('--', '-').replace(u'', u'') fullGenre = re.sub(r'[\.|"¬´¬ª]', '',fullGenre) fullGenre = re.sub(r'\[.*?\]', '',fullGenre) #    ,     /  allGenres = filter(None, fullGenre.split(',')) allGenres = [item.strip() for item in allGenres] #    ( ) allGenres = list(set(allGenres)) insertGenresList = [] for genre in allGenres: #    ,     morphology = morph.parse(genre)[0] genre = morphology.normal_form insertGenresList.append(genre)</span></span></code> </pre><br><br><h3>  Authors Names </h3><br>  We could also come up with something with the authors of the pymorphy2 library: break into words, check the occurrences of words and their coincidence.  But then I remembered the point about the global search for everything in all fields.  This will be the solution.  For full-text search took sphinx.  It is not directly friendly with mongodb, so you need to write a script that will throw out xml with the data according to the specified scheme. <br><br><pre> <code class="python hljs">docset = ET.Element(<span class="hljs-string"><span class="hljs-string">"sphinx:docset"</span></span>) schema = ET.SubElement(docset, <span class="hljs-string"><span class="hljs-string">"sphinx:schema"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  ID   ,     idAttribute = ET.SubElement(schema, "sphinx:attr") idAttribute.set("name", "mongoid") idAttribute.set("type", "int") #    ,    text = ET.SubElement(schema, "sphinx:field") text.set("name", "audioauthor") text = ET.SubElement(schema, "sphinx:field") text.set("name", "bookauthor") text = ET.SubElement(schema, "sphinx:field") text.set("name", "title") text = ET.SubElement(schema, "sphinx:field") text.set("name", "publisher") text = ET.SubElement(schema, "sphinx:field") text.set("name", "description") #                  id globalIterator = 0 all = bookTable.find() #  ,    xml  def safeText(data): data = re.sub('&lt;[^&lt;]+?&gt;', ' ', data) data = "".join([c for c in data if c.isalpha() or c.isdigit() or c==' ']).rstrip() return data for card in all: document = ET.SubElement(docset, "sphinx:document") globalIterator += 1 #    id document.set("id", str(globalIterator)) mongoid = ET.SubElement(document, "mongoid") mongoid.text = str(card["_id"]) title = ET.SubElement(document, "audioauthor") title.text = safeText(card["audioAuthor"]) #        ...</span></span></code> </pre><br><br>  Parameters in sphinx.conf: <br><br><pre> <code class="python hljs">source src_bookaudio { type = xmlpipe2 xmlpipe_command = python /path/to/sphinx.py sql_attr_uint = mongoid } index bookaudio { morphology = stem_enru charset_type = utf<span class="hljs-number"><span class="hljs-number">-8</span></span> source = src_bookaudio path = /var/lib/sphinxsearch/data/bookaudio.main }</code> </pre><br><br>  And the command: <b>indexer bookaudio --rotate</b> <br><br>  How to use search to unify the fields?  We take a list of all authors of the books, and add the same entries.  It turns out something like: <br><blockquote>  Vyacheslav Gerasimov - 1324 <br>  Igor Knyazev - 432 <br>  ... </blockquote><br><br><pre> <code class="python hljs">authors = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allBooks: author = book[<span class="hljs-string"><span class="hljs-string">'audioAuthor'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> author <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> authors: authors[author] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: authors[author] = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  What is used as often as possible is probably the most correct form.  We take top entries and do a global search on all authors. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sphinxapi client = sphinxapi.SphinxClient() client.SetServer(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">9312</span></span>) client.SetMatchMode(sphinxapi.SPH_MATCH_ALL) client.SetLimits(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> operator sorted_x = reversed(sorted(authors.items(), key=operator.itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>))) counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted_x: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> i[<span class="hljs-number"><span class="hljs-number">0</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">' - '</span></span> + str(i[<span class="hljs-number"><span class="hljs-number">1</span></span>]) searchData = client.Query(i[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'bookaudio'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> searchData[<span class="hljs-string"><span class="hljs-string">'matches'</span></span>]: mongoId = int(match[<span class="hljs-string"><span class="hljs-string">'attrs'</span></span>][<span class="hljs-string"><span class="hljs-string">'mongoid'</span></span>]) BULK.find({<span class="hljs-string"><span class="hljs-string">'_id'</span></span> : mongoId}).upsert().update({<span class="hljs-string"><span class="hljs-string">'$set'</span></span> : {<span class="hljs-string"><span class="hljs-string">'audioAuthor'</span></span> : i[<span class="hljs-number"><span class="hljs-number">0</span></span>]}})</code> </pre><br><br>  All similar entries (including ‚ÄúV. Gerasimov‚Äù, for example) will be replaced with the most used forms. <br><br><h3>  Interface </h3><br>  Writing a web interface for all this does not carry any technical complexity.  In fact, this is an add-on for access to the database.  Here's what I got.  The list of the most downloaded audiobooks in the entire tracker history: <br><br><img src="https://habrastorage.org/files/a03/2f0/187/a032f0187e99421b89a86a95a998516b.png"><br><br>  And work with filters: <br><br><img src="https://habrastorage.org/files/fd6/203/9d8/fd62039d870c4f75b1a7be90fae18568.png"><br><br>  As you can see, I wanted to see all the books sounded by Igor Knyazev by the genre of ‚ÄúRussian fiction‚Äù, sorted by the number of downloads on the rutracker (the most downloaded ones at the top). <br><br>  A space or by clicking on the cards below reveals information about the book.  Thanks to mongodb, all filters are processed instantly in a database of 30k books. <br><br><h3>  Completion </h3><br>  Not everything is perfect: the base is not always accurate, the interface can be improved.  Filter by genre needs to be translated into a tree structure.  All this work for 3 days and for personal use and selection of books is enough for me.  Would you use this service? </div><p>Source: <a href="https://habr.com/ru/post/283538/">https://habr.com/ru/post/283538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283526/index.html">35 useful tips for Ludum Dare members</a></li>
<li><a href="../283528/index.html">What makes a programmer a good programmer?</a></li>
<li><a href="../283530/index.html">Interfaces in the real world: we design the most hellish interface</a></li>
<li><a href="../283532/index.html">Game that is not a game</a></li>
<li><a href="../283536/index.html">Security Week 19: AI in security, zero days at Microsoft and Adobe, a different look at crypto-fiber</a></li>
<li><a href="../283540/index.html">Fail2ban 0.10: New features. Test open</a></li>
<li><a href="../283542/index.html">I needed a report ...</a></li>
<li><a href="../283546/index.html">Benefits of Juniper Stacking</a></li>
<li><a href="../283548/index.html">Doomsday: What are the hidden errors of asynchronous data processing with increasing load</a></li>
<li><a href="../283550/index.html">Distribute pictures by rails after disabling Google‚Äôs svn repositories</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>