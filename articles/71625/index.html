<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous Programming - Call Chains</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When a pair of BeginXxx()/EndXxx() calls appear in the code, this is acceptable. But what if the algorithm requires several such calls in a row, then ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous Programming - Call Chains</h1><div class="post__text post__text-html js-mediator-article"><p> When a pair of <code>BeginXxx()/EndXxx()</code> calls appear in the code, this is acceptable.  But what if the algorithm requires several such calls in a row, then the number of methods (or anonymous delegates) will multiply and the code will become less readable.  Fortunately, this problem is solved in both F # and C #. </p><br><br><a name="habracut"></a><br><h3>  Task </h3><br><p>  So, imagine that you want to download a web page in a fully asynchronous mode and save it on your hard disk.  For this you need </p><br><br><ul><li>  Start downloading site page </li><li>  When it downloads, start writing the file to disk. </li><li>  When the recording is complete, close the file stream and notify the user. </li></ul><br><h3>  A simple solution </h3><br><p>  A naive solution to a problem looks like this: </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote> <code><font color="black"><font color="#0202E5">static</font> <font color="#0202E5">void</font> Main( <font color="#0202E5">string</font> [] args)&lt;br/&gt; <br> {&lt;br/&gt; <br> Program p = <font color="#0202E5">new</font> Program();&lt;br/&gt; <br> <font color="#006400">//  </font> <br> p.DownloadPage( <font color="#570000">"http://habrahabr.ru"</font> );&lt;br/&gt; <br> <font color="#006400">//  10.</font> <br> p.waitHandle.WaitOne(10000);&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#006400">//    </font> <br> <font color="#0202E5">private</font> WebRequest wr;&lt;br/&gt; <br> <font color="#0202E5">private</font> FileStream fs;&lt;br/&gt; <br> <font color="#0202E5">private</font> AutoResetEvent waitHandle = <font color="#0202E5">new</font> AutoResetEvent( <font color="#0202E5">false</font> );&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#006400">//     </font> <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> DownloadPage( <font color="#0202E5">string</font> url)&lt;br/&gt; <br> {&lt;br/&gt; <br> wr = WebRequest.Create(url);&lt;br/&gt; <br> wr.BeginGetResponse(AfterGotResponse, <font color="#0202E5">null</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#006400">//      </font> <br> <font color="#0202E5">private</font> <font color="#0202E5">void</font> AfterGotResponse(IAsyncResult ar)&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">var</font> resp = wr.EndGetResponse(ar);&lt;br/&gt; <br> <font color="#0202E5">var</font> stream = resp.GetResponseStream();&lt;br/&gt; <br> <font color="#0202E5">var</font> reader = <font color="#0202E5">new</font> StreamReader(stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> html = reader.ReadToEnd();&lt;br/&gt; <br> <font color="#006400">//   true    </font> <br> fs = <font color="#0202E5">new</font> FileStream( <font color="#570000">@"c:\temp\file.htm"</font> , FileMode.CreateNew,&lt;br/&gt; <br> FileAccess.Write, FileShare.None, 1024, <strong><font color="#0202E5">true</font></strong> );&lt;br/&gt; <br> <font color="#0202E5">var</font> bytes = Encoding.UTF8.GetBytes(html);&lt;br/&gt; <br> <font color="#006400">//   </font> <br> fs.BeginWrite(bytes, 0, bytes.Length, AfterDoneWriting, <font color="#0202E5">null</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#006400">//   ,  wait handle</font> <br> <font color="#0202E5">private</font> <font color="#0202E5">void</font> AfterDoneWriting(IAsyncResult ar)&lt;br/&gt; <br> {&lt;br/&gt; <br> fs.EndWrite(ar);&lt;br/&gt; <br> fs.Flush();&lt;br/&gt; <br> fs.Close();&lt;br/&gt; <br> waitHandle.Set();&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br><p>  This solution still flowers.  Imagine, for example, that you additionally need to download and save asynchronously all the pictures, and only when they are all saved open the folder in which they were recorded.  Using the paradigm above, this is a real nightmare. </p><br><br><h3>  Solution through anonymous delegates </h3><br><p>  The first thing you can do is group the pieces of functionality into anonymous delegates [ <a href="https://habr.com/ru/post/71625/" title="It is noteworthy that you can initially make separate methods, and then &quot;zainlaynit&quot; them using ReSharper &amp; ars; a.">1</a> ].  Then we get something like this: </p><br><br><blockquote> <code><font color="black"><font color="#0202E5">private</font> AutoResetEvent waitHandle = <font color="#0202E5">new</font> AutoResetEvent( <font color="#0202E5">false</font> );&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> DownloadPage( <font color="#0202E5">string</font> url)&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">var</font> wr = WebRequest.Create(url);&lt;br/&gt; <br> wr.BeginGetResponse(ar =&gt;&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">var</font> resp = wr.EndGetResponse(ar);&lt;br/&gt; <br> <font color="#0202E5">var</font> stream = resp.GetResponseStream();&lt;br/&gt; <br> <font color="#0202E5">var</font> reader = <font color="#0202E5">new</font> StreamReader(stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> html = reader.ReadToEnd();&lt;br/&gt; <br> <font color="#0202E5">var</font> fs = <font color="#0202E5">new</font> FileStream( <font color="#570000">@"c:\temp\file.htm"</font> , FileMode.CreateNew,&lt;br/&gt; <br> FileAccess.Write, FileShare.None, 1024, <font color="#0202E5">true</font> );&lt;br/&gt; <br> <font color="#0202E5">var</font> bytes = Encoding.UTF8.GetBytes(html);&lt;br/&gt; <br> fs.BeginWrite(bytes, 0, bytes.Length, ar1 =&gt;&lt;br/&gt; <br> {&lt;br/&gt; <br> fs.EndWrite(ar1);&lt;br/&gt; <br> fs.Flush();&lt;br/&gt; <br> fs.Close();&lt;br/&gt; <br> waitHandle.Set();&lt;br/&gt; <br> }, <font color="#0202E5">null</font> );&lt;br/&gt; <br> }, <font color="#0202E5">null</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br><p>  This solution looks good, but if the call chain is really large, the code will not be readable and difficult to manage.  This is especially true when, for example, the execution of a chain needs to be suspended and canceled. </p><br><br><h3>  Solution using asynchronous workflows </h3><br><p>  Workflow is an F # construct.  The idea is approximately the same - you define a certain block in which some operators (such as <code>let</code> , for example) are redefined.  Asynchronous workflow is such a workflow within which the operators ( <code>let!</code> <code>do!</code> And others) are redefined so that these operators allow you to ‚Äúwait‚Äù for the operation to complete.  That is, when we write </p><br><br><blockquote> <code><font color="black">async {&lt;br/&gt; <br> ‚ãÆ&lt;br/&gt; <br> <font color="#0202E5">let</font> ! x = Y()&lt;br/&gt; <br> ‚ãÆ&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br><p>  this means that we make a call to <code>BeginYyy()</code> for <code>Y</code> , and when the result is available, we write the result in <code>x</code> . </p><br><br><p>  Thus, the analogue of downloading and writing a file to F # will look something like this: </p><br><br><blockquote> <code><font color="black"><font color="#006400">//      /   </font> <br> <font color="#006400">//           F#</font> <br> <font color="#0202E5">type</font> WebRequest <font color="#0202E5">with</font> &lt;br/&gt; <br> <font color="#0202E5">member</font> x.GetResponseAsync() =&lt;br/&gt; <br> Async.BuildPrimitive(x.BeginGetResponse, x.EndGetResponse)&lt;br/&gt; <br> <font color="#0202E5">let</font> <font color="#0202E5">private</font> DownloadPage(url:string) =&lt;br/&gt; <br> async {&lt;br/&gt; <br> <font color="#0202E5">try</font> &lt;br/&gt; <br> <font color="#0202E5">let</font> r = WebRequest.Create(url)&lt;br/&gt; <br> <font color="#0202E5">let</font> ! resp = r.GetResponseAsync() <font color="#006400">// let!   </font> <br> <font color="#0202E5">use</font> stream = resp.GetResponseStream()&lt;br/&gt; <br> <font color="#0202E5">use</font> reader = <font color="#0202E5">new</font> StreamReader(stream)&lt;br/&gt; <br> <font color="#0202E5">let</font> html = reader.ReadToEnd()&lt;br/&gt; <br> <font color="#0202E5">use</font> fs = <font color="#0202E5">new</font> FileStream( <font color="#570000">@"c:\temp\file.htm"</font> , FileMode.Create,&lt;br/&gt; <br> FileAccess.Write, FileShare.None, 1024, <font color="#0202E5">true</font> );&lt;br/&gt; <br> <font color="#0202E5">let</font> bytes = Encoding.UTF8.GetBytes(html);&lt;br/&gt; <br> <font color="#0202E5">do</font> ! fs.AsyncWrite(bytes, 0, bytes.Length) <font color="#006400">//    </font> <br> <font color="#0202E5">with</font> &lt;br/&gt; <br> | :? WebException -&gt; ()&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#006400">//      ,     - </font> <br> Async.RunSynchronously(DownloadPage( <font color="#570000">"http://habrahabr.ru"</font> ))&lt;br/&gt; <br></font></code> </blockquote><br><p>  Using clever syntactic constructions, F # allows us using specially created "primitives" (such as <code>GetResponseAsync()</code> and <code>AsyncWrite()</code> ) to make calls with Begin / End semantics, but without dividing them into individual methods or delegates.  Oddly enough, you can do about the same thing in C #. </p><br><br><h3>  Solution using asynchronous enumerator </h3><br><p>  Jeffrey Richter, the well-known author of the book CLR via C #, is also the author of the <a href="http://wintellect.com/powerthreading.aspx">PowerThreading</a> library.  This library [ <a href="https://habr.com/ru/post/71625/" title="The library is really interesting &amp; ndash; I advise you to open it in Reflector &amp; rsquo; e, there are a lot of tasty. Also note that the library license only allows you to use it on Windows, which will surely piss off Mono fans.">2</a> ] provides a number of interesting features, one of which is an implementation of the asynchronous workflow analogue in C #. </p><br><br><p>  This is done very simply - we have a certain ‚Äúmanager of tokens‚Äù called <code>AsyncEnumerator</code> .  This class actually allows you to interrupt the execution of the method and continue it again.  How can I interrupt the execution of a method?  This is done using a simple <code>yield return</code> . </p><br><br><p>  Using <code>AsyncEnumerator</code> easy.  We take and add it as a parameter to our method, and also change the return value to <code>IEnumerator&lt;int&gt;</code> : </p><br><br><blockquote> <code><font color="black"><font color="#0202E5">public</font> <strong>IEnumerator&lt; <font color="#0202E5">int</font> &gt;</strong> DownloadPage( <font color="#0202E5">string</font> url, <strong>AsyncEnumerator ae</strong> )&lt;br/&gt; <br> {&lt;br/&gt; <br> ‚ãÆ&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br><p>  Next, we write code using <code>BeginXxx()/EndXxx()</code> , using three simple rules: </p><br><br><ul><li>  Each BeginXxx () receives <code>ae.End()</code> as a callback parameter. </li><li>  Each EndXxx () as a token <code>IAsyncResult</code> gets <code>ae.DequeueAsyncResult()</code> </li><li>  Every time we need to wait, we make a <code>yield return X</code> , where X is the number of operations started. </li></ul><br><p>  This is what our download method looks like when using <code>AsyncEnumerator</code> : </p><br><br><blockquote> <code><font color="black"><font color="#0202E5">public</font> IEnumerator&lt; <font color="#0202E5">int</font> &gt; DownloadPage( <font color="#0202E5">string</font> url, AsyncEnumerator ae)&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">var</font> wr = WebRequest.Create(url);&lt;br/&gt; <br> wr.BeginGetResponse(ae.End(), <font color="#0202E5">null</font> );&lt;br/&gt; <br> <font color="#0202E5">yield</font> <font color="#0202E5">return</font> 1;&lt;br/&gt; <br> <font color="#0202E5">var</font> resp = wr.EndGetResponse(ae.DequeueAsyncResult());&lt;br/&gt; <br> <font color="#0202E5">var</font> stream = resp.GetResponseStream();&lt;br/&gt; <br> <font color="#0202E5">var</font> reader = <font color="#0202E5">new</font> StreamReader(stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> html = reader.ReadToEnd();&lt;br/&gt; <br> <font color="#0202E5">using</font> ( <font color="#0202E5">var</font> fs = <font color="#0202E5">new</font> FileStream( <font color="#570000">@"c:\temp\file.htm"</font> , FileMode.Create,&lt;br/&gt; <br> FileAccess.Write, FileShare.None, 1024, <font color="#0202E5">true</font> ))&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">var</font> bytes = Encoding.UTF8.GetBytes(html);&lt;br/&gt; <br> fs.BeginWrite(bytes, 0, bytes.Length, ae.End(), <font color="#0202E5">null</font> );&lt;br/&gt; <br> <font color="#0202E5">yield</font> <font color="#0202E5">return</font> 1;&lt;br/&gt; <br> fs.EndWrite(ae.DequeueAsyncResult());&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br><p>  As you can see, the asynchronous method is now recorded in a synchronous form - we even managed to use <code>using</code> for the file stream.  The code has become more readable, unless of course additional returns yield returns are considered. </p><br><br><p>  It now remains only to call this method: </p><br><br><blockquote> <code><font color="black"><font color="#0202E5">static</font> <font color="#0202E5">void</font> Main()&lt;br/&gt; <br> {&lt;br/&gt; <br> Program p = <font color="#0202E5">new</font> Program();&lt;br/&gt; <br> <font color="#0202E5">var</font> ae = <font color="#0202E5">new</font> AsyncEnumerator();&lt;br/&gt; <br> ae.Execute(p.DownloadPage( <font color="#570000">"http://habrahabr.ru"</font> , ae));&lt;br/&gt; <br> }   &lt;br/&gt; <br></font></code> </blockquote><br><h3>  Conclusion </h3><br><p>  The problem of chains of asynchronous calls was not so terrible.  For simple situations, anonymous delegates will do;  for complex ones, there are asynchronous workflows and <code>AsyncEnumerator</code> , depending on which language is closer to you. </p><br><br><p>  Chains are simple, but what to do with whole dependency graphs?  About this - in the next post.  ‚ñ† </p><br><br><h3>  Notes </h3><br><ol><li>  <a href="https://habr.com/ru/post/71625/" title="Back to text">‚Üë</a> It is noteworthy that you can initially make separate methods, and then "zainlaynit" them using ReSharper'a. </li><li>  <a href="https://habr.com/ru/post/71625/" title="Back to text">‚Üë The</a> library is really interesting - I advise you to open it in Reflector, there are a lot of tasty things there.  Also note that the library license only allows you to use it on Windows, which will surely piss off Mono fans. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/71625/">https://habr.com/ru/post/71625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../71613/index.html">IEEE 802.11n - How many to hang in grams?</a></li>
<li><a href="../71614/index.html">IntelliJ IDEA Atlassian Connector - plugin for convenient work with Jira</a></li>
<li><a href="../71615/index.html">Abramovich's laser shield, trying to figure out how it works</a></li>
<li><a href="../71618/index.html">Diploma Topics</a></li>
<li><a href="../71619/index.html">Zend Framework: aiming for MVC for Javascript, CSS</a></li>
<li><a href="../71627/index.html">My Place and Twitter</a></li>
<li><a href="../71628/index.html">There is a page height 2000px. List of jobs with a description. Not more than 6 pieces. What is more convenient for the user?</a></li>
<li><a href="../71629/index.html">Perhaps the most convenient online music player in RuNet!</a></li>
<li><a href="../71630/index.html">Everyone on YouSticker :)</a></li>
<li><a href="../71631/index.html">Mozilla does not approve Google Chrome Frame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>