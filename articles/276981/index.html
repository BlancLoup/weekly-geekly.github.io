<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Crash course on interfaces in go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Interfaces in Go are one of the distinguishing features of a language that form the way to solve problems. When similar to interfaces in other languag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Crash course on interfaces in go</h1><div class="post__text post__text-html js-mediator-article">  Interfaces in Go are one of the distinguishing features of a language that form the way to solve problems.  When similar to interfaces in other languages, Go interfaces still have important differences and this initially leads to excessive reuse of interfaces and confusion about how and when to use them.  This is normal, but let's try to figure out what is so special about the interfaces in Go, how they are arranged, why they are so important, and what the orthogonality of the interface types and structural types in Go means. <br><br>  In this article you will learn: <br><br><ul><li>  what is the difference from interfaces in java </li><li>  important and non-obvious consequences of these differences </li><li>  how the interfaces are arranged under the hood </li><li>  remember about the empty interface (interface {}) </li><li>  We will touch on the sacred topic about generics </li><li>  let's figure out who and why should create an interface </li><li>  and try to learn how not to abuse interfaces and start living </li></ul><br><img src="https://habrastorage.org/files/ac1/5db/b35/ac15dbb350f1475ba76ac01b3b66afdc.png" alt="Header"><br>  <em>( <a href="http://agudova.com/portfolio/for-golang-community/">artwork by Svitlana Agudova</a> )</em> <br><a name="habracut"></a><br><h1>  Orthogonality </h1><br>  So, let's start with the first important point, which is quite easy to understand - <strong>interfaces define behavior</strong> .  In this regard, the interface in Go is almost the same as in Java. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, here is the interface and its implementation in Java: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speakable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String greeting = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Human</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Speakable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Speakable.greeting); } } Speakable speaker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Human(); speaker.sayHello();</code> </pre> <br>  Go example: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Speaker</span></span></span><span class="hljs-class"> interface { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SayHello</span></span></span><span class="hljs-class">() } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Human</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Greeting</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Human</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SayHello</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Println</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Greeting</span></span></span><span class="hljs-class">) } ... var s </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Speaker</span></span></span><span class="hljs-class"> s = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Human</span></span></span><span class="hljs-class">{</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Greeting</span></span></span><span class="hljs-class">: "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Hello</span></span></span><span class="hljs-class">"} s.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SayHello</span></span></span><span class="hljs-class">()</span></span></code> </pre> <br>  <a href="http://play.golang.org/p/yqvDfgnZ78">http://play.golang.org/p/yqvDfgnZ78</a> <br><br>  At first glance, the differences are purely cosmetic: <br><br><ul><li>  in Java, the keywords public / protected / etc are used, in Go - case the first letter of the name of the method determines the visibility </li><li>  in Java, interfaces with the -able postfix are more often called, while in Go it is customary to use the postfix -er (Sender, Reader, Closer, etc) </li><li>  in Java, classes are used to implement the interface; in Go, structures with methods. </li><li>  in Java, implementation of an interface is specified explicitly ( <em>implements</em> ), in Go ‚Äî implicitly ( <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> ) </li><li>  in Java, both interfaces and classes can contain both data and methods; in Go, an interface cannot contain data, only methods. </li></ul><br>  But some of these differences are key, in particular the last two of them.  Let us dwell on them in more detail: <br><br><h3>  Implicit implementation </h3><br><blockquote>  If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck. </blockquote><br>  In Go, a structure with methods will satisfy the interface simply by the fact of the method declaration.  This does not seem to be particularly important on small programs or artificial examples, but <strong>it turns out to be key in large projects</strong> , where you have to think twice before changing a class repeatedly inherited by other classes. <br><br>  The ability to easily and simply implicitly implement various interfaces allows programs to grow painlessly without needing to think through all possible interfaces in advance and not to drown in multiple inheritance.  This is by the way that Go was designed to make life easier in large projects. <br><br>  An important and not immediately obvious difference of this is how, as a result, you build the architecture of your program - in Java or C ++ you most likely start with the declaration of abstract classes and interfaces, and then proceed to specific implementations.  In Go, on the contrary, you first write a specific type, define the data and methods, <strong>and only if you really need to abstract the behavior do you</strong> create a separate interface.  Again, the scale of this difference is more pronounced on large projects. <br><br><h3>  Data vs behavior </h3><br>  If in Java both classes and interfaces describe both data and behavior, then in Go these concepts are fundamentally delimited. <br><br>  <strong>The structure stores data, but not behavior.</strong>  <strong>The interface stores the behavior, but not the data.</strong> <br><br>  If you want to add a variable to the interface like <code>Hello string</code> - know that you are doing something wrong.  If you want to embed an interface into a structure, you confuse behavior and data.  In the Java world, this is normal, but in Go, this is an important distinction, since it forms the clarity of abstractions. <br><br>  In the example above, Speaker describes the behavior, but does not say what the one who implements this interface should say.  Again, Speaker as an <strong>interface in Go code emerged from the practical need to be implemented by some other type</strong> , and not as a "base class", to which a specific implementation of Human was written. <br><br>  It is important to understand that as soon as you begin to clearly separate the abstractions of "behavior" and "data", you will begin to more clearly understand the purpose and proper way of using interfaces in Go.  <strong>Human and Speaker are orthogonal</strong> .  Human can easily satisfy 10 more interfaces (Walker, Listener, Player, Programmer, etc), and Speaker can be satisfied with dozens of types, even from other packages (Robot, Animal, Computer, etc).  And all this, with minimal syntax overhead, which, again, is important in large code bases. <br><br><h1>  Interface device </h1><br>  If you do not really understand how Human can simultaneously be Speaker and a dozen more interfaces, and still be orthogonal, let's dig deeper and see how the interfaces under the hood are arranged.  In Go 1.5 (which is itself written in Go), the interface type looks like this: <br><br>  <strong><a href="">src / runtime / runtime2.go</a></strong> <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iface</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> tab *itab data <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span>.Pointer }</code> </pre> <br>  Where tab is a pointer to an <em>Interface Table</em> or <em>itable</em> is a structure that stores some type metadata and a list of methods used to satisfy an interface. <br>  data - indicates the actual variable with a specific (static) type, <br><br>  For clarity, we slightly modify our code as follows: <br><br><pre> <code class="hljs go">h := Human{Greeting: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>} s := Speaker(h) s.SayHello()</code> </pre> <br>  <a href="http://play.golang.org/p/AB0ExdGN0W">http://play.golang.org/p/AB0ExdGN0W</a> <br><br><img src="https://habrastorage.org/files/20a/4ae/423/20a4ae42343849488b23ce79e26d4faf.png" alt="Itable"><br><br>  The figure shows that <strong>s</strong> consists of two pointers, the first indicating itable for a particular pair (static type Human, Speaker interface), and the other on a copy of the original Human value. <br><br><pre> <code class="hljs go">h := Human{Greeting: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>} s := Speaker(h) h.Greeting = <span class="hljs-string"><span class="hljs-string">"Meow"</span></span> s.SayHello() <span class="hljs-comment"><span class="hljs-comment">//  "hello"</span></span></code> </pre> <br><h3>  itable </h3><br>  Now a few words about itable.  Since this table will be unique for each pair of interface-static type, it will be irrational and inefficient to calculate it at the compilation stage (early binding). <br><br>  Instead, the compiler generates metadata for each static type, which, among other things, stores a list of methods implemented for that type.  Similarly, metadata is generated with a list of methods for each interface.  Now, during program execution, runtime Go can calculate itable on the fly (late binding) for each specific pair.  This itable is cached, so the miscalculation occurs only once. <br><br>  Knowing this, it becomes obvious why Go catches type mismatches at the compilation stage, but casting to the interface during execution.  Do not forget that it is in order to safely catch errors of casting to interface types that there is a construction comma-ok - <code>if s, ok := h.(Speaker); !ok { ... }</code>  <code>if s, ok := h.(Speaker); !ok { ... }</code> . <br><br><pre> <code class="hljs lua">var s Speaker = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) // compile-<span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> var s Speaker = <span class="hljs-built_in"><span class="hljs-built_in">io</span></span>.Reader // compile <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> var h <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = Human{} // compile <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> var s interface{}; h = s.(Human) // runtime <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></code> </pre> <br><h3>  Empty interface {} </h3><br>  Now let us recall the so-called empty interface (interface) - <code>interface{}</code> , which is generally satisfied with any type.  Since the empty interface has no methods, it‚Äôs not even necessary to calculate and store itable - just enough meta-information about the static type. <br><br>  Therefore, in memory, an empty interface looks like this: <br><img src="https://habrastorage.org/files/a3f/031/245/a3f031245db24d7e89b78b6501457c3f.png" alt="Empty Interface"><br><br>  Now, every time you want to use an empty interface - remember.  that he means nothing.  No abstraction.  This is an invisible cloak over your particular type, which hides specifics from you, and does not give any understanding about the behavior.  That is why it is necessary to use empty interfaces in the most extreme cases. <br><br><h1>  Interfaces and generics </h1><br>  As you know, in Go, generic containers are limited only to those in the language - slices, maps.  Interfaces can be used to write generic algorithms in Go.  A classic example here is such <a href="https://godoc.org/github.com/google/btree">a Binary Tree implementation</a> . <br><br><pre> <code class="hljs cs">type Item <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Less tests whether the current item is less than the given argument. // // This must provide a strict weak ordering. // If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (ie we can only // hold one of either a or b in the tree). Less(than Item) bool }</span></span></code> </pre> <br>  The btree.Item type is an interface in which the only Less method is defined that allows you to compare values.  Under the hood of the algorithm, a slice from Item is used, and the algorithm doesn‚Äôt care much what static type is there - the only thing it needs is to be able to compare values, and this is what the Less () method gives us. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyInt</span></span></span><span class="hljs-class"> int func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyInt</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Less</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">than</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyInt</span></span></span><span class="hljs-class">) bool { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">than</span></span></span><span class="hljs-class"> } b := btree.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">New</span></span></span><span class="hljs-class">(10) b.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceOrInsert</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyInt(5)</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  A similar approach can be seen in the standard library in the <a href="https://golang.org/pkg/sort/">sort</a> package ‚Äî any type that satisfies the interface sort.Interface can be passed as a parameter to the sort.Sort function, which will sort it: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Interface interface { // Len <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() <span class="hljs-type"><span class="hljs-type">int</span></span> // Less reports whether the element <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i should sort <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> the element <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> j. Less(i, j <span class="hljs-type"><span class="hljs-type">int</span></span>) <span class="hljs-type"><span class="hljs-type">bool</span></span> // Swap swaps the elements <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j <span class="hljs-type"><span class="hljs-type">int</span></span>) }</code> </pre> <br>  For example: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> } // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge</span></span></span><span class="hljs-class"> implements sort.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interface</span></span></span><span class="hljs-class"> for []</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> based on // the </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> field. </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge</span></span></span><span class="hljs-class"> []</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Len</span></span></span><span class="hljs-class">() int { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Swap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">] = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">] } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Less</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) bool { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">].</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">].</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> } ... people := []</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">{ {"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bob</span></span></span><span class="hljs-class">", 31}, {"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">John</span></span></span><span class="hljs-class">", 42}, {"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Michael</span></span></span><span class="hljs-class">", 17}, {"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jenny</span></span></span><span class="hljs-class">", 26}, } sort.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sort</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByAge(people)</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><h1>  How to stop abusing interfaces and start living </h1><br>  Many newcomers to Go, especially those who have switched from languages ‚Äã‚Äãwith dynamic typing, see in interface types a way to not work with specific types.  ‚ÄúI‚Äôll wrap everything up in interface {},‚Äù the developer thinks and pollutes his program with interfaces that are mostly empty. <br><br>  But the golden rule here sounds like this - always work with specific types, and use the interface only where it is needed, and the empty interface is generally in the most extreme cases when there is no other way. <br><br>  For example, you are writing a dashboard on which you output some data, and this data comes from one source as float64 values, and from another as strings ("failed", "success", etc.).  How do you implement a function that receives values ‚Äã‚Äãby channel and displays them on the screen? <br><br>  Most beginners will say - easy, let's make a channel of empty interfaces ( <code>chan interface{}</code> ) and pass on it, and then do the castes to the type: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ch { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> x := v.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>: RenderFloat64(x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: RenderString(x) } } }</code> </pre> <br>  And, although this code also has the right to exist, we can make it more beautiful.  Let's think what is common in our case for float64 and string?  The fact that both of them should be rendered is already a candidate for creating an interface with the Render method.  Let's try: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Renderer</span></span></span><span class="hljs-class"> interface { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Render</span></span></span><span class="hljs-class">() }</span></span></code> </pre> <br>  Further, since we cannot hang methods on standard types (it will already be a different type), we will create our own MyFloat and MyString: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> ( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFloat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float64</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> )</span></span></code> </pre> <br>  And we implement the Render methods for everyone, automatically satisfying the Renderer interface: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f MyFloat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s MyString)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... }</code> </pre> <br>  And now our <code>Display</code> function will look like this: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Renderer)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ch { v.Render() } }</code> </pre> <br>  Much more beautiful and concise, is not it?  Now, if we add another type that we need to be able to render in Display, we simply add the Render method and we don‚Äôt have to change anything else. <br><br>  And, importantly, this code displays the real state of affairs - combining the types under the umbrella of the interface according to their general behavior.  This behavior is orthogonal to the data itself, and now it is reflected in the code. <br><br><h1>  Interface sizes </h1><br>  In <a href="https://habrahabr.ru/post/272383/">Go Proverbs</a> there is such a postulate - <em>"The larger the interface, the weaker the abstraction</em> . <em>"</em>  In the example above, a small interface with just one method helped to very clearly describe the abstraction of the ‚Äúvalues ‚Äã‚Äãto be rendered‚Äù.  If we created an interface with a bunch of methods that are specific to, say, string - we would not be able to use it for float64, and we would have to invent something new. <br><br>  In Go, most interfaces contain 1-2 methods, no more.  But this, of course, is not a ban - if you absolutely need an interface with hundreds of methods (for example, for some mocks) - this is also ok. <br><br><h1>  Who and when should create the interface? </h1><br>  I had an interesting discussion, during which the following statement was made - <em>"every library in Go must export an interface</em> . <em>"</em>  Like, if I want to lock (mock) the functionality of the library, then it will be enough for me to simply implement this interface in my stub and test against it. <br><br>  This is not true.  Each library should not export an interface, and the general rule for determining who should create an interface can be described as follows: <br><br>  <strong>The interface is created by the consumer (consumer), and not by the producer (producer).</strong> <br><br>  If your library implements StaticType1, there is no need to invent an interface for it.  If you, as a library consumer, want to abstract the behavior of a type, lock it and create StaticType2, which in your code should be interchangeable with StaticType1 - you will implement the Interface yourself, and use it yourself.  This is your task - you solve it by means of the language. <br>  In the sort library already mentioned above, the sort.Interface interface is needed for the sort.Sort function to work ‚Äî that is, the library itself and is its consumer. <br><br><img src="https://habrastorage.org/files/d62/14c/58c/d6214c58c48e41238271df1fc02da9d2.png"><br><br><h1>  Summary </h1><br>  For all its simplicity, the type system in Go still creates some difficulties when switching from other languages.  Someone is trying to squeeze it into the SOLID principle, someone is trying to make analogies with classes, someone considers specific types to be evil, and the others are good, and this creates certain difficulties for beginners.  But this is normal, almost everything goes through this, and I hope that this article has clarified a bit the essence, purpose and purpose of interfaces in Go. <br><br>  Summarizing, three theses: <br><br><ul><li>  interfaces define behavior, static types are data </li><li>  the larger the interface, the weaker the abstraction </li><li>  the interface is usually created by the consumer. </li></ul><br><h1>  Links </h1><br><ul><li>  <a href="https://golang.org/doc/effective_go.html">Effective Go - Interfaces</a> </li><li>  <a href="http://research.swtch.com/interfaces">Go Data Structures: Interfaces (2009)</a> </li><li>  <a href="https://medium.com/%40rakyll/interface-pollution-in-go-7d58bccec275">Interface types in Go</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/276981/">https://habr.com/ru/post/276981/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276971/index.html">RxSwift in action - we write reactive application</a></li>
<li><a href="../276973/index.html">Explaining the inexplicable. Part 2</a></li>
<li><a href="../276975/index.html">FRUSDR update for optimal server performance (INTEL platform)</a></li>
<li><a href="../276977/index.html">Domain telephony</a></li>
<li><a href="../276979/index.html">PRIMEFLEX vShape - turnkey solution for the implementation of virtualization</a></li>
<li><a href="../276983/index.html">VK vulnerability: access to previews of photos from dialogues and hidden albums of any user</a></li>
<li><a href="../276987/index.html">Part-to-whole ratio in temporal / event ontology</a></li>
<li><a href="../276989/index.html">Checking WPF source code for examples from Infragistics</a></li>
<li><a href="../276991/index.html">List of technical and IT conferences 2016. Part # 2</a></li>
<li><a href="../276995/index.html">Technologies: death and rebirth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>