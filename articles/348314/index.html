<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsers, word processing. Just about the complicated. CFG, BNF, LL (k), LR (k), PEG and other scary words</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably every programmer had to deal with tasks like ‚Äúread something in format A and perform some manipulations with it‚Äù. Whether it be json, logs of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsers, word processing. Just about the complicated. CFG, BNF, LL (k), LR (k), PEG and other scary words</h1><div class="post__text post__text-html js-mediator-article">  Probably every programmer had to deal with tasks like ‚Äúread something in format A and perform some manipulations with it‚Äù.  Whether it be json, logs of nginx, cfg, sql, yaml, csv or something else.  Well, when you can use the library, however, for various reasons, it is not always possible.  Then the question arises of creating your own parser for a given format.  And this, as the English say, often turns out to be PITA (pain in ...).  In this article I will try to alleviate this pain.  Who cares, welcome. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  So the question is, what exactly is this article about?  Here I will try to help the reader to get out of the situation with the least losses, when you need to parse some text format, and the library will not work.  That is, to solve an absolutely specific problem by common means. <br><br>  At once I will make a reservation, the topic in itself is not enough that it is VERY difficult, it is also impossible to be extensive and to cover everything in one article just will not work.  Therefore, I will start from the general and will proceed to the particular, specifically in this article, giving a review of the tools (which, however, can be used to solve very specific parsing problems) rather than diving deep into the concepts.  Perhaps, if readers are interested, the article will turn into a cycle in which I can reveal specific questions in more detail. <br><br>  I decided to write it because the information available on the topic is scattered and often incomplete, there are very few sources in Russian, and those that exist imply a fairly decent acquaintance of the reader with very specific mathematics.  Therefore, so that the reader far from the topic did not experience pain from the consciousness of his (imaginary) inferiority, I decided to try to describe this topic as simply as possible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Be brave, the article is large, some places will not be very interesting, but without them it can be incomprehensible. <br><br><h2>  Basic concepts </h2><br>  Before talking on the topic is to determine the basic concepts, so that there is no ambiguity.  This is a glossary of this article.  It may coincide with generally accepted terminology, but generally speaking, it is not obliged, since it shows a picture that is being formed in the author‚Äôs head. <br>  So: <br><br><ul><li>  <b>input character stream</b> (hereinafter <b>input stream</b> or <b>stream</b> ) - a stream of characters to parse, fed to the input of the parser </li><li>  <b>parser / parser</b> ( <b>parser, analyzer</b> ) - a program that accepts input stream and converts it into <b>AST</b> and / or allows you to bind executable functions to grammar elements </li><li>  <b>AST</b> (Abstract Syntax Tree) / <b>ASD</b> (Abstract Syntax Tree) ( <b>output data structure</b> ) - An object structure representing the hierarchy of <b>non-terminal</b> grammar entities of the parsed stream and their constituent <b>terminals</b> .  For example, the algebraic flow (1 + 2) + 3 can be represented as EXPRESSION (EXPRESSION (NUMBER (1) OPERATOR (+) NUMBER (2)) OPERATOR (+) NUMBER (3)).  As a rule, then this tree is somehow processed by the client of the parser to get results (for example, counting the response of this expression) </li><li>  <b>CFG</b> (Context-free grammar) / <b>CSG</b> (Context-free grammar) is the most common grammar type used to describe the incoming character stream for a parser (not only for this, of course).  Characterized by the fact that the use of its rules does not depend on the context (which does not exclude the fact that in some way it sets the context for itself, for example, the rule for calling a function will not matter if it is inside a stream fragment described by the comment rule).  Consists of product rules defined for terminal and non-terminal characters. </li><li>  <b>Terminal symbols</b> ( <b>terminals</b> ) - for a given parse language - a set of all (atomic) symbols that can occur in the incoming stream </li><li>  <b>Not terminal characters</b> ( <b>not terminals</b> ) - for a given parsing <b>language</b> - a set of all characters that are not found in the input stream, but are participating in grammar rules. </li><li>  <b>parse language</b> (in most cases, there will be a <b>CLS</b> ( <b>context-free language</b> )) - a set of all terminal and non-terminal symbols, as well as a YOG for a given input stream.  For example, in natural languages, the terminal symbols are all letters, numbers and punctuation marks used by the language, not the terminals will be words and sentences (and other constructions like subject, predicate, verbs, adverbs, etc.), but grammar itself language. </li><li> <b>BNF</b> (Backus-Naur Form, Backus normal form) / <b>BNF</b> (Backus-Naur form) is a form in which some syntactic categories are sequentially defined through others.  The representation form of the CGC, often used directly to specify the input to the parser.  Characterized by the fact that the ONE nonterminal symbol is always definable.  The classic form of the form is: <br> <code>&lt; &gt; ::= &lt;.1&gt; | &lt;.2&gt; | . . . | &lt;.n&gt;</code> <br>  There are also a number of varieties, such as ABNF (AugmentedBNF), EBNF (ExtendedBNF), etc. In general, these forms somewhat extend the syntax of the usual BNF notation. </li><li>  <b>LL (k), LR (k), SLR, ...</b> are types of parser algorithms.  In this article we will not dwell on them if someone is interested, below I will give a few links to material from which you can learn about them.  However, let us dwell on another aspect, on the grammars of parsers.  The grammar of the LL / LR parser groups is BNF, this is true.  But it is also true that not every BNF grammar is also LL (k) or LR (k).  Anyway, what does the letter k in the LL / LR (k) record mean?  It means that to parse the grammar you need to look forward a maximum of k terminal characters along the stream.  That is, to parse (0) grammar you only need to know the current character.  For (1), you need to know the current and 1 next character.  For (2) - current and 2 following, etc.  A little more about choosing / compiling BNF for a particular parser will be discussed below. </li><li>  <b>PEG</b> ( <b>Parsing expression grammar</b> ) / <b>PB grammar</b> is a grammar designed to recognize strings in a language.  An example of such a grammar for algebraic actions +, -, *, / for non-negative numbers is: <br> <code>Value ‚Üê [0-9]+ / '(' Expr ')' <br> Product ‚Üê Value (('*' / '/') Value)* <br> Sum ‚Üê Product (('+' / '-') Product)* <br> Expr ‚Üê Sum</code> </li> </ul><br>  Finally, we are done with basic concepts.  Let us turn to the choice of the method of analysis. <br><br><h2>  Parsing options </h2><br>  When we are faced with the task of creating a parser, the solution boils down, as a rule, to 4 main options: <br><br><ul><li>  Solve the problem in the forehead, that is, analyze the input stream character-by-character and using the rules of grammar, build an ASD or immediately perform the operations we need on the components we need.  Of the benefits - this option is the most simple, if we talk about the algorithms and the presence of the mathematical base.  Minuses - the probability of an accidental error is close to the maximum, since you have no formal criteria for whether you have taken into account all the rules of grammar when building a parser.  Very time consuming.  In general, it is not very easily modified and not very flexible, especially if you have not implemented the construction of the ASD.  Even with long work parser you can not be sure that it works absolutely correctly.  From plus or minus.  In this embodiment, it all depends on the directness of your hands.  We will not talk about this option in detail. </li><li>  We use regular expressions!  I will not joke right now on the topic of the number of problems and regular expressions, but in general, the method, although affordable, is not too good.  In the case of a complex grammar, working with regulars will turn into hell of a hell, especially if you try to optimize the rules to increase work speed.  In general, if you choose this method, I can only wish you good luck.  Regular expressions are not for parsing!  And let me not assure the opposite.  They are designed to search and replace.  Attempting to use them for other things inevitably leads to losses.  With them, we either significantly slow down the analysis, passing along the line many times, or lose brain cells, trying to figure out a way to remove the tonsils through the anus.  Perhaps the situation will be slightly improved by an attempt to cross this method with the previous one.  Probably no.  In general, the benefits are almost the same as in the past.  Only still need knowledge of regular expressions, and it is desirable not only to know how to use them, but also to have an idea how fast the option you are using works.  Of the minuses, too, about the same as in the previous version, except that it is less time consuming. </li><li>  Use a bunch of parsing tools for bnf!  This option is more interesting.  Firstly, we are offered a version of the type lex-yacc or flex-bison, secondly, in many languages ‚Äã‚Äãwe can find native libraries for parsing BNF.  The keywords for the search can be taken LL, LR, BNF.  The point is that all of them in some form accept the BNF variation as input, and LL, LR, SLR, etc. are specific algorithms that the parser uses.  Most often, the end user is not particularly interested in which algorithm is used, although they have certain limitations on grammar parsing (we‚Äôll dwell on this below) and may have different work times (although most say O (L), where L is the length of the stream of characters).  One of the advantages is a stable toolkit, an intelligible form of recording (BNF), adequate estimates of working time and availability of a BNF record for most modern languages ‚Äã‚Äã(if desired, can be found for sql, python, json, cfg, yaml, html, csv, and many others).  Of the minuses - not always the obvious and convenient interface of tools, you may have to write something on an unfamiliar PL, especially the understanding of grammar with different tools. </li><li>  Use the PEG parsing tools!  This is also an interesting option, plus, here is a bit richer with libraries, although they, as a rule, are of several different eras (PEG was proposed by Brian Ford in 2004, while the roots of BNF stretch in the 1980s), that is, noticeably younger and worse ironed and live mostly on github.  Of the benefits - quickly, simply, often - natively.  Of the minuses - heavily dependent on the implementation.  The pessimistic estimate for the PEG according to the specification seems to be O (exp (L)) (another thing, to create such a grammar will have to try hard).  Strongly dependent on the presence / absence of the library.  For some reason, many creators of PEG libraries consider tokenization and search / replace operations to be sufficient, and no AST to you, or even binding functions to grammar elements.  But in general, the topic is promising. </li></ul><br><h2>  We solve the problem of parsing </h2><br>  Let's go in order, skip the brute-force and regexp options. <br><br><h3>  Bnf </h3><br>  So the time has come to dwell a bit more on the parser's algorithms, or rather, on the grammars used by them.  So, GLR (up to O (L ^ 3) or up O (L ^ 4), as some sources (antlr) say), LR, LALR and LL are most often found, all within O (L).  GLR has the greatest ‚Äúgluttony‚Äù - it is able to better handle grammar ambiguities, but due to this it is slower.  That is, if we consider the ‚Äúsize‚Äù of the class of grammars processed by the parser (let's call it the power of the parser), then all other things being equal, the power will be distributed as follows: GLR&gt; LR&gt; LALR&gt; SLR&gt; LL.  Resource consumption, respectively, close to the opposite.  But back to the grammar. <br><br>  Compiling or searching the grammar for the LR parser as a whole is quite simple and there is a high chance that the BNF compiled by you ‚Äúon the knee‚Äù will be easily accepted by the parser and processed.  The main thing is that the grammar should be complete, that is, to describe all possible situations of the input stream, besides try to understand by yourself whether knowing the following k characters (depending on the selected LR parser) can unambiguously determine which rule should apply. <br><br>  For the LR-parser there can be conflicts of the following type: <br><br><ol><li>  Shift-reduce: <code>NT ::= x NT | x</code>  <code>NT ::= x NT | x</code> .  Where is the length x&gt; k.  It is solved this way: <code>NT ::= xK; K ::= K | e</code> <code>NT ::= xK; K ::= K | e</code> </li><li>  Convolution (reduce-reduce): <br> <code>NT :: = e <br> A ::= NT <br> B ::= NT <br> D ::= B uv | A uw</code>  <code>NT :: = e <br> A ::= NT <br> B ::= NT <br> D ::= B uv | A uw</code> , where the length u&gt; k <br>  It is solved like this: <br> <code>R ::= Au <br> J ::= Bu <br> D ::= Rw | Jv</code> <br> </li></ol><br>  Conflicts of a type are characteristic for an LL parser (it is necessary, but not enough, to reformulate them, upon request I can dwell on LL (k) grammars in more detail in the following article): <br><br>  Left recursion: <code>NT ::= NT x | y</code>  <code>NT ::= NT x | y</code> , where x, y are arbitrary strings of terminals / not terminals, but y does not start with NT <br><br>  Example: <code>E ::= E + T | T</code>  <code>E ::= E + T | T</code>  It can be reformulated as: <br><br> <code>E ::= TZ <br> Z ::= '+' TZ | x</code> <br> <br>  Left factorization: <code>NT ::= ax | ay</code>  <code>NT ::= ax | ay</code> , where a is a string of length&gt; k of our parser.  Solving is even simpler: <code>NT ::= aC; C = x|y</code> <code>NT ::= aC; C = x|y</code> <br><br>  So what are we going to decide? <br><br>  Well, let's say it will be a simple calculator: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> ::= "+ "| "-" | "*" | "/" STMT ::= "(" STMT ")" | STMT <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> STMT | <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> | <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> ::= <span class="hljs-type"><span class="hljs-type">INT</span></span> "." <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-type"><span class="hljs-type">INT</span></span> ::= (POSITIVE_DIGIT <span class="hljs-type"><span class="hljs-type">INT</span></span> | DIGIT ) | DIGIT POSITIVE_DIGIT ::= "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9" DIGIT ::= POSITIVE_DIGIT | "0"</code> </pre> <br>  If the reader tries to find the grammar of the calculator on the Internet, he will see that often the operations of addition / subtraction and multiplication / division are processed by different grammatical structures.  This was done specifically to take into account in the grammar such a moment as the priority of operations (and also to reveal the ambiguities of the grammar).  We will do this further in the course of the article. <br><br>  We try to find a native Python-solution, <a href="https://wiki.python.org/moin/LanguageParsing">we find a lot of them</a> . <br><br><ol><li>  Use <b>parglare</b> .  This is the Python library / cli-tool, which implements an LR / GLR parser with a fairly wide range of capabilities (inline functions, prioritization, trees, a distinct grammar analysis, and a QA visualizer resulting from grammar processing). <br><br><pre> <code class="bash hljs">pip install parglare</code> </pre> <br>  We reformulate our calculator as parglare asks. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> : "+ "| "-" | "*" | "/" | = STMT : "(" STMT ")" | STMT <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> STMT | <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> | <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> : <span class="hljs-type"><span class="hljs-type">INT</span></span> "." <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-type"><span class="hljs-type">INT</span></span> : (POSITIVE_DIGIT <span class="hljs-type"><span class="hljs-type">INT</span></span> | DIGIT ) | DIGIT POSITIVE_DIGIT : "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9" DIGIT : POSITIVE_DIGIT | "0"</code> </pre> <br>  Is that enough?  Save to calc.pg and use the cli-tool <br><br><pre> <code class="bash hljs">pglr --debug check calc.pg Error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file <span class="hljs-string"><span class="hljs-string">"/home/survivor/tests/calc.pg"</span></span> at position 1,42 =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span> | *=\nSTMT <span class="hljs-string"><span class="hljs-string">". Expected: Name or StrTerm or RegExTerm</span></span></code> </pre><br>  Oops!  it seems something extra.  Bingo!  I put in for some reason |  = after ‚Äú/‚Äù (no, I know where he is from there (but this does not apply to the topic of the article)).  The main thing is that the program clearly indicated this to us.  Further, after the correction, the program will complain about the absence;  at the end of the nonterminal designation and on the bracket in the INT rule.  The reformulated version will look like this: <br><br><pre> <code class="hljs pgsql">STMT : "(" STMT ")" | STMT <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> STMT | <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> | <span class="hljs-type"><span class="hljs-type">INT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> : "+ "| "-" | "*" | "/"; <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> : <span class="hljs-type"><span class="hljs-type">INT</span></span> "." <span class="hljs-type"><span class="hljs-type">INT</span></span>; <span class="hljs-type"><span class="hljs-type">INT</span></span> : POSITIVE_DIGIT <span class="hljs-type"><span class="hljs-type">INT</span></span> | POSITIVE_DIGIT DIGIT | DIGIT; POSITIVE_DIGIT : "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"; DIGIT : POSITIVE_DIGIT | "0";</code> </pre> <br>  As a result, pglr likes everything and he will tell us: <br><br><pre> <code class="bash hljs">Grammar ok!</code> </pre> <br>  BUT: <br><br><pre> <code class="bash hljs">There are 4 Shift/Reduce conflicts. Either use <span class="hljs-string"><span class="hljs-string">'prefer_shifts'</span></span> parser mode, try to resolve manually or use GLR parsing. There are 7 Reduce/Reduce conflicts. Try to resolve manually or use GLR parsing.</code> </pre><br>  Well, as described above for debug, you can read their beautiful (and understandable) description.  Well, let's think about it.  First, let's not be the smartest and throw out positive_digit.  If someone writes 0034 - firstly, he is angry with Pinocchio on his own, and secondly, most PLs, including Python, will not tell us anything when converting this to a number, and will simply give out 34. Well, that will help a lot.  Secondly, see here the division into int / float, for simplicity we assume that all numbers are floating point.  Also, pglr understands regular expressions in BNF, use this.  We get: <br><br><pre> <code class="hljs pgsql"> STMT : "(" STMT ")" | STMT <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> STMT | <span class="hljs-type"><span class="hljs-type">FLOAT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> : "+ "| "-" | "*" | "/"; <span class="hljs-type"><span class="hljs-type">FLOAT</span></span> : /\d+(\.\d+)?/;</code> </pre> <br>  and still <br><br><pre> <code class="bash hljs">There are 4 Shift/Reduce conflicts. Either use <span class="hljs-string"><span class="hljs-string">'prefer_shifts'</span></span> parser mode, try to resolve manually or use GLR parsing.</code> </pre> <br>  Well, be that as it may, grammar <br><br><pre> <code class="bash hljs">*** GRAMMAR *** Terminals: + EOF ) ( FLOAT STOP * / - \d+(\.\d+)? EMPTY NonTerminals: OPERATOR S<span class="hljs-string"><span class="hljs-string">' STMT Productions: 0: S'</span></span> = STMT STOP 1: STMT = STMT OPERATOR STMT 2: STMT = ( STMT ) 3: STMT = FLOAT 4: OPERATOR = + 5: OPERATOR = - 6: OPERATOR = * 7: OPERATOR = /</code> </pre> <br>  Let's try to parse something. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> parglare <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Grammar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> parglare <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Parser grammar = Grammar.from_file(<span class="hljs-string"><span class="hljs-string">'calc.pg'</span></span>) parser = Parser(grammar, build_tree=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, prefer_shifts=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) result = parser.parse(<span class="hljs-string"><span class="hljs-string">'1 + 2 / (3 - 1 + 5)'</span></span>)</code> </pre> <br>  We get: <br><br><pre> <code class="hljs xml">result <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NonTerm(start=0,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">end</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">19,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sym</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">STMT)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  we can get result.children and further along the tree.  We can calculate the final expression at the same time, but we will not do it here.  It is important that we have access to the object tree, for the terminal symbols they are also their ‚Äúvalue‚Äù and we can do whatever we want with this. <br><br>  If we want to fix conflict situations, how else can we resolve grammar conflicts? <br><br>  There are several options: <br><br><ul><li>  Solve the problem by reformulating the grammar. <br>  For example: <br><br><pre> <code class="hljs javascript">STMT : TERM | STMT ADDOP TERM ; TERM : FACTOR | FACTOR MULOP FACTOR ; FACTOR : <span class="hljs-string"><span class="hljs-string">"("</span></span> STMT <span class="hljs-string"><span class="hljs-string">")"</span></span> | NUMBER; ADDOP : <span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>; MULOP : <span class="hljs-string"><span class="hljs-string">"*"</span></span>|<span class="hljs-string"><span class="hljs-string">"/"</span></span>; NUMBER: <span class="hljs-regexp"><span class="hljs-regexp">/\d+(\.\d+)?/</span></span>;</code> </pre> <br>  As you can see, the task has become more complicated, but not too much.  Moreover, if we do the analysis of just such a tree, it will be easier for us. </li><li>  Use the means of parglare itself <br><br>  In this case, the solution is more specific, but in some cases more convenient.  Parglare provides a good toolkit for prioritizing rules, for example, for arithmetic expressions you can set the operation priority and associativity (from which side this operation is performed - from left to right or from right to left) the higher the priority, the operation will be performed earlier (relative to the others), for example, our grammar in this notation might look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">STMT</span></span> : <span class="hljs-type"><span class="hljs-type">STMT</span></span> <span class="hljs-type"><span class="hljs-type">ADDOP</span></span> <span class="hljs-type"><span class="hljs-type">STMT</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>} | <span class="hljs-type"><span class="hljs-type">STMT</span></span> <span class="hljs-type"><span class="hljs-type">MULOP</span></span> <span class="hljs-type"><span class="hljs-type">STMT</span></span> {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>} | <span class="hljs-string"><span class="hljs-string">"("</span></span> <span class="hljs-type"><span class="hljs-type">STMT</span></span> <span class="hljs-string"><span class="hljs-string">")"</span></span> | <span class="hljs-type"><span class="hljs-type">NUMBER</span></span>; <span class="hljs-type"><span class="hljs-type">ADDOP</span></span> : <span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>; <span class="hljs-type"><span class="hljs-type">MULOP</span></span> : <span class="hljs-string"><span class="hljs-string">"*"</span></span>|<span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-type"><span class="hljs-type">NUMBER</span></span>: /\d+(\.\d+)?/;</code> </pre> <br>  Parsing, but not working correctly.  For example, for <br><br> <code>1 + 2 / (3 - 1 + 5)</code> <br> <br>  we get (with non-tree parsing) <br><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">u'+'</span></span>, [<span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">u'/'</span></span>, [<span class="hljs-string"><span class="hljs-string">u'('</span></span>, [<span class="hljs-string"><span class="hljs-string">'3'</span></span>, <span class="hljs-string"><span class="hljs-string">u'-'</span></span>, [<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">u'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'5'</span></span>]], <span class="hljs-string"><span class="hljs-string">u')'</span></span>]]]</code> </pre> <br>  which obviously does not match the expected result: <br><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">u'+'</span></span>, [<span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">u'/'</span></span>, [<span class="hljs-string"><span class="hljs-string">u'('</span></span>, [[<span class="hljs-string"><span class="hljs-string">'3'</span></span>, <span class="hljs-string"><span class="hljs-string">u'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>], <span class="hljs-string"><span class="hljs-string">u'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'5'</span></span>], <span class="hljs-string"><span class="hljs-string">u')'</span></span>]]]</code> </pre> <br></li></ul><br>  Morals - it is better to use the standard moments described in BNF.  Brilliant and cool stuff shine and cool, but not always work.  Or I do not know how to cook them.  And most parsing libraries have alpha |  beta. <br><br>  According to the author about this bug, it is due to the fact that, in essence, the associativity (left) of the parser at the algorithm level means to prefer to reduce rather than shift.  That is, in fact, if there is an opportunity to ‚Äúchop off‚Äù the rule, or continue within its framework - it is better to chop off.  Since the parsing goes from left to right, this means left associativity.  The reason for the error is that the priority for the rules inside ADDOP / MULOP is not defined, which breaks the entire rule. <br><br>  However, even if we prioritize (for example: <br><br> <code>ADDOP: ‚Äú+‚Äù {1} <br> | ‚Äú-‚Äù {1}</code>  <code>ADDOP: ‚Äú+‚Äù {1} <br> | ‚Äú-‚Äù {1}</code> ), will not work anyway, already due to another error. <br><br>  Finally, an example with inline functions that are bound directly to the rules from the parglare documentation. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> parglare <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Parser, Grammar grammar = <span class="hljs-string"><span class="hljs-string">r""" E: E '+' E {left, 1} | E '-' E {left, 1} | E '*' E {left, 2} | E '/' E {left, 2} | E '^' E {right, 3} | '(' E ')' | number; number: /\d+(\.\d+)?/; """</span></span> <span class="hljs-comment"><span class="hljs-comment"># Define inline functions bound to grammar rule actions = { "E": [lambda _, nodes: nodes[0] + nodes[2], # for rule[0] ‚Äú+‚Äù lambda _, nodes: nodes[0] - nodes[2], # for rule[1] ‚Äú-‚Äù lambda _, nodes: nodes[0] * nodes[2], # for rule[2] ‚Äú*‚Äù lambda _, nodes: nodes[0] / nodes[2], # for rule[3] ‚Äú/‚Äù lambda _, nodes: nodes[0] ** nodes[2], # for rule[4] ‚Äú^‚Äù lambda _, nodes: nodes[1], # for rule[5] ‚Äú()‚Äù - just get the middle lambda _, nodes: nodes[0]], # for rule[6] just get node "number": lambda _, value: float(value), # for rule - convert to float } g = Grammar.from_string(grammar) parser = Parser(g, debug=True, actions=actions) result = parser.parse("34 + 4.6 / 2 * 4^2^2 + 78") print("Result = ", result) # Output # -- Debuging/tracing output with detailed info about grammar, productions, # -- terminals and nonterminals, DFA states, parsing progress, # -- and at the end of the output: # Result = 700.8</span></span></code> </pre> <br></li><li>  Next, try the standalone ANTLR tool. <br><br>  Installation is pretty simple, for linux it is <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lib $ curl -O http://www.antlr.org/download/antlr-4.7.1-complete.jar $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CLASSPATH=<span class="hljs-string"><span class="hljs-string">".:/usr/local/lib/antlr-4.7.1-complete.jar:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$CLASSPATH</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> antlr4=<span class="hljs-string"><span class="hljs-string">'java -Xmx500M -cp "/usr/local/lib/antlr-4.7.1-complete.jar:$CLASSPATH" org.antlr.v4.Tool'</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grun=<span class="hljs-string"><span class="hljs-string">'java org.antlr.v4.gui.TestRig'</span></span></code> </pre> <br>  In order to work on python2, you still need to install <br><br><pre> <code class="bash hljs">pip install antlr4-python2-runtime</code> </pre> <br>  Then try to make a grammar for it.  It has a slightly different format, so we replace the double quotes with single quotes and slightly rewrite the regular expression, as well as add the notation for WS, which was set by default in the previous tool.  In our case, the left recursion can be eliminated simply by rewriting it on the right. <br><br>  An important point!  ANTLR has parser rules and grammar rules.  The rules of parsing lead to the appearance of a node in the resulting AST.  In addition, there is some difference that can / cannot be in the grammatical / parsing rules.  In particular, there are no regular expressions in the rules of parsing.  In addition, the parser should receive the input rule, the starting net terminal (in general, everything is somewhat more complicated, but in our case this is also enough).  In general, it is worth noting that ANTLR has a rather powerful syntax, also supports inline functions (albeit in a slightly different format) and non-tree non-terminals and something else.  As a result, our grammar looks like this: <br><br><pre> <code class="hljs matlab">grammar calc; stmt : term | term addop stmt ; term : <span class="hljs-built_in"><span class="hljs-built_in">factor</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">factor</span></span> mulop <span class="hljs-built_in"><span class="hljs-built_in">factor</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">factor</span></span> : <span class="hljs-string"><span class="hljs-string">'('</span></span> stmt <span class="hljs-string"><span class="hljs-string">')'</span></span> | NUMBER; addop : <span class="hljs-string"><span class="hljs-string">'+'</span></span> | <span class="hljs-string"><span class="hljs-string">'-'</span></span>; mulop : <span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-string"><span class="hljs-string">'/'</span></span>; NUMBER: [<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>]+|[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>]+.[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>]+; WS : [ \t\r\n]+ -&gt; skip ;</code> </pre> <br>  The file is called calc.g4 (This is important! The name of the file must match the name of the grammar inside). <br><br>  Let's create a java-parser. <br><br><pre> <code class="bash hljs">antlr4 calc.g4 javac calc*.java grun calc stmt -gui</code> </pre> <br>  Then we give him some input (for example, <code>1 + 2 / (3 - 1 + 5)</code> ) and press the end of the line ( <code>ctrl-d</code> on * nix, <code>ctrl-z</code> on windows) and look at the result.  We were shown a beautiful parse tree, also interactive.  You can see, twist the nodes, think, export as a picture. <br><br>  Create a python2 parser: <br><br><pre> <code class="bash hljs">antlr4 -Dlanguage=Python2 calc.g4</code> </pre> <br><br>  Further, we can hang listeners on the grammar and enjoy. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> antlr4 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> calc_bakLexer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> calc_bakLexer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> calc_bakListener <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> calc_bakListener <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> calc_bakParser <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> calc_bakParser <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StmtPrinter</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(calc_bakListener)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.map_results = {} self.result = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exitStmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, ctx)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Oh, a stmt! {}"</span></span>.format(ctx.getText())) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv)</span></span></span><span class="hljs-function">:</span></span> input = FileStream(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) print(input) lexer = calc_bakLexer(input) stream = CommonTokenStream(lexer) parser = calc_bakParser(stream) tree = parser.stmt() printer = StmtPrinter() walker = ParseTreeWalker() walker.walk(printer, tree) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main(sys.argv)</code> </pre> <br>  ... Enjoy the wrong program.  Or rather, right, but unexpectedly. <br><br><pre> <code class="bash hljs">python ./calc_antlr_min.py ./example.antlr 1 + 2 / (3 - 1 + 5) Oh, a stmt! 5 Oh, a stmt! 1+5 Oh, a stmt! 3-1+5 Oh, a stmt! 2/(3-1+5) Oh, a stmt! 1+2/(3-1+5)</code> </pre><br>  As you can see, the associativity here is ‚Äúright‚Äù.  And operations of addition, subtraction, multiplication-division are left.  I honestly tried a few days (sic!) To find a solution (of course, I did not do this all the time, but in total I killed 12-15 hours for this).  Associative markers, heaps of manuals, grammar reformulation ...  Did not work out.  I am sure there is a solution.  Moreover, an example of a grammar calculator <a href="https://github.com/jszheng/py3antlr4book/tree/master/10-calc">is here</a> .  But I wanted to find my solution, if possible, in terms of a general grammar.  In the end, the goal was to LEARN, not to solve the problem. <br><br>  And I admit my failure.  Yes, the problem is solved.  But using only documentation and searching for general topics, I could not solve it.  The reasons ... First, excluding the book on ANTLR, the sources available on the web are not very detailed and expressive.  Secondly, there are a lot of materials in the network for different (non-compatible) versions of ANTLR.  No, I understand everything, development and so on.  But for some reason, in the process of getting acquainted with the instrument, I got the feeling that the author did not even hear about the concept of backward compatibility.  In general, sad. <br><h4>  Update </h4><br>  As rightly noted, one head is good and two is better. <br>  The reformulation of the grammar with the right-associative on the left is done literally ‚Äúwith a click of the fingers‚Äù (Thanks to Valentin Nechayev <a href="https://habrahabr.ru/users/netch80/" class="user_link">netch80</a> for the addition) - you just need to replace <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stmt</span></span> : term | term addop stmt ;</code> </pre><br>  on <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stmt</span></span> : term | stmt addop term ;</code> </pre><br>  In this case, ANTLR handles left-side recursion without questions (apparently, due to some optimizations).  Output simple listeners in this case. <br><pre> <code class="bash hljs">python ./calc_antlr_min.py ./example.antlr 1 + 2 / (3 - 1 + 5) Oh, a stmt! 1 Oh, a stmt! 3 Oh, a stmt! 3-1 Oh, a stmt! 3-1+5 Oh, a stmt! 1+2/(3-1+5)</code> </pre> <br><br></li></ol><br><h2>  Peg </h2><br>  In essence, they are a simplified form of BNF, but it‚Äôs not generally necessary to know about it to the programmer.  Unlike BNF, they are originally more like regular expressions.  In fact, one could say that it is BNF with the ability to use regular expressions ‚Äúaccording to the standard‚Äù (and, which is nice, not only within the non-terminal line, but also to some extent in the expression itself (PEG supports constructions of the form <code>A = B ( XC)*</code> ,   <code>Z = R (K)?</code> ,   ‚ÄúA   B     X  C,  ‚Äù  ‚ÄúZ   R     K 0  1 ‚Äù). ,   ,     .   ,  PEG  ,   .     <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do parsers encounter, including BNF? The ambiguity of choice! To solve this problem, PEG has a nice </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequential or</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú/‚Äù </font><font style="vertical-align: inherit;">operator </font><font style="vertical-align: inherit;">. Unlike the operator ‚Äú|‚Äù, which describes equivalent alternatives, ‚Äú/‚Äù clearly indicates the order of resolution of the rule. For example, </font></font><code>A / B / C / D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicates: compare with A, if not suitable, compare with B, if not suitable, compare with C, etc. For this reason, operating PEG grammars is EASIER. And still, the recommendation - if you are indifferent to the order of the comparison, it is better to write ‚Äú/‚Äù This will reduce the number of ambiguous situations for the parser. However, as with any tool, this should be handled with care.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, be careful, the creators of PEG parsers are even more prone to wanting to understand the standard as they like, so the vocabulary of different implementations can vary significantly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, let's move on to practice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use </font></font><a href="https://github.com/igordejanovic/Arpeggio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arpeggio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by parglare:</font></font><br><br><pre> <code class="bash hljs">pip install arpeggio</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we look at the documentation and find out that the Visitor pattern recommended for working with AST for this library is very similar to the listener recommended in ANTLR. </font><font style="vertical-align: inherit;">Fortunately, here for the whole experiment I had an hour, everything turned out to be not difficult:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> arpeggio.cleanpeg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ParserPEG <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> arpeggio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PTNodeVisitor, EOF, visit_parse_tree <span class="hljs-comment"><span class="hljs-comment"># Setting up our simple grammar calc_grammar = """ number = r'\d+(\.\d+)?' factor = number / "(" stmt ")" term = factor (mulop factor)* stmt = term (addop term)* addop = "+" / "-" mulop = "*" / "/" calc = stmt EOF """ #Creating a visitor class to calculate the result class CalcVisitor(PTNodeVisitor): def visit_number(self, node, children): return float(node.value) def visit_factor(self, node, children): # Children are list-like structure of VISITED node results # visits are made from depth to top return children[0] def visit_term(self, node, children): # For such rules you may use, for example children["factor"] # Though, you need to know, that children["factor"] is a list of ALL # factor's of this term if len(children) == 1: return children[0] else: res = children[0] for i in xrange(len(children) / 2): if children[2 * i + 1] == '*': res *= children[2 * (i + 1)] else: res /= children[2 * (i + 1)] return res def visit_stmt(self, node, children): if len(children) == 1: return children[0] else: res = children[0] for i in xrange(len(children) / 2): if children[2 * i + 1] == '+': res += children[2 * (i + 1)] else: res -= children[2 * (i + 1)] return res # Don't forget about root rule for your parser, as it will be produced as # a parsing result parser = ParserPEG(calc_grammar, "calc") input_expr = "(4-1)*5+(2+4.67)+5.89/(1.2+7)" print(input_expr) parse_tree = parser.parse(input_expr) result = visit_parse_tree(parse_tree, CalcVisitor( #debug=True )) print(result) input_expr = "1 + 2 / (3 - 1 + 5)" print(input_expr) parse_tree = parser.parse(input_expr) result = visit_parse_tree(parse_tree, CalcVisitor( #debug=True )) print(result)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At startup, it will display the following: </font></font><br><pre> <code class="bash hljs">python ./calc_arpeggio.py (4-1)*5+(2+4.67)+5.89/(1.2+7) 22.3882926829 1 + 2 / (3 - 1 + 5) 1.28571428571</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to see how a visitor goes around a tree, you can uncomment the debug. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we can see, the grammar has undergone minor but important changes. </font><font style="vertical-align: inherit;">In particular, if we pay attention to the stmt and term rules, it will be clear that they have an arbitrary number of elements. </font><font style="vertical-align: inherit;">Accordingly, thanks to this, the processing of the associativity of mathematical operations is entirely on our conscience. </font><font style="vertical-align: inherit;">Despite these changes, the program remains simple and straightforward.</font></font><br><br><h2>  General conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, there are several conclusions: </font></font><br><br><ul><li>    ,   .     , ,  , .           ,         .     ‚Äî  . ,         . </li><li>    .    ,   ,          . </li><li>    . ,     ,      .   ,   - ,   -   (-  js, python, lua  ruby ‚Äî      ). ,  ‚Äú stand-alone   ‚Äù,      . </li><li>   () .   ‚Äú:‚Äù  ‚Äú=‚Äù  BNF,    .    .   ,          20.       - ,     ,   .        .   ,    ‚Ä¶ </li><li>   ,    ‚Äú‚Äù .        ,     . </li><li>         , ,       C (, Bison),    ‚Äú ‚Äù.  ,    ,      (      ,      ‚Äî ).  ,      ‚Äî           . ,   . </li></ul><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to say that this was an interesting study. </font><font style="vertical-align: inherit;">I tried to describe my conclusions as simply and clearly as possible, I hope I managed to write this article so that the topic could be understood even by programmers far from mathematics, at least in general terms, sufficient to use the existing tools. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can ask any questions, if any details on the topic will excite many, they can serve for writing other articles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As promised, several useful links on the subject of the article:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Wikipedia, in English (there are significantly fewer articles in Russian): </font></font><br> <a href="https://en.wikipedia.org/wiki/Context-free_grammar"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FG </font></font></a> <br> <a href="https://en.wikipedia.org/wiki/Backus%25E2%2580%2593Naur_form"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BNF </font></font></a> <br> <a href="https://en.wikipedia.org/wiki/LL_parser"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LL </font></font></a> <br> <a href="https://en.wikipedia.org/wiki/LR_parser"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LR </font></font></a> <br> <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEG</font></font></a> </li><li>  -    ,    ‚Äú  ‚Äù,    . xo, .  ‚Äú  ,   ‚Äù. , , <a href="https://github.com/afrolovskiy/compilers_labs/tree/master/literature"></a> .     ,   . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/348314/">https://habr.com/ru/post/348314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348304/index.html">How to easily start writing on PowerShell or simple automation to manage Active Directory</a></li>
<li><a href="../348306/index.html">Registration for NeoQUEST-2018 is open: steampunk expedition to Atlantis</a></li>
<li><a href="../348308/index.html">Digital events in Moscow from February 5 to 11</a></li>
<li><a href="../348310/index.html">‚ÄúVITAMIN ROSTA‚Äù: how LANIT attracts young people and how young professionals get into LANIT</a></li>
<li><a href="../348312/index.html">How to "learn to learn" - tips, advice and research</a></li>
<li><a href="../348320/index.html">As I prepared a visual novel</a></li>
<li><a href="../348324/index.html">In defense of swap [in Linux]: common misconceptions</a></li>
<li><a href="../348326/index.html">Big Migration: How we raised a private cloud at RISC</a></li>
<li><a href="../348328/index.html">Creating a bonus system in Unity</a></li>
<li><a href="../348330/index.html">AI @ MIPT: ‚ÄúNeuromorphic computations and brain mechanisms‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>