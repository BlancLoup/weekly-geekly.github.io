<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with USB devices in a C program on MacOS X</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings dear readers. 
 In this small article I would like to consider the issue of interaction with hardware (in this case with USB devices) in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with USB devices in a C program on MacOS X</h1><div class="post__text post__text-html js-mediator-article">  Greetings dear readers. <br>  In this small article I would like to consider the issue of interaction with hardware (in this case with USB devices) in the MacOS X operating system. <br>  It will be considered a very interesting and useful IOKit framework, a way to get notifications about adding / removing obordovaniya, as well as getting complete information about the devices.  Of course, this material does not pretend to any uniqueness, because  Everyone can deal with these issues on their own, having studied the Apple documentation, as well as having smoked various sources on opensource.apple.com <br>  My article is an attempt to fill the gap in the Russian-language material of this kind and to describe some of the rakes that novices may encounter. <br>  All who became interested - welcome under cat. <br><a name="habracut"></a><br><br>  <b>Iokit</b> <br>  There is a wonderful thing in the MacOS X core - the IOKit framework.  This is an object-oriented C ++ framework designed specifically to support the hardware driver infrastructure.  True C ++ there is somewhat curtailed, for example, there are no exceptions, RTTI, patterns.  The rest of the kernel is written primarily in C. <br>  IOKit itself can be divided into two parts: the actual kernel framework on which the drivers are written and the user-specific IOKit.framework, designed for easy access to the kernel modules (and equipment, respectively) from user applications. <br>  The object-oriented nature of IOKit allows you to conveniently display the real physical model of the equipment: a USB device is connected, a USB port is connected to the hub, a hub is connected to the appropriate controller in the computer, this controller, is connected via PCI bus to the rest of the motherboard chipset.  Each IOKit driver is either an end node (for example, a USB modem) or a connecting module (for example, a USB port controller) in this model, in Apple's terminology, the latter is called nub. <br>  The Xcode delivery package includes the IORegExplorer graphical utility that allows you to view the entire structure of IOKit modules, read various parameters and technical information. <br><img src="https://habrastorage.org/storage2/4c9/920/ff2/4c9920ff23349228608d08a853e064ca.jpg"><br>  There is also a console analog utility - ioreg. <br><br>  This article will cover the work only with the user-specific IOKit.framework.  If any readers are interested in the kernel framework, you can read the <a href="http://habrahabr.ru/post/36875/">habrahabr.ru/post/36875</a> article, as well as the wonderful book OS X and iOS Kernel Programming. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Receive USB Notifications</b> <br>  As mentioned above, we will work with USB, so we need only one header file <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;IOKit/usb/IOUSBLib.h&gt;</span></span></span></span></code> </pre> <br>  Let's start by subscribing to receive notifications about adding / removing USB devices.  A special object of type IONotificationPortRef will help us with this. <br>  Create and initialize an instance of IONotificationPortRef <br><pre> <code class="cpp hljs">IONotificationPortRef notificationPort = IONotificationPortCreate(kIOMasterPortDefault);</code> </pre><br>  We have created a kind of virtual port for listening to events from IOKit (it has not yet been determined which ones).  kIOMasterPortDefault is a constant that defines a certain ‚Äúdefault‚Äù port to receive messages from IOKit, always use this value. <br><br>  Now we will determine which messages we want to receive.  To do this, you need to create a so-called dictionary, using the corresponding container of the base framework MacOS X. <br><pre> <code class="cpp hljs">CFMutableDictionaryRef matchDict = (CFMutableDictionaryRef) CFRetain(IOServiceMatching(kIOUSBDeviceClassName));</code> </pre><br>  The key method here is IOServiceMatching, which creates a dictionary of USB class devices, I think that this is obvious (there are other constants, for example, for FireWire, etc., that allow you to receive corresponding notifications).  Next, we ‚Äútake‚Äù ownership of this object using CFRetain.  This is to ensure that there are no problems with the possible double release of an object in the methods of the IOKit framework.  Actually, we ourselves do not need to free this object, in other cases, never forget to call CFRelease for objects allocated in a heap (not received by any Get * method).  In addition, always check, freshly created / freshly obtained * Ref objects of the basic framework, for NULL, since  these are, in fact, ordinary pointers and you need to work with them accordingly. <br><br>  Then we ‚Äúhang‚Äù this dictionary on the previously created port, as matching notification.  This is done using the IOServiceAddMatchingNotification method. <br>  Consider it carefully <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">kern_return_t</span></span> IOServiceAddMatchingNotification( IONotificationPortRef notifyPort, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">io_name_t</span></span> notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *refCon, <span class="hljs-keyword"><span class="hljs-keyword">io_iterator_t</span></span> *notification );</code> </pre><br><br>  The first parameter <b>notifyPort</b> is the port we created earlier. <br>  The second parameter of the <b>notificationType</b> is the type of notifications for this dictionary, such as <b>kIOTerminatedNotification</b> , <b>kIOMatchedNotification</b> , <b>kIOFirstMatchNotification</b> .  I think that from the names of these constants it is quite clear what they mean. <br>  The third parameter <b>matching</b> is the dictionary itself.  The object type, as you can see, is CFDictionaryRef.  This is not a problem, because  CFMutableDictionaryRef is no problem cast to type CFDictionaryRef. <br>  The fourth <b>callback</b> method is the most interesting.  This is a pointer to a callback method called when the corresponding event arrives.  About him a little lower. <br>  The fifth parameter <b>refCon</b> is the context of the callback method, here you can transfer your data to this function. <br>  The last parameter of the <b>notification</b> is an iterator intended to iterate over the collection of devices, this argument is initialized in <b>IOServiceAddMatchingNotification</b> and also is passed to the callback method, indicating the very first device in the collection. <br><br>  If successful, IOServiceAddMatchingNotification returns zero, otherwise a positive number, an error code. <br><br>  The callback function is defined as follows: <br> <code>typedef void (*IOServiceMatchingCallback)(void *refcon, io_iterator_t iterator);</code> <br>  As you can see, the function takes the very last two arguments from IOServiceAddMatchingNotification. <br><br>  We need to declare two such functions - add and delete devices. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_device_added</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* refcon, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_iterator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_device_removed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* refcon, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_iterator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><br>  And now, finally, we set up notifications. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">kern_return_t</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">io_iterator_t</span></span> deviceAddedIter; <span class="hljs-keyword"><span class="hljs-keyword">io_iterator_t</span></span> deviceRemovedIter; result = IOServiceAddMatchingNotification(notificationPort, kIOMatchedNotification, matchDict, usb_device_added, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;deviceAddedIter); ... result = IOServiceAddMatchingNotification(notificationPort, kIOTerminatedNotification, matchDict, usb_device_removed, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;deviceRemovedIter);</code> </pre><br><br>  No additional initialization of the methods is required and be sure to check the result code after each call to IOServiceAddMatchingNotification. <br><br>  Now we need to set up a stream with a cycle in which our listener will spin.  In MacOS X for these purposes, the corresponding object is provided - CFRunLoop.  For normal operation, this object must indicate the so-called source and run in the context of the current or some other stream, and after the end of the work, stop. <br>  Let's do it like this: <br><pre> <code class="cpp hljs">CFRunLoopAddSource(CFRunLoopGetCurrent(), IONotificationPortGetRunLoopSource(notificationPort), kCFRunLoopDefaultMode);</code> </pre><br>  In this case, we add the source of the notifications using the special IONotificationPortGetRunLoopSource method, using our notification port, and we also specify the identifier of the required stream ‚Äî in this case, the current CFRunLoopGetCurrent () <br><br>  Then this thread can start and start receiving notifications.  But there is one caveat that it would all work - callback methods must be called manually once, as if ‚Äúrubbing‚Äù the collection.  If you do not do this - notifications will not come. <br><br>  Starter stream is executed by the CFRunLoopRun () method;  Everything, at this point, the execution of the code will not go further.  This cycle can only be stopped using CFRunLoopStop, the argument, this method, is passed the identifier of the thread where CFRunLoopRun was run, the actual value that returned above CFRunLoopGetCurrent.  In a multithreaded environment, I recommend saving this value so that you can stop RunLoop from the context of another thread, simply by specifying the correct, saved identifier. <br><br>  After stopping the flow, you need to tidy up a little behind you <br><pre> <code class="cpp hljs">CFRunLoopRemoveSource(CFRunLoopGetCurrent(), IONotificationPortGetRunLoopSource(notificationPort), kCFRunLoopDefaultMode); IONotificationPortDestroy(notificationPort);</code> </pre><br><br>  <b>Getting information about USB devices</b> <br>  So, we learned how to receive notifications about adding / removing USB devices, now let's see how you can get all the information about devices directly in callback methods. <br>  On good, both methods should be reduced to calling one method iterate_usb_devices <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterate_usb_devices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">io_iterator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">io_service_t</span></span> usbDevice; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((usbDevice = IOIteratorNext(iterator))) { .... IOObjectRelease(usbDevice); } }</code> </pre><br><br>  Here we make a walk through the device collection, using the passed iterator and IOIteratorNext, after using the object must be freed in IOObjectRelease. <br>  Each received usbDevice object is the source of all the necessary information.  The simplest example is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">io_name_t</span></span> devicename; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IORegistryEntryGetName(usbDevice, devicename) != KERN_SUCCESS) == KERN_SUCCESS) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Device name: %s\n"</span></span>, devicename); }</code> </pre><br><br>  If successful, a readable device name will be displayed, for example, ‚ÄúNovatel wireless modem‚Äù.  io_name_t is essentially an ordinary char array. <br><br>  Another example is getting the full path to a device in the IOKit hierarchy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">io_name_t</span></span> entrypath; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IORegistryEntryGetPath(usbDevice, kIOServicePlane, entrypath) == KERN_SUCCESS) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\tDevice entry path: %s\n"</span></span>, entrypath); }</code> </pre><br><br>  These are the simplest cases, because  A whole dictionary of various parameters in the form of a key-value pair is associated with the usbDevice object.  By the corresponding keys, you can get the corresponding parameter values, for example, we will get the VendorID of the device. <br><br><pre> <code class="cpp hljs">CFNumberRef vendorId = (CFNumberRef) IORegistryEntrySearchCFProperty(usbDevice , kIOServicePlane , CFSTR(<span class="hljs-string"><span class="hljs-string">"idVendor"</span></span>) , <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> , kIORegistryIterateRecursively | kIORegistryIterateParents);</code> </pre><br><br>  This method searches for the corresponding parameter using a string key, in this case <b>‚ÄúidVendor‚Äù</b> (CFSTR is a MacOS X framework method that performs a quick conversion of a C string to an internal object of type CFStringRef) <br><br>  IORegistryEntrySearchCFProperty returns NULL if the search was unsuccessful, or a pointer to the object of the desired type, in this case CFNumberRef.  To "catch" the normal numeric value from CFNumberRef, you need to use the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CFNumberGetValue(vendorId, kCFNumberSInt32Type, &amp;result)) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"VendorID: %i\n"</span></span>, result); }</code> </pre><br><br>  Getting the <b>‚ÄúProductID‚Äù</b> is performed in exactly the same way, only the key ‚ÄúidProduct‚Äù should be used as the key <br><br>  Of course, the list of parameters and the corresponding keys can vary greatly from device to device.  The reader may have a corresponding question - how to find out what parameters and by what keys you need to look for this device and how to display all the values ‚Äã‚Äãat once? <br>  This is done quite simply: <br><br><pre> <code class="cpp hljs">CFMutableDictionaryRef properties; IORegistryEntryCreateCFProperties(usbDevice, &amp;properties, kCFAllocatorDefault, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  In case of successful implementation of this method, we will have at our disposal a dictionary filled with all the keys / values ‚Äã‚Äãof the device. <br>  The easiest way, now, to print this dictionary to the screen is the CFShow framework.  A few words about it, CFShow is a universal method for crafting any CoreFoundation Framework objects in MacOS X - CFMutableDictionaryRef, CFStringRef, CFNumberRef, etc.  Output is done in stderr. <br>  So, we display the contents of the dictionary on the screen: <br><br><pre> <code class="cpp hljs">CFShow(properties);</code> </pre><br><br>  Now we have a list of all keys and all parameters for this device and we can use this knowledge to get specific values ‚Äã‚Äãin the form of specific objects (either through IORegistryEntrySearchCFProperty, or directly from the dictionary, using the methods for working with dictionaries) <br><br>  <b>Work application.</b> <br>  Now I would like to give an example of a small application containing everything described above.  Among other things, I decided to add signal processing to this example in order to be able to correctly terminate the application using trl-. <br>  <i>Note:</i> In real projects, never perform such actions in a signal handler, why, you can read, for example, <a href="https://groups.google.com/group/fido7.ru.unix.prog/msg/f319ff7580e47ab1%3Fhl%3Dru%26pli%3D1">in this message</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;IOKit/usb/IOUSBLib.h&gt; #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; static IONotificationPortRef notificationPort; void usb_device_added(void* refcon, io_iterator_t iterator); void usb_device_removed(void* refcon, io_iterator_t iterator); void init_notifier() { notificationPort = IONotificationPortCreate(kIOMasterPortDefault); CFRunLoopAddSource(CFRunLoopGetCurrent(), IONotificationPortGetRunLoopSource(notificationPort), kCFRunLoopDefaultMode); printf("init_notifier ---&gt; Ok\n"); } void configure_and_start_notifier() { printf("Starting notifier...\n\n"); CFMutableDictionaryRef matchDict = (CFMutableDictionaryRef) CFRetain(IOServiceMatching(kIOUSBDeviceClassName)); if (!matchDict) { fprintf(stderr, "Failed to create matching dictionary for kIOUSBDeviceClassName\n"); return; } kern_return_t addResult; io_iterator_t deviceAddedIter; addResult = IOServiceAddMatchingNotification(notificationPort, kIOMatchedNotification, matchDict, usb_device_added, NULL, &amp;deviceAddedIter); if (addResult != KERN_SUCCESS) { fprintf(stderr, "IOServiceAddMatchingNotification failed for kIOMatchedNotification\n"); return; } usb_device_added(NULL, deviceAddedIter); io_iterator_t deviceRemovedIter; addResult = IOServiceAddMatchingNotification(notificationPort, kIOTerminatedNotification, matchDict, usb_device_removed, NULL, &amp;deviceRemovedIter); if (addResult != KERN_SUCCESS) { fprintf(stderr, "IOServiceAddMatchingNotification failed for kIOTerminatedNotification\n"); return; } usb_device_removed(NULL, deviceRemovedIter); CFRunLoopRun(); } void deinit_notifier() { CFRunLoopRemoveSource(CFRunLoopGetCurrent(), IONotificationPortGetRunLoopSource(notificationPort), kCFRunLoopDefaultMode); IONotificationPortDestroy(notificationPort); printf("deinit_notifier ---&gt; Ok\n"); } void signal_handler(int signum) { printf("\ngot signal, signnum=%i stopping current RunLoop\n", signum); CFRunLoopStop(CFRunLoopGetCurrent()); } void init_signal_handler() { signal(SIGINT, signal_handler); signal(SIGQUIT, signal_handler); signal(SIGTERM, signal_handler); } int main() { init_signal_handler(); init_notifier(); configure_and_start_notifier(); deinit_notifier(); return 0; } void print_cfstringref(const char* prefix, CFStringRef cfVal) { char* cVal = malloc(CFStringGetLength(cfVal) * sizeof(char)); if (!cVal) { return; } if (CFStringGetCString(cfVal, cVal, CFStringGetLength(cfVal) + 1, kCFStringEncodingASCII)) { printf("%s %s\n", prefix, cVal); } free(cVal); } void print_cfnumberref(const char* prefix, CFNumberRef cfVal) { int result; if (CFNumberGetValue(cfVal, kCFNumberSInt32Type, &amp;result)) { printf("%s %i\n", prefix, result); } } void get_usb_device_info(io_service_t device, int newdev) { io_name_t devicename; io_name_t entrypath; io_name_t classname; if (IORegistryEntryGetName(device, devicename) != KERN_SUCCESS) { fprintf(stderr, "%s unknown device (unable to get device name)\n", newdev ? "Added " : " Removed"); return; } printf("USB device %s: %s\n", newdev ? "FOUND" : "REMOVED", devicename); if (IORegistryEntryGetPath(device, kIOServicePlane, entrypath) == KERN_SUCCESS) { printf("\tDevice entry path: %s\n", entrypath); } if (IOObjectGetClass(device, classname) == KERN_SUCCESS) { printf("\tDevice class name: %s\n", classname); } CFStringRef vendorname = (CFStringRef) IORegistryEntrySearchCFProperty(device , kIOServicePlane , CFSTR("USB Vendor Name") , NULL , kIORegistryIterateRecursively | kIORegistryIterateParents); if (vendorname) { print_cfstringref("\tDevice vendor name:", vendorname); } CFNumberRef vendorId = (CFNumberRef) IORegistryEntrySearchCFProperty(device , kIOServicePlane , CFSTR("idVendor") , NULL , kIORegistryIterateRecursively | kIORegistryIterateParents); if (vendorId) { print_cfnumberref("\tVendor id:", vendorId); } CFNumberRef productId = (CFNumberRef) IORegistryEntrySearchCFProperty(device , kIOServicePlane , CFSTR("idProduct") , NULL , kIORegistryIterateRecursively | kIORegistryIterateParents); if (productId) { print_cfnumberref("\tProduct id:", productId); } printf("\n"); } void iterate_usb_devices(io_iterator_t iterator, int newdev) { io_service_t usbDevice; while ((usbDevice = IOIteratorNext(iterator))) { get_usb_device_info(usbDevice, newdev); IOObjectRelease(usbDevice); } } void usb_device_added(void* refcon, io_iterator_t iterator) { iterate_usb_devices(iterator, 1); } void usb_device_removed(void* refcon, io_iterator_t iterator) { iterate_usb_devices(iterator, 0); }</span></span></span></span></code> </pre><br><br>  Compiling an application is done by the command <br> <code>gcc usbnotify.c -framework IOKit -framework Foundation -o notifier</code> <br>  or <br> <code>clang usbnotify.c -framework IOKit -framework Foundation -o notifier</code> <br>  The result of executing both commands will be identical. <br><br>  Below you can see screenshots of the running application with information about the connected and disconnected devices. <br><br><img src="https://habrastorage.org/storage2/7f4/59c/069/7f459c069c526a37fb6a822920454ce1.png"><br><br><img src="https://habrastorage.org/storage2/79f/b66/88d/79fb6688d51546ac8f2b8d3f1cf11eb4.png"><br><br><img src="https://habrastorage.org/storage2/1b6/8db/50e/1b68db50e7c7c08b8ec0224b4b8097f2.png"><br><br><img src="https://habrastorage.org/storage2/623/224/937/62322493731b4aaccac3c59aff858cc8.png"><br><br><img src="https://habrastorage.org/storage2/154/8a6/0f6/1548a60f62f0f8800662c4aa52474ec5.png"><br><br>  Bibliography: <br>  <a href="http://goo.gl/LRyIr">goo.gl/LRyIr</a> <br>  <a href="http://goo.gl/O1Oyk">goo.gl/O1Oyk</a> <br>  <a href="http://goo.gl/NQUtL">goo.gl/NQUtL</a> <br>  <a href="http://goo.gl/daEiS">goo.gl/daEiS</a> <br>  <a href="http://goo.gl/7jkUs">goo.gl/7jkUs</a> <br>  <a href="http://goo.gl/yeJre">goo.gl/yeJre</a> <br>  <a href="http://www.amazon.com/OS-X-iOS-Kernel-Programming/dp/1430235365">www.amazon.com/OS-X-iOS-Kernel-Programming/dp/1430235365</a> <br>  <a href="http://habrahabr.ru/post/36875/">habrahabr.ru/post/36875</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/145855/">https://habr.com/ru/post/145855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145849/index.html">A couple of devices for DSLRs</a></li>
<li><a href="../145850/index.html">Code design</a></li>
<li><a href="../145852/index.html">HTC is going to expand the patent base to strengthen its position</a></li>
<li><a href="../145853/index.html">The Japanese have developed virtual avatars</a></li>
<li><a href="../145854/index.html">Canonical announces a developer contest with valuable prizes.</a></li>
<li><a href="../145856/index.html">Plim - the most complete port of Slim template engine on Python</a></li>
<li><a href="../145857/index.html">June 30, 2012 will be a second longer: 23:59:60</a></li>
<li><a href="../145858/index.html">You can go to jail for 15 years using Google Talk or Skype.</a></li>
<li><a href="../145859/index.html">HA (High Available) VMware vSphere cluster on HP BL460c and EVA blades</a></li>
<li><a href="../145860/index.html">Cream IT R & D (release 12) - 2016 is the year of change</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>