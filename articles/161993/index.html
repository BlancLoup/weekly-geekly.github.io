<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programmable microcontroller STM32 - right off the bat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Below is described my first experience with a programmable microcontroller in the face of STM32VLDiscovery , the result of which was a machine from LE...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programmable microcontroller STM32 - right off the bat</h1><div class="post__text post__text-html js-mediator-article">  Below is described my first experience with a programmable microcontroller in the face of <a href="http://www.st.com/internet/evalboard/product/250863.jsp">STM32VLDiscovery</a> , the result of which was a machine from LEGO, controlled from the phone, and one more thing.  I tried to state my way in the form of a step-by-step guide to action, but I warn you right away, not the ‚Äúhow to do it right‚Äù manual.  The first two sections are a preface and do not relate directly to this microcontroller. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/0e3/26a/b55/0e326ab55a539a325b0e78177017d6fc.jpg" alt="image"><br><br><h4>  Content: </h4><br><ol><li>  The first contact with microelectronics. </li><li>  Construction of cars on non-programmable logic elements. </li><li>  Getting started with STM32.  Development environment.  Connect the microcontroller to the typewriter. </li><li>  Determine the angle of rotation of the front wheels - feedback through the ADC. </li><li>  Use a DAC to play sounds. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  1. First contact with microelectronics </h4><br>  No matter why, but the thought arose: to make a device that receives commands from the phone.  How to do it?  It can be via Bluetooth, WiFi, USB, etc.  But it seemed simpler and more versatile to me the recognition of sounds that can be taken from the output of a mobile phone headset (hereinafter, the simplest to implement, result-oriented methods will be chosen to solve problems). <br>  Sounds can be synthesized by a special program for a smartphone, but there is an interesting option - <a href="http://ru.wikipedia.org/wiki/DTMF">DTMF</a> signals.  They are standard and are used in any mobile and in most fixed phones (when dialing a number or in the voice menu), they are transmitted without problems in the voice channel. <br><br><h6>  Task 1: Recognize DTMF Signals </h6><br>  Three options for implementing DTMF decryption are printed from the Internet (my idea is not new), with them to a well-known store.  It is bought: <br><ul><li>  MT 8870DE Decoder - from the input analog signal receives a binary code (4 bits) of the last recognized DTMF command and 1 bit - the presence / absence of the DTMF command this very second (let's call it ‚Äúfifth output‚Äù). </li><li>  Quartz resonator, capacitors and resistors necessary for the operation of the decoder. </li><li>  7-segment indicator - to display the number pressed on the phone. </li><li>  KP 514ID-1 decoder for a 7-segment indicator - from the binary code receives 7 outputs for each of the segments. </li><li>  Breadboard for installation without soldering. </li><li>  Wiring / jumper for the breadboard. </li></ul><br><br>  We collect, check, correct errors ... it works.  Shock. <br><br>  Now all this needs to be made to control the machine.  Moreover, the actions of the machine correspond logically to the pressed figure: 2 - forward, 4 - to the left, 6 - to the right, 8 - back. <br><br><h6>  Task 2: 4 certain combinations of signals from a DTMF decoder must activate one of the 4 functions </h6><br>  The simplest option is the decimal descrambler.  The K155ID10 with an open collector was bought - 4 inputs for a binary code, 10 outputs symbolize numbers from 0 to 9, on the required output there will be ‚Äú0‚Äù, on the others - ‚Äú1‚Äù.  This decoder is used with loads whose operating current can reach 80 mA (incandescent bulbs, relays), which is convenient.  Although transistors still had to be used. <br><br><h6>  Task 3: Change polarity for motors, N-bridge </h6><br>  All my childhood, I collected cars from LEGO, which went back and forth by manually switching the polarity of the batteries (I never had LEGO kits with motors and remotes).  Now it's time to play toys in an adult way. <br>  Normal people do <a href="http://ru.wikipedia.org/wiki/H_%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582">H-bridge</a> transistors.  Advanced - buy a turnkey solution on these transistors.  I did on switching electromagnetic relays.  Later I bought powerful (for a collector current up to 3A) NPN and PNP transistors TIP31 C ST and TIP32 C ST, I assembled the same H-bridge from them, but for some reason it worked only with counter-lit LEDs, and the motor was not turning power  I do not know why. <br><br>  Switching relays require two for each motor (transistors or closing relays require 4).  By default, both contacts of a motor (a common collector, as in toys) are connected to a minus.  If one of the relays gives a control signal, the contact of the motor will switch to plus, the motor will work.  The great advantage of such a connection is that under no circumstances can even a short-term short circuit be caused by the relay.  The disadvantage is that when the control voltage is removed from the relay, the motor is short-circuited and becomes a brake.  The solution is another closing relay.  Now, to rotate the motor, it is also necessary to close it, too, for free running - to open it, for ‚Äúbraking‚Äù - to close it again.  This relay will be added later. <br><br><h6>  Task 4: Assemble the machine </h6><br>  There are two motors in a typewriter: one through the LEGO differential drives the rear wheels, the other turns the front wheels.  The plastic gears in the gearboxes do not add efficiency to the system, but it all works. <br><br>  We put on the board 4 relays.  I was told that the breadboard was not designed for large currents (each motor consumes 1-1.6 A), but if I don‚Äôt get the result in a short time, the project risks remaining just another air lock.  By the way, turning on any relay caused voltage surges, which led to looping and malfunctioning.  Surely this is solved by special schemes, but I just powered the motors from a separate unit with batteries. <br><br>  Electromagnetic relays, two power sources - is it a bit hardcore?  Further more! <br><br>  It remains to connect all this to a decimal decoder.  The necessary outputs to the emitters of 4 NPN-transistors BC547, to the base of which the signal from the DTMF-decoder that the key is currently pressed (‚Äúfifth pin‚Äù), collectors - to each of the relays.  Crooked, strange, but it works. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e58/3fb/85f/e583fb85f8562dc0132828bf41ecf55a.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/bbe/b55/3c0/bbeb553c0f0678a82611945d6a66677f.jpg" alt="image"><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ltE-U0UD-is%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhhXbO3eRafyEbZGIZOeqDxHfkoQIQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  2. Construction of cars on non-programmable logic elements </h4><br>  Suppose the machine should be able to go and turn at the same time.  It is logical for this to use the numbers 1, 3, 7, 9, when clicked, which will trigger two relays.  Initially, I planned to implement this by connecting diodes from the emitters of transistors to a decimal decoder, but this all did not work.  Now it comes to me that if the decimal decoder produces ‚Äú0‚Äù, then a PNP transistor is needed, which will open with this ‚Äúzero‚Äù.  But I only had NPN. <br><br><h6>  Task 5: The machine should go and turn when you press 1, 3, 7 or 9 </h6><br>  For the purposes of entertainment / mastering / use, logical elements 4-AND, 4-OR, NOT, AND-NOT, OR-NOT, AND one-by-one are purchased.  The very first thought was to use the pins from the decimal decoder and the ‚Äúfifth pin‚Äù from the DTMF decoder in a simple logic circuit, which ultimately will open the necessary transistors (and through them the relay).  But!  The decimal decoder K155ID10 as a ‚Äúunit‚Äù gives 2 with something Volta.  None of the available logic elements has considered such a signal as a ‚Äúunit‚Äù.  In addition to 4-I (KR1533).  If using ‚Äúbare‚Äù 4 bits of binary code with DTMF, then it was not possible to assemble the required logic from the available elements.  A normal decimal decoder would make the task many times easier.  And it turned out such a small mockery - to make it hard, but you can do the same!  (The idea to go to bed and go for details in the morning was rejected). <br><br>  Bearing in mind that the decimal descrambler gives out its ‚Äúunder-unit‚Äù to all conclusions, except for the output with the decrypted number, we do the following. <br>  At first ... m ... quartet of the elements of element 4-I serve the numbers 1, 2, 3 and "one";  on the second - 7, 8, 9 and ‚Äúone‚Äù.  From the output of the first one we get ‚Äúzero‚Äù, if it was pressed 1, 2 or 3 (the machine goes forward), from the output of the second one - if 7, 8, 9 (back).  Otherwise, both outputs of the 4-I element are ‚Äúunits‚Äù. <br>  Now turns.  We use the 5 remaining logical elements and collect a cunning scheme.  It was decided to give up numbers 4 and 6 (why turn the wheels on the spot ?!), but even drawing up a scheme for turns with only 1 and 7 (to the left), 3 and 9 (to the right) made us pretty tense. <br><br>  As a result, on the board (I had to buy one more, more) DTMF-decoder, an indicator, a decoder for it, a decimal decoder, 4-AND, NOT, 4-OR, OR-NOT, AND-NO, 4 transistors, 4 relays. <br>  The machine performs 6 different commands, but does not know how to return the front wheels to the middle.  The efficiency of LEGO parts and the low power of the motor do not allow making a return spring or a rubber band. <br>  Relays sometimes clink several times, the reasons are not clear (interference?). <br>  The logic of working with logic mastered. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9a6/92f/a87/9a692fa87e84e2508cf53d62a4f744f6.jpg" alt="image"><br><br><h4>  3. Getting Started with STM32 </h4><br>  Development environment <br>  It is time to move from programming to code to programming.  About programmable microcontrollers / chips, I had only vague ideas that the Raspberry Pi is too powerful, the Arduino is expensive and not comme il faut.  It was then that the seller Michael and wrote me STM32VLDiscovery for 579 rubles.  About him <a href="http://habrahabr.ru/post/123791/">here</a> and <a href="http://cxem.net/mc/mc131.php">not only here</a> have already written, which greatly helped me in his study. <br><br>  The controller can be plugged into the breadboard, but not into any.  At the same time, 6 legs will remain hanging - you can do without them, the benefit remains a few dozen.  You can check the functionality of the program flooded into memory without even disconnecting the board from the mini-USB cable through which the program entered the device.  And you can eat from him. <br><br>  The best choice to get started was the <a href="http://www.coocox.org/CooCox_CoIDE.htm">CoIDE</a> environment from CooCox, which required just one dance with tambourines ‚Äî manually downloading certain files to a specific folder.  True, I didn‚Äôt manage to upload firmware from it to the device - I have to use ST-LINK Utility from the board manufacturer.  <a href="http://we.easyelectronics.ru/STM32/sublime-text-2-kak-ide-dlya-stm32.html">They say</a> that you can compile directly from convenient Sublime Text 2, but the length of the instruction has put too much skepticism into me to try. <br><br>  Considering that I never wrote to C, even the simplest flashes of LEDs caused me considerable difficulties.  In addition, incomprehensible registers, a hexadecimal system, different modes of operation of the outputs and inputs for a person who does not understand the purpose of the pull-up resistor ... But the copy-paste method of someone's ready-made examples did his job.  In turn, the price of the device allows you not to bother too much with the correct connection of the hardware.  For example, I did not understand whether it is necessary to connect each GND leg to the ground and whether it is harmful to power the device from 4-finger batteries - as long as everything is alive and working. <br><br>  Closer to the code.  I will not give and describe other examples here, but I offer you some of my best practices.  They appeared at a time when there was no acceptable solution to a particular problem on the Web. <br><br><h6>  Task 6: Delay </h6><br>  For example, we want to turn on the LED, and after a while to turn it off.  Often, the delay is implemented by an empty loop that runs many times.  The method is certainly simple, but it is applicable only where nothing except the flashing of the LED from the board is required.  We can interrupt the cycle only, excuse me, by interrupting (about them a bit later) or set additional conditions for exiting the cycle.  Otherwise, the board does nothing and does not react to anything while this cycle lasts. <br><br>  What I propose is: we use our main infinite loop for all the delays in the program at once, increasing each pass by the value of a certain variable (let's call it ‚Äúx‚Äù).  As soon as a variable reaches certain values, certain conditions are triggered in the body of the loop (there may be as many of them).  The disadvantage is that we do not know in advance how long such a delay will last.  If it does not matter, we select empirically necessary values ‚Äã‚Äãand use them. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> something; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x&gt;<span class="hljs-number"><span class="hljs-number">5000</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }; if (x==10000) { //  .    ,    x. }; if (something==1)//   { x=0; //        } if (x&lt;15000) { x++; }; //  x       0,   x  15000. }; };</span></span></code> </pre> <br></div></div><br><br><h6>  Task 7: Interrupts at a specified interval </h6><br>  Suppose we did not change the crystal resonator, and the processor frequency remained 24 MHz.  By creating an interrupt when the processor reaches the 2400th countdown through special instructions, we will get the execution of the function TIM6_DAC_IRQHandler (this is an interrupt handler) with a frequency of 100 Hz - every 10 milliseconds.  The code below was originally taken somewhere. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ti=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     6 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE); TIM6-&gt;PSC = 24000 - 1; //   1000    TIM6-&gt;ARR = 10 - 1; //     10-  TIM6-&gt;DIER |= TIM_DIER_UIE; //     TIM6-&gt;CR1 |= TIM_CR1_CEN; //  ! NVIC_EnableIRQ(TIM6_DAC_IRQn); //  TIM6_DAC_IRQn  }; //   TIM6_DAC void TIM6_DAC_IRQHandler(void) { ti++; TIM6-&gt;SR &amp;= ~TIM_SR_UIF; //     }</span></span></code> </pre><br></div></div><br><br>  The main purpose of this interrupt is to use the variable ti, which increases exactly every 10 milliseconds.  Soon I found out that interrupts are not just ‚Äúwedged‚Äù into the main program code, but can also distort the comparison operation or assignment to the variable ti, since it changes in the interrupt handler every time.  A situation may arise when instead of assigning another variable the value of the variable ti, a part of the old value and a part of the new value will be assigned.  Among the solutions to the problem found on the Web, I singled out about the following: <br><ul><li>  the use of atomic operations (they are not interrupted) - the assignment of the int type is not such, and it is necessary to use the ‚Äúlong‚Äù type; </li><li>  <a href="http://we.easyelectronics.ru/STM32/atomarnye-operacii-v-cortex-m3.html">using</a> additional variables or registers to find out if the interruption worked during the execution of specific instructions was a bit cumbersome and not very clear (for me); </li><li>  other options... </li></ul><br><br>  I solved this problem like this.  We assign a variable ti to a local variable sti until it is "assigned".  You can add a little ‚Äúbacklash‚Äù if accuracy is not fundamental. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { sti=ti; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ti&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>+sti);</code> </pre><br><br>  By itself, the local variable sti is used only to not insert such cycles wherever we need the value of the variable ti. <br><br>  Further in the program, you can fearlessly access the sti variable and even reset it.  I used all this to fix the time during which this or that team was given a typewriter so that the machine could then repeat the route.  Naturally, zeroing should not be in vain, so at the end of the main program loop, some simple code was added: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sti==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ti=<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ti&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>  If at the moment of assignment or at the moment of checking the exit condition the variable ti changes and is ‚Äúpresented‚Äù in an incorrect form, the cycle will repeat.  The higher the interrupt frequency, the more often the exit condition from the cycle will work the second time.  Naturally, if the interrupt frequency is too high, looping will not keep you waiting.  To control the number of failed assignment attempts, I used LEDs. <br><br><h6>  Task 8: LEDs as a display </h6><br>  Sometimes, to adjust the program, you want to get the values ‚Äã‚Äãof certain variables during the operation of the device, but there is no display or indicator at hand or you do not want to connect them.  Then you can simply make the LEDs blink the required number of times, pause, blink again, etc. For these purposes, I use the following code in the body of the main loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// - if ((todisp&gt;0) &amp;&amp; (sti%10==0)) { if ((sti%(todisp*20+100)&lt;todisp*20) &amp;&amp; (sti%20&lt;10)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS8; } else { GPIOC-&gt;BRR=GPIO_BRR_BR8; }; };</span></span></code> </pre><br><br>  At any place in the program, we assign the variable todisp, for example, 3, and the LED No. 8 on the board will flash three times, making a second pause between series.  The sti variable is incremented every 10 milliseconds (via the variable ti), instead you can use the variable x, incremented with each pass of the main loop.  In this case, the coefficients will need to be slightly increased. <br><br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { sti=ti; todisp++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ti&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>+sti); todisp--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((todisp&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (sti%<span class="hljs-number"><span class="hljs-number">10</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((sti%(todisp*<span class="hljs-number"><span class="hljs-number">20</span></span>+<span class="hljs-number"><span class="hljs-number">100</span></span>)&lt;todisp*<span class="hljs-number"><span class="hljs-number">20</span></span>) &amp;&amp; (sti%<span class="hljs-number"><span class="hljs-number">20</span></span>&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS8; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GPIOC-&gt;BRR=GPIO_BRR_BR8; }; }; }</code> </pre><br></div></div><br><br>  In this example, each time, because of an interruption, the assignment operation sti = ti was incorrect and, therefore, the comparison operation ti&gt; 1 + sti returns true (which can also occur if the interruption happened at the time of comparison), the LED will flash for one times more.  In principle, you can even measure how many times the LED flashes after n minutes of the board‚Äôs operation and calculate the average cycle time (based on the interrupt frequency), and also make sure that all these precautions when using interrupts are not superfluous. <br><br><h6>  Task 9: Connect the microcontroller to the typewriter </h6><br>  After conducting a sufficient number of experiments on LEDs, you can gradually change them to the wheels.  We take from the old circuit on the basic logic only the most necessary: ‚Äã‚ÄãDTMF-decoder, an indicator with a decoder for beauty, a relay with transistors.  You can finally forget about the decimal decoder! <br><br>  The outputs from the DTMF decoder are connected to the inputs on the controller that we have chosen for this purpose.  The outputs from the controller (again, selected and initialized in the program) via a resistor (for example, 3 kŒ©) to the base of a normal NPN transistor (I used the BC547).  Emitters - to "plus", collectors - to the coil of the corresponding relay.  Add the fifth relay, which prevents shorting (‚Äúbrake‚Äù mode) of the main motor, turn signals / dimensions to taste.  "Plus" for motors is supplied to the relay from a separate battery pack.  To power both the circuit and the motors, I use plastic cases (2 pieces) for 4 finger-type batteries / accumulators each.  They cost only 40 rubles, and I always suffered in childhood with scotch and foil ... <br><br>  It turned out that the wires from the DTMF decoder pass exactly above the relay, which are responsible for moving forward / backward.  Perhaps this adds interference to the existing power surges when the relay is turned on.  As a result, during the presentation before the fellow students the relays began to periodically pop, and the machine refused to go back at all - the relay switched non-stop, issuing a uniform crash.  Diodes connected in parallel to the coils of the relay in the direction of "plus", did not affect this situation.  We are finalizing the program - every 10 milliseconds we check the values ‚Äã‚Äãof the inputs and react to changes only if the combination of five inputs is the same 6 times in a row.  Delay on the eye is almost imperceptible, the problem with interference is solved.  Here they are, the main advantages of programmable microcontrollers! <br><br><h4>  4. Determine the angle of rotation of the front wheels - feedback through the ADC (analog-digital converter) </h4><br>  In the second part, I mentioned that it‚Äôs impossible to mechanically align the front wheels in the middle.  It's time to solve the problem, because the machine should be able to drive in a straight line! <br><br><h6>  Task 10: Connecting the rheostat </h6><br>  The decision suggests itself - if not the spring, then let the motor itself spin in the opposite direction until it aligns the wheels.  Digital <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA_%25D1%2583%25D0%25B3%25D0%25BB%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B2%25D0%25BE%25D1%2580%25D0%25BE%25D1%2582%25D0%25B0">encoders are not</a> at hand, but there is a remarkable 10 kŒ© rheostat, the board has a 12-bit ADC (even 2), the Internet has a connection scheme and code.  The ends of the rheostat to the "plus" and "minus", the slider through a 1 kŒ© resistor to the input.  By the way, for the purposes of the ADC, you can not use any input.  I used the one that was specified in the example.  Sample code can be found directly in CoIDE for each of the libraries, including the ADC (do not forget to connect the ADC library to CoIDE).  The code is copy-paste in my program and, most importantly, it works. <br><br>  Now we install the rheostat in the machine, we connect the rheostat shaft coaxially with the output shaft of the ‚Äúgearbox‚Äù of the turning mechanism - it is the third from the motor.  The process of conjugation of non-LEGO parts with LEGO's always delivers, but the motor still manages to turn the rheostat and turn the wheels.  With difficulty, I must say.  Three wires stretch from the resistor to the board, four more are pulled from the motors. <br><br><h6>  Task 11: Using data from a rheostat </h6><br>  The empirical method selects numerical values ‚Äã‚Äãfrom 0 to 4095, corresponding to acceptable left and right boundaries of the angle of rotation of the front wheels when they are installed straight.  It seems that this range is called the dead zone - within its wheels are considered aligned to the middle.  I also picked up the values ‚Äã‚Äãfor turning off the motor when the maximum angle of rotation was reached. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">js= <span class="hljs-number"><span class="hljs-number">2500</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    j ‚Äî     0  4095 () gist=150; //    full=500; //      while (1) { //... if ((x&gt;=max*7) &amp;&amp; (inpok)) // inpok  0,         .             . if ((num==1) || (num==4) || (num==7)) // { GPIOC-&gt;BRR=GPIO_BRR_BR7; if (j&gt;0+full) { GPIOC-&gt;BSRR=GPIO_BSRR_BS6; } else { if (j&lt;0+full-gist) { GPIOC-&gt;BRR=GPIO_BRR_BR6; } } } else { GPIOC-&gt;BRR=GPIO_BRR_BR1; } if ((num==3) || (num==6) || (num==9)) // { GPIOC-&gt;BRR=GPIO_BRR_BR6; if (j&lt;4250-full) { GPIOC-&gt;BSRR=GPIO_BSRR_BS7; //   ¬´ ¬ª } else { if (j&gt;4250-full+gist) { GPIOC-&gt;BRR=GPIO_BRR_BR7; //   ¬´ ¬ª } } } else { GPIOC-&gt;BRR=GPIO_BRR_BR3; } //     if ((num==2) || (num==5) || (num==8)) { if (j&lt;js-gist*3) //       { GPIOC-&gt;BRR=GPIO_BRR_BR6; //   ¬´ ¬ª (    ) GPIOC-&gt;BSRR=GPIO_BSRR_BS7; //   ¬´ ¬ª } else { if (j&gt;js-gist*2) { GPIOC-&gt;BRR=GPIO_BRR_BR7;   ¬´ ¬ª } }; if (j&gt;js+gist*3) { GPIOC-&gt;BRR=GPIO_BRR_BR7; GPIOC-&gt;BSRR=GPIO_BSRR_BS6; } else { if (j&lt;js+gist*2) { GPIOC-&gt;BRR=GPIO_BRR_BR6; } }; }; }; //.. }</span></span></code> </pre><br></div></div><br><br>  If the machine is operated in extreme modes, and under the influence of monstrous overloads, the wheels suddenly change the angle of rotation without the appropriate command, the same code will return them to the desired position.  If we press, for example, 4, and the wheels are already in the extreme left position, the relay will not turn on. <br><br>  Let me remind you that some code was taken from someone else's examples. <br><br><div class="spoiler">  <b class="spoiler_title">The final code of the machine control program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** ***************************************************************************** * @title ADC_simple.c * @author Claude * @date 2010 Dec 29 * @brief ADC Example, Blink a LED according to ADC value ******************************************************************************* */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stm32f10x_rcc.h&gt; #include&lt;stm32f10x_gpio.h&gt; #include&lt;stm32f10x_adc.h&gt; #include "stm32f10x.h" #include "stm32f10x_conf.h" GPIO_InitTypeDef GPIO_InitStructure; ADC_InitTypeDef ADC_InitStructure; unsigned int i,j,js,gist,full,ti=0; /* Blink a LED, blink speed is set by ADC value */ int main(void) { unsigned int x,max; unsigned int move[10]; unsigned int oldsti=0,sti=0,time[10],tit=0; unsigned short recheck=5; unsigned char todisp=0,todisp2=0; x=0; unsigned char ji,ju,inp0,inp1,inp2,inp3,inpok,ink,in0,in1,in2,in3,inok,num,oldnum,back; max=250; inp0=0; inp1=0; inp2=0; inp3=0; inpok=0; ink=0; back=0; num=0; void backreset(void) { back=0; for (ju=0;ju&lt;10;ju++) { time[ju]=0; move[ju]=0; } GPIOC-&gt;BRR=GPIO_BRR_BR9; } GPIO_InitTypeDef PORT,GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); PORT.GPIO_Pin = (GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12| GPIO_Pin_8 | GPIO_Pin_9); PORT.GPIO_Mode = GPIO_Mode_Out_PP; PORT.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init( GPIOC , &amp;PORT); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //   A GPIO_InitStructure.GPIO_Pin = (GPIO_Pin_9 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7); //   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE); PORT.GPIO_Pin = (GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_5); PORT.GPIO_Mode = GPIO_Mode_Out_PP; PORT.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init( GPIOA , &amp;PORT); // input of ADC (it doesn't seem to be needed, as default GPIO state is floating input) GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 ; // that's ADC1 (PA1 on STM32) GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //clock for ADC (max 14MHz --&gt; 72/6=12MHz) RCC_ADCCLKConfig (RCC_PCLK2_Div6); // enable ADC system clock RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); // define ADC config ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; // we work in continuous sampling mode ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_NbrOfChannel = 1; ADC_RegularChannelConfig(ADC1,ADC_Channel_1, 1,ADC_SampleTime_28Cycles5); // define regular conversion config ADC_Init ( ADC1, &amp;ADC_InitStructure); //set config of ADC1 // enable ADC ADC_Cmd (ADC1,ENABLE); //enable ADC1 // ADC calibration (optional, but recommended at power on) ADC_ResetCalibration(ADC1); // Reset previous calibration while(ADC_GetResetCalibrationStatus(ADC1)); ADC_StartCalibration(ADC1); // Start new calibration (ADC must be off at that time) while(ADC_GetCalibrationStatus(ADC1)); // start conversion ADC_Cmd (ADC1,ENABLE); //enable ADC1 ADC_SoftwareStartConvCmd(ADC1, ENABLE); // start conversion (will be endless as we are in continuous mode) // debug information RCC_ClocksTypeDef forTestOnly; RCC_GetClocksFreq(&amp;forTestOnly); //this could be used with debug to check to real speed of ADC clock //     6 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE); TIM6-&gt;PSC = 24000 - 1; //      1000    // TIM6-&gt;ARR = 1000 ; //       TIM6-&gt;ARR =4; TIM6-&gt;DIER |= TIM_DIER_UIE; //    TIM6-&gt;CR1 |= TIM_CR1_CEN; //  ! NVIC_EnableIRQ(TIM6_DAC_IRQn); // TIM6_DAC_IRQn  j= 2500; js=j; gist=150; full=500; if (back==0) { for (ju=0;ju&lt;10;ju++) { time[ju]=0; move[ju]=0; } } while (1) { // adc is in free run, and we get the value asynchronously, this is not a really nice way of doing, but it work! j = ADC_GetConversionValue(ADC1) ; // value from 0 to 4095 /* possible change : * ADC_ContinuousConvMode = DISABLE * then on the infinite loop, something like : * * ADC_SoftwareStartConvCmd(ADC1, ENABLE); // start ONE conversion * while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); // wait end of conversion * j = ADC_GetConversionValue(ADC1) * 500; // get value * */ do { sti=ti; } while (ti&gt;1+sti); //if ((back!=2) || GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_9)) if (oldsti!=sti) { oldsti=sti; if (ink&lt;recheck) { in0+=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_5); in1+=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_6); in2+=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_7); in3+=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_8); inok+=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_9); ink++; if (ink==recheck) { ink=0; if ((in0==0 || in0==recheck) &amp;&amp; (in1==0 || in1==recheck) &amp;&amp; (in2==0 || in2==recheck) &amp;&amp; (in3==0 || in3==recheck) &amp;&amp; (inok==0 || inok==recheck)) { if (in0==recheck) { in0=1; } if (in1==recheck) { in1=1; } if (in2==recheck) { in2=1; } if (in3==recheck) { in3=1; } if (inok==recheck) { inok=1; } if ((back==2) &amp;&amp; (inok==1)) { backreset(); } if ( (back!=2) &amp;&amp; (back!=4) &amp;&amp; ((inp0!=in0) || (inp1!=in1) || (inp2!=in2) || (inp3!=in3) || (inpok!=inok)) ) { x=0; inp0=in0; inp1=in1; inp2=in2; inp3=in3; inpok=inok; oldnum=num; if (inp0) // -  { if (inp1) { if (inp2) { if (inp3) { num=15; } else { num=7; }; } else { if (inp3) { num=11; } else { num=3; }; }; } else { if (inp2) { if (inp3) { num=13; } else { num=5; }; } else { if (inp3) { num=9; } else { num=1; }; }; }; } else { if (inp1) { if (inp2) { if (inp3) { num=14; } else { num=6; }; } else { if (inp3) { num=10; } else { num=2; }; }; } else { if (inp2) { if (inp3) { num=12; } else { num=4; }; } else { if (inp3) { num=8; } else { num=0; }; }; }; }; }; } in0=0; in1=0; in2=0; in3=0; inok=0; } } }; //  if ((todisp&gt;0) &amp;&amp; (sti%10==0)) { if ((sti%(todisp*20+100)&lt;todisp*20) &amp;&amp; (sti%20&lt;10)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS8; } else { GPIOC-&gt;BRR=GPIO_BRR_BR8; }; }; if ((todisp2&gt;0) &amp;&amp; (sti%10==2)) { if ((sti%(todisp2*20+100)&lt;todisp2*20) &amp;&amp; (sti%20&lt;10)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS9; } else { GPIOC-&gt;BRR=GPIO_BRR_BR9; }; }; //   if ((num==12)) { switch (back) { case 0: if (inpok) { back=3; }; break; case 3: if (!inpok) { back=4;ji=0;inpok=0;x=0; sti=0; }; break; default: ; } }; if (back==4) { if (inpok==0) { while ((move[ji]&lt;1) &amp;&amp; (ji&lt;10)) { ji++; }; if ((ji&lt;10)) { if ((sti&gt;100)) { x=0; sti=0; num=move[ji]; tit=time[ji]; inpok=1; GPIOC-&gt;BRR=GPIO_BRR_BR8; GPIOC-&gt;BSRR=GPIO_BSRR_BS9; } } else { backreset(); } } else { if (sti&gt;tit) { inpok=0; sti=0; x=0; ji++; GPIOC-&gt;BSRR=GPIO_BSRR_BS8; } } }; //   if ((num==10)) { switch (back) { case 0: if (inpok) { back=1; }; break; case 1: if (!inpok) { back=2;ji=9;inpok=0;x=0; sti=0; }; break; default: ; } }; if (back==2) { if (inpok==0) { if ((ji&gt;0) &amp;&amp; (move[ji]&gt;0)) { if ((sti&gt;100)) { x=0; sti=0; num=move[ji]; if (num&lt;4) { num+=6; } else { if (num&gt;6) { num-=6; } } tit=time[ji]; inpok=1; GPIOC-&gt;BRR=GPIO_BRR_BR8; GPIOC-&gt;BSRR=GPIO_BSRR_BS9; } } else { backreset(); } } else { if (sti&gt;tit) { inpok=0; x=0; sti=0; ji--; GPIOC-&gt;BSRR=GPIO_BSRR_BS8; } } }; //      "*" if (num==11) { backreset(); } if ((x==3*max)) { GPIOC-&gt;BRR=GPIO_BRR_BR12; if ((!inpok) || (num&lt;1) || (num&gt;9)) { GPIOC-&gt;BRR=GPIO_BRR_BR6; GPIOC-&gt;BRR=GPIO_BRR_BR7; GPIOC-&gt;BRR=GPIO_BRR_BR10; GPIOC-&gt;BRR=GPIO_BRR_BR11; } if ((back!=2)&amp;&amp;(back!=4)) { in0=inp0; in1=inp1; in2=inp2; in3=inp3; inok=inpok; } if ((move[9]&gt;0)&amp;&amp;(move[9]&lt;10)&amp;&amp;(!inpok)&amp;&amp;(back!=2)&amp;&amp;(back!=4)) { for (ju=0;ju&lt;9;ju++) { time[ju]=time[ju+1]; } time[9]=sti; }; }; if ((x==5*max) &amp;&amp; (inpok)) { if ((1&lt;=num) &amp;&amp; (num&lt;=9)&amp;&amp;(back!=2)&amp;&amp;(back!=4)) { for (ju=0;ju&lt;9;ju++) //    { move[ju]=move[ju+1]; } move[9]=num; sti=0; // ,       }; if ((num==1) || (num==2) || (num==3)) { GPIOC-&gt;BRR=GPIO_BRR_BR10; GPIOC-&gt;BSRR=GPIO_BSRR_BS11; GPIOC-&gt;BSRR=GPIO_BSRR_BS2; } else { GPIOC-&gt;BRR=GPIO_BRR_BR11; }; if ((num==7) || (num==8) || (num==9)) //  { GPIOC-&gt;BRR=GPIO_BRR_BR11; GPIOC-&gt;BSRR=GPIO_BSRR_BS10; GPIOC-&gt;BSRR=GPIO_BSRR_BS2; } else { GPIOC-&gt;BRR=GPIO_BRR_BR10; }; }; if ((x&gt;=max*7) &amp;&amp; (inpok)) // inpok  0,         .             . { if ((num==1) || (num==4) || (num==7)) // { GPIOC-&gt;BRR=GPIO_BRR_BR7; if (j&gt;0+full) { GPIOC-&gt;BSRR=GPIO_BSRR_BS6; } else { if (j&lt;0+full-gist) { GPIOC-&gt;BRR=GPIO_BRR_BR6; } } } else { GPIOC-&gt;BRR=GPIO_BRR_BR1; } if ((num==3) || (num==6) || (num==9)) // { GPIOC-&gt;BRR=GPIO_BRR_BR6; if (j&lt;4250-full) { GPIOC-&gt;BSRR=GPIO_BSRR_BS7; } else { if (j&gt;4250-full+gist) { GPIOC-&gt;BRR=GPIO_BRR_BR7; } } } else { GPIOC-&gt;BRR=GPIO_BRR_BR3; } //     if ((num==2) || (num==5) || (num==8)) { if (j&lt;js-gist*3) //       { GPIOC-&gt;BRR=GPIO_BRR_BR6; //   ¬´ ¬ª (    ) GPIOC-&gt;BSRR=GPIO_BSRR_BS7; //   ¬´ ¬ª } else { if (j&gt;js-gist*2) { GPIOC-&gt;BRR=GPIO_BRR_BR7;   ¬´ ¬ª } }; if (j&gt;js+gist*3) { GPIOC-&gt;BRR=GPIO_BRR_BR7; GPIOC-&gt;BSRR=GPIO_BSRR_BS6; } else { if (j&lt;js+gist*2) { GPIOC-&gt;BRR=GPIO_BRR_BR6; } }; }; }; if ((x==max*15)) { if (((num==1) || (num==2) || (num==3) || (num==5) || (num==7) || (num==8) || (num==9))&amp;&amp;(inpok)) //    { GPIOC-&gt;BSRR=GPIO_BSRR_BS12; } else { GPIOC-&gt;BRR=GPIO_BRR_BR12; } x++; } else { x++; if (x&gt;max*20+300000) { if (!inpok) { GPIOC-&gt;BRR=GPIO_BRR_BR2;//   } x=max*20+1; } } //   if (x%80000&lt;40000) { if ((num%3==1) &amp;&amp; (inpok) &amp;&amp; (num&lt;10)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS1; } else { GPIOC-&gt;BRR=GPIO_BRR_BR1; } if ((num%3==0) &amp;&amp; (inpok) &amp;&amp; (num&lt;10)) { GPIOC-&gt;BSRR=GPIO_BSRR_BS3; } else { GPIOC-&gt;BRR=GPIO_BRR_BR3; } } else { GPIOC-&gt;BRR=GPIO_BRR_BR1; GPIOC-&gt;BRR=GPIO_BRR_BR3; } if (sti==0) { do { ti=0; } while (ti&gt;1); } }; return 0; }; //   TIM6_DAC void TIM6_DAC_IRQHandler(void) { ti++; TIM6-&gt;SR &amp;= ~TIM_SR_UIF; //  UIF }</span></span></span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/fd9/688/632/fd9688632c7c79181572564468e1f141.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/550/3b9/992/5503b9992444fe8ec425ad2b72a0589c.jpg" alt="image"><br><br>  It works like this: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/CN3lW_b-Rcs%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhh0_ZY-cPqn-_OfEkZSZ_NcL1-LnQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  5. Using a DAC (Digital-to-Analog Converter) to Play Sounds </h4><br>  Since the ADC was mastered, then the DAC should not be ignored.  The most obvious way to use it for educational and entertainment purposes seems to me the generation of sounds.  The order of mastering is classic: we find a ready-made example on the Web, we run, ‚Äúwow!‚Äù, We modify the code. <br>  I connected the loudspeaker to the plus and to the collector of the NPN transistor, the signal from the foot to which the DAC is connected comes to the base of the transistor through a resistor.  In theory, the speaker is powered by an electrical audio signal with varying polarity, but I apply current to the speaker in only one direction.  I tried different circuits about two transistors, but I could not hear a significant difference in sound.  Maybe I just did not find a suitable scheme. <br><br>  The first sounds were obtained using <a href="http://easystm32.ru/for-beginners/37-dac-stm32">this</a> example. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_rcc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_gpio.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ,       DAC    */</span></span></span><span class="hljs-meta"> const uint16_t sin[32] = { 2047, 2447, 2831, 3185, 3498, 3750, 3939, 4056, 4095, 4056, 3939, 3750, 3495, 3185, 2831, 2447, 2047, 1647, 1263, 909, 599, 344, 155, 38, 0, 38, 155, 344, 599, 909, 1263, 1647}; unsigned char i=0; int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   6 */</span></span></span><span class="hljs-meta"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*        */</span></span></span><span class="hljs-meta"> TIM6-&gt;PSC = 0; TIM6-&gt;ARR = 500; TIM6-&gt;DIER |= TIM_DIER_UIE; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    TIM6-&gt;CR1 |= TIM_CR1_CEN; //  ! NVIC_EnableIRQ(TIM6_DAC_IRQn); // TIM6_DAC_IRQn  /*  DAC1 */ DAC-&gt;CR |= DAC_CR_EN1; /*   */ while (1) { } } /*    6 */ void TIM6_DAC_IRQHandler(void) { TIM6-&gt;SR &amp;= ~TIM_SR_UIF; //  UIF DAC-&gt;DHR12R1=sin[i++]; //      if (i==32) i=0; //     32     }</span></span></span></span></code> </pre><br></div></div><br><br>  It would be nice to calculate what frequency the squeaking should turn out, based on the program code, and compare the result with the tuner readings.  Processor frequency: 24,000,000 Hz.  The TIM6-&gt; PSC timer is reset when it reaches zero, i.e.  every beat.  Timer TIM6-&gt; ARR counts up to 500, i.e.  The interrupt is triggered at every 501th reset of TIM6-&gt; PSC - in our case it is (24,000,000 Hz / 1) / 501 ‚âà 47 904 Hz.  This <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D0%25B4%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">is the sampling frequency of the</a> future sound signal. ,      -   mp3     44 100 . , ,     ‚Äî 16    12. ,   . <br><br>   ‚Äî ,     32    sin.             : 47 904  / 32 ‚âà 1 497 .     (  5       ),     ‚Ä¶  ¬´!¬ª.     F#6,  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0"></a>    ,     : 1 497,1 . <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/930/7af/21c/9307af21c45ca523e383a1bb2dbd8cf4.jpg" alt="image"><br><br><h6>  12:     </h6><br>  Since       ,    -    . -,    . ,    5     , <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D0%259D%25D0%25B0%25D0%25B9%25D0%25BA%25D0%25B2%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0"></a>    10 .    : <br> TIM6-&gt;PSC = 23; //  1 M <br> TIM6-&gt;ARR = 99; //  PSC 23  ARR 99   100  (10 ) <br>     , ,  ‚Äî 27,5 .   ,           (440   ,      ),     <img src="https://habrastorage.org/getpro/geektimes/post_images/9e2/bcf/4e2/9e2bcf4e2a044f9298085204b40d536b.png" alt="image">   11  (  ).             (   12  n    ). <br><br>    :      ,         Excel .       , . . ,          (),    .  2 400 .       Excel, ,       : <br><ol><li>  ,    12  (  ). </li><li>           ( ‚Äî 27,5 )      (# ‚Äî  +1 ,  ‚Äî +2 ,    ‚Äî +12 ). </li><li>          ,    10 000 ,             10 000 . </li><li>           . </li><li>     0  4095, . </li></ol><br><br>          .  Result: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  const uint16_t noteC[]={ 76,2216,2383,2547,2709,2865,3017,3162,3299,3428,3547,3657,3755,3842,3917, 3979,4028,4064,4086,4095,4090,4070,4038,3991,3932,3860,3775,3679,3572, 3455,3328,3193,3050,2900,2744,2584,2419,2253,2085,1917,1749,1584,1422, 1264,1111,965,826,695,574,462,361,271,194,129,76,38,12,1,3,19,49,92,149, 218,300,393,498,613,738,871,1013,1161,1316,1475,1639,1805,1973 };</span></span></code> </pre><br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   const uint16_t noteCd[]={ 72,2226,2402,2576,2746,2911,3069,3220,3361,3493,3614,3722,3818,3901,3970, 4024,4063,4087,4095,4088,4065,4027,3974,3907,3825,3730,3622,3503,3372, 3231,3081,2924,2759,2590,2416,2239,2061,1883,1706,1532,1362,1196,1038, 887,744,612,490,381,284,200,130,75,35,10,0,6,27,64,116,182,263,357,464, 583,713,853,1002,1159,1323,1492,1666,1842,2020 }; const uint16_t noteD[]={ 68,2236,2423,2607,2786,2959,3124,3280,3425,3559,3680,3787,3879,3955,4016, 4059,4086,4095,4087,4061,4018,3959,3883,3792,3686,3566,3432,3288,3132, 2968,2795,2617,2433,2246,2057,1869,1682,1498,1318,1145,980,823,677,543, 421,314,221,143,82,38,10,0,7,32,74,133,207,298,403,523,655,799,954,1118, 1291,1469,1652,1839,2028 }; const uint16_t noteDd[]={ 63,2247,2445,2639,2828,3009,3181,3342,3490,3625,3745,3849,3935,4003, 4053,4084,4095,4087,4059,4012,3946,3862,3761,3643,3510,3363,3204, 3034,2854,2666,2473,2275,2076,1876,1678,1483,1293,1111,938,775, 625,488,366,260,171,100,48,14,0,6,31,76,139,220,319,434,565,710, 868,1037,1215,1402,1594,1792,1991 }; //  const uint16_t noteE[]={ 60,2259,2469,2673,2872,3061,3239,3405,3556,3691,3809,3907,3986,4044,4080, 4095,4087,4058,4008,3936,3844,3733,3604,3458,3297,3122,2937,2741,2538, 2330,2119,1907,1697,1490,1289,1097,914,744,588,447,324,219,133,69,25, 3,3,24,68,133,218,323,446,586,742,912,1095,1287,1488,1694,1905 }; const uint16_t noteF[]={ 57,2272,2493,2709,2917,3115,3300,3470,3623,3756,3870,3961,4029,4074, 4094,4089,4060,4007,3930,3831,3710,3569,3410,3234,3044,2842,2631, 2413,2190,1965,1742,1522,1309,1104,911,731,567,421,295,189,106,47, 11,0,14,51,113,199,306,434,582,748,929,1123,1329,1543,1763,1987 }; const uint16_t noteFd[]={ 54,2285,2519,2747,2966,3172,3362,3536,3689,3820,3927,4008, 4063,4091,4092,4065,4010,3929,3823,3693,3540,3367,3177, 2971,2753,2526,2291,2054,1817,1582,1354,1135,929,738,564, 410,279,171,89,33,4,3,29,83,163,269,399,550,723,912,1118,1336,1563,1797,2034 }; const uint16_t noteG[]={ 51,2299,2547,2787,3016,3230,3426,3602,3754,3880,3978,4047,4086, 4094,4071,4017,3934,3822,3683,3519,3333,3127,2905,2670,2426,2176, 1924,1674,1430,1194,972,766,580,416,276,163,79,25,1,8,47,115,213, 338,490,665,861,1075,1303,1543,1791,2042 }; const uint16_t noteGd[]={ 48,2314,2576,2829,3068,3290,3492,3668,3817,3936,4023,4076, 4095,4079,4028,3944,3828,3681,3506,3307,3086,2848,2596, 2335,2069,1802,1540,1286,1045,821,618,440,288,167,78,22, 0,14,61,143,257,401,574,771,991,1228,1479,1739,2005 }; const uint16_t noteA[]={ 45,2330,2606,2872,3123,3353,3558,3734,3878,3987,4059,4092, 4087,4043,3961,3842,3689,3504,3292,3056,2801,2532,2253, 1970,1689,1415,1153,907,684,486,319,184,85,23,0,16,71, 163,292,454,646,865,1107,1366,1639,1919 }; const uint16_t noteAd[]={ 42,2346,2639,2918,3179,3416,3624,3798,3934,4030,4083,4093, 4059,3982,3864,3707,3514,3290,3039,2767,2480,2183,1883, 1587,1301,1031,782,561,371,218,103,30,1,15,72,172,313, 490,700,940,1203,1484,1777 }; const uint16_t noteH[]={ 40,2364,2673,2967,3238,3481,3690,3859,3985,4064,4095,4076, 4009,3894,3736,3536,3301,3036,2747,2441,2126,1809,1498,1199, 922,671,453,274,137,46,3,10,65,168,316,506,732,991,1274,1577,1890 }; const uint16_t noteP[]={ //   1,2048 };</span></span></code> </pre><br></div></div><br><br>  ,           (  1, 2, 4, 8  ..): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mnote(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *pa,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> octave) <span class="hljs-comment"><span class="hljs-comment">//         { int ii=0; do {ii=i;} while (ii!=i); ii=(octave*ii)%pa[0]; ii=*(pa+ii); return ii; }</span></span></code> </pre><br><br>  i   100    : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    6 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIM6_DAC_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ i++; TIM6-&gt;SR &amp;= ~TIM_SR_UIF; <span class="hljs-comment"><span class="hljs-comment">//  UIF }</span></span></code> </pre><br><br>  ,    .      ,     Nokia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *melody[]={ noteE,noteP,noteG,noteP, noteA,noteA,noteP,noteE, noteP,noteG,noteP,noteAd, noteA,noteA,noteP,noteP, noteE,noteP,noteG,noteP, noteA,noteA,noteP,noteG, noteP,noteE,noteP,noteP, noteP,noteP,noteP,noteP };</code> </pre><br><br> ,        ?.. <br><br>   <a href="http://ru.wikipedia.org/wiki/%25CC%25E0%25E6%25EE%25F0%25ED%25EE%25E5_%25F2%25F0%25E5%25E7%25E2%25F3%25F7%25E8%25E5"></a> (),    ,   : <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *melody2[]={ noteH,noteP,noteD,noteP, noteE,noteE,noteP,noteH, noteP,noteD,noteP,noteF, noteE,noteE,noteP,noteP, noteH,noteP,noteD,noteP, noteE,noteE,noteP,noteD, noteP,noteH,noteP,noteP, noteP,noteP,noteP,noteP }; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *melody3[]={ noteGd,noteP,noteH,noteP, noteCd,noteCd,noteP,noteGd, noteP,noteH,noteP,noteD, noteCd,noteCd,noteP,noteP, noteGd,noteP,noteH,noteP, noteCd,noteCd,noteP,noteH, noteP,noteGd,noteP,noteP, noteP,noteP,noteP,noteP };</code> </pre><br></div></div><br><br>             ( ).  But!     0  4095,        .      ,        ,   .    100 ‚Ä¶ <br><br>    . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_rcc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x_gpio.h"</span></span></span><span class="hljs-meta"> int i=0; uint16_t current=0; int loccurrent=0; uint16_t mnote(const uint16_t *pa,char octave) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//         { int ii=0; do {ii=i;} while (ii!=i); ii=(octave*ii)%pa[0]; ii=*(pa+ii); return ii; } //      100 ,  0  4095 //  const uint16_t noteC[]={ 76,2216,2383,2547,2709,2865,3017,3162,3299,3428,3547,3657,3755,3842,3917,3979,4028,4064,4086,4095,4090,4070,4038,3991,3932,3860,3775,3679,3572,3455,3328,3193,3050,2900,2744,2584,2419,2253,2085,1917,1749,1584,1422,1264,1111,965,826,695,574,462,361,271,194,129,76,38,12,1,3,19,49,92,149,218,300,393,498,613,738,871,1013,1161,1316,1475,1639,1805,1973 }; //   const uint16_t noteCd[]={ 72,2226,2402,2576,2746,2911,3069,3220,3361,3493,3614,3722,3818,3901,3970,4024,4063,4087,4095,4088,4065,4027,3974,3907,3825,3730,3622,3503,3372,3231,3081,2924,2759,2590,2416,2239,2061,1883,1706,1532,1362,1196,1038,887,744,612,490,381,284,200,130,75,35,10,0,6,27,64,116,182,263,357,464,583,713,853,1002,1159,1323,1492,1666,1842,2020 }; const uint16_t noteD[]={ 68,2236,2423,2607,2786,2959,3124,3280,3425,3559,3680,3787,3879,3955,4016,4059,4086,4095,4087,4061,4018,3959,3883,3792,3686,3566,3432,3288,3132,2968,2795,2617,2433,2246,2057,1869,1682,1498,1318,1145,980,823,677,543,421,314,221,143,82,38,10,0,7,32,74,133,207,298,403,523,655,799,954,1118,1291,1469,1652,1839,2028 }; const uint16_t noteDd[]={ 63,2247,2445,2639,2828,3009,3181,3342,3490,3625,3745,3849,3935,4003,4053,4084,4095,4087,4059,4012,3946,3862,3761,3643,3510,3363,3204,3034,2854,2666,2473,2275,2076,1876,1678,1483,1293,1111,938,775,625,488,366,260,171,100,48,14,0,6,31,76,139,220,319,434,565,710,868,1037,1215,1402,1594,1792,1991 }; //  const uint16_t noteE[]={ 60,2259,2469,2673,2872,3061,3239,3405,3556,3691,3809,3907,3986,4044,4080,4095,4087,4058,4008,3936,3844,3733,3604,3458,3297,3122,2937,2741,2538,2330,2119,1907,1697,1490,1289,1097,914,744,588,447,324,219,133,69,25,3,3,24,68,133,218,323,446,586,742,912,1095,1287,1488,1694,1905 }; const uint16_t noteF[]={ 57,2272,2493,2709,2917,3115,3300,3470,3623,3756,3870,3961,4029,4074,4094,4089,4060,4007,3930,3831,3710,3569,3410,3234,3044,2842,2631,2413,2190,1965,1742,1522,1309,1104,911,731,567,421,295,189,106,47,11,0,14,51,113,199,306,434,582,748,929,1123,1329,1543,1763,1987 }; const uint16_t noteFd[]={ 54,2285,2519,2747,2966,3172,3362,3536,3689,3820,3927,4008,4063,4091,4092,4065,4010,3929,3823,3693,3540,3367,3177,2971,2753,2526,2291,2054,1817,1582,1354,1135,929,738,564,410,279,171,89,33,4,3,29,83,163,269,399,550,723,912,1118,1336,1563,1797,2034 }; const uint16_t noteG[]={ 51,2299,2547,2787,3016,3230,3426,3602,3754,3880,3978,4047,4086,4094,4071,4017,3934,3822,3683,3519,3333,3127,2905,2670,2426,2176,1924,1674,1430,1194,972,766,580,416,276,163,79,25,1,8,47,115,213,338,490,665,861,1075,1303,1543,1791,2042 }; const uint16_t noteGd[]={ 48,2314,2576,2829,3068,3290,3492,3668,3817,3936,4023,4076,4095,4079,4028,3944,3828,3681,3506,3307,3086,2848,2596,2335,2069,1802,1540,1286,1045,821,618,440,288,167,78,22,0,14,61,143,257,401,574,771,991,1228,1479,1739,2005 }; const uint16_t noteA[]={ 45,2330,2606,2872,3123,3353,3558,3734,3878,3987,4059,4092,4087,4043,3961,3842,3689,3504,3292,3056,2801,2532,2253,1970,1689,1415,1153,907,684,486,319,184,85,23,0,16,71,163,292,454,646,865,1107,1366,1639,1919 }; const uint16_t noteAd[]={ 42,2346,2639,2918,3179,3416,3624,3798,3934,4030,4083,4093,4059,3982,3864,3707,3514,3290,3039,2767,2480,2183,1883,1587,1301,1031,782,561,371,218,103,30,1,15,72,172,313,490,700,940,1203,1484,1777 }; const uint16_t noteH[]={ 40,2364,2673,2967,3238,3481,3690,3859,3985,4064,4095,4076,4009,3894,3736,3536,3301,3036,2747,2441,2126,1809,1498,1199,922,671,453,274,137,46,3,10,65,168,316,506,732,991,1274,1577,1890 }; const uint16_t noteP[]={ 1,2048 }; //,   uint16_t *melody[]={ noteE,noteP,noteG,noteP, noteA,noteA,noteP,noteE, noteP,noteG,noteP,noteAd, noteA,noteA,noteP,noteP, noteE,noteP,noteG,noteP, noteA,noteA,noteP,noteG, noteP,noteE,noteP,noteP, noteP,noteP,noteP,noteP }; //  uint16_t *melody2[]={ noteH,noteP,noteD,noteP, noteE,noteE,noteP,noteH, noteP,noteD,noteP,noteF, noteE,noteE,noteP,noteP, noteH,noteP,noteD,noteP, noteE,noteE,noteP,noteD, noteP,noteH,noteP,noteP, noteP,noteP,noteP,noteP }; //  uint16_t *melody3[]={ noteGd,noteP,noteH,noteP, noteCd,noteCd,noteP,noteGd, noteP,noteH,noteP,noteD, noteCd,noteCd,noteP,noteP, noteGd,noteP,noteH,noteP, noteCd,noteCd,noteP,noteH, noteP,noteGd,noteP,noteP, noteP,noteP,noteP,noteP }; int main(void) { GPIO_InitTypeDef PORT; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC , ENABLE); PORT.GPIO_Pin = (GPIO_Pin_9 | GPIO_Pin_8); PORT.GPIO_Mode = GPIO_Mode_Out_PP; PORT.GPIO_Speed = GPIO_Speed_2MHz; GPIO_Init(GPIOC, &amp;PORT); /*    */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); /*   */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE); /*   6 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE); /*    */ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); TIM6-&gt;PSC = 23; // 24000-1  1000 TIM6-&gt;ARR = 99; // PSC 23  ARR 99   100  TIM6-&gt;DIER |= TIM_DIER_UIE; //    TIM6-&gt;CR1 |= TIM_CR1_CEN; //  ! NVIC_EnableIRQ(TIM6_DAC_IRQn); // TIM6_DAC_IRQn  /*  DAC1 */ DAC-&gt;CR |= DAC_CR_EN1; /*   */ while (1) { GPIOC-&gt;BRR=GPIO_BRR_BR8; GPIOC-&gt;BSRR=GPIO_BSRR_BS9; do { loccurrent=i; } while (i!=loccurrent); //  ,    GPIOC-&gt;BRR=GPIO_BRR_BR9; GPIOC-&gt;BSRR=GPIO_BSRR_BS8; current=(loccurrent/(2000))%32; //   ,  0  31. DAC-&gt;DHR12R1=(mnote(melody[current],1)+mnote(melody2[current],1)+mnote(melody[current],2)+mnote(melody2[current],2)+mnote(melody[current],4)+mnote(melody3[current],2))/6; } } /*    6 */ void TIM6_DAC_IRQHandler(void) { i++; TIM6-&gt;SR &amp;= ~TIM_SR_UIF; //  UIF }</span></span></span></span></code> </pre><br></div></div><br><br>   ,          -  ?  Yes. <br><br><h6>  13:     </h6><br>  ,  ,   <a href="http://we.easyelectronics.ru/STM32/vosproizvedenie-zvuka-na-stm32-discovery-pri-pomoschi-speex.html"></a>  STM32VLDiscovery,      .  : <br> 1.   Youtube    Aston Martin. <br> 2.  ( )  . <br> 3.     (   <a href="http://audacity.sourceforge.net/">Audacity</a> ). <br> 4.     .   24 . ,        2 ,     2-3  -.  Just right. <br> 5.    WAV-. <br> 6.      ( WAV 2 TEXT) ‚Äî -,   . ,    . <br> 7.     0  4095   Excel.  60 000    Notepad++  Sublime Text,     .   Excel    30  ,         ‚Äî CoIDE    ‚Ä¶ <br> 8.    . <br><br> , over 9000     .  : <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/NIDG6INFt7w%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhhK48IDSsf_AMtOcY_em6HvLx_zKg" frameborder="0" allowfullscreen=""></iframe><br><br>   ,          , , ,  ,  : <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/CN3lW_b-Rcs%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhh0_ZY-cPqn-_OfEkZSZ_NcL1-LnQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Something like this. </div><p>Source: <a href="https://habr.com/ru/post/161993/">https://habr.com/ru/post/161993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161979/index.html">One Div: icons on CSS</a></li>
<li><a href="../161981/index.html">Promotion of mobile applications</a></li>
<li><a href="../161987/index.html">Standard PHP Library (SPL) - Part 1: Data Structures</a></li>
<li><a href="../161989/index.html">Perl6 - I / O Modules</a></li>
<li><a href="../161991/index.html">Weather Station Thunder-2M (Anemometer)</a></li>
<li><a href="../161997/index.html">Comfortable lighting for work and leisure</a></li>
<li><a href="../161999/index.html">256 colors in the terminal ‚áí nightmare level</a></li>
<li><a href="../162003/index.html">Simple USB Keyboard Emulation with PIC18F2550 in Android CarPC</a></li>
<li><a href="../162005/index.html">Copyright history. Part 1: The Black Death</a></li>
<li><a href="../162007/index.html">The future is near: Queen Elizabeth is broadcasting in 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>