<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL integration with MS SQL Server for those who want quicker and deeper</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, a description of the integration of PostgreSQL and MSSQL has been published on Habr√©. But, the details there are absolutely not enough. Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL integration with MS SQL Server for those who want quicker and deeper</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/af7/cbe/2cb/af7cbe2cb3b748be8ef2710b5befdfee.png"></div><br>  Recently, a <a href="https://habrahabr.ru/company/postgrespro/blog/309490/">description of the integration of</a> PostgreSQL and MSSQL has been published on Habr√©.  But, the details there are absolutely not enough.  Therefore, the purpose of this publication is as follows: <br><br><ul><li>  Expand and deepen publicly available information about FDW for MSSQL called <a href="https://github.com/tds-fdw/tds_fdw">tds_fdw</a> : talk about the difference in major versions and describe basic compatibility issues; </li><li>  talk about the possibilities of optimizing queries using external tables; </li><li>  touch on the topic of external data caching in materialized views; </li><li>  say a few words about the exotic approaches to the integration of PostgreSQL and MSSQL. </li></ul><br><a name="habracut"></a><br><h3>  Installing and configuring TDS FDW </h3><br>  The guys from PostgresPro have already <a href="https://habrahabr.ru/company/postgrespro/blog/309490/">said</a> enough about this process, I will not repeat.  I‚Äôll leave only a few links to the official PostgreSQL documentation and examples from tds_fdw: <br><br><ul><li>  creation of an extension (extension) in PG: <a href="https://www.postgresql.org/docs/current/static/sql-createextension.html">off.documentation</a> ; </li><li>  server creation: <a href="https://www.postgresql.org/docs/9.5/static/sql-createserver.html%2522">off.documentation</a> , <a href="">example from tds_fdw</a> ; </li><li>  creation of user mapping (user mapping): <a href="https://www.postgresql.org/docs/9.5/static/sql-createusermapping.html%2522">off.documentation</a> , <a href="">example from tds_fdw</a> ; </li><li>  creation of a foreign table (foreign table): <a href="https://www.postgresql.org/docs/9.5/static/sql-createforeigntable.html%2522">off.documentation</a> , <a href="">an example from tds_fdw</a> . </li></ul><br>  And one more thing: please do not do as indicated in <a href="">the installation instructions for tds_fdw</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="bash hljs">sudo make USE_PGXS=1 install</code> </pre> <br>  <a href="https://habrahabr.ru/post/130868/">Save the cats</a> , collect the deb-package and enjoy your life: <br><br><pre> <code class="bash hljs">sudo USE_PGXS=1 checkinstall</code> </pre><br><h3>  Differences between major versions of TDS FDW </h3><br>  At the moment there are two current versions of FDW's: stable 1.0.7 and 2.0.0-alpha, which, in essence, is a master branch and in which all the most interesting happens.  Here is a small list of their differences: <br><br><ul><li>  in 2.0.0, pushdown support finally appeared for conditions in the WHERE clause directly related to the external table;  however, it still does not work well when using the <i>query</i> option inside a foreign_table declaration; </li><li>  tds 7.4 version has been added (I‚Äôll describe why this is necessary and important below); </li><li>  There are some problems with the work of DISTINCT on the external table ( <a href="https://github.com/tds-fdw/tds_fdw/issues/99">here is an issue on GitHub</a> ), although it is not known for certain: if my hands do not grow from there or the bug is quite tricky and only manifests under certain circumstances. </li></ul><br><h3>  Compatibility Pitfalls </h3><br>  Until recently, tds_fdw did not work with tds version above 7.3.  But in the course of writing this article, support for version 7.4 had <a href="https://github.com/tds-fdw/tds_fdw/issues/100">to be found</a> .  So now, starting with commit <a href="https://github.com/tds-fdw/tds_fdw/commit/3a803c5840b8cf69e1a725fb4377d0f95a53a4e9">3a803c</a> , tds_fdw supports all current tds versions. <br><br>  Why is the support of this version so important?  For me personally, this is important because of the need to work with MSSQL 2012. In short: Ruby on Rails uses an <a href="http://activerecord-sqlserver-adapter/">activerecord-sqlserver-adapter</a> library to connect to MSSQL, which, in turn, uses <a href="https://github.com/rails-sqlserver/tiny_tds">tiny_tds</a> , which uses <a href="http://www.freetds.org/">FreeTDS</a> , which can communicate with MSSQL.  The trouble is that for RoR 3 and the corresponding major versions of libraries, using tds 7.1 is nailed and you can only change it through the config in the 4+ version.  At the same time, version 7.1 works fine with MSSQL 2008, but when communicating with MSSQL 2012 the following errors appear: <br><br><pre> <code class="hljs pgsql">DB-Library error: DB #: <span class="hljs-number"><span class="hljs-number">20017</span></span>, DB Msg: Unexpected EOF <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">server</span></span></code> </pre> <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ActiveRecord</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::LostConnection</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TinyTds</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">closed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">connection</span></span>: ...</code> </pre> <br><pre> <code class="hljs pgsql">TinyTds::Error: Adaptive <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> failed</code> </pre> <br>  And like them. <br><br>  They wanted to avoid switching to the use of FDW, since updating RoR is definitely longer and more expensive.  But tds_fdw did not support the required version and had to do something about it. <br><br>  As for errors, they all appear randomly and grow due to the same place;  make some "diversity" in the application, forcing it to fall off in random places at random times.  All this disgrace is treated only by using the correct version of tds.  For MSSQL 2012, this is tds 7.4. <br><br>  Here is the first ambush: tds 7.4 version support has been implemented in FreeTDS since version 0.95.  But out of the box in Ubuntu 14.04 and 16.04 are versions <a href="http://packages.ubuntu.com/trusty/freetds-common">0.91-5</a> and <a href="http://packages.ubuntu.com/xenial/freetds-common">0.91-6.1build1,</a> respectively.  And to get a newer version of FreeTDS in two ways: <br><br><ol><li>  compile FreeTDS <a href="https://github.com/FreeTDS/freetds">from source</a> ; </li><li>  use <a href="https://launchpad.net/~jamiewillis/%2Barchive/ubuntu/freetds">alternative PPA</a> with FreeTDS version 1.00. </li></ol><br>  In the second case, there is one nuance: in the specified repository there is a package only for Ubuntu 14.04 (which is trusty).  For 16.04 (which is xenial), there is nothing there.  But, on the whole, nothing is fatal and if you correct <b>/etc/apt/sources.list.d/jamiewill-freetds-trusty.list</b> on 16.04 to something like this: <br><br><pre> <code class="bash hljs">deb http://ppa.launchpad.net/jamiewillis/freetds/ubuntu trusty main</code> </pre> <br>  It will be possible to install the package in the latest Ubuntu (and yes, it works without problems). <br><br>  If you have CentOS, then under it you can <a href="https://rpmfind.net/linux/rpm2html/search.php%3Fquery%3Dfreetds">easily find</a> FreeTDS up to version 0.95 inclusive.  All that is older will have to collect from the source. <br><br><h4>  Temporary solution to compatibility issues </h4><br>  If the error numbered 20017 and its derivatives are very annoying, and there is no possibility to use the required version of tds, then you can handle the exception thrown by PostgreSQL and restart the / etc block, which calls MSSQL via FDW.  In my case for the RoR application, it looked like this: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retry_mssql_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tries = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::StatementInvalid =&gt; e <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.message =~ <span class="hljs-regexp"><span class="hljs-regexp">/^PG::FdwUnableToCreateExecution/</span></span> &amp;&amp; tries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> tries -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">retry</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> raise <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  For the first time, it saves, but for a long-term solution it is categorically inappropriate. <br><br><h3>  A little bit about pushdown and how FDW works on the fingers </h3><br>  Before turning to the issues of optimizing queries to an external database, I would like to say a few words about pushdown.  For some reason, the description of this mechanism is not in demand in Russian-speaking resources (or I am not familiar with its correct translation, and the <a href="">tricep press down on the block</a> is clearly not from that opera).  Therefore, I want to talk briefly about him. <br><br>  In the simplest case, when we in PG execute a query of the form: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> column_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> foreign_table <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> column_id = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  In fact, the following occurs in the database: <br><br><ol><li>  from the table associated with foreign_table (or non-table) located on a third-party server, all the contents in postgres are retrieved; </li><li>  then, the resulting data is filtered based on conditions from WHERE. </li></ol><br>  Not very effective scheme, especially if you want to get only one from a table with several million rows.  And here appears pushdown.  This mechanism allows you to reduce the number of lines that we receive from a remote server.  This is done by constructing a query to an external database, taking into account what we want on the PG side, that is, taking into account what is specified in WHERE, JOIN, ORDER, etc. In other words, FDW parses the original request in PotsgreSQL, select from it, that the remote data warehouse can understand and assemble a new query, according to these conditions.  This leads to an obvious consequence: pushdown is not applicable to all FDWs (for example, pushdown is almost useless for <a href="https://www.postgresql.org/docs/9.5/static/file-fdw.html">file_fdw</a> , but quite the opposite for <a href="https://www.postgresql.org/docs/9.5/static/postgres-fdw.html">postgres_fdw</a> or <i>tds_fdw</i> ). <br><br>  Total: pushdown is cool, it allows you to use external data storage mechanisms, reduces the amount of data circulating between the PG and external storage, thereby speeding up the execution of requests, but at the same time, it is a separate mechanism, so it needs to be implemented, maintained and pretty nontrivial task. <br><br><h3>  Speed ‚Äã‚Äãup requests </h3><br>  With the installation, configuration and materiel sorted out.  Now we will start the description of how it is possible to extract data from MSSQL as soon as possible. <br><br><h4>  Pushdown </h4><br>  This approach is useful in the case of simple queries that are not burdened with various JOINs and other SQL tricks.  The latest version of tds_fdw (currently 2.0.0-alpha) adds support for the simplest pushdown for WHERE. <br><br>  For example, consider the table <i>simple_table</i> from the MSSQL database.  There are two fields in this table: id and data.  The definition of the external table for it will be as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> mssql_table ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, custom_data <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span> OPTIONS (column_name <span class="hljs-string"><span class="hljs-string">'data'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span> mssql_svr OPTIONS (schema_name <span class="hljs-string"><span class="hljs-string">'dbo'</span></span>, table_name <span class="hljs-string"><span class="hljs-string">'simple_table'</span></span>, row_estimate_method <span class="hljs-string"><span class="hljs-string">'showplan_all'</span></span>, match_column_names <span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><br>  In this case, the first column has the same name in PostgreSQL and in MSSQL: id.  The second column has different names in PG and MSSQL, so the <i>column_name</i> option is needed here.  This parameter explicitly sets the mapping of columns from PostgreSQL to columns in MSSQL.  Also, at the end is the <i>match_column_name</i> parameter, which is responsible for the implicit mapping of column names by name, that is, thanks to it, the column id is mapped. <br><br>  Everything, now if we execute the query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> custom_data <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mssql_table <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  FDW must process the condition specified in WHERE and collect the correct query in MSSQL.  For example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> simple_table <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  In the case of tds_fdw version 1.0.7 and below, the request in MSSQL will be different: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> simple_table;</code> </pre><br>  I repeat: pushdown, currently, works only for WHERE;  for JOIN, ORDER and other functions such as MAX, LOWER, etc., it will not take off. <br><br>  And one more thing: how do you know which query was actually executed on the MSSQL side?  When using FDW for, for example, MySQL, this line appears in explain: <br><br><pre> <code class="sql hljs">Remote query: <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">`id`</span></span>, <span class="hljs-string"><span class="hljs-string">`customer_id`</span></span>, <span class="hljs-string"><span class="hljs-string">`order_date`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">`data`</span></span>.<span class="hljs-string"><span class="hljs-string">`orders`</span></span></code> </pre><br>  And it is convenient.  In tds_fdw there is no such thing yet and you need to go a longer way through the FreeTDS logs.  By default, logs are disabled in FreeTDS, but this is easily fixed by digging into <b>/etc/freetds/freetds.conf</b> .  There you can find the following lines: <br><br><pre> <code class="bash hljs">; dump file = /tmp/freetds.log ; debug flags = 0xffff</code> </pre><br>  Those who need to remove the semicolon at the beginning. <br><br>  Now for any query in MSSQL from PG, FreeTDS will log everything that it can.  This will slow down the execution of all external queries and can spawn a bunch of logs (in my case, the usual SELECT made a log in ~ 300MB, and JOIN could barely get to ~ 1.5GB).  But in logih, it will be seen what actually happened in MSSQL.  In addition, the volume of logs can be reduced by playing around with `debug flags`.  For more information about logging in FreeTDS, write <a href="http://www.freetds.org/userguide/logging.htm">here</a> , and details about `debug flags` are <a href="http://www.freetds.org/userguide/freetdsconf.htm">right here</a> . <br><br><h4>  Materialized view </h4><br>  <a href="https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html">The materialized view</a> (hereinafter MV) is the usual view + data table.  This approach will help in case of complex queries with joins of external and internal tables, with functions, preference and courtesans. <br><br>  The profit from MV is as follows: it is the ‚Äúnative‚Äù object for the PG, that is, the MV interacts remarkably well with the rest of PostgreSQL and it can be indexed and analyzed regardless of the data source that filled it.  There are also disadvantages: MV needs to be updated.  You can update by internal triggers, by external events, you can completely re-create and so on.  But, in any case, the MV generates a PG lag from the original data source. <br><br>  For the above-described external MV table, you can create it as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATERIALIZED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> materialized_mssql_table <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, custom_data <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> mssql_table;</code> </pre><br>  Now all the data from MSSQL is in PostgreSQL, which means they can be indexed as they please ( <a href="https://ru.wikipedia.org/wiki/B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">B-tree</a> , <a href="https://www.postgresql.org/docs/current/static/textsearch-indexes.html">GIN and GiST</a> , etc.), <a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html">statistics</a> become available for them, you can see the details of the query execution plan and many more pleasant things from PG. <br><br>  You can update the MV through standard INCERT / UPDATE / DELETE commands, or simply recreate all the content with <br><br><pre> <code class="sql hljs">REFRESH MATERIALIZED VIEW CONCURRENTLY materialized_mssql_table;</code> </pre> <br>  The CONCURRENTLY option allows you to update the MV without blocking competing read requests, but it takes more time and resources.  Also, in order to be able to use CONCURRENTLY, the target MV must satisfy certain requirements.  They can be found on the <a href="https://www.postgresql.org/docs/9.5/static/sql-refreshmaterializedview.html">corresponding documentation page</a> . <br><br><h4>  Exotic approach </h4><br>  Honestly, the devil knows whether this approach can take off, perhaps a respected public will tell something interesting in this regard.  In any case, I think that it is necessary to say about it, since the core resources for the majority of questions on the integration of two databases respond to "use FDW" and no diversity is expected, even if you want a strange one. <br><br>  So, when it may be necessary: ‚Äã‚Äãif all the above options did not help due to various restrictions.  For example: <br><br><ul><li>  indecently large amount of external database and the impossibility of its cloning in PG; </li><li>  strict speed requirements and the availability of an optimal query to an external database; </li><li>  the desire to execute a parameterized query, that is, an analogue of the query option for FDW, only with a dynamic parameter, for example, you want to use full-text search on the MSSQL side through the <a href="https://msdn.microsoft.com/ru-ru/library/ms187787.aspx">CONTAINS</a> function; </li><li>  something else unusual. </li></ul><br>  What to use: <a href="http://pgfoundry.org/projects/dbi-link/">dbi-link</a> or <a href="http://dblink-tds.projects.pgfoundry.org/">dblink-tds</a> .  This is analogous to <a href="https://www.postgresql.org/docs/9.5/static/dblink.html">dblink</a> but with support for several DBMS: PostgreSQL, MySQL, MSSQL Server and Oracle in the case of dbi-link and simply TDS in the case of dblink-tds. <br><br>  The mechanics of work seems to be: as a kind of highly specialized analogue of FDW as a PG function, which collects the necessary request within itself based on the arguments passed, executes it in the external database through the above tools, receives data, processes them and returns them to the PG as a <a href="http://manojadinesh.blogspot.ru/2011/11/pipelined-in-oracle-as-well-in.html">pipeline function</a> .  That is, hypothetically, you can execute exactly the query that you want and present its result in the form that is digestible for further processing in PG. <br><br>  All of the above are pure theoretical considerations.  If you have real experience using these or similar tools, please share your knowledge with the world. <br><br><h3>  Conclusion </h3><br>  Currently, there is only one simple and working solution for PostgreSQL and MSSQL docking.  This is <a href="https://github.com/tds-fdw/tds_fdw">tds_fdw</a> .  It has many flaws, but the project is developing, bugs are being repaired, features are rolling out and it's great.  Therefore, tds_fdw can solve most of the problems associated with extracting data from MSSQL via PG.  Those who want to quickly, more optimally and with courtesans will help PostgreSQL and its rich arsenal of optimization tools.  And those who want a very strange and want to do everything inside the database with a minimum of external services will be difficult.  The toolkit is ancient, there is no documentation, there is no support, it is <s>populated by robots</s> and nothing will help except reading the source code. </div><p>Source: <a href="https://habr.com/ru/post/312090/">https://habr.com/ru/post/312090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312078/index.html">Code Optimization: Memory</a></li>
<li><a href="../312080/index.html">Why I, as a developer, hate iOS</a></li>
<li><a href="../312084/index.html">DIY Password Manager</a></li>
<li><a href="../312086/index.html">Easy way to lose customers or why not use Google CDN</a></li>
<li><a href="../312088/index.html">ES6 const is not about immunity</a></li>
<li><a href="../312092/index.html">We consider porn sites, we evaluate the effectiveness of Roskomnadzor</a></li>
<li><a href="../312096/index.html">"Spherical trader in a vacuum": instructions for use</a></li>
<li><a href="../312098/index.html">Y Combinator recommends reading in 2016</a></li>
<li><a href="../312110/index.html">"Flaskr" - introduction to Flask, development through testing (TDD) and jQuery</a></li>
<li><a href="../312112/index.html">Free backup utility with free ESXI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>