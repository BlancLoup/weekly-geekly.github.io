<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expressions: no magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The code for this post, like the post itself, is laid out on github . 

 Until recently, regular expressions seemed like magic to me. I could not unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expressions: no magic</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cc/1be/18b/7cc1be18b5537994537cd6fff234713b.png" alt="image"></div><br>  The code for this post, like the post itself, is laid out on <a href="https://github.com/rcoh/toyregex">github</a> . <br><br>  Until recently, regular expressions seemed like magic to me.  I could not understand how it can be determined whether the string matches the specified regular expression.  And now I understand it!  Below is the implementation of a simple regular expression engine in less than 200 lines of code. <br><br><h2>  Part 1: Parsing </h2><br><h2>  Specification </h2><br>  Implementing regular expressions completely is quite a challenge;  worse, it will teach you little.  The version we are implementing is enough to study the topic without slipping into a routine.  Our regular expression language will support the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li><code>.</code>  - match any character </li><li> <code>|</code>  - match <code>abc</code> or <code>cde</code> </li><li>  <code>+</code> - match one or more previous patterns </li><li>  <code>*</code> - match 0 or more of the previous pattern </li><li>  <code>(</code> and <code>)</code> - for grouping </li></ul><br>  Although the set of options is small, it can be used to create interesting regexes, for example, <a href="http://xkcd.com/1313/"><code>m (t|n| ) | b</code></a>  <a href="http://xkcd.com/1313/"><code>m (t|n| ) | b</code></a> allows you to find subtitles for Star Wars without subtitles for Star Trek, or <code>(..)*</code> to find the set of all lines of even length. <br><br><h2>  Attack plan </h2><br>  We will analyze regular expressions in three steps: <br><br><ol><li>  Parsing (parsing) a regular expression into a syntax tree </li><li>  Convert the syntax tree to the state machine </li><li>  Analysis of the state machine for our row </li></ol><br>  For the analysis of regular expressions (more on this below) we will use a state machine called <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">NFA</a> .  At a high level, the NFA will represent our regex.  Upon receipt of the input data, we will move to NFA from state to state.  If we come to a point from which it is impossible to make a valid transition, then the regular expression does not match the string. <br><a name="habracut"></a><br>  This approach was first demonstrated by one of the Unix authors Ken Thompson.  In his 1968 article in CACM magazine, he outlined the principles for implementing a text editor and added this approach as an interpreter of regular expressions.  The only difference is that his article was written in machine code 7094. At that time, everything was much more hardcore. <br><br>  This algorithm is a simplification of how engines without reverse lookup, like RE2, analyze regular expressions in provable linear time.  It is very different from the regex engines from Python and Java, which use reverse lookup.  For given input data with small lines, they run almost infinitely.  Our implementation will be done in <code>O(length(input) * length(expression)</code> . <br><br>  My approach roughly corresponds to the strategy laid out by Russ Cox in his <a href="http://swtch.com/~rsc/regexp/regexp1.html">amazing post</a> . <br><br><h2>  Regular Expression Representation </h2><br>  Let's step back and think about how to represent a regular expression.  Before we start analyzing a regular expression, we need to convert it into a data structure with which the computer can work.  Although strings have a linear structure, regular expressions have a natural hierarchy. <br><br>  Let's look at the string <code>abc|(c|(de))</code> .  If we left it with a string, we would have to go back and perform transitions, tracking different sets of brackets when analyzing an expression.  One solution is to convert it to a tree that a computer can easily bypass.  For example, <code>b+a</code> turns into the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eda/822/516/eda822516f42789f2dc0ca9cb0e1b7f0.png"></div><br>  To represent the tree, we need to create a class hierarchy.  For example, our class <code>Or</code> must have two subtrees representing both of its sides.  From the specification it is clear that we need to recognize four different components of regular expressions: <code>+</code> , <code>*</code> , <code>|</code>  and character literals like <code>.</code>  , <code>a</code> and <code>b</code> .  In addition, we also need to represent cases where one expression follows another.  Here are our classes: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> ., </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Literal</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">c: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Char</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a|b</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Or</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">expr1: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expr2: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concat</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">a,b</span></span></span><span class="hljs-class">)</span></span>; abc -&gt; <span class="hljs-type"><span class="hljs-type">Concat</span></span>(a, <span class="hljs-type"><span class="hljs-type">Concat</span></span>(b, c)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concat</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">first: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span><span class="hljs-class"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a*</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Repeat</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">expr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a+</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plus</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">expr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RegexExpr</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexExpr</span></span></span></span></code> </pre> <br><h2>  Regular expression parsing </h2><br>  To move from string to tree view, we need to use a conversion process known as " <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7">parsing (parsing)</a> ".  I will not talk in detail about building parsers.  Instead, I will lay out information that is enough to point you in the right direction if you decide to write your own.  I will briefly talk about how to parse regular expressions using <a href="http://www.scala-lang.org/api/2.10.3/index.html">parser combinator library</a> Scala. <br><br>  The Scala parser library allows us to write a parser by simply writing a set of <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">rules describing our language</a> .  Unfortunately, it uses a lot of stupid characters, but I hope you can get through the noise and get a general understanding of what is happening. <br><br>  When implementing a parser, we need to determine the order of operations.  Just as in arithmetic, PEMDAS is used <i>[approx.</i>  <i>per.</i>  <i><b>P</b> arentheses, <b>E</b> xponents, <b>M</b> ultiplication / <b>D</b> ivision, <b>A</b> ddition / <b>S</b> ubtraction - a mnemonic that allows you to remember the order in which arithmetic operations are performed]</i> and a regular set of rules is used in regular expressions.  We can express it more formally with the help of the idea of ‚Äã‚Äã‚Äúbinding‚Äù the operator to the symbol next to it.  Different operators ‚Äúbecome attached‚Äù with different strengths ‚Äî by analogy, in expressions like 5 + 6 * 4, the operator <code>*</code> binds more strongly than <code>+</code> .  In regular expressions, <code>*</code> binds more strongly than <code>|</code>  .  One could imagine this in the form of a tree in which the weakest operators are at the top. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bf/d4f/d41/9bfd4fd41e104eac08249a8a7a2ebea6.png"></div><br>  Therefore, we must first parse the weaker operators, and behind them the already stronger operators.  When parsing, this can be represented as extracting the operator, adding it to the tree, and then recursively processing the remaining two parts of the string. <br><br>  In regular expressions, the binding strength is as follows: <br><br><ol><li>  Character literals and parentheses </li><li>  <code>+</code> and <code>*</code> </li><li>  "Concatenation" - a follows b </li><li> <code>|</code> </li> </ol><br>  Since we have four levels of binding power, we need four different types of expressions.  We called them (arbitrarily enough): <code>lit</code> , <code>lowExpr</code> ( <code>+</code> , <code>*</code> ), <code>midExpr</code> (concatenation) and <code>highExpr</code> ( <code>|</code> ).  Let's go to the code.  First, we will create a parser for the most basic level, for a single character: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charLit</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = (<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"\w"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>.r | <span class="hljs-string"><span class="hljs-string">"."</span></span>) ^^ { char =&gt; <span class="hljs-type"><span class="hljs-type">Literal</span></span>(char.head) }</code> </pre> <br>  Let's take a minute to explain the syntax.  The code defines a parser that <code>RegexExpr</code> .  The right side says: ‚ÄúFind something that matches <code>\w</code> (to any word symbol) or point.  If found, turn it into a <code>Literal</code> . ‚Äù <br><br>  The brackets must be defined at the lowest level of the parser, because they have the strongest reference.  However, we need to be able to put something in brackets.  We can achieve this with the following code: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parenExpr</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = <span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; highExpr &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = charLit | parenExpr</code> </pre> <br>  Here we define <code>*</code> and <code>+</code> : <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = lit &lt;~ <span class="hljs-string"><span class="hljs-string">"*"</span></span> ^^ { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> l =&gt; <span class="hljs-type"><span class="hljs-type">Repeat</span></span>(l) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = lit &lt;~ <span class="hljs-string"><span class="hljs-string">"+"</span></span> ^^ { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> p =&gt; <span class="hljs-type"><span class="hljs-type">Plus</span></span>(p) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lowExpr</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = repeat | plus | lit</code> </pre> <br>  Next, we define the next level - concatenation: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = rep(lowExpr) ^^ { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> list =&gt; listToConcat(list)} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">midExpr</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = concat | lowExpr</code> </pre> <br>  Finally, we define "or": <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">or</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = midExpr ~ <span class="hljs-string"><span class="hljs-string">"|"</span></span> ~ midExpr ^^ { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> l ~ <span class="hljs-string"><span class="hljs-string">"|"</span></span> ~ r =&gt; <span class="hljs-type"><span class="hljs-type">Or</span></span>(l, r)}</code> </pre> <br>  And at the end we define <code>highExpr</code> .  <code>highExpr</code> is <code>or</code> , the weakest binding operator, or, if not, then <code>midExpr</code> . <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highExpr</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = or | midExpr</code> </pre> <br>  Next, add some helper code to finish: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listToConcat</span></span></span></span>(list: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>]): <span class="hljs-type"><span class="hljs-type">RegexExpr</span></span> = list <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> head :: <span class="hljs-type"><span class="hljs-type">Nil</span></span> =&gt; head <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> head :: rest =&gt; <span class="hljs-type"><span class="hljs-type">Concat</span></span>(head, listToConcat(rest)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>] = { parseAll(highExpr, input) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(result, _) =&gt; <span class="hljs-type"><span class="hljs-type">Some</span></span>(result) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> failure : <span class="hljs-type"><span class="hljs-type">NoSuccess</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">None</span></span> } } }</code> </pre> <br>  And that is all!  If you take this code in Scala, you can generate syntax trees for any regular expression that meets the specification.  The resulting data structures will be trees. <br><br>  Now that we can transform our regular expressions into syntax trees, we are approaching to analyze them. <br><br><h2>  Part 2: Generating NFA </h2><br><h2>  Convert the syntax tree to NFA </h2><br>  In the previous section, we converted the representation of a regular expression in the form of a flat string to the form of a hierarchical syntactic tree.  In this part, we convert the syntax tree to a state machine.  The finite automata leads the regex components into a linear graph form, creating the relations ‚Äúa follows b follows c‚Äù.  Representation in the form of a graph will simplify the analysis relative to the potential line. <br><br>  <em>Why do another conversion just to map to regex?</em> <br><br>  Of course, one could perform the conversion directly from the string to the state machine.  You can even try to analyze a regular expression directly from the syntax tree or from a string.  However, this will have to deal with much more complex code.  Slowly lowering the level of abstraction, we can ensure that the code is easy to understand at every stage.  This is especially important when building something like an interpreter of regular expressions with almost infinite boundary cases. <br><br><h2>  NFA, DFA and you </h2><br>  We will create a state machine called the NFA, or <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">nondeterministic finite automata</a> .  It has two types of components: states and transitions.  When presented on the state diagram are indicated by circles, and transitions - by arrows.  The coincidence state is indicated by a double circle.  If the transition is marked, this means that we must receive this character at the input in order to make this transition.  Transitions may also not have tags.  This means that we can make the transition without consuming the input data.  <em>Note: in the literature it is sometimes referred to as Œµ.</em>  A state machine representing a simple regex "ab": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/7a3/512/e0b7a35126da084f5a80f6617c631b93.png"></div><br>  Our nodes can have several valid subsequent states for the given input data, since the diagram below shows two paths that, when moving from a node, consume the same input data: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c7/22a/7dc/2c722a7dce445fd12a4ee12346e561ac.png"></div><br>  Contrast this with the deterministic state machine (DFA), in which, as its name implies, the given input data can lead to a single state change.  On the one hand, this reduction in restrictions makes analysis a little more difficult, but on the other hand, as we will soon see, it greatly simplifies generating them from wood.  From a fundamental point of view, NFA and DFA are similar to each other in the state machines that they can represent. <br><br><h2>  Transformation in theory </h2><br>  Let's outline the strategy for converting a syntax tree to NFA.  Although it may seem intimidating, you will see that by breaking the process down into composable fragments, we will make it easy to understand.  Recall the syntax elements that we need to convert: <br><br><ol><li>  Character literals: <code>Lit(c: Char)</code> </li><li>  <code>*</code> : <code>Repeat(r: RegexExpr)</code> </li><li>  <code>+</code> : <code>Plus(r: RegexExpr)</code> </li><li>  Concatenation: <code>Concat(: RegexExpr, : RegexExpr)</code> </li><li> <code>|</code>  : <code>Or(a: RegexExpr, b: RegexExpr)</code> </li></ol><br>  Subsequent changes were originally outlined by Thompson in his 1968 article.  In the conversion schemes, <code>In</code> will refer to the state machine's entry point, and <code>Out</code> to the output one.  In practice, they can be the ‚ÄúMatch‚Äù state, the ‚ÄúStart‚Äù state, or other regex components.  The <code>In</code> / <code>Out</code> abstraction allows us to link and combine finite state machines ‚Äî the most important conclusion.  We will apply this principle in a more general sense to transform from each element of the syntactic tree into a composable state machine. <br><br>  Let's start with character literals.  A character literal is a transition from one state to another that consumes input data.  Consumption of the literal "a" will be as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/ed1/219/7f0ed121904618e650853514804a0585.png"></div><br>  Next, let's explore concatenation.  To concatenate the two components of the syntax tree, we just need to connect them with an arrow without labels.  It is worth noting that in this example, as <code>Concat</code> may contain the concatenation of two arbitrary regular expressions, so <code>A</code> with <code>B</code> in the scheme can be finite automata, and not just separate states.  Something a bit strange happens if both <code>A</code> and <code>B</code> are both literals.  How do we connect two arrows without intermediate states?  The answer is that literals can have phantom states on both sides in order to preserve the integrity of the state machine.  <code>Concat(A, B)</code> converted to the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e6/2c5/33c/4e62c533c57ec2fd0ea94e02a67793d0.png"></div><br>  To represent <code>Or(A, B)</code> , we need to branch from the initial state to two separate states.  After the completion of these automata, they both should indicate the following state ( <code>Out</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed1/83d/ccd/ed183dccde25c0dd0628eb9de549a706.png"></div><br>  Let's look at <code>*</code> .  An asterisk can be 0 or more repetitions of the pattern.  To realize this, we need one connection to point directly to the next state, and one to go back to the current state through <code>A</code>  <code>A*</code> will look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c23/da8/080/c23da80801cc14637a7234ec01d21eb0.png"></div><br>  For <code>+</code> we will use a little trick.  <code>a+</code> is just <code>aa*</code> .  In sum, <code>Plus(A)</code> can be rewritten as <code>Concat(A, Repeat(A))</code> .  We will do so, instead of developing a special pattern for this case.  I had a special reason for including in language <code>+</code> : I wanted to show how other, more complex elements of regular expressions that I missed can often be expressed in categories of our language. <br><br><h2>  Conversion in practice </h2><br>  Now that we have a theoretical plan, let's see how to implement it in code.  We will create a mutable graph to hold our tree.  Although I prefer immutability, creating immutable graphs is annoying in its complexity, but I'm lazy. <br><br>  If we try to reduce the above schemes to basic components, then we end up with three types of components: arrows that consume input data, a state of coincidence, and one state that splits into two states.  I know it looks a little weird, and potentially unfinished.  You just have to trust me that such a solution will lead to the purest code.  Here are our three classes of NFA components: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consume</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val c: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Char</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val out: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">State</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Split</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val out1: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">State</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val out2: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">State</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Match</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span></code> </pre> <br>  <em>Note: I made the <code>Match</code> <a href="http://stackoverflow.com/questions/2312881/what-is-the-difference-between-scalas-case-class-and-class"><code>case-</code></a> instead of the regular class.</em>  <em>Case classes in Scala give the class a convenient default characteristics.</em>  <em>I used it because it gives equivalence based on values.</em>  <em>This makes all <code>Match</code> objects equivalent ‚Äî a useful property.</em>  <em>For other types of NFA components, we need link equivalency.</em> <br><br>  Our code will recursively bypass the syntax tree, saving the <code>andThen</code> object as a parameter.  <code>andThen</code> is what we will attach to the free exits of our expression.  It is required because in an arbitrary branch of the syntactic tree there is not enough context for what will go on - <code>andThen</code> allows us to transfer this context down during a recursive walk.  It also provides us with an easy way to add a <code>Match</code> state. <br><br>  When it comes to handling <code>Repeat</code> , we have a problem.  <code>andThen</code> for <code>Repeat</code> itself is a splitting operator.  To deal with this problem, we introduce a placeholder, which will allow you to bind it later.  We will present the placeholder as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Placeholder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var pointingTo: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">State</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span></code> </pre> <br>  <code>var</code> in <code>Placeholder</code> means that <code>pointingTo</code> changeable.  This is an isolated part of the variability, allowing us to conveniently create a cyclic graph.  All other members are unchanged. <br><br>  To begin with, <code>andThen</code> is <code>Match()</code> .  This means that we will create a state machine corresponding to our Regex, which can then go to the <code>Match</code> state without consuming incoming data.  The code will be short, but saturated: <br><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">regexToNFA</span></span></span></span>(regex: <span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>): <span class="hljs-type"><span class="hljs-type">State</span></span> = regexToNFA(regex, <span class="hljs-type"><span class="hljs-type">Match</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">regexToNFA</span></span></span></span>(regex: <span class="hljs-type"><span class="hljs-type">RegexExpr</span></span>, andThen: <span class="hljs-type"><span class="hljs-type">State</span></span>): <span class="hljs-type"><span class="hljs-type">State</span></span> = { regex <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Literal</span></span>(c) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Consume</span></span>(c, andThen) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Concat</span></span>(first, second) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//  first  NFA.  "" //    second  NFA. regexToNFA(first, regexToNFA(second, andThen)) } case Or(l, r) =&gt; new Split( regexToNFA(l, andThen), regexToNFA(r, andThen) ) case Repeat(r) =&gt; val placeholder = new Placeholder(null) val split = new Split( //     , //   -   r regexToNFA(r, placeholder), andThen ) placeholder.pointingTo = split placeholder case Plus(r) =&gt; regexToNFA(Concat(r, Repeat(r)), andThen) } } }</span></span></code> </pre> <br>  And that is all!  The ratio of sentences to lines of code in this part is quite high - each line encodes a lot of information, but it all comes down to the transformations discussed in the previous part.  It should be explained - I did not just sit down and wrote the code in this form;  the brevity and functionality of the code are the result of several iterations of working with data structures and an algorithm.  Clean code is hard to write. <br><br>  During the debugging process, I wrote a short script to generate <code>dot</code> files from NFA, so that you can see the generated NFA for debugging purposes.  It is worth noting that the NFA generated by this code contains many unnecessary transitions and states.  When writing an article, I tried to make the code as simple as possible, even at the cost of performance.  Here are some examples of simple regular expressions: <br><br> <code>(..)*</code> <br> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/d13/34b/4a5d1334baaf257a26d1c8c3a72bdf2f.png"></div><br> <code>ab</code> <br> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/0a1/645/3e10a1645ef36e320b948174c62a088d.png"></div><br> <code>a|b</code> <br> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/696/4b3/dde/6964b3dded0097b61ce753cc062f04dd.png"></div><br>  Now that we have NFA (the hardest part), we just have to analyze it (the part is easier). <br><br><h2>  Part 3: NFA Analysis </h2><br><h3>  NFA, DFA and regular expressions </h3><br>  In the second part, we said that there are two types of finite automata: deterministic and non-deterministic.  They have one key difference: a non-deterministic finite-state machine can have several paths to a single node for a single token;  in addition, paths can be followed without receiving input data.  In terms of expressive capabilities (often called ‚Äúpower‚Äù), NFA, DFA, and regular expressions are similar.  This means that if you can express a rule or pattern (for example, strings of even length) with NFA, you can also express it through DFA or a regular expression.  Let's first look at the regular expression <code>abc*</code> , expressed as DFA: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/fdf/958/fc0fdf958c106f7ba1d031a97ff43687.png"></div><br>  DFA analysis is straightforward - we simply move from state to state, consuming a line of input data.  If we finish consuming the input data in a match state, then we have a match, otherwise it does not.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, our state machine is NFA. </font><font style="vertical-align: inherit;">Generated by our NFA code for this regular expression looks like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/1be/d8d/38b1bed8d542d875061628a7a01249f3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that there are several unlabeled edges that can be walked without consuming a symbol. </font><font style="vertical-align: inherit;">How to track them effectively? </font><font style="vertical-align: inherit;">The answer is surprisingly simple: instead of tracking only one possible state, you need to keep a list of states in which the engine is currently located. </font><font style="vertical-align: inherit;">When a branching occurs, one should follow both ways (turning one state into two). </font><font style="vertical-align: inherit;">If the state has no valid transition for the current input, then it is removed from the list.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you need to consider two fine points: avoidance in the graph of infinite cycles and correct processing of transitions without input data. </font><font style="vertical-align: inherit;">When analyzing a given state, we first go to all states to list all possible states reachable from our current state, if we do not consume more input data. </font><font style="vertical-align: inherit;">At this stage, you need to be careful and keep "many visited" to avoid endless looping in the graph. </font><font style="vertical-align: inherit;">Having listed all these states, we consume the next token of input data, either moving to these states or removing them from the list.</font></font><br><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFAEvaluator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span></span>(nfa: <span class="hljs-type"><span class="hljs-type">State</span></span>, input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> = evaluate(<span class="hljs-type"><span class="hljs-type">Set</span></span>(nfa), input) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span></span>(nfas: <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>], input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> = { input <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> =&gt; evaluateStates(nfas, <span class="hljs-type"><span class="hljs-type">None</span></span>).exists(_ == <span class="hljs-type"><span class="hljs-type">Match</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> string =&gt; evaluate( evaluateStates(nfas, input.headOption), string.tail ) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluateStates</span></span></span></span>(nfas: <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>], input: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Char</span></span>]): <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> visitedStates = mutable.<span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>]() nfas.flatMap { state =&gt; evaluateState(state, input, visitedStates) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluateState</span></span></span></span>(currentState: <span class="hljs-type"><span class="hljs-type">State</span></span>, input: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Char</span></span>], visitedStates: mutable.<span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>]): <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">State</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visitedStates contains currentState) { <span class="hljs-type"><span class="hljs-type">Set</span></span>() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { visitedStates.add(currentState) currentState <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> placeholder: <span class="hljs-type"><span class="hljs-type">Placeholder</span></span> =&gt; evaluateState( placeholder.pointingTo, input, visitedStates ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> consume: <span class="hljs-type"><span class="hljs-type">Consume</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">Some</span></span>(consume.c) == input || consume.c == '.') { <span class="hljs-type"><span class="hljs-type">Set</span></span>(consume.out) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Set</span></span>() } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s: <span class="hljs-type"><span class="hljs-type">Split</span></span> =&gt; evaluateState(s.out1, input, visitedStates) ++ evaluateState(s.out2, input, visitedStates) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m: <span class="hljs-type"><span class="hljs-type">Match</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.isDefined) <span class="hljs-type"><span class="hljs-type">Set</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Set</span></span>(<span class="hljs-type"><span class="hljs-type">Match</span></span>()) } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And that is all! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finish the case </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are done with all the important code, but the API is not as clean as we would like. </font><font style="vertical-align: inherit;">Now we need to create a single call user interface to call our regular expression engine. </font><font style="vertical-align: inherit;">We will also add the ability to match the pattern anywhere in the line with a share of syntactic sugar.</font></font><br><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Regex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fullMatch</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>, pattern: <span class="hljs-type"><span class="hljs-type">String</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsed = <span class="hljs-type"><span class="hljs-type">RegexParser</span></span>(pattern).getOrElse( <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">RuntimeException</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed to parse regex"</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nfa = <span class="hljs-type"><span class="hljs-type">NFA</span></span>.regexToNFA(parsed) <span class="hljs-type"><span class="hljs-type">NFAEvaluator</span></span>.evaluate(nfa, input) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchAnywhere</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>, pattern: <span class="hljs-type"><span class="hljs-type">String</span></span>) = fullMatch(input, <span class="hljs-string"><span class="hljs-string">".*"</span></span> + pattern + <span class="hljs-string"><span class="hljs-string">".*"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is how the code is used: </font></font><br><br><pre> <code class="scala hljs"> <span class="hljs-type"><span class="hljs-type">Regex</span></span>.fullMatch(<span class="hljs-string"><span class="hljs-string">"aaaaab"</span></span>, <span class="hljs-string"><span class="hljs-string">"a*b"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// True Regex.fullMatch("aaaabc", "a*b") // False Regex.matchAnywhere("abcde", "cde") // True</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on this we finish. </font><font style="vertical-align: inherit;">Now we have a partially functional regex implementation with just 106 lines. </font><font style="vertical-align: inherit;">You can add some more details, but I decided not to increase the complexity without increasing the code value:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Character classes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extract values </font></font></li><li> <code>?</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escape characters </font></font></li><li>  And much more. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope this simple implementation will help you understand what is happening inside the regular expression engine! </font><font style="vertical-align: inherit;">It is worth mentioning that the performance of the interpreter is disgusting, truly awful. </font><font style="vertical-align: inherit;">Perhaps in one of the future posts I will examine the reasons for this and discuss ways to optimize ...</font></font></div><p>Source: <a href="https://habr.com/ru/post/348890/">https://habr.com/ru/post/348890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348878/index.html">New online software for developers</a></li>
<li><a href="../348880/index.html">Use for simple tests inheritance, polymorphism and patterns? Why not‚Ä¶</a></li>
<li><a href="../348882/index.html">Market as a stereotype regarding segment, need, supply</a></li>
<li><a href="../348884/index.html">KODOS: stay alive</a></li>
<li><a href="../348886/index.html">See the world through the eyes of animals: new horizons of eytreking</a></li>
<li><a href="../348892/index.html">Information Security Recommendations for Small and Medium Business (SMB)</a></li>
<li><a href="../348894/index.html">Guide to background work in Android. Part 1</a></li>
<li><a href="../348896/index.html">Cradle: Rave. Two hackathons + conference, with emphasis on Big Data & ML, Blockchain, Quantum Computing, DevOps and Mobile</a></li>
<li><a href="../348898/index.html">Slack is the opposite of organizational memory.</a></li>
<li><a href="../348900/index.html">Blockchain and medicine: 4 startups in the field of health care that are worth following</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>