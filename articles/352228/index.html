<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity3D animated spacecraft shield effect</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! I want to tell how to make a shader for drawing a spacecraft shield in Unity3D. 

 Here is such 

 The article is designed for beginners, but...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity3D animated spacecraft shield effect</h1><div class="post__text post__text-html js-mediator-article">  Hi Habr!  I want to tell how to make a shader for drawing a spacecraft shield in Unity3D. <br><br><div class="spoiler">  <b class="spoiler_title">Here is such</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  The article is designed for beginners, but I will be glad if experienced shader writers will read and criticize the article. <br><br>  Interested please under the cat.  (Caution! Inside are heavy pictures and gifs). <br><a name="habracut"></a><br>  The article is written as a set of instructions with explanations, even a complete beginner will be able to execute them and get a ready-made shader, but in order to understand what is happening, it is advisable to navigate in basic terms: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Shader </li><li>  Vertex shader </li><li>  Fragment / Pixel Shader </li><li>  UV coordinates </li></ul><br>  The effect consists of 3 main components: <br><br><ul><li>  Base translucent shader using texture as transparency map and color as shield color </li><li>  Fresnel effect </li><li>  Shield Reaction </li><li>  Animation </li></ul><br>  Let us add these components to the shader in order, and by the end of the article we will get the effect as on the KDPV. <br><br><h2>  Basic shader </h2><br>  Let's start with the standard Unity3D shader: <br><br><div class="spoiler">  <b class="spoiler_title">Source Code Standard Unlit Shader</b> <div class="spoiler_text"><pre><code class="hljs pgsql">Shader "Unlit/NewUnlitShader" { Properties { _MainTex ("Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> #pragma multi_compile_fog #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; UNITY_FOG_COORDS(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; }; sampler2D _MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); // apply fog UNITY_APPLY_FOG(i.fogCoord, col); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; } ENDCG } } }</code> </pre> <br></div></div><br>  Prepare it for our purposes. <br><br><ol><li>  Rename it to Shields / Transparent. For this, replace the string <code>Shader "Unlit/NewUnlitShader"</code> with <code>Shader "Shields/Transparent"</code> </li><li>  Translucent elements in the unit are drawn in a separate queue and in a special way. To do this, you need to tell the unit that the translucent shader replacing <code>Tags { "RenderType"="Opaque" }</code> with <code>Tags { "Queue"="Transparent" "RenderType"="Transparent" }</code> <br>  To draw translucent elements, you need to set a special blending mode; to do this, after <code>Tags { "Queue"="Transparent" "RenderType"="Transparent" }</code> add the line <code>Blend SrcAlpha OneMinusSrcAlpha</code> . <br><br>  It is also necessary to disable the recording in the Z-Buffer - it is used to sort the opaque objects, and for rendering translucent objects will only interfere.  To do this, add the line <br><br><pre> <code class="hljs pgsql">ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span></code> </pre> <br>  after <br><br><pre> <code class="hljs objectivec">Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> }</code> </pre> <br></li><li>  The shield effect will not be used together with the fog effect built into the unit, so remove all references to it from the shader - delete the lines <br><br><pre> <code class="hljs lisp">UNITY_FOG_COORDS(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><pre> <code class="hljs lisp">UNITY_TRANSFER_FOG(<span class="hljs-name"><span class="hljs-name">o</span></span>,o.vertex)</code> </pre> <br><pre> <code class="hljs lisp">UNITY_APPLY_FOG(<span class="hljs-name"><span class="hljs-name">i</span></span>.fogCoord, col)</code> </pre> </li></ol><br>  We got a basic unlit translucent shader.  Now it is necessary to make a shader from it, which uses the texture as a translucency mask and the color specified by the user as the pixel color: <br><br><ol><li>  Now the shader has only one input parameter - the texture, we add color as the input parameter, and the texture parameter will be renamed to Transparency Mask.  In the unit, the input parameters for the shader are set inside the Properties block, now it looks like this: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_MainTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre><br>  Add an input color parameter and rename the texture: <br><br><pre> <code class="hljs objectivec">Properties { _ShieldColor(<span class="hljs-string"><span class="hljs-string">"Shield Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Transparency Mask"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre><br>  In order for the input parameters specified in the Properties block to be available in the vertex and fragment shaders, they must be declared as variables inside the shader pass ‚Äî insert the string <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> _ShieldColor;</code> </pre> <br>  before the line <br><br><pre> <code class="hljs lisp">v2f vert (<span class="hljs-name"><span class="hljs-name">appdata</span></span> v)</code> </pre> <br>  More information about the transfer of parameters to the shader can be read in the <a href="https://docs.unity3d.com/ru/current/Manual/SL-Properties.html">official documentation</a> . </li><li>  The color of a single pixel is determined by the return value of the fragment shader, <br>  Now it looks like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v2f i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { <span class="hljs-comment"><span class="hljs-comment">// sample the texture fixed4 col = tex2D(_MainTex, i.uv); return col; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">What is v2f</b> <div class="spoiler_text">  Here <code>v2f</code> is the return value of the vertex shaders interpolated for the given pixel on the screen <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class"> </span></span>{ float2 uv : <span class="hljs-type"><span class="hljs-type">TEXCOORD0</span></span>; float4 vertex : <span class="hljs-type"><span class="hljs-type">SV_POSITION</span></span>; };</code> </pre><br>  <code>uv</code> - pixel texture coordinate <br>  <code>vertext</code> - pixel coordinate in screen coordinates <br></div></div><br>  This simple function takes the color from the texture according to the texture coordinates that came from the vertex shader and returns it as the color of the pixel.  We also need the texture color to be used as a transparency mask, and the color was taken from the shader parameters. <br><br>  Do the following: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v2f i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { <span class="hljs-comment"><span class="hljs-comment">// sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); return fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, transparencyMask.r); }</span></span></code> </pre><br>  That is, we sample the texture as before, but instead of returning its color directly, we return the color as <code>_ShieldColor</code> with the alpha channel taken from the red color of the texture. <br></li><li>  Add another parameter - the intensity factor of the shield - in order to be able to adjust the translucency of the shield without changing the texture. <br><br>  I suggest the reader to do it yourself or look under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Properties { _ShieldIntensity("Shield Intensity", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _ShieldColor("Shield Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Transparency Mask", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} }</code> </pre><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _ShieldIntensity; <span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v2f i</span></span></span><span class="hljs-function">) : SV_Target</span></span> { <span class="hljs-comment"><span class="hljs-comment">// sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); return fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, _ShieldIntensity * transparencyMask.r); }</span></span></code> </pre><br></div></div><br></li></ol><br>  You should have something like this: <br><br><img src="https://habrastorage.org/webt/sh/bo/wn/shbownkuwgivgfitmql8imkbzfg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Hereinafter I use this seamless noise texture.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/uf/_c/gduf_cntas3du6bbr3qxk6wmgms.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Full listing of the resulting shader</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "Shields/Transparent" { Properties { _ShieldIntensity("Shield Intensity", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _ShieldColor("Shield Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Transparency Mask", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "Queue"="Transparent" "RenderType"="Transparent" } ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float3 normal: NORMAL; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; }; sampler2D _MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> _MainTex_ST; <span class="hljs-type"><span class="hljs-type">float4</span></span> _ShieldColor; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } <span class="hljs-type"><span class="hljs-type">float</span></span> _ShieldIntensity; fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, _ShieldIntensity * transparencyMask.r); } ENDCG } } }</code> </pre><br></div></div><br>  While not very good, but this is the base on which the whole effect will be built. <br><br><h2>  Fresnel effect </h2><br>  In general, the Fresnel effect is the effect of increasing the intensity of the reflected beam with increasing its angle of incidence.  But I use the formulas used in the calculation of this effect to set the dependence of the intensity of the glow of the shield on the viewing angle. <br><br>  We start implementation using the approximate formula from cg tutorial on nvidia <br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/512/ab5/2cb512ab52e4a6a7c0a08f6d981c5ccf.jpg"><br>  where I is the direction from the camera to the top, N is the normal of the surface at the point of incidence <br><br><ol><li>  First, copy the shader to a new file and rename it to Shields / Fresnel to have a history of changes. </li><li>  As you can see from the formula, we will need 3 new parameters for the <code>Bias, <br> Scale, Power</code> shader <code>Bias, <br> Scale, Power</code> <code>Bias, <br> Scale, Power</code>  <code>Bias, <br> Scale, Power</code> .  I expect that the reader has already learned how to add parameters to the shader and will not provide detailed instructions on how to do this.  In case of difficulties, you can always see the full code at the end of the section. </li><li>  Calculate I and N in the vertex shader.  The vertex shader in our shader is the function <code>v2f vert (appdata v)</code> return value is the <code>v2f</code> structure described earlier, and <code>appdata</code> is the vertex parameters taken from the mesh. <br><br><div class="spoiler">  <b class="spoiler_title">What is appdata</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> </span></span>{ float4 vertex : <span class="hljs-type"><span class="hljs-type">POSITION</span></span>; float3 normal: <span class="hljs-type"><span class="hljs-type">NORMAL</span></span>; float2 uv : <span class="hljs-type"><span class="hljs-type">TEXCOORD0</span></span>; };</code> </pre><br>  <code>vertex</code> - <code>vertex</code> coordinates in local coordinates <br>  <code>normal</code> - the surface normal specified for this vertex <br>  <code>uv</code> - vertex texture coordinates <br></div></div><br>  I - the direction from the camera to the top in world coordinates - can be calculated as the difference of the world coordinates of the top and the world coordinates of the camera.  In Unity shaders, the transition matrix from local to world coordinates is available in the <code>unity_ObjectToWorld</code> variable, and the world camera coordinates in the <code>_WorldSpaceCameraPos</code> variable.  Knowing this, you can calculate I with the following lines in the vertex shader code: <br><br><pre> <code class="hljs lisp">float4 worldVertex = mul(<span class="hljs-name"><span class="hljs-name">unity_ObjectToWorld</span></span>, v.vertex)<span class="hljs-comment"><span class="hljs-comment">; float3 I = normalize(worldVertex - _WorldSpaceCameraPos.xyz);</span></span></code> </pre><br>  N is the surface normal in world coordinates - it is even easier to calculate: <br><br><pre> <code class="hljs lisp"> float3 normWorld = normalize(<span class="hljs-name"><span class="hljs-name">mul</span></span>(<span class="hljs-name"><span class="hljs-name">unity_ObjectToWorld</span></span>, v.normal))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br></li><li>  Now you can calculate the shield opacity using the Fresnel effect formula: <br><br><pre> <code class="hljs lisp">float fresnel = _Bias + _Scale * pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + dot(<span class="hljs-name"><span class="hljs-name">I</span></span>, normWorld), _Power)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  You may notice that the value of fresnel with certain values ‚Äã‚Äãof variables may be less than 0, this will give color artifacts when drawing.  Restrict the value of a variable to the interval [0; 1] using the <code>saturate</code> function: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fresnel = saturate(_Bias + _Scale * <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(I, normWorld), _Power));</code> </pre> <br></li><li>  It remains only to transfer this value to the pixel shader.  To do this, add the intensity field to the v2f structure: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class"> {</span></span> float2 uv : TEXCOORD0; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity : COLOR0; float4 vertex : SV_POSITION; };</code> </pre><br>  ( <code>COLOR0</code> is semantics, the explanation of what it is is beyond the scope of this article, those interested can read about semantics in hlsl). <br><br>  Now we can fill this field in the vertex shader and use it in the fragment: <br><br><pre> <code class="hljs mel">v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); float4 worldVertex = mul(unity_ObjectToWorld, v.vertex); float3 normWorld = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(mul(unity_ObjectToWorld, v.normal)); float3 I = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(worldVertex - _WorldSpaceCameraPos.xyz); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fresnel = saturate(_Bias + _Scale * <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(I, normWorld), _Power)); o.intensity = fresnel; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _ShieldIntensity; fixed4 frag (v2f i) : SV_Target { <span class="hljs-comment"><span class="hljs-comment">// sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); return fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, (_ShieldIntensity + i.intensity) * transparencyMask.r); }</span></span></code> </pre><br>  You may notice that now you can add <code>_ShieldIntensity</code> and <code>i.intensity</code> even in the vertex shader, so <code>i.intensity</code> do it. <br></li></ol><br>  Done!  After playing with the parameters of the Fresnel equation, you can get this picture <br><br><img src="https://habrastorage.org/webt/kl/mp/d4/klmpd4v5hgxa7r8agdocyjwzbjm.png"><br><br><div class="spoiler">  <b class="spoiler_title">My parameters</b> <div class="spoiler_text">  Bias = -0.5, Scale = 1, Power = 1 </div></div><br><div class="spoiler">  <b class="spoiler_title">Full listing of the Fresnel effect shield</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "Shields/Fresnel" { Properties { _ShieldIntensity("Shield Intensity", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _ShieldColor("Shield Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Transparency Mask", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Bias("Bias", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _Scale("Scale", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _Power("Power", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> } SubShader { Tags { "Queue"="Transparent" "RenderType"="Transparent" } ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float3 normal: NORMAL; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float</span></span> intensity : COLOR0; <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; }; sampler2D _MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> _MainTex_ST; <span class="hljs-type"><span class="hljs-type">float4</span></span> _ShieldColor; <span class="hljs-type"><span class="hljs-type">float</span></span> _ShieldIntensity; <span class="hljs-type"><span class="hljs-type">float</span></span> _Bias; <span class="hljs-type"><span class="hljs-type">float</span></span> _Scale; <span class="hljs-type"><span class="hljs-type">float</span></span> _Power; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); <span class="hljs-type"><span class="hljs-type">float4</span></span> worldVertex = mul(unity_ObjectToWorld, v.vertex); float3 normWorld = normalize(mul(unity_ObjectToWorld, v.normal)); float3 I = normalize(worldVertex - _WorldSpaceCameraPos.xyz); <span class="hljs-type"><span class="hljs-type">float</span></span> fresnel = saturate(_Bias + _Scale * pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> + dot(I, normWorld), _Power)); o.intensity = fresnel + _ShieldIntensity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, i.intensity * transparencyMask.r); } ENDCG } } }</code> </pre><br></div></div><br>  Now you can go to the most interesting - display hits on the shield. <br><br><h2>  Drawing hit </h2><br>  I will describe just one of the possible response options to the hit; it is fairly simple and cheap in performance; it looks quite nice and, unlike the simplest ones, gives a nice picture when the hits are close. <br><br><ol><li>  To implement the effect, the shader needs to somehow find out at what point the hit occurred and at what time.  The script on the GameObject of the shield will deal with the transfer of these arguments, and since # scripting is not the subject of this article, I will simply provide the source codes of the scripts: <br><br><div class="spoiler">  <b class="spoiler_title">Listing script for an object with a shield</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ShieldHitter</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] hitInfoId = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_WorldHitPoint0"</span></span>), Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_WorldHitPoint1"</span></span>), Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_WorldHitPoint2"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] hitTimeId = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_HitTime0"</span></span>), Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_HitTime1"</span></span>), Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_HitTime2"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Material material; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.gameObject.GetComponent&lt;MeshRenderer&gt;().material; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastHit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point, Vector3 direction</span></span></span><span class="hljs-function">)</span></span> { material.SetVector(hitInfoId[lastHit], point); material.SetFloat(hitTimeId[lastHit], Time.timeSinceLevelLoad); lastHit++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastHit &gt;= hitInfoId.Length) lastHit = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision collision</span></span></span><span class="hljs-function">)</span></span> { OnHit(collision.contacts[<span class="hljs-number"><span class="hljs-number">0</span></span>].point, Vector3.one); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Listing script for camera</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [ExecuteInEditMode] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CameraControls : MonoBehaviour { private const <span class="hljs-type"><span class="hljs-type">int</span></span> minDistance = <span class="hljs-number"><span class="hljs-number">25</span></span>; private const <span class="hljs-type"><span class="hljs-type">int</span></span> maxDistance = <span class="hljs-number"><span class="hljs-number">25</span></span>; private const <span class="hljs-type"><span class="hljs-type">float</span></span> minTheta = <span class="hljs-number"><span class="hljs-number">0.01</span></span>f; private const <span class="hljs-type"><span class="hljs-type">float</span></span> maxTheta = Mathf.PI - <span class="hljs-number"><span class="hljs-number">0.01</span></span>f; private const <span class="hljs-type"><span class="hljs-type">float</span></span> minPhi = <span class="hljs-number"><span class="hljs-number">0</span></span>; private const <span class="hljs-type"><span class="hljs-type">float</span></span> maxPhi = <span class="hljs-number"><span class="hljs-number">2</span></span> * Mathf.PI ; [SerializeField] private <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span> _target; [SerializeField] private Camera _camera; [SerializeField] [Range(minDistance, maxDistance)] private <span class="hljs-type"><span class="hljs-type">float</span></span> _distance = <span class="hljs-number"><span class="hljs-number">25</span></span>; [SerializeField] [Range(minTheta, maxTheta)] private <span class="hljs-type"><span class="hljs-type">float</span></span> _theta = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField] [Range(minPhi, maxPhi)] private <span class="hljs-type"><span class="hljs-type">float</span></span> _phi = <span class="hljs-number"><span class="hljs-number">2.5</span></span>f; [SerializeField] private <span class="hljs-type"><span class="hljs-type">float</span></span> _angleSpeed = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; [SerializeField] private <span class="hljs-type"><span class="hljs-type">float</span></span> _distanceSpeed = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; // <span class="hljs-keyword"><span class="hljs-keyword">Update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> once per frame <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Update</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_target == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || _camera == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isPlaying) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.Q)) { _distance += _distanceSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.E)) { _distance -= _distanceSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } Mathf.Clamp(_distance, minDistance, maxDistance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.A)) { _phi += _angleSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.D)) { _phi -= _angleSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } _phi = _phi % (maxPhi); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.S)) { _theta += _angleSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetKey(KeyCode.W)) { _theta -= _angleSpeed * <span class="hljs-type"><span class="hljs-type">Time</span></span>.deltaTime; } _theta = Mathf.Clamp(_theta, minTheta, maxTheta); Vector3 newCoords = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector3 { x = _distance * Mathf.Sin(_theta) * Mathf.Cos(_phi), z = _distance * Mathf.Sin(_theta) * Mathf.Sin(_phi), y = _distance * Mathf.Cos(_theta) }; this.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.position = newCoords + _target.position; this.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.LookAt(_target); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { Ray ray = _camera.ScreenPointToRay(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.mousePosition); RaycastHit hit; var isHit = Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isHit) { ShieldHitter <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = hit.collider.gameObject.GetComponent&lt;ShieldHitter&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>.Log(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>.OnHit(hit.point, ray.direction); } } } } } }</code> </pre><br></div></div><br></li><li>  Like last time, save the shader under the new name Shields / FresnelWithHits </li><li>  The idea is to calculate the perturbation of the shield from nearby hits at each point of the shield, and the earlier the hit occurs, the less its influence on the shield perturbation. <br><br>  I chose the following formula: <p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>&amp;#x2212;</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="42.075ex" height="2.66ex" viewBox="0 -832 18115.4 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-69" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-6E" x="345" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-74" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-65" x="1307" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-6E" x="1774" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-73" x="2374" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-69" x="2844" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-74" x="3189" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-79" x="3551" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-3D" x="4326" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-28" x="5382" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-31" x="5772" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-2212" x="6494" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-74" x="7495" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-69" x="7857" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-6D" x="8202" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-65" x="9081" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-29" x="9547" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-2217" x="10159" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-28" x="10881" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-31" x="11271" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-2F" x="11771" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-64" x="12272" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-69" x="12795" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-73" x="13141" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-74" x="13610" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-61" x="13972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-6E" x="14501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-63" x="15102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMATHI-65" x="15535" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-2212" x="16224" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-31" x="17225" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/352228/&amp;xid=17259,1500004,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPLkAYqvtMW6dAGvKQ-pG2Gn5rdg#MJMAIN-29" x="17725" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">)</mo><mo>‚àó</mo><mo stretchy="false">(</mo><mn>1</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> intensity = (1 - time) * (1 / distance - 1) </script></p><br>  Where: <br>  <code>distance</code> - the fraction of the distance to the point of contact with the maximum, [0, 1] <br>  <code>time</code> - the fraction of the lifetime of the maximum, [0, 1] <br>  Thus, the intensity is inversely proportional to the distance to the collision point, <br>  proportional to the time remaining until the end of the action of the hit, and also equal to 0 with a distance equal to or greater than the maximum and with a remaining time equal to 0. <br><br>  I would like to find a function that would satisfy these conditions without the need to limit the range of time and distance, but this one is all that I have. <br></li><li>  Drawing effects of hit in shaders inevitably imposes restrictions on the number of simultaneously processed hits, for example, I chose 3 simultaneously displayed hits.  Add the WorldHitPoint0, WorldHitPoint1, WorldHitPoint2, HitTime0, HitTime1, HitTime2 input parameters to the shader - a pair for each simultaneously processed hit.  We will also need the MaxDistance parameters - the maximum distance to which the shield perturbation from falling extends, and HitDuration - the duration of the shield perturbation from falling. </li><li>  For each hit we will calculate in the vertex shader time and distance <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t0 = saturate((_Time.y - _HitTime0) / _HitDuration); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d0 = saturate(distance(worldVertex.xyz, _WorldHitPoint0.xyz) / (_MaxDistance)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = saturate((_Time.y - _HitTime1) / _HitDuration); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d1 = saturate(distance(worldVertex.xyz, _WorldHitPoint1.xyz) / (_MaxDistance)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = saturate((_Time.y - _HitTime2) / _HitDuration); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = saturate(distance(worldVertex.xyz, _WorldHitPoint2.xyz) / (_MaxDistance));</code> </pre><br>  and calculate the total intensity of hits by the formula: <br><br><pre> <code class="hljs lisp">float hitIntensity = (<span class="hljs-number"><span class="hljs-number">1</span></span> - t0) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-name"><span class="hljs-name">d0</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - t1) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-name"><span class="hljs-name">d1</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - t2) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-name"><span class="hljs-name">d2</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  It remains only to add the intensity of the shield from hits with the intensity of other effects: <br><br><pre> <code class="hljs">o.intensity = fresnel + _ShieldIntensity + hitIntensity;</code> </pre><br></li><li>  We adjust the material, set the correct values ‚Äã‚Äãof the distance and voila: <br><br><img src="https://habrastorage.org/webt/1i/ci/yh/1iciyht3qee8k_ninveb-8ofbv0.gif"><br><br>  Already good enough, right?  But there is one problem.  The hits on the back of the shield are not visible.  The reason for this is that, by default, polygons, the normal of which is directed from the camera, are not drawn.  To force the graphics engine to draw them, you need to add the line <code>Cull off</code> after <code>ZWrite Off</code> .  But here too the problem awaits us: <br>  The Fresnel effect, implemented in the last section, highlights all the polygons looking from the camera - you'll have to change the formula to <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(I, normWorld); fresnel = saturate(_Bias + _Scale * <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dt * dt, _Power));</code> </pre><br>  Since the original formula is already an approximation, the use of a square does not have a significant effect on the result (it can be corrected by other parameters) and allows you not to add an expensive branch operator and not to use expensive sqrt. <br><br>  Run, check and: <br><br><img src="https://habrastorage.org/webt/wf/rj/yj/wfrjyjyxeu0zjhxlmgc8abqb95c.gif"><br><br>  Now everything is very good. <br></li><li>  The final touch remains: to give the effect of ‚Äúvividness‚Äù, you can add the current time to the texture coordinates of the noise to create the effect of the movement of the shield on the sphere. <br><br><pre> <code class="hljs">o.uv = TRANSFORM_TEX(v.uv, _MainTex) + _Time.x / 6;</code> </pre><br></li></ol><br>  Final result: <br><br><img src="https://habrastorage.org/webt/dw/pj/u_/dwpju_8jezttudsjsihpot_m1la.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Listing the final version of the shader</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "Shields/FresnelWithHits" { Properties { _ShieldIntensity("Shield Intensity", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _ShieldColor("Shield Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Transparency Mask", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Bias("Bias", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _Scale("Scale", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _Power("Power", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">1.0</span></span> _WorldHitPoint0("Hit Point 0", Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) _WorldHitTime0("Hit Time 0", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">-1000</span></span> _WorldHitPoint1("Hit Point 1", Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) _WorldHitTime1("Hit Time 1", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">-1000</span></span> _WorldHitPoint2("Hit Point 2", Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) _WorldHitTime2("Hit Time 2", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">-1000</span></span> _HitDuration("Hit Duration", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">10.0</span></span> _MaxDistance("MaxDistance", <span class="hljs-type"><span class="hljs-type">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> } SubShader { Tags { "Queue" = "Transparent" "RenderType" = "Transparent" } ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float3 normal: NORMAL; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float</span></span> intensity : COLOR0; <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; }; sampler2D _MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> _MainTex_ST; <span class="hljs-type"><span class="hljs-type">float4</span></span> _ShieldColor; <span class="hljs-type"><span class="hljs-type">float</span></span> _ShieldIntensity; <span class="hljs-type"><span class="hljs-type">float</span></span> _Bias; <span class="hljs-type"><span class="hljs-type">float</span></span> _Scale; <span class="hljs-type"><span class="hljs-type">float</span></span> _Power; <span class="hljs-type"><span class="hljs-type">float</span></span> _MaxDistance; <span class="hljs-type"><span class="hljs-type">float</span></span> _HitDuration; <span class="hljs-type"><span class="hljs-type">float</span></span> _HitTime0; <span class="hljs-type"><span class="hljs-type">float4</span></span> _WorldHitPoint0; <span class="hljs-type"><span class="hljs-type">float</span></span> _HitTime1; <span class="hljs-type"><span class="hljs-type">float4</span></span> _WorldHitPoint1; <span class="hljs-type"><span class="hljs-type">float</span></span> _HitTime2; <span class="hljs-type"><span class="hljs-type">float4</span></span> _WorldHitPoint2; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex) + _Time.x / <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> worldVertex = mul(unity_ObjectToWorld, v.vertex); float3 normWorld = normalize(mul(unity_ObjectToWorld, v.normal)); float3 I = normalize(worldVertex - _WorldSpaceCameraPos.xyz); <span class="hljs-type"><span class="hljs-type">float</span></span> fresnel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> dt = dot(I, normWorld); fresnel = saturate(_Bias + _Scale * pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dt * dt, _Power)); <span class="hljs-type"><span class="hljs-type">float</span></span> t0 = saturate((_Time.y - _HitTime0) / _HitDuration); <span class="hljs-type"><span class="hljs-type">float</span></span> d0 = saturate(distance(worldVertex.xyz, _WorldHitPoint0.xyz) / (_MaxDistance)); <span class="hljs-type"><span class="hljs-type">float</span></span> t1 = saturate((_Time.y - _HitTime1) / _HitDuration); <span class="hljs-type"><span class="hljs-type">float</span></span> d1 = saturate(distance(worldVertex.xyz, _WorldHitPoint1.xyz) / (_MaxDistance)); <span class="hljs-type"><span class="hljs-type">float</span></span> t2 = saturate((_Time.y - _HitTime2) / _HitDuration); <span class="hljs-type"><span class="hljs-type">float</span></span> d2 = saturate(distance(worldVertex.xyz, _WorldHitPoint2.xyz) / (_MaxDistance)); <span class="hljs-type"><span class="hljs-type">float</span></span> hitIntensity = (<span class="hljs-number"><span class="hljs-number">1</span></span> - t0) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (d0)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - t1) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (d1)) - <span class="hljs-number"><span class="hljs-number">1</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - t2) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> / (d2)) - <span class="hljs-number"><span class="hljs-number">1</span></span>); o.intensity = fresnel + _ShieldIntensity + hitIntensity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 transparencyMask = tex2D(_MainTex, i.uv); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fixed4(_ShieldColor.r, _ShieldColor.g, _ShieldColor.b, saturate(i.intensity * transparencyMask.r)); } ENDCG } } }</code> </pre><br></div></div><br>  Exactly what is needed. <br><br>  That's so easy and not too expensive, you can get quite a beautiful effect of the shield of the spacecraft. <br><br><h2>  Instead of an afterword: optimization </h2><br>  I will outline the main directions of possible optimization: <br><br><ul><li>  Remove unused: Fresnel effect, basic translucent shield - all this is not free and if some of the components are not needed, you need to remove them. </li><li>  t0, t1, t2 can be counted on the CPU once per frame for each shield in the script.  Thus, you can remove 3 saturate and a bunch of calculations. </li><li>  Using floating-point numbers with less precision, in many places you can get fixed or even half instead of float. </li><li>  If many shields are drawn on the screen, it makes sense to consider using instancing. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/352228/">https://habr.com/ru/post/352228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352218/index.html">US authorities will check the activities of the cryptocurrency fund founder techclog TechCrunch</a></li>
<li><a href="../352220/index.html">Softer Meetup. How to deal with User Story?</a></li>
<li><a href="../352222/index.html">Fernando Gaunt will talk about IPv6 security on PHDays 8</a></li>
<li><a href="../352224/index.html">White Paper on the Federal Law ‚Ññ152 - a book that can be referenced in the processing of personal data</a></li>
<li><a href="../352226/index.html">Our Friday quest for system administrators and not only</a></li>
<li><a href="../352230/index.html">Magic Leap released SDK. Let's see what's inside?</a></li>
<li><a href="../352234/index.html">When it's hard to be a ‚Äúbad guy‚Äù</a></li>
<li><a href="../352236/index.html">16 DevOps conferences of 2018, performances from which are worth seeing</a></li>
<li><a href="../352238/index.html">What will happen in the new Workspace ONE from VMware</a></li>
<li><a href="../352240/index.html">Security Week 10: where to hide the miner and a brief excursion into darknet marketing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>