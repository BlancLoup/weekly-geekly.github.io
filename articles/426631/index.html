<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to update the code of smart contracts in Ethereum</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to update the code of smart contracts in Ethereum 


 The article assumes that the reader has a basic understanding of how Ethereum, EVM (Ethereum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to update the code of smart contracts in Ethereum</h1><div class="post__text post__text-html js-mediator-article"><h2>  How to update the code of smart contracts in Ethereum </h2><br><p>  <i>The article assumes that the reader has a basic understanding of how Ethereum, EVM (Ethereum Virtual Machine) and smart contracts work at a technical level, as well as an understanding of the basics of the programming language of smart contracts - Solidity.</i> </p><br><p>  <em>The material was worked on by the team of the <a href="https://www.axiomadev.ru/%3Futm_source%3DHABR%26utm_medium%3Dreferral%26utm_campaign%3Dhabr">AXIOMA GROUP</a> company, led by Dmitry Abrosimov.</em> </p><a name="habracut"></a><br><p>  In applications where transparency of operations and user confidence are prioritized, blockchains and smart contracts are often used.  The advantage of this architectural solution is that the operations on the blockchain are irreversible and are visible to everyone, that is, everyone can easily check whether the application works honestly. </p><br><p>  Smart contracts are special programs that execute code programmed before it is published on the blockchain.  Change it after the publication is no longer possible.  This is an undoubted advantage for many applications, but it is rather difficult to maintain and maintain the smart contract code.  Imagine that after prolonged work a logical error was discovered, allowing fraudsters to divert the broadcast from the smart contract.  In such a situation, all that can be done is to observe how the air is transferred to someone else‚Äôs wallet.  As an <a href="https://twitter.com/TuurDemeester/status/927906221692157953">example,</a> let <a href="https://twitter.com/TuurDemeester/status/927906221692157953">us</a> recall an error in one of Parity‚Äôs wallet libraries, which led to the freezing of air worth $ 160 million. </p><br><p>  Therefore, the ability to update the smart contract code is needed to correct errors.  In addition, it makes the development of the application as it grows more convenient.  In this article, we will group and classify the well-known methods of updating the code of smart contracts in Ethereum and describe the advantages and disadvantages of various methods. </p><br><p>  <b>Basic ways to update code</b> </p><br><p>  <i>The article uses code samples from the public open-source repository <a href="https://github.com/zeppelinos/labs">ZeppelinOS</a> .</i>  <i>We have no goal to reinvent the wheel, so we use ready-made and tested solutions.</i>  <i><u>The names of smart contracts may vary.</u></i> <br></p><p>  The most difficult in all ways of updating the code is to save permanent data in the storage of a smart contract.  There are different ways to update the code, while allowing to save data, all of them can be divided into two groups: </p><br><p>  Breakdown of code that implements logic and data storage for various smart contracts. <br>  Proxy code from one smart contract to another using shared data storage. </p><br><p>  Consider each of the groups in more detail. </p><br><p>  Breakdown of logic and data storage on different smart contracts </p><br><p>  The idea is to break the data storage code and the code to implement the logic into different smart contracts. </p><br><p>  Abstract scheme of work looks like this: </p><br><img src="https://habrastorage.org/webt/sb/j3/gu/sbj3guwqk6ztgccicvnd8a5gtlg.png"><br><p>  <i>The concept of ‚Äúsmart contract‚Äù in the schemes for convenience is reduced to ‚ÄúSM‚Äù.</i> </p><br><ul><li>  The front controller in this scheme is necessary for the client to always access a single access point, which automatically sends it to the current version of the smart contract with logic. </li><li>  The front controller implements the same methods as the smart contract with logic, through a separate interface common to both smart contracts for integrity. </li><li>  The front controller stores the address of the current implementation, which can be changed via the setCurrentLogicAddress () function. </li><li>  A smart contract with logic stores the address of a smart data contract (data). </li><li>  If the function involves working with data (read or write), then a smart contract is applied to the data (via the data address) </li><li>  All business logic, validation and return values ‚Äã‚Äãare implemented in a smart contract with logic, and the front controller only calls the necessary functions of a smart contract with logic, passing the necessary arguments </li></ul><br><p>  The process of updating the code is that instead of the current version of the smart contract with logic, a new version is created and the address of the new version of the code is changed in the front controller. </p><br><p>  The problem with this scheme is that a smart data contract has a fixed data scheme.  The product in the IT field is changing rapidly and must adapt to the new requirements.  This is where the problem arises: the smart data contract is not updated. <br>  This problem can be solved by using the ‚ÄúPerpetual Key-Value Type Storage‚Äù data storage template. </p><br><p>  <b>Eternal key-value storage (Eternal key-value storage)</b> </p><br><p>  The idea is to universalize the data storage scheme in a smart data contract so that it can store any type of data (numbers, strings, addresses, and so on) in unlimited quantities. <br>  This can be achieved by declaring the space of possible values ‚Äã‚Äãfor storage through mappings, as shown in <a href="">this example</a> . <br>  Thus we get the ability to save almost any type of data. </p><br><ul><li>  Note that the largest size types (32 bytes) are used as mapping values ‚Äã‚Äãto be as flexible as possible in data storage. </li><li>  The key is the type bytes32, which must contain a hash obtained, for example, via keccak256 ('...').  This choice is due to the fact that: </li></ul><br><p>  This allows the use of arbitrary key lengths. <br>  This makes it possible to use composite keys, for example keccak256 (‚Äúusers‚Äù, ‚Äúuser_id_123‚Äù). </p><br><p>  All data types are declared as internal in order to use less gas to access them.  To work with data, for each type you need to write the necessary functions.  An example of operations for the uint data type can be viewed by <a href="">reference</a> . </p><br><p>  It is also important to restrict write access and data deletion only for a smart contract with logic (using the get * function check does not make sense because it is a safe operation that does not change the internal state of the smart contract).  This can be done in the same way as storing the address of the current version of the smart contract code in the front controller.  Only in this case, the current address of the code will be stored in EternalStorage. </p><br><p>  An example of using the template ‚Äúperpetual storage‚Äù of a smart contract with logic can be found <a href="">here</a> . </p><br><p>  <b>Underwater rocks</b> </p><br><p>  What should be considered when updating the smart contract code in this way: </p><br><p>  As a ‚Äúfoolproof‚Äù in a smart logic contract, you only need to allow access to functions that change state for the front controller. </p><br><p>  <i>The main disadvantages of this approach in general:</i> </p><br><ul><li>  Gas consumption increases due to the fact that working with a single smart contract changes to a chain of three.  Also, the cost of publishing such smart contracts in the blockchain will be higher. </li><li>  In a smart contract with logic, you can change any internal functions or change the operation of any public function, keeping its signature.  If, however, you cannot save the signature for some reason, you will have to update the common interface between the front controller and the smart contract with logic and implement the same changes in the front controller.  As can be seen from the description of the approach, it is impossible.  It turns out that a single entry point also needs to be updated, using the same approach (for which the same problem, however, will remain relevant). </li><li>  The problem can be solved through the low-level <a href="http://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html">call</a> function, which accepts functions with an arbitrary number of arguments as input.  If we add to this the use of solidity assembly code, then the common interface between the front controller and the code with logic can be removed, and in the front controller you can leave a single function for processing client requests to redirect directly to the smart contract with logic.  We will not consider solving the problem in this way, because a similar scheme is used in proxying, except that the <a href="http://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html">delegatecall</a> function is used there, which does not switch the context. </li></ul><br><p>  <i>Cons of the template "perpetual storage of the key-value type":</i> </p><br><ul><li>  Abstraction from the application domain.  This complicates the work and perception of data, and can also become an obstacle to the implementation of requirements (for example, there are no structures). </li><li>  Gas consumption is more likely to be higher than if the data scheme were designed taking into account the application domain.  First, whatever key types are used in mappings, they will occupy 32 bytes (because mapping keys are implemented using <a href="https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html">keccak256</a> ).  Secondly, it is difficult to optimize the mapping because each mapping value occupies <a href="https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html">a whole slot</a> (32 bytes) in the storage, regardless of the data type used. </li></ul><br><p>  <b>Code proxying using shared storage</b> </p><br><p>  To understand this way of updating the code, you need to understand how EVM works at the communication level of two (or more) smart contracts and what possibilities Solidity provides for this. </p><br><p>  Outside, smart contract functions can be invoked in two ways: </p><br><ul><li>  Call is a local function call that does not send anything to the blockchain network and does not change the state, that is, it performs the function in read mode. </li><li>  Transaction is a function call that changes the state of the blockchain and sends a transaction to the network for processing by the miners. </li></ul><br><p>  When using any method, the execution context of the function remains inside the smart contract in which the function is called.  This means that the data warehouse and the balance with which the function works are stored and changed only within the current smart contract. </p><br><p>  If a smart contract causes a function of another smart contract, then the called function works in the context of its smart contract, which ensures safe and independent work with the storage of one and the second smart contract. </p><br><p> Although the call of a function of another smart contract is similar to the type of call ‚Äútransaction‚Äù, it works somewhat differently in terms of the availability of the result of another function, and the official name of such a call of the function is <u>message call</u> . </p><br><p>  Consider an example: </p><br><img src="https://habrastorage.org/webt/9i/rx/1e/9irx1evo89tll8lmtforytzmhzi.png"><br><p>  The code of both functions (handle, handle2) can be viewed by <a href="">reference</a> . </p><br><p>  The SM1.handle () function changes the value of the data variable to true, working only in the context of the SM1 smart contract, and the SM2.handle2 () function changes the value of the data2 variable to false, working only in the context of the smart contract SM2.  If SM1.handle () tries to change the value of SM2.data2, then EVM will complete this operation with an error. </p><br><p>  <b>Low-level Solidity functions for calling another smart contract code</b> </p><br><p>  What is shown above uses the function call of another smart contract with the well-known <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI</a> (sm2 variable type - SM2). </p><br><p>  There are <a href="">ways to call the code of another smart contract without an ABI</a> , i.e.  in our case, not importing the SM2 smart contract or its interface. </p><br><p>  Solidity provides two built-in low-level functions that allow you to call another smart contract code: </p><br><ul><li>  call - a function call of another smart contract with context switching (as in the example above with ABI). </li><li>  delegatecall - a function call of another smart contract within the current context. </li></ul><br><p>  There is a third low-level function - callcode, but it is not recommended to be used and it will be removed in future versions of Solidity. </p><br><p>  Call works according to the scenario already familiar to us, but delegatecall introduces something new - when executing a function from another smart contract, the context does not switch.  Here we first come across the concept of ‚Äúshared storage‚Äù.  The called function is able to change the value of variables in the calling smart contract ‚Äî it delegates the execution of the function code from another smart contract, but within its own context. </p><br><p>  If you go back to the example code above and replace call with delegatecall, then SM2.handle2 (), setting the data2 variable as the value false, will actually change the value of the variable SM1.data, and SM2.data2 will remain unchanged because the function SM2. handle2 () worked in the context of the SM1 smart contract. </p><br><p>  To explain this behavior, you need to refer to the <a href="https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html">organization of state variables in the persistent store</a> .  The Solidity compiler places each state variable of a fixed value in a separate slot of 32 bytes (EVM uses a 32-byte machine word) in the persistent storage, starting from the zero position in the variable declaration order.  Position is calculated as follows: </p><br><p></p><pre><code class="hljs objectivec">keccak256(variablePosition) <span class="hljs-comment"><span class="hljs-comment">// variablePosition   0</span></span></code> </pre> <br>  The state variables of the dynamic quantity are placed somewhat differently.  For example, the position of the mapping elements is calculated as follows: <p></p><br><p></p><pre> <i><code class="hljs lisp">keccak256(<span class="hljs-name"><span class="hljs-name">elementKey</span></span> . mappingPosition)</code></i> </pre> <br>  If the total value of the values ‚Äã‚Äãof several state variables is less than 32 bytes, then the compiler tries to pack them into one storage slot.  When describing the data scheme, you need to keep this in mind, but later we will omit this point in order not to complicate the examples. <p></p><br><p>  If we return to the code of two contracts SM1 and SM2, then the storage slots can be expressed as a table: </p><br><img src="https://habrastorage.org/webt/cu/5j/an/cu5jan_uxp0mhyzmrsk_zb_grgi.png"><br><p>  As the table shows, SM2.data2 and SM1.data occupy the same slot in the storage, so when using delegatecall to execute the function SM2.handle2, which changes the value of the variable data2, the value of the data variable of the smart contract SM1 changes inside the EVM. </p><br><p>  The call and delegatecall functions are useful if you need to call a function of another smart contract whose ABI is not known and only its address is present. </p><br><p>  Disadvantages of these functions: </p><br><ul><li>  They do not return the result of the execution of the called function, but only the ‚Äúsuccess‚Äù or ‚Äúfailure‚Äù of the function (true / false). </li><li>  They do not cause exceptions in case of errors on the side of the called function, therefore, as a consequence of the first drawback, the function call must be framed in the require () statement: </li></ul><br><p>  <u><i>require (sm2.call ("handle2"));</i></u> </p><br><p>  Solidity provides the ability to return the result of a function execution via call / delegatecall using the Solidity Assembly, a low-level programming language. </p><br><p>  <b>Solidity assembly</b> </p><br><p>  <a href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html">Solidity assembly</a> is a low-level programming language that can be used without Solidity itself.  We will look at the <a href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html">inline assembly</a> - this is the assembly code, which is embedded directly into the code of the smart contracts Solidity. </p><br><p>  Solidity assembly must be used with caution and knowledge of the matter, because using it, communication with EVM occurs at a low level, which can cause unsafe code to be written. </p><br><p>  Consider an example of calling the SM2.handle2 function from SM1 using delegatecall at the assembly level.  Rewrite code SM1 and SM2 <a href="">as follows</a> and understand it: </p><br><ul><li>  Implemented the so-called fallback function (without a name and arguments) in SM1, which is triggered when a function call of a smart contract occurs that is not present in the smart contract. </li><li>  In order for the smart contract to be able to receive air, the fallback function is indicated by the keyword payable. </li><li>  Inside the fallback function, an inline assembly code is declared which, using assembly expressions, calls the function of another smart contract via delegatecall. </li><li>  The SM2 code is rewritten so that the state variables are declared in the same order and with the same types as in the SM1 smart contract.  For data consistency, we write our own SM2 address in sm2. </li></ul><br><p>  Let us consider in more detail the fallback code of the function in order. </p><br><ul><li>  We declare a local variable addr, which takes the value _sm2, outside the assembly code block, because inside the assembly block, the reference to external variables (state variables) does <a href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html">not</a> happen <a href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html">as usual</a> : </li></ul><br><p>  <i>address addr = _sm2;</i> </p><br><ul><li>  We are starting to embed the assembly code in the function code of a smart contract: </li></ul><br><p>  <i>assembly {</i> </p><br><ul><li>  Create a pointer to the address 0x40 (in the range of 0x40 - 0x5f there is a ‚Äúfree memory‚Äù area) using the mload operation: </li></ul><br><p>  let ptr: = mload (0x40) </p><br><ul><li>  Copy the entire calldata (the data that was passed when the function was called) to the beginning of the pointer that we created earlier. </li></ul><br><p>  calldatacopy (ptr, 0, calldatasize) </p><br><p>  Below, the function of another smart contract is called using delegatecall, the result of which (true / false) is stored in the variable success.  Call arguments mean the following: </p><br><p>  gas - the remainder of the gas available for work <br>  addr - the address of another smart contract <br>  ptr - we specify the position of the beginning of the calldata memory area, which we pass to the called function <br>  calldatasize - we specify the position of the end of the calldata memory area, which we pass to the called function <br>  the last two arguments (0, 0) - indicate the position of the beginning and end of the memory area of ‚Äã‚Äãthe returned data of the called function.  At the time of the function call, the size of the returned data is unknown, therefore both arguments are indicated by zeros, and below is the actual calculation of the size of the returned data. </p><br><p>  <i>let success: = delegatecall (gas, addr, ptr, calldatasize, 0, 0)</i> </p><br><ul><li>  Write the size of the data that the called function (returndata) returned to the size variable: </li></ul><br><p>  <i>let size: = returndatasize</i> </p><br><ul><li>  Copy all the data that the called function (returndata) returned to the beginning of the pointer that we created earlier: </li></ul><br><p>  <i>returndatacopy (ptr, 0, size)</i> </p><br><ul><li>  We check the success of the function call: </li></ul><br><p>  If success = 0, then cancel all state changes and return returndata (32 bytes long). </p><br><p>  In the opposite case (success = 1), simply return returndata (32 bytes long). </p><br><p></p><pre> <i><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> success <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> { revert(ptr, <span class="hljs-number"><span class="hljs-number">32</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(ptr, <span class="hljs-number"><span class="hljs-number">32</span></span>) }</code></i> </pre> <p></p><br><p>  At this fallback function completes its work.  Thus, when calling the function SM1.handle () (which is actually not in SM1), the function SM2.handle () is called, which will change the value of the state variable SM1.data. </p><br><p>  The approach described above, using the inline assembly and delegatecall, is the basis for the way to update the smart contract code - ‚Äúcode proxying using shared storage‚Äù.  All the options that will be described below differ only in terms of organizing the data scheme. </p><br><p>  Consider the well-known code proxying options: inherited storage (inherited storage), eternal storage (eternal storage), and unstructured storage (unstructured storage). </p><br><p>  <b>Option 1: Inherited Storage</b> </p><br><p>  In fact, everything described above uses storage of an inherited type.  We will bring the code described above into a more general form that can be reused in the following sections. </p><br><p>  Schematically, proxying with the inherited storage looks like this: </p><br><img src="https://habrastorage.org/webt/gp/uq/47/gpuq47rsotnrrbqvssl2hehsl74.png"><br><ul><li>  Proxy Storage is a smart contract that stores the necessary variables for a proxying smart contract to work correctly (it stores the address of the current version of the smart contract with logic). </li><li>  Base Proxy SM is a basic smart contract containing code for proxying, which can be inherited by other smart contracts (in our case, Logic Proxy SM inherits Base Proxy SM). </li><li>  Logic Proxy SM is the entry point for function calls that delegates their execution to a specific version of a smart contract with logic (in our case, Logic SM v1).  Logic Proxy SM inherits Proxy Storage to store the address of the current version of the smart logic contract. </li><li>  Logic SM v1 is an implementation of a specific version of a smart contract with logic that inherits Proxy Storage in order to reconcile common state variables with a proxying smart contract.  A smart contract with logic may represent new state variables. </li></ul><br><p>  Updating a smart contract with logic happens like this: </p><br><ul><li>  A new smart contract with logic is created - Logic SM v2 (v3, v4, v5, ...). </li><li>  <u>Important:</u> since proxying is based on the use of shared storage, all new versions of smart contracts with logic must be inherited <u>from the previous version</u> in order for the order and type of state variables to be preserved. </li><li>  Logic Proxy SM updates the address of the new version of the code. </li></ul><br><p>  Thus, in a smart contract with logic, you can add new functions, as well as new state variables. </p><br><p>  The <a href="">BaseProxy</a> code contains a fallback function for proxying and an implementation interface function that gives the address of the current version of the smart contract with logic. </p><br><p>  The <a href="">ProxyStorage</a> code contains state variables necessary for the operation of code proxying (in our example, the presence of the registry variable can be excluded), and also implements the implementation function. </p><br><p>  LogicProxy only inherits BaseProxy, and also contains a function for updating the address of the current version of the smart contract with logic. </p><br><p>  The smart contract with logic itself (Logic SM v1) implements the application logic and contains its own state variables: </p><br><p></p><pre> <i><code class="hljs cs">contract LogicV1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ProxyStorage {&lt;/p&gt; &lt;source&gt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> data1; address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> data2; <span class="hljs-comment"><span class="hljs-comment">// other state variables function handleSomething() { // ... }</span></span></code></i> </pre> <i><br></i> <p></p><p>  } </p><br><br>  A new version of the smart contract with logic is created based on the previous version: <br><p></p><pre> <i><code class="hljs cs">contract LogicV2 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> LogicV1 {&lt;/p&gt; &lt;p&gt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> data3; <span class="hljs-comment"><span class="hljs-comment">// ... other code&lt;/p&gt; &lt;p&gt;}</span></span></code></i> </pre> <br>  The main disadvantages of this option is that for new versions of a smart contract with logic, you must pull the code of all previous versions and you cannot exclude any state variable from the previous version. <p></p><br><p>  <b>Option 2: Perpetual Storage (eternal storage)</b> </p><br><p>  The essence of code proxying using perpetual storage is to get rid of the need to inherit the storage variable scheme from previous versions of a smart contract with logic, and in principle makes it possible not to inherit previous versions. </p><br><p>  The idea is to connect the same storage option, which is described in the ‚Äúmethod of breaking logic and storing data into different smart contracts‚Äù using perpetual key-value storage. </p><br><p>  Schematically, the method looks like this: </p><br><img src="https://habrastorage.org/webt/ig/c0/ps/igc0pstpfwspapphuur9lckbb24.png"><br><p>  Differences from inherited storage: </p><br><ul><li>  A new smart contract is being introduced - EternalStorage, mentioned in the ‚Äúmethod of breaking down logic and storing data into different smart contracts‚Äù.  Since the proxy method uses shared storage, in EternalStorage there is no need to implement data manipulation functions (setUint, getUint, deleteUint, ...) - all mappings will be available directly in a smart contract with logic. </li><li>  EternalStorage inherits ProxyStorage so that the data required for the proxying functionality is consistent. </li><li>  LogicProxy and LogicV1 inherit from both EternalStorage - thus, the data scheme is consistent between the smart contracts. </li></ul><br><p>  The process of updating a smart contract with logic: </p><br><ul><li>  A new smart contract with logic is created - Logic SM v2 (v3, v4, v5, ...). </li><li>  <u>Important:</u> new versions of smart contracts with logic must inherit EternalStorage and <u>not introduce</u> new state variables. </li><li>  Logic Proxy SM updates the address of the new version of the code. </li></ul><br><p>  Thus, the new versions of smart contracts with logic can make any changes with functions (up to the removal of functions that were present in the old versions) and are not required to pull the old versions. </p><br><p>  The main disadvantages of this option are that you have to work with too abstract data and there are problems with the optimization of storage and an increase in gas consumption. </p><br><p>  <b>Option 3: Unstructured storage (unstructured storage)</b> </p><br><p>  This option is similar to inherited storage (inherited storage), but smart contracts with logic should not inherit ProxyStorage, which contained the necessary state variables for proxying. And ProxyStorage itself is not in this version as a separate smart contract.  State variables with the address of the current version of the smart contract with logic are transferred directly to LogicProxy. </p><br><p>  Schematically it looks like this: </p><br><img src="https://habrastorage.org/webt/er/zt/km/erztkmnxe3wb-2skjvbt1y3ldww.png"><br><ul><li>  LogicV1 contains nothing more related to state variables from ProxyStorage. </li><li>  LogicProxy stores directly in its own smart contract the address of the current version of LogicV1. </li><li>  BaseProxy still provides the standard proxy function. </li><li>  The address of the current version of the smart contract with logic now handles differently.  LogicProxy needs to be rewritten as shown in <a href="">this example</a> . </li></ul><br><p>  As you can see, the state variable for storing the address of the current version of a smart contract with logic does not exist at all.  Instead, the following is done: </p><br><ul><li>  A private <u>implementationPosition</u> constant is declared, which takes as its value the result of the keccak256 hash function, which hashes an arbitrary unique string (unique within your smart contracts). </li><li>  The current version of a smart contract is updated with logic using the inline assembly code: the setImplementation function sets the smart contract address to the position specified in the implementationPosition constant. </li><li>  Getting the current version of a smart contract with logic is similarly done using the inline assembly: the implementation function loads data stored in the implementationPosition from the storage (the data obtained will be the address of the current code version). </li></ul><br><p>  At first glance, this scheme looks confusing, but if you remember how Solidity distributes variables in the repository, then everything becomes clear.  For the distribution of variables, the same hash function is used - keccak256, which accepts the variable position number (starting with 0) as input.  The implementationPosition constant explicitly states the address of the variable value to store the address of the current version of the smart contract with logic. </p><br><p>  According to the <a href="https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html">documentation</a> , the constants are not distributed in the repository, so the only risk of this approach is that there is a small probability of collision with those variables that Solidity automatically distributes.  In order to avoid this, you need to specify a value unique within your smart contracts as the value of keccak256 in the implementationPosition. </p><br><p>  Updating a smart contract with logic is the same as in the case of updating using inherited storage. </p><br><p>  Thus, in a smart contract with logic, you can add new functions, as well as new state variables, and there is no need to include in the code the variables necessary for the proxying operation. </p><br><p>  <b>Initialization of smart contracts with logic</b> </p><br><p>  Versions of smart contracts with logic are published in two stages: </p><br><ol><li>  the publication of the smart contract with logic, </li><li>  address update in a proxy smart contract. </li></ol><br><p>  There is one problem with smart contracts with logic, which are updated using the proxying method.  At the second stage, the proxying smart contract does not see what is happening in the smart contract designer with the logic in the first step.  And if the initial values ‚Äã‚Äãof state variables are set in the constructor, then when the smart contract with logic through the proxying smart contract is accessed, the values ‚Äã‚Äãof these same variables will have different values, because the initialization of the variables occurred in the context of the smart contract with logic. </p><br><p>  To avoid this problem, in smart contracts with logic, you need to take the initialization of state variables into a separate function (for example, initialize), and add the upgradeToAndCall function to the LogicProxy code, as was done in <a href="">this example</a> . </p><br><p>  The upgradeToAndCall function does the same thing as updateCurrentVersionAddress, and in addition to this, it makes a low-level call to a new version of the smart contract with logic, passing all the necessary parameters for initialization.  The call function <a href="https://solidity.readthedocs.io/en/v0.4.21/types.html">can receive the signature of the called function with parameter passing</a> .  Accordingly, if a new version of a smart contract with logic requires initialization of any state variables, instead of calling updateCurrentVersionAddress, you need to call upgradeToAndCall, passing the signature to the initialize function and arguments for it. </p><br><p>  <b>Underwater rocks</b> </p><br><p>  Code proxying is undoubtedly a more flexible way than splitting logic and storing data into different smart contracts, but you should treat it with care.  What you should pay attention to: </p><br><ul><li>  The proxying method uses low-level constructions using inline assembly, which is the closest way to access EVM, so you need to understand well how the Solidity Assembly works. </li><li>  It is necessary to strictly follow the data scheme between all associated smart contracts, so as not to disturb the organization of variables in the repository. </li><li>  You need to pay great attention to the security of your code using assembly code or other low-level constructs (call, delegatecall).  As an example, you can pay attention to the <a href="https://medium.com/%40MyPaoG/explaining-the-dao-exploit-for-beginners-in-solidity-80ee84f0d470">case of detection of code vulnerabilities in The DAO</a> , which also has the use of low-level functions, and which allowed to ‚Äústeal‚Äù the broadcast worth $ 150 million. </li></ul><br><p>  <b>The way to create short-term autonomous smart contracts</b> </p><br><p>  Sometimes there is a need for a ‚Äúfactory‚Äù creation of separate independent smart contracts of a general type that live for a short time.  For example, in a project that is based on any transactions, each transaction may be represented as a separate smart contract, with a common code, but belonging to different users. </p><br><p>  Let us tell you how we implemented this work in one of the projects. </p><br><p>  The project works in the field of betting and in the heart of the system lies the essence - ‚Äúevent‚Äù, which is a separate smart contract that allows you to bet on this event.  For example, the events of ‚ÄúWorld Cup 2018‚Äù and ‚ÄúPresidential Election 2024‚Äù are each expressed as a separate smart contract in the blockchain.  There can be an infinite number of events, and the new smart contract will be posted on the blockchain as many times. </p><br><p>  An event smart contract contains a fairly large amount of code (event outcomes, rates, determining the correct outcome of an event, winning, and so on), which also consumes a lot of gas during the publication of a smart contract. </p><br><p>  To significantly save on gas consumption when publishing a smart contract event, we applied the following approach based on the same mechanism as code proxying. </p><br><p>  Some requirements for smart event contracts are: </p><br><ul><li>  Must be able to update business logic. </li><li>  At the same time, when updating the code, the previously created smart contracts should not be affected in any way. </li></ul><br><p>  Schematically, creating a new event looks like this: </p><br><img src="https://habrastorage.org/webt/og/ir/5a/ogir5a6b_13_zth5419y7rxyujo.png"><br><ul><li>  BaseEvent - is a ‚Äúprototype‚Äù of the event, which contains all the necessary code to implement the logic of the most events (Event).  BaseEvent is published once, until you need to update it - in this case, its new version is published. </li><li>  An event is directly a smart contract of a specific event - it is created by an EventFactory. </li><li>  An EventFactory is a factory that a user accesses to create a new event (Event).  The factory stores the address of the current version of BaseEvent and allows you to update it to new versions. </li></ul><br><p>  The solution to the requirements is that: </p><br><p>  The smart contract of an event contains nothing but the delegation of a call to a function to an EventBase smart contract (that is, it runs in its own context with a shared storage). <br>  Factory at event creation: </p><br><ul><li>  Creates a new smart contract Event, specifying in its constructor the prototype address - EventBase (so that Event delegates the execution to EventBase). </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúWraps‚Äù a newly created Event in EventBase to initialize a new event with multiple parameters (in our case, through an array of bytes with a single argument) to the EventBase.init function. </font></font></li></ul><br><p> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smart contract code Event</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains one state variable ‚Äî the address of the event prototype, EventBase. </font><font style="vertical-align: inherit;">When creating a new event, its address must be passed to the constructor. </font><font style="vertical-align: inherit;">This is how the second requirement is implemented - the previously created event smart contracts are not affected in any way when the EventBase prototype is updated.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The factory function for creating an event looks like </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The factory also stores the address of the event prototype EventBase, and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows it to be updated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , implementing the first requirement ‚Äî the ability to update.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The creation itself is covered in the line: </font></font></p><br><p> <i>EventBase _lastEvent = EventBase(address(new Event(address(eventBase))));</i> </p><br><p>  ,  EventBase            : </p><br><p> <i>EventBase public base</i> </p><br><p>    EventBase      ,    - . </p><br><p>             ,    ,       ,    -. </p><br><p> <b>   </b> </p><br><p>  -       ‚Äî        ,      ,         ,   . </p><br><p>    ,         , : </p><br><ul><li>     :   -    ,         -  (    ).        - (  - ‚Äú  ‚Äù  ,       ). </li><li>                (emit event),        ,       . </li></ul><br><p>  ,       . </p><br><p>   -           . ,      ‚Äî    -    ,     -. </p><br><p>      ,        :   .        -  .           - (          -  - ‚Äú  ‚Äù).       . </p><br><p>   ,    :  ,  -     . ,       ERC223       ,      ,     . </p><br><h3>    - </h3><br><p>      , , ,        -: </p><br><img src="https://habrastorage.org/webt/j2/fn/9d/j2fn9dbtpkphtspylczzy_9l9ru.png"><br><p>     <a href="https://www.axiomadev.ru/%3Futm_source%3DHABR%26utm_medium%3Dreferral%26utm_campaign%3Dhabr">AXIOMA GROUP</a> ,     . <br> ,  ! </p><br><p> <i></i> </p><br><p> <a href="https://solidity.readthedocs.io/">https://solidity.readthedocs.io</a> <br> <a href="https://github.com/comaeio/porosity/wiki/Ethereum-Internals">https://github.com/comaeio/porosity/wiki/Ethereum-Internals</a> <br> <a href="https://blog.zeppelinos.org/proxy-patterns/">https://blog.zeppelinos.org/proxy-patterns/</a> <br> <a href="https://blog.zeppelinos.org/smart-contract-upgradeability-using-eternal-storage/">https://blog.zeppelinos.org/smart-contract-upgradeability-using-eternal-storage/</a> <br> <a href="https://blog.zeppelinos.org/upgradeability-using-unstructured-storage/">https://blog.zeppelinos.org/upgradeability-using-unstructured-storage/</a> <br> <a href="https://medium.com/%40novablitz/storing-structs-is-costing-you-gas-774da988895e">https://medium.com/@novablitz/storing-structs-is-costing-you-gas-774da988895e</a> <br> <a href="https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201">https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201</a> <br> <a href="https://github.com/zeppelinos/labs">https://github.com/zeppelinos/labs</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426631/">https://habr.com/ru/post/426631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426621/index.html">Compact strings in Java 9</a></li>
<li><a href="../426623/index.html">This is an electric bus: what do we know about transport with a battery</a></li>
<li><a href="../426625/index.html">Multilingual trees in Yii2 on the example of creating a menu module</a></li>
<li><a href="../426627/index.html">Flexbox usage examples</a></li>
<li><a href="../426629/index.html">Trump's Tax Reform Philosophy</a></li>
<li><a href="../426633/index.html">Pavel Durov will launch Telegram blockchain platform this fall</a></li>
<li><a href="../426637/index.html">Record of the webinar "Do you need Kubernetes"</a></li>
<li><a href="../426639/index.html">SberTech ‚ô• Open Source, concurrency and reliable banking operations - problem analysis with Joker 2018</a></li>
<li><a href="../426641/index.html">The basics of the shop</a></li>
<li><a href="../426645/index.html">Validation of electronic signatures on C # using CRIPTO PRO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>