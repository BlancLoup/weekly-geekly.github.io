<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three F # Paradigms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Anyone who is somehow connected with .NET programming knows that already in the next version of Visual Studio a new programming languag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three F # Paradigms</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Anyone who is somehow connected with .NET programming knows that already in the next version of Visual Studio a new programming language will be built in - F #, which is positioned as functional, which immediately led to suspicions of uselessness.  In order to show that F # is much more than just a FNP (although just FNP is a lot), I wrote all of the following. <br>  This article, despite the hefty length, does not pretend to fully describe all the functionality of the language.  This is just a brief overview, designed to demonstrate a wide range of possibilities, each of which deserves a separate article, and not even one. <br>  Besides, having written such a lengthy post, I wanted to make a reserve for the future, so that in the future I would not be distracted by minor things of a basic level.  Of course, immediately head over to the pond - this is effective, but even some kind of foundation will not interfere. <br>  And the next time I will give an example on the exciting topic of F # suitability for ordinary professional programming. <br>  And once again, under the cut is really a lot of text.  And do not say later that I did not warn you.  =) <br><a name="habracut"></a><br><h2>  F # functional </h2><br>  Of course, first of all, F # is a functional language, which means it supports the functional paradigm in it most fully.  As you know, many keywords and literals in it are borrowed from OCaml, which is not surprising since Don Syme, the main creator of F #, once had a hand in OCaml. <br>  A lot of knowledge about F #, as a pure functional programming language, the reader could already learn from my previous posts, but solely in order to create a complete impression of the language, I will briefly repeat all of them once again. <br><br><h4>  Identifiers, keywords, functions. </h4><br>  So, F #, oddly enough, allows the programmer to determine the identifiers with which it will be possible to subsequently access the functions.  This is done using the <font color="#0000ff">let</font> keyword, followed by the name of the identifier, the list of parameters, and after the equal sign, the expression that defines the function.  Like that: <br><blockquote><code><font color="black"><font color="#0000ff">let</font> k = 3.14 <br> <font color="#0000ff">let</font> square x = x**2.0 <br></font></code> </blockquote><br>  Unlike imperative programming, the first expression does not define a variable, but rather a constant, since its value cannot be changed during program execution.  Generally speaking, F # does not distinguish between functions and values ‚Äã‚Äã‚Äî any function is a value that can also be freely passed as a parameter. <br>  A list of all the F # keywords can be seen <a href="http://stuff.mit.edu/afs/athena/software/fsharp_v1.1.12/FSharp-1.1.12.3/manual/lexyacc.html">here</a> .  The words from the second list given by reference are not used at the moment, but are reserved for the future.  They can be used, but the compiler will give a warning. <br>  F # supports <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">curried</a> functions, in which you can transfer not all parameters at once: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> add ab = a + b <font color="#A31515">//'a -&gt; 'a -&gt; 'a</font> <br> <font color="#0000ff">let</font> addFour = add 4 <font color="#A31515">//'a -&gt; 'a</font> <br></font></code> </blockquote><br>  The second identifier sets the function already from one free parameter, the other is defined as 4. This again demonstrates the thesis that the function is a value.  Since a function is a value, without having received a complete set of parameters, it simply returns another function, which is also a value. <br>  However, all functions from .NET do not possess the property of curvature, and for their use in F # tuples are used - sets of several different types of values.  A tuple can contain many different parameters within itself, however, F # is considered as one parameter, and as a result, it is applied only as a whole.  Tuples are written in parentheses, separated by commas. <br><blockquote> <code><font color="black"><br> <font color="#0000ff">let</font> add (a,b) = a + b <br> <font color="#0000ff">let</font> addFour = add 4 <br></font></code> </blockquote><br>  Such code will not be compiled, since according to F # we are trying to apply the function to the parameter of the wrong type, namely int instead of 'a *' b. <br>  However, it should be remembered that when developing your own functions, especially those that will be used by other programmers, you should, if possible, make them curried, since they obviously have greater flexibility in use. <br>  As I believe, the reader has already noticed that in F # in functions you do not need to explicitly define the return value.  However, it is not clear how to calculate the intermediate values ‚Äã‚Äãinside the function?  Here, F # uses a method that many people have, I think, have forgotten - with the help of spaces.  Internal calculations in a function are usually separated by four spaces: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> midValue ab = <br> <font color="#0000ff">let</font> dif = b - a <br> <font color="#0000ff">let</font> mid = dif / 2 <br> mid + a <br></font></code> </blockquote><br>  By the way, if someone from those who saw the program on F # was surprised by the constant presence in the code of the <font color="#0000ff">#light command</font> , then one of its effects is precisely that the spaces become important.  This avoids the use of multiple keywords and characters that come from OCaml, such as <font color="#0000ff">in</font> , ;;, <font color="#0000ff">begin</font> , <font color="#0000ff">end</font> . <br>  Each of the identifiers has its own scope, which starts from the place of its definition (that is, it cannot be applied higher in code than the place of its definition), but ends at the end of the section where it was defined.  For example, the intermediate dif and mid identifiers from the previous example will not act outside the midValue function. <br>  Identifiers defined inside functions have some peculiarity in comparison with those defined on the external level ‚Äî they can be redefined using the word <font color="#0000ff">let</font> .  This is useful because it allows you not to invent all new, and most often, little meaningful names for holding intermediate values.  For example, in the previous example we could write this: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> midValue ab = <br> <font color="#0000ff">let</font> k = b - a <br> <font color="#0000ff">let</font> k = k / 2 <br> k + a <br></font></code> </blockquote><br>  Moreover, since this redefinition is in the full sense, and not a change in the value of a variable, we can easily change not only the value of the identifier, but also its type. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> changingType () = <br> <font color="#0000ff">let</font> k = 1 <br> <font color="#0000ff">let</font> k = <font color="#A31515">"string"</font> <br></font></code> </blockquote><br>  F # makes it possible in most cases to do without cycles at all at the expense of the batch functions for processing the sequences map, list, fold, etc., however, in those cases where it is necessary, recursion can be used.  What is easier to understand, a cycle or a recursion is a whole open question, in my opinion, both are perfectly possible.  In order for a function in F # to be able to refer to itself within its definition, it is necessary to add the keyword <font color="#0000ff">rec</font> after the <font color="#0000ff">let</font> . <br><br>  F # is a strongly typed language, that is, you cannot use functions with values ‚Äã‚Äãof the wrong type.  Functions, like any values, have their own type.  F # in many cases itself displays the type of the function, while it can be determined ambiguously, for example: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> square x = x*x <br></font></code> </blockquote><br>  has type 'a <font color="#0000ff">-&gt;</font> ' a, where 'a can be int, float, and generally speaking anyone for which the * operator is overloaded. <br>  If necessary, the type of the parameter of the function can be set yourself (for example, when you need to use the class methods): <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> parent (x:XmlNode) = x.ParentNode <br></font></code> </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Lambda and Operators </h4><br>  F # supports anonymous functions or lambdas, which are used if there is no need to name the function when it is passed as a parameter to another function.  Lambda example below: <br><blockquote> <code><font color="black">List.map (fun x <font color="#0000ff">-&gt;</font> x**2) [1..10] <br></font></code> </blockquote><br>  This function will display a list consisting of squares of all numbers from one to ten. <br>  In addition, in F # there is another way to define lambda using the <font color="#0000ff">function</font> keyword.  A lambda defined in this way can contain a pattern matching operation within itself, but it takes only one parameter.  But even in this case, it is possible to preserve the curvature of the function: <br><blockquote> <code><font color="black"><font color="#0000ff">function</font> x <font color="#0000ff">-&gt;</font> <font color="#0000ff">function</font> y <font color="#0000ff">-&gt;</font> x + y <br></font></code> </blockquote><br>  Lambda in F # supports <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BC%25D1%258B%25D0%25BA%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">closure</a> , but this will be discussed in more detail in the second part of the review. <br>  In F #, operators (unary and binary) can be considered as a more aesthetic way to call functions.  As in C #, operators are overloaded, so they can be used with different types, however, unlike C #, the operator cannot be applied to operands of different types, that is, strings with numbers cannot be added (and even integers with real ones); do a ghost <br>  F # allows you to overload operators, or define your own. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> (+) ab = a - b <br> printfn "%d" (1 + 1) <font color="#A31515">// "0"</font> <br></font></code> </blockquote><br>  Operators can be any sequence of the following characters! $% &amp; * + _. / &lt;=&gt;? @ ^ | ~: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> (+:*) ab = (a + b) * a * b <br> printfn <font color="#A31515">"%d"</font> (1 +:* 2) <font color="#A31515">// "6"</font> <br></font></code> </blockquote><br><br><h4>  Initializing Lists </h4><br>  Another powerful F # technique is list initialization, which allows you to create fairly complex lists, arrays, and sequences (equivalent to IEnumerable) directly, using special syntax.  Lists are specified in square brackets [], sequences are specified in {}, arrays are specified in [|  |]. <br>  The simplest way is to define a space, which is specified using (..), for example: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> lst = [1 .. 10] <br> <font color="#0000ff">let</font> seq = { <font color="#A31515">'a'</font> .. <font color="#A31515">'z'</font> } <br></font></code> </blockquote><br>  Also, by adding another (..) you can set the selection step in the interval: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> lst = [1 .. 2 .. 10] <font color="#A31515">// [1, 3, 5, 7, 9]</font> <br></font></code> </blockquote><br>  In addition, when creating lists, you can use cycles (cycles can be either single or nested to any degree) <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> lst = [for i <font color="#0000ff">in</font> 1..10 <font color="#0000ff">-&gt;</font> i*i] <font color="#A31515">// [1, 4, 9,..]</font> <br></font></code> </blockquote><br>  However, this is not all.  When initializing lists, you can explicitly specify which elements to add using the <font color="#0000ff">yield</font> (adds one element to the sequence) and <font color="#0000ff">yield!</font>  (adds many elements), and you can also use any logical constructions, cycles, comparisons with the template.  For example, this is how the creation of a sequence of names for all files contained in this folder and in all its subfolders looks like: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">rec</font> xamlFiles dir filter = <br> seq { <font color="#0000ff">yield!</font> Directory.GetFiles(dir, filter) <br> <font color="#0000ff">for</font> subdir <font color="#0000ff">in</font> Directory.GetDirectories(dir) <font color="#0000ff">do</font> <font color="#0000ff">yield!</font> xamlFiles subdir filter} <br></font></code> </blockquote><br><br><h4>  Pattern comparison </h4><br>  Comparison with the template is a bit like a conventional conditional statement or switch, but it has much more functionality.  In general, the syntax of the operation is as follows: <br><blockquote> <code><font color="black"><font color="#0000ff">match</font>  <font color="#0000ff">with</font> <br> [|]1|2|..|10 <font color="#0000ff">-&gt;</font> 1 <br> |11 <font color="#0000ff">when</font> 1 <font color="#0000ff">-&gt;</font> 2 <br> ... <br></font></code> </blockquote><br>  Comparison with templates goes from top to bottom, so you should not forget that narrower templates should be placed higher.  The most common pattern is: _ (underscore), and means that we are not interested in the value of the identifier.  In addition, the comparison with the template must be complete (there are no unexamined capabilities) and all calculations must produce a result of the same type. <br>  The simplest type of template operation compares an identifier with a certain value (numeric, string). Using the <font color="#0000ff">when</font> keyword, you can add a condition to the template, so that calculations will be performed <br>  If another identifier is substituted for the value, then the value of the identifier being checked is assigned to it. <br>  The most commonly used pattern comparison options are over tuples and lists.  Let x be a tuple of the form (string * int), then it is possible to write any similar pattern: <br><blockquote> <code><font color="black"><font color="#0000ff">match</font> x <font color="#0000ff">with</font> <br> | <font color="#A31515">""</font> , _ <font color="#0000ff">-&gt;</font> <font color="#A31515">", !"</font> <br> | _, i <font color="#0000ff">when</font> i &gt; 200 <font color="#0000ff">-&gt;</font> <font color="#A31515">", !"</font> <br> | name, age <font color="#0000ff">-&gt;</font> sprintf <font color="#A31515">" %s, %d"</font> name age <br> | _ <font color="#0000ff">-&gt;</font> <font color="#A31515">"   "</font> <br></font></code> </blockquote><br>  Note that if there are identifiers in the template, they are automatically determined by the corresponding values, and the name and age fields can be used separately in processing. <br>  The list is processed in exactly the same way (which in fact is not even a list, but a marked-up union (discriminated union), which are discussed below).  Usually, templates for a list ('a list) appear either as [] if it is empty, or head :: tail where head is of the type' a, and tail is' a of the list, however other options are possible, for example: <br><blockquote> <code><font color="black"><font color="#0000ff">match</font> lst <font color="#0000ff">with</font> <br> |[x;y;z] <font color="#0000ff">-&gt;</font> <font color="#A31515">//lst   ,     xy z.</font> <br> |1::2::3::tail <font color="#0000ff">-&gt;</font> <font color="#A31515">// lst   [1,2,3] tail   </font> <br></font></code> </blockquote><br>  When comparing with a template, the ability to pass in identifiers of values ‚Äã‚Äãis so useful that in F # there is the possibility of such an assignment directly, without using a template syntax, like this: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> (name, age) = x <br></font></code> </blockquote><br>  or even like this: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> (name, _) = x <br></font></code> </blockquote><br>  if we are only interested in the first element of the tuple. <br><br><h4>  Records </h4><br>  Records (record) in F # are similar to tuples, with the difference that each field has a name in them.  The entry definition is enclosed in braces and separated by a semicolon. <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> org = { boss : string; tops :string list } <br> <font color="#0000ff">let</font> Microsoft = { boss = <font color="#A31515">"Bill Gates"</font> ; tops = [ <font color="#A31515">"Steve Balmer"</font> , <font color="#A31515">"Paul Allen"</font> ]} <br></font></code> </blockquote><br>  The entry fields are accessed, as usual, through a dot.  Entries can mimic classes, as shown below. <br><br><h4>  Marked union </h4><br>  This type in F # allows you to store data that has a different structure and meaning.  For example, this is the type: <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> Distance = <br> |Meter <font color="#0000ff">of</font> float <br> |Feet <font color="#0000ff">of</font> float <br> |Mile <font color="#0000ff">of</font> float <br> <br> <font color="#0000ff">let</font> d1 = Meter 10 <br> <font color="#0000ff">let</font> d2 = Feet 65.5 <br></font></code> </blockquote><br>  Although all three types of data are of the same type (which is optional), they are obviously different in meaning.  Processing of tagged associations is always done through comparison with the template. <br><blockquote> <code><font color="black"><font color="#0000ff">match</font> x <font color="#0000ff">with</font> <br> |Meter x <font color="#0000ff">-&gt;</font> x <br> |Feet x <font color="#0000ff">-&gt;</font> x*3.28 <br> |Mile x <font color="#0000ff">-&gt;</font> x*0.00062 <br></font></code> </blockquote><br>  As already mentioned, such a common data type as a list is a markup union.  Its informal definition looks like this: <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> a' list = <br> |[] <br> |:: <font color="#0000ff">of</font> a' * List <br></font></code> </blockquote><br>  By the way, as is noticeable from the above example, marked sets in F # can be parameterized in the manner of generics. <br><br><h2>  F # imperative </h2><br><br><h4>  Type of unit </h4><br>  The unit type is related to the void type of C #.  If the function takes no arguments, then its input type is unit; if it returns no value, its output type is unit.  For functional programming, a function that does not accept or return a value is of no value, but in the imperative paradigm it has value due to side effects (for example, input-output). The only value of the type unit is ().  Such a function takes nothing and does nothing (unit -&gt; unit). <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> doNothingWithNothing () = () <br></font></code> </blockquote><br>  The parentheses after the name mean that this is a function with an empty input, and not a value.  As we have said, functions are values, but there is a big difference between functional and non-functional values ‚Äã‚Äã- the second is calculated only once, and the first is with each call. <br>  Any function that returns a value can be converted to a function that returns the type unit using the ignore function.  Using it, we kind of tell the compiler that in this function we are only interested in the side effect, not the return value. <br><br><h4>  Keyword mutable </h4><br>  As we know, in general, identifiers in F # can be defined by some value, but this value cannot be changed.  However, good old imperative variables are still useful, so F # provides a mechanism for creating and using variables.  To do this, you must write the <font color="#0000ff">mutable</font> keyword in front of the variable name, and you can change the value using the <font color="#0000ff">&lt;-</font> operator. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">mutable</font> i = 0 <br> i <font color="#0000ff">&lt;-</font> i + 1 <br></font></code> </blockquote><br>  However, the use of such variables is limited, for example, they cannot be used in internal functions, as well as for closure in lambdas.  This code will generate an error: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> mainFunc () = <br> <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> i = 0 <br> <font color="#0000ff">let</font> subFunc () = <br> i <font color="#0000ff">&lt;-</font> 1 <br></font></code> </blockquote><br><br><h4>  Ref type </h4><br>  In F #, there is another way to define variables using the type <font color="#0000ff">ref</font> .  To do this, you just need to put the <font color="#0000ff">ref</font> keyword before the calculations, which represent the value of the identifier. <br>  In order to assign a different value to a variable, the nostalgic operator is painfully used: =, the variable is referenced by adding!  before the variable name. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> i = <font color="#0000ff">ref</font> 0 <br> i := !i + 1 <br></font></code> </blockquote><br>  Perhaps this notation is not as neat as the previous one, which is only the use of an exclamation mark to get the value (for negation in F # there is the keyword not) <br>  However, unlike the <font color="#0000ff">mutable</font> , the <font color="#0000ff">ref</font> type has no restrictions on the scope, so it can be used both in nested functions and in closures.  This code will work: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> i = <font color="#0000ff">ref</font> 2 <br> <font color="#0000ff">let</font> lst = [1..10] <br> List.map (fun x <font color="#0000ff">-&gt;</font> x * !i) lst <br></font></code> </blockquote><br><br><h4>  Arrays </h4><br>  In F #, there are arrays that are mutable.  Values ‚Äã‚Äãinside an array can be reassigned, unlike values ‚Äã‚Äãin lists.  Arrays are specified in brackets [| |  |], items in it are listed separated by a semicolon.  The access to the array element is done through. [Ind], and the assignment is done by the <font color="#0000ff">&lt;&lt;-</font> operator familiar with working with mutables.  All functions for processing arrays (almost similar to the methods for processing lists) are in the class Array. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> arr = [|1; 2; 3|] <br> arr.[0] <font color="#0000ff">&lt;-</font> 10 // [|10,2,3|] <br></font></code> </blockquote><br>  Arrays can be initialized in exactly the same way as lists, using .., yield, etc. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> squares = [| <font color="#0000ff">for</font> x <font color="#0000ff">in</font> 1..9 <font color="#0000ff">-&gt;</font> x,x*x |] // [| (1,1);(2,4);...;(9,81) |] <br></font></code> </blockquote><br>  F # also allows you to create multi-dimensional arrays, both ‚Äústepped‚Äù (with subarrays of different lengths) and ‚Äúmonolithic‚Äù. <br><br><h4>  Control logic </h4><br>  In F #, you can use the usual imperative control logic - the conditional operator <font color="#0000ff">if</font> ... <font color="#0000ff">then</font> ... <font color="#0000ff">else</font> , as well as <font color="#0000ff">for</font> and <font color="#0000ff">while</font> loops. <br>  It should be remembered that the <font color="#0000ff">if statement</font> can also be viewed as a function, which means it must, under any condition, produce a value of the same type.  This also implies that the use of <font color="#0000ff">else is</font> mandatory.  In fact, there is one exception - when the calculations with the performed condition return the type unit: <br><blockquote> <code><font color="black"><font color="#0000ff">if</font> System.DateTime.Now.DayOfWeek = System.DayOfWeek.Sunday <font color="#0000ff">then</font> <br> printfn <font color="#A31515">" !"</font> <br> printfn <font color="#A31515">"  !"</font> <br></font></code> </blockquote><br>  Shifts are also used to determine which functions are related to the cycle, which are not.  For example, in the upper example, the second sentence will be displayed regardless of the day of the week. <br>  The <font color="#0000ff">for</font> loop in F # is of type unit, so calculations in the body of the loop must produce this type, otherwise the compiler will generate a warning. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> arr = [|1..10|] <br> <font color="#0000ff">for</font> i = 0 <font color="#0000ff">to</font> Array.length arr - 1 <font color="#0000ff">do</font> <br> printfn arr.[i] <br></font></code> </blockquote><br>  If you want to go in the opposite direction, then <font color="#0000ff">to</font> is replaced by <font color="#0000ff">downto</font> , as in the good old days. <br>  You can also use another form of the <font color="#0000ff">for</font> loop, similar to everyone you know foreach: <br><blockquote> <code><font color="black"><font color="#0000ff">for</font> item <font color="#0000ff">in</font> arr <br> print_any item <br></font></code> </blockquote><br>  The <font color="#0000ff">while loop is</font> also quite common and familiar to the imperative programmer, its body is located between the keywords <font color="#0000ff">do</font> and <font color="#0000ff">done</font> , but the second can be optionally omitted using the shift system. <br><br><h4>  Calling static methods and objects from .NET libraries </h4><br>  In F #, you can use the entire set of .NET tools, however, it is obvious that all methods not written under F # do not have the property of curvature, so they need to be given arguments in the form of a tuple corresponding in type to the set of input elements.  At the same time, the call record will not be a jot different from sisharp: <br><blockquote> <code><font color="black"><font color="#0000ff">#light</font> <br> <font color="#0000ff">open</font> System.IO <br> <font color="#0000ff">if</font> File.Exists( <font color="#A31515">"file.txt"</font> ) <font color="#0000ff">then</font> <br> printf <font color="#A31515">"  !"</font> <br></font></code> </blockquote><br>  However, if you really want the .NET method to have curvature, you need to import it, like this: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> exists file = File.Exists(file) <br></font></code> </blockquote><br>  Using objects is just as easy - they are created using the <font color="#0000ff">new</font> keyword (who would have thought?), And using the appropriate tuple of constructor parameters.  An object can be assigned to an identifier using <font color="#0000ff">let</font> .  method call is similar to static, fields are changed using <font color="#0000ff">&lt;-</font> . <br><blockquote> <code><font color="black"><font color="#0000ff">#light</font> <br> <font color="#0000ff">let</font> file = <font color="#0000ff">new</font> FileInfo( <font color="#A31515">"file.txt"</font> ) <br> <font color="#0000ff">if</font> not file.Exists <font color="#0000ff">then</font> <br> using (file.CreateText()) (fun stream <font color="#0000ff">-&gt;</font> <br> stream.WriteLine( <font color="#A31515">"Hello world"</font> )) <br> file.Attributes <font color="#0000ff">&lt;-</font> FileAttributes.ReadOnly <br></font></code> </blockquote><br>  F # allows you to initialize the fields immediately when you create an object, like this: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> file = <font color="#0000ff">new</font> FileInfo( <font color="#A31515">"file.txt"</font> , Attributes = FileAttributes.ReadOnly) <br></font></code> </blockquote><br><br><h4>  Using events in F # </h4><br>  Each event in F # has an Add method that adds a handler function to the event.  The handler function must be of type 'a <font color="#0000ff">-&gt;</font> unit.  Here's how to subscribe to a timer event: <br><blockquote> <code><font color="black"><font color="#0000ff">#light</font> <br> <font color="#0000ff">open</font> System.Timers <br> <font color="#0000ff">let</font> timer = <font color="#0000ff">new</font> Timer(Interval=1000, Enabled=true) <br> timer.Elapsed.Add(fun _ <font color="#0000ff">-&gt;</font> printfn <font color="#A31515">"Timer tick!"</font> ) <br></font></code> </blockquote><br>  Cancellation of an event is done using the Remove method. <br><br><h4>  Operator |&gt; </h4><br>  The forwarding operator |&gt; is defined as follows: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> (|&gt;) fg = gf <br></font></code> </blockquote><br>  It passes the first argument as a parameter to the second argument.  The second argument, of course, must be a function that takes a value of type f as the only parameter.  By the way, precisely because of the possibility of using the forwarding operator, all functions on lists (iter, map, fold) take the list itself last.  Then, as g, you can use an undefined function: <br><blockquote> <code><font color="black">[1..10] |&gt; List.iter (fun i <font color="#0000ff">-&gt;</font> print_int i) <br></font></code> </blockquote><br>  For example, the iter function has the form ('a list <font color="#0000ff">-&gt;</font> unit) <font color="#0000ff">-&gt;</font> ' a list <font color="#0000ff">-&gt;</font> unit, setting the first parameter to lambda, we get a function of the type 'a list <font color="#0000ff">-&gt;</font> unit, which just takes as an argument the list defined before the statement. <br>  The programs often use long chains of forwarding operators, each of which processes the value obtained by the previous one, a sort of conveyor. <br><br><h2>  F # object oriented </h2><br>  I think very few people are willing to argue with the fact that the object-oriented paradigm is currently the flagship of programming, and of course, F # could not ignore the concepts inherent in it.  Let's see what he offers us. <br><br><h4>  Typification. </h4><br>  In F #, it is possible to explicitly change the static value type.  For F #, two different operators are used to bring up and down.  The reduction upwards, i.e. the assignment to a static type of a value of the type of one of its ancestors, is done by the operator:&gt;.  The value of strObj in the lower example will be of type object. <br><blockquote> <code><font color="black"><br> <font color="#0000ff">let</font> strObj = ( <font color="#A31515">"-, -"</font> :&gt; obj) <br></font></code> </blockquote><br>  The assignment down, i.e., the specification of the type of a value by the type of one of its descendants, is carried out by the operator:?&gt; <br>  To check the value type (analogue is from C #), use the operator:?, Which can be used not only in logical constructions, but also when compared with a template. <br><blockquote> <code><font color="black"><font color="#0000ff">match</font> x <font color="#0000ff">with</font> <br> |:? string <font color="#0000ff">-&gt;</font> printf <font color="#A31515">" !"</font> <br> |:? int <font color="#0000ff">-&gt;</font> printf <font color="#A31515">" !"</font> <br> |:? obj <font color="#0000ff">-&gt;</font> printf <font color="#A31515">" !"</font> <br></font></code> </blockquote><br>  Usually, F # does not take into account the hierarchy of type inheritance when calculating functions, that is, it does not allow to use a type-successor as an argument.  For example, such a program will not compile: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> showForm (form:Form) = <br> form.Show() <br> <font color="#0000ff">let</font> ofd = <font color="#0000ff">new</font> OpenFileDialog(); <br> showForm ofd <br></font></code> </blockquote><br>  In principle, you can explicitly give the type: showForm (ofd:&gt; Form), but F # provides another way - to add a # sign in front of the type in the function signature. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> showForm (form: #Form) = <br> form.Show() <br></font></code> </blockquote><br>  Thus, a certain function will take as its argument an object of any class inherited from the Form. <br><br><h4>  Records and Connections as Objects </h4><br>  Methods can be added to the records and associations.  To do this, after defining the entry, you must add the keyword <font color="#0000ff">with</font> , after defining all the methods write <font color="#0000ff">end</font> , and before the identifier of each method use the <font color="#0000ff">member</font> keyword: <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> Point ={ <br> <font color="#0000ff">mutable</font> x: int; <br> <font color="#0000ff">mutable</font> y: int; } <br> <font color="#0000ff">with</font> <br> <font color="#0000ff">member</font> p.Swap() = <br> <font color="#0000ff">let</font> temp = px <br> px <font color="#0000ff">&lt;-</font> py <br> py <font color="#0000ff">&lt;-</font> temp <br> <font color="#0000ff">end</font> <br></font></code> </blockquote><br>  Notice that the p parameter specified before the method name is used inside it to access the fields. <br><br><h4>  Classes and Interfaces </h4><br>   F#      <font color="#0000ff">type</font> ,     ,      <font color="#0000ff">class</font> .      <font color="#0000ff">end</font> .  ,   ,         <font color="#0000ff">new</font> . <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> construct = <font color="#0000ff">class</font> <br> <font color="#0000ff">new</font> () = {} <br> <font color="#0000ff">end</font> <br> <font color="#0000ff">let</font> inst = <font color="#0000ff">new</font> construct() <br></font></code> </blockquote><br>  ,           ,    ! F#     ,  C#. <br>   ,        <font color="#0000ff">val</font> . <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> File = <font color="#0000ff">class</font> <br> <font color="#0000ff">val</font> path: string <br> <font color="#0000ff">val</font> info : FileInfo <br> <font color="#0000ff">new</font> () = <font color="#0000ff">new</font> File( <font color="#A31515">"default.txt"</font> ) <br> <font color="#0000ff">new</font> (path) = <br> { path = path; <br> info = <font color="#0000ff">new</font> FileInfo(path) } <br> <font color="#0000ff">end</font> <br> <font color="#0000ff">let</font> file1 = <font color="#0000ff">new</font> File( <font color="#A31515">"sample.txt"</font> ) <br></font></code> </blockquote><br>  ,      .       ,     . ,           .      ,     <font color="#0000ff">then</font> ,      : <br><blockquote> <code><font color="black"><font color="#0000ff">new</font> (path) <font color="#0000ff">as</font> x = <br> { path = path; <br> info = <font color="#0000ff">new</font> FileInfo(path) } <br> <font color="#0000ff">then</font> <br> <font color="#0000ff">if</font> not x.info.Exists <font color="#0000ff">then</font> printf <font color="#A31515">" !"</font> <br></font></code> </blockquote><br>     ,     ,      <font color="#0000ff">mutable</font> . <br>   F#     : <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> ISampleInterface = interface <br> abstract Change : newVal : int <font color="#0000ff">-&gt;</font> unit <br> <font color="#0000ff">end</font> <br> <br> <font color="#0000ff">type</font> SampleClass = <font color="#0000ff">class</font> <br> <font color="#0000ff">val</font> <font color="#0000ff">mutable</font> i : int <br> <font color="#0000ff">new</font> () = { i = 0} <br> interface ISampleInterface <font color="#0000ff">with</font> <br> <font color="#0000ff">member</font> x.Change y = xi <font color="#0000ff">&lt;-</font> y <br> <font color="#0000ff">end</font> <br> <font color="#0000ff">end</font> <br></font></code> </blockquote><br> F#        ‚Äî  .       ,         .       ,    let,   .         .          <font color="#0000ff">member</font> .    : <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> Counter (start, inc, length) = <font color="#0000ff">class</font> <br> <font color="#0000ff">let</font> finish = start + length <br> <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> current = start <br> <font color="#0000ff">member</font> c.Current = current <br> <font color="#0000ff">member</font> c.Inc () = <br> <font color="#0000ff">if</font> current &gt; finish <font color="#0000ff">then</font> failwith <font color="#A31515">"-!"</font> <br> current <font color="#0000ff">&lt;-</font> current + inc <br> <font color="#0000ff">end</font> <br> <br> <font color="#0000ff">let</font> count = <font color="#0000ff">new</font> Counter(0, 5, 100) <br> count.Inc() <br></font></code> </blockquote><br> F#   C#    ,    .       <font color="#0000ff">inherit</font>     <font color="#0000ff">class</font> : <br><blockquote> <code><font color="black"><br> <font color="#0000ff">type</font> Base = <font color="#0000ff">class</font> <br> <font color="#0000ff">val</font> state : int <br> <font color="#0000ff">new</font> () = {state = 0} <br> <font color="#0000ff">end</font> <br> <br> <font color="#0000ff">type</font> Sub = <font color="#0000ff">class</font> <br> <font color="#0000ff">inherit</font> Base <br> <font color="#0000ff">val</font> otherState : int <br> <font color="#0000ff">new</font> () = {otherState = 0} <br> <font color="#0000ff">end</font> <br></font></code> </blockquote><br>       .          .      ,              <font color="#0000ff">inherit</font> . <br>   F#   : <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> PropertySample = <font color="#0000ff">class</font> <br> <font color="#0000ff">let</font> <font color="#0000ff">mutable</font> field = 0 <br> <font color="#0000ff">member</font> x.Property <br> <font color="#0000ff">with</font> get () = field <br> and set v = field <font color="#0000ff">&lt;-</font> rand <br> <font color="#0000ff">end</font> <br></font></code> </blockquote><br>      <font color="#0000ff">member</font>    <font color="#0000ff">static</font>   ,   : <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> StaticSample = <font color="#0000ff">class</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">member</font> TrimString (st:string) = st.Trim() <br> <font color="#0000ff">end</font> <br></font></code> </blockquote><br><br><h2>  Conclusion </h2><br><br>        ,       - . <br>  ,  ,      ,   C#,      F#,        -,    .      ,   ,   ,    .   ,    F#,     (      ,     </div><p>Source: <a href="https://habr.com/ru/post/55272/">https://habr.com/ru/post/55272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../55265/index.html">Namespaces in memcahced</a></li>
<li><a href="../55267/index.html">Rota-Rota Combo - USB Hub with Thermometer</a></li>
<li><a href="../55268/index.html">Updated: Screw Torrents.ru to Vuze</a></li>
<li><a href="../55269/index.html">The most profitable social network in the world</a></li>
<li><a href="../55270/index.html">Habrachat</a></li>
<li><a href="../55279/index.html">Lenovo presents concept Pocket Yoga</a></li>
<li><a href="../55281/index.html">RusCHI. Seminar number 20 "Psychological concepts of activity analysis" (Moscow - 03/31/2009)</a></li>
<li><a href="../55282/index.html">Preliminary caching support</a></li>
<li><a href="../55283/index.html">Attention! Passwords!</a></li>
<li><a href="../55284/index.html">Move the cursor down</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>