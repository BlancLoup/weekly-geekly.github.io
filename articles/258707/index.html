<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Digestible call of Java methods from native code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are quite a few Android applications that combine C ++ and Java code. Where Java acts as a wrapper / interlayer, and C ++ does all the dirty wor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Digestible call of Java methods from native code</h1><div class="post__text post__text-html js-mediator-article">  There are quite a few Android applications that combine C ++ and Java code.  Where Java acts as a wrapper / interlayer, and C ++ does all the dirty work.  Perhaps a prime example is the game.  In this regard, it is often necessary to call Java code from the native access to system properties and the buns that the system provides (switch to another activity, send or download something from the Internet).  There are many reasons, but one problem: every time, at best, you have to write 5 lines of code and remember which function signature to push into the parameter.  Then you still need to translate these parameters to the desired type.  Standard example from tutorials: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, String s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g)</span></span></span></span>;</code> </pre> <br>  The signature string for this method will be <b>(ILjava / lang / String; F) J.</b> <br><br>  Is it convenient for you to memorize everything?  And translate C strings to jstring?  I do not.  I want to write: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs">CallStaticMethod&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(className, ‚Äúf‚Äù, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1.2f</span></span>);</code> </pre><br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br>  First, let's understand what we need.  In essence, these are four things: <br><br><ol><li>  Call a method; </li><li>  From the parameters you need to pull the signature line.  Yes, yes, this one (ILjava / lang / String; F) J; </li><li>  Convert parameters to the desired type; </li><li>  Return the data type that the user of our class wants to see. </li></ol><br>  Actually, that's all.  It seems to be simple.  Let's start? <br><br><h3>  Method call </h3><br>  Now it's worth noting how we will call our wrapper function.  Since there are different numbers of parameters (from zero and more), we need a function like print in the standard library, but in order to make it convenient to pull the parameter type and the parameter itself.  In C ++ 11, variadic templates appeared.  And we will use them. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-function">MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args... args)</span></span></span></span>;</code> </pre><br><h3>  Make a signature </h3><br>  First we need to get the string that is listed in the documentation for this type.  There are two options: <br><ol><li>  Use typeid and if ... else chain.  You should get something like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(arg) == <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚ÄúI‚Äù; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(arg) == <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚ÄúF‚Äù;</code> </pre><br>  And so for all the types that you need. </li><li>  We use templates and their partial typifications.  The method is interesting because you will have functions in one line and there will be no unnecessary type comparisons.  Moreover, all this will be at the stage of instantiation of templates.  Everything will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// int template &lt;&gt; std::string GetTypeName&lt;int&gt;() { return ‚ÄúI‚Äù; } // string template &lt;&gt; std::string GetTypeName&lt;const char*&gt;() { return ‚ÄúLjava/lang/String;‚Äù; }</span></span></code> </pre><br></li></ol><br>  There are two ways to create signature strings in ours: recursive and through an array.  First consider the recursive call. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeRecursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeRecursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; signatureString, T value, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ signatureString += GetTypeName&lt;T&gt;(); GetTypeRecursive(signatureString, args...); }</code> </pre><br>  The challenge of all this lewdness: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-function">MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* className, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mname, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signature_string = <span class="hljs-string"><span class="hljs-string">"("</span></span>; GetTypeRecursive(signature_string, args...); signature_string += <span class="hljs-string"><span class="hljs-string">")"</span></span>; signature_string += GetTypeName&lt;MethodType&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodType(); <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  Recursion is good for educational purposes, but I prefer to bypass it whenever possible.  There is such an opportunity.  Since the arguments go sequentially and we can find out the number of arguments, you can use the convenience <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">provided by the C ++ 11 standard</a> .  The code is converted to: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-function">MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* className, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mname, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> arg_num = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signatures[arg_num] = { GetType(args)... }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signature_string; signature_string.reserve(<span class="hljs-number"><span class="hljs-number">15</span></span>); signature_string += <span class="hljs-string"><span class="hljs-string">"("</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg_num; ++i) signature_string += signatures[i]; signature_string += <span class="hljs-string"><span class="hljs-string">")"</span></span>; signature_string += GetTypeName&lt;MethodType&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodType(); <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  Code seems to be more, but it works faster.  At least due to the fact that we do not call more functions than we need it. <br><br><h3>  Data type conversion </h3><br>  There are <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html">several options for calling</a> CallStaticMethod: <br><br><pre> <code class="cpp hljs">NativeType CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...); NativeType CallStatic&lt;type&gt;MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args); NativeType CallStatic&lt;type&gt;MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</code> </pre><br>  After <s>torture</s> attempts and tricks, it was decided to use CallStaticMethodA (JNIEnv *, jclass, jmethodID, jvalue *).  Now you just need to bring all the parameters to jvalue.  The jvalue itself is a union in which you need to set the required field depending on the type of data that your favorite users gave you.  We will not be wise and create a structure (or class; matter of taste) JniHolder with constructors of the necessary types. <br><br><div class="spoiler">  <b class="spoiler_title">Jniholder</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JniHolder</span></span></span><span class="hljs-class"> {</span></span> jvalue val; JObjectHolder jObject; <span class="hljs-comment"><span class="hljs-comment">// bool explicit JniHolder(JNIEnv *env, bool arg) : jObject(env, jobject()) { val.z = arg; } // byte explicit JniHolder(JNIEnv *env, unsigned char arg) : jObject(env, jobject()) { val.b = arg; } // char explicit JniHolder(JNIEnv *env, char arg) : jObject(env, jobject()) { val.c = arg; } // short explicit JniHolder(JNIEnv *env, short arg) : jObject(env, jobject()) { val.s = arg; } // int explicit JniHolder(JNIEnv *env, int arg) : jObject(env, jobject()) { val.i = arg; } // long explicit JniHolder(JNIEnv *env, long arg) : jObject(env, jobject()) { val.j = arg; } // float explicit JniHolder(JNIEnv *env, float arg) : jObject(env, jobject()) { val.f = arg; } // double explicit JniHolder(JNIEnv *env, double arg) : jObject(env, jobject()) { val.d = arg; } // string explicit JniHolder(JNIEnv *env, const char* arg) : jObject(env, env-&gt;NewStringUTF(arg)) { val.l = jObject.get(); } // object explicit JniHolder(JNIEnv *env, jobject arg) : jObject(env, arg) { val.l = jObject.get(); } //////////////////////////////////////////////////////// operator jvalue() { return val; } jvalue get() { return val; } };</span></span></code> </pre><br></div></div><br>  Where JObjectHolder is a wrapper for holding and deleting a jobject. <br><br><div class="spoiler">  <b class="spoiler_title">JObjectHolder</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JObjectHolder</span></span></span><span class="hljs-class"> {</span></span> jobject jObject; JNIEnv* m_env; JObjectHolder() : m_env(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) {} JObjectHolder(JNIEnv* env, jobject obj) : jObject(obj) , m_env(env) {} ~JObjectHolder() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jObject &amp;&amp; m_env != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) m_env-&gt;DeleteLocalRef(jObject); } <span class="hljs-function"><span class="hljs-function">jobject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jObject; } };</code> </pre><br></div></div><br>  A JniHolder object is created, to which the JNIEnv * and value are passed.  In the constructor, we know which field needs to be set in jvalue.  In order to avoid the temptation of the compiler to type types imperceptibly, we make all constructors explicit.  The whole chain takes one line: <br><br><pre> <code class="cpp hljs">jvalue val = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;jvalue&gt;(JniHolder(env, <span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre><br>  But there is one thing.  When conversion occurs, we return jvalue, but jObject is deleted and val.l points to an invalid address.  Therefore, you have to save the holders during the java function call. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JniHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">holder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> jvalue val </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;jvalue&gt;(holder);</code> </pre><br>  In the case of the transfer of several parameters, we use the initialization list: <br><br><pre> <code class="cpp hljs">JniHolder holders[size] = { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(JniHolder(env, args))... }; jvalue vals[size]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; ++i) vals[i] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;jvalue&gt;(holders[i]);</code> </pre><br><h3>  Return the desired data type </h3><br>  I would like to write some one method that resolved the situation and looked like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-function">MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args... args)</span></span></span><span class="hljs-function"> </span></span>{ MethodType result = ...; ‚Ä¶. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reesult; }</code> </pre><br>  But there is an unpleasant feature of JNI: for each return type there is a specific method.  That is, for int you need CallStaticIntMethod, for float, CallStaticFloatMethod and so on.  Came to partial typing patterns.  First, we declare the interface we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass clazz, jmethodID method, Args... args)</span></span></span></span>; };</code> </pre><br>  Then for each type we write an implementation.  For integers (int) will look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class"> &lt;int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass clazz, jmethodID method, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size != <span class="hljs-number"><span class="hljs-number">0</span></span>) { jvalue vals[size] = { <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;jvalue&gt;(JniHolder(env, args))... }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env-&gt;CallStaticIntMethodA(clazz, method, vals); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env-&gt;CallStaticIntMethod(clazz, method); } };</code> </pre><br>  If we have zero parameters, then CallStaticMethod should be called, not CallStaticMetodA.  Well, if you try to create an array of dimension zero, the compiler will tell you everything you think about it. <br><br><h3>  The final </h3><br>  The calling method itself looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MethodType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-function">MethodType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* className, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mname, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> arg_num = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signatures[arg_num] = { GetType(args)... }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> signature_string; signature_string.reserve(<span class="hljs-number"><span class="hljs-number">15</span></span>); signature_string += <span class="hljs-string"><span class="hljs-string">"("</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg_num; ++i) signature_string += signatures[i]; signature_string += <span class="hljs-string"><span class="hljs-string">")"</span></span>; signature_string += GetTypeName&lt;MethodType&gt;(); JNIEnv *env = getEnv(); <span class="hljs-function"><span class="hljs-function">JniClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clazz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(env, className)</span></span></span></span>; jmethodID method = env-&gt;GetStaticMethodID(clazz.get(), mname, signature_string.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Impl&lt;MethodType&gt;::CallStaticMethod(env, clazz.get(), method, args...); }</code> </pre><br>  Now call the method from java: <br><br><div class="spoiler">  <b class="spoiler_title">Java code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String par, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ mOutString += <span class="hljs-string"><span class="hljs-string">"float String: "</span></span> + par + <span class="hljs-string"><span class="hljs-string">" float="</span></span> + x + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } };</code> </pre><br></div></div><br>  Somewhere in the native code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fRes = CallStaticMethod&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"TestMethod"</span></span>, <span class="hljs-string"><span class="hljs-string">"TestString"</span></span>, <span class="hljs-number"><span class="hljs-number">4.2f</span></span>);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Previously, the code looked like</b> <div class="spoiler_text"><pre> <code class="cpp hljs">JNIEnv* env = getEnv(); <span class="hljs-comment"><span class="hljs-comment">// -     jclass clazz = env-&gt;FindClass(‚ÄúTest‚Äù); jmethodID method = env-&gt;GetStaticMethodID(‚ÄúTest‚Äù, ‚ÄúTestMethod‚Äù, ‚Äú(Ljava/lang/String;F)Ljava/lang/String;); jstring str = env-&gt;NewStringUTF(‚ÄúTestString‚Äù); float fRes = env-&gt;CallStaticFloatMethod(clazz, method, str, 4.2f); env-&gt;DeleteLocalRef(clazz); env-&gt;DeleteLocalRef(str);</span></span></code> </pre></div></div><br><h3>  findings </h3><br>  Calls to methods have become a convenient thing, and you don‚Äôt need to memorize signatures and convert values ‚Äã‚Äãand delete references.  It is enough to pass the name of the class, method and arguments. <br><br>  It also turned out to be an interesting task, thanks to which I had a little understanding with the new buns of the language (which I really liked) and remembered the patterns. <br><br>  Thanks for reading.  Well, or for attention, if you have not read everything.  I am pleased to read suggestions for improvement and criticism of the work.  And also answer questions. </div><p>Source: <a href="https://habr.com/ru/post/258707/">https://habr.com/ru/post/258707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258693/index.html">Again about domain-based development (Domain-Driven Design, DDD)</a></li>
<li><a href="../258695/index.html">Oberon in UAV programming</a></li>
<li><a href="../258699/index.html">Robots and 3D printing</a></li>
<li><a href="../258701/index.html">IBM FlashSystem 820 storage system overview and testing</a></li>
<li><a href="../258705/index.html">Geo-targeting by city (region, country) for WordPress</a></li>
<li><a href="../258709/index.html">Transparent transition PgQ -> RabbitMQ</a></li>
<li><a href="../258711/index.html">Podcast "Five Minute PHP"</a></li>
<li><a href="../258715/index.html">The long-awaited domestic processor Baikal-T1 was released</a></li>
<li><a href="../258717/index.html">Windows Preinstallation Network Download Guide (WinPE)</a></li>
<li><a href="../258719/index.html">Remote user experience: Windows Server 2012R2 RDS and Azure RemoteApp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>