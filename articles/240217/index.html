<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lapis: Lua site in Nginx configs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tl; dr Lapis (Lua) = RoR (Ruby) = Django (Python) 


 Introduction 


 Lua is a powerful and fast scripting language that can be easily integrated int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lapis: Lua site in Nginx configs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ead/bc1/5b4/eadbc15b429ccd3a11e56f7098bd6381.png" alt="lapis"><img src="https://habrastorage.org/getpro/habr/post_images/119/914/8f2/1199148f2c93671a9e8d4818ab5e9a5f.png" alt="openresty, Lua, Nginx" height="200"><br><br>  <i>Tl; dr Lapis (Lua) = RoR (Ruby) = Django (Python)</i> <br><a name="habracut"></a><br><br><h2>  Introduction </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/717/6cd/6a2/7176cd6a2550abc85666113c803b6c36.gif" alt="image"><br>  <a href="http://www.lua.org/">Lua</a> is a powerful and fast scripting language that can be easily integrated into C. Developed in PUC-Rio (Brazil). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/6d3/5e2/e666d35e241c7f8475bd1151e2814f1d.png" width="200" alt="LuaJIT"><br>  <a href="http://luajit.org/luajit.html">LuaJIT</a> is the fastest implementation of Lua (JIT compiler), a true work of art.  According to <a href="https://github.com/LewisJEllis/awesome-lua">some estimates</a> , it has a six-fold advantage over the standard Lua interpreter and in <a href="https://attractivechaos.github.io/plb/">many</a> <a href="https://gist.github.com/spion/3049314">tests</a> <a href="https://github.com/starius/lang-bench">beats</a> V8.  Developer Mike Pall (Germany). <br><br>  LuaJIT can also bind C functions and structures on the Lua side (without writing bindings on C): <br><pre><code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ffi = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"ffi"</span></span>) ffi.cdef<span class="hljs-string"><span class="hljs-string">[[int printf(const char *fmt, ...);]]</span></span> ffi.C.printf(<span class="hljs-string"><span class="hljs-string">"Hello %s!\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"wiki"</span></span>)</code> </pre> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6b/d3a/1e3/e6bd3a1e3344a28cf3b6014ccb14cce2.png" width="400" alt="Nginx"><br>  <a href="http://nginx.org/">Nginx</a> is one of the most efficient web servers developed by Igor Sysoev.  Many large sites use Nginx.  Starting from version 0.8, <a href="http://wiki.nginx.org/HttpLuaModule">it</a> is <a href="http://wiki.nginx.org/HttpLuaModule">possible to</a> directly embed the Lua language.  Lua is executed in the Nginx process itself, and not taken out in a separate process, as is the case with other languages.  The Lua code in the Nginx context runs in non-blocking mode, including database requests and external HTTP requests generated by the web application (for example, a request to the API of another site). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73a/651/233/73a651233b6827e484f64e031a4d395b.png" alt="Openresty"><br>  <a href="http://openresty.org/">OpenResty</a> is an assembly of Nginx with a lot of third-party modules, including non-blocking access to popular databases.  Latest versions use LuaJIT to run Lua.  Developer Yichun Zhang (USA, place of work: CloudFlare, the main developer of lua-nginx-module). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b1/684/bfb/3b1684bfb17cc03fa4aa76d99dcc412c.png" alt="MoonScript"><br>  <s>Sailor</s> <a href="http://moonscript.org/">MoonScript</a> is a scripting language that is translated to Lua.  Adds syntactic sugar, makes it easier to write certain things, such as list expressions;  implements classes with inheritance.  You could say that MoonScript for Lua is CoffeeScript for JavaScript.  Developer Leaf Corcoran (USA). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ead/bc1/5b4/eadbc15b429ccd3a11e56f7098bd6381.png" alt="lapis"><br>  <a href="http://leafo.net/lapis/">Lapis</a> is a web framework for writing Lua and MoonScript web applications that lives inside OpenResty.  Developer Leaf Corcoran (USA). <br><br><h2>  What is the advantage of Lua in Nginx? </h2><br>  <i>Tl; dr. All high-level language features and efficient use of resources under heavy loads.</i> <br><br>  For the answer, let's go back to the distant past, when all sites were served by the Apache web server. <br><img src="https://habrastorage.org/getpro/habr/post_images/777/c3e/366/777c3e3664f5d1085af6d2178db913cc.png" alt="Apache"><br>  <i>Delays contribute to the red nodes and edges of the graph.</i>  <i>Yellow shaded components located on the same machine.</i> <br><br>  Apache allocated a separate thread of the operating system, which read the request, performed the processing and sent the result to the user.  (Modern Apache can be taught not to do this.) It turns out how many active requests, so many OS threads, and they are expensive.  In such a scheme, most of the stream lifetime is spent not on processing the request, but on data transmission over the network, limited by the Internet speed of the user. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/219/c85/769/219c8576901227da0cda67f77ba5f307.png" alt="Nginx"><br>  How to deal with it?  We need to instruct the operating system to monitor the transfer of data so that our web server can work only when the network has completed the next task.  This approach is called <i>non-blocking I / O</i> and is implemented in most modern operating systems.  Nginx web server uses this feature, due to which it can serve tens of thousands of simultaneous requests using just one OS thread. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b54/969/8b5/b549698b5d47814d46e616fd18bc49f5.png" alt="Nginx, PHP"><br>  Thus, we optimized data transfer between the browser and the web server, but there is another bottleneck on which OS threads are idle: work with the database and external resources (for example, HTTP-API of another site).  It is important to understand that it‚Äôs not so much the inevitable delays of the database itself or the external API, but the fact that our web application is idle idle until it receives an answer from them. <br><br>  <u>The usual solution</u> : already in the web application itself to generate threads that we have so successfully disposed of in the web server.  <u>Effective solution</u> : make the web application and database communicate in a non-blocking way.  The web application sends the request to the database and immediately proceeds to the next request from the user.  The database counts, returns the result, and the web application, when free, returns to processing the request from the user that originated the database request.  This approach is used, for example, in node.js: <br><img src="https://habrastorage.org/getpro/habr/post_images/130/131/587/1301315875a9c972e1b98be3f772db94.png" alt="node.js"><br>  <i>The database and external APIs are still shaded in red, as they may introduce latency.</i>  <i>The advantage of the approach is that the web application is not just waiting for them, but processes other requests at this time.</i> <br><br>  Wonderful!  Now let's see how external HTTP requests are programmed in node.js: <br><br><pre> <code class="hljs vbscript">var <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = require(<span class="hljs-string"><span class="hljs-string">"request"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"http://www.whatever.com/my.csv"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">response</span></span>, body) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">response</span></span>.statusCode == <span class="hljs-number"><span class="hljs-number">200</span></span>) { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Got body: "</span></span> + body); } });</code> </pre><br>  Suppose we want to download a file from a URL and do something with it.  The result has to be processed in the lambda function.  Uncomfortable?  Is this the inevitable asynchronous fee?  Fortunately, this is not the case;  Let's see the similar code in Lapis: <br><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"lapis.nginx.http"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body, status_code, headers = http.simple(<span class="hljs-string"><span class="hljs-string">"http://www.whatever.com/my.csv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status_code == <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  It is convenient to write the code for Lapis as if it were synchronous, but behind the scenes it is executed completely asynchronously.  This is possible thanks to the active use of <i>coroutines</i> ( <i><a href="http://www.lua.org/pil/9.html">coroutines</a></i> , <i><a href="https://en.wikipedia.org/wiki/Green_threads">green threads</a></i> , and in Lua terminology just <i>threads</i> ).  All code that processes a request from a user is executed in a separate coroutine, and coroutines can stop and continue in certain places.  In our example, such a place was inside the call to the <a href="&amp;xid=17259,1500004,15700022,15700186,15700190,15700253&amp;usg=ALkJrhg18UNlbkN0wTfZAqIlhXR1baMUKQ#making-">http.simple</a> function. <br><br>  Why are coroutines more efficient than OS threads?  Have we not dragged all the overhead into the app?  In fact, the key difference between coroutines and OS threads is the freedom of the programmer, where exactly the coroutine falls asleep and wakes up.  (In the case of OS threads, the decision is made by the OS.) Started a query to the database - put the coroutine that generated the query to sleep.  The answer came from the database - wake up the coroutine and continue its execution.  We do a lot of work at the same time and all in one OS thread! <br><br>  <i>Note.</i>  <i>A similar mechanism <a href="http://wingolog.org/archives/2013/05/08/generators-in-v8">is about to</a> appear in node.js.</i> <br><br>  <i>Note.</i>  <i>I advise you to read a <a href="http://habrahabr.ru/post/201826/">great article</a> about coroutines in the context of C ++.</i>  <i>At the end of the article turned out asynchronous code, written as synchronous, and all thanks to coroutines.</i>  <i>It is a pity that in C ++ coroutines are more of a hack than a generally accepted technique.</i> <br><br>  In addition, Lapis is executed directly in Nginx, which eliminates the overhead of transferring information between Nginx and the web application.  Of course, node.js can be used as the main web server, without Nginx, but then the opportunity to use different features of Nginx is lost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ec/50c/a74/5ec50ca74893cc553edb0debbe07d278.png" alt="lapis"><br><br>  On the other hand, not everyone decides to send Lua code directly into the main Nginx.  In this case, we run a separate Nginx with Lua on behalf of a separate user with reduced rights, but basically Nginx is setting a proxy. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/907/5ba/5a3/9075ba5a34dbf4a00a0ff873b87db344.png" alt="lapis2"><br><br>  The effectiveness of Lapis is confirmed in a 10-gigabit <a href="http://www.techempower.com/benchmarks/">benchmark</a> .  Lapis occupies a leading place at the level of C ++ and Java. <br><br><h2>  Lapis </h2><br>  On April 1, 2014, the April Fools' <a href="http://habrahabr.ru/post/217773/">article ‚ÄúLUA in nginx: inline php noodles‚Äù</a> was published on Habr√©.  The article considered a comic code that implements PHP-like templates on Lua.  Lapis was <a href="http://habrahabr.ru/post/217773/">mentioned</a> in comments to the same article.  I did not find any other references to Lapis on Habr√©, so I decided to write myself. <br><br>  Writing Hello World is boring.  Let's write a simple web proxy instead on Lapis. <br><br><h3>  Install OpenResty </h3><br>  Install perl 5.6.1+, libreadline, libpcre and libssl and make sure that the ldconfig command is available (its parent folder may be missing in the PATH). <br><pre> <code class="hljs ruby">$ wget <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/openresty.org/download</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ngx_openresty-1.7.4.1.tar.gz $ tar xzvf ngx_openresty-1.7.4.1.tar.gz $ cd ngx_openresty-1.7.4.1/</span></span> $ ./configure $ make <span class="hljs-comment"><span class="hljs-comment"># make install</span></span></code> </pre><br><br><h3>  Install Lapis </h3><br>  First you need to install LuaRocks (available in the main distributions). <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># luarocks install lapis</span></span></code> </pre><br><br><h3>  Create a web application </h3><br>  Create the backbone of the site: <br><br><pre> <code class="hljs pgsql">$ lapis <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-comment"><span class="hljs-comment">--lua wrote nginx.conf wrote mime.types wrote app.lua</span></span></code> </pre><br>  If we hadn't passed the --lua option, the backbone in MoonScript would have been created. <br><br>  Now let's implement the logic of our application in app.lua: a form for entering a URL is displayed on the main page of the site.  The form is sent to / geturl, where the page is loaded at the specified URL and content is transferred to the user's browser. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> lapis = require("lapis") <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> app = lapis.Application() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> http = require("lapis.nginx.http") app:<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("/", <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[ &lt;form <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>="POST" action="/geturl"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>="http://ip4.me/" <span class="hljs-type"><span class="hljs-type">name</span></span>="url" /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit" <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>="Get" /&gt; &lt;/form&gt; ]] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) app:post("/geturl", <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> url = self.req.params_post.url <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body, status_code, headers = http.simple(url) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app</code> </pre><br>  The home page simply gives out HTML code with a form.  Double brackets are another notation for strings in Lua.  The / geturl page receives a POST request from the form, extracts the URL entered by the user from the form from it, downloads the content at that URL using the http.simple function (the OS thread is not blocked, see above) and shows the result to the user. <br><br>  For http.simple to work, you need to change nginx.conf: <br><br><pre> <code class="hljs swift"> location / { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> $_url <span class="hljs-string"><span class="hljs-string">""</span></span>; default_type text/html; content_by_lua ' require(<span class="hljs-string"><span class="hljs-string">"lapis"</span></span>).serve(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) '; } location /proxy { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>; rewrite_by_lua ' local req = ngx.req <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs(req.get_headers()) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k ~= <span class="hljs-string"><span class="hljs-string">"content-length"</span></span> then req.clear_header(k) end end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ngx.ctx.headers then <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs(ngx.ctx.headers) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> req.set_header(k, v) end end '; resolver <span class="hljs-number"><span class="hljs-number">8.8</span></span>.<span class="hljs-number"><span class="hljs-number">8.8</span></span>; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_pass $_url; }</code> </pre><br>  This code creates in Nginx location / proxy, through which Lua makes external requests.  In the main location you need to add set $ _url "";  Read more about this in the <a href="&amp;xid=17259,1500004,15700022,15700186,15700190,15700253&amp;usg=ALkJrhg18UNlbkN0wTfZAqIlhXR1baMUKQ#making-">documentation</a> . <br><br>  Run our web proxy: <br><br><pre> <code class="hljs pgsql">$ lapis <span class="hljs-keyword"><span class="hljs-keyword">server</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/ef6/057/18fef6057411f275b588190aa898173b.png" alt="web proxy"><br><br>  Click on the "Get" button.  The site ip4.me shows the IP address of the server on which Lapis is running. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88d/018/bd1/88d018bd17e3c835e2db1d1b68903fb4.png" alt="web-proxy result"><br><br>  <i>If there is no path in the URL, then / proxy is used as the path.</i>  <i>Apparently, this is a Lapis bug, for which a <a href="https://github.com/leafo/lapis/issues/172">report</a> has already been made.</i> <br><br><h2>  Conclusion </h2><br>  In Lapis, Lua and Nginx there are many other interesting things, for example, asynchronous work with <a href="http://leafo.net/lapis/reference/database.html">Postgres</a> database, <a href="http://leafo.net/lapis/reference/database.html">wrapper classes</a> for database objects, <a href="http://leafo.net/lapis/reference/html_generation.html">HTML generation</a> , powerful template language <a href="http://leafo.net/lapis/reference/etlua_templates.html">etlua</a> , <a href="http://leafo.net/lapis/reference/utilities.html">caching of</a> variables between different Nginx workflows, <a href="http://leafo.net/lapis/reference/utilities.html">protection against CSRF</a> , <a href="http://leafo.net/lapis/reference/testing.html">two tools for testing</a> and <a href="http://leafo.net/lapis/reference/lapis_console.html">interactive Lua-console</a> right in the browser.  If the article finds a reader, I will continue the story about Lapis in other articles. <br><br>  Without a doubt, Lapis has long outgrown the level of April Fool's joke and is rapidly gaining ground in the community of web developers.  I wish you a pleasant study of these promising technologies! <br><br><h2>  Links </h2><br><ul><li>  <a href="http://leafo.net/lapis/reference.html">Lapis documentation</a> (the menu is hidden on the left, and on top there is a switch between Lua and MoonScript) </li><li>  <a href="https://github.com/LewisJEllis/awesome-lua">a selection of good links on Lua</a> (projects + tutorials) </li><li>  <a href="http://wiki.nginx.org/HttpLuaModule">HttpLuaModule documentation</a> </li><li>  <a href="http://moonscript.org/">moonScript language</a> </li><li>  opinions on coroutine use on the Web: <a href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">pessimistic</a> , <a href="https://medium.com/code-adventures/callbacks-vs-coroutines-174f1fe66127">optimistic</a> </li><li>  article source codes <a href="https://github.com/starius/harb-lapis/">are available on GitHub</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/240217/">https://habr.com/ru/post/240217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240201/index.html">New Wi-Fi for the Internet of Things (Part 1)</a></li>
<li><a href="../240203/index.html">Substitution Benefit Criterion and Dynamic Profiling</a></li>
<li><a href="../240207/index.html">Print outsourcing: how to save on printing with active paper workflow</a></li>
<li><a href="../240209/index.html">Latent semantic analysis: implementation</a></li>
<li><a href="../240213/index.html">How do we cluster gifts in OK</a></li>
<li><a href="../240219/index.html">Expressive JavaScript: An Introduction</a></li>
<li><a href="../240221/index.html">Development of quadrocopter angular stabilization</a></li>
<li><a href="../240223/index.html">Expressive JavaScript: Values, Types and Operators</a></li>
<li><a href="../240225/index.html">Expressive JavaScript: Program Structure</a></li>
<li><a href="../240227/index.html">How to keep a customer: 5 gorgeous examples of email marketing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>