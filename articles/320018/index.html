<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Customization in 1C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About customization in general 
 The need for customization of software, i.e. its changes to the needs of a particular user appeared, probably, simult...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Customization in 1C</h1><div class="post__text post__text-html js-mediator-article"><h2>  About customization in general </h2><br>  The need for customization of software, i.e.  its changes to the needs of a particular user appeared, probably, simultaneously with the software itself.  It is difficult to write a program that will satisfy everyone, and therefore it is a good idea to lay in it the possibility of change without involving the program manufacturer.  Especially when it comes to business applications, because  business processes even in the same areas may differ in different organizations. <br><br><img src="https://habrastorage.org/files/298/645/474/2986454743ef4a2496f43abb27df9f2d.jpg" alt="image"><br><a name="habracut"></a><br><h3>  Change source code </h3><br>  There are different customization strategies.  If the application comes in source code, then the most obvious approach is to rewrite the source code to fit your needs.  And the most obvious problem in this case is the transition to a new version of the application, since  it entails merging the source codes of the client-modified version and the new version from the supplier.  This can be a nontrivial task, especially if the code on the client side is highly customizable. <br><br><h3>  Plugins </h3><br>  A safer strategy is plugins.  The original application provides the plugin with a fixed set of interfaces, as well as the ability to register itself with the application.  When a new version of the application is released, the plugins written for the previous version will continue to work in the new version (provided that the interfaces remain unchanged).  The behavior of plug-ins in the new version may differ from the behavior of the previous version, if the software vendor has changed the behavior of the application.  The concept of plug-ins is used in a wide variety of software classes - office and business software, development environments (Visual Studio, Eclipse, ...), graphic and sound editors, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Subscriptions </h3><br>  Another customization technology is the ability to subscribe (subscription) to events in the application and execute custom code in a well-known or proprietary language during these events.  Events can be of various types - opening a window, loading an image (for a graphic editor), order processing (for a business system). <br><br>  One of the variations of this approach is to embed the ability to execute custom scripts in languages ‚Äã‚Äãlike Visual Basic for Application ( <a href="https://ru.wikipedia.org/wiki/Visual_Basic_for_Applications">VBA</a> ) into the main program.  Custom code can, in particular, be executed in response to application events.  The same VBA proved to be a very powerful and flexible means of customization;  It is built into Microsoft Office, AutoCAD, SolidWorks, CorelDRAW, WordPerfect, ESRI ArcGIS, and other products. <br><br><h2>  Customization in the solutions "1C": the beginning </h2><br>  The 1C: Enterprise platform implements different customization strategies.  Since 1C application solutions are supplied in source codes, naturally, one of the most obvious scenarios is a change in the source code. <br><br><h3>  Change the source code of applications 1C </h3><br>  When a client changes the source code of a 1C solution to fit his needs, he needs to remember that the application provider is also not inactive and releases new versions, adding functionality and correcting errors.  So that when installing the new version of the application, the changes made to the needs of the client are not lost, you need to somehow merge the modified previous version of the application and the new version. <br><br>  Naturally, we in 1C paid great attention to this task and developed <a href="http://v8.1c.ru/overview/Term_000000290.htm">a delivery and support mechanism</a> that facilitates its solution.  Before telling how it works - a couple of details about the internal device solutions "1C". <br><br>  Source codes and metadata of the applied solution ‚Äú1C‚Äù (configurations) are stored in the database, in the same one in which the data of the application itself (wiring, data of reference books and documents, etc.), i.e.  the program is stored with the data.  A database with a configuration (and application data) in the terminology of 1C is called an information database (abbreviated as infobase). <br><br>  During the development process, the configuration provider determines which configuration objects (directories, documents, etc.) the client can change, and which not. <br><br><img src="https://habrastorage.org/files/48d/631/db1/48d631db1f9947fa8f935c6c9644067e.png" alt="image"><br><br>  <b>Setting up delivery on the supplier</b> <br><br>  The client, on his own side, using this mechanism, can also determine the rules for supporting objects of the embedded configuration of the supplier ‚Äî for example, he can refuse the supplier‚Äôs support of a specific object if he takes responsibility for further modification of this object.  And, on the contrary, it is possible to prohibit the editing of the object by its ‚Äúown‚Äù configuration (even if the supplier allows it) in order to insure against accidental change. <br><br><img src="https://habrastorage.org/files/145/77f/608/14577f608449426eaae9ca8a1e71c651.png" alt="image"><br><br>  <b>Configuring client side support</b> <br><br>  When a client starts changing something in a typical configuration, two configurations are created in the info database: <br><br><ol><li>  Original supplier configuration. </li><li>  The current configuration is changed on the client side. </li></ol><br>  And here the supplier releases a new version.  It can be supplied as a complete application, or as a service pack with modified objects.  When switching to a new version, we have 3 configurations on the client side, on the basis of which the so-called three-way merging of configurations is carried out: <br><br><ol><li>  Old configuration from supplier. </li><li>  The current configuration of the client (the old configuration from the supplier plus the changes made in it by the client). </li><li>  New configuration from the supplier. </li></ol><br>  It is clear that in some cases the objects changed by the supplier can be updated automatically: <br><br><ul><li>  Objects not modified by the client. </li><li>  Simple changes to objects on the client (for example, adding additional details to the object). </li></ul><br>  In the case when the object was changed both on the client side and in the new version from the supplier, manual intervention is necessary.  We have a powerful comparison and merging mechanism not only for code modules, but also for models (metadata, forms, reports ...), but even with this mechanism, the combination of configurations can be a non-trivial task. <br><br><h3>  External reports and processing </h3><br>  Another customization mechanism that is relatively safe in terms of switching to new versions is the <a href="http://v8.1c.ru/overview/Term_000000600.htm">external reporting</a> and <a href="http://v8.1c.ru/overview/Term_000000601.htm">processing</a> mechanism.  As the name implies, both types of objects ‚Äî external reports and external processing ‚Äî are external to the application solution, stored in separate files and loaded into the application solution at the time of execution.  Thus, the transition to the new version does not affect them at all.  But if in the new version the details of any object were deleted or renamed, and the processing or report refers to them, the report or processing without rework will not work on the new version. <br><br>  External reports and processing are essentially plugins.  They are well suited for ‚Äúcustom‚Äù reports and specific operations on data (for example, to import information from other systems), but, of course, not all customization scenarios are covered.  If the client needs to add a specific code that must be executed when the document is being carried out, external processing cannot be done here - the source code of the document module must be edited. <br><br><h2>  Cloud customization </h2><br>  With the advent of <a href="https://habrahabr.ru/company/1c/blog/312456/">1cFresh</a> cloud technology <a href="https://habrahabr.ru/company/1c/blog/312456/">, the</a> task of customization has reached a new level.  The fact is that in the ‚Äúcloud‚Äù users of an application solution from different organizations can physically work with one information base (i.e., with one application instance), but at the same time, thanks to the data <a href="http://v8.1c.ru/overview/Term_000000788.htm">separation</a> mechanism, they see only the data of their organization .  Customization through changing the source code here becomes unacceptable - each organization needs its own customization, and no customization of the ‚Äúneighbors‚Äù on the infobase is necessary at all. <br><br>  In the ‚Äúcloud‚Äù for customization, only the use of external reports and processing is applicable, but, as mentioned above, external reports and processing cover far from all the scenarios that users need. <br><br><h2>  Configuration extensions </h2><br>  So, we needed to come up with a customization mechanism that would satisfy the following requirements: <br><br><ol><li>  It would allow to easily update the customized solution to the new version, avoiding the manual work of combining configurations. </li><li>  Allowed to include customization under certain conditions (for example, if we work in the context of a certain organization). </li><li>  Reduced the likelihood of loss of customization performance when upgrading to the new version of the original configuration. </li><li>  Had the ability to disable customization in case of problems to preserve the health of the application. </li></ol><br>  Such a mechanism, besides being used in cloud solutions, would greatly simplify life when switching to a new version on implementations of typical configurations where customization is necessary. <br>  We invented such a mechanism and named its <a href="http://v8.1c.ru/overview/Term_000000883.htm">extensions</a> .  In a sense, this mechanism combines two approaches to customization - the ideology of plug-ins and the subscription mechanism. <br><br>  Extensions are a way to keep configuration changes separate from the configuration itself.  The extension, in fact, is itself a separate configuration containing modified objects.  It, like the configuration, is represented as a tree of objects.  For work with the extension, the same methods of work are used as with the usual configuration: <br><br><img src="https://habrastorage.org/files/645/ca7/a20/645ca7a20d0346dc8cac028f2e85e6e9.png" alt="image"><br><br>  If we want to use an object from the main configuration in the extension (for example, add a new form to an existing document in the main configuration), we first need to borrow the object to our extension through the ‚ÄúAdd to Extension‚Äù command.  Immediately after adding an object to an extension, it is ‚Äúempty‚Äù in the tree of extension objects ‚Äî it has only those properties that are in the main configuration.  You can also borrow an already existing form from the main configuration and, for example, add a new button to it that performs a specific action.  It is not possible to add new details to the objects in the extensions, but we are working on it. <br><br><img src="https://habrastorage.org/files/c45/950/26b/c4595026b09141b9b6b16e4a1428715c.png" alt="image"><br><br>  <b>Basic configuration and extension with a borrowed document Invoice Invoiced</b> <br><br>  The extension also has an analogue of event subscription ‚Äî the ability to handle events of extensible configuration objects, for example, record processing.  You can specify exactly how our code will be called in the extension: <br><br><img src="https://habrastorage.org/files/f21/5c3/103/f215c310307b43f68200b1bfb36da52d.png" alt="image"><br><br>  Before the standard procedure for recording a document, we can call our code, which, for example, will check if the employee responsible for the document is filled in, and if not, write the current user in this field: <br><br><pre><code class="1c hljs"><span class="hljs-meta"><span class="hljs-meta">&amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">("")  _(, , ) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> (. = ..()) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> . = .(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">; </span></span></code> </pre> <br>  In the new version of the configuration, the implementation of the document record may change, but our code in the extension will still be executed before the standard document record code and do its work. <br><br>  At runtime, the typical configuration and extensions (there may be several of them) are "added up", resulting in a new, customized configuration, with which the end user works. <br><br><img src="https://habrastorage.org/files/3a5/dcd/09a/3a5dcd09ae484047af5b74812bb27a73.png" alt="image"><br><br><h3>  Extension order </h3><br>  When developing extensions, it should be remembered that the platform does not guarantee the same order of extensions when adding several extensions to the configuration.  We deliberately refused to explicitly specify the order in which the extensions are executed, since  this, in our opinion, complicates tuning and ultimately introduces more problems than it solves. <br><br>  If we have several extensions added to the configuration, each of which has processing processing of the same document with the ‚Äú&amp; After‚Äù directive, then all the handlers will be executed, but the platform does not guarantee that the order of their execution will always be the same.  This must be considered when developing extensions. <br><br>  If there is a handler for the same event in several extensions with the ‚Äú&amp; Instead‚Äù directive, only one handler will be executed, and which one cannot be said in advance.  This should be remembered and monitored, so that to the configuration of no more than one extension have an ‚Äú&amp; Instead‚Äù handler for the same object / event. <br><br><h3>  Customization of forms in extensions </h3><br>  We can borrow in our extension the shape of the object from the configuration (for example, the form of the document).  In this case, in the visual form editor in the extension, we will see the form the same as in the main configuration.  And in the code editor of the form in the extension will be empty - all the code for the form so far is contained only in the main configuration. <br><br>  On the form, you can add a new button (or even several).  In case several extensions add their own buttons to the same form - all of them will be present on the final form during execution. <br><br>  But it is not recommended to remove standard elements from the form - it can break the code existing in the original configuration (if it refers to the elements of the form).  If there is such a need, it is better to make the elements invisible through the ‚ÄúVisibility‚Äù property. <br><br>  It should be borne in mind that the application on 1C: Enterprise is not just a code in a programming language.  Most of the application is described in the form of declarative models.  And for different tasks, different types of models are used (forms, reports, rights, ....).  For each type of model, we select our own way of customization in extensions, providing the most convenient change for typical cases. <br><br><h2>  Advantages of extensions </h2><br>  Extensions have an ideological difference from the supply and support mechanism.  In the delivery and support mechanism, the developer corrects the configuration of the supplier, as he wants, as if he is simply modifying his configuration, and then (when updating) he deals with how to synchronize conflicting changes.  In extensions, the developer immediately initially develops the extension itself - in terms of the added functionality.  The extension is stored by the system precisely as an add-on and the system takes care of the safest update. <br><br><h3>  Easy transition to the new version of the configuration </h3><br>  When a vendor releases a new version of a typical configuration, an automatic update is performed, since the mode of support for a typical configuration has not changed - it remained at the full support of the supplier.  And when you launch the updated application solution, the platform will again automatically merge the modified sample configuration with the extension.  And the client will continue to work with the typical solution that has been changed for his needs. <br><br>  Sometimes, after updating the version of a typical configuration, it may be necessary to adapt the extension to a new version, for example, if the new version renames the objects or details of the objects involved in the extension.  A little more about this below, in the "Early Error Reporting" section. <br><br><img src="https://habrastorage.org/files/c50/3fa/9ed/c503fa9edca44a698d0b4495bb3742d6.png" alt="image"><br><br><h3>  The changes are separate </h3><br>  The first obvious advantage of extensions is that all customizations made for the client are separate from the typical configuration, and now it is not necessary to compare the modified configuration with the typical one in order to understand what exactly has been changed. <br><br>  It has already been mentioned that in order to use an object from the main configuration in the extension, it must be borrowed into the extension from the main configuration.  Thus, in the extension appears something like a link to an object from the main configuration. <br><br>  At the same time, there is a way to understand which borrowed objects in the configuration are really changed, and which are borrowed in read-only mode ‚Äî for example, for use in reports.  In the tree of extension objects there is a button for the ‚ÄúChanged and added in extension‚Äù filter, after clicking on which only borrowed objects modified in this extension and new objects created in this extension remain in the tree. <br><br><img src="https://habrastorage.org/files/1c9/f2e/091/1c9f2e0915e44946ac4f08b5e63f5075.png" alt="image"><br><br><h3>  Early error reporting </h3><br>  Suppose we borrowed the Contracts directory extension from the main configuration for use in the report.  In the meantime, a new version of the standard configuration was released, in which the Contracts directory was renamed to Contracts.  Naturally, after the transition to the new version, our report in the extension will not work.  If we used the old customization technology - an external report, then the error would occur only at the moment of the report execution.  In the case of extensions, we have the opportunity to check the correctness of extensions in the design-time after updating the version of a typical configuration, and fix all the problems before users start working. <br><br>  This is especially true for implementations where many extensions are used in the same information base and the configuration version is updated centrally (for example, in cloud implementations, where different organizations using the same configuration but operating in different <a href="http://v8.1c.ru/overview/Term_000000790.htm">data areas</a> can use different sets extensions).  The administrator can, on a test base, update the version of the standard configuration and verify the correctness of all user extensions relative to the new version.  In case of problems, he will inform about them to the owners of the extensions, and the transition of the working base to the new version of the typical configuration will be made only when all the extensions are brought in line with the new version of the configuration. <br><br><h2>  What's next? </h2><br>  We consider the development of extensions to be one of the main directions for the development of customization tools in the 1C: Enterprise platform.  Extensions, originally conceived to facilitate customization in the cloud service, were designed to facilitate both customization and non-cloud implementations. <br><br>  While in extensions you can otkastomizirovat not everything that you want.  For example, while it is impossible to create new application objects (directories, documents, etc.) and it is not possible to add new details to existing application objects.  We are working on this (and on other features too) and in almost every new version of the 1C: Enterprise platform we add new features to the extensions: <br><br><ul><li>  <a href="http-servisy-v-rasshireniyakh/%3Fsphrase_id%3D5493">Web and HTTP services in extensions</a> (version 8.3.7). </li><li>  Add your own objects in extensions - common commands, layouts and pictures, as well as forms of borrowed application objects, their commands and layouts (version 8.3.8, <a href="http://v8.1c.ru/overview/release_8_3_8/">link</a> ). </li><li>  <a href="https://wonderland.v8.1c.ru/blog/razvitie-mekhanizma-rasshireniy/%3Fsphrase_id%3D5493">Development of the extension mechanism</a> (adding roles in extensions - version 8.3.9). </li><li>  <a href="https://wonderland.v8.1c.ru/blog/rasshirenie-moduley/%3Fsphrase_id%3D5493">Expansion of modules</a> (version 8.3.9). </li></ul></div><p>Source: <a href="https://habr.com/ru/post/320018/">https://habr.com/ru/post/320018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320006/index.html">ESP8266 + PCA9685 + LUA</a></li>
<li><a href="../320010/index.html">A brief overview of the innovations in Laravel 5.4</a></li>
<li><a href="../320012/index.html">Hearst Shkulev Media: ‚ÄúWe need to make content for people, not for search engines‚Äù</a></li>
<li><a href="../320014/index.html">AngularJS vs Angular 2: key differences</a></li>
<li><a href="../320016/index.html">How I hid 1C base in Germany</a></li>
<li><a href="../320020/index.html">Reception campaign 2017: Useful links and materials for future bachelors, masters and graduate students of ITMO University</a></li>
<li><a href="../320022/index.html">Flexbox First. Layout tables and text flexboxes</a></li>
<li><a href="../320024/index.html">Analyze it: how Skyeng chose a product analytics system for mobile apps</a></li>
<li><a href="../320026/index.html">"Friday format": where to grow technical specialists</a></li>
<li><a href="../320030/index.html">Intel Software Guard Extensions tutorial. Part 5, development of the enclave</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>