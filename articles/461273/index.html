<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Greedy approach and slot machines. Analysis of the tasks of the ML-track of the programming championship</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to publish analyzes of the tasks that were proposed at the recent championship. Next in line are tasks taken from the qualification round ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Greedy approach and slot machines. Analysis of the tasks of the ML-track of the programming championship</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  We continue to publish analyzes of the tasks that were proposed at the recent championship.  Next in line are tasks taken from the qualification round for machine learning specialists.  This is the third track out of four (backend, frontend, ML, analytics).  Participants needed to make a model for correcting typos in texts, propose a strategy for playing on slot machines, bring to mind a system of recommendations for content, and compose several more programs. <br><br><a name="habracut"></a><h2>  A. Typos </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>All languages</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Time limit </td><td>  1 s </td><td>  5 s </td><td>  5 s </td></tr><tr><td>  Memory limit </td><td>  64 MB </td><td>  256 MB </td><td>  256 MB </td></tr><tr><td>  Enter </td><td colspan="3">  standard input or input.txt </td></tr><tr><td>  Conclusion </td><td colspan="3">  standard output or output.txt </td></tr></tbody></table></div>  (epigraph) (from one forum) <br>  - Who composed this nonsense? <br>  - Astrophysicists.  They are people too. <br>  - You made 10 mistakes in the word ‚Äújournalists‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many users make typing errors, some because of hitting keys, some because of their illiteracy.  We want to check if the user could really mean some other word than the one he typed. <br><br>  More formally, suppose that the following error model takes place: the user begins with a word that he wants to write, and then subsequently makes a number of errors in it.  Each mistake is a substitution of some substring of the word for another substring.  One error corresponds to replacing only in one position (that is, if the user wants to make a single error by the rule ‚Äúabc‚Äù ‚Üí ‚Äúcba‚Äù, then from the line ‚Äúabcabc‚Äù he can get either ‚Äúcbaabc‚Äù or ‚Äúabccba‚Äù).  After each error, the process repeats.  The same rule could be used several times in different steps (for example, in the above example, ‚Äúcbacba‚Äù could be obtained in two steps). <br><br>  It is required to determine the minimum number of errors a user could make if he had in mind one given word and wrote another. <br><br><div class="spoiler">  <b class="spoiler_title">I / O Formats and Example</b> <div class="spoiler_text"><h4>  Input format </h4><br>  The first line contains the word, which, according to our assumption, the user had in mind (it consists of letters of the Latin alphabet in lower case, the length does not exceed 20). <br><br>  The second line contains the word that he actually wrote (it also consists of letters of the Latin alphabet in lower case, the length does not exceed 20). <br><br>  The third line contains a single number N (N &lt;50) - the number of replacements that describe various errors. <br><br>  The next N lines contain possible replacements in the format &amp; lt "correct" letter sequence &amp; gt &lt;space&gt; &lt;"erroneous" letter sequence&gt;.  Sequences are no more than 6 characters long. <br><br><h4>  Output format </h4><br>  It is required to print one number - the minimum number of errors that the user could make.  If this number exceeds 4 or it is impossible to get another from one word, print -1. <br><br><h4>  Example </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4>  Decision </h4><br>  Let's try to generate from the correct spelling all possible words with no more than 4 errors.  In the worst case, there may be O ((LÔπíN) <sup>4</sup> ).  In the limitations of the problem, this is a rather large number, so you need to figure out how to reduce complexity.  Instead, you can use the meet-in-the-middle algorithm: generate words with no more than 2 errors, as well as words from which you can get a user-written word with no more than 2 errors.  Note that the size of each of these sets will not exceed 10 <sup>6</sup> .  If the number of errors made by the user does not exceed 4, then these sets will intersect.  Similarly, we can verify that the number of errors does not exceed 3, 2, and 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2>  B. Many-armed bandit </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Time limit </td><td>  2 s </td></tr><tr><td>  Memory limit </td><td>  64 MB </td></tr><tr><td>  Enter </td><td>  standard input </td></tr><tr><td>  Conclusion </td><td>  standard output </td></tr></tbody></table></div>  This is an interactive task. <br><br>  You yourself do not know how it happened, but you found yourself in a hall with slot machines with a whole bag of tokens.  Unfortunately, at the box office, they refuse to accept tokens back, and you decided to try your luck.  There are many slot machines in the hall that you can play.  For one game with a slot machine you use one token.  In case of a win, the machine gives you one dollar, in case of a loss - nothing.  Each machine has a fixed probability of winning (which you do not know), but it is different for different machines.  Having studied the website of the manufacturer of these machines, you found out that the probability of winning for each machine is randomly selected at the manufacturing stage from a <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B5%25D1%2582%25D0%25B0-%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">beta distribution</a> with certain parameters. <br><br>  You want to maximize your expected winnings. <br><br><div class="spoiler">  <b class="spoiler_title">I / O Formats and Example</b> <div class="spoiler_text"><h4>  Input format </h4><br>  One execution may consist of several tests. <br><br>  Each test starts with the fact that your program contains two integers in one line, separated by a space: the number N is the number of tokens in your bag, and M is the number of machines in the hall (N ‚â§ 10 <sup>4</sup> , M ‚â§ min (N, 100) )  The next line contains two real numbers Œ± and Œ≤ (1 ‚â§ Œ±, Œ≤ ‚â§ 10) - the parameters of the beta distribution of the probability of winning. <br><br>  The communication protocol with the checking system is this: you make exactly N requests.  For each request, print in a separate line the number of the machine you will play (from 1 to M inclusive).  As an answer, in a separate line there will be either ‚Äú0‚Äù or ‚Äú1‚Äù, meaning respectively a loss and a win in a game with the requested slot machine. <br><br>  After the last test, instead of the numbers N and M, there will be two zeros. <br><br><h4>  Output format </h4><br>  The task will be considered completed if your decision is not much worse than the decision of the jury.  If your decision is significantly worse than the jury's decision, you will receive the verdict ‚Äúwrong answer‚Äù. <br><br>  It is guaranteed that if your decision is no worse than the decision of the jury, then the probability of receiving the verdict ‚Äúincorrect answer‚Äù does not exceed <sup>10-6</sup> . <br><br><h4>  Notes </h4><br>  Interaction Example: <br><br><pre> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  Decision </h4><br>  This problem is well known, it could be solved in different ways.  The main decision of the jury implemented the <a href="https://en.wikipedia.org/wiki/Thompson_sampling">Thompson sampling</a> strategy, but since the number of steps was known at the beginning of the program, there are more optimal strategies (for example, UCB1).  Moreover, one could even get by with the epsilon-greedy-strategy: with a certain probability Œµ play a random machine and with a probability (1 - Œµ) play a machine with the best victory statistics. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2>  C. Alignment of sentences </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Time limit </td><td>  2 s </td></tr><tr><td>  Memory limit </td><td>  64 MB </td></tr><tr><td>  Enter </td><td>  standard input or input.txt </td></tr><tr><td>  Conclusion </td><td>  standard output or output.txt </td></tr></tbody></table></div>  One of the most important tasks for training a good machine translation model is a good case of parallel sentences.  Typically, the source for parallel offers is parallel documents.  It turns out that often in order to build a certain corpus of parallel sentences, you do not need to know anything but their lengths.  In particular, you may notice that the longer the sentence in the source language, the longer it will most likely be translated.  Some difficulty lies in the fact that during the translation the number of sentences in the text can change: sometimes two neighboring sentences in the translation can be combined into one, or vice versa - one sentence could be divided into two.  In some rare cases, sentences may be omitted entirely in a translation, or a translation may appear in a translation that was not in the original. <br><br>  More formally, suppose the following generative model for parallel enclosures is true.  At each step, we do one of the following: <br><br>  <b>1. <i>Stop</i></b> <br><br>  With probability p <sub>h,</sub> hull generation ends. <br><br>  <b>2. [1-0] <i>Skipping offers</i></b> <br><br>  With probability p <sub>d we</sub> ascribe one sentence to the original text.  We do not attribute anything to the translation.  The length of the sentence in the original language L ‚â• 1 is selected from the discrete distribution: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  Here <i>Œº <sub>s</sub></i> , <i>œÉ <sub>s</sub></i> are the distribution parameters, and <i>Œ± <sub>s</sub></i> is the normalization coefficient chosen so that <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>Insert proposal</i></b> <br><br>  With probability p <sub>i we</sub> ascribe one sentence to the translation.  We do not ascribe anything to the original.  The length of a sentence in a translation language L ‚â• 1 is selected from a discrete distribution: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  Here <i>Œº <sub>t</sub></i> , <i>œÉ <sub>t</sub></i> are the distribution parameters, and <i>Œ± <sub>t</sub></i> is the normalization coefficient chosen so that <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>Translation</i></b> <br><br>  With probability (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ) we take the length of the sentence in the original language L <sub>s</sub> ‚â• 1 from the distribution p <sub>s</sub> (with rounding up).  Next, we generate the length of the sentence in the translation language L <sub>t</sub> ‚â• 1 from the conditional discrete distribution: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  Here, <i>Œ± <sub>st</sub></i> is the normalization coefficient, and the remaining parameters are described in the previous paragraphs. <br><br>  Next is another step: <br><br>  1. [2-1] With probability p <sub>split s, the</sub> generated sentence in the original language splits into two non-empty sentences, so that the total number of words <b><i>increases by exactly one</i></b> .  The probability that a sentence of length L <sub>s will</sub> fall apart into parts of length L <sub>1</sub> and L <sub>2</sub> (that is, L <sub>1</sub> + L <sub>2</sub> = L <sub>s</sub> + 1) is proportional to P <sub>s</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>s</sub> (L <sub>2</sub> ). <br><br>  2. [1-2] With probability p <sub>split t, the</sub> generated sentence in the target language splits into two non-empty sentences, so that the total number of words increases by exactly one.  The probability that a sentence of length L <sub>t will</sub> fall apart into parts of length L1 and L2 (that is, L <sub>1</sub> + L <sub>2</sub> = L <sub>t</sub> + 1) is proportional to P <sub>t</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>t</sub> (L <sub>2</sub> ). <br><br>  3. 3. [1-1] With the probability (1 - p <sub>split s</sub> - p <sub>split t</sub> ), none of the pair of generated sentences will decay. <br><br><div class="spoiler">  <b class="spoiler_title">I / O Formats, Examples, and Notes</b> <div class="spoiler_text"><h4>  Input format </h4><br>  The first line of the file contains the distribution parameters: p <sub>h</sub> , p <sub>d</sub> , p <sub>i</sub> , p <sub>split s</sub> , p <sub>split t</sub> , Œº <sub>s</sub> , œÉ <sub>s</sub> , Œº <sub>t</sub> , œÉ <sub>t</sub> .  0.1 ‚â§ œÉ <sub>s</sub> &lt;œÉ <sub>t</sub> ‚â§ 3. 0 ‚â§ Œº <sub>s</sub> , Œº <sub>t</sub> ‚â§ 5. <br><br>  The next line contains the numbers N <sub>s</sub> and N <sub>t</sub> - the number of sentences in the case in the original language and in the target language, respectively (1 ‚â§ N <sub>s</sub> , N <sub>t</sub> ‚â§ 1000). <br><br>  The next line contains N <sub>s</sub> integers - the lengths of sentences in the original language.  The next line contains N <sub>t</sub> integers - the lengths of sentences in the target language. <br><br>  The next line contains two numbers: j and k (1 ‚â§ j ‚â§ N <sub>s</sub> , 1 ‚â§ k ‚â§ N <sub>t</sub> ). <br><br><h4>  Output format </h4><br>  It is required to derive the probability that sentences with indices j and k in the texts, respectively, are parallel (that is, that they are generated at one step of the algorithm and none of them is the result of decay). <br><br>  Your answer will be accepted if the absolute error does not exceed 10 <sup>‚Äì4</sup> . <br><br><h4>  Example 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4>  Example 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4>  Example 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4>  Notes </h4><br>  In the first example, the initial sequence of numbers can be obtained in three ways: <br><br>  ‚Ä¢ First, with probability p <sub>d,</sub> add one sentence to the original text, then with probability p <sub>i</sub> add one sentence to the translation, then with probability p <sub>h</sub> finish the generation. <br><br>  The probability of this event is P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  ‚Ä¢ First, with probability p <sub>d,</sub> add one sentence to the original text, then with probability p <sub>i</sub> add one sentence to the translation, then with probability p <sub>h</sub> finish the generation. <br><br>  The probability of this event is equal to P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  ‚Ä¢ With probability (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) generate two sentences, then with probability (1 - p <sub>split s</sub> - p <sub>split t</sub> ) leave everything as it is (that is, do not split the original or the translation into two sentences ) and after that with probability p <sub>h</sub> finish the generation. <br><br>  The probability of this event is <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  As a result, the answer is calculated as <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4>  Decision </h4><br>  The task is a special case of alignment using hidden Markov models (HMM alignment).  The main idea is that you can calculate the probability of generating a specific pair of documents using this model and <a href="https://en.wikipedia.org/wiki/Forward_algorithm">the forward algorithm</a> : in this case, the state is a pair of document prefixes.  Accordingly, the required probability of alignment of a specific pair of parallel sentences can be calculated by the <a href="https://en.wikipedia.org/wiki/Forward%25E2%2580%2593backward_algorithm">forward-backward</a> algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2>  D. Guideline </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Time limit </td><td>  2 s </td></tr><tr><td>  Memory limit </td><td>  64 MB </td></tr><tr><td>  Enter </td><td>  standard input or input.txt </td></tr><tr><td>  Conclusion </td><td>  standard output or output.txt </td></tr></tbody></table></div>  Consider a feed of recommendations for heterogeneous content.  It mixes objects of various types (pictures, videos, news, etc.).  These objects are usually ordered by relevance to the user: the more relevant (interesting) the object to the user, the closer to the top of the list of recommendations.  However, with such ordering, situations often arise in which several objects of the same type appear in the list of recommendations.  This greatly affects the external variety of our recommendations and therefore users do not like it.  It is necessary to implement an algorithm that, according to the list of recommendations, will compose a new list that will be free from this problem and will be most relevant. <br><br>  Let an initial list of recommendations be given a = [a <sub>0</sub> , a <sub>1</sub> , ..., a <sub>n - 1</sub> ] of length n&gt; 0. An object with number i has type with number b <sub>i</sub> ‚àà {0, ..., m - 1}.  In addition, an object under number i has relevance r (a <sub>i</sub> ) = 2 <sub>‚àíi</sub> .  Consider the list that is obtained from the initial one by selecting a subset of objects and rearranging them: x = [a <sub>i <sub>0</sub></sub> , a <sub>i <sub>1</sub></sub> , ..., a <sub>i <sub>k ‚àí 1</sub></sub> ] of length k (0 ‚â§ k ‚â§ n).  A list is called admissible if no two consecutive objects in it match in type, i.e., b <sub>i <sub>j</sub></sub> ‚â† b <sub>i <sub>j + 1</sub></sub> for all j = 0, ..., k ‚àí 2.  The relevance of the list is calculated by the formula <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;xid=17259,1500004,15700023,15700186,15700190,15700256,15700259,15700262,15700265&amp;usg=ALkJrhhs7R2OvKRTTTKBwtyTaxf-Taq7BA#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>‚àí</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  You need to find the maximum relevance list among all valid. <br><br><div class="spoiler">  <b class="spoiler_title">I / O Formats and Examples</b> <div class="spoiler_text"><h4>  Input format </h4><br>  The first line contains space-separated numbers n and m (1 ‚â§ n ‚â§ 100000, 1 ‚â§ m ‚â§ n).  The next n lines contain the numbers b <sub>i</sub> for i = 0, ..., n - 1 (0 ‚â§ b <sub>i</sub> ‚â§ m - 1). <br><br><h4>  Output format </h4><br>  Write out, with a space, the numbers of objects in the final list: i <sub>0</sub> , i <sub>1</sub> , ..., i <sub>k ‚àí 1</sub> . <br><br><h4>  Example 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Example 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Example 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Decision </h4><br>  Using simple mathematical calculations, it can be shown that the problem can be solved by a ‚Äúgreedy‚Äù approach, that is, in the optimal list of recommendations, each position has the most relevant object of all that are valid at the same beginning of the list.  The implementation of this approach is simple: we take objects in a row and add them to the answer, if possible.  When an invalid object is encountered (the type of which coincides with the type of the previous one), we put it aside in a separate queue, from which we insert it into the response as soon as possible.  Note that at every moment in time, all objects in this queue will have a matching type.  At the end, several objects may remain in the queue, they will no longer be included in the response. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2>  D. Clustering character sequences </h2><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>All languages</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Time limit </td><td>  1 s </td><td>  6 s </td><td>  6 s </td></tr><tr><td>  Memory limit </td><td>  64 MB </td><td>  64 MB </td><td>  64 MB </td></tr><tr><td>  Enter </td><td colspan="3">  standard input or input.txt </td></tr><tr><td>  Conclusion </td><td colspan="3">  standard output or output.txt </td></tr></tbody></table></div>  There is a finite alphabet A = {a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>K ‚àí 1</sub> , a <sub>K</sub> = S}, a <sub>i</sub> ‚àà {a, b, ..., z}, S is the end of the line. <br><br>  Consider the following method of generating random strings over the alphabet A: <br><br>  1. The first character x <sub>1</sub> is a random variable with the distribution P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (it is known that q <sub>K</sub> = 0). <br>  2. Each next character is generated on the basis of the previous one in accordance with the conditional distribution P (x <sub>i</sub> = a <sub>j</sub> || x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. If x <sub>i</sub> = S, generation stops and the result is x <sub>1</sub> x <sub>2</sub> ... x <sub>i ‚àí 1</sub> . <br><br>  A set of lines generated from a mixture of two described models with different parameters is given.  It is necessary for each row to give the index of the chain from which it was generated. <br><br><div class="spoiler">  <b class="spoiler_title">I / O Formats, Example and Notes</b> <div class="spoiler_text"><h4>  Input format </h4><br>  The first line contains two numbers 1000 ‚â§ N ‚â§ 2000 and 3 ‚â§ K ‚â§ 27 - the number of lines and the size of the alphabet, respectively. <br><br>  The second line contains a line consisting of K ‚àí 1 different lowercase letters of the Latin alphabet, indicating the first K ‚àí 1 elements of the alphabet. <br><br>  Each of the following N lines is generated according to the algorithm described in the condition. <br><br><h4>  Output format </h4><br>  N lines, the i-th line contains the cluster number (0/1) for the sequence on the i + 1-th line of the input file.  Coincidence with the true answer should be at least 80%. <br><br><h4>  Example </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Enter</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4>  Notes </h4><br>  Note to the test from the condition: in it the first 50 lines are generated from the distribution <br>  P (x <sub>i</sub> = a | x <sub>i ‚àí 1</sub> = a) = 0.5, P (x <sub>i</sub> = S | x <sub>i ‚àí 1</sub> = a) = 0.5, P (x <sub>1</sub> = a) = 1;  second 50 - from distribution <br>  P (x <sub>i</sub> = b | x <sub>i ‚àí 1</sub> = b) = 0.5, P (x <sub>i</sub> = S | x <sub>i ‚àí 1</sub> = b) = 0.5, P (x <sub>1</sub> = b) = 1. </div></div><br><h4>  Decision </h4><br>  The problem is solved using the <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3DEM-%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">EM algorithm</a> : it is assumed that the presented sample is generated from a mixture of two Markov chains whose parameters are restored during iterations.  A restriction of 80% of the correct answers is made so that the correctness of the solution is not affected by examples that have a high probability in both chains.  These examples, therefore, if properly restored, can be assigned to a chain that is incorrect in terms of the generated response. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the </font></font><a href="https://habr.com/ru/company/yandex/blog/457262/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breakdowns of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tasks on the </font><a href="https://habr.com/ru/company/yandex/blog/457262/"><font style="vertical-align: inherit;">backend</font></a><font style="vertical-align: inherit;"> and </font></font><a href="https://habr.com/ru/company/yandex/blog/460139/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frontend</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/461273/">https://habr.com/ru/post/461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461261/index.html">Checklist of useful RRC webinars on RRC products</a></li>
<li><a href="../461265/index.html">About the abuse of the use of the operating system in projects for microcontrollers</a></li>
<li><a href="../461269/index.html">Problem solving with pwnable.kr 08 is leg and 10 is shellshock. ARM assembler. Bash vulnerability</a></li>
<li><a href="../46127/index.html">8 ways to turn a new site visitor into a regular visitor</a></li>
<li><a href="../461271/index.html">How to promote a mobile application in 2019: 4 practical ways + useful tools</a></li>
<li><a href="../461277/index.html">Overview of the free SQLIndexManager tool</a></li>
<li><a href="../461279/index.html">How to create a simple microservice on Golang and gRPC and containerize it using Docker</a></li>
<li><a href="../461281/index.html">Walkthrough for setting up a BIND DNS server in a chroot environment for Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../461283/index.html">Software architecture and systems design: a big picture and resource guide</a></li>
<li><a href="../461285/index.html">5 main sampling algorithms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>