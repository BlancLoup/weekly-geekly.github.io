<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Top 10 Common JavaScript Mistakes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, JavaScript is at the core of most modern web applications. At the same time, in recent years a large number of JavaScript libraries and framewo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Top 10 Common JavaScript Mistakes</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/mailru/blog/233553/"><img src="https://habrastorage.org/files/b85/99c/3fb/b8599c3fb489413692a4a60123e37b78.jpg"></a> <br><br>  Today, JavaScript is at the core of most modern web applications.  At the same time, in recent years a large number of JavaScript libraries and frameworks for developers of <a href="http://ru.wikipedia.org/wiki/Single_Page_Application">Single Page Application (SPA)</a> , graphics, animation, and even server platforms have appeared.  JavaScript is widely used for web development, and therefore the quality of the code is becoming increasingly important. <br><br>  At first glance, this language may seem rather simple.  Embedding basic JavaScript functionality into a web page is not a problem for any experienced developer, even if he hasn‚Äôt previously come across this language.  However, this is a deceptive impression, since JavaScript is much more complicated, more powerful and more sensitive to nuances than it seems at first.  Many subtleties in this language lead to a large number of common errors.  Today we look at some of them.  You need to pay special attention to these errors if you want to program well in JavaScript. <br><a name="habracut"></a><br><h1>  1. Incorrect links to this </h1> Due to the fact that in recent years, JavaScript programming has become very complicated, the number of occurrences of callback functions and closures has increased, which often cause confusion with the <code>this</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, the execution of this code: <br><pre> <code class="javascript hljs">Game.prototype.restart = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearLocalStorage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearBoard(); <span class="hljs-comment"><span class="hljs-comment">//   "this"? }, 0); };</span></span></code> </pre><br>  Causes an error: <br><pre> <code class="javascript hljs">Uncaught <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> is not a <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre><br>  Why is this happening?  It's all about context.  When you call <code>setTimeout()</code> , you actually call <code>window.setTimeout()</code> .  As a result, the anonymous function passed to <code>setTimeout()</code> is defined in the context of a <code>window</code> object that does not have a <code>clearBoard()</code> method. <br><br>  The traditional solution, compatible with older browsers, involves simply storing the reference to <code>this</code> in a variable that can be stored in the closure: <br><pre> <code class="javascript hljs">Game.prototype.restart = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearLocalStorage(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    'this',     'this'! this.timer = setTimeout(function(){ self.clearBoard(); //    }, 0); };</span></span></code> </pre><br>  For new browsers, you can use the <code>bind()</code> method, which allows you to associate a function with the execution context: <br><pre> <code class="javascript hljs">Game.prototype.restart = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearLocalStorage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reset.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'this' }; Game.prototype.reset = function(){ this.clearBoard(); //     'this'! };</span></span></code> </pre><br><h1>  2. Block-level scope </h1>  Developers often believe that JavaScript creates a new scope for each block of code.  Although this is true for many other languages, this does not happen in JavaScript.  Let's look at this code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">//   ?</span></span></code> </pre><br>  If you think that the <code>console.log()</code> call will result in an <code>undefined</code> output or an error, then you are mistaken: ‚Äú10‚Äù will be output.  Why?  In most other languages, this code would lead to an error, because the scope of the variable <code>i</code> would be limited to a <code>for</code> block.  However, in JavaScript, this variable remains in scope even after the <code>for</code> loop is completed, retaining its last value (this behavior is known as ‚Äú <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">var hoisting</a> ‚Äù).  It should be noted that block-level support for scopes has been introduced in JavaScript since version 1.7 using the <code>let</code> descriptor. <br><br><h1>  3. Memory leaks </h1>  Memory leaks are almost inevitable if, during work, you do not consciously avoid them.  There are many reasons for the appearance of leaks, but we will focus only on the most frequent. <br><br>  <u>References to non-existent objects</u> .  Let's analyze this code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> theThing = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> replaceThing = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> priorThing = theThing; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unused = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 'unused' -  ,   'priorThing', //  'unused'    if (priorThing) { console.log("hi"); } }; theThing = { longStr: new Array(1000000).join('*'), //  1M  someMethod: function () { console.log(someMessage); } }; }; setInterval(replaceThing, 1000); //  'replaceThing'  </span></span></code> </pre><br>  If you run the execution of this code, you can detect a massive memory leak at a speed of about a megabyte per second.  It seems that we lose the memory allocated for <code>longStr</code> on every call to <code>replaceThing</code> .  What is the reason? <br><br>  Each <code>theThing</code> object contains its own 1Mb <code>longStr</code> object.  Every second when calling <code>replaceThing</code> , the function stores a reference to the previous <code>theThing</code> object in the <code>theThing</code> variable.  This is not a problem, because each time the previous <code>priorThing</code> link will be ground ( <code>priorThing = theThing;</code> ).  So what is the reason for the leak? <br><br>  A typical way to implement a closure is to create a connection between each function object and a dictionary object, which is the lexical scope for this function.  If both functions ( <code>unused</code> and <code>someMethod</code> ) defined inside <code>replaceThing</code> actually use <code>priorThing</code> , then it is important to understand that they receive the same object, even if <code>priorThing</code> rewritten again and again, since both functions use the same lexical scope .  And as soon as the variable is used in any of the closures, it falls into the lexical scope, used by all closures in this scope.  And this little nuance leads to a powerful memory leak. <br><br>  <u>Cyclic links</u> .  Consider the sample code: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addClickHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ element.click = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Clicked the "</span></span> + element.nodeName) } }</code> </pre><br>  Here <code>onClick</code> has a closure in which the <code>element</code> reference is stored.  By <code>onClick</code> as the <code>click</code> event handler for <code>element</code> , we created a circular reference: <code>element</code> -&gt; <code>onClick</code> -&gt; <code>element</code> -&gt; <code>onClick</code> -&gt; <code>element</code> ... <br><br>  Even if you delete an <code>element</code> from the DOM, a circular reference will hide <code>element</code> and <code>onClick</code> from the garbage collector and a memory leak will occur.  What is the best way to avoid leaks?  JavaScript memory management (and, in particular, garbage collection) is largely based on the concept of object reachability.  The following objects are considered reachable and are known as root: <br><ul><li>  references to which are contained in the call stack (all local variables and parameters of functions that are currently being called, as well as all variables in the scope of the closure); </li><li>  all global variables. </li></ul><br>  Objects are stored in memory only as long as they are accessible from the root by reference or chain of references. <br><br>  Browsers have a built-in garbage collector that clears memory from unreachable objects.  That is, the object will be deleted from memory <b>only if</b> the garbage collector decides that it is unreachable.  Unfortunately, unused large objects that are considered ‚Äúachievable‚Äù can easily accumulate. <br><br><h1>  4. Misunderstanding of equality </h1>  One of the advantages of JavaScript is that it automatically converts any value to a boolean value if it is used in a boolean context.  However, there are times when this convenience can be misleading: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     'true'! console.log(false == '0'); console.log(null == undefined); console.log(" \t\r\n" == 0); console.log('' == 0); //   ! if ({}) // ... if ([]) // ...</span></span></code> </pre><br>  Given the last two lines, even if they are empty, <code>{}</code> and <code>[]</code> are actually objects.  And any object in JavaScript corresponds to the boolean value <code>true</code> .  However, many developers believe that the value will be <code>false</code> . <br><br>  As the two examples show, automatic type conversion can sometimes interfere.  It is generally better to use <code>===</code> and <code>!==</code> instead of <code>==</code> and <code>!=</code> To avoid the side effects of type conversion. <br><br>  By the way, comparing <code>NaN</code> with something (even with <code>NaN</code> !) <code>NaN</code> always give the result <code>false</code> .  Thus, you cannot use the equality operators ( <code>==</code> , <code>===</code> <code>!=</code> <code>!==</code> ) to determine if the value of <code>NaN</code> matches.  Instead, use the <code>isNaN()</code> built-in global function: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> == <span class="hljs-literal"><span class="hljs-literal">NaN</span></span>); <span class="hljs-comment"><span class="hljs-comment">// false console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true</span></span></code> </pre><br><h1>  5. Irrational use of the DOM </h1>  In JavaScript, you can easily work with the DOM (including adding, changing and deleting elements), but often developers do it inefficiently.  For example, add a series of items one at a time.  However, the operation of adding elements is very costly, and its consistent implementation should be avoided. <br><br>  If you need to add several elements, then, as an alternative, you can use document fragments: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">"my_div"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragment = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createDocumentFragment(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-number"><span class="hljs-number">0</span></span>; e &lt; elems.length; e++) { fragment.appendChild(elems[e]); } div.appendChild(fragment.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre><br>  We also recommend that you first create and modify elements, and then add to the DOM, it also significantly improves performance. <br><br><h1>  6. Incorrect use of function definitions inside for loops </h1>  Consider the sample code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = elements.length; <span class="hljs-comment"><span class="hljs-comment">// ,    10  for (var i = 0; i &lt; n; i++) { elements[i].onclick = function() { console.log("This is element #" + i); }; }</span></span></code> </pre> <br>  When clicking on any of the 10 elements, the message ‚ÄúThis is element # 10‚Äù would appear.  The reason is that by the time <code>onclick</code> is called by any of the elements, the upstream <code>for</code> loop will have completed and the value of <code>i</code> will be 10. <br><br>  An example of the correct code: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = elements.length; <span class="hljs-comment"><span class="hljs-comment">// ,    10  var makeHandler = function(num) { //   return function() { //   console.log("This is element #" + num); }; }; for (var i = 0; i &lt; n; i++) { elements[i].onclick = makeHandler(i+1); }</span></span></code> </pre> <br>  <code>makeHandler</code> immediately launched at each iteration of the loop, gets the current value of <code>i+1</code> and stores it in the variable <code>num</code> .  The external function returns an internal function (which also uses the <code>num</code> variable) and sets it as an <code>onclick</code> handler.  This ensures that each <code>onclick</code> receives and uses the correct <code>i</code> value. <br><br><h1>  7. Incorrect prototype inheritance </h1>  Surprisingly, many developers do not have a clear understanding of the mechanism of inheritance through prototypes.  Consider the sample code: <br><pre> <code class="java hljs">BaseObject = function(name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof name !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'default'</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseObject(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseObject(<span class="hljs-string"><span class="hljs-string">'unique'</span></span>); console.log(firstObj.name); <span class="hljs-comment"><span class="hljs-comment">// -&gt;  'default' console.log(secondObj.name); // -&gt;  'unique'</span></span></code> </pre><br>  But if we wrote this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> secondObj.name;</code> </pre><br>  you would get: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(secondObj.name); <span class="hljs-comment"><span class="hljs-comment">// -&gt;  'undefined'</span></span></code> </pre><br>  But isn't it better to return the value to <code>default</code> ?  This can be done easily if you apply inheritance through prototypes: <br><pre> <code class="javascript hljs">BaseObject = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }; BaseObject.prototype.name = <span class="hljs-string"><span class="hljs-string">'default'</span></span>;</code> </pre><br>  Each <code>BaseObject</code> instance inherits the name property of its prototype, in which it is assigned the value of <code>default</code> .  Thus, if the constructor is called without a <code>name</code> , the default <code>name</code> will be <code>default</code> .  And in the same way, if the <code>name</code> property is removed from the <code>BaseObject</code> instance, the prototype chain will be searched and the <code>name</code> property will be obtained from the <code>prototype</code> object, in which it is still equal to <code>default</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thirdObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseObject(<span class="hljs-string"><span class="hljs-string">'unique'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(thirdObj.name); <span class="hljs-comment"><span class="hljs-comment">// -&gt;  'unique' delete thirdObj.name; console.log(thirdObj.name); // -&gt;  'default'</span></span></code> </pre><br><h1>  8. Creating invalid references to instance methods. </h1>  We define a simple constructor and use it to create an object: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyObject = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} MyObject.prototype.whoAmI = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> === <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> ? <span class="hljs-string"><span class="hljs-string">"window"</span></span> : <span class="hljs-string"><span class="hljs-string">"MyObj"</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObject();</code> </pre><br>  For convenience, create a link to the <code>whoAmI</code> method: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> whoAmI = obj.whoAmI;</code> </pre><br>  <code>whoAmI</code> value of our new variable <code>whoAmI</code> : <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(whoAmI);</code> </pre><br>  The console will display: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> === <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> ? <span class="hljs-string"><span class="hljs-string">"window"</span></span> : <span class="hljs-string"><span class="hljs-string">"MyObj"</span></span>); }</code> </pre><br>  Now notice the difference when calling <code>obj.whoAmI()</code> and <code>whoAmI()</code> : <br><pre> <code class="javascript hljs">obj.whoAmI(); <span class="hljs-comment"><span class="hljs-comment">//  "MyObj" (  ) whoAmI(); //  "window"</span></span></code> </pre><br>  Something went wrong?  When we assign <code>var whoAmI = obj.whoAmI;</code>  The new variable has been defined in the global namespace.  As a result, the value of <code>this</code> turned out to be equal to <code>window</code> , and not <code>obj</code> , to the <code>MyObject</code> instance.  Thus, if we really need to create a reference to an existing object method, we need to do it within the namespace of this object.  For example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyObject = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} MyObject.prototype.whoAmI = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> === <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> ? <span class="hljs-string"><span class="hljs-string">"window"</span></span> : <span class="hljs-string"><span class="hljs-string">"MyObj"</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObject(); obj.w = obj.whoAmI; <span class="hljs-comment"><span class="hljs-comment">//     obj.whoAmI(); //  "MyObj" (  ) obj.w(); //  "MyObj" (  )</span></span></code> </pre><br><h1>  9. Using a string as the first argument to setTimeout or setInterval </h1>  This in itself is not a mistake.  And it's not just about performance.  The fact is that when you pass a string variable as the first argument to <code>setTimeout</code> or <code>setInterval</code> , it will be passed to the <code>Function</code> constructor for conversion to a new function.  This process can be slow and inefficient.  An alternative is to use the function as the first argument: <br><pre> <code class="javascript hljs">setInterval(logTime, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   logTime  setInterval setTimeout(function() { //     setTimeout logMessage(msgValue); // (msgValue    ) }, 1000);</span></span></code> </pre><br><h1>  10. Failure to use "strict mode" </h1>  This is a mode in which a number of restrictions are imposed on the executable code, which increases security and can prevent some errors from occurring.  Of course, the rejection of the use of "strict mode" is not an error per se.  Just in this case, you deprive yourself of a number of advantages: <br><br><ul><li>  <u>Simplify the debugging process</u> .  Errors in the code that would be ignored or not noticed will cause warnings and generate exceptions that will quickly lead you to the source of the problem. </li><li>  <u>Prevent the random appearance of global variables</u> .  Assigning an undeclared variable automatically creates a global variable with that name.  This is one of the most common errors in javascript.  In "strict mode" this will result in an error message. </li><li>  <u>Prevent duplication of property names or parameter values</u> .  If the ‚Äústrict mode‚Äù is turned on, the object has duplication of property names (for example, <code>var object = {foo: "bar", foo: "baz"};</code> ) or the function argument names, an error message will be displayed.  This allows you to quickly detect and eliminate the bug. </li><li>  <u>Reducing the potential hazard of <code>eval()</code></u> .  In "strict mode", variables and functions declared inside <code>eval()</code> are not created in the current scope. </li><li>  <u>Receiving an error message when using the <code>delete</code> operator in error</u> .  This statement cannot be applied to properties of an object whose <code>configurable</code> flag is <code>false</code> , and an attempt to do this will display an error message. </li></ul><br><h1>  In conclusion </h1>  The better you understand how and why JavaScript works, the more reliable the code will be, the more effectively you can use the capabilities of this language.  Conversely, a misunderstanding of the paradigms embedded in JavaScript causes a large number of bugs in software products. <br><br>  Therefore, the study of the nuances and subtleties of the language is the most effective strategy to improve their professionalism and productivity, and also help to avoid many common mistakes when writing JavaScript code. </div><p>Source: <a href="https://habr.com/ru/post/233553/">https://habr.com/ru/post/233553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233541/index.html">Will solid-state batteries change the world?</a></li>
<li><a href="../233543/index.html">Tesla extended the warranty period for Tesla Model S (+ unlimited mileage) to the detriment of the company's earnings</a></li>
<li><a href="../233545/index.html">Like Mitnick trolled the FBI. Articles on Habr from the camp for schoolchildren</a></li>
<li><a href="../233547/index.html">School time in Akademgorodok - impressions</a></li>
<li><a href="../233551/index.html">Linux GUI Setup for High DPI Monitors</a></li>
<li><a href="../233555/index.html">Back to the Scala Future</a></li>
<li><a href="../233557/index.html">Private detective, patents and illegal imports - a little about the fight against startups with fakes</a></li>
<li><a href="../233559/index.html">‚ÄúLike me, being an ordinary schoolboy, I designed and assembled my own 3D printer model.‚Äù</a></li>
<li><a href="../233561/index.html">Two films about nuclear engines</a></li>
<li><a href="../233565/index.html">Fields of Mathematics for the first time in history received a woman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>