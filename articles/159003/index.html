<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda functions and implementation of a convenient mechanism for Callbacks in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, on the example of implementing a callback mechanism, the possibilities of using lambda functions in a convenient and fast form will b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda functions and implementation of a convenient mechanism for Callbacks in C ++</h1><div class="post__text post__text-html js-mediator-article">  In this article, on the example of implementing a callback mechanism, the possibilities of using lambda functions in a convenient and fast form will be considered. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  It is necessary to implement a convenient and fast mechanism for storing a ‚Äúpointer‚Äù to an arbitrary function and then calling it with the argument passed (for example, take the char * type). <br><br><h4>  Method 1 - on the classic "C" </h4><br>  Solving the problem "in the forehead" you can get something like this: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   static void MyFunction(char *s){ puts(s); } int main(){ //,     void (*MyCallback)(char *argument); //     MyCallback=MyFunction; //    MyCallback("123"); return 0; }</span></span></code> </pre> <br>  The mechanism is very simple and often used.  But with a large number of callbacks, their announcement is not very convenient. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Lambda functions in C ++ </h4><br>  For those who have not heard about C ++ 11 (or C ++ 0x) or have not yet touched it, I will tell you about some of the innovations from this standard.  In C ++ 11, the auto keyword appeared, which can be set instead of type when declaring a variable with initialization.  In this case, the type of the variable will be identical to the type indicated after ‚Äú=‚Äù.  For example: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    int a=1; auto b=""; //    const char* b=1; auto c=1.2; //    double c=1; auto d; // !     d</span></span></code> </pre><br><br>  But the most interesting is the lambda function.  In principle, these are normal functions, but which can be declared directly in the expression: <br><pre> <code class="cpp hljs">[](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,  bool { return a&gt;b; }</span></span></code> </pre><br><br>  The syntax of the lambda function is as follows: <br><br><pre> <code class="cpp hljs">[ ]()-&gt; {   }</code> </pre><br><br>  The ‚Äú-&gt; return type‚Äù chunk may be missing.  Then "-&gt; void" is meant.  Another usage example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//,  abs(int) auto f1=[](int a)-&gt;int{ return (a&gt;0)?(a):(-a); }; //,     0.0  1.0 auto f2=[]()-&gt;float{ return float(rand())/RAND_MAX; }; //,   enter auto f3=[](){ puts("Press enter to continue..."); getchar(); }; printf("%d %d\n",f1(5),f1(-10)); printf("%f %f\n",f2(),f2()); f3(); return 0; }</span></span></code> </pre><br><br>  This program will output: <br><br><pre> <code class="hljs kotlin"><span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0.563585</span></span> <span class="hljs-number"><span class="hljs-number">0.001251</span></span> Press enter to <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>...</code> </pre><br><br>  In this example, three variables (f1, f2 and f3) of type auto were declared and initialized, therefore the type of which corresponds to the type on the right - the type of lambda functions. <br>  The lambda function, by itself, is not a pointer to a function (although in some cases it can be applied to it).  The compiler calls the function not by the address but by its type - that is why each lambda of the function has its own type, for example, "&lt;lambda_a48784a181f11f18d942adab3de2ffca&gt;".  This type cannot be specified, so it can only be used in conjunction with auto or templates (where the type can also be automatically defined there). <br>  The standard also allows conversion from lambda type to type of pointer to function, in the absence of captured variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*func)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg); func= [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg){ ... }; <span class="hljs-comment"><span class="hljs-comment">//  ,  </span></span></code> </pre><br><br>  Captured variables are those variables that ‚Äúget inside‚Äù the lambda function when specified: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f=[argc,&amp;argv](<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s){ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>;c&lt;argc;c++){ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(argv[c]); } }; f(<span class="hljs-string"><span class="hljs-string">"123"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  These parameters are actually saved (copied by value) in the variable f. <br>  If you specify the &amp; sign in front of the name, the parameter will be passed by reference, and not by value. <br>  The address of the function itself is still not stored anywhere. <br><br><h4>  Method 2 - Implementation in C ++ </h4><br>  Replacing a static function with a lambda can simplify our example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*MyCallback)(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *argument); <span class="hljs-comment"><span class="hljs-comment">//      ! MyCallback=[](char *s){ puts(s); }; MyCallback("123"); return 0; }</span></span></code> </pre><br><br>  This is how a little adding ‚Äúpluses‚Äù can greatly simplify life, the main thing is not to overdo it, which we are now trying to do.  In this example, such a construction will work until we want to ‚Äúcapture‚Äù the variables in the lambda functions.  Then the compiler will not be able to convert lambda to a pointer.  Here, using C ++, you can do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ,       class FuncClass{ public: //   virtual void Call(char*)=0; }; //     FuncClass *function; public: Callback(){ function=0; } ~Callback(){ if(function) delete function; } template&lt;class T&gt; void operator=(T func){ if(function) delete function; //     Call,  func class NewFuncClass:public FuncClass{ public: T func; NewFuncClass(T f):func(f){ } void Call(char* d){ func(d); } }; //       function=new NewFuncClass(func); } void operator()(char* d){ if(function) function-&gt;Call(d); } }; int main(){ Callback MyCallback; MyCallback=[](char *s){ puts(s); }; MyCallback("123"); return 0; }</span></span></code> </pre><br><br>  Like this.  A little bit of pluses and a code several times more.  A cumbersome implementation, and yet the possibility of copying Callback instances has not been taken into account here.  But the convenience of use at altitude.  Similarly, the modest operation ‚Äú=‚Äù hides the allocation of dynamic memory, and even the constructor does not clearly fit into the concept of code visibility widely loved by those who are faithful to the classic ‚ÄúC‚Äù programmers. <br><br>  Let's try to fix it and speed up and simplify the implementation as much as possible without losing convenience. <br><br><h4>  Method 3 - Something Mean </h4><br>  Implementation: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*function)(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*,<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *parameters[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Callback(){ function=[](<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*,<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*){ }; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">){</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,  sizeof(T) &lt;= sizeof(parameters) //    ,   compile-time , .. //      sizeof(int[ sizeof(parameters)-sizeof(T) ]); //    ,     func function=[](char* arg,void *param){ (*(T*)param)(arg); }; //     func  parameters memcpy(parameters,&amp;func,sizeof(T)); } void operator()(char* d){ //     function,    parameters function(d,parameters); } }; int main(){ Callback MyCallback; MyCallback=[](char *s){ puts(s); }; MyCallback("123"); return 0; }</span></span></code> </pre><br><br>  First of all: we removed a large piece associated with virtual functions and memory allocation.  Saving occurs at copy speeds of a few bytes. <br><br>  The call is also quick - from calling two nested functions (auxiliary and stored) to one, when the compiler embeds one into the other - almost an ideal variant (one extra argument ‚Äúparameters‚Äù separates from the ideal). <br><br>  For such an implementation, the only limitation is the maximum size of the variables captured in the lambda functions.  But usually it is required to transfer not so many additional parameters.  And with a large number, you can use the dynamic memory at the expense of speed. <br><br><h4>  Total </h4><br>  The convenience and functionality of the transfer function as a pointer has been brought to a high level of convenience without a special increase in resource intensity.  As for the functional, there is still plenty of room for creativity: creating a queue with priorities (event flow), a template for different types of argument, etc. </div><p>Source: <a href="https://habr.com/ru/post/159003/">https://habr.com/ru/post/159003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../158991/index.html">VKontakte "I like" widget caches parameters</a></li>
<li><a href="../158995/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ31 (November 10 - 16, 2012)</a></li>
<li><a href="../158997/index.html">3D printing and heart tissue biorobots</a></li>
<li><a href="../158999/index.html">The portal Opera redirected users to a malicious resource</a></li>
<li><a href="../159001/index.html">The effect of turning the page. Now - patented</a></li>
<li><a href="../159005/index.html">How to become a millionaire in the AppStore or a few formulas about promotion and sales. Part 2</a></li>
<li><a href="../159009/index.html">A small overview of Ingress or how to privatize the sights</a></li>
<li><a href="../159011/index.html">Simple clock on MSP430</a></li>
<li><a href="../159013/index.html">Making your local DNS (PDNSD), with blackjack and faster Google Public DNS</a></li>
<li><a href="../159017/index.html">SVG text</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>