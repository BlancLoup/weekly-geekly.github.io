<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Desktop GUI tests in Python. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vasily Ryabov vasily-v-ryabov from the company Aquantia explains how using Python you can start testing your desktop interfaces. From the lecture, you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Desktop GUI tests in Python. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  Vasily Ryabov <a href="https://habrahabr.ru/users/vasily-v-ryabov/" class="user_link">vasily-v-ryabov</a> from the company Aquantia explains how using Python you can start testing your desktop interfaces.  From the lecture, you will learn about open source tools and accessibility-technology support in the pywinauto library.  Video and decryption are mainly intended for those who are engaged in testing software for Windows, but the author also talks a little about Linux and macOS. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6rrgmjVFZ_E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a>  - Hello.  I have a technical report about automating desktop GUI tests.  It will be purely about open source, about the paid I will not mention.  Almost all open source solutions that can be used will be mentioned. <br><br>  I do not pretend to have a full review and comparison, but I will tell you what I used and what our small community works on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/240/d24/526/240d24526c4e4714b7b7e997073f073d.jpg"><br><br>  The task of the desktop GUI itself is more complicated than the web, because there are no uniform standards.  For example, to send some control actions, it can still be solved more or less easily, but not so simple. <br><br>  We also need to be able to get the text from the controls in order to verify some information, but not only for this.  We also need to know exactly where to click, so as not to just click anywhere. <br><br><img src="https://habrastorage.org/web/901/ef0/f09/901ef0f0906a4b3b88039f4acfda9b5f.jpg"><br><br>  There are three common approaches.  The most unreliable - they took zahardkozhennye coordinates, poked somewhere, with a finger into the sky.  Once, and the screen resolution changed, the theme changed, the window size, the window opened in another place, something else, everything went and swam.  Support is impossible, easier to test hands. <br><br>  The second approach is more reliable, but also not so stable - based on pattern recognition.  Now there are tools that have gained some popularity.  This is not about text recognition.  Rather, just search for a similar square or rectangle on the screen so that you can click there.  The most popular of them is Sikuli.  Lackey - analogue in pure Python.  Basically, the report will be about tools in Python, but I will also mention other languages. <br><br>  Finally, the most reliable and fast approach is based on accessibility technologies.  Unfortunately, it is not always applicable - if you have nowhere to go at all, you can somehow recognize the image. <br><br><img src="https://habrastorage.org/web/e53/b34/ff9/e53b34ff9e37407db90aa72938fb45da.jpg"><br><br>  What are accessibility technologies?  Mostly you have already heard about them: the good old Win32 API and the latest technology from Microsoft, not so new - MS UI Automation, which partially includes the Win32 API, but its hierarchy is different, everything is not so simple.  It supports many more applications in itself. <br><br>  Surely many of you used object inspectors like Spy ++.  This is an automatist's best friend.  UI Automation has its own object inspector, which also allows you to view the hierarchy of windows and find out how the tree is located there.  This is Insect.exe, it is located in the Windows SDK in the Program Files folder.  If everything is set, you can find it. <br><br>  There are also technologies on Linux and Mac, I‚Äôll mention them only on one slide.  They exist, there are even tools that use them. <br><br>  First, let's talk about the open source tools for the good old Win32 API.  Though he is old, but smart. <br><br><img src="https://habrastorage.org/web/a95/0bb/c4a/a950bbc4a79b44e99008bd80630f8eff.jpg"><br><br>  There are quite well-known tools, such as AutoIt and AutoHotkey.  Each of them has its own scripting languages, which is a bit not universal, but they are popular and have long existed on the market.  Although the same AutoIt is rather positioned by developers for admin tasks, automation, in order to deliver something.  Nevertheless, many testers adapted it for GUI tests. <br><br>  At one time, I came across a Python library called pywinauto.  Then I did not know about AutoIt or AutoHotkey.  It is in pure Python, a rather beautiful interface, the license is also convenient.  At one time I chose pywinauto for my tasks. <br><br><img src="https://habrastorage.org/web/97e/76c/715/97e76c7156764fa28550fb1a6f4b1373.jpg"><br><br>  To illustrate, an example of how easy it is to write code on pywinauto.  Just run the application, then we refer to the name of the main window, as an attribute of the object.  Just as a member of the class appeal.  Then we also turn to the same combo box - namely, the one that has Color written next to it.  We select everything in the text.  We click on the buttons and control that our window has ceased to be visible, that it has closed. <br><br>  It looks quite comfortable, but we will analyze in more detail how this all works.  Under this simple external concept a lot of things lie. <br><br><img src="https://habrastorage.org/web/f06/7a3/950/f067a39503a44e589dbeb7e6ce06f408.jpg"><br><br>  First, a little about history.  The library appeared in 2006, until 2010 it was developed by the author Mark McMahon.  Just in 2010, I began to use it, and it just ceased to be supported.  So it came out, this is life.  Then we in our applications just switched to 64 bits and, when we wrote the first tests, we realized that we need to test 64 bits already.  I had to shake up the insides of the library myself. <br><br>  We used our internal clone for a while in Intel, we lived with this clone for a very long time, it was quite stable, and by the end of 2014 it came to an understanding that we needed to return it to open source, because the project was not going to come to life itself.  I had to revive him. <br><br>  At the same time ported to the third Python from the second.  After all the bureaucratic steps, a new major release of version 0.5.4 was released, and I continued to pursue this project in my spare time. <br><br>  The next major release, which came out this fall, supported the MS UI Automation technology, that is, a much wider range of applications.  He has already left the developer community.  We continue to support this library, there are still many plans to support other platforms. <br><br><img src="https://habrastorage.org/web/e17/bf2/602/e17bf26029ef4dedba37ea52776c47ae.jpg"><br><br>  About the technology itself UI Automation.  The name you heard, I guess.  Some people think this is pure .NET technology.  In fact, it is not.  There is a wrapper on .NET.  And the core of this library, for the client part, has a native COM interface. <br><br>  There are other open source tools on the same C # that uses .NET technology.  These are TestStack.White, which already exists for quite a long time, and the younger Winium.Desktop, which offers an interface in Selenium-style. <br><br>  And that, and other library can be used, if you prefer C #.  At one time, I gave students the task to drag and drop a file from explorer.exe using drag-and-drop to the same Yandex or Google Drive.  Both with White and Winium, they coped normally, both tools are quite usable.  The only thing is not quite clear how in C # they could become cross-platform in the future. <br><br>  The pywinauto library is by popularity in the middle between them, everything is ahead. <br><br><img src="https://habrastorage.org/web/f31/da0/bdf/f31da0bdf1f04be887362f16c46e5ede.jpg"><br><br>  UI Automation would use everything if it were completely perfect.  Unfortunately, it is better than the Win32 API, but there is still some bulkiness.  Plus, using the .NET wrapper may not be very good, because sometimes it is easy to miss some controls.  There is a rarely reproduced but known bug. <br><br>  Plus the COM interface, though native, is not quite standard.  This is not IDispatch, as in MS Excel or Word.  They use their own custom interfaces. <br><br>  And of course, technology, too, not everyone can.  Java has its own distinctive window system.  GTK +, in my opinion.  Generally with accessibility-technologies on Windows they have nothing.  This is not 80% of the market, if we talk about Java and especially about GTK +.  Therefore, you can cover a wide range of applications. <br><br><img src="https://habrastorage.org/web/7da/d52/6ac/7dad526accf6443f944732a06ae6beb8.jpg"><br><br>  At one time we tried to use UI Automation from under .NET.  There is a Python interpreter that works directly on .NET, ‚ÄúIron Python‚Äù, but it is not perfect by itself either, I had to crush it with a small C # library, because there is an unpleasant bug with ArrayList.  Moreover, the project has for some time been about to die.  It seems to be resurrected again, if we talk about "iron Python".  In general, not an option. <br><br>  But there was a solution for pure Python, called CPython.  This is Python, which is available to everyone on python.org or ActiveState Python. <br><br>  There is a third-party non-standard Python project called Com Types.  It supports these custom COM interfaces.  He really saved us and allowed us to do a lot.  Of course, he has his limitations.  Apparently, there is a deep and small, but unpleasant and hard-to-find bug, which does not allow loading functions from the library that allow processing custom controls.  Maybe in the future someone will solve this problem, but it is difficult to hope for someone. <br><br><img src="https://habrastorage.org/web/220/322/3a9/2203223a9cd0411c89f24eefa086cc65.jpg"><br><br>  Nevertheless, we can support all standard controls.  Changes that need to be made to the pywinauto code: we introduced the concept of a low-level layer, left Win32 API support and added what we called another backend, uia. <br><br>  At first, the only difference is that we run the application not only as an application object, but indicate that it supports another backend.  And that's all.  Then almost everything is the same.  Not really - the hierarchy of windows is slightly different for different accessibility technologies.  But fundamentally the approach is the same. <br><br><img src="https://habrastorage.org/web/77c/f1a/092/77cf1a0920d848239dcb1c2e183fe0f2.jpg"><br><br>  What is this approach?  First of all, we need a starting point from which we will dance.  This is an application object.  You can start it and connect to an already running application.  There is a large range of criteria by which we are able to connect: by exe, by windows somehow.  There may be more criteria, only examples are given here. <br><br>  In some desktop applications, especially on Windows 10, even the hierarchy of windows can be spread over several processes ‚Äî like, for example, a calculator.  In order to run throughout this hierarchy, it is sometimes more convenient to take and from the root element to dance, tons of the desktop object, which we recently implemented specifically for this purpose. <br><br>  From the application or root element, we can create a window specification.  This is just the core concept, the very foundation of the pywinauto interface device.  Window specification - we just describe it.  It may not exist, and it may no longer exist on the screen.  And from this description we can look for the control. <br><br>  After we found it, we create a Wrapper object - a wrapper attached to a real-life button, a real-life editbox, something green with tentacles that can pull control and control it. <br><br>  Let us see in more detail what kind of descriptions you can create. <br><br><img src="https://habrastorage.org/web/6de/e62/4e7/6dee624e7ec24339a69652a7d70c2253.jpg"><br><br>  The first and easiest is to simply go from the application by the name of the main window, then by the name of the button, for example.  But we have a restriction on access to an object through a point, by attribute.  If the text is in Russian or written in Chinese - what to do?  We'll have to use access by key, as to the usual Python dictionary.  It is almost the same. <br><br>  To be perfectly accurate, this is equivalent to the third option.  The search for the window is approximately up to typos, because spaces cannot be entered into the access by attribute in the first option.  So we can use this in more detail - creating detailed descriptions.  There may be more than one criterion, but, as shown below, two or more at once, so that the text is the same and that the type of control we have coincides.  When we specify the type of control explicitly, it works faster.  This is a small trick on writing faster code. <br><br><img src="https://habrastorage.org/web/9e3/ce1/638/9e3ce16389e5444a8df35251153389bd.jpg"><br><br>  How does this whole kitchen work?  From the window specification, you need to somehow create a Wrapper.  The first blue line and the second one work in exactly the same way, they do the same thing, just creating a Wrapper object is hidden with Python tools.  Python has not yet done so. <br><br>  If we do this without a click, but simply write such a statement at the bottom, they will return slightly different things.  The first option will return the window specification, the second - Wrapper, with which you can work.  When laying, when developing a test, it is convenient to explicitly call a Wrapper object and see what methods it has, what we can do with the control.  In the production code, in order not to clutter up, you can remove these Wrapper objects.  Then they will be automatically created, and the Click method or something else will start to be called. <br><br><img src="https://habrastorage.org/web/1e8/9e2/5ff/1e89e25ff8144e879bb68a84400402a1.jpg"><br><br>  Prior to this, we did not explicitly indicate inside what class object we are creating.  Pywinauto can automatically search for the desired class and create the desired class for the desired Wrapper.  It works through metaclass in Python.  Another black magic python.  This is a kind of registry of objects, called the registry pattern.  It stores some class registries.  Depending on what type of control you have - usually this is a string of a class name - it can create an object of the necessary class. <br><br>  If we call the base class, which is called HwndWrapper, then the second branch new_class automatically searches for the necessary Wrapper and creates an object of this class.  And if we create a derived class, it simply creates it explicitly.  If we want, we can explicitly create the specified class, but in most cases this is not necessary, which slightly reduces the input threshold for people with little or no programming experience. <br><br><img src="https://habrastorage.org/web/c35/c96/5f1/c35c965f1f8f487dab11da20ede489eb.jpg"><br><br>  This is how the derived class from HwndWrapper is implemented.  This indicates which class name is accepted.  This is support for standard ComboBox and Windows Forms.  Next, we have methods that can pull controls. <br><br><img src="https://habrastorage.org/web/b22/2ca/a7c/b222caa7c2e6465b8cef410b70d1d162.jpg"><br><br>  Consider a part of the example with dragging from explorer.exe somewhere in Yandex.Disk, but without Yandex.Disk so far.  The example is not so trivial, in explorer using the Win32 API, not everything can be done.  We have the pywinauto folder open, we want to click on the file and see its properties, a training example. <br><br><img src="https://habrastorage.org/web/3eb/17a/022/3eb17a022037414da817ada9f5d7b847.jpg"><br><br>  To complete it, you need not so many lines on pywinauto.  We connect to the explorer, which has the window title we need.  Switched to the active window.  Next is a list of files. <br><br>  It is necessary to add a function that waits until the use of the processor drops, because there is a lazy initialization, more on that later.  Also one additional line. <br><br>  We do the right_click_input, it clicks, we call the properties menu in the context menu with one line.  Then, since the properties are opened not in explorer.exe, but in another process, we go to it through the desktop object, we get a dialog and just click on the Cancel button.  All it takes is so much. <br><br>  Result. <br><br><img src="https://habrastorage.org/web/06a/d38/1ac/06ad381ac11c419cbc337a9ea7745114.jpg"><br><br>  A little bit of magic.  Supervision <br><br><img src="https://habrastorage.org/web/12a/f85/c2e/12af85c2e7f146308c04f5ea9223787e.jpg"><br><br>  Where can I get identifiers by which we can communicate to controls?  Suppose there is a main window, it has a title, it is visible.  Then you can print all the identifiers.  Some things can actually be copied into Python code, into your own script. <br><br>  For example, the ComboBox attribute has two suggested names: simply ComboBox and border-sized ComboBox.  On the left - just a static control. <br><br><img src="https://habrastorage.org/web/c02/f0e/fc0/c02f0efc093a4476bfcbf3f15c13e7c9.jpg"><br><br>  We have five ways to cast a spell.  We can apply simply by text, the OK button.  We can say that this is not just OK, not just some inscription, but also a button ,.  We can, if there are a lot of buttons and all have the same text, just refer to the index: button1, button2, etc. If the controls are dynamic, EditBox, the text in it is constantly changing, we enter and delete something there, then we need something something static to access the control equally each time.  Any label on the left or a TextBox can be static.  In the case of Tab Control and other elements of the list, we can refer to the type of control and the name of one of the tabs.  Internal text can also participate in this name.  This scheme fully covers how to access controls. <br><br><img src="https://habrastorage.org/web/881/bc0/970/881bc0970b15477fb79f7e78edac385d.jpg"><br><br>  There is a very detailed way - when we create a Windows specification by calling the Window method.  It doesn't matter how the specification is created.  According to it, we can wait for it to appear or when it disappears, switch simple states of the type enabled or visible. <br><br>  Another useful thing, when it comes in handy for the same explorer, is to wait for the CPU load to fall.  And not for the whole system, but for this particular process.  There are such things in the Win32 API, we implemented them through such a simple wrapper.  We expect that the processor load for the specified process will fall below 10% and, if this has not happened within 10 seconds, we throw an exception. <br><br>  Also, for expectations, there are methods that do not throw exceptions, but simply return true or false, exist, visible, etc. <br><br>  Maybe it looks understandable, but the topic of desktop automation is complex, there are a lot of pitfalls. <br><br><img src="https://habrastorage.org/web/f81/53b/9b2/f8153b9b20c84d2eb9148435dd4ebcc8.jpg"><br><br>  It takes some experience to write GUI tests.  Programming experience is very desirable. <br><br>  About common problems that do not depend on the library.  You can meet them both with pywinauto and with any other library. <br><br>  Often for graphic tests you need an active desktop.  If you locked the system and went to dinner, there is no active desktop.  If you went through the remote desktop and turned it off, you again have no active desktop.  And if unfolded, that is.  You want the script to run, test something while you are having lunch.  For remote desktop, you can not minimize it, but exit the full-screen mode, leaving it in window mode, run the script and quickly switch to your local laptop, for example.  At this time, the script works fine, but the way is a little collective farm, because you need to turn off the laptop and go home in the end. <br><br>  To run tests in the lab, you need to configure the VNC server, and even if we disconnect from the session, the active desktop is still disconnected.  This is one of the tricks that had to be learned and applied. <br><br>  And of course, if you run the script from under the same jenkins-slave, which God forbid, comes as a service, then again it will not work.  This is an operating system limitation.  It is impossible to work with the graphical interface as from under the service. <br><br>  A little about other platforms.  On Linux, there is also a Python package - pyatspi2, which uses atspi technology.  On OS X there is pyatom.  They are not very convenient to use and require, in particular, compilation.  Pywinauto does not require compilation, just put one line.  Javista recommend the Jemmy library of those that can really be used. <br><br>  Recently, our small community has been working in this direction.  Technology atspi on Linux and OS X. There is a simple prototype, which is only in the process of learning. <br><br>  As for Java, they have not even started there.  But from more or less usable there is a library JPype, which from pure CPython allows you to call Java code.  I know there is a jython that runs right in a java virtual machine.  This is also a Python interpreter, it also has features that are not very compatible with regular CPython.  A more promising direction in the development towards Java, I would see JPype. <br><br>  Of course, I want more features.  Other things have already been laid in pywinauto, but they are still poorly used.  Implemented global hooks when we can subscribe to an event in the operating system.    ,           ,   .   ,    ,    ,     . <br><br>   UI Automation      ,    .      ,  ,  ,        .      record/replay,   ,     .     ,       ,    . <br><br>       ‚Äî        , ,    .     ,        ,  ,  ,   ,    ,         . <br><br>    .    , ,  EditBoxes    -    -   .   ,     ,  .    ,  ,     . <br><br>      .   open source,   .   . <br><br><img src="https://habrastorage.org/web/c3d/83d/0a0/c3d83d0a01f948fc9a42f1187d40ce29.jpg"><br><br>    GUI.      ? ,   ,        unittest.      , -  GitHub    .     Windows    Linux.    Linux    . <br><br>   ,           . <br><br>  ,         Python.  ‚Äî  95%,  . <br><br><img src="https://habrastorage.org/web/11c/adc/9ec/11cadc9ecf1a4131befc7a44809480c7.jpg"><br><br>  ,        ,      .    .  ,        ,        .          UIAutomation   .        Linux,      accessibility API  Apple,     . ,   - pywinauto        . <br><br><img src="https://habrastorage.org/web/f1f/c7b/f55/f1fc7bf5506646a1851ec7061712e9b0.jpg"><br><br>  ‚Äî    ,     ,    .        ,   .       Stack Overflow,  ,     .  ,  -       .   , . </div><p>Source: <a href="https://habr.com/ru/post/336476/">https://habr.com/ru/post/336476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336464/index.html">Dealing with complexity in an application layer network protocol</a></li>
<li><a href="../336466/index.html">We check the browser for support of certain CSS properties</a></li>
<li><a href="../336468/index.html">Creating a programming language using LLVM. Part 7: Language Expansion: Variable Variables</a></li>
<li><a href="../336470/index.html">Why GitHub can't host the Linux kernel</a></li>
<li><a href="../336474/index.html">Work and life in Bulgaria</a></li>
<li><a href="../336478/index.html">We sharpen a tool on PyQt</a></li>
<li><a href="../336480/index.html">Solving the direct and dual problems of linear programming with Python</a></li>
<li><a href="../336482/index.html">Migrate the VueJS application to Vuex</a></li>
<li><a href="../336486/index.html">Inter-AS Option C Pitfalls on JunOS</a></li>
<li><a href="../336488/index.html">The digest of interesting materials for the mobile developer # 218 (August 21 - August 27)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>