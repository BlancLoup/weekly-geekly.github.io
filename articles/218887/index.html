<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the application protected by the virtual machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will consider building application protection using various software "tricks" such as: resetting the zero entry point, encrypting ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the application protected by the virtual machine</h1><div class="post__text post__text-html js-mediator-article">  In this article, we will consider building application protection using various software "tricks" such as: resetting the zero entry point, encrypting the file body and the decryptor covered with polymorph garbage, hiding the execution logic of the application algorithm in the virtual machine body. <br><br>  Unfortunately, the article will be hard enough for an ordinary application programmer who is not interested in software protection, but there's nothing to be done about it. <br><br>  For more or less adequate perception of the article will require minimal knowledge of the assembler (there will be a lot of it) as well as skills in working with a debugger. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But those who hope that some simple steps to implement this type of protection will be given here will have to be disappointed.  The article will consider the already implemented functionality, but ... in terms of its hacking and the full reverse of the algorithm. <br><br>  The main goals that I set for myself are to give a general idea of ‚Äã‚Äãhow such software protection works, but the most important thing is how a person who will remove your protection will approach this, because there is an old rule - you cannot implement a competent protection kernel algorithm imagining the methods of its analysis and hacking. <br><br>  As a recipient, on the advice of one sufficiently competent comrade, I chose a slightly old (but not lost in actuality, due to the quality of performance) keygenme from the notorious Ms-Rem. <br><br>  Here is the original link where it appeared: <a href="http://exelab.ru/f/index.php%3Faction%3Dvthread%26forum%3D1%26topic%3D4732">http://exelab.ru/f/index.php?action=vthread&amp;forum=1&amp;topic=4732</a> <br>  And then he got here: <a href="http://www.crackmes.de/users/ms_rem/keygenme_by_ms_rem/">http://www.crackmes.de/users/ms_rem/keygenme_by_ms_rem/</a> <br>  Where this keygenme was set to 8 out of 10 (* VERY VERY * hard). <br>  Although, to be honest, this is a slightly overestimation - I would put in the area of ‚Äã‚Äã5-6 points. <br><br>  Perhaps we will begin. <br><a name="habracut"></a><br><h4>  0. Requirements </h4><br>  For good, for the full debugging of this keygenme, the most convenient platform will be Windows XP 32 bits, it is generally the most optimal environment, therefore I am constantly deployed on my workstation as a virtual machine. <br><br>  Under Windows 7 - 32 bits (on which debugging was actually done in the process of writing this article) will be a little difficult, but they can be solved (this will be mentioned in the fourth chapter of the article). <br><br>  Serious difficulties will begin on 64-bit OC due to the fact that the tool used as the main tool (OllyDebug) when debugging this Keygenme will produce errors even at the stage of the loader operation.  OllyDebug version 2 will not spit out these errors, but there is one more difficulty, for it there are no necessary plug-ins yet (or maybe I‚Äôve been looking badly). <br><br>  The keygenme itself must be downloaded from this link: <a href="">http://exelab.ru/f/files/3635_03.05.2006_CRACKLAB.rU.tgz</a> (registration will be required). <br><br>  To complete the work with the text of the article, if you decide to go through all the steps described in it, you will need a small set of tools. <br>  I will not describe here in detail about them, all that needs to be done is described in the file ‚Äúused_tools.txt‚Äù located in the root of the archive with examples for the article: <a href="">http://rouse.drkb.ru/blog/vm_analize.zip</a> <br><br>  It is also necessary to remember the correct pair of login and serial numbers provided by the very first link, namely ‚ÄúMs-Rem‚Äù and ‚ÄúC38FB7A0CF38F73B1159‚Äù.  These data will greatly help in the process of parsing keygenme. <br><br>  Once everything is set, you can begin. <br><br><h4>  1. Initial analysis </h4><br>  For a start it is worth deciding what we are dealing with. <br>  Start PEiD and open keygenme.exe in it. <br>  Press the rightmost bottom button and select the ‚ÄúHardcore Scan‚Äù type in the menu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/a1c/51f/fbba1c51f0d6f68e2cba2585adb9880f.png"></div><br><br>  The trouble starts right away, firstly the entry point of the Entrypoint is set to zero, which cannot be in a normal executable file, secondly, the scan showed that UPolyX v0.5 * is present. <br>  The second is just not scary - there would be something like ‚ÄúEXECryptor‚Äù or ‚ÄúThemida‚Äù - some kind of commercial protectors, then yes, and then just some suitable signature seemed to be found. <br><br>  We press the second lower right button and in the appeared dialog there are three buttons on the right. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18a/8ba/4bc/18a8ba4bc6b87c30436744765ed1913f.png"></div><br>  He says that the file is packed and the entropy is already 7.56. <br>  Well, let's say, although it still says nothing.  Big entropy happens not only at the packed, but also at the ciphered files. <br><br>  Close the dialog and click on the button to the right of "Subsystem:" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d9/e8f/021/9d9e8f021eb6c55971c86062ab5e9648.png"></div><br>  In addition to the entry point, the code and data bases are killed, the standard load base is 4000000. <br>  Well, okay - in our hands we have a file that was slightly adjusted with pens. <br>  Let's try to feel it all in the debugger. <br><br><h4>  2. Analyze the behavior of the application with Entrypoint = 0 </h4><br>  Open OllyDebug, go to the "Options" menu, select "Debugging options" and on the "Events" tab set the checkbox "Make first pause at: -&gt; System breakpoint". <br>  Thus, we will force the debugger to stop when receiving the first debug message before transferring control to the body of the application being debugged. <br>  This is done because of the entry point dropped to zero. <br><br>  Open the keygenme.exe itself and immediately interrupt somewhere inside the ntdll.dll <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/13b/ed6/19613bed6628439ab7f6e3f8ac98d6e2.png"></div><br><br>  What is the entry point (for the application) is the offset from its load base (hInstance), to which the loader transfers control immediately after the process is initialized. <br>  The load base always contains a PE header, where the very first is the _IMAGE_DOS_HEADER structure. <br><br>  Since  the entry point at keygenme is zero, which means control will be transferred directly to its hInstance. <br><br>  Knowing this, let's see what we have there. <br>  Press "Ctrl + G" and drive in the address of the database "400000", it should work out something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/2b9/91e/cad2b991e0ee8ada5b573df785e25a9f.png"></div><br>  Quite a decent code instead of a standard header, but the title should be in place, otherwise the application would not start, so changes were made directly to _IMAGE_DOS_HEADER. <br><br>  We look what exactly has changed: <br><br><pre><code class="delphi hljs">_IMAGE_DOS_HEADER = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-comment"><span class="hljs-comment">{ DOS .EXE header }</span></span> e_magic: Word; <span class="hljs-comment"><span class="hljs-comment">{ Magic number }</span></span> e_cblp: Word; <span class="hljs-comment"><span class="hljs-comment">{ Bytes on last page of file }</span></span> e_cp: Word; <span class="hljs-comment"><span class="hljs-comment">{ Pages in file }</span></span> e_crlc: Word; <span class="hljs-comment"><span class="hljs-comment">{ Relocations }</span></span> e_cparhdr: Word; <span class="hljs-comment"><span class="hljs-comment">{ Size of header in paragraphs }</span></span> e_minalloc: Word; <span class="hljs-comment"><span class="hljs-comment">{ Minimum extra paragraphs needed }</span></span></code> </pre> <br>  The e_magic field cannot be touched and it must always contain the initials of Mark Zbikowski 'MZ' (0x4D, 0x5A). <br>  Actually it is not touched, and both of these symbols are interpreted as instructions: <br><br><pre> <code class="delphi hljs">DEC EBP <span class="hljs-comment"><span class="hljs-comment">//     POP EDX //       EDX</span></span></code> </pre><br>  The value of the second e_cblp field is changed to 0x45, 0x52, which, as a result, cancels the changes made by the first two instructions, restoring the correct stack state. <br><br>  The remaining 4 fields are used to implement the MOV + JMP commands. <br>  Here in this picture it is shown more clearly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9a/f6c/ef4/d9af6cef42ef8985d8fb3d5ee9f0eb3c.png"></div><br>  The whole point of such manipulations with _IMAGE_DOS_HEADER and a dropped entry point is the transfer of control somewhere inside the application body at 4053B6. <br><br>  Those.  in principle, we can open keygenme.exe right now and specify 53B6 as an entry point in the corresponding field (ignoring edits in the file header), but is this the correct entry point? <br><br><h4>  3. Disassemble the decryptor code of the application body and unpack the application. </h4><br>  We go to the address of the transition "Ctrl + G" 4056B6 and there we see this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/9c9/d13/a629c9d133062f073057d2fb385f3cc8.png"></div><br>  Generally solid garbage.  Whatever the line, the garbage instruction. <br>  For example, all conditional branch operators (JG / JPE / JCXZ / JE) are garbage, because  it does not matter whether the condition is fulfilled or not, the transition will always be carried out to the next line (note the addresses of the jumps). <br>  Instructions LEA, MOV, XCNG work with the same register without making any changes to its state - garbage. <br>  The instructions for working with the mattress processor (FCLEX / FFREE) reset the exceptions (which are not present, since the work with the mattress processor has not yet been carried out) frees the registers (which are not actually occupied) - garbage. <br><br>  Scroll through the code to the end to see where this mess of garbage ends. <br>  Just scroll down until we get to the code consisting of all zeros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/360/9a7/969/3609a796997a9aaa293f8b1d06439b01.png"></div><br>  Yeah, but it looks like the address we need is 401000, to which the jump is going, which theoretically could be the original entry point. <br><br>  Let's see what is there: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f7/9c0/58b/3f79c058b3cbae7c5e0ae66069fb8fa0.png"></div><br>  And there we have the code, which obviously should not be in the Win32 application, which is clearly indicated by the instructions IN and OUT, which will generate an exception when they are executed. <br><br>  So it turns out that the code at the original entry point (OEP - Original Entry Point) is encrypted and the code in procedure 53B6 must decrypt it before performing the final jump. <br><br>  But!!! <br>  But in the 53B6 procedure, as shown earlier, garbage. <br><br>  In fact, there should be more than trash.  Apparently we are dealing with the so-called garbage polymorphic, and in its most simple implementation. <br><br>  The task of the polymorphic engine is to convert the original code by replacing the original instructions with their analogues (or groups of analogues).  In order to make the analysis of the resulting code difficult, garbage blocks of instructions are usually added. <br>  Here, the blocks are not observed, just garbage instructions are generated, plus in the end even if there was a replacement of instructions with analogs, then I noticed this only in one case.  It is quite possible that just a garbage generator was used here, which plentifully crammed it between useful instructions, who knows ... <br><br>  However, a task appeared - it is necessary among all this garbage from the address 4053B6 to 406839 (5251 bytes - however) to find useful instructions that carry out the application's script. <br><br>  This can be done in two ways. <br>  The first is to view the entire code with the eyes and try to find such instructions.  I even tried it for the sake of interest and spent about 7 minutes, as a result I even found two such instructions, which are not rubbish.  However, as it turned out later, I missed one between them, and even after the second one I found, I somehow got sick of looking further - too tedious. <br><br>  Therefore, let's go the second way, and write a small script that will help remove all the garbage and leave only the payload. <br><br>  The script itself is located in the <a href="">archive that goes with the article</a> along the following path: ". \ Scripts \ fill_trash_by_nop.txt". <br>  To run it, the OllyScript plugin must be installed. <br><br>  The script runs like this: you need to restart the keygenme in the debugger and wait for the first BP to be triggered inside NTDLL, then select ‚ÄúODbgScript-&gt; Run Script ...‚Äù in the ‚ÄúPlugins‚Äù menu, select the script file in the dialog (the path is above) and run him. <br><br>  As soon as the script starts its work, you can go to make yourself some tea, you will have five minutes of free time. <br><br>  The logic of the script is simple: <br>  Since  the garbage instructions do not change the register values ‚Äã‚Äã(except for EIP), the garbage instruction is detected by checking the state of the registers before and after its execution, if the registers have changed - the instruction performs something useful, otherwise the instruction is considered garbage and the NOP is placed instead. <br><br>  When the script completes its work and displays a message, you can view the results of its work (do not stop the debugger itself - it is still needed). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/483/bcf/bb9/483bcfbb92eb975c85fd2478fadbff31.png"></div><br>  All the garbage will be replaced by NOP and we will only have the following instructions (we need to go from 4053B6 to 406839 and write everything that is not NOP into a notebook): <br><br>  The first two lines will be some garbage (zero-delayed sleep is called). <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">0040548</span></span>B PUSH <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0040548</span></span>D CALL DWORD PTR DS:[&lt;&amp;kernel32.Sleep&gt;] ; kernel32.Sleep</code> </pre><br>  Well, more precisely, how - this is not exactly garbage, this line causes the bootloader to load kernel32.dll into the process address space, paired with the already loaded ntdll.dll, when the process starts;  This library is declared in the keygenme import table (just as one single function sleep). <br><br>  Next comes the decryptor code itself: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">004054</span></span>B4 MOV ESI,keygenme.<span class="hljs-number"><span class="hljs-number">00401000</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ESI      0040559D MOV EDI,ESI //  EDI   //   ..      00405677 MOV ECX,1058 //    . //   16736 , // ..    4  ($1058 * 4) 004057FE LODS DWORD PTR DS:[ESI] //  4  00405904 NEG EAX //   -1 00405B69 NOT EAX //   NOT, //     EAX  1 // (NEG + NOT = DEC) 00405D3A BSWAP EAX //   00405E90 SUB EAX,4FE62125 //  0x4FE62125 00406121 XOR EAX,12345 //   0x12345 00406256 STOS DWORD PTR ES:[EDI] //    00406442 DEC ECX //     004065C8 JNZ keygenme.004057D9 //     (  004057FE LODS)</span></span></code> </pre><br>  and direct transition to OEP on which the debugger is currently stopped. <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">00406839</span></span> JMP keygenme.<span class="hljs-number"><span class="hljs-number">00401000</span></span></code> </pre><br>  Roughly speaking, if you look at the decryptor's instructions, the keygenme body is decrypted by this simple algorithm: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, Winsock; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, A: Integer; M: TMemoryStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> M := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M.LoadFromFile(<span class="hljs-string"><span class="hljs-string">'keygenme.exe'</span></span>); M.Position := <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       $1000 for I := 0 to $1058 - 1 do begin M.ReadBuffer(A, 4); // LODS Dec(A); // NEG + NOT A := htonl(A); // BSWAP Dec(A, $4FE62125); // SUB A := A xor $12345; // XOR M.Position := M.Position - 4; M.WriteBuffer(A, 4); // STOS end; M.SaveToFile('keygenme.exe'); finally M.Free; end; end.</span></span></code> </pre><br>  Now, in order not to wait for the file decryption each time, you need to dump the result (the OllyDump plugin must be installed). <br><br>  To do this, you need to switch to OEP (‚ÄúCtrl + G‚Äù 401000) and place a breakpoint there, and then continue with the program. <br>  As soon as the debugger stops at the installed BP, go to the ‚ÄúPlugins‚Äù menu, there we select ‚ÄúOllyDump-&gt; Dump debugged process‚Äù, this dialog will open: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/515/9cb/6d45159cb69d3902e181c1adda41f16d.png"></div><br>  Focusing on the ‚ÄúVirtual Offset‚Äù column, set the code base to 1000, and the database to 7000, remove the ‚ÄúRebuil import‚Äù checkbox and press the ‚ÄúDump‚Äù button. <br>  In the dialog that appears, specify the new name "keygen_unpacked.exe". <br><br>  Actually everything - so we took off the first envelope. <br><br>  <b>A little trick:</b> <br><br>  In general, it was possible to dump more easily, without considering the source code of the decryptor and other things, but since I decided to look at everything thoroughly, therefore I also had to stop at it. <br><br>  The second unpacking option is as follows. <br>  1. Run the debugger and wait for the first BP to fire inside NTDLL. <br>  2. Go to the tab of the memory card "Alt + M" and at the address 401000 put MBP on the record: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/d78/0e5/7ded780e5d64d79fbd1b4c6a4c6d1349.png"></div><br>  3. We start the program for execution as soon as we have interrupted for a write operation (this will be the STOS DWORD instruction), go back to the memory card and remove the MBP, then go to the OEP (401000) and set the usual breakpoint there. <br>  4. Well, as soon as we stop on it - you need to perform the steps already described on the dump of the process. <br><br>  By the way, if you want, you can check the resulting file under PEiD, the entropy magically became 6.95 - but all just decrypted the data block. <br><br><h4>  4. Primary analysis of the unpacked file and bypass startup problems for Vista and above. </h4><br>  Now we will work with the already unpacked file. <br>  Since the entry point in it is set correctly, in order not to make extra gestures, you need to configure Olly to make the first stop not in NTDLL, but directly at the entry point. <br>  Open OllyDebug, go to the "Options" menu, select "Debugging options" and on the "Events" tab set the checkbox "Make first pause at: -&gt; Entry point of main module". <br><br>  Open the keygenme_unpacked.exe and see what the previously encrypted code has become: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa0/3ea/8c4/fa03ea8c4272050c3def022fd05e0349.png"></div><br>  We immediately see the first ‚Äútrouble‚Äù, the first CALL call goes inside itself (the address 401004 is called, while the next instruction starts only with 4010005). <br><br>  I have already talked about such jumps earlier in this article: <a href="http://habrahabr.ru/post/178159/">‚ÄúWe study the debugger, part two‚Äù</a> <br><br>  The essence of such a trick is to confuse the disassembler and make it display the wrong code that will be executed in reality.  There is nothing wrong with such a ‚Äútrick‚Äù, just press F7 performing this CALL and immediately see the correct code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c46/c09/51e/c46c0951ebb2c7f2ba10f373aeb44b55.png"></div><br>  You can once again dump the process + remove the POP EBX instruction to turn off such a ‚Äúfocus‚Äù, but since  it will not interfere - let's leave it as it is and start analyzing. <br><br>  First comes a block of five instructions that reads some data from the PEB (Process Environment Block), whose address is always located in FS: [$ 30]. <br>  If you open the PEB structure and see what the offsets shown in the code mean, you‚Äôll get something like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">0040100</span></span>A MOV EAX,DWORD PTR FS:[<span class="hljs-number"><span class="hljs-number">30</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    PEB 00401010 MOV EAX,DWORD PTR DS:[EAX+C] //    PEB-&gt;LoaderData 00401013 MOV EAX,DWORD PTR DS:[EAX+1C] //  LoaderData-&gt;InInitOrder 00401016 MOV EAX,DWORD PTR DS:[EAX] //    _LDR_DATA_TABLE_ENTRY 00401018 MOV EAX,DWORD PTR DS:[EAX+8] //   DllBase</span></span></code> </pre><br>  Thus, these five instructions look for hInstance "kernel32.dll", which will be located at this address, though under Vista and above, this address will be located hInstance "kernelbase.dll" and this will be associated with one nasty error. <br><br>  The LEA ESI instruction, places in ESI a pointer to a small array of Ansi strings located at 004012DE.  These are three strings separated by zeros: "LoadLibraryA", "ExitProcess", and "VirtualAlloc". <br><br>  By the way, I completely forgot to mention this earlier, if you look at the keygenme.exe import table, you will see that it imports one single function kernel32.sleep, the rest are missing.  This means that the addresses of the others necessary for the work, the application should find by itself. <br><br>  The following instruction, LEA EDI, places in EDI a pointer to a buffer that will contain the addresses of the functions found (this will be a virtual import table for kernel32), after which the procedure is called at 401198. <br><br>  In fact, both LEA EDI / ESI calls are garbage, because  These registers will be reset when you call the procedure at 401198, but they will be used in it exactly as I described above (EDI, more precisely EBP + 305, will eventually contain the addresses of functions). <br><br>  In short, the task of procedure 401198 is to prepare an ESI register in which a pointer to the name of the function sought is placed, as well as an EDI register in which a pointer is placed to the library's export table, the hInstance of which we received by reading the data from PEB, <br>  then call the function at 4011E2, which will search by name. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/ced/1a0/624ced1a035f9e3ea274d76dab8d40c7.png"></div><br>  And here we are waiting for the second trouble, much more serious than the trick with CALL at the very beginning. <br><br>  The very first one will be searched for "LoadLibraryA", which "kernelbase.dll" does not export. <br>  This means that under Windows Vista and above, this keygenme will not work and will fall at the start. <br><br>  You can check, the exception will rise here: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">004011</span></span>EB CMPS BYTE PTR DS:[ESI],BYTE PTR ES:[EDI]</code> </pre><br>  To get around this is quite simple, just after starting the keygenme, put the BP on the instruction: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">0040101</span></span>B LEA ESI,DWORD PTR SS:[EBP+<span class="hljs-number"><span class="hljs-number">2</span></span>DE]</code> </pre><br>  those.  immediately after receiving the library loading address, and changing the value in the EAX register to the hInstance of the library ‚Äúkernel32.dll‚Äù (the correct address can be found in the memory card of the Alt + M process). <br><br>  After such manipulations, the keygenme will start as normal. <br><br>  In order not to do this every time the application starts, it will be enough to run the script from the folder ". \ Scripts \ run_at_vista.txt", which will automatically replace the EAX value with the correct one each time and start the program without errors. <br><br><h4>  5. Read login and serial number </h4><br>  Now it's time to see how the login and serial numbers are read into the application memory and what modifications are made on them. <br><br>  Usually, reading data from EDIT occurs through the function "GetWindowsText" or "GetDlgItemText", but since  in the end, the second function still calls the first one, then we will set the breakpoint on ‚ÄúGetWindowsText‚Äù. <br><br>  To do this, after the keygenme was launched (and the user32.dll library was also loaded) and its dialog box appeared, go to the debugger and look for all available functions in all modules: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/514/2dc/c2f/5142dcc2f792e3b363c6d7f2ed92a799.png"></div><br>  In the dialog that appears, look for the name of the exported function ‚ÄúGetWindowsTextA‚Äù, and in the menu select the item ‚ÄúFollow in Disassembler‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/68e/a02/7de68ea0232cfa952cb699a3d8628d92.png"></div><br>  After that, we put the BP, go to the dialogue with the keygenme and enter the ‚ÄúMs-Rem‚Äù login and the serial number ‚ÄúC38FB7A0CF38F73B1159‚Äù into the corresponding fields. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/d38/434/df7d38434276b917f60689898988fb48.png"></div><br>  Click the "Check" button and ... stop at the breakpoint inside user32 just at the beginning of the "GetWindowsTextA" function. <br><br>  Now you need to return to the place of her call. <br><br>  Click: <br>  1. Ctrl + Shift + F9 - jumping to the end of the function ‚ÄúGetWindowsTextA‚Äù <br>  2. F8 - go up to the function ‚ÄúGetDlgItemText‚Äù <br>  3. Ctrl + Shift + F9 - jumping to the end of the function ‚ÄúGetDlgItemText‚Äù <br>  4. F8 - go up to the place of the call <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/569/413/e915694131f74ff7e4b3a9ae9f1b1bca.png"></div><br>  The blue frame contains the ‚ÄúGetDlgItemText‚Äù call just made, with the following parameters: <br><br>  hDlg = ESI <br>  nIDDlgItem = 65 <br>  lpString = EAX <br>  nMaxCount = $ 10 <br><br>  We read the login value to the buffer pointed to by the EAX register, 16 bytes in size, and in the red frame the call to read the serial number to the buffer pointed to by EDI (EBP + 414E) 32 bytes would be highlighted. <br><br>  The most interesting begins immediately after reading the serial number. <br>  It is followed by an interesting cycle of 10 iterations, while the ESI register points to the buffer with the serial number just read, and EDI to the buffer where the result is placed: <br><br><pre> <code class="delphi hljs"><span class="hljs-number"><span class="hljs-number">00401111</span></span> MOV ECX,<span class="hljs-number"><span class="hljs-number">0</span></span>A <span class="hljs-comment"><span class="hljs-comment">//    00401116 LODS WORD PTR DS:[ESI] //      00401118 CALL keygenme.0040117B //   0040111D STOS BYTE PTR ES:[EDI] //  1  0040111E LOOPD SHORT keygenme.00401116 //    </span></span></code> </pre><br>  Those.  Over the serial number in the function 40117B, some transformations are performed, the result of which is placed in EDI. <br><br>  This function is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/fa2/d7b/2a8fa2d7b5bbd854fc0adfd2c5131bb8.png"></div><br>  This is something like converting two characters from a string HEX representation to a byte. <br>  If roughly this is an analogue of Result: = StrToInt ('$' + Value); <br>  Take for example the original known serial number: "C38FB7A0CF38F73B1159" <br><br>  After 10 iterations, it will be converted to an array with the following contents: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sn: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte = ($C3, $<span class="hljs-number"><span class="hljs-number">8</span></span>F, $B7, $A0, $CF, $<span class="hljs-number"><span class="hljs-number">38</span></span>, $F7, $<span class="hljs-number"><span class="hljs-number">3</span></span>B, $<span class="hljs-number"><span class="hljs-number">11</span></span>, $<span class="hljs-number"><span class="hljs-number">59</span></span>);</code> </pre><br>  But since  the function does not check for boundaries beyond which HEX values ‚Äã‚Äãshould not be in string format, that is, a very large range of acceptable values, which after such a reduction will give the same number. <br><br>  For example, that "C3" that "s1" as a result of this conversion will be equal to 195 (or $ C3).  Therefore, this will also be quite a valid serial number: " <b>s1</b> 8FB7A0CF38F73B1159". <br><br>  Thus, we conclude: the entered login is read as is, and the serial number after reading is converted to a byte representation, and, since  There are only 10 iterations, the length of the serial number should not exceed 20 HEX characters (the rest will not be taken into account). <br><br>  In principle, this is all the information that we need, now it's time to look at the keygenme source code from a slightly different angle. <br><h4>  6. Analyze keygenme under IDA Pro, disassemble VM and get its P-Code </h4><br>  Launch IDA Pro and open keygenme_unpacked.exe in it, right after opening we go to the tab ‚ÄúFunctions‚Äù. <br><br>  Only 8 pieces: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f8/3e8/466/7f83e8466c7a8640622cd08b62411e56.png"></div><br>  And almost all of us are known: <br>  401,000 is OEP, not interested <br><br>  401096 - and this seems to be the original entry point, which was before any encryption and creation of virtual IATs hung there, but, by the way, we no longer need it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07b/f1a/703/07bf1a70304fe46d2cfa188fb9cfdb95.png"></div><br>  40117B is HexToInt, saw ... <br>  401198 - filling virtual IAT, saw ... <br>  4011E2 - search function address by name, saw ... <br><br>  sub_401204 - something interesting (judging by the graph), perhaps we will begin with it, by the way, it calls the two remaining functions sub_401257 and sub_401276. <br><br>  And the calls to the reading functions from EDITs at 004010F5 and 00401107, as well as the cycle at 00401111, were not recognized by IDA as procedures due to garbage instructions going before them (and not so important). <br><br>  So, look at the function graph sub_401204: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/86b/ea5/31186bea5c78442276c5170093933ab0.png"></div><br>  Have you ever seen what a VM graph looks like in IDA? <br>  If not, then look - this is the body of the virtual machine, and it is quite simple. <br><br>  What is a virtual machine? <br>  Roughly ... a normal processor performs a set of instructions known to it (machine code that can be disassembled). <br>  A virtual machine is essentially also a processor, only it executes its own set of instructions that are generated and placed somewhere in the available memory in the form of a so-called P-Code. <br>  It is not at all necessary that these instructions will coincide with those that the real processor can execute (more precisely, on the contrary - in most cases they will not be the same). <br><br>  In the process of protection, commercial protectors disassemble the protected code blocks, generate their own virtual machine for each of them with a unique logic set and instruction set, translate the disassembled code into a picode that a particular virtual machine can execute and save the result as a buffer somewhere in the body applications.  Each VM, when receiving control during the execution of a program, sequentially reads the instructions of the picode intended only for it, and executes them. <br><br>  Thus, the attacker hides the logic of the protected algorithm, which he could disassemble under the debugger.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After such modifications, it will be necessary to first analyze each VM, and only after its complete analysis, the algorithm will be pulled out of the picode performed by it, transforming it back into a machine code understandable to the ordinary processor. The job is still ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the picture above, we see just one of the implementations of VM, which can execute only 8 instructions known to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a closer look:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/762/76d/e4376276d591489fc2854ade4c6fd9e0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything starts with the initialization of the EBX register, which indicates the beginning of the buffer with the picode for the virtual machine, as well as the EAX register, which is the cursor (index of the instruction being executed). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VM operation begins with the procedure loc_40120D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its task is to first obtain the opcode of the instruction being executed, by calling the function sub_401276, the code of which is given in the hint. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Judging by this code, it can be understood that the picode itself is also encrypted and immediately after reading each byte, its decrypt occurs approximately like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A, B: Byte; ... A := PicodeBuff[I]; B := A; B := B <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; A := A xor B; Result := A <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After receiving the opcode, it is checked, if it is zero, then control is transferred here: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/dd1/797/470dd17976e100fe99eb9f960016a82a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where a unit is simply added to some variable (let's call it arg_4 as it is), </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and as a result, further control is transferred to the finalizing block, which starts the execution of the next opcode, incrementing the EAX register.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/514/b62/fd4/514b62fd4fa39ccfefffe72a173c06d7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in it we can find out the total size of the picode, it is equal to $ 3DA2 (15778 bytes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, let's sort all the instructions in order: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0. (loc_4012CA): increases the value of the variable "arg_4" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. (loc_4012C5): decreases the value of the variable "arg_4" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. (loc_4012BE): increases the value pointed to by "arg_4" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ( loc_4012B7): decreases the value pointed to by arg_4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. (loc_4012A8): puts the value pointed to by arg_4 in memory pointed to by arg_8, then increases the value of the variable arg_8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 (loc_401299) :. puts the value pointed to by "arg_" in memory pointed to by "arg_4", and then increases the value of the variable "arg_"</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. (loc_401284): checks the value pointed to by ‚Äúarg_4‚Äù, and if it is zero, runs the procedure ‚Äúsub_401257‚Äù passing the value 1 to the EDX </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. (0040123E): checks the value pointed to by ‚Äúarg_4‚Äù and if it is not zero, runs the ‚Äúsub_401257‚Äù procedure, passing the value -1 to the EDX </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the ‚Äúsub_401257‚Äù procedure, the following occurs, EDX is the direction of the picode scanning, in the case of a positive value, opcode number 7 is searched, corresponding to opcode number 6 with regard to nesting (t. that is, if they go 066770, then when calling from the first opcode 6, the EAX cursor is set to zero, and when called from the second opcode 6, EAX will point to the second seven). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if EDX = -1, then the scan goes in the opposite direction, taking into account the nesting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's actually the whole VM.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing like? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yeah - that's Brainfuck itself, as it is. </font></font><br> <a href="http://ru.wikipedia.org/wiki/Brainfuck"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://ru.wikipedia.org/wiki/Brainfuck</font></font></a> <br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it turns out that inside the keygenme is an encrypted P-Code, which must be executed on the Brainfuck interpreter, which actually acts as a virtual machine (well, why not?) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, if you pay attention to the description of BF in Wikipedia and the implementation of handlers in this variant of the interpreter, you will see that the fourth and fifth opcodes (read and write) are interchanged. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, if so, all that is left for us is to pull out the picode itself from the keygenme body and the keygenme is no longer needed, then we ourselves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to determine the location of the buffer with the picode, put the BP at the beginning of the VM and look at the address with which EBX is initialized. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We launch OllyDebug and put BP on address 401208 in it.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/4aa/4b6/5494aa4b6b88535248f7bedb6818391c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After BP triggers, we look at the EBX value, this is the address 401380. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go to it in the dump window and look at the HEX values, the first 8 bytes are equal to "CE44 4E53101708DD". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now open the keygenme_unpacked.exe in any HEX editor and look for these 8 bytes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VM size, as we found earlier 15778 bytes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy 15778 bytes starting from those found in the ‚Äúvm.mem‚Äù file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great, now we have the P-Code of the virtual machine, which we have a long and hard work to do, and we no longer need the keygenme along with OllyDebug and IDA Pro, they have done their job. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: already copied file "vm.mem" is available </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive with examples for the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and is located in the folder ". \ Data \ vm.mem".</font></font><br><br>  By the way. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of reading the article, I was pointed out at such a moment: in a real combat application, the number of functions will be several orders of magnitude larger, and how, in this case, determine the body of the virtual machine? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this situation, it will be sufficient to set the BP to read external data (login and serial number), from which it will be easy enough to track the transition to one of the virtual machine handlers, or perform the same actions with the output buffer (after all, VM must do something and have interaction with the external environment). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But all this, of course, depends on the specific implementation of the VM and this approach is not always applicable.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. We write our own interpreter Brainfuck </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To begin with, we decode the resulting ‚Äúvm.mem‚Äù into a normal representation like this: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BrainFuckOpcode: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar = (<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'['</span></span>, <span class="hljs-string"><span class="hljs-string">']'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PicodeBuffSize = <span class="hljs-number"><span class="hljs-number">15778</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> PicodeBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..PicodeBuffSize - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; M: TMemoryStream; I: Integer; A, B: Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> M := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M.LoadFromFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\vm.mem'</span></span>); M.ReadBuffer(PicodeBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], PicodeBuffSize); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> PicodeBuffSize - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A := PicodeBuff[I]; B := A; B := B <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; A := A xor B; PicodeBuff[I] := Byte(BrainFuckOpcode[A <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; M.Clear; M.WriteBuffer(PicodeBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], PicodeBuffSize); M.SaveToFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\vm.brainfuck'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> M.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You get the file "vm.brainfuck" containing the BF code in the form in which it is usually recorded, and here it is already taken into account that the instructions "." and "," mixed up in places. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, this file can already be fed to any BF interpreter, and if you slip the correct buffer with a login and serial number, it will even be executed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way about the buffer with the login and serial number - I completely forgot to mention it. It enters the virtual machine as a block of 20 bytes, where the first 10 bytes are filled with login characters (if the login is less than 10 bytes, the remaining bytes are zero), and immediately after them there are 10 bytes of the serial number converted from the string HEX representation to byte.</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the ‚ÄúMs-Rem‚Äù and ‚ÄúC38FB7A0CF38F73B1159‚Äù known to us, the buffer will be like this: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">('M', 's', '-', 'R', 'e', ‚Äã‚Äã'm', 0, 0, 0, 0, $ C3, $ 8F, $ B7, $ A0, $ CF, $ 38, $ F7, $ 3B, $ 11, $ 59) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This could be seen when starting the virtual machine under the debugger by looking at the data located at the address pointed to by the variable " arg_C. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The BF interpreter requires a buffer of 300,000 bytes (according to the conditions described in the wiki), but in fact this version of the code uses only 221 bytes out of 300,000. We </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actually write the code.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need 4 buffers, for picode, for the VM workspace, input and output buffers.</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PicodeBuffSize = <span class="hljs-number"><span class="hljs-number">15778</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-comment"><span class="hljs-comment">//    PicodeBuff: array [0..PicodeBuffSize - 1] of Byte; PicodeIndex: Integer; //    VM WorkBuff: array [0..220] of Byte; WorkBuffIndex: Integer; //   OutputBuff: array [0..39] of AnsiChar; OutputBuffIndex: Integer; //       LoginAndPwd: array [0..29] of AnsiChar; LoginAndPwdIndex: Integer;</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the start, it is necessary to load the picode and correctly initialize the buffer with the login and serial number:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitVM</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M: TMemoryStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> M := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M.LoadFromFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\vm.brainfuck'</span></span>); M.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>(PicodeBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], PicodeBuffSize); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> M.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLoginAndPwd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Login, Password: AnsiString)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; A, B: Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   Move(Login[1], LoginAndPwd[0], Length(Login)); Move(Password[1], LoginAndPwd[10], Min(Length(Password), 20)); //      for I := 0 to 9 do begin A := Byte(LoginAndPwd[10 + I * 2]); B := Byte(LoginAndPwd[11 + I * 2]); if A &gt; $39 then Dec(A, $37) else Dec(A, $30); if B &gt; $39 then Dec(B, $37) else Dec(B, $30); A := a shl 4; A := A or B; LoginAndPwd[10 + I] := AnsiChar(A); end; end;</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that you need to write the code itself interpreter:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunVM</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Count: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PicodeBuff[PicodeIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>): Inc(WorkBuffIndex); Byte(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>): Dec(WorkBuffIndex); Byte(<span class="hljs-string"><span class="hljs-string">'+'</span></span>): Inc(WorkBuff[WorkBuffIndex]); Byte(<span class="hljs-string"><span class="hljs-string">'-'</span></span>): Dec(WorkBuff[WorkBuffIndex]); Byte(<span class="hljs-string"><span class="hljs-string">'.'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OutputBuff[OutputBuffIndex] := AnsiChar(WorkBuff[WorkBuffIndex]); Inc(OutputBuffIndex); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Byte(<span class="hljs-string"><span class="hljs-string">','</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> WorkBuff[WorkBuffIndex] := Byte(LoginAndPwd[LoginAndPwdIndex]); Inc(LoginAndPwdIndex); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Byte(<span class="hljs-string"><span class="hljs-string">'['</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WorkBuff[WorkBuffIndex] &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(PicodeIndex); <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Count := <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := PicodeIndex + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> PicodeBuffSize - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[I] = Byte(<span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(Count); <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[I] = Byte(<span class="hljs-string"><span class="hljs-string">']'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Dec(Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PicodeIndex := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Byte(<span class="hljs-string"><span class="hljs-string">']'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WorkBuff[WorkBuffIndex] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(PicodeIndex); <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Count := <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := PicodeIndex - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[I] = Byte(<span class="hljs-string"><span class="hljs-string">']'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(Count); <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[I] = Byte(<span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Dec(Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PicodeIndex := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Inc(PicodeIndex); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> PicodeIndex = PicodeBuffSize; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It remains only to run it all: </font></font><br><br><pre> <code class="delphi hljs">InitVM; InitLoginAndPwd(<span class="hljs-string"><span class="hljs-string">'Ms-Rem'</span></span>, <span class="hljs-string"><span class="hljs-string">'C38FB7A0CF38F73B1159'</span></span>); RunVM; Writeln(PAnsiChar(@OutputBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>])); Readln;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run and look at the result: </font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/680/b3b/ff6/680b3bff66eb42e48902c33547309cdb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, it seems everything is done correctly and works as it should. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(The source code of the interpreter </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive with examples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> '. \ Tools \ bf_execute \') </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus - the second envelope is removed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now what do we do with all this? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is impossible to analyze the picode head-on - there are no tools, the only thing that can be peeped are the numbers of the cells in which the login and password are entered and from which the result is derived. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We put BP on reading and writing procedures and see what </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">happens </font><font style="vertical-align: inherit;">with us ... </font><font style="vertical-align: inherit;">Nothing good, while the login and serial numbers are read, each byte is always read in cell number six of the working buffer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same happens with data output from the VM, the next character is also taken from cell number six.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The only thing that can somehow clarify the picture for us is a dump of the working buffer at the moment of data output, look at it: </font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/d3e/5a8/434/d3e5a8434fe74f859261019d0815829a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here at least it is clear that in the VM working buffer there is a login and password, as well as just below it two already prepared lines with ‚Äúgood message‚Äù and ‚Äúbad‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the sixth cell of the working buffer (the second from the right above), the prepared ‚ÄúC‚Äù character is already sitting from the displayed message ‚ÄúCongratulations !!! </font><font style="vertical-align: inherit;">It is a valid serial! ‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is such an ambush.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. We write Brainfuck decompiler </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is a decompiler? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it is a utility that converts a set of machine codes for the processor into a set of assembly instructions that the programmer understands. For each processor it will be its own assembler (32/64 / ARM, etc.). Well, the virtual machine (as mentioned earlier) has the same processor with its own set of instructions, expressed in the form of a picode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The challenge now is to write a picode decompiler into a 32-bit assembler so that we can work somehow with the result, since we already have a tool for analysis, this is a debugger. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the task is essentially simple, you do not need to take into account the prefixes, parse ModRM / SIB - just eight instructions, but first you need to figure out how it will look.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disassembling into the forehead will not be a good idea, you need to collapse the blocks of repeating instructions of the pyode BF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we have a brainfuck script of the following type: "&gt;&gt;&gt; +++ &lt;&lt; ----" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can go to the fourth cell, increase its value by three, go to the second and decrease its value by four. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you disassemble into the forehead, you get something unintelligible:</font></font><br><br><pre> <code class="delphi hljs">inc eax inc eax inc eax inc byte ptr [eax] inc byte ptr [eax] inc byte ptr [eax] dec eax dec eax dec byte ptr [eax] dec byte ptr [eax] dec byte ptr [eax] dec byte ptr [eax]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is much easier to minimize duplicate sets of instructions: </font></font><br><br><pre> <code class="delphi hljs">add eax, <span class="hljs-number"><span class="hljs-number">3</span></span> add byte ptr [eax], <span class="hljs-number"><span class="hljs-number">3</span></span> sub eax, <span class="hljs-number"><span class="hljs-number">2</span></span> sub byte ptr [eax], <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input and output are assembled quite simply. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We only need to know where to read and where to display. Moreover, it is necessary to take into account that each time when reading or outputting data, it is necessary to shift the position in order not to read what has already been read or not to overwrite what has already been written. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is only a variant with brackets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The brackets in BF perform an analog of the while loop, i.e. until the cell is zero, the loop body is executed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The opening bracket "[" is responsible for entering the loop body, for the transition to the next iteration, closing "]".</font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roughly in the assembler, we need to provide two conditional transitions, one at the entrance to the cycle, one at the transition to the next iteration. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the heap, at least one more thing is needed, this is the address where you need to go if the condition for entering the loop failed, or if the condition for going to the next iteration of the loop was not met. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to figure out how to disassemble the cycles, taking into account the three jumps described above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, there is such a picode:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dc/629/de9/0dc629de9911a57ef59d562876794c9e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> More convenient for disassembling (at least for me) will be the removal of the loop body beyond the main code, like this: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/958/ac3/7c1958ac3d517f237b1fe742f604a408.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we approach this way, then from the disassembler you only need to know the beginning and end of each procedure and in a cycle to decompile the body of each one, inserting jumps into the internal cycles in the right places. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: True, right now I am looking at this picture and I understand that it probably shouldn't have been tolerated, because an extra jump has appeared, but ... laziness to rewrite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, okay, now about the working buffer and input / output buffers: the ESI register will be used as a pointer to the working buffer, it will also be the cursor, i.e. on the operations "&gt;" or "&lt;" this particular register will increase or decrease. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pointer to the buffer with the login and serial number will store the EBX register, and the output buffer will be responsible for the EDI register. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We write the code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The decompiler will need a buffer with a picode and a small list in which the beginning and end of each While loop will be stored. </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> PicodeBuffSize: Integer; PicodeBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TWhileSubProc = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> StartAddr, EndAddr: Integer; SubProcEndLabel, SubProcStartLabel: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TWhileSubProcList = TList&lt;TWhileSubProc&gt;;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, we need several utilitarian procedures. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first builds the list itself, and the second and third, returns a list item based on the fields StartAddr and EndAddr.</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWhileSubProcList</span></span></span><span class="hljs-function">:</span></span> TWhileSubProcList; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, A, Z: Integer; Item: TWhileSubProc; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TWhileSubProcList.Create; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> PicodeBuffSize - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[I] = Byte(<span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Item.StartAddr := I; Z := <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A := I + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> PicodeBuffSize - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[A] = Byte(<span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(Z); <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PicodeBuff[A] = Byte(<span class="hljs-string"><span class="hljs-string">']'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Dec(Z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Z = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Item.EndAddr := A; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result.Add(Item); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexAtStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List: TWhileSubProcList; Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> List.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> List[I].StartAddr = Value <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(I); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexAtEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List: TWhileSubProcList; Value: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> List.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> List[I].EndAddr = Value <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>(I); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the main procedure is a decompiler of the specified While block:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeSubRoutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List: TWhileSubProcList; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharSimbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: Integer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value &lt; <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">' // #'</span></span> + IntToHex(Abs(Value), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-string"><span class="hljs-string">' // char "'</span></span> + AnsiChar(Value) + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LabelPfx = <span class="hljs-string"><span class="hljs-string">'@vm_code_'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Count, I: Integer; SubRoutineName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; Item: TWhileSubProc; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   while ,       PicodeIndex := List[Index].StartAddr; SubRoutineName := LabelPfx + IntToHex(PicodeIndex, 4); MakeAsmCode(SubRoutineName + ':'); Inc(PicodeIndex); end else //          SubRoutineName := '@root'; repeat case PicodeBuff[PicodeIndex] of //      Byte('&gt;'), Byte('&lt;'): begin Count := 0; while PicodeBuff[PicodeIndex] in [Byte('&gt;'), Byte('&lt;')] do begin if PicodeBuff[PicodeIndex] = Byte('&gt;') then Inc(Count) else Dec(Count); Inc(PicodeIndex); end; if Count = 0 then Continue; if Count &lt; 0 then begin if Count = -1 then MakeAsmCode(' dec esi') else MakeAsmCode(' sub esi, ' + IntToStr(Abs(Count))); end; if Count &gt; 0 then begin if Count = 1 then MakeAsmCode(' inc esi') else MakeAsmCode(' add esi, ' + IntToStr(Count)); end; Continue; end; //      Byte('+'), Byte('-'): begin Count := 0; while PicodeBuff[PicodeIndex] in [Byte('+'), Byte('-')] do begin if PicodeBuff[PicodeIndex] = Byte('+') then Inc(Count) else Dec(Count); Inc(PicodeIndex); end; if Count = 0 then Continue; if Count &lt; 0 then begin if Count = -1 then MakeAsmCode(' dec byte ptr [esi]') else MakeAsmCode(' sub byte ptr [esi], ' + IntToStr(Abs(Count)) + GetCharSimbol(Count)); end; if Count &gt; 0 then begin if Count = 1 then MakeAsmCode(' inc byte ptr [esi]') else MakeAsmCode(' add byte ptr [esi], ' + IntToStr(Count) + GetCharSimbol(Count)); end; Continue; end; //    Byte('.'): begin MakeAsmCode(' mov al, byte ptr [esi]'); MakeAsmCode(' mov byte ptr [edi], al'); MakeAsmCode(' inc edi'); end; //      Byte(','): begin MakeAsmCode(' mov al, byte ptr [ebx]'); MakeAsmCode(' inc ebx'); MakeAsmCode(' mov byte ptr [esi], al'); end; //    While Byte('['): begin I := IndexAtStart(List, PicodeIndex); Item := List[I]; MakeAsmCode(' cmp byte ptr [esi], 0 // ['); Item.SubProcEndLabel := SubRoutineName + '_' + IntToHex(PicodeIndex + 1, 4); Item.SubProcStartLabel := LabelPfx + IntToHex(PicodeIndex, 4); //   ,      //             MakeAsmCode(' jne ' + Item.SubProcStartLabel); MakeAsmCode(Item.SubProcEndLabel + ':'); PicodeIndex := Item.EndAddr + 1; List[I] := Item; Continue; end; //     Byte(']'): begin I := IndexAtEnd(List, PicodeIndex); MakeAsmCode(' cmp byte ptr [esi], 0 // ]'); //   ,      MakeAsmCode(' jne ' + List[I].SubProcStartLabel); //           MakeAsmCode(' jmp ' + List[I].SubProcEndLabel); //   -    Exit; end; end; Inc(PicodeIndex); until PicodeIndex = PicodeBuffSize; //   ,   MakeAsmCode(' popa'); MakeAsmCode(' ret'); end;</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It remains to cycle through to decompile each While block: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeVM</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; List: TWhileSubProcList; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MakeAsmCode(<span class="hljs-string"><span class="hljs-string">'procedure RunBrainfuck(pWorkBuff, pInBuf, pOutBuf: Pointer);'</span></span>); MakeAsmCode(<span class="hljs-string"><span class="hljs-string">'asm'</span></span>); MakeAsmCode(<span class="hljs-string"><span class="hljs-string">' pusha'</span></span>); MakeAsmCode(<span class="hljs-string"><span class="hljs-string">' mov esi, pWorkBuff'</span></span>); MakeAsmCode(<span class="hljs-string"><span class="hljs-string">' mov ebx, pInBuf'</span></span>); MakeAsmCode(<span class="hljs-string"><span class="hljs-string">' mov edi, pOutBuf'</span></span>); List := GetWhileSubProcList; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> DecodeSubRoutine(List, -<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> List.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> DecodeSubRoutine(List, I); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> List.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; MakeAsmCode(<span class="hljs-string"><span class="hljs-string">'end;'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And write the startup code for all of this: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPicode</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M: TMemoryStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ParamCount = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FileExists(ParamStr(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'Brainfuck file not found.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; M := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> M.LoadFromFile(ParamStr(<span class="hljs-number"><span class="hljs-number">1</span></span>)); PicodeBuffSize := M.Size; SetLength(PicodeBuff, PicodeBuffSize); M.ReadBuffer(PicodeBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], PicodeBuffSize); Result := True; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> M.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> InitPicode <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AsmCode := TFileStream.Create(ChangeFileExt(ParamStr(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">'.inc'</span></span>), fmCreate); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> DecodeVM; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> AsmCode.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Writeln(<span class="hljs-string"><span class="hljs-string">'Done.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(The source code of the decompiler </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive with examples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> '. \ Tools \ bf_decompiler \') </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you need to check its work on anything. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take for example Hello World from a wiki with this content:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++++++++++ [&gt; +++++++&gt; +++++++++&gt; +++&gt; + &lt;&lt;&lt;&lt; -]&gt; ++ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.&gt; +. + ++++++. +++.&gt; ++. &lt;&lt; +++++++++++++++.&gt;. +++. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">------.--------.&gt; +.&gt;.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And let's see what it is being decompiled into: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunBrainfuck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pWorkBuff, pInBuf, pOutBuf: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> pusha mov esi, pWorkBuff mov ebx, pInBuf mov edi, pOutBuf add byte ptr [esi], <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// #0A cmp byte ptr [esi], 0 // [ jne @vm_code_000B @root_000C: inc esi add byte ptr [esi], 2 // #02 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi inc esi inc byte ptr [esi] mov al, byte ptr [esi] mov byte ptr [edi], al inc edi add byte ptr [esi], 7 // #07 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi mov al, byte ptr [esi] mov byte ptr [edi], al inc edi add byte ptr [esi], 3 // #03 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi inc esi add byte ptr [esi], 2 // #02 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi sub esi, 2 add byte ptr [esi], 15 // #0F mov al, byte ptr [esi] mov byte ptr [edi], al inc edi inc esi mov al, byte ptr [esi] mov byte ptr [edi], al inc edi add byte ptr [esi], 3 // #03 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi sub byte ptr [esi], 6 // #06 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi sub byte ptr [esi], 8 // #08 mov al, byte ptr [esi] mov byte ptr [edi], al inc edi inc esi inc byte ptr [esi] mov al, byte ptr [esi] mov byte ptr [edi], al inc edi inc esi mov al, byte ptr [esi] mov byte ptr [edi], al inc edi popa ret @vm_code_000B: inc esi add byte ptr [esi], 7 // #07 inc esi add byte ptr [esi], 10 // #0A inc esi add byte ptr [esi], 3 // #03 inc esi inc byte ptr [esi] sub esi, 4 dec byte ptr [esi] cmp byte ptr [esi], 0 // ] jne @vm_code_000B jmp @root_000C end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looks like. </font><font style="vertical-align: inherit;">I agree, you can sub-optimize, but not the task. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check how it will work and write a test:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> hello_world_test; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$I ..\..\data\helloworld.inc}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WorkBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">300000</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; OutBuf: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RunBrainfuck(@WorkBuff[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, @OutBuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Writeln(PAnsiChar(@OutBuf[<span class="hljs-number"><span class="hljs-number">0</span></span>])); Readln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> See the result: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72d/76d/57c/72d76d57c015a9e1e5d5aee6e27f105c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, not bad. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out what was intended, now we decompile the body of the VM itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output was 8153 lines of the purest assembler :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(the result of VM decompilation </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive with examples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> '. \ Data \ vm.inc')</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having run through his eyes, you can immediately notice the initialization procedure for the 'good' and 'bad' lines inside vm_code_001B_001D:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs">@vm_code_001B_001D: add esi, <span class="hljs-number"><span class="hljs-number">105</span></span> add byte ptr [esi], <span class="hljs-number"><span class="hljs-number">67</span></span> <span class="hljs-comment"><span class="hljs-comment">// char "C" add esi, 2 add byte ptr [esi], 111 // char "o" add esi, 2 add byte ptr [esi], 110 // char "n" add esi, 2 add byte ptr [esi], 103 // char "g" add esi, 2 add byte ptr [esi], 114 // char "r" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 116 // char "t" add esi, 2 add byte ptr [esi], 117 // char "u" add esi, 2 add byte ptr [esi], 108 // char "l" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 116 // char "t" add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 111 // char "o" add esi, 2 add byte ptr [esi], 110 // char "n" add esi, 2 add byte ptr [esi], 115 // char "s" add esi, 2 add byte ptr [esi], 33 // char "!" add esi, 2 add byte ptr [esi], 33 // char "!" add esi, 2 add byte ptr [esi], 33 // char "!" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 73 // char "I" add esi, 2 add byte ptr [esi], 116 // char "t" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 115 // char "s" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 118 // char "v" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 108 // char "l" add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 100 // char "d" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 115 // char "s" add esi, 2 add byte ptr [esi], 101 // char "e" add esi, 2 add byte ptr [esi], 114 // char "r" add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 108 // char "l" add esi, 2 add byte ptr [esi], 33 // char "!" add esi, 4 add byte ptr [esi], 83 // char "S" add esi, 2 add byte ptr [esi], 101 // char "e" add esi, 2 add byte ptr [esi], 114 // char "r" add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 108 // char "l" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 110 // char "n" add esi, 2 add byte ptr [esi], 118 // char "v" add esi, 2 add byte ptr [esi], 97 // char "a" add esi, 2 add byte ptr [esi], 108 // char "l" add esi, 2 add byte ptr [esi], 105 // char "i" add esi, 2 add byte ptr [esi], 100 // char "d" add esi, 2 add byte ptr [esi], 32 // char " " add esi, 2 add byte ptr [esi], 58 // char ":" add esi, 2 add byte ptr [esi], 40 // char "("</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But ... all the same, more than 8 thousand lines, with a swoop they can not be analyzed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Need to write additional tools.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for this you need to write a small demo application that executes decompiled VM code, with which we will work throughout the rest of the article.</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> decompiled_vm_test; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, Math; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-comment"><span class="hljs-comment">//    VM WorkBuff: array [0..220] of Byte; WorkBuffIndex: Integer; //   OutputBuff: array [0..39] of AnsiChar; OutputBuffIndex: Integer; //       LoginAndPwd: array [0..29] of AnsiChar; LoginAndPwdIndex: Integer; procedure InitLoginAndPwd(const Login, Password: AnsiString); var I: Integer; A, B: Byte; begin //   Move(Login[1], LoginAndPwd[0], Length(Login)); Move(Password[1], LoginAndPwd[10], Min(Length(Password), 20)); //      for I := 0 to 9 do begin A := Byte(LoginAndPwd[10 + I * 2]); B := Byte(LoginAndPwd[11 + I * 2]); if A &gt; $39 then Dec(A, $37) else Dec(A, $30); if B &gt; $39 then Dec(B, $37) else Dec(B, $30); A := a shl 4; A := A or B; LoginAndPwd[10 + I] := AnsiChar(A); end; end; {$I ..\..\data\vm.inc} begin InitLoginAndPwd('Ms-Rem', 'C38FB7A0CF38F73B1159'); RunBrainfuck(@WorkBuff[0], @LoginAndPwd[0], @OutputBuff[0]); Writeln(PAnsiChar(@OutputBuff[0])); Readln; end.</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the demo application settings, you need to enable the generation of the MAP file (in the Detailed mode), it will be useful to us in the next chapter. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Writing a tracer </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to understand what exactly is happening in the decompiled code, it is necessary to build the execution trace. And there will be enough information about which blocks are executed and where the transition takes place from them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the route is to build a directional graph, analyzing which logical branches in vector blocks can be stopped (roughly, in the form of a flowchart). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will require a debugger: </font></font><a href="http://habrahabr.ru/post/178159/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://habrahabr.ru/post/178159/</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the process of building the route, the debugger will go step by step according to the code of the recipient, interrupting at the addresses that we can lead to the line number in the source code we previously generated. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To bring the address to the line number in the asm listing, you will need a small module that will parse the MAP file and return this information.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will also need another module, which, by the line number in the asm listing, will return the name of the sub-procedure on which the stop occurred. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the last two modules will not be given - they are very simple, in any case, the code can be seen </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive with examples for the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the following way: '. \ Tools \ tracer \'. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You also need a class that will store the data about the shot track. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roughly his whole task is to keep an array of records like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TTraceItem = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> SubName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; InList, OutList: TStringList; CustomData: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and provide methods for working with it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also very simple, you can see the code </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the way: '. \ Tools \ common \ trace_data.pas' </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The execution route will be shot in 4 passes in 4 different modes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Full track program execution. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Partial trace, from one iteration of reading the buffer with login and serial number. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Partial trace from one iteration of output. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Detection of procedures in which cells with login and password are recorded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little later, the treser will have to be added, adding the fifth mode to it to completely remove the track, but removed from the de-example, in which the serial number will be dropped into a sequence of zeros (in the source code this mode will be called ttWrongSN).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But more about that later, but now ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the tracer is quite banal:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. turn off the OnCreateProcess debugger and initialize it with the installation of the corresponding BP:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTracer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreateProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TCreateProcessDebugInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'process start'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FTraceType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ttFull: begin FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.StartLine)), hsByte, hmExecute, 0, 'vm_start'); FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.EndLine)), hsByte, hmExecute, 1, 'vm_end'); end; ttIn: //      FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.ReadPwdLine)), hsByte, hmExecute, 0, 'read_pwd_start'); ttOut: //     FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.OutputBufLine)), hsByte, hmExecute, 0, 'out_data_start'); ttCheckLoginBuff: begin //            FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.StartLine)), hsByte, hmExecute, 0, 'LoginAndSN_MBP_Present'); FDebuger.SetHardwareBreakpoint(ThreadIndex, Pointer(FMap.AddrAtLine(FSrc.EndLine)), hsByte, hmExecute, 1, 'vm_end'); end; end; end;</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. After that, in the handler of the hardlock, we set the operation modes:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTracer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHardwareBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: THWBPIndex; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CurrentName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; ThreadData: TThreadData; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(FTotalStepCount); ThreadData := FDebuger.GetThreadData(ThreadIndex); Writeln(ThreadData.Breakpoint.Description[BreakPointIndex]); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FTraceType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ttFull: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> BreakPointIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FDebuger.ResumeAction := raTraceInto; ReleaseBreakpoint := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReleaseBreakpoint := True; CurrentName := FSrc.GetProcedureNameAtLine(FMap.LineAtAddr(DWORD(ExceptionRecord.ExceptionAddress))); FTrace.AddTace(FPreviousName, CurrentName); FTrace.SaveToFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\full.trace'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Trace done.'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Total instructions traced: '</span></span>, FTotalStepCount); Writeln(<span class="hljs-string"><span class="hljs-string">'Traced subroutine added: '</span></span>, FTrace.Count); Writeln(<span class="hljs-string"><span class="hljs-string">'Time elapsed: '</span></span>, GetTickCount - FStart, <span class="hljs-string"><span class="hljs-string">'ms'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ttIn, ttOut: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FProcList.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReleaseBreakpoint := True; CurrentName := FSrc.GetProcedureNameAtLine(FMap.LineAtAddr(DWORD(ExceptionRecord.ExceptionAddress))); FTrace.AddTace(FPreviousName, CurrentName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FTraceType = ttIn <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FProcList.SaveToFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\in.proclist'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FProcList.SaveToFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\out.proclist'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Trace done.'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Total instructions traced: '</span></span>, FTotalStepCount); Writeln(<span class="hljs-string"><span class="hljs-string">'Traced subroutine added: '</span></span>, FProcList.Count); Writeln(<span class="hljs-string"><span class="hljs-string">'Time elapsed: '</span></span>, GetTickCount - FStart, <span class="hljs-string"><span class="hljs-string">'ms'</span></span>); FDebuger.ResumeAction := raRun; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FDebuger.ResumeAction := raTraceInto; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ttCheckLoginBuff: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReleaseBreakpoint := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> BreakPointIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FWorkBuffAddr := PByte(FDebuger.GetContext(<span class="hljs-number"><span class="hljs-number">0</span></span>).Eax); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> FDebuger.SetMemoryBreakpoint(FWorkBuffAddr + <span class="hljs-number"><span class="hljs-number">28</span></span> + (I * <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, True, <span class="hljs-string"><span class="hljs-string">'Login'</span></span> + IntToStr(I)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> FDebuger.SetMemoryBreakpoint(FWorkBuffAddr + <span class="hljs-number"><span class="hljs-number">48</span></span> + (I * <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, True, <span class="hljs-string"><span class="hljs-string">'SN'</span></span> + IntToStr(I)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FProcList.SaveToFile(<span class="hljs-string"><span class="hljs-string">'..\..\data\change_buff.proclist'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Trace done.'</span></span>); Writeln(<span class="hljs-string"><span class="hljs-string">'Total instructions traced: '</span></span>, FTotalStepCount); Writeln(<span class="hljs-string"><span class="hljs-string">'Traced subroutine added: '</span></span>, FProcList.Count); Writeln(<span class="hljs-string"><span class="hljs-string">'Time elapsed: '</span></span>, GetTickCount - FStart, <span class="hljs-string"><span class="hljs-string">'ms'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In short, in the full dump mode (ttFull) the second HBP will signify the completion of the trace process, the ‚ÄúttIn, ttOut‚Äù modes will stop at the second HBP trigger (one I / O pass), and ttCheckLoginBuff will perform a trace using the MBP until the entire VM cycle will be executed. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Trace results will be collected in these two handlers:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTracer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSingleStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CurrentName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(FTotalStepCount); CurrentName := FSrc.GetProcedureNameAtLine(FMap.LineAtAddr(DWORD(ExceptionRecord.ExceptionAddress))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FTraceType = ttFull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FPreviousName = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FPreviousName := CurrentName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FPreviousName &lt;&gt; CurrentName <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTrace.AddTace(FPreviousName, CurrentName); FPreviousName := CurrentName; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FProcList.Add(CurrentName); FDebuger.ResumeAction := raTraceInto; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTracer</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMemoryBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(FTotalStepCount); FProcList.Add( FSrc.GetProcedureNameAtLine(FMap.LineAtAddr(DWORD(ExceptionRecord.ExceptionAddress)))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first one follows the branching of the transitions, and the second simply collects the names of the procedures from which the access to the buffer occurred, in which the login and the serial number are located. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of the work of the tracer, we will have 4 files on the basis of which we can fairly easily analyze all the work of the VM, but ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for this, you need to somehow display the data in the form in which you can work with them ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Display the execution route in the form of a graph. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDA Pro is an excellent tool, the graphs issued by it are very helpful in the process of analyzing the source code, but ... but it is not universal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, with the graph of the decompiled VM code built by IDA, it is not very convenient to work in this case. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is why I went to personally removing the track (described in the last chapter) and writing a tool to visualize it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the tool is as follows: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. turn the software execution trace into the graph being visualized </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. display the logical execution blocks in the column </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. as a result, show block addresses interesting for code analysis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The very first stage is the conversion of data from the tracer into a directed graph.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is built quite simply - we take the current block and recursively build outgoing transitions from it. The main thing to forget about while cycles, where the transition at the end of the procedure to its beginning, will be directed to the already added element. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, when constructing a graph, it is necessary for each element to add a custom property in which the graph node will be stored, to which a link should be placed at the first call. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyzing the BF code, the following conclusions can be made: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. In each of the while cycles there can be only 2 inputs (from the external code block and the transition from the end of the cycle). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. The end of each while cycle has only 2 exits (if the cycle is completed go to a higher level by code, otherwise return to the beginning of the cycle).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. From the body of the block while there may be a multiple number of outputs, provided there are ifthen blocks in its body (but this is not our case). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code convolution means the following: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. If the procedure has one input and one output (according to the trace results), then it is added to the current convolution block. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. The beginning of each convolution block will be any procedure that has two inputs (while loop). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. The end of the convolution block will be a transition to an already added code (end of while) or any other block of code that, according to the results of the route, has two outputs (which implies the same end of the cycle, based on the previous item 3).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fairly simple recursive procedure ('. \ Tools \ trace_viewer \ trace_graph.pas') is responsible for all these stages:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTraceGraph</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer; AParent: TExecutionBlock)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Block: TExecutionBlock; Item: TTraceItem; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    -   //    -         //   -           //    ,        Item := FTrace[Index]; if Item.CustomData &lt;&gt; nil then begin AddVector(AParent, Item.CustomData); Exit; end; Block := TExecutionBlock(AddNode(NodesCount)); if AParent = nil then Block.Level := 0 else begin AddVector(AParent, Block); Block.Level := AParent.Level + 1; FMaxLevel := Max(FMaxLevel, Block.Level); end; Block.ProcList.Add(Item.SubName); FTrace.SetCustomData(Index, Block); //     -     if Item.OutList.Count = 0 then Exit; //       -     if (Item.OutList.Count = 2) then begin LoadItem(FTrace.GetItemIndexByName(Item.OutList[0]), Block); LoadItem(FTrace.GetItemIndexByName(Item.OutList[1]), Block); Exit; end; //      Item := FTrace.ItemByName(Item.OutList[0]); while Item.InList.Count = 1 do begin Block.ProcList.Add(Item.SubName); FTrace.SetCustomData(FTrace.GetItemIndexByName(Item.SubName), Block); case Item.OutList.Count of 0: Exit; 1: Item := FTrace.ItemByName(Item.OutList[0]); 2: begin LoadItem(FTrace.GetItemIndexByName(Item.OutList[0]), Block); LoadItem(FTrace.GetItemIndexByName(Item.OutList[1]), Block); Exit; end; end; end; if Item.InList.Count = 2 then LoadItem(FTrace.GetItemIndexByName(Item.SubName), Block); end;</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of processing the trace of the decompiled code (in which there are no complicated cases in the form of multiple outputs from while) will be the following picture:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/733/d20/dc6733d202f06e9061d0465629e003c8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It displays the program execution trace, with minimized execution blocks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not pay attention to the fact that everything is so beautifully arranged in vertical columns - I did not write an algorithm for this arrangement and everything was trivially scattered with pens (for it is much faster than writing the same visualization engine as with IDA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not give the source code of this utility , you can see it </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the archive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". \ tools \ trace_viewer \". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its main task is to give a starting point from which you can push off when analyzing the VM code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here are two pictures that show part of the logic of the work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is what happens when reading the login and serial number:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/67d/e90/02c67de901831839431adcdde1e712fd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But these procedures are performed when displaying the result: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ca/ea8/051/4caea8051360a2dec15c2cbf5a83a7da.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the execution of procedures in the center of the scheme, they are a hardware and do not participate in the logic of the algorithm hidden in the VM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately make a reservation - this conclusion was made in the process of researching the code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, having received such two pictures on my hands, I was a little puzzled and suggested that there could be another mini-VM hiding inside (a green vertical block from the bottom left) that spreads logic based on my own instructions, but ... the assumption turned out to be wrong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so, judging by the pictures we have on hand: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. The upper left block of the diagram is the reading of data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Lower right - output result. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. The central branch is a kind of matapparat (as a result, it‚Äôs not even necessary to analyze it).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All that is not highlighted in green and there is a third envelope (hidden under VM logic). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Those who will study the source code of this viewer apologize in advance - the tool code is very raw and was written literally on the knee in two nights, so the utility does not have much functionality. It only knows how to display the graph itself, provides a mechanism for modifying it (read, you can move blocks as it will be more convenient). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZOOM mode is not added, for this there is a separate button that generates a general preview (from which the screenshots were taken). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the role of the graph analysis tool is not bad. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the archive with the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there is an already placed graph ('. \ Data \ current.graph') which was obtained from the route taken in the previous chapter ('. \ Data \ full.trace').</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However ... to our sheep. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tool for analyzing the decompiled VM code is ready, let's proceed directly to its analysis ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Analysis and detection of the variable reading algorithm. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having started the VM analysis, I already had some idea of ‚Äã‚Äãwhat I would have to work with. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relying on the memory card with which the VM is running (shown in Chapter 7), I knew the offsets for which the ‚Äúcorrect‚Äù and ‚Äúincorrect‚Äù lines with the results are located, as well as the offset for which the buffer with the login and serial number is located. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knowing how the BF interpreter works, I even figured out an approximate algorithm for working with data, taking into account the fact that certain operations should be performed on login and SN. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if you want to add two Z and X fields, then there is no addition operation in Brainfuck, for this you will need to write a while loop in which the value of cell X will be iteratively decremented and the value of cell Y will be incremented.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, cell Y will contain the sum of both cells, and cell X will be reset. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But at data output, as shown above, one can observe that the buffer with the login and serial number is where it should be and none of its fields are changed. So in the VM, some other approach is used to read the data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A strange nuance to which I immediately noticed that the login, the serial number, the ‚Äúcorrect‚Äù and ‚Äúnot correct‚Äù lines in the memory card are not as they are, and each byte is separated from the next by zero. It feels like we are working with unicode, although in reality the work goes with ANSI strings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These two points were not clear to me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it is still necessary to start with something, and I decided to start analyzing the algorithm from its end, assuming that the decision on outputting the result is made here with such a block of procedures (where the result is displayed):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/877/835/746/877835746610118c5626e16df765b834.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the graph shows this block as one function with one entry point and one exit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(By the way, the assumption that a decision is made in this block, in the end, turned out to be wrong). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For debugging, I used the CPU-View mode directly by Delphi itself (this turned out to be sufficient for the eyes). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The debugged application was ‚Äúdecompiled_vm_text.exe‚Äù from which the execution trail was shot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three variables were added to the Watch List as auxiliary prompts: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. The current value of the working buffer cursor (ESI register), which was calculated by the difference from the start address of the working buffer (pWorkBuff) and the current register value. (esi- $ 4E5008) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. The value of the current pWorkBuff cell (pbyte (esi) ^) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. It is the same in HEX mode only.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. The dump window was tuned to the beginning of the VM working buffer ($ 4E5008). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: you have the address of the working buffer may be different, so the number 4E5008 you must calculate in advance at the start of debugging, by looking at this value in the variable pWorkBuff. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the configured debugger stopped at the beginning of the "@ vm_code_39D7" procedure looked like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/6e8/5ac/6606e85ac9bdec4cbd1d948a1e086d42.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually with this procedure and begin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you pay attention to the graph image, this is the very first procedure in the minimized execution block that calls itself (while loop). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the time of calling this procedure, the working buffer cursor is set to cell number 27 (in the picture with the memory card highlighted in red), which contains a certain number (40 or $ 28). This cell is located just before the buffer with the login and serial number (located on the offset 28, which stores the first character of the login - "M"). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember the number of this cell - it is one of the central elements of the VM logic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see the source code of the minimized block:</font></font><br><br><pre> <code class="delphi hljs">@vm_code_39D7: cmp byte ptr [esi], <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ‚Ññ27 ? jne @vm_code_39D8 //  ,    @vm_code_39D8: add esi, 2 //       2   cmp byte ptr [esi], 0 //   ? jne @vm_code_39D8 //  ,    @vm_code_39D7_39D9: //    ? inc byte ptr [esi] //     1 cmp byte ptr [esi], 0 jne @vm_code_39DD //      #27 @vm_code_39DD: sub esi, 2 //     ( 2 ), // ..     ,       #27 cmp byte ptr [esi], 0 jne @vm_code_39DD @vm_code_39D7_39DE: add esi, 2 //   #27 dec byte ptr [esi] //    cmp byte ptr [esi], 0 //      ,     jne @vm_code_39D7 jmp @vm_code_397A_39D8 //  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here I built the execution blocks in the order of their execution (not in the form in which they go in the source code) in order to make it easier to analyze the logic from the work. </font></font><br><br>  So what is going on here? <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm initializes zeros (which separate each element of the login / serial number, as well as the "bad" and "good" lines) with units. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you stop at the finalization of the cycle and look at the result, you can see this picture:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/04d/3e3/6a504d3e3d68871ee0ddfd9892fca9e6.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cell 27 will be reset to zero, but as a result you can see that the buffer will be initialized to units ending just before the first VM output with the ‚Äúgood string‚Äù character, namely the ‚ÄúC‚Äù character. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice how interesting are the transitions to the beginning and end of the data being changed (the @ vm_code_39D8 and @ vm_code_39DD procedures). The detection of the end blocks is used to verify the current cell value with zero, the leftmost zero will indicate the position of cell 27 (with a shift), and the rightmost zero will indicate the cell that has not yet been initialized. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the essence of this block is reduced to the construction of an index (in the form of units) to a cell with which the next while cycle will start, starting with the @ vm_code_39EB procedure.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will begin its work from the cell to which the last unit of the previously built index points, namely from cell No. 108, where the ‚ÄúC‚Äù symbol (highlighted in blue) is located, which the VM should now output to the external buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before calling this procedure, VM managed to perform some preparatory actions, one of which was the initialization of cell No. 27 by a unit, thus. The leftmost cell to which the search algorithm of the left end of the index will go from now on will be cell No. 26.</font></font><br><br>  So: <br><br><pre> <code class="delphi hljs">@vm_code_39EB: dec esi <span class="hljs-comment"><span class="hljs-comment">//     ‚Ññ108,   cmp byte ptr [esi], 0 // ,      jne @vm_code_39ED @vm_code_39ED: sub esi, 2 //  ,  cmp byte ptr [esi], 0 //    (  ‚Ññ26) jne @vm_code_39ED jmp @vm_code_39EB_39EE @vm_code_39EB_39EE: inc esi //      ‚Ññ26 inc byte ptr [esi] //    ‚Ññ26 sub esi, 20 //    ‚Ññ6 inc byte ptr [esi] //    add esi, 21 //       cmp byte ptr [esi], 0 jne @vm_code_3A1D @vm_code_3A1D: add esi, 2 //      (   108) cmp byte ptr [esi], 0 jne @vm_code_3A1D jmp @vm_code_39EB_3A1E //   ,    @vm_code_39EB_3A1E: dec esi //    ‚Ññ108 dec byte ptr [esi] //    cmp byte ptr [esi], 0 //     ,     ... jne @vm_code_39EB jmp @vm_code_397A_39EC // </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The logic of the second cycle is as follows: it transfers the value of cell No. 108 to cells number 26 and number 6 (note that this is the sixth cell from which the character is taken, which I indicated in the seventh chapter). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in fact, the logic of working with data already begins to emerge (when reading a value, a value is duplicated at two addresses). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The memory card starts to look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/650/520/0a5650520a2eadbc9893941730840d9f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The green rectangles indicate the places with which the changes occurred, the red cell highlighted number 108 from which the value was taken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next while loop in the graph begins with the procedure "@ vm_code_3A2A". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He will begin his work from cell number 26, which stores a copy of the number previously placed in cell number 108. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code looks like this:</font></font><br><br><pre> <code class="delphi hljs">@vm_code_3A2A: inc esi <span class="hljs-comment"><span class="hljs-comment">//       cmp byte ptr [esi], 0 jne @vm_code_3A2C @vm_code_3A2C: add esi, 2 cmp byte ptr [esi], 0 //   ,    ‚Ññ108 jne @vm_code_3A2C jmp @vm_code_3A2A_3A2D @vm_code_3A2A_3A2D: dec esi //      ‚Ññ108 inc byte ptr [esi] //     dec esi //     cmp byte ptr [esi], 0 jne @vm_code_3A33 @vm_code_3A33: sub esi, 2 //    cmp byte ptr [esi], 0 jne @vm_code_3A33 jmp @vm_code_3A2A_3A34 //   ,    @vm_code_3A2A_3A34: inc esi //    ‚Ññ26 dec byte ptr [esi] //   cmp byte ptr [esi], 0 //      jne @vm_code_3A2A //   jmp @vm_code_397A_3A2B // </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task of this code is to move the value of the jar of cell No. 26 back to cell No. 108, thus restoring the original value of the cell with which the algorithm began its work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the memory card after the algorithm works:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/121/b9b/4ee121b9b8cb2630414c1d3775451da7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the final step in this slightly confusing logic of working with cells will be the final, located in the procedure "@ vm_code_3A41". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is quite simple:</font></font><br><br><pre> <code class="delphi hljs">@vm_code_3A41: dec byte ptr [esi] sub esi, <span class="hljs-number"><span class="hljs-number">2</span></span> cmp byte ptr [esi], <span class="hljs-number"><span class="hljs-number">0</span></span> jne @vm_code_3A41</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its whole task is to start work from the most recent cell equal to one (by means of which the index is built) and remove all units of the index. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of her work is such a map:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a0/031/998/3a00319988edfa68520fed937a914536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The green fields are the index fields that were removed by the last procedure, and the red one is the result of the work of all four rolled blocks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confused? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing strange, but if you look closely at the most recent picture, you can understand that all this fancy logic from the four stages essentially performs one simple operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this operation is the assignment of the value of cell ‚ÄúA‚Äù to cell ‚ÄúB‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the algorithm is quite flexible and thus allows you to read the value of any login / serial number symbol or ‚Äúgood / bad‚Äù lines; to do this, it is enough to initialize cell No. 27 with the symbol number and perform all four steps described above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A beautiful approach - you will not say anything, the logic of working with cells is fairly solidly smeared, although there is a small nuance.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having understood how the cell value is obtained and having the execution graph in hand, it will take an hour and a half to analyze all the logic of the work from this moment on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rest of the procedures from the top picture with the graph does not make sense to consider, there is some internal hardware necessary for the VM to work, there are frankly garbage pieces of code (for example, changing the value of two / three cells in places and returning everything to its original state in the cycle) .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Analysis of elements of logic into components. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it turned out that the cell value is obtained by performing three cycles, which can be clearly seen on the graph and the final block of finalization, which removes the array of indices immediately after the end of the third cycle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here in this picture I immediately selected them with red rectangles and repelled from this image throughout the entire VM logic parsing:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fca/2db/9b0/fca2db9b0d87e651adce10c63c190fa9.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The two blue rectangles also highlight the reading cycles of the cell value, but since they read the values ‚Äã‚Äãof the characters Login [0] and Login [1] (I learned this after analyzing all the cycles of the algorithm), then an index array of ones is not built in these two cases, the first cycle reads the value in cells 26 and 6, and in the second, the value from cell # 26 is returned. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The picture is not quite clearly visible (affects the zoom), to make it more clear, here is the second option, which shows the principle by which I circled the blocks with rectangles:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa6/404/8dd/fa64048dd848c464a3cef15dbc7a67c4.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To check my guess, I checked myself and displayed on the graph the blocks in which the login and serial number fields change (the button ‚ÄúShow access to the buffer with login and SN‚Äù). For this button, the viewer will load the list of such procedures, created earlier by the tracer in ttCheckLoginBuff mode and show just such a picture:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/435/bed/36d435bed8ef1dc1ae1049cca574cb91.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything was as it was supposed in the previous image, the block from the left above is only knocked out of logic (circled by a blue rectangle), this is a piece of code that reads the values ‚Äã‚Äãof the login and serial number from the external buffer, so it is not surprising that changes in these fields occur in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I concluded that apparently each of the vertical blocks is one of the stages of checking the serial number (the assumption also turned out to be true). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step was interesting to me, and where the decision on the correctness of the serial number is generally made, for this I reassembled the example ‚Äúdecompiled_vm_text.exe‚Äù in which I changed the value of the serial number to zero, and again took the track in ttWrongSN mode.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After all these steps, I looked at the differences of the route (the button ‚ÄúShow differences of the route with the wrong SN‚Äù) as a result saw the following: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/750/fff/3d0750fffe42d32972c5871b73743f2b.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You could say bingo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the very first operation (right vertical block), an exit occurred, and not all the procedures were completed (the block marked in red). </font><font style="vertical-align: inherit;">So it is in it that the decision is made on the results of the first operation on the buffer with the login and serial number. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More precisely, there will be several such blocks in the end, for each operation it‚Äôs different, but you don‚Äôt have to disassemble their operation logic, since </font><font style="vertical-align: inherit;">the meaning of all operations will be fairly transparent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step I put breakpoints in the debugger at the beginning of each vertical block (which I had previously marked with rectangles), in order to understand in what order the operations are performed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out this list:</font></font><br><br><ol><li> vm_code_17AB </li><li> vm_code_1A63 </li><li> vm_code_1E74 </li><li> vm_code_2333 </li><li> vm_code_28DA ‚Äî      </li><li> vm_code_2AF3 </li><li> vm_code_2D27 </li><li> vm_code_2F41 </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remaining, focusing on the graph, just go through all the selected places (skipping the already known elements of logic in which the login / SN symbol is taken) and analyze what operations are performed on these symbols. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not give ranges of procedures in which an index is created, a value is read, a value is returned and the index is removed. For simplicity, I will only show the name of the procedure of the first cycle (in which the construction of an index array of ones takes place). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us proceed to the analysis of logic: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. vm_code_17AB</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.1 vm_code_1815 - read the value of SN [0] in cell # 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2 vm_code_17AB_1880 add to cell # 6 the number 12 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3 vm_code_1903 - read the value of SN [4] in cell # 7</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the same number will be obtained in both cells (6, 7), thus we conclude that the first mathematical operation performs the following check: SN [4] = SN [0] + 12 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. vm_code_1A63</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.1 vm_code_1AD4 - read the value SN [0] in cell No. 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2 vm_code_1B58 this value is transferred to cell No. 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3 vm_code_1BC8 - read the value of SN [3] in cell No. 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4 vm_code_1C4C value of cell No. 6 is added to cell No. 7 (result in 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5 vm_code_1A63_1C5A - cell ‚Ññ7 increased by the number 84 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.6 vm_code_1D12 - read SN [2] to the cell ‚Ññ6 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, both cells (6, 7) is obtained one and the same numbers, thereby de amu conclusion that the second mathematical operation produces the following test: SN [2] = SN [0] + SN [3] + 84</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. vm_code_1E74</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1 vm_code_1EE8 - read the Login [0] value in cell # 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 vm_code_1F5B - transfer the value from 6 to 7 cell </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3 vm_code_1FDD - read the Login value [1] in cell # 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4 vm_code_204D - cell value # 6 is summed with cell No. 7 (result in 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5 vm_code_20CB - read the value of SN [4] in cell # 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.6 vm_code_214F - the value of cell # 6 is added to cell # 7 (result in 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.7 vm_code_21C3 - read the value of SN [1] in cell # 8 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as a result, in both cells (7, 8) one and the same number will be obtained, thus we conclude that the third mathematical operation performs the following check: SN [1] = Login [0] + Login [1] + SN [4] </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 . v m_code_2333</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 vm_code_239B - read the Login value [8] to cell # 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2 vm_code_2493 - read the Login value [4] to cell # 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 vm_code_2517 - cell No. 6 value is added to cell # 7 (result in 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 vm_code_2586 - read the Login value [ 2] in cell No. 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 vm_code_260A - the value of cell No. 6 is subtracted from cell No. 7 (the result is 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.6 vm_code_2689 - we read the value of SN [5] in cell No. 6 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, in both cells (6, 7) we get the same -zhe number, so we conclude that the fourth mathematical operation produces the following test: SN [5] = Login [8] + Login [4] - Login [2] </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. vm_code_28DA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - loop 10 pass all the symbols lo </font><font style="vertical-align: inherit;">ins and summarize them with a cell ‚Ññ7</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Roughly as a result of the fifth mathematical operation, the following code is executed: </font></font><br><br><pre> <code class="delphi hljs">Tmp := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Inc(Tmp, Login[I]); <span class="hljs-comment"><span class="hljs-comment">//   "Ms-Rem"     $11</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sum of all login symbols will remain in cell number 7 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. vm_code_2AF3</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.1 vm_code_2bc5 ‚Äî read SN value [8] in cell No. 6 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the same number will be obtained in both cells (6, 7), thus we conclude that the sixth mathematical operation produces the following check: SN [8] = Tmp (sum of all login numbers) </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. vm_code_2D27</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 vm_code_2D27_2D29 - 72 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2 vm_code_2DD5 is </font><font style="vertical-align: inherit;">added to cell # 7 </font><font style="vertical-align: inherit;">; we read the value of SN [9] in cell # 8 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, in both cells ( 7, 8) we get the same number, so we conclude that the seventh mathematical operation produces the following check: SN [9] = Tmp (sum of all login numbers) + 72 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. vm_code_2F41</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(at the moment of calling this procedure, the sum of the login numbers will be in cell No. 18) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1 vm_code_2FA1 - read the value of SN [6] in cell No. 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2 vm_code_2F41_300C - cell No. 6 is increased by the number 51 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3 vm_code_3071_307D + vm_code_308B toss Tmp in cell No. 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 vm_code_30AA - the value of cell No. 7 is added to cell No. 6 (the result is 6) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.5 vm_code_311D - we read the value of SN [7] in cell No. 7 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the same number will be obtained in both cells (6, 7), thus we do the conclusion that the eighth mathematical operation makes the following check: SN [7] = SN [6] + 51 + Tmp </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's actually the whole algorithm hidden in video </font><font style="vertical-align: inherit;">Rtualnoy machine, in full view.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how its source code will look like:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> keygenme_source; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Math; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ALogin, ASerial: AnsiString)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValidSN = <span class="hljs-string"><span class="hljs-string">'Congratulations!!! It is valid serial!'</span></span>; InvalidSN = <span class="hljs-string"><span class="hljs-string">'Serial invalid :('</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Login: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; Serial: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; I, A, B, Tmp: Byte; Checked: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Login[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">10</span></span>); Move(ALogin[<span class="hljs-number"><span class="hljs-number">1</span></span>], Login[<span class="hljs-number"><span class="hljs-number">0</span></span>], Min(<span class="hljs-number"><span class="hljs-number">10</span></span>, Length(ALogin))); <span class="hljs-comment"><span class="hljs-comment">//   for I := 0 to 9 do begin A := Byte(ASerial[1 + I * 2]); B := Byte(ASerial[2 + I * 2]); if A &gt; $39 then Dec(A, $37) else Dec(A, $30); if B &gt; $39 then Dec(B, $37) else Dec(B, $30); A := A shl 4; Serial[I] := A or B; end; //   Checked := True; //   if Serial[4] &lt;&gt; Byte(Serial[0] + 12) then Checked := False; //   if Serial[2] &lt;&gt; Byte(Serial[0] + Serial[3] + 84) then Checked := False; //   if Serial[1] &lt;&gt; Byte(Login[0] + Login[1] + Serial[4]) then Checked := False; //   if Serial[5] &lt;&gt; Byte(Login[8] + Login[4] - Login[2]) then Checked := False; //   Tmp := 0; for I := 0 to 9 do Inc(Tmp, Login[I]); //   if Serial[8] &lt;&gt; Tmp then Checked := False; //   if Serial[9] &lt;&gt; Byte(Tmp + 72) then Checked := False; //   if Serial[7] &lt;&gt; Byte(Serial[6] + 51 + Tmp) then Checked := False; //   if Checked then Result := ValidSN else Result := InvalidSN; end; begin Writeln(CheckSerial('Ms-Rem', 'C38FB7A0CF38F73B1159')); Readln; end.</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well ... almost all, the last third envelope is removed. </font></font><br>  Left just a little bit. <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13. We write the generator of serial numbers. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the keygenme task, the condition went on - it is necessary to zakigenit </font><font style="vertical-align: inherit;">write an algorithm that will generate a serial number based on the entered login. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having on hand the algorithm for checking the serial number to do it is quite trivial. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at the fields of the serial number, you can see that SN [0], SN [3] and SN [6] are not checked, they only participate in checking the values ‚Äã‚Äãof other fields. </font><font style="vertical-align: inherit;">Therefore, these three fields can contain absolutely any values, and the remaining fields will be calculated on their basis.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the generator code will look like this:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> serial_generator; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Math, SysUtils; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ALogin: AnsiString)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Login: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; Serial: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; I, Tmp: Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Login[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">10</span></span>); Move(ALogin[<span class="hljs-number"><span class="hljs-number">1</span></span>], Login[<span class="hljs-number"><span class="hljs-number">0</span></span>], Min(<span class="hljs-number"><span class="hljs-number">10</span></span>, Length(ALogin))); Randomize; <span class="hljs-comment"><span class="hljs-comment">//           Serial[0] := Random(255); Serial[3] := Random(255); Serial[6] := Random(255); //       Serial[4] := Serial[0] + 12; //       Serial[2] := Serial[0] + Serial[3] + 84; //       Serial[1] := Login[0] + Login[1] + Serial[4]; //       Serial[5] := Login[8] + Login[4] - Login[2]; //         Tmp := 0; for I := 0 to 9 do Inc(Tmp, Login[I]); //       Serial[8] := Tmp; //       Serial[9] := Tmp + 72; //       Serial[7] := Serial[6] + 51 + Tmp; //        HEX  Result := ''; for I := 0 to 9 do Result := Result + IntToHex(Serial[I], 2); end; begin Writeln(GetSN('Rouse_')); Readln; end.</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, here is a small list of serial numbers for the login "Rouse_": </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5E2BB2006AF04EEE6DB5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C5929D84D1F0F9996DB5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BC894434C8F0BA5A6DB5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14E19B3320F0B2526DB5 </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keygenme resolved. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Conclusions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let‚Äôs go through the stages again and remember which methods were used to hide the serial number check algorithm: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Resetting the entry point to zero is a controversial method, moreover, antiviruses will be looked at with suspicion because the usual ones the compiler will never generate such an executable file, it means that someone has modified it, which is a signal for the antivirus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Encryption of the body of an executable file is not in principle punishable, but as was shown above, such encryption is removed quite simply and does not constitute a serious obstacle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. The decryptor code abundantly diluted with garbage is a controversial decision; it is rather simply removed due to the fact that garbage blocks were not used as garbage. </font><font style="vertical-align: inherit;">Well, for example, instead of the ADD EAX, 2 instruction, you can write such a garbage block (the first thing that came to mind):</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> inc eax <span class="hljs-comment"><span class="hljs-comment">//    //    push eax lea eax, @label inc eax xchg eax, [esp] call @label @label: ret //    inc eax //    end;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a garbage unit is no longer removed on the machine with a script that detects the absence of changes in the registers, since </font><font style="vertical-align: inherit;">each instruction in reality will change their meaning. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it is well podshamanit over such a block and inflated to a large size, then it will be quite difficult to determine the beginning and end of the garbage. </font><font style="vertical-align: inherit;">Moreover, there is always a stack available, retaining the value of registers on it can, as garbage, even prove Fermat's theorem until you get bored, and then just restore the values ‚Äã‚Äãof the registers and continue the program :)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Virtual machine - due to unprotected handlers (VM instruction handlers) to write its equivalent did not take much time. For good in the combat application, the VM handlers must be qualitatively obfuscated in order to make it difficult to understand the logic of the VM operation. It is clear that for keygenme this stage is superfluous, but one should not forget about such subtlety. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. The logic of the P-Code operation - despite the presence of clearly garbage instructions, the basic algorithm for receiving data from the buffer with login / SN turned out to be the same at all stages, which made it possible to quickly disassemble all the logic based on the template. If several variants of data acquisition were introduced (and a unique variant for obtaining each symbol would be better), this would greatly complicate the analysis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. VM analysis would be complicated at times if inside the P-Code there was another virtual machine (say, based on the same Brainfuck) that would interpret its own P-Code. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the result:</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A very high-quality keygenme, perfectly showing the work with the virtual machine. The only nuance to which he does not give an answer is how the P-Code was obtained for the virtual machine that it executes :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This stage is individual for each developer, each one uses his own methods, however, I have an article on the implementation of the picode generation algorithm , true for a slightly different type of VM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For my part, I showed one of the options for hacking such VMs, without the deobfuscation stage of an acm listing, using VM execution graphs as a toolkit.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think it will be able to help you in analyzing your own VM implementations for their resistance to this hacking option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, if you have not yet come to the actual implementation of the VM, at least now you have a minimal idea of ‚Äã‚Äãhow it can work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of demos for an article can be collected at this link: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://rouse.drkb.ru/blog/vm_analize.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Draw conclusions and good luck.</font></font></div><p>Source: <a href="https://habr.com/ru/post/218887/">https://habr.com/ru/post/218887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218871/index.html">Dropbox launched the Carousel application</a></li>
<li><a href="../218873/index.html">How to create and earn money on SaaS (Part 4 / StartTap Quickme - communication and collaboration of small teams)</a></li>
<li><a href="../218881/index.html">Launch of Brain Basket, April 15, NSC Olympic</a></li>
<li><a href="../218883/index.html">Development of sensors with Bluetooth low energy radio interface</a></li>
<li><a href="../218885/index.html">Navigator for the project: MS Project + formulas + indicators</a></li>
<li><a href="../218889/index.html">How we integrated Teamlab with Google Drive and increased attendance 4 times</a></li>
<li><a href="../218893/index.html">IT subsystems of the sports center: pre-reality, security, medicine, point accounting, etc.</a></li>
<li><a href="../218895/index.html">(For) what is feeding and watering developers in the office ?!</a></li>
<li><a href="../218897/index.html">Quadcopter control using Oculus Rift</a></li>
<li><a href="../218899/index.html">Yandex investigated how the Internet developed in the regions of Russia in 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>