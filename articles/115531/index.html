<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Server from image: DHCP + TFTP + Initrd + OpenVZ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings. Often, large projects use fairly large sets of identical servers that have the same software configuration (read the root). And often, the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Server from image: DHCP + TFTP + Initrd + OpenVZ</h1><div class="post__text post__text-html js-mediator-article">  Greetings.  Often, large projects use fairly large sets of identical servers that have the same software configuration (read the root).  And often, the administrators of these machines need to maintain them in a symmetrical state - the same sets of packages, configs, etc.  etc.  One of the solutions to this problem is to download such machines over the network, so that they have a common root and keep it in RAM, and stored data (for example / var / www for web servers) are kept on hard drives mounted after the download.  About this and talk. <a name="habracut"></a><br><br><h5>  A couple of words about what we will do </h5><br>  One of the goals that I set is maximum simplicity.  Therefore, this article uses the minimum set of tools, and they are as easy to use as possible.  We will pack the image directly into the initrd, and issue it with the same TFTP server, which will give the kernel and the loader. <br>  As an optional continuation, in the last section I will talk about the use of OpenVZ in this task - in my opinion, it‚Äôs more convenient to work with a virtual host than with the chroot environment - especially if you make massive server updates (and even for banal testing is convenient). <br>  If you decide to use OpenVZ - think about settling a DHCP and TFTP server inside the VZ-container (especially if you already have several host systems) - this will allow you to deploy a DHCP server in case of failure of the main host system. <br>  So let's go. <br><br><h5>  DHCP </h5><br>  Everything is simple here.  I used dhcpd.  In the default config we enter: <br> <code>#     dhcpd  pxelinux <br> option space pxelinux; <br> option pxelinux.magic code 208 = string; <br> option pxelinux.configfile code 209 = text; <br> option pxelinux.pathprefix code 210 = text; <br> option pxelinux.reboottime code 211 = unsigned integer 32; <br> <br> site-option-space "pxelinux"; <br> option pxelinux.magic f1:00:74:7e; <br> if exists dhcp-parameter-request-list { <br> option dhcp-parameter-request-list = concat(option dhcp-parameter-request-list,d0,d1,d2,d3); <br> } <br> <br> group <br> { <br> option pxelinux.configfile "configs/bla-bla.ru/config"; #  pxelinux`a    <br> filename "/var/lib/tftpboot/pxelinux.0"; #  <br> #  <br> host first.bla-bla.ru <br> { <br> hardware ethernet 48:5b:39:90:b9:06; #MAC   <br> fixed-address 192.168.0.100; <br> option host-name "first.bla-bla.ru"; <br> } <br> #  <br> host second.bla-bla.ru <br> { <br> hardware ethernet 48:5b:39:90:b9:07; #MAC   <br> fixed-address 192.168.0.101; <br> option host-name "second.bla-bla.ru"; <br> } <br> } <br> <br> subnet 192.168.0.0 netmask 255.255.255.0 #,     dhcp- <br> { <br> option routers 192.168.0.1; # <br> option domain-name-servers 192.168.0.2; #DNS <br> range 192.168.0.100 192.168.0.150; #    <br> } <br> <br> deny unknown-clients; #   <br></code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Restart dhcpd.  Now it will offer machines to boot over the network. <br><br><h5>  Tftp </h5><br>  For tftp tftp-hpa was used.  To work correctly in /etc/xinetd.d/tftp (in ubuntu, the file needed to be created independently) the following lines fit in: <br><br> <code>service tftp <br> { <br> port = 69 <br> socket_type = dgram <br> wait = yes <br> user = root <br> server = /usr/sbin/in.tftpd <br> server_args = /var/lib/tftpboot <br> disable = no <br> } <br></code> <br><br>  As can be seen from the config, we will store all the good intended for downloading machines over the network in / var / lib / tftpboot.  Restart xinetd.  TFTP is now ready too <br><br><h5>  Boot Loader (PXELinux) </h5><br>  PXELinux is the twin brother of SYSLinux ªa (which is used, probably in all Linux-CD installations), but focused on network booting.  I myself have taken the bootloader from a Ubuntu netboot image, although I suspect there are other ways to get it.  Put the binary (pxelinux.0) in / var / lib / tftpboot /.  Its default configs can be located in the pxelinux.cfg subdirectory, then the default will be used as the main one (the full path for it will be: /var/lib/tftpboot/pxelinux.cfg/default).  But we indicated in the dhcpd config that the servers of the bla-bla.ru group will retrieve their configs from configs / bla-bla.ru / config (the full path /var/lib/tftpboot/configs/bla-bla.ru/config ).  Therefore, we create the necessary directories and write to the config: <br><br> <code>default linux <br> timeout 100 <br> <br> label linux <br> kernel kernels/vmlinuz-2.6.32 <br> append panic=15 initrd=images/bla-bla.ru/current <br></code> <br><br>  As you can see, the kernel will be stored in kernels /, and the image itself is in images /.  Of course, you will specify your kernel version later.  But all this later, but for now we will be engaged in the manufacture of the image itself. <br><br><h5>  Cooking image </h5><br>  As I said, our image will be stored directly in the initrd.  This way is much easier than using SquashFS + UnionFS (because the latter is not included in the kernel, and therefore requires chronic recompilation of the latter).  And simpler / safer nfs_root.  does not require additional services that may become additional points of failure. <br>  I compiled my image in Ubuntu, for Debian, the procedure will be the same.  So, we need debootstrap.  Create a directory somewhere (let it be / root / image) and deploy an image into it.  Well, for example, Ubuntu Lucid: <br><br> <code>debootstrap lucid /root/image</code> <br> <br>  Now chroot` there and put the kernel (in the box).  We exit the chroot`a, and drag the resulting kernel into / var / lib / tftpboot / kernels / and enter it into the config from the previous section.  By the way, it can be removed from the environment itself so that it does not occupy precious space. <br>  As you probably already understood, this environment is the future image.  Here you can put the necessary packages and edit configs.  Also, you definitely need to create / etc / fstab (even if you don‚Äôt want to fill it, although I would write the / proc;)) and the init file in the root (for some reason, Kernel Panic was obtained without it, although the file was intentionally there was no right to execute, and the content was empty).  I also advise you to enter the receipt of ip-addresses via dhcp in / etc / network / interfaces - our DHCP server can issue static addresses. <br>  Now we are ready to assemble an image.  But before that you need to know about one particular process: <b>cpio - does not know how to pack hardlinks</b> .  This means that if you do not disassemble them, you will lose some utilities - for example, ifup, ifdown, mkfs, and some other files. <br>  To solve this problem, I wrote a small crutch on Perl, which parses them: the <a href="http://pastebin.com/MtkaDVHg">code is here</a> .  We tell this script as a parameter to the / root / image directory so that it can disassemble the links there.  Next, go to the directory with the environment (/ root / image) and say: <br><br> <code>find | cpio -H newc -o -p &gt; ../bla-bla.ru; gzip -9 ../bla-bla.ru;cp ../bla-bla.ru.gz /var/lib/tftpboot/images/bla-bla.ru/2011-03-16;ln -s /var/lib/tftpboot/images/bla-bla.ru/2011-03-16 /var/lib/tftpboot/images/bla-bla.ru/current</code> <br> <br>  This command will pack the image as an initrd, put it in the right place and create a link to it with current (which is specified in the config file). <br>  That's all!  When you try to boot on the network, the machine should unwind from the image we created. <br><br><h5>  Openvz </h5><br>  With the help of OpenVZ we will make a live model of the image.  It (OpenVZ) is convenient for our purposes, first of all, because the images of VZ virtualos are stored on the disk ‚Äúas is‚Äù in the form of a tree, and therefore they are conveniently packaged.  In my case, I went a little further and collected DHCP + TFTP also inside an OpenVZ container (separate, of course). <br>  If you also want to use OpenVZ in solving this task - we will assume that you have already configured a server with everything you need for this virtualization system (support in the kernel, vzctl) - good, there is enough documentation on this topic. <br><br>  Create a virtual machine: <br><br> <code>vzctl create 100 --hostname model.bla-bla.ru</code> <br> <br>  Run it is not necessary.  Delete the entire contents of the private directory (by default / var / lib / vz / private / 100, where 100 is the VEID specified during creation) and put the directory tree in it, which we did in the previous paragraph. <br><br>  If you have already entered the auto-receiving network settings into the system being deployed from the image, do not be too lazy to enter the DHCP server and the address of this virtual machine into the configuration (you can find the MAC address of the container by going to the host system through vzctl enter and executing ifconfig is there), otherwise it risks to remain without a network. <br><br>  Run: <br><br> <code>vzctl start 100</code> <br> <br>  With a positive outcome virtualka comes down to the DHCP-server for the address and will be available on the network.  Now you can work with it in the same way as with a full-fledged machine from which images will be created. <br>  To automatically build images, I wrote a small <a href="http://pastebin.com/GBZ40szh">Perl script</a> that works like this: <br><ol><li>  In the title, we declare the VEIDs of the ‚Äúmodels‚Äù (virtual machines from which we will shoot images) and the dhcp server.  If your dhcp-server does not live on the VZ-container - just correct $ out_path) </li><li>  For each virtualka specified in the script, the modification time of / var / lib / apt / extended_states is checked (this file is changed each time the package list is changed - setting / updating something or via apt-get); the resulting time stamp is recorded in / var / cache / netboot / number (directory must exist). </li><li>  If the time stamp from the script cache is lower than the change time of the scanned file, the virtual machine stops. </li><li>  Next, the / var / cache / apt is cleaned (to save space) and a cpio image is assembled, after which the virtual machine is started back.  Previously, the previous script is executed that parses the hard links.  It is believed that it lies in the directory described in PATH, and it is called nb_links_breaker. </li><li>  In the final stage, the cpio image is pressed by gzip, it moves to the right place (by default - / var / lib / tftpboot / images / virtual_name / date and a link from current is attached to it. </li></ol><br><br>  As you can see, the script is the simplest and, if desired, it can be rewritten to respond to any other change.  You can hang his cron and he will follow the process himself, collecting as needed images. <br><br><h5>  Total </h5><br>  There are two obvious disadvantages of the proposed option - the consumption of RAM for the use of a RAM disk and <i>the</i> higher boot time compared to hard drives (by obtaining an image and unpacking it).  The flip side is the resulting functionality: once you have assembled an image, you will be able to commission a new server in minutes, and each assembled image can serve as a rollback point in case of an unsuccessful update. <br>  Of course, only the general principles and manipulations necessary to obtain a basic system packed in an initrd with the ability to boot over the network are described here.  Various options for finishing, such as the mdadm ªa config and small scripts that make life easier (for example, for partitioning disks on a new server) are left to the discretion of the reader. <br><br>  I hope that it will be useful to someone.  Thanks for attention.  :) </div><p>Source: <a href="https://habr.com/ru/post/115531/">https://habr.com/ru/post/115531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115522/index.html">Anyone, even the smallest online store, can accept cards</a></li>
<li><a href="../115525/index.html">Prostopleer became paid</a></li>
<li><a href="../115527/index.html">How to get and measure high-speed TCP connection</a></li>
<li><a href="../115528/index.html">HTML5 Canvas browser performance test</a></li>
<li><a href="../115529/index.html">Free access to the course on ReSharper from PluralSight</a></li>
<li><a href="../115533/index.html">Donetsk coffee-and-code with a taste of Ruby on Rails</a></li>
<li><a href="../115536/index.html">The simplest RSS reader</a></li>
<li><a href="../115538/index.html">Features Firewall in Windows 7</a></li>
<li><a href="../115539/index.html">Communication billing and Cisco Catalyst 2960 via SNMP. Change port speed, traffic count</a></li>
<li><a href="../115540/index.html">What does VKontakte do with personal data after deleting the page?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>