<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unbiased DirectX Rendering on GPU, CPU and in the cloud</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to create a renderer that would even work on your grandmother‚Äôs computer? Initially, we faced a slightly different task - to create an unbiased re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unbiased DirectX Rendering on GPU, CPU and in the cloud</h1><div class="post__text post__text-html js-mediator-article">  How to create a renderer that would even work on your grandmother‚Äôs computer?  Initially, we faced a slightly different task - to create an unbiased render for all GPU models: NVidia, ATI, Intel. <br>  Although the idea of ‚Äã‚Äãsuch a render for all video cards has been in the air for a long time, it hasn‚Äôt reached a high-quality implementation, especially on Direct3D.  In our work, we have come to a very wild bunch and will continue to tell you what brought us to it and how it works. <br><br><img src="https://habrastorage.org/storage2/e9d/ced/f01/e9dcedf01a9c7f3584d4b42398f7fdd3.png" alt="renderbro resource combined"><br><a name="habracut"></a><br><br>  That is unbiased rendering, or rendering without assumptions, very well outlined <a href="http://habrahabr.ru/users/marchevsky/" class="user_link">Marchevsky</a> in a series of articles <br>  "Tracing the path to the GPU" <a href="http://habrahabr.ru/post/132862/">Part 1</a> , <a href="http://habrahabr.ru/post/132904/">Part 2</a> and " <a href="http://habrahabr.ru/post/142003/">Unbiased rendering (rendering without assumptions)</a> ". <br>  In short: this is a rendering that does not introduce systematic errors in the calculation and reproduces physically accurate effects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  global lighting </li><li>  soft shadows, realistic reflections </li><li>  depth of field and motion blur </li><li>  subsurface scattering and more </li></ul><br><br> <a href="http://renderbro.com/"><img src="https://habrastorage.org/storage2/6eb/867/8f6/6eb8678f67bb8095fd4ba68c189674c4.jpg" alt="glass ball, 2 minutes on HD 5770"></a> <br><br>  Due to the physical accuracy and quality of the image, this approach is obviously very resource-intensive.  You can solve the problem by transferring calculations to the GPU, since this approach gives an increase in the calculation speed to 50 and once per GPU device. <br><br> <a href=""><img src="https://habrastorage.org/storage2/13b/ee1/4cf/13bee14cfa7a93c35f30721d4b63244a.jpg" alt="mech octopus, 9 minutes on HD 6870"></a> <br>  1200x600 (clickable), AMD Radeon HD 6870, render time: <b>9 min</b> <br><br><h4>  Why Direct3D </h4><br>  There are many GPGPU platforms (OpenCL, CUDA, FireStream, DirectCompute, C ++ AMP, Shaders, etc.), but the debate about the optimal choice is still going on, and there is no definitive answer to what is best to use.  Consider the main arguments in favor of Direct3D, which have led us to choose the name of this API: <br><br><ul><li>  It works on the entire spectrum of video cards, is emulated on all processor models: the same shader works everywhere </li><li>  It is Direct3D specifications that set the direction for consumer iron development. </li><li>  Always the first to get the most recent and stable drivers. </li><li>  The remaining cross ‚Äí vendor technologies are unstable or poorly supported. </li></ul><br>  From OpenCL and Direct3D, we chose the evil that, at least, has stable drivers, honed by decades of the gaming industry, and has better performance in a number of benchmarks.  Also, based on the task, CUDA was rejected, despite all the tools, an abundant number of examples and a strong developer community.  C ++ AMP was not yet announced at the time, but since  its implementation is built on top of DirectX, transferring the render to it will not make any special problems. <br>  The OpenGL / GLSL bundle was also considered, but was quickly discarded due to limitations that are solved in DirectX using DirectCompute (problems of bidirectional path tracing, etc.). <br><br>  Also, we note the situation with GPGPU consumer hardware drivers, which come out late and are brought to stability for a long time.  So, with the release of the NVIDIA Kepler 600 line, gamers immediately got quality Direct3D drivers and more efficient gaming machines, but most of the GPGPU applications lost their compatibility or became less productive.  For example, Octane Render and Arion Render, built on CUDA, began to support the Kepler line just a few days ago.  In addition, professional GPGPU hardware is not always much better in a number of tasks, as described in the article ‚Äú <a href="http://habrahabr.ru/post/142369/">NVidia for professional 3D applications</a> ‚Äù.  This gives reason to assemble a workstation on the consumer gaming hardware. <br><br><h4>  Why not Direct3D </h4><br>  In all announcements of DirectX 10‚Äí11 they write that new shader models are ideal for ray tracing and many other GPGPU tasks.  But in fact, no one really used this opportunity.  Why? <br><br><ul><li>  There were no tools and support </li><li>  Research shifted towards NVIDIA CUDA due to strong marketing </li><li>  Snapping to one platform </li></ul><br>  Let's go back a year ago.  The last update of the DX SDK was in July 2010. There is no integration with VisualStudio, there are practically no GPGPU developer communities and qualitative examples of normal computing tasks.  But what really is there, there is no syntax highlighting for shaders!  Sane debugging tools either.  PIX is not able to withstand multiple nested loops or a shader of 400+ lines of code.  D3DCompiler could crash through time and compile complex shaders for tens of minutes.  Hell. <br><br>  On the other hand, weak implementation of the technology.  Most of the scientific articles and publications were written using CUDA, and sharpened by NVIDIA hardware.  The NVIDIA OptiX team is also not particularly interested in research for other vendors.  The German company mentalimages, which for decades has accumulated experience and patents in this area, is now also owned by NVIDIA.  All this creates an unhealthy imbalance in the direction of one vendor, but the market is the market.  For us, this all meant that all new GPGPU tracing and rendering techniques must be investigated anew, but only on DirectX and on ATI and Intel hardware, which often led to completely different results, for example, on the VLIW5 architecture. <br><br><h4>  Implementation </h4><br>  <b>Eliminate problems</b> <br>  Before describing the implementation, here are some useful tips that helped us in the development: <br><ul><li>  If possible, go to VisualStudio2012.  The long-awaited integration with DirectX, built-in debug shaders, and, oh, a miracle, HLSL syntax highlighting will save you a lot of time. </li><li>  If VS2012 is not a variant, you can use tools like NVidia Parallel Nsight, but again there is a binding to one type of GPU. </li><li>  Use the Windows 8.0 SDK, this is your bro.  Even if you are developing on Windows Vista / 7 and older versions of VisualStudio, you will have the latest D3D libraries at your disposal, including the fresh D3DCompiler, which shortens the compiler time for shaders by 2-4 times and works stably.  There is a detailed <a href="http://blogs.msdn.com/b/vcblog/archive/2012/03/25/10287354.aspx">manual</a> for configuring DirectX from Windows 8.0 SDK. </li><li>  If you are still using D3DX, consider dropping it, this is not a bro.  The Windows 8.0 SDK stopped supporting it for very obvious reasons. </li></ul><br><br>  <b>Rasterization vs tracing</b> <br>  Despite the fact that DirectX is used, there is no talk about rasterization.  Standard Pipeline Vertex, Hull, Domain, Geometric and Pixel Shaders are not used.  We are talking about tracing the paths of light by means of pixel and Compute shaders.  The idea of ‚Äã‚Äãcombining rasterization + tracing, of course, arose, but turned out to be very difficult to implement.  The first intersection of the rays can be replaced by rasterization, but after that it is very difficult to generate secondary rays.  Often it turned out that the rays were under the surface, and the result was wrong.  The guys from Sony Pictures Imageworks, who are developing Arnold Renderer, came to the same conclusion. <br><br>  <b>Rendering</b> <br>  There are two basic rendering organization approaches: <br><br><ol><li>  All calculations take place in the mega-core of the GPU program, which is responsible for both tracing and shading.  This is the fastest rendering method.  But if the scene does not fit in the memory of the GPU, then either the scene will be swapped, or the application will break. </li><li> Out Of Core Rendering: Only the geometry of the scene or part of it is transmitted to the GPU, along with the ray buffer for tracing, and a multi-pass ray tracing is performed.  Shading is done either on the CPU, or another pass on the GPU.  Such approaches are not famous for amazing performance, but they allow rendering scenes of production  size. </li></ol><br><br><img src="https://habrastorage.org/storage2/40f/564/d37/40f564d3737452e7e002bb268100a023.png"><br><br>  We stopped at the first option using shaders for GPGPU, but before that or rendering, you need to prepare the geometry and data about the scene, correctly placing them in the memory of the GPU. <br>  Scene data includes: <br><br><ul><li>  geometry (vertices, triangles, normals, texture coordinates) </li><li>  accelerating structure (nodes Kd ‚Äí tree or BVH) </li><li>  surface materials (type, colors, texture pointers, reflective exponents, and more) </li><li>  texture materials, normal maps, etc. </li><li>  light sources (singular and extended) </li><li>  camera position and parameters, such as DOF, FOV, etc. </li></ul><br>  No vertex and index buffers are used when rendering.  In Direct3D11, the data is unified, everything is stored in the same format, but you can tell the device how to look at it: like Buffer, Texture1D / 2D / 3D / Array / CUBE, RenderTarget, etc.  Data that is more less linear access is best stored in the form of buffers.  Data with random access, for example, accelerating the structure of the scene, it is better to store in the texture, because  with frequent calls, part of the data is cached. <br>  Quickly changing small data chunks are reasonably stored in constant buffers, these are camera parameters, light sources and materials, if there are not many of them and they fit into a buffer of 4096 x float4.  In interactive rendering, changing the camera position, setting up materials and light is the most common operation.  The change in geometry occurs somewhat less frequently, but the constant memory is still not enough to accommodate it. <br><br>  Because  GPU memory is relatively small, you need to use smart approaches to its organization and try to pack everything that you can pack and use data compression.  The textures of the materials we place in a multi-layered texture atlas, because  The number of GPU texture slots is limited.  Also, the GPU has built-in texture compression formats - DXT, which are used for texture atlases and can reduce the size of textures by up to 8 and times. <br><br>  Texture packing in satin: <br><img src="https://habrastorage.org/storage2/960/6b2/ab1/9606b2ab19d36f7638c59de77e31ccd0.png"><br><br>  As a result, the location of the data in memory looks like this: <br><img src="https://habrastorage.org/storage2/e34/a7f/615/e34a7f615f0740512c4c613cf65916d3.png"><br><br>  It is assumed that the data of light and materials can fit in the constant registers.  But if the scene is quite complicated, the materials and the light will be placed in the global memory, where there should be enough space for them. <br><br> <a href="http://renderbro.com/"><img src="https://habrastorage.org/storage2/fb2/220/9dc/fb22209dc0a06346bdc3af25d93da190.jpg"></a> <br><br>  Moving to rendering: in the vertex shader, draw a quad, screen size, and use the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb219690(v%3Dvs.85).aspx">mapping</a> technique of <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb219690(v%3Dvs.85).aspx">pixels to pixels</a> so that each pixel of the pixel shader rasterizes the correct texture coordinates and, consequently, the correct x and y values ‚Äã‚Äãon the screen. <br><img src="https://habrastorage.org/storage2/d59/d46/379/d59d463797595c29dfbcb917e7da81fc.png"><br>  Further, for each pixel in the shader, a ray path tracing algorithm is calculated.  This method performs GPGPU computations on pixel shaders.  Such an approach may not seem to be the most optimal, and it would be more reasonable to use DirectCompute, for which no vertex shaders and screenshots should be created.  But numerous tests have shown that DirectCompute is 10-15% slower.  In the task of tracing the path, all the benefits of using SharedMemory or using packets of rays quickly disappear due to the random nature of the algorithm. <br><br>  Two techniques are used for rendering: interactive viewing works on modified unidirectional path tracing (Path Tracing), and Bidirectional Path Tracing can be used for final rendering.  her frame rate is not very interactive on complex scenes.  Sampling by the Metropolis Light Transport method is not yet used, since  its effectiveness has not yet been justified, as <a href="http://www.chaosgroup.com/forums/vbulletin/showthread.php%3F52307-V-Ray-2-0-VRayBPTracer">evidenced by</a> one of the V-Ray developers on the ChaosGroup closed forum: <br><br>  <i>vlado posted:</i> <br><blockquote>  ‚Äú... I came to the conclusion that MLT is way overrated.  It can be much more than a well-implemented path tracer.  This is because MLT can‚Äôt take a sample of ordering (for example, quasi-Monte Carlo sampling, or we can use it, or N-rooks sampling, etc.).  The MLT renderer must be able to reduce the number of scenes (like an open skylight scene). ‚Äù <br></blockquote><br><br><h4>  Multi ‚Äí Core.  Multi ‚Äí Device.  Cloud </h4><br>  Note that the unbiased ‚Äí rendering is very good - it is based on the Monte  Carlo method, which means that in the general case each rendering iteration does not depend on the previous one.  That is what makes this algorithm attractive for computing on GPU, multi-core systems and clusters. <br><br>  To support DX10 and DX11 class hardware and not to rewrite everything anew for each version, you should use DirectX11, which <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ff476872(v%3Dvs.85).aspx">runs on DX10 Hardware</a> with minor limitations.  Having support for a wide class of hardware and the algorithm's predisposition to distribution, we made Multi Multi Device rendering, the principle of which is very simple: you need to put the same data, shaders into each GPU and simply collect the result from each GPU as it is ready, restarting the rendering with changes in scene.  The algorithm allows you to distribute the rendering on a very large number of devices.  This concept is great for cloud computing.  However, there are not so many cloud-based GPU providers , and the computer time is also not very cheap. <br><br>  With the advent of DirectX11 came to the aid of a remarkable technology - <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/gg615082(v%3Dvs.85).aspx">WARP</a> (Windows Advanced Rasterization Platform).  WARP Device translates your GPU code into SSE ‚Äí optimized multi-thread code, allowing you to perform GPU computations on all CPU cores.  And absolutely any CPU: x86, x64 and even ARM!  From a programming point of view, such a device is no different from a device's GPU.  It is on the basis of WARP in C ++ AMP that heterogeneous calculations are implemented.  WARP Device is also your bro, use WARP Device. <br><img src="https://habrastorage.org/storage2/09a/d19/3d9/09ad193d939a2a6b6bd0fde9929cd077.png"><br><br>  Thanks to this technology, we were able to run GPU rendering in the CPU cloud.  We got a bit of free access to Windows Azure through the BizSpark program.  Azure Storage was used for data storage, data with scene geometry and textures were stored in Blobs, data on rendering tasks, uploading and downloading scenes are in queues (Queues).  To ensure stable operation, three processes were used: the task scheduler (Work Scheduler), the process monitor (Process Monitor), and the process that downloads rendered images (Image Downloader).  Work Scheduler is responsible for loading data into blobs and setting tasks.  Process Monitor is responsible for maintaining all workers (Worker - Azure Compute node) in working condition.  If one of the workers stops responding, then a new instance is initialized, thus ensuring maximum system performance.  Image Downloader collects the rendered pieces of images from all workers and transfers the finished or intermediate image to the client.  As soon as the rendering task is completed, Process Monitor eliminates the images of the workers so that there are no idle resources for which you would have to pay. <br><img src="https://habrastorage.org/storage2/fd2/46d/a97/fd246da976d809f862004ee3e01ff529.png"><br><br>  This scheme works well, and for this, it seems to us, the future of rendering - <a href="http://renderman.pixar.com/products/tools/faq-cloud.html">Pixar is already rendering in the cloud</a> .  Typically, cloud billing is only for downloaded traffic, which consists of rendered images no larger than a few megabytes.  The only bottleneck of this approach is the user's channel.  If you need to re-create an animation with the size of asets of several tens or hundreds of GB, then you have problems. <br><br><h4>  Result </h4><br>  The result of all this work was the RenderBro plug-in for Autodesk 3DS Max, which, as it was intended, should render even on a grandmother‚Äôs computer and can use any computing resources. <br><br> <a href="http://renderbro.com/"><img src="https://habrastorage.org/storage2/bac/8bc/127/bac8bc1275d758a22beb883fe6097c2b.jpg"></a> <br><br>  He is now at the stage of closed alpha testing.  If you are a GPU ‚Äí enthusiast, 3D ‚Äí artist, you have decided to build an ATI / NVIDIA cluster, you have a lot of different GPUs and CPUs, or any other interesting configuration, <a href="http://renderbro.com/">let me know if</a> it will be interesting to work together.  I'd love to check the render on something like this: <br><img src="https://habrastorage.org/storage2/151/d03/726/151d0372643be13d87b057433741b883.jpg"><br><br>  Also, ahead of C ++ AMP version of the render, more serious cloud tests and plugin development for other editors.  Join now! </div><p>Source: <a href="https://habr.com/ru/post/152033/">https://habr.com/ru/post/152033/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152024/index.html">Centralized logging from network equipment consoles via ssh</a></li>
<li><a href="../152025/index.html">My "paradigm" of working with threads</a></li>
<li><a href="../152028/index.html">7,100 employees work on the Google Maps project.</a></li>
<li><a href="../152030/index.html">IPhone 5 Review - Habrahabr Edition</a></li>
<li><a href="../152031/index.html">A small review of the large computer Acer Predator</a></li>
<li><a href="../152034/index.html">IR remote for PC and sockets. Part 2</a></li>
<li><a href="../152035/index.html">Programmers playing economics</a></li>
<li><a href="../152036/index.html">Simulation of the will in artificial intelligence</a></li>
<li><a href="../152038/index.html">InterSystems Grant Program</a></li>
<li><a href="../152039/index.html">Publishing the application in the Windows Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>