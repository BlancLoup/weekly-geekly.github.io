<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Securing Network Security in the Kubernetes Cluster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Network Policies is a new Kubernetes functionality that, through the creation of firewalls, allows you to configure network interaction between groups...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Securing Network Security in the Kubernetes Cluster</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/8ce/63b/42e/8ce63b42e14d4cc79e42b5f0f359ce61.png" align="left" hspace="10" vspace="10">  Network Policies is a new Kubernetes functionality that, through the creation of firewalls, allows you to configure network interaction between groups of hoops and other network nodes.  In this guide, I will try to explain features not described in the official Kubernetes network policy documentation. </p><br><p>  Network policy functionality has stabilized in Kubernetes 1.7.  In this article, their work is explained in theory and in practice.  If you wish, you can go directly to the repository with examples of <a href="https://github.com/ahmetb/kubernetes-networkpolicy-tutorial">kubernetes-networkpolicy-tutorial</a> or to the <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">documentation</a> . </p><a name="habracut"></a><br><h2 id="chto-mozhno-delat-s-setevymi-politikami">  What can you do with network policies </h2><br><p>  In the Kubernetes cluster, the traffic between the subfields is not limited by default.  This means that pods can easily connect to each other, and there are no firewalls inside the cluster that could prevent them. </p><br><p>  Network policies allow declaratively determine which pods to whom they can connect.  When configuring policies, it is possible to drill them down to namespaces or more precisely, denoting the ports for which the selected policies will operate. </p><br><p>  Currently, traffic originating from hearths cannot be controlled in this way.  This functionality is planned in Kubernetes 1.8. </p><br><p>  At the same time, an open source project called <a href="https://istio.io/">Istio</a> is a good alternative with support for outbound filtering, as well as many other features, including native support for Kubernetes. </p><br><h2 id="chem-horoshi-setevye-politiki">  What are good network policies </h2><br><p>  Network Policies has been another name for IT access control lists (ACLs) for more than a decade.  With the Kubernetes cluster, access control lists for pods are configured with their help.  Like all other resources in the Kubernetes cluster, network policies are configured using declarative manifests.  They are part of the application, located in its repository and deployed to Kubernetes along with the application. </p><br><p>  <strong>Network policies are applied in near real time.</strong>  If there are open connections between the sub, applying a new policy prohibiting such connections will lead to their immediate rupture.  However, for such efficiency you have to pay a small loss of performance.  See more details and benchmark results in <a href="http://blog.kubernetes.io/2016/09/high-performance-network-policies-kubernetes.html">this article</a> . </p><br><h2 id="primery-ispolzovaniya">  Examples of using </h2><br><p>  Below are some common examples of the use of network policies by Kubernetes.  Additional examples and corresponding manifests can be found on GitHub: <a href="https://github.com/ahmetb/kubernetes-networkpolicy-tutorial">kubernetes-networkpolicy-tutorial</a> . </p><br><h3 id="zapreschenie-vsego-trafika-k-prilozheniyu-deny">  Deny all traffic to the application (DENY) </h3><br><p>  This policy will cause a drop (drop) of all traffic to the application pods selected using the Pod Selector. </p><br><p>  <strong>Usage scenarios:</strong> </p><br><ul><li>  You want to run under, but prevent others from interacting with it. </li><li>  You want to temporarily isolate traffic to the service from other platforms. </li></ul><br><img src="https://habrastorage.org/web/240/37f/c47/24037fc475964bcdab52387b37814b9e.gif"><br><p>  <strong>Example</strong> </p><br><p> Run nginx under the tags <code>app=web</code> and <code>env=prod</code> , and also open its 80th port: </p><br><pre> <code class="plaintext hljs">kubectl run web --image=nginx --labels app=web,env=prod --expose --port 80</code> </pre> <br><p>  Run a temporary one and run a request to the <code>web</code> service: </p><br><pre> <code class="plaintext hljs">$ kubectl run --rm -i -t --image=alpine test-$RANDOM -- sh / # wget -qO- http://web &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ...</code> </pre> <br><p>  Works!  Now, save the following manifest to the <code>web-deny-all.yaml</code> and apply it to the cluster: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: web-deny-all spec: podSelector: matchLabels: app: web env: prod</code> </pre> <br><pre> <code class="plaintext hljs">$ kubectl apply -f web-deny-all.yaml networkpolicy "access-nginx" created</code> </pre> <br><p>  <strong>Check</strong> </p><br><p>  Run the container again and try to make a request to the <code>web</code> service: </p><br><pre> <code class="plaintext hljs">$ kubectl run --rm -i -t --image=alpine test-$RANDOM -- sh / # wget -qO- --timeout=2 http://web wget: download timed out</code> </pre> <br><p>  Traffic is blocked! </p><br><hr><br><p>  <strong>Remarks</strong> </p><br><p>  In the above manifest to achieve the desired, we assigned to submit special tags <code>app=web,env=prod</code> .  However, this file lacks the <code>spec.ingress</code> field.  Therefore, all traffic is denied. </p><br><p>  If you create another network policy that will allow some users to access the application directly or indirectly, the first network policy will expire. </p><br><p>  If there is at least one network policy with rules permitting traffic, this traffic will follow the allowed route, regardless of the existence of prohibitory rules. </p><br><p>  Cleaning </p><br><pre> <code class="plaintext hljs">kubectl delete deploy web kubectl delete service web kubectl delete networkpolicy web-deny-all</code> </pre> <br><h2 id="ogranichenie-trafika-k-prilozheniyu-limit">  Limit traffic to the application (LIMIT) </h2><br><p>  You can create a network policy that restricts traffic only from certain hearths. </p><br><p>  <strong>Usage scenarios:</strong> </p><br><p>  Providing access to the service only to those microservices that need it. </p><br><p>  Providing access to the database only to applications using it. </p><br><img src="https://habrastorage.org/web/eb3/ec3/355/eb3ec335570e4b3d98451125b307e1ae.gif"><br><p>  <strong>Example</strong> </p><br><p>  Suppose that in our application there is a REST API server with tags <code>app=bookstore</code> and <code>role=api</code> : </p><br><pre> <code class="plaintext hljs">kubectl run apiserver --image=nginx --labels app=bookstore,role=api --expose --port 80</code> </pre> <br><p>  Save the following network policy to the <code>api-allow.yaml</code> .  It only allows access to other sites (for example, other microservices) with the <code>app=bookstore</code> tag: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: api-allow spec: podSelector: matchLabels: app: bookstore role: api ingress: - from: - podSelector: matchLabels: app: bookstore</code> </pre> <br><pre> <code class="plaintext hljs">$ kubectl apply -f api-allow.yaml networkpolicy "api-allow" created</code> </pre> <br><p>  <strong>Check</strong> </p><br><p>  Let's make sure that we give access without access to the <code>app=bookstore</code> tag: </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --rm -i -t --image=alpine -- sh / # wget -qO- --timeout=2 http://apiserver wget: download timed out</code> </pre> <br><p>  Traffic is blocked! </p><br><p>  And now let's check that traffic is allowed from the pods labeled <code>app=bookstore</code> : </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --rm -i -t --image=alpine --labels app=bookstore,role=frontend -- sh / # wget -qO- --timeout=2 http://apiserver &lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt;</code> </pre> <br><p>  Traffic is allowed. </p><br><p>  <strong>Cleaning</strong> </p><br><pre> <code class="plaintext hljs">kubectl delete deployment apiserver kubectl delete service apiserver kubectl delete networkpolicy api-allow</code> </pre> <br><h2 id="zapreschenie-deny-vsego-ne-vnesennogo-v-belyy-spisok-trafika-v-tekuschem-prostranstve-imen">  Prohibition (DENY) of all unlisted traffic in the current namespace </h2><br><p>  <strong>Usage scenario</strong> </p><br><p>  This is a very important policy that blocks all traffic between the slots, with the exception of being whitelisted using another policy. </p><br><p>  <code>kube-system</code> applying the appropriate manifest in all namespaces in which the workload is deployed (but not in the <code>kube-system</code> ). </p><br><p>  With this policy, you can configure the "deny all" access type (default "deny all").  Thus, it is possible to clearly determine which components depend on other components, and implement network policies on which to build dependency graphs between components. </p><br><img src="https://habrastorage.org/web/185/6c2/4f7/1856c24f776343f7845ffa2dbc700206.gif"><br><p>  <strong>Manifesto</strong> </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: default-deny-all namespace: default spec: podSelector: matchLabels:</code> </pre> <br><p>  A few notes: </p><br><ul><li>  <code>namespace</code> ‚Äî by default, apply this policy in the <code>default</code> namespace. </li><li>  <code>matchLabels</code> - not filled, it means compliance with all submit.  Thus, the policy will be applied to all subsets in the specified namespace. </li><li>  <code>ingress</code> rules are not defined, so traffic going to selected (all) slots will be rejected. </li></ul><br><p>  Save this manifest to the <code>default-deny-all.yaml</code> and apply the policy: </p><br><pre> <code class="plaintext hljs">$ kubectl apply -f default-deny-all.yaml networkpolicy "default-deny-all" created</code> </pre> <br><p>  <strong>Cleaning</strong> </p><br><pre> <code class="plaintext hljs">kubectl delete networkpolicy default-deny-all</code> </pre> <br><h2 id="zapret-deny-vsego-trafika-iz-drugih-prostranstv-imen">  Ban (DENY) all traffic from other namespaces </h2><br><p>  <strong>(also known as LIMIT - restricting traffic to the current namespace)</strong> </p><br><p>  You can configure network policies to block all traffic from other namespaces, while allowing local traffic within the namespace in which it is located. </p><br><p>  <strong>Usage scenarios</strong> </p><br><ul><li>  You do not want applications from the <code>test</code> namespace to accidentally direct any traffic to services or databases in the <code>prod</code> namespace. </li><li>  You have different client applications in different namespaces, and you want to isolate them from each other. </li></ul><br><img src="https://habrastorage.org/web/d9a/b1a/82c/d9ab1a82c7874515856e951a636ea4ac.gif"><br><p>  <strong>Example</strong> </p><br><p>  Create a new namespace called <code>secondary</code> and start the web service: </p><br><pre> <code class="plaintext hljs">kubectl create namespace secondary kubectl run web --namespace secondary --image=nginx \ --labels=app=web --expose --port 80</code> </pre> <br><p>  Save the following manifest to <code>web-deny-other-namespaces.yaml</code> and apply it to the cluster: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: namespace: secondary name: web-deny-other-namespaces spec: podSelector: matchLabels: ingress: - from: - podSelector: {}</code> </pre> <br><pre> <code class="plaintext hljs">$ kubectl apply web-deny-other-namespaces.yaml networkpolicy "web-deny-other-namespaces" created"</code> </pre> <br><p>  A few notes about the manifest: </p><br><ul><li>  <code>namespace: secondary</code> will cause the manifest to be applied in the <code>secondary</code> namespace; </li><li>  the policy will be applied to all subsets in the <code>secondary</code> namespace, since <code>spec.podSelector.matchLabels</code> does not contain values, thus selecting all subsets; </li><li>  allowed traffic from all subs in the <code>secondary</code> namespace, since <code>spec.ingress.from.podSelector</code> does not contain values, which also means compliance with all subsets. </li></ul><br><p>  <strong>Check</strong> </p><br><p>  Request this web service from the <code>default</code> namespace: </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --namespace=default --rm -i -t --image=alpine -- sh / # wget -qO- --timeout=2 http://web.secondary wget: download timed out</code> </pre> <br><p>  Traffic from the <code>default</code> namespace is blocked! </p><br><p>  At the same time, any user from the <code>secondary</code> namespace will get: </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --namespace=secondary --rm -i -t --image=alpine -- sh / # wget -qO- --timeout=2 http://web.secondary &lt;!DOCTYPE html&gt; &lt;html&gt;</code> </pre> <br><p>  <strong>Cleaning</strong> </p><br><pre> <code class="plaintext hljs">kubectl delete deployment web -n secondary kubectl delete service web -n secondary kubectl delete networkpolicy web-deny-other-namespaces -n secondary kubectl delete namespace secondary</code> </pre> <br><h2 id="razreshenie-allow-lyubogo-trafika-iz-prostranstva-imen">  Allow (ALLOW) of any traffic from the namespace </h2><br><p>  This policy is similar to <a href="">allowing traffic from all namespaces</a> , while it allows you to select a specific namespace. </p><br><p>  <strong>Usage scenarios:</strong> </p><br><ul><li>  Limiting traffic to a production-database in such a way that it is allowed only from namespaces in which production-applications are deployed. </li><li>  Deploy monitoring tools that are allowed to collect the metrics of the current namespace in a specially created separate namespace. </li></ul><br><img src="https://habrastorage.org/web/391/942/9ed/3919429ed3264a3c8f5c7a77894fa71c.gif"><br><p>  <strong>Example</strong> </p><br><p>  Start the web server in the default namespace: </p><br><pre> <code class="plaintext hljs">kubectl run web --image=nginx \ --labels=app=web --expose --port 80</code> </pre> <br><p>  Now suppose you have these namespaces: </p><br><ul><li>  <code>default</code> - created by Kubernetes, your API is deployed here; </li><li>  <code>prod</code> - other production-services are deployed here;  it has the label <code>purpose=prod</code> ; </li><li>  <code>dev</code> is the dev / test environment;  it is labeled <code>purpose=testing</code> . </li></ul><br><p>  Create <code>prod</code> and <code>dev</code> namespaces: </p><br><pre> <code class="plaintext hljs">kubectl create namespace dev kubectl label namespace/dev purpose=testing kubectl create namespace prod kubectl label namespace/prod purpose=production</code> </pre> <br><p>  The following manifest will only allow traffic from pods that are in the namespace with the label <code>purpose=production</code> .  Save it to <code>web-allow-prod.yaml</code> and apply to the cluster: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: web-allow-prod spec: podSelector: matchLabels: app: web ingress: - from: - namespaceSelector: matchLabels: purpose: production</code> </pre> <br><pre> <code class="plaintext hljs">$ kubectl apply -f web-allow-prod.yaml networkpolicy "web-allow-prod" created</code> </pre> <br><p>  <strong>Check</strong> </p><br><p>  Make a request to the web server from the <code>dev</code> namespace, make sure that traffic is blocked: </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --namespace=dev --rm -i -t --image=alpine -- sh If you don't see a command prompt, try pressing enter. / # wget -qO- --timeout=2 http://web.default wget: download timed out ( )</code> </pre> <br><p>  Now make a request from the <code>prod</code> namespace, make sure the request passes: </p><br><pre> <code class="plaintext hljs">$ kubectl run test-$RANDOM --namespace=prod --rm -i -t --image=alpine -- sh If you don't see a command prompt, try pressing enter. / # wget -qO- --timeout=2 http://web.default &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... ( )</code> </pre> <br><p>  <strong>Cleaning</strong> </p><br><pre> <code class="plaintext hljs">kubectl delete networkpolicy web-allow-prod kubectl delete deployment web kubectl delete service web kubectl delete namespace {prod,dev}</code> </pre> <br><h2 id="razreshenie-allow-trafika-ot-vneshnih-klientov">  Allow (ALLOW) traffic from external clients </h2><br><p>  This network policy allows external clients to access the store via a load balancer or directly from the Internet. </p><br><p>  <strong>Usage scenarios:</strong> </p><br><ul><li>  You need to configure access to the feeds directly from the Internet, <a href="">while prohibiting all traffic that is not whitelisted</a> . </li></ul><br><img src="https://habrastorage.org/web/fdb/5a3/ba9/fdb5a3ba9e134280b5b8d14a782a7c24.gif"><br><p>  <strong>Example</strong> </p><br><p>  Launch and open its 80th port for access from the Internet via a load balancer: </p><br><pre> <code class="plaintext hljs">kubectl run web --image=nginx \ --labels=app=web --port 80 kubectl expose deployment/web --type=LoadBalancer</code> </pre> <br><p>  Wait for the EXTERNAL-IP to <code>kubectl get service</code> in the output of the <code>kubectl get service</code> .  Open <code>http://[EXTERNAL-IP]</code> in the browser and make sure that you have access to the resource. </p><br><p>  The following manifest allows traffic from any sources (both within the cluster and from external sources).  Save it to the <code>web-allow-external.yaml</code> file and apply to the cluster: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: web-allow-external spec: podSelector: matchLabels: app: web ingress: - from: []</code> </pre> <br><pre> <code class="plaintext hljs">$ kubectl apply -f web-allow-external.yaml networkpolicy "web-allow-external" created</code> </pre> <br><p>  Open <code>http://[EXTERNAL-IP]</code> in the browser again and make sure it still works. </p><br><p>  <strong>Remarks</strong> </p><br><p>  This manifest defines one ingress-rule for hearths with the tag <code>app=web</code> .  Since specific <code>podSelector</code> or <code>namespaceSelector</code> not specified, traffic from any sources, including external ones, will be transmitted. </p><br><p>  To allow access from the outside only to port 80, use the following ingress-rule: </p><br><pre> <code class="plaintext hljs"> ingress: - ports: - port: 80 from: []</code> </pre> <br><p>  <strong>Cleaning</strong> </p><br><pre> <code class="plaintext hljs">kubectl delete deployment web kubectl delete service web kubectl delete networkpolicy web-allow-external</code> </pre> <br><h2 id="kak-primenyayutsya-setevye-politiki">  How network policies are applied </h2><br><p>  Network policies are not basic Kubernetes functionality.  And although you can send a NetworkPolicy object to the Kubernetes wizard, the policy will not work if the corresponding functionality is not implemented in the network plugin. </p><br><p>  Examples of network plugins that support network policies can be found <a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/">on this page</a> .  Network policies are also supported by <a href="https://kubernetes.io/docs/tasks/administer-cluster/calico-network-policy/">Calico</a> and <a href="https://kubernetes.io/docs/tasks/administer-cluster/weave-network-policy/">Weave Net</a> plugins. </p><br><p>  In <a href="https://cloud.google.com/container-engine">Google Container Engine (GKE)</a> network policy support is implemented in the initial stage (alpha) by pre-installing the Calico network plugin. </p><br><p>  <strong>Network policies are applied to connections, not network packets.</strong>  Note that connections imply bidirectional transfer of network packets.  For example, if under A can connect to hearth B, under B can respond hearth A within the current connection.  However, this does not mean that under B can initiate a connection with the hearth A. </p><br><h2 id="anatomiya-networkpolicy">  Anatomy of NetworkPolicy </h2><br><p>  NetworkPolicy is one of the Kubernetes API objects.  Many such objects can be created in a cluster.  NetworkPolicy has two main components: </p><br><ol><li>  <strong>Targeted pods</strong> are pods whose ingress network connections should be subject to the appropriate policies.  These pods are selected by tags. </li><li>  <strong>Incoming rules</strong> determine which plots can connect to target plots.  They are also selected by label or by namespace. </li></ol><br><p>  Here is a concrete example of the NetworkPolicy manifest: </p><br><pre> <code class="plaintext hljs">kind: NetworkPolicy apiVersion: networking.k8s.io/v1 metadata: name: api-allow spec: podSelector: matchLabels: app: bookstore role: api ingress: - from: - podSelector: matchLabels: app: bookstore - from: - podSelector: matchLabels: app: inventory</code> </pre> <br><p>  In this policy, with tags <code>app=bookstore</code> or <code>app=inventory</code> , you are allowed to connect to sites with tags <code>app=bookstore</code> or <code>role=api</code> .  It can be voiced in the following way: "Provide bookstore applications with access to the bookstore API to microservices." </p><br><h2 id="kak-rabotayut-setevye-politiki">  How network policies work </h2><br><p>  Despite the fact that <a href="">project documentation</a> and network policy <a href="https://kubernetes.io/docs/api-reference/v1.7/">API help</a> are very difficult to understand, I managed to highlight a few simple rules: </p><br><ul><li>  If selected under NetworkPolicy, the traffic intended for this will be limited. </li><li>  If the pod does not have a NetworkPolicy object defined, all pods from all namespaces can connect to this pod.  That is, if the network policy is not defined for a specific pod, the default is implicitly implying the behavior of ‚Äúallow all‚Äù. </li><li>  If traffic to A is limited and B must connect to it, you need to create a NetworkPolicy object, which is selected under A, and there is an ingress rule in which it is selected under B. </li></ul><br><p>  The matter becomes more complicated when it is necessary to configure the network interaction between different namespaces.  In a nutshell, it works like this: </p><br><ul><li>  Network policies only affect network connections for those subnets that are in the same namespace with NetworkPolicy. </li><li>  In the ingress-rule <code>podSelector</code> you can select only pods from the same namespace in which the NetworkPolicy object is deployed. </li><li>  If hearth A needs to connect to a hearth B in a different namespace and network connections to hearth B are limited by network policy, under A must be selected in the <code>namespaceSelector</code> field of the network policy under fire B. </li></ul><br><h2 id="naskolko-bezopasny-setevye-politiki">  How safe are network policies? </h2><br><p>  Network policies restrict network communication between the sub and are an important part of ensuring traffic and application security in the Kubernetes cluster.  However, unlike firewalls, deep packet inspection is not performed within network policies. </p><br><p>  In order to ensure the security of traffic between the sub-clusters in the cluster, you should not rely only on network policies.  I also recommend looking at such methods as TLS (transport layer security) with mutual authentication, which allows you to encrypt traffic and perform authentication when interacting with microservices. </p><br><p>  Take a look at <a href="https://cloud.google.com/security/whitepaper">Google Cloud Security Whitepaper</a> (highlighted by me): </p><br><blockquote>  Defense in depth describes the many layers of the security system that protects the Google network from outside attacks.  Passage is allowed only to authorized services and protocols that meet our security requirements.  Everything else is discarded automatically.  <strong>Industrial-grade firewalls and access control lists (ACLs) are used to separate networks.</strong>  All traffic is directed through specially configured GFE servers (Google Front End), which allows you to detect and stop malicious requests and DDoS attacks.  Also GFE-servers are allowed to interact only with internal servers that are in a special list.  <strong>Such a ‚Äúdefault by default‚Äù policy allows preventing access from GFE servers to those resources that they do not need.</strong>  <strong>[...]</strong> <br><br>  When transmitted over the Internet and internal networks, data becomes vulnerable and unauthorized access can be made to them.  [...] The Google Front End (GFE) servers support <strong>strong encryption protocols such as TLS</strong> , which allows you to secure connections between client devices and Google web services. </blockquote><p>  The projects mentioned earlier by me related to service grids (service mesh), such as <a href="https://istio.io/">Istio</a> and <a href="https://linkerd.io/">linkerd</a> , promise qualitative improvements in this area.  For example, Istio can encrypt traffic between microservices using TLS and apply network policies transparently, without the need to change the application code. </p><br><h2 id="dopolnitelnaya-informaciya">  Additional Information </h2><br><p>  If you want to try network policies in action, the easiest place to start is to <a href="">create a GKE cluster</a> .  You can also read the following: </p><br><ul><li>  <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Network policy documentation</a> ; </li><li>  <a href="">Network Policy Design document</a> - the purpose of network policy functionality is described here, but their implementation is not reflected in sufficient detail; </li><li>  <a href="https://kubernetes.io/docs/api-reference/v1.7/">Network Policy API reference</a> ; </li><li>  <a href="http://blog.kubernetes.io/2016/09/high-performance-network-policies-kubernetes.html">NetworkPolicy benchmark</a> from Romana network plugin. </li></ul><br><hr><br><p>  Thanks to Matthew DeLio and Daniel Nardo for checking drafts of this article. </p><br><p>  References: </p><br><ol><li>  Original: <a href="https://ahmet.im/blog/kubernetes-network-policy/%3Fimm_mid%3D0f591b%26cmp%3Dem-webops-na-na-newsltr_20170818">Securing Kubernetes Cluster Networking</a> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337088/">https://habr.com/ru/post/337088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337078/index.html">Using Graphviz for flowcharts</a></li>
<li><a href="../337080/index.html">Our rake when starting Calltouch Predict: 365 days of speech recognition and machine learning</a></li>
<li><a href="../337082/index.html">Practical use of the blockchain as a distributed data warehouse</a></li>
<li><a href="../337084/index.html">Methods for detecting "glued" files</a></li>
<li><a href="../337086/index.html">Corporate communication in Telegram. Migration from WhatsApp at full speed</a></li>
<li><a href="../337092/index.html">Artificial intelligence will save from ransomware</a></li>
<li><a href="../337094/index.html">4 ICO IT startups in September: sale of excess communications, parallel Internet and awards to open-source developers</a></li>
<li><a href="../337096/index.html">Sending an e-mail message in the 3CX Call Flow Designer development environment</a></li>
<li><a href="../337098/index.html">Creator of Node.js: ‚ÄúFor servers, I can‚Äôt imagine another language other than Go‚Äù</a></li>
<li><a href="../337100/index.html">Be careful with what you measure - MJIT vs TruffleRuby: 2.1 times slower or 4.2 times faster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>