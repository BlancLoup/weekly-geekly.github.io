<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wireless thermometer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... on ultra-cheap radio modules for $ 5 per bundle . 

 The kit contains a radio transmitter and superregenerative receiver. The number of contacts, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wireless thermometer</h1><div class="post__text post__text-html js-mediator-article">  ... on ultra-cheap radio modules for <a href="http://www.ebay.com/itm/290935235157">$ 5 per bundle</a> . <br><img src="https://habrastorage.org/getpro/habr/post_images/839/78c/65e/83978c65e3de8688afc39deef603928d.jpg"><br>  The kit contains a radio transmitter and superregenerative receiver.  The number of contacts, in fact, 3 each, two of which are powered, hints at the extreme simplicity of working with them.  True, the kit is more focused on remote control and is more often used in tandem with encoders and decoders on specialized chips, but we will miss it, because  your bike is always more expensive. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d2e/21f/0a4/d2e21f0a40aa15f885ea9ceadd7f6114.gif" align="right"><br>  Transmitter with amplitude modulation at a frequency of 433 MHz, the frequency is stabilized by SAW.  The transmitter is a close relative of all one-, two-, three-transistor bugs and beacons, which made everyone who has ever been involved in radio engineering (a lot of circuits on <a href="http://vrtp.ru/index.php%3Fact%3Dcategories%26cat%3D1">vrtp.ru</a> ).  Power to the transmitter is allowed up to 12 V. Input data actually opens the transistor and starts the generation, with a low input level, the generation stops.  Respectively exposing Hi and Lo at the input with a certain frequency, we can transfer data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/910/c61/3d9/910c613d9c421deae57f2a8ab27a3c0b.jpg"><br><br>  The receiver belongs to the class superregenerative.  Today, this scheme is almost completely out of use and replaced by superheterodyne, but decades ago even industrial receivers were released to listen to the radio. <br>  Supergenerate is the further development of a direct gain receiver.  In the input circuit, due to positive feedback in the discontinuous mode, at frequencies of tens of kHz, the energy of the power source is introduced in the form of oscillations of the same frequency to which the circuit is tuned.  This compensates for losses in the circuit and improves its Q-factor.  At the output of the radio module there is a comparator issuing Data Hi or Lo to the line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/72c/f5e/cce/72cf5eccec4ee7b45d9de41a43568a54.gif"><br>  Advantages of superregenerative receivers: <br><ul><li>  Simplicity and low cost designs </li><li>  Very high sensitivity </li><li>  High bandwidth </li><li>  Automatic gain control </li></ul><br>  The disadvantages arising from the advantages: <br><ul><li>  Wide bandwidth, which always gets something.  The value of the order of units is MHz. </li><li>  High sensitivity, even though the transmitter is on, even off, there is always some noise at the receiver output (see below). </li><li>  The difficulty in setting up, because  the superregenerative cascade simultaneously performs two or three functions (amplifier, generator, detector).  But we already have nothing to set up. </li></ul><br><br>  On both modules left a hole under the antenna.  After the adjacent modules were finally separated, I realized that without an antenna there was nothing to do and I attached crocodiles with wires to the modules as antennas.  In this form, the range of the collected devices was over 10 meters in a straight line when the transmitter was powered from the Krone 9V.  I remind you that a piece of wire equal to approximately ¬º or ¬Ω wavelength can be used as an antenna, in our case it will be 17 or 34 cm. It‚Äôs better to connect the common wire (GND) to the counterweight, which could be a metal case or another piece wires directed in the opposite direction from the antenna. <br><br>  This picture is when you remove the transmitter by 10 meters.  Despite the fact that the signal power is visually greatly reduced, the receiving module receives data confidently. <br><img src="https://habrastorage.org/getpro/habr/post_images/ccd/b43/e10/ccdb43e10b368fc8b77cbe66a956609e.jpg"><br><br>  Now directly to the transfer of data.  How naive I was when I connected the transmitter to the UART on one controller, and to the UART on the other.  I saw a transmitted byte, although it was surrounded by dozens of extra!  Look at the following picture, the receiver always catches something.  And only when there is a steady periodic (!) Signal, it is clearly manifested in all incoming garbage.  The UART transmits data one bit at a time, without dividing each bit, if 0x00 is transmitted, it will be a low level during the entire transfer of a byte, i.e.  the transmitter will simply be turned off, and if 0xff is transmitted, this will be a high level, but even so, the receiver will soon begin to see discontinuities in it and give out a random sequence. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/3a7/257/ea93a7257deaaaf3285f1c49985ef360.gif"><br><br>  Those.  I turn on the transmitter, soot the power data line, the transmitter broadcasts the carrier at full power, and at the receiver I see several units, and then garbage 11111111110100100101001. I release the data line, zeros appear and again 00000000011010101010. Conclusion: the receiver needs periodic level drops. <br><br>  And we have this code.  Mancunian.  In the Manchester code, bits are encoded by a differential from a low level up (let it be 1), or from a top down (let it be 0).  Accordingly, before the start of the transmission of each bit, the level should be set to the initial position, and in the middle should be changed.  It has been experimentally found that the optimal data transfer rate is about 5-10-20 kilobits per second.  This will allow to achieve a sufficiently stable reception, and will be used in the prototype of the device, which I will begin to describe further. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c50/70d/b08/c5070db081db6f6cf6090135c5901bbf.gif"><br><br>  Traditionally it will be a thermometer, but now with wireless data transmission.  According to the condition of the task on the bed under the film lies the transmitter, and in the house there is a receiver, which, as it were, collects the data from the sensors, well from one sensor, and builds a histogram.  Those.  if I see that at night there was 0 degrees, I understand from what all the seedlings are frozen and it remains only to find the culprit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/ef3/542/a25ef354267b2197bfe4286ceeafdb13.jpg"><br><br>  The transmitter is assembled on the controller Attiny13, with a thermal sensor LM335.  Analog thermal sensor, gives 100mV to 1K.  The reference voltage source MK uses an internal 1.1V.  Since  values ‚Äã‚Äãfrom the sensor over 3V, then the data on the ADC is transmitted through a divider.  The controller wakes up once every 30 minutes, and in debugging mode once every 4 seconds, it supplies power to the thermal sensor, turns on the transmitter, and for about 1-2 seconds transmits the current temperature a thousand times.  Yes!  It is a thousand times in a row, because  even with 100 transmissions in a row, I skipped the data in some sessions.  Modern cities, with dozens of automotive signaling at 433 MHz is not the most peaceful place. <br>  The temperature is transmitted as a single byte with a Manchester coding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a61/ec6/e54/a61ec6e541da9125cd2595e99d483396.gif"><br><br>  0b10101011 on the receiver side turn into 21 ¬∞ . <br><br><div class="spoiler">  <b class="spoiler_title">Transfer bytes</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PORT_TX&amp;=~B_TX; _delay_us(DELAY_US); PORT_TX|=B_TX; _delay_us(DELAY_US); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PORT_TX|=B_TX; _delay_us(DELAY_US); PORT_TX&amp;=~B_TX; _delay_us(DELAY_US); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ send1(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i=<span class="hljs-number"><span class="hljs-number">128</span></span>; i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; i&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c &amp; i) send1(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> send0(); } PORT_TX&amp;=~B_TX; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Falling asleep after data transfer until interrupt from watchdog timer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(debug_mode) { cli(); wdt_reset(); WDTCR=<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDCE | <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDTIE; WDTCR=<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDP3 | <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDTIE; <span class="hljs-comment"><span class="hljs-comment">// 4  sei(); MCUCR|=1&lt;&lt;SE | 1&lt;&lt;SM1; //   Power-down sleep_cpu(); } else for(uint8_t i=0; i&lt;SLEEP_TIME; i++) { cli(); wdt_reset(); WDTCR=1&lt;&lt;WDCE | 1&lt;&lt;WDTIE; WDTCR=1&lt;&lt;WDP3 | 1&lt;&lt;WDP0 | 1&lt;&lt;WDTIE; // 8  sei(); MCUCR|=1&lt;&lt;SE | 1&lt;&lt;SM1; sleep_cpu(); }</span></span></code> </pre><br></div></div><br><br>  Power is supplied through the same Krona 9V, measured by the Chinese tester in active mode consumption 6mA, in sleep mode 0,2mA.  I can not pay attention to the voltage regulator circuit.  The controller from 9V will simply die, and 5V or less will be small for the transmitter, so a power converter was needed.  Boost pulse, perhaps I would interfere, and I did not experiment with it.  It was easier to put a lowering linear, like the classic 7805. But suddenly I saw that she had her own consumption of 6 mA.  This means that while the controller is sleeping, she will eat the entire battery.  Googling, I found low-consuming converters LP2950, ‚Äã‚ÄãMCP1700‚Ä¶.  But there weren't any nearby, but here <a href="http://pro-radio.ru/power/7080-2/">such a circuit</a> turned up on a pair of transistors 7002. Resistors had to be reduced not even to mega, but to hundreds of kilo, otherwise the output voltage did not rise above 3 with a small volt.  Now it has become approximately 4.6V, which is quite comfortable for the controller. <br><br><div class="spoiler">  <b class="spoiler_title">The scheme of the transmitter, how not to do!</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/ea1/e07/5d0ea1e07e2c12885e9e677de229acb3.gif"></div></div><br><br>  The receiver is assembled on the basis of Attiny85 with a display from the Nokia 5110. The top line is reserved for the display of the current temperature, the bottom one shows the highest and the lowest.  The central area 84x32 displays a histogram from 0 to 32C.  Anything above or below is simply clipped. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/c1d/77d/117c1d77d0f99fae7cf51785c34bb9fe.jpg"><br><br>  Reception is ongoing.  When switching to the receive line from Lo to Hi, an attempt is made to receive 8 data bits.  In the original version, the reception of bits looked like this:  The first transition from Lo to Hi is the middle of start bit 1, then the time is measured from it a little less than the bit duration, the value at the input is fixed, and a little later, when the time of the second half of the bit arrives, the value at the port is fixed again.  This determines the transition to the upper or lower level.  Further it is clear that it worked badly. <br><br><div class="spoiler">  <b class="spoiler_title">Receiver circuit</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/a00/78a/8d7a0078a95be5e787589b6170f93da4.gif"></div></div><br><br>  For screening garbage, I expect three parcels in a row, and if they match, then this will be the current temperature.  At the same time, it is displayed for 0.5 sec.  reception indicator is displayed.  Once every 15 minutes, the histogram shifts, and if no new temperature is received within 45 minutes, the current temperature indication goes out, and the histogram will continue to move with an empty column.  If the char in the GCC settings were not unsigned, then everything would have worked from half a kick, but strange glitches would peck out my brain until the night.  And in the morning turning on the receiver, with the transmitter turned off, within half an hour I caught the noise, getting -91 degrees. <br>  Then I did not lose my head and made an expectation of four parcels in a row.  And I caught a false package again within half an hour.  I did wait for two consecutive bytes and confirm their CRC8.  And after an hour again I caught the false temperature, all according to the theorem on infinite monkeys. <br>  ‚ÄúHalf a dozen monkeys, if they had typewriters and one or other eternity in reserve, will create all the books that are kept today in the British Museum‚Äù <br>  And, finally, having returned to the triple premise, but having changed the algorithm for receiving individual bits, I sort of calmed down, although I understand that the monkeys are not asleep. <br><br>  In the modified algorithm, when each bit is received, several intermediate readings of the port are made, and if there is an untimely level transition, the reception is interrupted. <br><br><div class="spoiler">  <b class="spoiler_title">It was</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> read_bit() { _delay_us(<span class="hljs-number"><span class="hljs-number">160</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    char rx=PIN_RX &amp; B_RX; //     for(uint8_t i=0; i&lt;6; i++) { if((PIN_RX &amp; B_RX) != rx) { if(rx) return 0; else return 1; } } return -1; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">It became</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> read_bit() { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rx=PIN_RX &amp; B_RX; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((PIN_RX &amp; B_RX) != rx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   } _delay_us(40); //        rx=PIN_RX &amp; B_RX; for(uint8_t i=0; i&lt;5; i++) { if((PIN_RX &amp; B_RX) != rx) return -1; //   } rx=PIN_RX &amp; B_RX; for(uint8_t i=0; i&lt;6; i++) //       { if((PIN_RX &amp; B_RX) != rx) { if(rx) return 0; else return 1; } } return -1; }</span></span></code> </pre><br></div></div><br><br>  Despite the fact that these radio modules are hardly suitable for serious use as data transfer modules, but for collecting statistics, with the subsequent processing and rejection of obviously inaccurate data, it is quite. <br><br>  Since  the devices are only a demonstration function, then I deliberately do not spread the printed circuit boards, the more they should be repackaged to fix bugs. <br>  The original krivoruky C-code and hex files in the <a href="https://drive.google.com/file/d/0B5EawOBij9PRN1FuNFJ2YUpzLVU/edit%3Fusp%3Dsharing">archive</a> .  Fuse bits by default. </div><p>Source: <a href="https://habr.com/ru/post/224459/">https://habr.com/ru/post/224459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224447/index.html">The future of scripts in unity 3d</a></li>
<li><a href="../224449/index.html">Doing Smart Point or ‚ÄúInternet thing‚Äù with your own hands</a></li>
<li><a href="../224451/index.html">How much is the apple market today?</a></li>
<li><a href="../224453/index.html">Anatoly Wasserman: about the future, intelligence and socialism</a></li>
<li><a href="../224455/index.html">A simple way to make plain text marketing</a></li>
<li><a href="../224461/index.html">A / B testing errors in AirBnB</a></li>
<li><a href="../224463/index.html">Nokia X News Digest: Russian sales of Nokia XL and webinar recordings for developers</a></li>
<li><a href="../224465/index.html">Neurobiological project Rybka Project</a></li>
<li><a href="../224467/index.html">Debug email with MailCatcher</a></li>
<li><a href="../224469/index.html">New in the release of Kerio Connect 8.3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>