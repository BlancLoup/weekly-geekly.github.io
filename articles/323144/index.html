<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build a cache with efficient multithreaded access</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Pasha Matlashov. I am the Director of Game Server Development Department in the Plarium gaming company. 

 Today, using our projects...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build a cache with efficient multithreaded access</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c96/cd1/92d/c96cd192de26426aa917247d4c539bf6.jpg"><br><br>  Hello!  My name is Pasha Matlashov.  I am the Director of Game Server Development Department in the Plarium gaming company. <br><br>  Today, using our projects as an example, I will talk about caching features, pitfalls, and how to get around them. <br><a name="habracut"></a><br><h2>  Prerequisites </h2><br>  Our servers process 8500 requests per second and store information about 200 million users.  To provide effective linear scaling, we apply user segmentation (it‚Äôs also sharding).  The process of distributing new users follows a simple balancing rule: the new user falls into the least ‚Äúpopulated‚Äù segment.  Such segmentation is static, which provides ease of development.  Additionally, to simplify the architecture, there is a rule: user data can be edited only on the segment on which it is stored.  This allows you to not worry about issues such as distributed locks and transactions.  Within the server, the user is called a gaming entity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Data lock </h2><br>  To regulate the flow and correct data editing, you can go on the principle of optimistic or pessimistic blocking. <br><br>  Using optimistic locking does not guarantee that by the end of the transaction, parallel entities / threads / queries will not change the data.  To minimize the number of data reads before editing, we remember the version of the game entity.  When the changed data is saved to the database, we additionally save the value of the old version. <br><br>  In this approach, there is a minus: there may be situations where the game entity will have to be re-read due to the large amount of interaction. <br><br>  Imagine that a user buys a building and a battle is fired at the same time.  Both of these events change the game essence.  It may happen that the result of the battle will be calculated at the time of applying the building purchase logic.  The data is stored in the database, changing the user revision.  We need to throw away a huge array of data.  Additionally, you need to take into account that the preservation of the game entity in the database includes the stage of serialization and data compression.  As a result, the data is sent to the database, but the revision does not match.  You need to get the entity from the database again, reproduce the transaction logic, serialize, compress the data, try again to fix the version of the data in the hope that nothing changes.  This approach complicates the code and consumes extra resources. <br><br>  We went on the principle of pessimistic blocking.  Before any action, data is locked - this guarantees the sole editing process. <br><br><h2>  Choosing a place to lock data </h2><br>  Continuing to go to the database where data is stored is long and resource-expensive.  It is easier to lock in the memory of the workflow than in the database.  But you need to comply with certain guarantees: <br><br><ul><li>  All methods follow user data only to the server. </li><li>  Developers ensure that data is edited only on the segment where the user is stored. </li><li>  Only one copy of the user should be in memory. </li></ul><br>  As a result, we come to the user cache, which improves the efficiency of working with data.  The cache keeps track of the uniqueness of a copy of each entity and provides a blocking location.  In such a scenario, the cache works on the write-through principle. <br><br>  The work of the cache with game entities can be described in stages: <br><br><ul><li>  Subtract the user from the database to the cache. </li><li>  Getting exclusive access to data by blocking. </li><li>  Editing a user in the cache. </li><li>  Save user to database.  Current user data remains in the cache. </li></ul><br>  ‚ÄúBut what if you put the cache in another process, for example, in Memcached?‚Äù You will say :) In this situation, you need to take into account that there will be additional costs for serialization and deserialization when interacting with the external cache and transferring it over the network. <br><br>  In the case of multithreading and a large number of processes, theoretically, a situation may arise in which a copy of the user will exist in parallel in two cache processes.  This phenomenon is caused by an interesting feature of ASP.NET.  When the assembly changes in the deployed site, for a while there are 2 instances of the site: the first modifies the old code and the old requests, and the second creates a new process for the new requests with a new memory.  Technically, the game entity from the new site can load before all the processes on the old one are completed.  Each copy of the site believes that only it has these game entities, which is why data loss occurs. <br><br>  <i>We encountered such a problem when rebooting and pouring out a new version of the server.</i>  <i>Standardly at 2‚Äì3 users "were lost" troops.</i>  <i>To resolve this issue, we have banned the simultaneous launch of two applications at the code level.</i> <br><br>  To avoid deadlock threads, we follow a number of rules: <br><br><ul><li>  Lock take indicating timeout. </li><li>  Do not take more than one lock at a time. </li><li>  Change of several entities through the exchange of messages in the queue. </li></ul><br><h2>  First decision </h2><br>  The first thing that comes to mind for organizing work with the cache is to use a Dictionary of the form &lt;Id, User&gt;.  But such a decision has a minus.  Dictionary is well suited for single-threaded applications.  In a multithreaded environment, it becomes non-thread-safe and requires additional protection. <br><br>  Dictionary protection can be implemented through a single exclusive lock, under which the presence of the desired user in the collection is checked.  If there is no user, the game entity is loaded and returned to the calling code.  To ensure sequential access, the called code will be blocked on the user.  To optimize a little, you can use ReaderWriterLock (or any other variant on the same topic). <br><br>  But everything is complicated by the fact that any cache sooner or later reaches the threshold size and requires data crowding out.  What will happen in this case? <br><br>  We will model the situation in accordance with the above decision.  The cache contains a gaming entity.  A request came, took the game entity into the context of the lock, and started editing it.  In parallel, there is a displacement of the game entity from the cache - for example, the flow of crowding out has managed to designate this data as old in use.  At this time, another request comes to the game entity, but it is no longer in the cache.  The request reads the data from the database, puts in the cache, takes the context and also starts editing.  As a result, we get two copies of the game entity, and this violates our own guarantee of uniqueness (Figure 1).  Data is lost, and lucky that request, which will save the gaming entity last. <br><br><img src="https://habrastorage.org/files/061/255/b76/061255b763c64cde8d9d4acc5cf11ddb.png"><br>  <i>Picture 1</i> <br><br>  Obviously, you need to reckon with the stream that is already editing the game entity.  It is possible to block all entities that should be repressed, but this is labor-intensive and inefficient.  If, for example, 20,000 game entities are cached and 10% of them need to be supplanted, 2000 locks will occur.  Additionally, if some locks are busy, you will have to wait for them to be released. <br><br><h2>  Pin and UnPin operations </h2><br>  We decided to implement Pin and UnPin operations.  Instead of storing an entity as a value in a Dictionary, we store a certain CacheItem, which indicates a lock on the game entity, the entity itself, and a usage count.  The counter is used to regulate access during preemption.  When a context is created, the counter value is increased by using Interlocked operation on the CacheItem (Pin operation), when the context is released, it is decreased (UnPin operation).  We added the Shrink operation, which displaces objects with a zero value of the counter by the date of the last use.  A global blocking of the entire Dictionary is used without an entry for the individual blocking of each entity.  Pin is executed in the context of the same lock to preserve the atomicity of receiving and blocking the entity. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// User Cache private readonly object _lock = new object(); private Dictionary&lt;long, UserCacheItem&lt;TUser&gt;&gt; _dict = new Dictionary&lt;long, UserCacheItem&lt;TUser&gt;&gt;(); public bool TryGet(long userId, out UserCacheItem&lt;TUser&gt; userCacheItem, bool pinCacheItem) { lock(_lock) { if (!_dict.TryGetValue(userId, out userCacheItem)) return false; userCacheItem.UpdateLastAccessTime(); if (pinCacheItem) userCacheItem.PinInCache(); return true; } }</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Shrink private void ShrinkOldest(int shrinkNumber) // shrinkNumber - quantity CacheItem superseded. { lock(_lock) { var orderedByAccess = _dict.OrderBy(pair =&gt; pair.Value.LastAccessTime).Where(pair =&gt; !pair.Value.IsPinnedInCache()); int i = 0; foreach (var pair in orderedByAccess) { i++; if (i &gt; shrinkNumber) break; _dict.Remove(pair.Key); } } }</span></span></code> </pre><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UserCacheItem public class UserCacheItem&lt;TUser&gt; where TUser : class, IUser, new() { private int _pinnedInCache; // _pinnedInCache prevents deletion of data from the Cache on Shrink public object Locker = new object(); // userCacheItem blocked before user editing public long UserId; public TUser User; public DateTime LastAccessTime; public UserCacheItem(TUser user) { UserId = user.Id; User = user; UpdateLastAccessTime(); } public void UpdateLastAccessTime() { LastAccessTime = DateTime.UtcNow; } public void PinInCache() { Interlocked.Increment(ref _pinnedInCache); } public void UnpinInCache() { Interlocked.Decrement(ref _pinnedInCache); } public bool IsPinnedInCache() { return _pinnedInCache != 0; } }</span></span></code> </pre><br>  It seems to be all beautiful and very effective, but there are drawbacks.  First, the global blocking of the entire Dictionary in terms of resource protection is very large - it protects too much data.  This is comparable to a huge library and one old grandmother, who in turn gives everyone books.  Until Shrink is complete, no one can take context.  Secondly, there remains a high competition of threads for execution in the device of Lock itself. <br><br>  Classic synchronization tools on Windows or Linux to lock or release locks require entering kernel mode.  For blocking in Mutex, for example, even if it is free, you need plus or minus 1000 processor cycles.  At one time, optimizations were created for this process (for example, CRITICAL_SECTION in native applications, Monitor in .NET).  Initially, an attempt is made to take a lock with a single Interlocked.CompareExchange operation, if it is free.  If it is busy, it is assumed that the lock is released soon, and SpinWait occurs.  Only after the expiration of the maximum number of spins begins waiting for the flow to block.  This is very profitable: either there will be no competition, or because of the short blocking time, extra processor clock cycles will not be spent on switching to kernel mode. <br><br>  This is an excellent optimization in time and processor resources, but theoretically it is possible to choose a degree of competition for blocking, which, due to SpinWait operations, will lead to excessive or explosive consumption of the processor.  Let me explain exactly how this can happen: the request detects that Lock is currently busy, and decides to spend, for example, 32 cycles on SpinWait.  After repeated unsuccessful attempts, he decides to go to sleep.  In such a competition, each Lock will spend extra cycles on Spin in quite a large amount.  We have one exclusive lock for the entire segment, through which all requests must pass.  In the worst case, this can lead to a critical mass of competition, which will load the processor by 100%. <br><br>  Six months ago, Microsoft fixed this bug for us in the implementation of ASP.NET, and recently we again found a similar one. <br><br>  When we were busy with the new version of the cache, a problem arose: during the period of average CPU utilization (about 50‚Äì60%), consumption could sharply increase to 100%.  This anomalous surge was not associated with an increase in the number of requests over the network or a sharp influx of new users ‚Äî the server worked at a normal pace. <br><br>  In .NET there are lots of unique and useful performance counters.  One of them with the help of the Monitor class shows how much competition is taking place per second - that is, how many collisions there were on classic locks.  With a typical CPU consumption, the collision was an average of 70 per second.  At the time of 100 percent loading - 500-600.  But the most interesting thing is that the coverage rate of our code with an average load was 90‚Äì92%, and at the time of loading the rate dropped to 17%.  Our code literally squeezed something else. <br><br>  What we found: in ASP.NET, there is a closed type BufferAllocator and several derivatives of it.  Inside this type there is a pool that allows you to reuse already allocated buffers to reduce the number of objects created.  It is implemented very simply: Stack, which is protected by a single lock.  The problem was that one application accounted for only one copy of each given type.  In fact, we received several global locks that took all requests, albeit for a short time. <br><br>  After a long review, Microsoft fixed its bug - the number of such allocators was increased to one for each HttpApplication instance.  This significantly reduced the number of competitions for blocking and saved us from the anomaly for several months. <br><br>  Recently, again, there was a problem of sudden and long consumption of 100% of the processor.  Already knowing what to look for, we found a bug very close - in the HttpApplicationFactory type, which buffers the HttpApplication instances in the Stack, blocking on each request. <br><br>  An application with such a bug is considered from several months to six months.  We have developed a mechanism that affectionately call the "handbrake".  Its essence is simple: the server monitors the CPU utilization and the state of high load on the server.  If the state persists for three minutes, we slow down all incoming requests for a short, random period of time, disrupting the chain reaction. <br><br>  As a result, the peaks became short-lived and invisible to users. <br><br><h2>  Search for new solutions </h2><br>  Lock acted as a bottleneck of the entire server.  It is as if the whole city had one road with one traffic light.  We wanted to increase the number of locks in order to reduce the number of competitions.  After all, if we increase the number of roads and traffic lights to 10, there will be no less cars, but traffic will be faster. <br><br>  We found a great ConcurrentDictionary class in .NET.  It has locks and baskets, the number of which is equal to the product of the existing processors by 4. The class is implemented as a low lock and allows you to modify yourself from several threads in parallel.  If 2 objects go to 2 baskets, they can be locked at the same time, if they are in one - they just wait in the queue.  This class is blocked only on addition, subtraction occurs without locks. <br><br><h2>  Operation evict </h2><br>  When we used Dictionary and Lock, Pin went inside Lock.  With ConcurrentDictionary, data retrieval and Pin have become two non-atomic operations.  Imagine that we have an Item that lies in the ConcurrentDictionary.  We take the context of the gaming entity without blocking and set Pin, but at the same time Shrink comes in, displaces the gaming entity and performs Remove.  It turns out a clear race. <br><br>  You can avoid this situation by simply putting another Lock on Pin, but it will look very ugly.  It‚Äôs as if the supermarket had 20 cash desks, you paid for one of them, but you still have to go through an extra one so that you can re-pierce the goods for verification with a check. <br><br>  We came up with a banal simple idea.  We wrote the Evict operation, which sets the pin count to a deliberately incorrect value of ‚àí1, using the usual Interlocked.CompareExchange operation, if the original value is 0. <br><br>  Let's return to the situation described above, but already taking into account Evict.  There is an Item that lies in ConcurrentDictionary.  At the same time comes a request to change the game entity and its replacement.  If Evict managed to set the value to ‚àí1, Shrink realizes that now this entity is not occupied by anyone and will not be taken later.  Pin at this time pretends that there is no object, and tries to go back to ConcurrentDictionary.  If Evict didn‚Äôt have time to change the value, Shrink realizes that the game entity has grabbed Pin first, and doesn‚Äôt touch anything. <br><br>  In a situation where a Pin with a value of 0 wants to simultaneously take 2 processes, we say that 2 Items can be pinned more than once (Pin will take the value 2).  Lock at the same time there will be only one.  The value will be set to 2. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PinInCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldCounter; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { oldCounter = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pinnedInCache; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldCounter &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Interlocked.CompareExchange(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pinnedInCache, oldCounter + <span class="hljs-number"><span class="hljs-number">1</span></span>, oldCounter) != oldCounter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnpinInCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pinnedInCache); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvictFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Interlocked.CompareExchange(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pinnedInCache, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UserCache public bool TryGet(long userId, out UserCacheItem&lt;TUser&gt; userCacheItem, bool pinCacheItem) { if (!_dict.TryGetValue(userId, out userCacheItem)) return false; userCacheItem.UpdateLastAccessTime(); // Return true if item was found. No need to pin or item was evicted. return !pinCacheItem || userCacheItem.PinInCache(); } private void ShrinkOldest(int shrinkNumber) { // Get N oldest elements. Evict the oldest elements from the Cache if possible // Make additional Select call to prevent detecting sequence in LINQ as ICollection in Buffer class and prevent using CopyTo method var orderedByAccess = _dict.Select(kvp =&gt; kvp).OrderBy(pair =&gt; pair.Value.LastAccessTime); UserCacheItem&lt;TUser&gt; dummy; int i = 0; foreach (var pair in orderedByAccess) { if (pair.Value.EvictFromCache()) { _dict.TryRemove(pair.Key, out dummy); if (++i &gt;= shrinkNumber) return; } } }</span></span></code> </pre><br>  As a result, we have highly efficient synchronization on Interlocked operations.  Thanks to Evict, we got a good reduction in competitions, and the pin point and Evict counter became the synchronization point for crowding out the gaming entity. <br><br>  The rest of the caches, which do not require the support of such operations for editing and serve only to improve the efficiency of reading data, we also rewrote to use ConcurrentDictionary. <br><br>  This approach gave a good additional effect: reduced the server load by 7%.  During periods of non-critical due to a bug in ASP.NET, we have from 0 to 2 competitions per second and up to 10 in a short period after a complete garbage collection. <br><br><h2>  KeyLockManager and LockManager </h2><br>  We have developed for ourselves an interesting and quite effective tactic of work in a multi-threaded environment for editing objects.  KeyLockManager essentially contains the same ideas as ConcurrentDictionary, Pin, UnPin.  But in itself does not store any data, and allows you to synchronize streams by key value. <br><br>  Suppose there is a goal to write data to a file or send it to the network from two streams at the same time, but there is no desire (or possibility) to put Stream instances in the cache itself.  When using KeyLockManager, streams can be synchronized, for example, simply by the name of a file, while storing it in another place (or generally instantiating it only after they receive exclusive access by key). <br><br>  LockManager is already a more complete derivative of the cache.  It is essentially represented by the same ConcurrentDictionary with Pin, UnPin, and Evict, but without saving to the database.  This is a generalization of the idea of ‚Äã‚Äãsynchronization with locks, where you can put absolutely any data. <br><br>  <i>We found the use of LockManager in visualizing the movement of troops on a global map.</i> <br><br><h2>  Is everything good in the end? </h2><br>  Thanks to the situation with the bug in ASP.NET, we have become better versed in the features of the synchronization mechanism and parallel access to data and more efficiently use them.  ConcurrentDictionary we now use everywhere, but we understand our actions and their consequences. <br><br>  The only drawback of ConcurrentDictionary is there is no complete documentation on its work.  All descriptions are addressed to novice users.  In our own practice, we found the following points, which are definitely worth paying attention to.  They are not in MSDN and in articles on similar subjects. <br><br>  Count method - counting the number of elements in ConcurrentDictionary.  Nowhere is it written that its execution implies blocking of all baskets and may adversely affect performance.  Obviously, the Count on the contract tells you the exact value, but not in all situations it is necessary.  If you want to calculate approximately, it is better to use the LINQ .Select (..). Count () operations. <br><br>  The TryRemove method attempts to delete an object using the specified key.  To do this, TryRemove locks the cart, and then searches.  This is not bad, but there is a high probability that there is no object in the collection.  It is better to first check its availability using TryGetValue, which does not block anything, and then try to delete it.  Two search operations can often be more profitable than permanently blocking baskets. <br><br>  The most interesting method is GetOrAdd.  It either returns a value that lies on a specific key, or adds a value and returns it.  GetOrAdd has 2 overloaded versions.  The first version accepts the value, the second accepts the function to be called in case the value is not found, and will try to add it. <br><br>  Paradox, but they work absolutely differently.  The GetOrAdd variant with a value immediately locks the basket, determines that there is nothing there, and then only executes Add.  GetOrAdd with function is valid without initial blocking.  If there is nothing in the basket, it calls the function, gets the value, tries to block and add.  What is the difference: in the case of a function, we can once again execute the code to calculate the value, but there will be less synchronization.  In the case of value, we will perform a permanent lock, thereby increasing the competition.  That is, because of a spelling error, you can fundamentally change the work inside.  We are using a version of GetOrAdd that accepts a function. <br><br>  LINQ operation OrderBy.  When sending sequences, LINQ checks if the given sequence is an ICollection.  Then instead of going through the sequence, the collection will be copied entirely.  But this is the ConcurrentDictionary :) Internally, LINQ takes a sequence for a collection, creates a buffer, and copies it there.  LINQ goes to this collection through the Count property, which, as we have already determined, blocks all baskets.  If the size of the collection decreases, it will exclude the exception ‚Äúthe number of elements does not match.‚Äù  We deliberately inserted an extra Select request to hide that the sequence could be a collection. <br><br><h2>  What's next? </h2><br>  At this stage, we have only theoretical ideas for improving the server.  They can be used when in some of the server versions we decide to switch to full asynchrony.  If the competition score for the ConcurrentDictionary is too large or the processes occur in asynchronous mode, you can synchronously block the object and not leave it until the object is available.  Jeffrey Richter came up with excellent asynchronous locks: instead of waiting for the lock to be released, the thread will give up its function, which will be called when the lock is released.  Waiting for release is not the same as blocking and waiting.  This approach can be converted to cache. <br><br><h2>  PS </h2><br>  I will be glad to know your ideas, thoughts and discuss them in the comments.  Tell us what features do you know and what would you like to read about in the following articles? </div><p>Source: <a href="https://habr.com/ru/post/323144/">https://habr.com/ru/post/323144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323130/index.html">How IT professionals work. Ilya Vislotsky, Director of Client Solutions Architecture Center, Stack Group</a></li>
<li><a href="../323134/index.html">Tips, books, blogs and tools for mobile traffic arbitration</a></li>
<li><a href="../323136/index.html">DataLine experience: how we prepare duty engineers for our data centers</a></li>
<li><a href="../323138/index.html">How effective are the next-generation information security solutions?</a></li>
<li><a href="../323142/index.html">React or Vue? Choosing a library for front-end development</a></li>
<li><a href="../323148/index.html">ReactDoc - the first open source solution of the program "Common Frontal System"</a></li>
<li><a href="../323152/index.html">Some techniques of working in Bitrix on SQL and BASH</a></li>
<li><a href="../323154/index.html">Microservices: experience of use in a loaded project</a></li>
<li><a href="../323156/index.html">Interactive UX prototype: parsing on a real example</a></li>
<li><a href="../323158/index.html">RandLib. Library of probability distributions in C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>