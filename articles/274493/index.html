<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>One more analysis of bubble sort</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once, on New Year's Eve, inspired by the article about bubble sorting and its modifications, I decided to write my own implementation, and to think ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>One more analysis of bubble sort</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img width="60%" src="https://habrastorage.org/files/181/853/1a3/1818531a33ac43c18ac9b5caef0089b0.jpg"></div><br>  Once, on New Year's Eve, inspired by the <a href="http://habrahabr.ru/post/204600/">article</a> about bubble sorting and its modifications, I decided to write my own implementation, and to think about how I could improve it.  But at the same time, to start learning JAVA after all (by profession I am not a programmer, although I wrote a little). <br><br>  Why do we need bubble sorting these days? <br>  She's practically the slowest. <br>  It has the highest (quadratic) complexity algorithm. <br><br>  But!  It is the easiest to implement and very visual, and is often used for educational purposes or at junior / intern interviews. <br>  In addition, with minor modifications, interesting results can be achieved. <br>  Newbies in programming and interested - please under the cat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  So, we immediately pursue several goals. <br>  Write the implementation of the classic bubble sort; <br>  Try to write a modified algorithm that should overtake the classic "bubble"; <br>  Learn the basics of JAVA and a bit of OOP. <br><br>  All work with sorting and processing will be <b>moved</b> to a separate class <b>ArrayUtils</b> , from the class <b>Run</b> we will call sorting methods and form the order of calls with different data sets. <br><br>  In the ArrayUtils class, we will have: <br><ol><li>  Actually the array itself </li><li>  As the simplest metrics, we add two variables <b>compareValue</b> and <b>switchValue</b> to count the number of comparisons and the number of displacements of values, as well as <b>timeAmount</b> - operation time - they will be updated when the sorting method is started; </li><li>  Method of outputting results and metrics results (); </li><li>  The validation () method to immediately check if the sort is really working correctly; </li></ol><br><br>  I did the validation in the following way. <br>  The constructor of the <b>ArrayUtils</b> class receives an array as input, which copies it into two local arrays, <b>array</b> and <b>sortedArray</b> , the latter is immediately sorted by the regular sorter Arrays.sort (). <br><div class="spoiler">  <b class="spoiler_title">class ArrayUtils</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] sortedArray; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> switchCount, compareCount, timeAmount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sortedArray = Arrays.copyOf(array, array.length); Arrays.sort(sortedArray); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(String.format(<span class="hljs-string"><span class="hljs-string">"%-35s Compares: %, 15d, Switches: %, 15d, Time: %, 15d"</span></span>, text, compareCount, switchCount, timeAmount)); } }</code> </pre> <br></div></div><br>  The actual validation () method actually compares the current state of the <b>array</b> with our <b>sortedArray</b> , which is sorted by the regular sorter (in Java, this is one of the variations of the smart quicksort).  I call the method via assert, in eclipse it is turned off by default, but by adding the <b>-ea</b> options, our assert correctly <b>drops</b> out if the array breaks. <br><div class="spoiler">  <b class="spoiler_title">Validation method</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arrays.equals(array,sortedArray)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br></div></div><br>  Now we can proceed to the implementation of bubble sorting, which will be the benchmark for further work. <br><div class="spoiler">  <b class="spoiler_title">sortBubbleClassic</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortBubbleClassic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp; switchCount=<span class="hljs-number"><span class="hljs-number">0</span></span>; compareCount=<span class="hljs-number"><span class="hljs-number">0</span></span>; time = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (maxPosition=array.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; maxPosition &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>;maxPosition--) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (currentPosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; currentPosition &lt; maxPosition; currentPosition++) { compareCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[currentPosition] &gt; array[currentPosition+<span class="hljs-number"><span class="hljs-number">1</span></span>]) { temp = array[currentPosition]; array[currentPosition] = array[currentPosition+<span class="hljs-number"><span class="hljs-number">1</span></span>]; array[currentPosition+<span class="hljs-number"><span class="hljs-number">1</span></span>] = temp; switchCount++; } } } time = System.nanoTime() - time; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(validate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br></div></div><br>  We now write the <b>Run</b> class, from which we will call sorting, we add the fillRandom () method in it to create a set of random data for further sorting. <br><div class="spoiler">  <b class="spoiler_title">Run.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Run</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillRandom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; array.length; count++) { array[count] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Math.random()*<span class="hljs-number"><span class="hljs-number">100</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> random[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[arraySize+<span class="hljs-number"><span class="hljs-number">1</span></span>]; FillRandom(random); ArrayUtils bubbleClassic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayUtils(random); bubbleClassic.sortBubbleClassic(); bubbleClassic.results(<span class="hljs-string"><span class="hljs-string">"Bubble Classic, random array"</span></span>); } }</code> </pre><br></div></div><br>  You can run.  Passing an array to the created class, and then copying it, I did so that the original array with random data remains unchanged for later use.  So we can sort an identical set of random data in different ways. <br><br>  Run, we get the result: <br><pre> <code class="diff hljs">Bubble Classic, random array Compares: 50 005 000, Switches: 24 486 908, Time: 117 116 326</code> </pre> <br>  If assert did not throw an error, then the algorithm sorts correctly.  On an array of 10,000 elements, we received over 50 million comparisons and 24 million permutations. <br><br>  We copy our sortBubbleClassic method into sortBubbleAdvanced, and we begin to think what can be improved. <br>  First of all, I thought that it was possible to add a check on whether the array was sorted so as not to drive through it for nothing. <br>  To do this, I created the Boolean variable <b>changed</b> , which is set to <b>false</b> before the start of the inner loop, and inside the loop, if we do the permutation, is set to <b>true</b> . <br>  If, having run the entire internal cycle, we have not made a single permutation, we can not drive further the wasted cycles, but immediately exit. <br><div class="spoiler">  <b class="spoiler_title">sortBubbleAdvanced - step 1</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortBubbleClassic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp; switchCount=<span class="hljs-number"><span class="hljs-number">0</span></span>; compareCount=<span class="hljs-number"><span class="hljs-number">0</span></span>; timeAmount = System.nanoTime(); Boolean changed; <span class="hljs-comment"><span class="hljs-comment">//    for (maxPosition=array.length - 1; maxPosition &gt;= 0;maxPosition--) { changed=false; //   for (currentPosition = 0; currentPosition &lt; maxPosition; currentPosition++) { compareCount++; if (array[currentPosition] &gt; array[currentPosition+1]){ temp = array[currentPosition]; array[currentPosition] = array[currentPosition+1]; array[currentPosition+1] = temp; switchCount++; changed = true; //   } } if (!changed) { //     -   timeAmount = System.nanoTime() - timeAmount; assert(validate()); return; } } timeAmount = System.nanoTime() - timeAmount; assert(validate()); return; }</span></span></code> </pre><br></div></div><br>  Further, if at the beginning of the array, we have a large number, we pull it to the right, making a bunch of permutations.  It is logical that you can immediately move it to the end of the array. <br>  However, doing a lot of checks to figure out exactly where to throw it is expensive.  Therefore, I made the simplest solution - check if the current value is greater than the value in the rightmost element - swap them.  Increase the number of checks, but reduce the number of permutations. <br>  Immediately and the second optimization - if we have a small number at the very end of the array, it will generally run to the beginning of the array through N internal cycles, almost equal to the number of elements in the array.  Therefore, we add another check to swap the current value and the leftmost value in the array, if it is smaller.  In itself, this action gives an extra check, but it accelerates slightly.  But, after the completion of the internal cycle, we can be sure that the smallest number is in the leftmost position of our data array.  This means that we can now begin the inner loop not from the first element, but from the second.  With each step, we will now cut the array for the inner loop into two values ‚Äã‚Äãat once - left and right.  This is a clear increase. <br>  We have our three checks rationally. <br>  The first check is the main bubble - two elements are compared, then we compare the current element with the leftmost element of the array, for which one is smaller.  Then with the most right, on the subject, who is more. <br><div class="spoiler">  <b class="spoiler_title">sortBubbleAdvanced - step 2</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortBubbleAdvanced</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPosition; <span class="hljs-comment"><span class="hljs-comment">//    int minPosition = 0; //    boolean changed; // ,    int temp; switchCount = 0; compareCount = 0; timeAmount = System.nanoTime(); for (maxPosition = array.length - 1; maxPosition &gt;= 0; maxPosition--) { changed=false; for (currentPosition = minPosition; currentPosition &lt; maxPosition; currentPosition++) { if (array[currentPosition] &gt; array[currentPosition+1]){ //      temp = array[currentPosition+1]; array[currentPosition+1] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; } if (array[currentPosition] &lt; array[minPosition]){ //      temp = array[minPosition]; array[minPosition] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; } if (array[currentPosition] &gt; array[maxPosition]){ //      temp = array[maxPosition]; array[maxPosition] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; } compareCount+=3; } if (!changed) { timeAmount=System.nanoTime()-timeAmount; assert(validate()); return; } compareCount++; minPosition++ //    } timeAmount=System.nanoTime()-timeAmount; assert(validate()); return; }</span></span></code> </pre><br></div></div><br>  You can check what happened with us.  Rule the <b>Run</b> class to add now the check of two methods and run <br><pre> <code class="diff hljs">Bubble Classic, random array Compares: 50 005 000, Switches: 24 758 509, Time: 105 797 881 Bubble Advanced, random array Compares: 112 317 213, Switches: 18 684 909, Time: 87 415 460</code> </pre><br>  As you can see, the result is very significant.  The number of comparisons has more than doubled.  But on the other hand, the number of permutations has decreased, and they are more expensive in time, so by time we win about <b>15%</b> ! .. <br><br>  Add two more data sets ‚Äî already sorted incremental array, and sorted in reverse order ‚Äî decremental (in theory it should be the worst case for sorting), add them to the <b>Run</b> class and add <b>sortBubbleClassic</b> and <b>sortBubbleAdvanced calls</b> for all three arrays - <b>random</b> , <b>incremental</b> and <b>decremental</b> <br><div class="spoiler">  <b class="spoiler_title">two more types of arrays</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDecremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; array.length; count++) { array[count] = array.length-count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillIncremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; array.length; count++) { array[count] = count; } }</code> </pre><br></div></div><br>  See the results: <br><pre> <code class="diff hljs">Bubble Classic, random array Compares: 50 005 000, Switches: 24 678 169, Time: 116 314 053 Bubble Advanced, random array Compares: 111 879 748, Switches: 18 615 013, Time: 77 282 419 Bubble Classic, decremental array Compares: 50 005 000, Switches: 50 005 000, Time: 48 202 818 Bubble Advanced, decremental array Compares: 112 527 500, Switches: 49 985 004, Time: 77 115 071 Bubble Classic, incremental array Compares: 50 005 000, Switches: 0, Time: 24 805 261 Bubble Advanced, incremental array Compares: 30 000, Switches: 0, Time: 35 084</code> </pre><br>  On a random data set, our advanced method is expected to win, and on the <b>decremental</b> it is almost 60% longer; ( <br>  But he just instantly checks the already sorted array, thanks to our small check with the variable <b>changed</b> . <br><br>  I was only partially pleased with this result.  You can not leave the optimization of the algorithm, if it on some sets can show the result worse than the original.  Reflecting on how to improve bubble sorting, without changing the basic principle, I noticed that in the ‚Äúbubble‚Äù, large numbers actively travel to the right with each pass of the internal cycle, plus the maximum number also moves there.  Thus, our right-hand side of the array becomes sorted before the left-hand side ... This idea was realized into the following idea: <br>  With each permutation, I remember this position.  Having reached the last element of the inner loop, I can reduce the array on the right not by one, but immediately cut to this last position where the permutation was, since this means that all positions after it are already sorted. <br>  The number of cycles should be significantly reduced, at least about two times for the decremental array. <br>  It is implemented in just three lines: <br><div class="spoiler">  <b class="spoiler_title">sortBubbleAdvanced - final step</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortBubbleAdvanced</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> changedMaxPosition = array.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    int minPosition = 0; boolean changed; int temp; switchCount = 0; compareCount = 0; timeAmount = System.nanoTime(); for (maxPosition = array.length - 1; maxPosition &gt;= 0; minPosition++) //       ,    minPosition++ { changed=false; for (currentPosition = minPosition; currentPosition &lt; maxPosition; currentPosition++) { if (array[currentPosition] &gt; array[currentPosition+1]){ temp = array[currentPosition+1]; array[currentPosition+1] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; changedMaxPosition = currentPosition; //      } if (array[currentPosition] &lt; array[minPosition]){ temp = array[minPosition]; array[minPosition] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; } if (array[currentPosition] &gt; array[maxPosition]){ temp = array[maxPosition]; array[maxPosition] = array[currentPosition]; array[currentPosition] = temp; switchCount++; changed=true; } compareCount+=3; } if (!changed) { timeAmount=System.nanoTime()-timeAmount; assert(validate()); return; } compareCount++; maxPosition = changedMaxPosition; //    -     } timeAmount=System.nanoTime()-timeAmount; assert(validate()); return; }</span></span></code> </pre><br></div></div><br>  We look at what happened with us: <br><pre> <code class="diff hljs">Bubble Classic, random array Compares: 50 005 000, Switches: 25 020 725, Time: 117 550 372 Bubble Advanced, random array Compares: 45 090 482, Switches: 10 174 100, Time: 70 032 156 Bubble Classic, decremental array Compares: 50 005 000, Switches: 50 005 000, Time: 47 815 033 Bubble Advanced, decremental array Compares: 60 022 000, Switches: 30 003 000, Time: 46 042 519 Bubble Classic, incremental array Compares: 50 005 000, Switches: 0, Time: 25 072 582 Bubble Advanced, incremental array Compares: 30 000, Switches: 0, Time: 34 773</code> </pre><br>  We snapped up on random data by about 10%, and <b>YES</b> , on the decremental array with a small margin, but we overtook the classic ‚Äúbubble‚Äù - as expected, the time decreased by about two times. <br>  The incremental array is instantaneous. <br>  Due to the sharp reduction of empty passes on the already sorted part, the number of checks of the advanced algorithm has decreased, and in some cases even less than the original, and the number of permutations is always much less (well, apart from the checks, this is just the cost of an empty pass through the array). <br><br>  So, staying within the main idea of ‚Äã‚Äãbubble sorting, we were able to significantly improve the result. <br>  What else can be done? <br>  Let's compare our algorithm with the quicksort leader. <br><br>  We write a simple implementation (to be honest, I just stole it in the internet, slightly correcting it so that the metrics remain, but given that <b>quicksort</b> uses recursion, in a good way, you would need to add a metric for it ... but how can you compare it with algorithms without recursion? In general, not the essence ...), so: <br><div class="spoiler">  <b class="spoiler_title">Simple quicksort implementation</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quickSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ timeAmount = System.nanoTime(); switchCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; compareCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; doQuickSort(<span class="hljs-number"><span class="hljs-number">0</span></span>, array.length - <span class="hljs-number"><span class="hljs-number">1</span></span>); timeAmount = System.nanoTime() - timeAmount; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(validate()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doQuickSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lastPosition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startPosition &gt;= lastPosition) { compareCount++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tempStartPosition = startPosition, tempLastPosition = lastPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentPosition = tempStartPosition - (tempStartPosition - tempLastPosition) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tempStartPosition &lt; tempLastPosition) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tempStartPosition &lt; currentPosition &amp;&amp; (array[tempStartPosition] &lt;= array[currentPosition])) { compareCount++; tempStartPosition++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tempLastPosition &gt; currentPosition &amp;&amp; (array[currentPosition] &lt;= array[tempLastPosition])) { compareCount++; tempLastPosition--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempStartPosition &lt; tempLastPosition) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp = array[tempStartPosition]; array[tempStartPosition] = array[tempLastPosition]; array[tempLastPosition] = temp; switchCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempStartPosition == currentPosition) currentPosition = tempLastPosition; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempLastPosition == currentPosition){ currentPosition = tempStartPosition; compareCount++; } compareCount++; } compareCount++; } doQuickSort(startPosition, currentPosition); doQuickSort(currentPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>, lastPosition); }</code> </pre><br></div></div><br><br>  See the results: <br><pre> <code class="diff hljs">Bubble Classic, random array Compares: 50 005 000, Switches: 24 684 713, Time: 117 338 627 QuickSort, random array Compares: 453 318, Switches: 22 234, Time: 3 000 141 Bubble Advanced, random array Compares: 44 832 715, Switches: 10 048 493, Time: 70 540 407 Bubble Classic, decremental array Compares: 50 005 000, Switches: 50 005 000, Time: 47 269 214 QuickSort, decremental array Compares: 153 632, Switches: 5 000, Time: 179 766 Bubble Advanced, decremental array Compares: 60 022 000, Switches: 30 003 000, Time: 45 579 908 Bubble Classic, incremental array Compares: 50 005 000, Switches: 0, Time: 24 927 899 QuickSort, incremental array Compares: 143 632, Switches: 0, Time: 134 437 Bubble Advanced, incremental array Compares: 30 000, Switches: 0, Time: 35 394</code> </pre><br>  As expected, <b>quicksort</b> easily does all of our algorithms on both a random data set and a decrement array.  But suddenly, on an already sorted array, our advanced bubble makes it almost 4 times faster! <br><br>  At first, I thought that there wasn‚Äôt much point.  Well, yes, my advanced algorithm checks that the array is already sorted faster, but such a task is extremely rare. <br>  Then I figured that this is not all - in fact, almost at the same speed, our advanced algorithm, in one pass, can sort at best 3 numbers (minimum, maximum, and move a couple more along the way), and decided to check for practice. <br>  I changed the method that creates the incremental array so that there are several random numbers in the middle of the sorted array: <br><div class="spoiler">  <b class="spoiler_title">Create a not exactly sorted array.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillIncremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; array.length; count++) { array[count] = count; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=array.length/<span class="hljs-number"><span class="hljs-number">2</span></span>; count &lt; array.length/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>; count++) <span class="hljs-comment"><span class="hljs-comment">//     5    array[count]=(int)Math.random()*100; }</span></span></code> </pre><br></div></div><br><br>  Look what happened: <br><pre> <code class="diff hljs">Bubble Classic, incremental array Compares: 50 005 000, Switches: 24 995, Time: 24 751 238 QuickSort, incremental array Compares: 219 964, Switches: 8 426, Time: 249 624 Bubble Advanced, incremental array Compares: 179 740, Switches: 24 981, Time: 125 123</code> </pre><br>  The advanced bubble algorithm did faster than quicksort, sorting out 5 random numbers almost twice as fast. <br><br>  Increase the size of the array 10 times, check just in case: <br><pre> <code class="diff hljs">Bubble Classic, incremental array Compares: 5 000 050 000, Switches: 249 995, Time: 2 168 664 535 QuickSort, incremental array Compares: 2 539 530, Switches: 86 062, Time: 11 479 582 Bubble Advanced, incremental array Compares: 1 799 740, Switches: 249 981, Time: 6 411 974</code> </pre><br>  Anyway, almost twice as fast. <br>  On an almost sorted array, where the number of unsorted elements does not exceed a certain minimum number, our converted bubble algorithm does not show quadratic complexity, but the usual O (N), and considering its simplicity to implement, it bypasses quicksort. <br><br>  If we add the number of non-sorted elements up to about 10, the quicksort and bubbleAdvanced speeds are compared, and then our algorithm is still getting bored into hopeless quadratic slowness.  However, if you need to sort a few randomly inserted values ‚Äã‚Äãin a previously sorted data array, it was out of competition. <br><br>  Moral, results, conclusions. <br><br>  <b>The results</b> , or rather the figures were shown above, can be discussed in the comments. <br>  Sources are available on <a href="https://github.com/sfkulyk/SortingVizualization/tree/Habra">github</a> (although there is a bit of garbage there, I tried to learn maven, but the source files of the classes can be compiled into any IDE or console). <br>  In addition, I did write my first JAVA code, a bit more complicated than HelloWorld.  And also learned at least about two methods of sorting from within. <br>  And besides, if you dig into the algorithms, you can then intuitively guess what results you can expect, and where to dig. <br>  So far, I don‚Äôt really understand why the decremental array is processed faster than the random one.  It seemed to me that for the bubble sort the worst case is that it is a decremental array.  Perhaps this is due to the fact that in a random array there are the same numbers, in general, there is still something to think about. <br><br>  <b>Conclusions and morality</b> - under a certain set of data, if speed is important, it always makes sense to think and come up with your own bike, which can outrun regular methods, whose main task is to show quick results in the most common cases. </div><p>Source: <a href="https://habr.com/ru/post/274493/">https://habr.com/ru/post/274493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274483/index.html">Creating game levels: tips and tricks (part 1)</a></li>
<li><a href="../274485/index.html">String and & str in Rust functions</a></li>
<li><a href="../274487/index.html">Digest on the results of 2015</a></li>
<li><a href="../274489/index.html">Java in Android: Change is Coming (Rumors)</a></li>
<li><a href="../274491/index.html">C # string comparison (default)</a></li>
<li><a href="../274495/index.html">Flash Player (ActiveX) update for January 1, 2016</a></li>
<li><a href="../274497/index.html">Centrifugal compressor installations. Surge protection</a></li>
<li><a href="../274499/index.html">Definition of gender by name - when accuracy is really important</a></li>
<li><a href="../274501/index.html">IBM opens blockchain lab</a></li>
<li><a href="../274503/index.html">Attackers have targeted the BlackEnergy Trojan at Ukrainian energy companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>