<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Splitting algorithms and van der Waerden numbers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I decided to indulge in graphomania and share the result of last weekend's entertainment (only this weekend passed a long time ago and the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Splitting algorithms and van der Waerden numbers</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I decided to indulge in graphomania and share the result of last weekend's entertainment (only this weekend passed a long time ago and the article was written much longer than entertainment. As they say, time is fun for an hour). <br><br>  I will talk about the so-called splitting algorithms (in particular, about the DPLL algorithm), about the theorem and van der Waerden numbers, and in conclusion of the article we will write our own splitting algorithm and in half an hour of calculations we will prove that the number w (2; 5 ) equal to 178 (pioneers in 1978, it took more than 8 days of calculations). <br><a name="habracut"></a><br><h4>  Splitting algorithm </h4><br>  This is a fairly general algorithm that solves the following problem: there is some finite set S and we want to divide it into two subsets A and B, with some properties, or to determine that the set S cannot be divided in the necessary way. <br><br>  This is done in the following way: 3 non-intersecting subsets A, B, C are supported, which completely cover the set S, where C is the set of those elements that we have not yet distributed between A and B. Initially, C = S, and A and B are empty.  At each iteration in the set C, the element a is arbitrarily chosen, which can be placed either in the set A or in the set B. In fact, we do both, and then recursively process both possible options. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/dba/d2c/b87/dbad2cb87aff45b3bc022c1396846e90.png" alt="image" width="400"></div><br><br>  The result is a splitting tree, the leaves of which contain all sorts of divisions of the set S into A and B, and the set C is empty.  Now we just need to check for all leaves that the properties of interest to us. <br><br>  ‚ÄúAllow me!‚Äù, You will say, ‚Äúthan this is better than the obvious brute force of 2 <sup>| S |</sup>  options?  And the whole thing in the cutoffs, which are very convenient to add to the above proposed core of the algorithm! <br><br>  List of cuts: <br><ol><li>  If partially constructed A and B do not fit - rollback </li><li>  Moving an element from S to A or B may result in moving other elements from S to A or B </li><li>  Proper selection of the element a of S at each step can significantly reduce the size of the search tree </li></ol><br>  With the use of clippings, the size of the tree is greatly reduced, the number of leaves decreases noticeably, sometimes to 0 (this means that it is impossible to divide S into A and B as appropriate).  Although the complexity of the algorithm still remains exponential at worst. <br><br>  It is convenient to explain the general splitting algorithm and all the proposed cut-offs using the example of the classical DPLL algorithm. <br><br><h4>  DPLL algorithm </h4><br>  <a href="http://ru.wikipedia.org/wiki/DPLL-%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">The Davis ‚Äì Putnam ‚Äì Laugemann ‚Äì Loveland</a> algorithm (DPLL) was developed in 1962 to determine the feasibility of Boolean formulas written in conjunctive normal form, i.e.  to solve the problem of SAT.  The algorithm turned out to be so efficient that after more than 50 years it is the basis for the majority of effective SAT solvers. <br><br>  Let's take a closer look at what the DPLL algorithm does.  He takes the Boolean formula and tries to divide all the variables in it into two sets A and B, where A is the set of all variables with a value of true and B is the set of all variables with a value of false. <br><br>  At each step, a variable is selected in some way, which has not yet been assigned a value (let's call such variables <i>free</i> ) and is assigned the value true (this variable is entered into the set A).  After that, the resulting simplified problem is solved.  If it is doable, then the original formula is doable.  Otherwise, the selected variable is assigned the value false (it is entered in B) and the problem is solved for the new simplified formula.  If it is doable, then the original formula is doable.  Otherwise - alas, the original formula is impracticable. <br><br>  After each assignment, the formula is further simplified using the following two rules: <br><br><ol><li>  Variable propagation (unit propagation).  If exactly one variable remains in any clause, then it must be assigned such a value so that the clause finally becomes true (move to A or B depending on whether there is a negative or not). </li><li>  Elimination of ‚Äúpure‚Äù variables (pure literal elimination).  If any variable enters the formula with only negatives, or always without negatives, it is called <i>pure</i> .  This variable can be assigned such a value that all its entries will be true, which will reduce the number of free variables. </li></ol><br>  These two rules should be applied as long as they are applied: usually after the first assignment, a whole cascade of simplifications follows, which well reduces the number of free variables. <br><br>  If, after simplification, we have received an empty clause (all its simple conjuncts are false) - the current formula is not feasible and should be rolled back.  If there are no free variables left, then the formula is feasible and the work of the algorithm can be completed.  You can also finish the work of the algorithm if the clause is not left - you can assign unused free variables in an arbitrary way. <br><br>  A small C-like pseudocode explaining what happens: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DPLL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( eq F, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">set</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">set</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">set</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    if (F is empty) { //  ! write A, B, C; return true; } if (F contains an empty clause) return false; //    //  bool flag = false; if (unit_propagation(&amp;F, &amp;A, &amp;B, &amp;C)) flag = true; if (pure_literal_elimination(&amp;F, &amp;A, &amp;B, &amp;C)) flag = true; if (!flag) break; //    } //  x = choose_literal(F, ); if (DPLL(F ‚àß (x), A^x, B, C^x)) return true; if (DPLL(F ‚àß (¬¨x), A, B^x, C^x)) return true; return false; }</span></span></code> </pre> <br><br>  The &amp; symbol shows that in the function unit_propagation and pure_literal_elimination, the variables F, A, B and C are passed by reference, i.e.  they can change inside.  If anything has changed, these functions return true.  When recursive descent - on the contrary, copies of objects are created.  The ^ icon excludes an object from the set if it exists or adds if it does not exist. <br><br>  Consider the following formula and, using its example, let's see how the DPLL algorithm works: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/14f/040/fca/14f040fcaedd48eeb8086e694d09af0e.png" alt="image"></div><br>  The simplification rules do not apply to this formula, so we will have to branch our tree.  As an element for branching, we take x <sub>1</sub> and, for a start, assign it the value true.  We get the following chain of simplifications: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f0a/e17/517/f0ae1751768548b0baee18aa7a1baf67.png" alt="image"></div><br>  Double arrows show that we use the first rule, namely, we find a lonely variable and assign it the desired value. <br><br>  Unfortunately, this branch leads to an impracticable formula, i.e.  In this branch, we tried in vain.  We roll back and try to set the variable x <sub>1</sub> to false.  This will lead to the following chain of simplifications: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/19a/b4f/9cb/19ab4f9cb7014e9ea40104ee08a5deee.png" alt="image"></div><br>  Triple arrows indicate that we apply the second rule of simplification.  Success is waiting for us in this branch - 2 solutions were found! <br><br>  Whole walk tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/490/b99/a50/490b99a508c44faba41a3a0effb4e51f.png" alt="image"></div><br>  Since the transformations shown by double and triple arrows occur inside each vertex of the tree, it turns out that the tree itself actually consists of only three vertices!  However, it was probably possible to come up with a more intricate example. <br><br>  Note that if, at the very beginning, for the branching, for example, the element x <sub>2</sub> was chosen, then the desired tree would have been much smaller and the answer would have been found much earlier (the necessary calculations are proposed to be made to the reader independently).  Therefore, the element selection strategy for branching is very important.  For example, you can choose to branch a variable that is included in the largest number of clauses. <br><br>  It is also worth noting that with the help of this algorithm it is impossible to find all the solutions - this is prevented by the heuristic of the exclusion of ‚Äúpure‚Äù variables.  It may well be missing a solution in which the value of the variable that we, following the heuristic, set to true, is false.  To search for all solutions, the second rule should be excluded from the algorithm. <br><br><h4>  Theorem and van der Waerden numbers </h4><br>  Van der Warder's theorem is one of the most important results in Ramsey‚Äôs theory, a branch of mathematics that studies the appearance of patterns in objects consisting of a large number of random elements.  It all started like this: <br><br>  In the twenties of the last century, one mathematician faced the following task: <br><br>  <i>Let the set of all natural numbers be colored in 2 different colors.</i>  <i>Is it possible to assert that there is an arbitrarily long arithmetic progression whose numbers are painted in the same color?</i> <br><br><img src="https://habrastorage.org/files/702/fe7/332/702fe7332d8c4c9497fc9631caf4f743.jpg" alt="image" align="right">  The task seems very simple and a positive solution seems almost obvious.  However, attempts to prove this statement did not lead to anything at first.  A few years later, the task finally gave in to the young Dutch mathematician <a href="http://en.wikipedia.org/wiki/Bartel_Leendert_van_der_Waerden">Barthel Leendert van der Waerden</a> .  He proved a more general version in a slightly different formulation: <br><br>  <i>For any r and k there is a number n (r; k) such that, for any coloring of the set of natural numbers S = {1, 2, ..., n (r; k)} in r different colors, this set S will contain arithmetic a progression of k numbers painted in the same color.</i> <br><br>  The proof is based on the so-called <i>double induction</i> .  A simplified version of this proof can be found, for example, <a href="http://ilib.mccme.ru/djvu/hinchin-3zhem.htm">here</a> . <br><br>  Denote the minimum of the numbers n (r; k) by w (r; k).  The numbers w (r; k) are usually called van der Waerden numbers.  The proof of the van der Waerden theorem does not give exact values ‚Äã‚Äãof the numbers w (r; k), only the upper bound.  And believe me, this upper limit is huge!  It turned out that even for two colors, the estimate for the number w (r; k) grows as a <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">function of Ackermann</a> !  This rating from above gradually improved.  The latest result, obtained by <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2583%25D1%258D%25D1%2580%25D1%2581,_%25D0%25A3%25D0%25B8%25D0%25BB%25D1%258C%25D1%258F%25D0%25BC_%25D0%25A2%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2582%25D0%25B8">Timothy Gowers</a> in 2001, reads as follows: <br><br>  w (r; k) ‚â§ 2 <sup>2 <sup>r <sup>2 <sup>2 <sup>k + 9</sup></sup></sup></sup></sup> . <br><br>  The result is a little less scary than the original, but still a little frightening.  Still, this boundary is very far from the exact values ‚Äã‚Äãof w (r; k). <br><br>  A separate branch of research is the determination of the exact values ‚Äã‚Äãof the numbers w (r; k) for various r and k.  This task is very resource intensive (this is typical of most of the tasks of Ramsey Theory).  Wikipedia <a href="http://en.wikipedia.org/wiki/Van_der_Waerden_number">says</a> that at the moment the exact value of w (r; k) is known only for 7 pairs of numbers r and k. <br><br><table><tbody><tr><th>  r / k </th><th>  3 </th><th>  four </th><th>  five </th><th>  6 </th></tr><tr><th>  2 colors </th><td>  9 </td><td>  35 </td><td>  178 </td><td>  1132 </td></tr><tr><th>  3 colors </th><td>  27 </td><td>  293 </td><td></td><td></td></tr><tr><th>  4 colors </th><td>  76 </td><td></td><td></td><td></td></tr></tbody></table><br>  The answer for w (2; 3) is trivial: <br><br><div class="spoiler">  <b class="spoiler_title">Proof that w (2; 3) = 9</b> <div class="spoiler_text">  Another proof with a similar idea and in a slightly more detailed form is given <a href="http://www.ega-math.narod.ru/Nquant/Ramsey.htm">here</a> . <br><br>  An example of painting 8 numbers in 2 colors so that there is no monochromatic arithmetic progression of length 3 among them looks like this: <br><br>  <b><font color="red">1 2</font> <font color="blue">3 4</font> <font color="red">5 6</font> <font color="blue">7 8</font></b> <br><br>  This means that w (2; 3)&gt; 8.  For 9 colors, let's consider the numbers 4 and 6. Without loss of generality, two cases are possible: either these two numbers are painted in the same color, or different. <br><br>  1) Let 4 and 6 be colored red: <br><br>  <b>1 2 3 <font color="red">4</font> 5 <font color="red">6</font> 7 8 9</b> <br><br>  Then we are obliged to paint 5 in blue, because otherwise there are three red numbers 4 5 6. Similar arguments for 2 and 8. As a result, we get a blue three 2 5 8: <br><br>  <b>1 <font color="blue">2</font> 3 <font color="red">4</font> <font color="blue">5</font> <font color="red">6</font> 7 <font color="blue">8</font> 9</b> <br><br>  2) Let 4 be blue and 6 be red: <br><br>  <b>1 2 3 <font color="blue">4</font> 5 <font color="red">6</font> 7 8 9</b> <br><br>  Then, without loss of generality, 5 can be painted blue.  It follows from this that 3 should be painted red to avoid blue 3 4 5. Next, 9 should be painted blue to avoid red 3 6 9. Subtotal: <br><br>  <b>1 2 <font color="red">3</font> <font color="blue">4</font> <font color="blue">5</font> <font color="red">6</font> 7 8 <font color="blue">9</font></b> <br><br>  The number 1 should be red to avoid blue 1 5 9. From this follows blue 2, because otherwise we get red 1 2 3. To avoid red 2 5 8, paint 8 in red and eventually we get: <br><br>  <b><font color="red">1</font> <font color="blue">2</font> <font color="red">3</font> <font color="blue">4</font> <font color="blue">5</font> <font color="red">6</font> 7 <font color="red">8</font> <font color="blue">9</font></b> <br><br>  Now, if we paint 7 in red, then we get the red three 6 7 8. If we paint 7 in blue, the blue three will come out 5 7 9. <br></div></div><br><br>  For slightly larger values ‚Äã‚Äãof w (r, k), the proof usually reduces to the following: the length of the colored chain of numbers n is fixed, after which a Boolean formula is constructed in conjunctive normal form to check that these n numbers can be colored taking into account the constraints r and k, and verifies its feasibility with the help of SAT-Solver.  If there is a solution, then the number n + 1 is the lower bound for w (r; k), otherwise the number n should be considered the upper bound for w (r; k). <br><br>  Given that many SAT solvers are based on the DPLL algorithm, the numbers w (r; k) are searched for using splitting algorithms. <br><br>  We present a simple method for constructing the desired Boolean formula for the number of colors r = 2.  Let's get n variables x <sub>i</sub> , meaning what color the corresponding numbers are painted in.  A value of true will mean the 1st color, false - the second.  We need to introduce restrictions so that any arithmetic progression contains both colors.  This is done very simply: a disjunction of the form (x <sub>a <sub>1</sub></sub> ‚à®x <sub>a <sub>2</sub></sub> ‚à® ... x <sub>a <sub>k</sub></sub> ) guarantees the presence of the first color, and a disjunction of the form (¬¨x <sub>a <sub>1</sub></sub> ‚à®¬¨x <sub>a <sub>2</sub></sub> ‚à® ... ‚à®¬¨x <sub>a <sub>k</sub></sub> ) - the second .  Well and, actually, everything - for each arithmetic progression we build 2 formulas and glue everything that turned out into one big CNF. <br><br>  An example of a formula for r = 2, k = 3 and n = 9: <br><br>  (x <sub>1</sub> ‚à®x <sub>2</sub> ‚à®x <sub>3</sub> ) ‚àß (¬¨x <sub>1</sub> ‚à®¬¨x <sub>2</sub> ‚à®¬¨x <sub>3</sub> ) (x <sub>2</sub> ‚à®x <sub>3</sub> ‚à®x <sub>4</sub> ) (¬¨x <sub>2</sub> ‚à®¬¨x <sub>3</sub> ‚à®¬¨x <sub>4</sub> ) (x <sub>3</sub> ‚à®x <sub>4</sub> ‚à®x <sub>5</sub> ) ‚àß (¬¨x <sub>3</sub> ‚à®¬¨x <sub>4</sub> ¬¨x <sub>5</sub> ) <br>  (x <sub>4</sub> ‚à®x <sub>5</sub> ‚à®x <sub>6</sub> ) ‚àß (¬¨x <sub>4</sub> ‚à®¬¨x <sub>5</sub> ‚à®¬¨x <sub>6</sub> ) (x <sub>5</sub> ‚à®x <sub>6</sub> ‚à®x <sub>7</sub> ) (¬¨x <sub>5</sub> ‚à®¬¨x <sub>6</sub> ‚à®¬¨x <sub>7</sub> ) (x <sub>6</sub> ‚à®x <sub>7</sub> ‚à®x <sub>8</sub> ) ‚àß (¬¨x <sub>6</sub> ‚à®¬¨x <sub>7</sub> ‚à®¬¨x <sub>8</sub> ) <br>  (x <sub>7</sub> ‚à®x <sub>8</sub> ‚à®x <sub>9</sub> ) ‚àß (¬¨x <sub>7</sub> ‚à®¬¨x <sub>8</sub> ‚à®¬¨x <sub>9</sub> ) (x <sub>1</sub> ‚à®x <sub>3</sub> ‚à®x <sub>5</sub> ) (¬¨x <sub>1</sub> ‚à®¬¨x <sub>3</sub> ‚à®¬¨x <sub>5</sub> ) (x <sub>2</sub> ‚à®x <sub>4</sub> ‚à®x <sub>6</sub> ) ‚àß (¬¨x <sub>2</sub> ‚à®¬¨x <sub>4</sub> ¬¨x <sub>6</sub> ) <br>  (x <sub>3</sub> ‚à®x <sub>5</sub> ‚à®x <sub>7</sub> ) ‚àß (¬¨x <sub>3</sub> ‚à®¬¨x <sub>5</sub> ‚à®¬¨x <sub>7</sub> ) (x <sub>4</sub> x <sub>6</sub> ‚à®x <sub>8</sub> ) (¬¨x <sub>4</sub> ‚à®¬¨x <sub>6</sub> ‚à®¬¨x <sub>8</sub> ) (x <sub>5</sub> ‚à®x <sub>7</sub> ‚à®x <sub>9</sub> ) ‚àß (¬¨x <sub>5</sub> ‚à®¬¨x <sub>7</sub> ‚à®¬¨x <sub>9</sub> ) <br>  (x <sub>1</sub> ‚à®x <sub>4</sub> ‚à®x <sub>7</sub> ) ‚àß (¬¨x <sub>1</sub> ‚à®¬¨x <sub>4</sub> ‚à®¬¨x <sub>7</sub> ) (x <sub>2</sub> ‚à®x <sub>5</sub> ‚à®x <sub>8</sub> ) (¬¨x <sub>2</sub> ‚à®¬¨x <sub>5</sub> ‚à®¬¨x <sub>8</sub> ) ‚àß (x <sub>3</sub> ‚à®x <sub>6</sub> ‚à®x <sub>9</sub> ) ‚àß (¬¨x <sub>3</sub> ‚à®¬¨x <sub>6</sub> ‚à®¬¨x <sub>9</sub> ) <br>  (x <sub>1</sub> ‚à®x <sub>5</sub> ‚à®x <sub>9</sub> ) ‚àß (¬¨x <sub>1</sub> ‚à®¬¨x <sub>5</sub> ‚à®¬¨x <sub>9</sub> ) <br><br>  In the previous spoiler proved that this formula is impossible. <br><br><h4>  We apply knowledge in practice </h4><br>  Let us now write our own splitting algorithm for searching for numbers w (2; k), which does not use any tinsel like SAT-solver.  We will write in C ++ (I use MS Visual Studio).  The basis of the algorithm is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(linker,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/STACK:64000000"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;bitset&gt; #include &lt;time.h&gt; #include &lt;memory.h&gt; using namespace std; #define N 178 #define K 5 #define BSET bitset&lt; N &gt; bool dfs( BSET &amp; A, BSET &amp; B ) { int i = choice( A, B ); if (i&lt;0) { for (int a=0; a&lt;N; a++) if (A[a]) cout &lt;&lt; "A"; else if (B[a]) cout &lt;&lt; "B"; else cout &lt;&lt; "?"; cout &lt;&lt; "\n"; return true; } A[i] = true; if (check(A, B)) { BSET A1 = A, B1 = B; if (reduce( A1, B1 )) if (dfs( A1, B1 )) return true; } A[i] = false; B[i] = true; if (check( A, B )) { BSET A1 = A, B1 = B; if (reduce( A1, B1 )) if (dfs( A1, B1 )) return true; } B[i] = false; return false; } int main() { freopen("input.txt","r",stdin); freopen("output.txt","w",stdout); BSET A, B; if (!dfs( A, B )) cout &lt;&lt; "No counterexamples\n"; cout &lt;&lt; "n=" &lt;&lt; N &lt;&lt; " k=" &lt;&lt; K &lt;&lt; "\n"; cout &lt;&lt; "time=" &lt;&lt; clock() &lt;&lt; "\n"; return 0; }</span></span></span></span></code> </pre><br>  The dfs procedure is the backbone of the algorithm.  The constants N and K (the length of the sequence and the length of the arithmetic progression, respectively) will be inserted into the code by the preprocessor as numbers, sometimes it helps the compiler to better optimize the code.  The sets A and B (elements of the sequence painted in the first and second colors, respectively) are specified by a bit mask of length N. Now you should hang the functions on the proposed backbone <br><br><ol><li>  choice - the choice of the element on which we will branch our tree. </li><li>  check ‚Äî Verifies that there is no arithmetic progression in the sequence of length K. </li><li>  reduce - painting of additional elements for which the color can be determined uniquely. </li></ol><br><br>  The choice function is one of the most interesting: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BSET &amp; A, BSET &amp; B )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( cost, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cost) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;N; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=<span class="hljs-number"><span class="hljs-number">1</span></span>; a+d*(K<span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;N; d++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt1=<span class="hljs-number"><span class="hljs-number">0</span></span>, cnt2=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[a+c*d]) cnt1 ++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (B[a+c*d]) cnt2 ++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt1==<span class="hljs-number"><span class="hljs-number">0</span></span> || cnt2==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!A[a+c*d] &amp;&amp; !B[a+c*d]) cost[a+c*d] += cnt1+cnt2+<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;N; a++) mx = max( mx, cost[a] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;N; a++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost[a] == mx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  The strategy for selecting an element, embedded in the choice, is as follows: the element that is included in the largest number of potential monochrome arithmetic progressions is selected.  But that‚Äôs not all: the more the potential progression of colored numbers, the greater the contribution it makes to the estimate.  As a rule, in splitting algorithms, you always need to choose the element that does everything as badly as possible and leads to a conflict (when the check function returns false).  Such a strategy often cuts out unnecessary branches, reducing the space of options. <br><br>  Now consider the check procedure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BSET &amp; A, BSET &amp; B )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;N; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=<span class="hljs-number"><span class="hljs-number">1</span></span>; a+d*(K<span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;N; d++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> f1=<span class="hljs-literal"><span class="hljs-literal">true</span></span>, f2=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) f1 &amp;= A[a+c*d]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) f2 &amp;= B[a+c*d]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f1 || f2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  This procedure is small, simple and understandable, so it makes no sense to dwell on it. <br><br>  Finally, the reduce procedure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BSET &amp; A, BSET &amp; B )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;N; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=<span class="hljs-number"><span class="hljs-number">1</span></span>; a+d*(K<span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;N; d++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt1=<span class="hljs-number"><span class="hljs-number">0</span></span>, cnt2=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[a+c*d]) cnt1 ++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (B[a+c*d]) cnt2 ++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt1+cnt2&lt;K) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt1 == K<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!A[a+c*d]) { B[a+c*d] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt2 == K<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>; c&lt;K; c++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!B[a+c*d]) { A[a+c*d] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!flag) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!check( A, B )) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  We are simply looking for progressions in which all elements except one are painted in one color, and one is not painted.  Well, actually, we paint it in the opposite color.  The flag variable holds in itself - we painted something on the current pass or not.  If not, we exit, otherwise we check for contradictions and if they are not, we go through all the progressions again. <br><br><h4>  results </h4><br>  The code was tested on a laptop Core i5 4Gb RAM.  With the values ‚Äã‚Äãof the parameters N = 177 K = 5, the following example was found in 2 minutes: <br><br> <code>BBBABBBBABB?BAAABABBBA?AABAAAABAAAABBBABAAABBBBABBBBABB?BAAABABBBAAAABAAAABAABABBBABAAABA <br> BBABBBBABBABAAABABBBAAAABAAAABAABABBBABAAABABBABBBBABB?BAAABABBBABAABAAAABAABABBBABAAAB?</code> <br> <br>  A and B are colors.  A question means that it does not matter to us what kind of color in a given position.  That is, in fact, we found as many as 32 examples of length 177, in which there is no monochrome arithmetic progression of length 5. <br><br>  On the parameters N = 178 K = 5, the code worked for 20.5 minutes and showed that there are no desired arithmetic progressions.  Not bad for <sup>2,178</sup> options in general. <br><br>  This code can be infinitely optimized - select the necessary data structures for quick execution of choice, check and reduce, search for a more optimal strategy for selecting an element for branching, or at least paint the very first selected element in only one color.  But this is already beyond the scope of this article. <br><br>  Of course, the code also works to calculate w (2; 3) and w (2; 4) (the whole thing was initially tested on them). <br><br>  What can be said about the case of K = 6?  More recently (in 2008) it was <a href="https://www.cs.umd.edu/~gasarch/TOPICS/vdw/1132.pdf">proved</a> that w (2; 6) = 1132 and this took about 250 days of computing on a cluster of 200 cores.  By the way, the implementation of their algorithm proves that w (2; 5) = 178, in less than 3 seconds on one core.  For the case K = 7, the question remains open. <br><br><h4>  Read </h4><br><ol><li>  <a href="http://compsciclub.ru/node/455">Splitting</a> <a href="http://compsciclub.ru/node/454">algorithms</a> on Lectorium (video, lecture slides) </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%259A%25D0%25B5%25D1%2580%25D0%25B1%25D0%25BE%25D1%2588%25D0%25B0">Bron-Kerbosh</a> search <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%259A%25D0%25B5%25D1%2580%25D0%25B1%25D0%25BE%25D1%2588%25D0%25B0">algorithm</a> for all clicks in the graph (in fact, the splitting algorithm) </li><li>  DPLL-algorithm on Wikipedia ( <a href="http://ru.wikipedia.org/wiki/DPLL-%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">rus</a> , <a href="http://en.wikipedia.org/wiki/DPLL_algorithm">eng</a> ) </li><li>  Van der Waerden <a href="http://en.wikipedia.org/wiki/Van_der_Waerden%2527s_theorem">theorem</a> and <a href="http://en.wikipedia.org/wiki/Van_der_Waerden_number">numbers</a> (eng) </li><li>  A. Ya. Khinchin.  <a href="http://ilib.mccme.ru/djvu/hinchin-3zhem.htm">Three Pearls of Number Theory</a> </li><li>  <a href="http://www.math.u-bordeaux1.fr/~ybilu/various/habtalk/indexru.html">Bible Code, Ramsey Theory, and the Existence of God</a> </li><li>  Ronald L. Graham, Joel X. Spencer.  <a href="http://www.ega-math.narod.ru/Nquant/Ramsey.htm">Ramsey Theory</a> </li><li>  RS Stevens, R. Shantaram.  <a href="http://www.ams.org/journals/mcom/1978-32-142/S0025-5718-1978-0491468-X/S0025-5718-1978-0491468-X.pdf">Computer-Generated van der Waerden Partitions</a> (eng, pdf) </li><li>  Michal Kouril, Jerome L. Paul.  <a href="https://www.cs.umd.edu/~gasarch/TOPICS/vdw/1132.pdf">The van der Waerden Number W (2,6) Is 1132</a> (eng, pdf) </li></ol><br>  PS Not all the links were read deeply, so if any link is really off topic, I‚Äôll remove it. </div><p>Source: <a href="https://habr.com/ru/post/224069/">https://habr.com/ru/post/224069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224055/index.html">Active noise reduction of the shutter sound in the camera of the mobile device</a></li>
<li><a href="../224057/index.html">Open Terminal Client OTC-110 - works with Citrix</a></li>
<li><a href="../224063/index.html">Hacking the D-Link DSP-W215 Smart Plug: Again, Again, Again</a></li>
<li><a href="../224065/index.html">Python-digest # 28. News, interesting projects, articles and interviews [May 19, 2014 - May 25, 2014]</a></li>
<li><a href="../224067/index.html">Profishop - solution for receiving orders from wholesale customers</a></li>
<li><a href="../224071/index.html">Popularizing 3D printing in an adult way ... in schools</a></li>
<li><a href="../224073/index.html">Node.js: Overview of General Library Development Technologies</a></li>
<li><a href="../224075/index.html">Haskell. We test the multithreaded application</a></li>
<li><a href="../224077/index.html">Testing through abstract classes in TestNG</a></li>
<li><a href="../224079/index.html">Amazon hides books from Hachette</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>