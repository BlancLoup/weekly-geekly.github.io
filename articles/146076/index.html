<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inferno Part 0: namespaces</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FAQ: What is OS Inferno and why is it needed? 

 I promised, but have not yet written a post on how to install and run Inferno, and do incredible thin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inferno Part 0: namespaces</h1><div class="post__text post__text-html js-mediator-article">  <b>FAQ:</b> <a href="http://habrahabr.ru/post/145993/">What is OS Inferno and why is it needed?</a> <br><br>  I promised, but have not yet written a post on how to install and run Inferno, and do incredible things;  I have blown it up to a series of articles, of which this is the first, introductory part.  I'm going to talk a little bit about namespaces.  This is a critical part of the OS, and one of those things that strongly distinguishes Plan 9 and Inferno from what is currently running on your computer. <br><br>  Inferno is little known, and I do not intend to evangelize it.  I want to help bridge the gap between history and practice to explain how to use Inferno, and why it works the way it works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will have to deviate slightly to the side.  I'm going to talk about the evolution of namespaces, not quite in chronological order, rather in the order of development of possibilities, and then show how to use the capabilities of Inferno. <br><a name="habracut"></a><br><h4>  Content </h4><br><ul><li>  <a href="https://habr.com/ru/post/146076/">Dos</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Unix, Linux</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Plan 9, Inferno</a> </li><li>  <a href="https://habr.com/ru/post/146076/">‚Ä¶ Well?</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Finally, something that you can dial</a> <br><ul><li>  <a href="https://habr.com/ru/post/146076/">root is not needed for mounting</a> </li><li>  <a href="https://habr.com/ru/post/146076/">mount -o loop and FUSE are not needed</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Drivers in the kernel are not needed</a> </li><li>  <a href="https://habr.com/ru/post/146076/">chroot is not needed</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Simlinks are not needed</a> </li><li>  <a href="https://habr.com/ru/post/146076/">$ PATH, $ LDPATH and root privileges are not needed to install software</a> </li><li>  <a href="https://habr.com/ru/post/146076/">NFS is not needed</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/146076/">Powerful primitives mean you will never regret</a> </li><li>  <a href="https://habr.com/ru/post/146076/">Somewhere in the future</a> </li><li>  <a href="https://habr.com/ru/post/146076/">To be continued</a> </li></ul><br><a name="dos"></a><h4>  Dos </h4><br>  Remember DOS?  You had A: and B :, your floppy drives.  Was C :, your hard drive, etc.  You had a directory hierarchy on each of these disks.  (Let us omit the extra details.) You can think of this as a flat, high-level, single-letter, namespace bound to the gland.  One disk - one letter. <br><br><a name="nix"></a><h4>  Unix, Linux </h4><br>  In Unix, however, there was a top-level directory, "/".  The root disk was mounted there, and all other disks were mounted in subdirectories of the root directory, in subdirectories of subdirectories where you would like to see this disk.  You did not need to know what partition or disk, unless you were engaged in setting up the system or free space was running out on one of the partitions.  You can think of it as a hierarchical namespace common to the entire OS. <br><br>  This is a much more flexible and powerful approach.  Programs and users do not need to know what is on what disk. <br><br>  Later, a new type of file system appeared in Unix: synthetic.  For example, / proc.  On Linux, there is also / sys, and it is not rare that / dev is also a synthetic file system.  There is no physical disk on which files of these file systems would be stored, but, nevertheless, programs do not need to know anything about it.  Files are visible in the namespace just like any other files, and programs do not need to be modified so that they can read or write files in these file systems. <br><br>  In a sense, between them there are file systems that, although they store files on the disk as usual, but the user cannot know for sure or prove this.  For example, NFS is a remote service containing a hierarchy of files and directories. <br><br>  Next is <a href="http://fuse.sourceforge.net/">FUSE</a> , which provides file systems in user space.  Using FUSE to interact with the local OS kernel, and having realized what you were going to write a driver for, you can create a service for any synthetic file system ‚Äî without having to write a real driver for the OS kernel.  (I keep quiet about BSD; there seem to be fewer features from Plan 9, although <a href="http://dragonflybsd.org/">DragonFly</a> developed some interesting ideas.) <br><br>  On the other hand, since the namespace is common to the entire system, you need to be root in order to change it.  Imagine a random user who has mounted something on top of / sbin, having even killed the umount command.  Custom mount is a minor exception, in a sense, a crutch that does not fundamentally change anything: you can mount the FUSE file system in any _ your_ directory.  (By the way, Linux has a driver for 9P2000, the protocol used by Plan 9 and Inferno.) <br><br>  Previously, the file system could only be mounted in one place.  Linux Bind mounts provide a bit more flexibility - if the file system (or part of it) is already available somewhere in the namespace, it can be connected to another location via <code>mount --bind</code> .  This is a relatively recent addition, and before the 2.6.26 kernel it was impossible to attach the same file system to one place in read-write mode and at the same time to another in read-only mode. <br><br><a name="inferno"></a><h4>  Plan 9, Inferno </h4><br>  Plan 9 and Inferno took several large chunks of the historical semantics of Unix and threw them out of the window, threw out some of the key assumptions of the OS, assumptions that were largely implied and implicit.  I'm talking about Inferno now, but almost all of this also applies to (and first appeared in) Plan 9. When I say ‚Äúin Inferno‚Äù you can safely add in brackets ‚Äúand in Plan 9‚Äù.  These assumptions are not specified in any particular order, I simply numbered them for convenience. <br><br>  The first assumption that was easiest to break, and perhaps the most obvious in retrospect, is that the files and directories in the namespace represent objects on the disk. <br><br>  The second assumption is that there is a one-to-one connection between file systems and mount points.  Those.  that this file system is connected only in one place, and that only this one file system is connected to this place.  Getting rid of this assumption means that the file system and the place where it is connected are independent of each other, and that any number of file systems can be connected to the same place. <br><br>  The third assumption is that there is a one-to-one relationship between the operating system and the namespace.  If namespace changes are visible only to the process that has changed the namespace and its descendants, there will be no need to protect users from namespace changes made by other users, and the restriction of who can install what and where will be removed.  It is enough for the user to have read access to the file system in order to mount it. <br><br>  Throwing out these assumptions about namespaces allowed us to get a much more powerful system, and this difference may not be so obvious at first glance, but in fact is as big as the difference between DOS and Unix namespaces. <br><br>  These three assumptions were violated to varying degrees in Unix-like operating systems, and with varying degrees of success.  The first assumption was successfully violated in Unix.  You have / proc, for example, in almost all Unix.  FUSE allowed users to mount file systems, even to hide them (not perfect, of course) from other users, which gave the semblance of a personal namespace, almost breaking the third assumption.  Bind mounts made it possible for one part of the namespace to appear in somewhere in another part, approaching a violation of the second assumption, but requiring root.  Union mounts also made their way to Unix, it seems.  But, with the exception of the first assumption, all these solutions are not complete.  What if we start from the beginning without dragging Unix luggage? <br><br>  Since the namespace is now for each process its own (more precisely, any process can, but is not required to fork the namespace), anyone can mount anything anywhere, or connect (bind) anything anywhere, without creating any problems security.  Since the mount point can contain any number of mounted systems, and all will be simultaneously available, it becomes possible to overlay one file system to another.  Since any file system can be ‚Äúreal‚Äù or ‚Äúsynthetic‚Äù as long as it uses the appropriate protocol (9P2000 in the case of Inferno), anything can be a file system and any program that works with files can use it. <br><br>  Many things that are either hacks or curved solutions suddenly disappear, since they are no longer necessary.  Obviously, much of what has been delegated to root is no longer needed, as is sudo.  chroot is no longer needed.  Symbolic links are not needed.  A huge number of drivers built into the OS kernel are not needed.  NSF and / etc / exports are not needed (good riddance).  <code>mount -o loop</code> not needed.  <code>mount --bind</code> not needed.  FUSE is not needed.  Even $ PATH is no longer needed, and with it the need to be root to install software. <br><br><a name="so"></a><h4>  ‚Ä¶ Well? </h4><br>  One of the things that annoys me in the documentation for Inferno (and Plan 9) is that there are research articles, man pages, source code, but almost no textbooks or howto documents.  Maybe I'm spoiled by the Linux that comes with the <a href="http://www.faqs.org/docs/Linux-mini/Coffee.html">HOWTO how to make coffee</a> .  Getting started is not an easy task, especially if you don‚Äôt know enough about the system to use the system to study yourself.  You try, but there is an unfamiliar shell that launches unfamiliar commands, and the man pages written as a reference book do not really help. <br><br>  So I can evaluate the document trying to answer the question ‚ÄúSo?  I heard tempting promises before.  How can I use it? ‚ÄùAnd I'm going to combine all this with a few concrete examples, explaining what's going on. <br><br><a name="type"></a><h4>  Finally, something that you can dial </h4><br>  Remember all these things that are no longer needed?  Each of them was replaced by something better, and some of them by several things, each one better.  I‚Äôm going to (for simplicity) ignore authentication in these examples, but I‚Äôll say that you have a choice of authentication methods and encryption in Inferno. <br><br><a name="type-root"></a><h5>  root is not needed for mounting </h5><br>  It's pretty simple: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> <span class="hljs-string"><span class="hljs-string">'#p'</span></span> /n/prog</code> </pre><br>  This mounts the prog file system (analogous to / proc) to / n / prog.  By the way, you can manage, debug, and do everything normally with running processes through the / prog file system, just like in Unix.  The difference is that if you locally mount / prog of a remote machine, you can do all these things with remote processes without any ssh and even without running a debugger on the remote machine.  Yes, you can execute <code>kill 15</code> locally and this will kill process 15 on the remote machine. <br><br><a name="type-loop"></a><h5>  mount -o loop and FUSE are not needed </h5><br>  I have a bunch of .iso files on my computer.  Suppose they are in / n / cds, and I want to connect one of them: <br><pre> <code class="bash hljs">; 9660srv /n/cds/dfly-i386-3.0.2_REL.iso /n/dfly ; ls /n/dfly</code> </pre><br>  Now the current process and its descendants can see the contents of this CD.  Nothing much is required;  <a href="http://man.cat-v.org/inferno/4/dossrv">9660srv (4)</a> knows how to read the ISO-9660 file system on the one hand and supports the 9P2000 protocol on the other. <br><br>  Inferno also comes bundled with, for example, <a href="http://man.cat-v.org/inferno/4/tarfs">tarfs (4)</a> , which treats the tar archive as a read-only file system. <br><br><a name="type-drv"></a><h5>  Drivers in the kernel are not needed </h5><br>  Well, most.  Those that do not just export the file system, and finally you can forget about ioctl ().  The drivers provided by the kernel can be seen in the / dev / drivers file, and this is a rather short list, more concise than the output of <code>lsmod</code> on a typical Ubuntu machine or even Arch. <br><br>  Where you need a kernel driver to support the new file system on most operating systems, Inferno does not need modprobe (and thus root) and does not touch the kernel to add a new file system.  You can get ext2 support (read-only) by downloading <a href="http://ueber.net/code/r/ext2fs">ext2fs</a> , just like the kernel did not need to know about ISO-9660 in the example above. <br><br><a name="type-chroot"></a><h5>  chroot is not needed </h5><br>  Since the process can create a namespace for itself, everything that can be dangerous to show to a non-trusted process can be unmounted from the namespace, and the <a href="http://man.cat-v.org/inferno/2/sys-pctl">pctl (2)</a> system call can be used to <a href="http://man.cat-v.org/inferno/2/sys-pctl">prevent the</a> process from mounting the drivers.  An extreme example that unmounts everything (and therefore will not be able to do anything except use the shell built-in functionality): <br><pre> <code class="bash hljs">; load std ; pctl newns ; pctl nodevs ; unmount / ; ls / sh: ls: <span class="hljs-string"><span class="hljs-string">'./ls'</span></span> file does not exist</code> </pre><br>  Of course, you need to act a little more carefully than just unmount everything if you want to get something useful, but the idea is simple. <br><br>  You can also make a temporary sandbox, if you want, by mounting the file system in memory over the root directory: <br><pre> <code class="bash hljs">; mount -bc {memfs -s} / ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Mad with power! &gt; /asdf</code> </pre><br>  And, of course, / asdf will not appear anywhere.  (It should be noted that this only applies to the creation of new files.) <br><br><a name="type-symlink"></a><h5>  Simlinks are not needed </h5><br>  bind solves this problem by providing the ability to put some directories on top of others.  For example, I like the tinytk icon set more than the default icons, so I overlap the default icons with them before running the window manager: <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> -bc /icons/tinytk /icons/tk</code> </pre><br>  You can even put one file on top of another: <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Hello &gt; some-file ; <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> some-file /NOTICE ; cat /NOTICE Hello</code> </pre><br>  Since symlinks are not needed and are missing in Inferno, the problem of circular references in the file system almost disappears. <br><br><a name="type-path"></a><h5>  $ PATH, $ LDPATH and root privileges are not needed to install software </h5><br>  I hate messing with $ PATH.  Large chunks of my .bashrc are dedicated to figuring out who goes first, and not adding redundant paths or paths that point to binaries for other architectures.  I have <a href="http://swtch.com/plan9port/">Plan 9 Port</a> installed, but I don't want the Plan 9 man version to conflict with the Linux version, for example. <br><br>  In Inferno, everything you want to run is in / dis (/ bin in Plan 9).  If you want to run programs from another location, you simply connect it before or after / dis. <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> -bc <span class="hljs-variable"><span class="hljs-variable">$home</span></span>/dis /dis</code> </pre><br>  So if you want to install something, but you cannot write to / dis, install it wherever you want, and connect it over / dis.  sudo is not required.  The same goes for / lib and / module. <br><br><a name="type-nfs"></a><h5>  NFS is not needed </h5><br>  I'm going to ignore authentication (the -A flag) and encryption, so we will export something <a href="http://man.cat-v.org/inferno/4/memfs">unimportant</a> : <a href="http://man.cat-v.org/inferno/4/memfs">memfs (4)</a> again.  First car: <br><pre> <code class="bash hljs">; mount -c {memfs -s} /n/mem ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> something &gt; /n/mem/asdf ; listen -A <span class="hljs-string"><span class="hljs-string">'tcp!*!1234'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> /n/mem &amp; }</code> </pre><br>  Second car: <br><pre> <code class="bash hljs">; mount -A <span class="hljs-string"><span class="hljs-string">'tcp!thefirstmachine!1234'</span></span> /n/remotememfs ; cat /n/remotememfs/asdf something</code> </pre><br>  Since most file server commands can work via stdin / stdout instead of connecting to a mount point, the file system does not even need to be locally mounted to make it accessible over the network: <br><pre> <code class="bash hljs">; styxlisten -A <span class="hljs-string"><span class="hljs-string">'tcp!*!1234'</span></span> {memfs -s}</code> </pre><br>  And on the second car: <br><pre> <code class="bash hljs">; mount -Ac <span class="hljs-string"><span class="hljs-string">'tcp!thefirstmachine!1234'</span></span> /n/remotememfs</code> </pre><br>  The <a href="http://man.cat-v.org/inferno/1/listen">listen (1) and dial (1)</a> commands are simply convenient wrappers for interacting with the / net file system, which is the interface to the network for Inferno.  Sockets in Unix are handled by the BSD sockets library (with the corresponding system calls) and are much more difficult to use.  You can think of listen and dial as analogous to netcat.  styxlisten is the same, only expects to transmit the 9P2000 protocol (also called Styx until it was accepted into Plan 9) instead of a stream of bytes. <br><br><a name="power"></a><h4>  Powerful primitives mean you will never regret </h4><br>  All this is achieved by several short commands, which themselves are just wrappers around Inferno system calls.  You have <a href="http://man.cat-v.org/inferno/1/bind">bind (1), mount (1), and unmount (1)</a> .  If you need introspection, <a href="http://man.cat-v.org/inferno/1/ns">ns (1)</a> will help you. <br><br>  Representation of all OS objects as file systems means that programs like cat, sed and echo can be used for, for example, network access using the <a href="http://man.cat-v.org/inferno/3/ip">ip (3)</a> file system.  <a href="http://man.cat-v.org/inferno/4/ftpfs">ftpfs (4)</a> allows you to use ls and cp without an interactive client, which makes scripting easier (no need to redirect through an FTP client).  In fact, your scripts do not need to know at all that they work with an FTP server and not with a regular file on disk.  <a href="http://ueber.net/code/r/zipfs">zipfs</a> allows you to mount a .zip file.  By combining them, you can mount .iso, which is inside .zip, which is on the FTP server, and then copy individual files from it. <br><br><a name="future"></a><h4>  Somewhere in the future </h4><br>  We are already at an interesting point.  Most of the population owns at least a laptop and a smartphone, and, of them, most also own a home computer, have a computer at work, a tablet, etc.  In the heyday of Unix, there was one computer and many users.  This seems obvious, but we are rapidly approaching the point when the general case will be many computers for one user and not vice versa. <br><br>  Managing all these resources (disk and CPU, in particular) is already a big problem.  File synchronization, contact synchronization, etc.  If your phone does not have enough resources to process something, you need to go to a regular computer (physically or via ssh).  If you want to watch a movie on your phone, you need to copy it there.  What do you do if you read the article on the phone and decide to continue reading on the laptop?  Do you send email or IM?  (This is still better than DBUS, but this is a digression.) <br><br>  I do not think that this will continue.  As a temporary solution, you can give all your data to Google, Facebook, or any ‚Äúcloud‚Äù service, but this solution leaves much to be desired (and listing the reasons is another digression). <br><br>  Software solution to the problem of managing computational resources and combining all these machines (local and remote) is inevitable.  At least at the moment, I see Inferno as the best candidate for the platform that will make all this possible.  If this does not fully explain why I suddenly fell in love with this system, then at least I do it partially. <br><br><a name="continue"></a><h4>  To be continued </h4><br>  This description is very superficial.  ‚ÄúEverything is a file system‚Äù is only one of the great ideas on which Inferno is built. </div><p>Source: <a href="https://habr.com/ru/post/146076/">https://habr.com/ru/post/146076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146067/index.html">Pygame player</a></li>
<li><a href="../146068/index.html">Password Generator / Validator for LinkedIn Hacking</a></li>
<li><a href="../146070/index.html">Are you annoyed by the permanent ‚ÄúAccess to publication closed‚Äù?</a></li>
<li><a href="../146071/index.html">The simplest WDM driver</a></li>
<li><a href="../146074/index.html">Basic principles of working with the Catalyst MVC Framework</a></li>
<li><a href="../146077/index.html">Formation of high-level signs using a large-scale learning experiment without a teacher</a></li>
<li><a href="../146078/index.html">What are the most promising new gTLDs?</a></li>
<li><a href="../146079/index.html">Myself DynDNS or Managed DNS implementation via PowerShell</a></li>
<li><a href="../146080/index.html">ASM to Unix</a></li>
<li><a href="../146081/index.html">ABBYY Cup: Debriefing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>