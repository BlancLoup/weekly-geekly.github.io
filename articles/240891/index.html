<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AsyncCollections: the story of one bike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since ancient times, I have been a big fan of System.Collections.Concurrent and the BlockingCollection in particular. How many times this engineering ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AsyncCollections: the story of one bike</h1><div class="post__text post__text-html js-mediator-article">  Since ancient times, I have been a big fan of System.Collections.Concurrent and the BlockingCollection in particular.  How many times this engineering marvel has rescued in the most diverse situations - it is impossible to count. <br><br>  Since a little less ancient times, async / await has become a part of everyday life.  It would seem that life is beautiful, but there is one ‚Äúbut‚Äù: you don‚Äôt really want to mix asynchronous code with a blocking code.  And BlockingCollection, as it is easy to guess (at least from the name), in some cases, the flow blocks. <br><a name="habracut"></a><br><h3>  False trail: Nito.AsyncEx </h3><br>  One day I came across a reference to the <a href="https://github.com/StephenCleary/AsyncEx">Nito.AsyncEx</a> library written by Stephen Cleary, in which there was a class with the intriguing name AsyncCollection.  However, having looked at what is under his hood, I was left in some bewilderment: there was AsyncLock from the same library, hung on all the actions on the wrapped IProducerConsumerCollection.  AsyncLock, in turn, is actively using the most ordinary lock-ups and a thin layer of magic, which I suddenly didn't want to unravel.  Even if this implementation does what is stated, it looks a bit sophisticated, monstrous, and perhaps not very optimal.  Is it really impossible to solve this problem more accurately? <br><br>  We all know what such thoughts are fraught with.  Visual Studio, New project ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  AsyncQueue </h3><br>  To begin with, let's define what we all want from our asynchronous collection.  As a starting point, you can take the following interface: <br><br><pre><code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface IAsyncCollection&lt;T&gt;: IEnumerable&lt;T&gt; { <span class="hljs-type"><span class="hljs-type">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( T item ); Task&lt;T&gt; TakeAsync(); }</code> </pre> <br>  In addition, for simplicity, we will focus on the fact that our collection is a queue.  Why the queue?  Yes, for about the same reason that the default queue is used in the BlockingCollection. <br><br>  Then comes the intense work of thought associated with an attempt to determine the possible states of our collection.  At first glance, there may be 3 of them: <br><br>  <b>1.</b> There are no elements in the collection, but there were calls to TakeAsync (), which need to be completed Task when the elements appear (for simplicity and brevity, I will call them awaiter later).  In this case: <br><ul><li>  Awaiter s obviously need to be stored somewhere.  The queue suggests itself, specifically - the ConcurrentQueue. </li><li>  If a call to TakeAsync () occurs, we have a new awaiter, throwing it into the awaiter queue. </li><li>  If the Add () call occurs, we have a new element that can be used to instantly take one of the awaiter and complete it. </li></ul><br>  <b>2.</b> Awaiter is not present, but there were calls to Add ().  The situation is completely symmetrical to the previous one: <br><ul><li>  Items need to be stored somewhere.  Where?  In ConcurrentQueue, where else. </li><li>  If the Add () call occurs, a new item appears, we throw it into the item queue. </li><li>  If a TakeAsync () call occurs, a new awaiter appears, which can be instantly terminated by taking the top item from the queue. </li></ul><br>  <b>3.</b> Both queues ‚Äî both the awaiter queue and the item queue ‚Äî are empty.  Depending on the following action, we go either to state 1 or to state 2: <br><ul><li>  If Add () is called, a new item appears, try to take awaiter for it from the queue, it's empty, try to add it to the item queue ... </li><li>  At this very moment, a call to TakeAsync () occurs, a new awaiter appears, we are trying to take an element from the queue for it; </li><li>  Oops.  We broke everything: awaiter and the element are sitting in different lines and waiting for each other.  What to do? </li></ul><br>  I don‚Äôt want to hang locks, we didn‚Äôt go away from the implementation of Nito.AsyncEx, which was stuffed with them.  What do ConcurrentQueues do in such cases?  They understand that right now an operation is underway in the next thread, which is about to end, and after which we can do something useful, create SpinWait and turn on hold.  Let's try to reproduce this idea with us.  Need to: <br><br><ul><li>  understand what state we are in (1 or 2) </li><li>  report at the same time that we started our operation, be it adding an awaiter or adding an element </li><li>  depending on the state, either add an awaiter / element to the queue, or spin until another element / awaiter is added to the opposite queue, which we will immediately take away </li></ul><br>  The first two requirements very much resemble the work of the Interlocked class;  to store the state, you can use something like a queue balance: TakeAsync () atomically reduces the balance by one, Add () atomically increases it.  And by the value of the balance, which returns Interlocked.Increment / Interlocked.Decrement, you can find out that a new element / awaiter is coming, even before it appears in the corresponding queue.  Pretty chatter, try to code all of the above: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AsyncQueue&lt;T&gt;: IAsyncCollection&lt;T&gt; { private ConcurrentQueue&lt;T&gt; _itemQueue = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConcurrentQueue&lt;T&gt;(); private ConcurrentQueue&lt;TaskCompletionSource&lt;T&gt;&gt; _awaiterQueue = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConcurrentQueue&lt;TaskCompletionSource&lt;T&gt;&gt;(); // _queueBalance &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> means there are free awaiters <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> enough items. // _queueBalance &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> means the opposite <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. private long _queueBalance = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( T item ) { long balanceAfterCurrentItem = Interlocked.Increment( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _queueBalance ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( balanceAfterCurrentItem &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { // Items are dominating, so we can safely <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the queue. _itemQueue.Enqueue( item ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Ther<span class="hljs-string"><span class="hljs-string">e's at least one awaiter available or being added as we'</span></span>re speaking, so w<span class="hljs-string"><span class="hljs-string">e're giving the item to it. TaskCompletionSource&lt;TItem&gt; awaiter; SpinWait spin = new SpinWait(); while ( !_awaiterQueue.TryDequeue( out awaiter ) ) spin.SpinOnce(); awaiter.SetResult( item ); } } public Task&lt;T&gt; TakeAsync() { long balanceAfterCurrentAwaiter = Interlocked.Decrement( ref _queueBalance ); if ( balanceAfterCurrentAwaiter &lt; 0 ) { // Awaiters are dominating, so we can safely add a new awaiter to the queue. var taskSource = new TaskCompletionSource&lt;TItem&gt;(); _awaiterQueue.Enqueue( taskSource ); return taskSource.Task; } else { // There'</span></span>s at least one item available <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> being added, so w<span class="hljs-string"><span class="hljs-string">e're returning it directly. T item; SpinWait spin = new SpinWait(); while ( !_itemQueue.TryTake( out item ) ) spin.SpinOnce(); return Task.FromResult( item ); } } }</span></span></code> </pre><br>  We are testing, we are surprised to find that it seems to even work.  Victory?  On the one hand, yes, on the other hand, the overwhelming creative impulse is so easy to stop ... <br><br><h4>  Useful (and not so) buns </h4><br>  Let's look closely at what we did.  Synchronous Add (), asynchronous TakeAsync () ... Stop, asynchronous method without the possibility of its cancellation?  Disorder.  We fix. <br><br>  First, when canceling CancellationToken, you must immediately cancel the corresponding task: <br><br><pre> <code class="hljs ruby"> public Task&lt;TItem&gt; TakeAsync( CancellationToken cancellationToken ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( balanceAfterCurrentAwaiter &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { var taskSource = new TaskCompletionSource&lt;TItem&gt;(); _awaiterQueue.Enqueue( taskSource ); cancellationToken.Register( state =&gt; { TaskCompletionSource&lt;T&gt; awaiter = state as TaskCompletionSource&lt;T&gt;; awaiter.TrySetCanceled(); }, taskSource, useSynchronizationContext : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> taskSource.Task; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } }</code> </pre><br>  Secondly, we obviously cannot pick out canceled awaiter from somewhere in the middle of the queue, so we need to teach Add () to skip this canceled awaiter.  The balance is magically maintained automatically: <br><br><pre> <code class="hljs pgsql"> private <span class="hljs-type"><span class="hljs-type">bool</span></span> TryAdd( TItem item ) { long balanceAfterCurrentItem = Interlocked.Increment( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _queueBalance ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( balanceAfterCurrentItem &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { _itemQueue.Enqueue( item ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TaskCompletionSource&lt;T&gt; awaiter; SpinWait spin = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_awaiterQueue.TryDequeue( <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> awaiter ) ) spin.SpinOnce(); // <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the cancellation occurred earlier. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> awaiter.TrySetResult( item ); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( TItem item ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !TryAdd( item ) ) ; }</code> </pre><br>  Thirdly, the old TakeAsync () method (which, without CancellationToken) can generally be transferred to an IAsyncCollection interface as an extension: <br><br><pre> <code class="hljs actionscript"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEnumerable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ int Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Add( T item ); Task&lt;T&gt; TakeAsync( CancellationToken cancellationToken ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncCollectionExtensions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; TakeAsync&lt;T&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IAsyncCollection&lt;T&gt; collection ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.TakeAsync( CancellationToken.None ); } }</code> </pre><br>  By the way, about the IAsyncCollection.  If you look closely, then our implementation of AsyncQueue does not have to be nailed to a ConcurrentQueue; any thread-safe IProducerConsumerCollection is suitable for storing items.  For example, ConcurrentStack.  Therefore, you can do this: <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncCollection</span></span></span><span class="hljs-class">&lt;TItem, TItemQueue&gt;:</span></span> IAsyncCollection&lt;TItem&gt; where TItemQueue: IProducerConsumerCollection&lt;TItem&gt;, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TItemQueue _itemQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TItemQueue(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentQueue&lt;TaskCompletionSource&lt;TItem&gt;&gt; _awaiterQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;TaskCompletionSource&lt;TItem&gt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... } public class AsyncQueue&lt;T&gt;: AsyncCollection&lt;T, ConcurrentQueue&lt;T&gt;&gt; { } public class AsyncStack&lt;T&gt;: AsyncCollection&lt;T, ConcurrentStack&lt;T&gt;&gt; { }</span></span></code> </pre><br>  On the one hand, I would like not to produce type parameter, but simply to take an IProducerConsumerCollection in the constructor, but the trouble is: we can slip a collection that is already referenced from the outside and into which we can tap elements outside ( part of our elements), there having destroyed the synchronization between the real state of the collection and the stored balance.  The factory method has the same problem, so you have to create the collection yourself. <br><br><h4>  Benchmarks! </h4><br>  It is time to measure the speed of our bike.  To run benchmarks, there is a <a href="https://www.nuget.org/packages/BenchmarkDotNet/">BenchmarkDotNet</a> package that implements a bunch of small details that should be considered when running benchmarks, so that we zayuzay.  The general idea of ‚Äã‚Äãthe benchmark is as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncQueueBenchmark</span></span></span><span class="hljs-class"> { private const int _consumerThreadCount = 3; private const int _producerThreadCount = 3; private const int _itemsAddedPerThread = 10000; private const int _itemsAddedTotal = _producerThreadCount * _itemsAddedPerThread; private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAsyncCollection</span></span></span><span class="hljs-class">&lt;int&gt; _currentQueue; private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CancellationTokenSource</span></span></span><span class="hljs-class"> _cancelSource; private int _itemsTaken; //      private void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DdosCurrentQueue</span></span></span><span class="hljs-class">() { _consumerTasks = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Enumerable</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Range</span></span></span><span class="hljs-class">( 0, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_consumerThreadCount</span></span></span><span class="hljs-class"> ) .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Select</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Run</span></span></span><span class="hljs-class">( () =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RunConsumerAsync</span></span></span><span class="hljs-class">() ) ) .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ToArray</span></span></span><span class="hljs-class">(); _producerTasks = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Enumerable</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Range</span></span></span><span class="hljs-class">( 0, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_producerThreadCount</span></span></span><span class="hljs-class"> ) .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Select</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Run</span></span></span><span class="hljs-class">( () =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RunProducer</span></span></span><span class="hljs-class">() ) ) .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ToArray</span></span></span><span class="hljs-class">(); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WaitAll</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_producerTasks</span></span></span><span class="hljs-class"> ); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WaitAll</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_consumerTasks</span></span></span><span class="hljs-class"> ); } private async </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RunConsumerAsync</span></span></span><span class="hljs-class">() { try { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CancellationToken</span></span></span><span class="hljs-class"> cancelToken = _cancelSource.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Token</span></span></span><span class="hljs-class">; while ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_itemsTaken</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_itemsAddedTotal</span></span></span><span class="hljs-class"> &amp;&amp; !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancelToken</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsCancellationRequested</span></span></span><span class="hljs-class"> ) { int item = await _currentQueue.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TakeAsync</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancelToken</span></span></span><span class="hljs-class"> ); int itemsTakenLocal = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interlocked</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Increment</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ref</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_itemsTaken</span></span></span><span class="hljs-class"> ); if ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">itemsTakenLocal</span></span></span><span class="hljs-class"> &gt;= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_itemsAddedTotal</span></span></span><span class="hljs-class"> ) { _cancelSource.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cancel</span></span></span><span class="hljs-class">(); break; } } } catch ( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationCanceledException</span></span></span><span class="hljs-class"> ) { } } private void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RunProducer</span></span></span><span class="hljs-class">() { for ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> = 0; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_itemsAddedPerThread</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">++ ) { int item = 42; _currentQueue.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ); } }</span></span></code> </pre><br>  Those.  we simply take a fixed pack of elements, fi Ô¨Å e them in a queue in several streams, in parallel in several streams, we queue this queue, note how much time it takes.  We slip different implementations of IAsyncCollection, compare.  Participate in the race: <br><br>  <b>1.</b> Freshly AsyncQueue <br>  <b>2.</b> Nito.AsyncEx.AsyncCollection as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NitoAsyncCollectionAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; { private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nito</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncEx</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; _collection; public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NitoAsyncCollectionAdapter</span></span></span><span class="hljs-class">() { _collection = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nito</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncEx</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;(); } #region </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Members</span></span></span><span class="hljs-class"> public void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ) { _collection.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ); } public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TakeAsync</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">System</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Threading</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CancellationToken</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellationToken</span></span></span><span class="hljs-class"> ) { return _collection.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TakeAsync</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellationToken</span></span></span><span class="hljs-class"> ); } #endregion }</span></span></code> </pre><br>  <b>3.</b> BlockingCollection (well, how not to compare with it) in the form: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BlockingCollectionAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; { private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BlockingCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; _collection; public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BlockingCollectionAdapter</span></span></span><span class="hljs-class">() { _collection = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BlockingCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;(); } #region </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAsyncCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Members</span></span></span><span class="hljs-class"> public void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ) { _collection.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ); } public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TakeAsync</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">System</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Threading</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CancellationToken</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellationToken</span></span></span><span class="hljs-class"> ) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> item = _collection.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Take</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellationToken</span></span></span><span class="hljs-class"> ); return </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Task</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FromResult</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">item</span></span></span><span class="hljs-class"> ); } #endregion }</span></span></code> </pre><br>  Results: <br><pre> HellBrick.AsyncCollections.AsyncQueue: 1ms |  Stats: MedianTicks = 3368, MedianMs = 1, Error = 06.34%
 Nito.AsyncEx.AsyncCollection: 12ms |  Stats: MedianTicks = 40503, MedianMs = 12, Error = 31.36%
 System.Concurrent.BlockingCollection: 2ms |  Stats: MedianTicks = 7222, MedianMs = 2, Error = 38.82%
</pre><br>  The intuitive assessment of Nito.AsyncEx.AsyncCollection did not let down: this is really a monstrous slow down crap.  But the most interesting thing: we managed to overtake the BlockingCollection in performance and at the same time do without blocking threads.  Win!  Open the cake or any other bonus snacks and go further. <br><br><h3>  AsyncBatchQueue </h3><br>  I occasionally had to use a small wrapper over the BlockingCollection, which took on the input single elements and gave them packs of a certain size.  At the same time, if for a certain time the required number of elements did not accumulate, the timer worked and made the forced flush of what we managed to dial.  Who wants an asynchronous version of this thing?  I want to. <br><br>  To begin with, we will do without a timer and manual flush.  It is logical to store and deliver the assembled packs of elements using our new AsyncQueue tools: <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncBatchQueue</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _batchSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Batch _currentBatch; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsyncQueue&lt;IReadOnlyList&lt;T&gt;&gt; _batchQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncQueue&lt;IReadOnlyList&lt;T&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncBatchQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batchSize )</span></span></span><span class="hljs-function"> </span></span>{ _batchSize = batchSize; _currentBatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Batch( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T item )</span></span></span><span class="hljs-function"> </span></span>{ SpinWait spin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_currentBatch.TryAdd( item ) ) spin.SpinOnce(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Task&lt;IReadOnlyList&lt;T&gt;&gt; TakeAsync( CancellationToken cancellationToken ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _batchQueue.TakeAsync( cancellationToken ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Batch</span></span></span><span class="hljs-class">:</span></span> IReadOnlyList&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsyncBatchQueue&lt;T&gt; _queue; <span class="hljs-comment"><span class="hljs-comment">// ? public Batch( AsyncBatchQueue&lt;T&gt; queue ) { _queue = queue; } public bool TryAdd( T item ) { // ? } } }</span></span></code> </pre><br>  What is happening here: in the Add method, you need to try to add an element to the current batch and, if we have filled it, flip it in the _batchQueue.  In this case, the situation is quite possible when another stream has outstripped us, is currently engaged in adding / flush, but it has not yet managed to write a link to a (empty) batch in _currentBatch.  Hence the good old SpinWait. <br><br>  The main magic will be in the nested class Batch, the idea of ‚Äã‚Äãwhich is most brazenly borrowed from the implementation of the ConcurrentQueue (by the way, if anyone has not read the source, I recommend reading: there are many interesting things there).  This idea is as follows: <br><br><ul><li>  The elements are stored in a regular array, we know the size in advance. </li><li>  Problems with concurrency are solved using the Interlocked.Increment field, where the index of the last inserted element is stored. </li><li>  If the thread captures the last slot of the array, then it [the flow, not the slot] is responsible for flush the current batch. </li><li>  If the thread has captured a slot that goes beyond the array, then we are not lucky: this batch is already filled and the thread needs to spin in anticipation of a new </li></ul><br>  It looks something like this.  (Beware, the code is not yet viable! I‚Äôll explain why later.) <br><br><pre> <code class="hljs pgsql"> private <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Batch: IReadOnlyList&lt;T&gt; { private AsyncBatchQueue&lt;T&gt; _queue; private T[] _items; private <span class="hljs-type"><span class="hljs-type">int</span></span> _lastReservationIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; private <span class="hljs-type"><span class="hljs-type">int</span></span> _count = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Batch( AsyncBatchQueue&lt;T&gt; queue ) { _queue = queue; _items = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> T[ _queue._batchSize ]; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> TryAdd( T item ) { <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = Interlocked.Increment( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _lastReservationIndex ); // The <span class="hljs-keyword"><span class="hljs-keyword">following</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> someone has beaten us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the last slot <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> we have <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> the next batch comes along. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> &gt;= _queue._batchSize ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; // The <span class="hljs-keyword"><span class="hljs-keyword">following</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w<span class="hljs-string"><span class="hljs-string">e've taken the last slot, which means we'</span></span>re obligated <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> flush the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> batch <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> one. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> == _queue._batchSize - <span class="hljs-number"><span class="hljs-number">1</span></span> ) FlushInternal( _queue._batchSize ); _items[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] = item; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } private <span class="hljs-type"><span class="hljs-type">void</span></span> FlushInternal( <span class="hljs-type"><span class="hljs-type">int</span></span> count ) { _count = count; _queue._currentBatch = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Batch( _queue ); _queue._batchQueue.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( this ); } }</code> </pre><br>  Further, it would be nice to still implement IReadOnlyList.  Here one nuance comes up: no one guarantees that when we are flush or batch, all the elements of the array are filled with real data.  The stream that grabbed the last element could just be faster.  This suggests a solution: for each slot in the array, store a flag that determines whether the corresponding value can be read. <br><br><pre> <code class="hljs perl"> private class Batch: IReadOnlyList&lt;T&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... private bool[] _finalizationFlags; public Batch( AsyncBatchQueue&lt;T&gt; queue ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... _finalizationFlags = new bool[ _queue._batchSize ]; } public bool TryAdd( T item ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... _items[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] = item; _finalizationFlags[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] = true; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> true; } public T this[ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> &gt;= _count ) throw new IndexOutOfRangeException(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetItemWithoutValidation( <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ); } } private T GetItemWithoutValidation( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ) { SpinWait spin = new SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_finalizationFlags[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] ) spin.SpinOnce(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ]; } // ...     GetItemWithoutValidation }</code> </pre><br><br>  And now begins the real magic.  The problem is that in the code there are a lot of places where the compiler with the processor can spoil everything, rearranging the instructions in places and caching that which cannot be cached categorically. <br><br>  <b>1.</b> In AsyncBatchCollection.Add (), the _currentBatch value can be read once and cached, with the result that, if the batch is full, the thread will spin forever.  volatile to the rescue: <br><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncBatchQueue</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private volatile Batch _currentBatch; // ... }</span></span></code> </pre><br>  <b>2.</b> In the FlushInternal () method, batch can be added to the output queue before the _count field is filled.  We stick full fence: <br><br><pre> <code class="hljs pgsql"> private <span class="hljs-type"><span class="hljs-type">void</span></span> FlushInternal( <span class="hljs-type"><span class="hljs-type">int</span></span> count ) { _count = count; _queue._currentBatch = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Batch( _queue ); // The <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> fence ensures that the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> batch will never be added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the queue <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> _count <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>. Thread.MemoryBarrier(); _queue._batchQueue.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( this ); }</code> </pre><br>  <b>3.</b> In the TryAdd method, the write instructions in _items [index] and _finalizationFlags [index] can be swapped.  Again we stick in full fence: <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> T item </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... // The full fence prevents setting finalization flag before the actual item value is written. _items[ index ] = item; Thread.MemoryBarrier(); _finalizationFlags[ index ] = true; return true; }</span></span></code> </pre><br>  <b>4. An</b> inverse problem (reading an item before a flag) can occur in GetItemWithoutValidation.  We stick you-know-what: <br><br><pre> <code class="hljs pgsql"> private T GetItemWithoutValidation( <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ) { SpinWait spin = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_finalizationFlags[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] ) spin.SpinOnce(); // The <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> fence prevents reading item <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> finalization flag <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>. Thread.MemoryBarrier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ]; }</code> </pre><br>  <b>5.</b> Everything in the same method, the value _finalizationFlags [index] can be cached, because of which the thread will spin forever.  Usually, this is solved by hanging a volatile modifier on the field, but it is not possible to do this with an array element, so you understand: <br><br><pre> <code class="hljs axapta"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T GetItemWithoutValidation( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ) { SpinWait spin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_finalizationFlags[ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> ] ) { spin.SpinOnce(); <span class="hljs-comment"><span class="hljs-comment">// The full fence prevents caching any part of _finalizationFlags[ index ] expression. Thread.MemoryBarrier(); } // ... }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Here, by the way, it is worth making a small digression.</b> <div class="spoiler_text">  In the ConcurrentQueue, a similar problem is solved in a <a href="http://referencesource.microsoft.com/">very unusual way</a> : <br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> VolatileBool[] m_state; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> VolatileBool { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VolatileBool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { m_value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_value; }</code> </pre><br>  If VolatileBool were a class instead of a structure, everything would be extremely simple: even if a reference to a VolatileBool instance is cached somewhere, reading volatile m_value is guaranteed to return the actual value of the field.  Why this trick works with the structure, which in theory is supposed to be copied at the time of the call m_state [index], I did not understand. </div></div><br><br>  It seems that the dangerous places are over and the basic functionality should work (at least, I sincerely would like to believe in it). <br><br><h4>  Now we set the timer </h4><br>  Everything seems to be great, but there is one (already not related to multithreading) caveat: if the number of elements added to the collection is not a multiple of batchSize, then we will never see the rest.  Need the ability to do flush manually, and better by timer.  The easiest way is to make the call to the Flush () method attempt to immediately grab the last slot in the array, thus marking the batch as full.  At the same time, it is necessary to remember the last real _lastReservationIndex value, otherwise we will not be able to find out how many slots are actually occupied (spoiler: Interlocked.CompareExchange () comes to the rescue).  A total of 5 possible scenarios are possible: <br><br><ol><li>  _lastReservationIndex &lt;0. flush is nothing. </li><li>  _lastReservationIndex&gt; = _queue._batchSize.  FlushInternal () will execute the thread that grabbed the last slot, do not do anything. </li><li>  _lastReservationIndex is valid and we managed to atomically install it to _queue._batchSize.  We know the real number of elements in the array, you can do FlushInternal (). </li><li>  Between reading past _lastReservationIndex value and writing a new value to the same place, another thread crept in and grabbed the last element.  In fact, the situation repeats option number 2: do nothing. </li><li>  Same as # 4, but the batch is not full.  Spin, try again. </li></ol><br><pre> <code class="hljs lua"> public class AsyncBatchQueue&lt;T&gt;: IEnumerable&lt;IReadOnlyList&lt;T&gt;&gt; { // ... public void Flush() { SpinWait spin = new SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !_currentBatch.TryFlush() ) spin.SpinOnce(); } // ... private class Batch: IReadOnlyList&lt;T&gt; { // ... public bool TryFlush() { int expectedPreviousReservation = Volatile.Read( ref _lastReservationIndex ); // We don<span class="hljs-string"><span class="hljs-string">'t flush if the batch doesn'</span></span>t have any items <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> another thread is about to <span class="hljs-built_in"><span class="hljs-built_in">flush</span></span> it // However, we report success to avoid unnecessary spinning. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( expectedPreviousReservation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || expectedPreviousReservation &gt;= _queue._batchSize ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; int previousReservation = Interlocked.CompareExchange( ref _lastReservationIndex, _queue._batchSize, expectedPreviousReservation ); // Flush reservation has succeeded. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( expectedPreviousReservation == previousReservation ) { FlushInternal( previousReservation + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } // The following is <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> someone has completed the batch by the <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> we tried to <span class="hljs-built_in"><span class="hljs-built_in">flush</span></span> it. // Therefore the batch will be flushed anyway even <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we don<span class="hljs-string"><span class="hljs-string">'t do anything. // The opposite means someone has slipped in an update and we have to spin. return previousReservation &gt;= _queue._batchSize; } // ... } }</span></span></code> </pre><br>  Done!  It remains to hang the timer from above - this is a process so devoid of magic that I will try to do without the copy-related code.  Benchmarks also will not, because  I do not know with whom it would be possible to compare the performance. <br><br><h3>  What's next? </h3><br>  First, both the collections reviewed suffer from one subtle flaw.  If someone does Thread.Abort (), then at the most unexpected moment ThreadAbortException may crash and destroy the carefully maintained consistency of the state of the collections.  In the aforementioned ConcurrentQueue (and in a bunch of other places), this problem is solved in a very extravagant way: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Insert Thread.Abort()-safe code here }</span></span></code> </pre><br>  The case is quite rare, but just in case it would be nice to defend against it.  Maybe someday I'll do it anyway. <br><br>  Secondly, for happiness, we still lack at least one asynchronous collection: a prioritized queue.  And, unlike the BlockingCollection, a trivial implementation using TakeFromAny () is not visible on the horizon.  To be continued?.. <br><br><h3>  PS </h3><br>  For those who heroically read to the end: <br><br>  Nuget package: <a href="https://www.nuget.org/packages/AsyncCollections/">www.nuget.org/packages/AsyncCollections</a> <br>  Source code: <a href="https://github.com/HellBrick/AsyncCollections">github.com/HellBrick/AsyncCollections</a> <br><br>  If there is criticism, bugs, suggestions or just sound thoughts - write, I will be glad to discuss. </div><p>Source: <a href="https://habr.com/ru/post/240891/">https://habr.com/ru/post/240891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240881/index.html">The story of how Apple taught me to make a quality product</a></li>
<li><a href="../240883/index.html">Discover the Oro Platform</a></li>
<li><a href="../240885/index.html">How to change the parameters of accelerating the movement of the mouse cursor in Mac OS</a></li>
<li><a href="../240887/index.html">Why do I need a blog on Habr√©: experience Madrobots</a></li>
<li><a href="../240889/index.html">How to protect your server from the vulnerability POODLE SSLv3</a></li>
<li><a href="../240895/index.html">Blog PayAnyWay - everything you wanted to know, but were afraid to ask</a></li>
<li><a href="../240897/index.html">Another little engineering investigation or cry Yaroslavna</a></li>
<li><a href="../240899/index.html">Just the hard stuff: high performance computing for engineering and research tasks.</a></li>
<li><a href="../240901/index.html">Fly IQ4511 Tornado One Octa: ‚Äúflagship‚Äù, ‚Äúpremium‚Äù or ‚Äújust a smartphone‚Äù?</a></li>
<li><a href="../240903/index.html">From idea to business - or go with the flow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>