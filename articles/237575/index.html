<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Patching Linux processes on the fly with GDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Techniques for intercepting functions in Linux are well known and described on the Internet. The simplest method is to write a dynamic library with ‚Äúc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Patching Linux processes on the fly with GDB</h1><div class="post__text post__text-html js-mediator-article"> Techniques for intercepting functions in Linux are well known and described on the Internet.  The simplest method is to write a dynamic library with ‚Äúclone functions‚Äù and use the LD_PRELOAD mechanism to redefine the import table at the process loading stage. <br><br>  The disadvantage of LD_PRELOAD is that it is necessary to control the process start  To intercept functions in an already running process or functions that are not in the import table, you can use ‚Äúsplicing‚Äù - recording the transition command to the interceptor to the beginning of the intercepted function. <br><br>  It is also known that in Python there is a <code>ctypes</code> module <code>ctypes</code> allows you to interact with the data and functions of the C language (that is, a large number of dynamic libraries with C interface).  Thus, nothing interferes with intercepting a process function and sending it to Python with a method wrapped in a C-callback using <code>ctypes</code> . <br><a name="habracut"></a><br>  For intercepting control and loading code into a target process, it is convenient to use the GDB debugger, which supports writing extension modules in Python ( <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html">https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html</a> ). <br><div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  The example code is given completely at the end of the article and consists of two files: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  pyinject.py - GDB extension </li><li>  hook.py - module with interceptor functions </li></ul><br>  From the GDB side, it is convenient to issue the code as a user command.  A new command can be created by inheriting from the <code>gdb.Command</code> class.  When using a command in GDB, the method <code>invoke(argument, from_tty)</code> will be called. <br><br>  You can also create custom parameters by inheriting from <code>gdb.Parameter</code> .  In the sample article, it is used to set the name of the file with interception functions. <br><br>  Connecting to the running <code>PID</code> process and loading the module is convenient to do immediately when GDB starts. <br><pre> <code class="bash hljs">gdb -ex <span class="hljs-string"><span class="hljs-string">'attach PID'</span></span> -ex <span class="hljs-string"><span class="hljs-string">'source pyinject.py'</span></span> -ex <span class="hljs-string"><span class="hljs-string">'set hookfile hook.py'</span></span></code> </pre>  The field of this debugged process is stopped and the interactive command line GDB is launched, in which a new command ‚Äúpyinject‚Äù will be available. <br></div></div><br>  Interception can be divided into three stages: <ol><li>  Injecting a Python interpreter into the address space of the target process </li><li>  Collection of information about the intercepted function </li><li>  Interception </li></ol>  Points 1 and 2 are easier to do on the debugger side, point 3 is already inside the target process. <br><br><h2>  Python interpreter injection </h2><br>  Most of the GDB Python interface is designed to enhance debugging capabilities.  For everything else, there is <code>gdb.execute(command, from_tty, to_string)</code> , which allows you to execute an arbitrary GDB command and get its output as a string. <br>  For example: <br><pre> <code class="python hljs">out = gdb.execute(<span class="hljs-string"><span class="hljs-string">"info registers"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre>  Also useful is <code>gdb.parse_end_eval(expression)</code> , which evaluates the expression and returns the result in the form <code>gdb.Value</code> . <br><br>  The first step is to load the Python library into the address space of the target process.  To do this, call <code>dlopen</code> in the context of the target process. <br>  You can use the <code>call</code> command in <code>gdb.execute</code> , or <code>gdb.parse_and_eval</code> : <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># pyinject.py gdb.execute('call dlopen("libpython2.7.so", %d)' % RTLD_LAZY) assert long(gdb.history(0)) handle = gdb.parse_and_eval('dlopen("libpython2.7.so", %d)' % RTLD_LAZY) assert long(handle)</span></span></code> </pre><br>  You can then initialize the interpreter. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># pyinject.py gdb.execute('call PyEval_InitThreads()') gdb.execute('call Py_Initialize()')</span></span></code> </pre>  The first call creates a GIL (global interpreter lock), the second prepares the Python C-API for use. <br><br>  And load the interception module <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># pyinject.py fp = gdb.parse_and_eval('fopen("hook.py", "r")') assert long(fp) != 0 pyret = gdb.parse_and_eval('PyRun_AnyFileEx(%u, "hook.py", 1)' % fp)</span></span></code> </pre>  <code>PyRun_AnyFileEx</code> executes code from a file in the context of the <code>__main__</code> module. <div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  The above will only work if the target process does not use Python (as the main or scripting language).  If this is not the case, then everything becomes seriously complicated.  The main problem is that in the process stopped for debugging in a random place, you cannot use any Python C-API functions (except maybe <code>Py_AddPendingCall</code> ). </div></div><br><h2>  Hook.py module </h2><br>  The hook.py module contains interceptors and the <code>Hook</code> class that performs the actual interception. <br>  Interceptor functions are indicated by the decorator.  For example, for the <code>open</code> function of the standard library, we print its arguments and return the result of calling the original function stored in the <code>orig</code> field. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py @hook(symbol='open', ctype=CFUNCTYPE(c_int, c_char_p, c_int)) def python_open(fname, oflag): print "open: ", fname, oflag return python_open.orig(fname, oflag)</span></span></code> </pre><br>  The <code>@hook</code> decorator takes two parameters: <ul><li>  symbol - the name of the symbol being intercepted (it is assumed that the symbol is available in GDB from import tables or debug information, but nothing prevents intercepting functions by addresses instead of characters) </li><li>  ctype - class <code>ctypes</code> specifying the type of function </li></ul>  The decorator registers the function in the class Hook and returns without changing. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py def hook(symbol, ctype): def deco(func): Hook.register(symbol, ctype, func) return func return deco</span></span></code> </pre><br>  The <code>register</code> method creates an instance of the class and stores it in the <code>all_hooks</code> dictionary.  Thus, after the file has been executed, thanks to the decorators in <code>Hook.all_hooks</code> will be all the information about the available functions of the interceptors. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py class Hook(object): all_hooks = {} @staticmethod def register(symbol, *args): Hook.all_hooks[symbol] = Hook(symbol, *args)</span></span></code> </pre><br>  In order to be intercepted by GDB by calling one function, it is convenient to define a static method in the <code>Hook</code> class responsible for intercepting <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py class Hook(object): @staticmethod def hook(symbol, *args): h = Hook.all_hooks[symbol] if h.active: return h.install(*args)</span></span></code> </pre>  In <code>*args</code> , additional information about the function being intercepted is passed here.  Which one depends on the method of interception. <br><br><h2>  Splicing interception methods </h2><br>  Splicing is globally divided into two subspecies by the method of calling the original function. <br><br>  In a <b>simple hook, a</b> call to the original function consists of several steps: <ol><li>  the beginning of the original function is restored from the saved copy </li><li>  made a call </li><li>  the beginning is overwritten again by the instruction for switching to the interceptor </li></ol><div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  The disadvantage is obvious, in a multi-threaded program it cannot be guaranteed that another thread will not call a function during its rewrite.  In part, this is treated by stopping other threads while calling the original function.  But firstly there is no standard way to achieve this, secondly, you can catch a deadlock if you fail to call a function like malloc </div></div><br>  In the <b>trampoline hook, the</b> beginning of the original function is copied to a new place and after it the transition to the body of the original function is recorded.  In this version, the original function is always available at the new address. <br><br>  Trampoline hook works in multi-threaded programs, but much more difficult to install.  It is necessary to rewrite an integer number of instructions, for which the disassembler is usually used.  The arrival of the x86_64 architecture added even more problems due to the ubiquitous distribution of memory addressing relative to the <code>%rip</code> register (address of the current command). <br><div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  Let's look at the beginning of the <code>open</code> function in GDB: <br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83e0</span></span> &lt;open64+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">83</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d ed <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>d <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> cmpl $0<span class="hljs-keyword"><span class="hljs-keyword">x</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x2d33ed</span></span>(%rip) <span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83e7</span></span> &lt;open64+<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> jne <span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83f9</span></span> &lt;open64+<span class="hljs-number"><span class="hljs-number">25</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83e9</span></span> &lt;__open_nocancel+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: b8 <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov $0x2,%eax <span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83ee</span></span> &lt;__open_nocancel+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: 0f <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span></code> </pre><br>  If we rewrite the first command " <code>cmpl $0x0,0x2d33ed(%rip)</code> " to another address, then the relative address <code>0x2d33ed(%rip)</code> , which now points to <code>0x7f6cc8d7b7d4</code> , will point to another place (hello SIGSEGV). <br><br>  To make a trampoline hook of this function you need: <ol><li>  determine the size of commands at the beginning of the function </li><li>  allocate memory no farther than 2GB from the target address of the cmpl command (offset <code>0x2d33ed(%rip)</code> signed 32-bit) </li><li>  copy the beginning to a new place and patch memory access relative to <code>%rip</code> in <code>cmpl</code> </li></ol>  On top of the picture, the transition command should be shorter than 9 bytes, since  this function with two entry points and at <code>0x7f6cc8aa83e9</code> already <code>__open_nocancel</code> .  This means that our springboard should be no farther than 2GB from the beginning of the <code>open</code> to allow a 32-bit transition (all 64-bit transitions are longer than 9 bytes). </div></div><br>  In principle, with all the power of GDB behind you ( <code>gdb.execute()</code> ), nothing prevents you from correctly implementing a trampoline hook, but for the sake of simplicity, this article will use a simple hook. <br><br>  In a <b>simple hook, the</b> only limit is the length of the transition instruction. <br>  There are two (main) options: <br><ul><li>  The E9 opcode (5 bytes) is a relative 32-bit transition to the additionally allocated memory (as in a trampoline hook) and from there a full 64-bit transition to the interceptor. <br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">0x7f6cc8aa83e0</span></span> &lt;open64+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: e9 <span class="hljs-number"><span class="hljs-number">1</span></span>b <span class="hljs-number"><span class="hljs-number">6</span></span>c <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span> jmp <span class="hljs-number"><span class="hljs-number">0x7f6cfffff000</span></span></code> </pre>  Transition to <code>0x7f6cc8aa83e0 + 0x37556c1b + 5 = 0x7f6cfffff000</code> </li><li>  The opcode FF 25 (6 bytes) is an absolute 64-bit jump to the address in memory relative to% rip.  For the address, you still need to allocate additional memory no further than 2GB from the beginning of the function. <br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">0x00007f6cc8aa83e0</span></span> &lt;open64+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: ff <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>a <span class="hljs-number"><span class="hljs-number">6</span></span>c <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span> jmpq *<span class="hljs-number"><span class="hljs-number">0x37556c1a</span></span>(%rip)</code> </pre>  Here in the <code>0x7f6cc8aa83e0 + 0x37556c1a + 6 = 0x7f6cfffff000</code> address of the absolute transition is stored. </li></ul><br>  The article uses the second method. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py class Hook(object): @staticmethod def get_indlongjmp(srcaddr, proxyaddr): s = struct.pack('=BBl', 0xff, 0x25, proxyaddr - srcaddr - 6) return map(ord, s)</span></span></code> </pre>  <code>get_indlongjmp</code> returns the code for jumping from the address <code>srcaddr</code> to the address stored in QWORD at <code>proxyaddr</code> <br><br>  Now you can finally write the missing methods of the <code>Hook</code> class.  The <code>install</code> method gets the address of the original <code>address</code> function and the address of the <code>proxyaddr</code> secondary zone.  After that, it rewrites the beginning of the function (after saving it in <code>self.code</code> ) by switching to an interceptor <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py def install(self, address, proxyaddr): self.address = address self.proxyaddr = proxyaddr proxymemory = (c_void_p * 1).from_address(self.proxyaddr) proxymemory[0] = Hook.cast_to_void_p(self.cfunc) self.jmp = self.get_indlongjmp(self.address, self.proxyaddr) self.memory = (c_ubyte * len(self.jmp)).from_address(self.address) self.code = list(self.memory) self.patchmem(self.jmp) self.pyfunc.orig = self.origfunc() self.active = True</span></span></code> </pre><br>  <code>patchmem</code> overwrites the beginning of the original function with data from <code>src</code> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py def patchmem(self, src): for i in range(len(src)): self.memory[i] = src[i]</span></span></code> </pre><br>  <code>origfunc</code> wraps the function call in a code that removes and sets the transition to the interceptor. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py def origfunc(self): ofunc = self.ctype(self.address) def wrap(*args): self.patchmem(self.code) val = ofunc(*args) self.patchmem(self.jmp) return val return wrap</span></span></code> </pre><br><h2>  Finishing touches </h2><br>  Python is loaded into the address space, hook.py is loaded into Python.  It remains to call <code>Hook.hook(symbol, address, proxyaddr)</code> on the Python side of the GDB module. <br><br>  Find the address of the function " <code>open</code> " <br><pre> <code class="python hljs">line = gdb.execute(<span class="hljs-string"><span class="hljs-string">'info address %s'</span></span> % <span class="hljs-string"><span class="hljs-string">"open"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) m = re.match(<span class="hljs-string"><span class="hljs-string">r'.*?(0x[0-9a-f]+)'</span></span>, line) addr = int(m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  In general, before running to rewrite the code of a stopped process, you need to make sure that it is not stopped in the middle of this code (or is going to return to it).  It is easiest to do this by parsing the output of <code>gdb.execute("thread apply all backtrace")</code> </div></div><br>  We allocate memory nearby from <code>addr</code> <br><pre> <code class="python hljs">prot = PROT_READ | PROT_WRITE | PROT_EXEC flags = MAP_PRIVATE | MAP_ANONYMOUS maddr = gdb.parse_and_eval(<span class="hljs-string"><span class="hljs-string">'(void*)mmap(0x%x, %d, %d, %d, -1, 0)\n'</span></span> % (addr | <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>, <span class="hljs-number"><span class="hljs-number">4096</span></span>, prot, flags)) maddr = (long(maddr) &amp; <span class="hljs-number"><span class="hljs-number">0x00000000FFFFFFFF</span></span>) | (addr &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF00000000</span></span>)</code> </pre><div class="spoiler">  <b class="spoiler_title">Nuances</b> <div class="spoiler_text">  The last line is to bypass the bug in GDB, which eats the most significant bits of the result.  The argument <code>(addr | 0x7FFFFFFF)</code> uses the undocumented <code>mmap</code> property to <code>(addr | 0x7FFFFFFF)</code> memory with the address less than the desired one. <br><br>  Without tricks, the right one is slightly longer: you need to parse the output of <code>gdb.execute('info proc mappings', False, True)</code> , find the hole closest to addr in the address space and wipe out mmap with <code>MAP_FIXED</code> .  And of course it is not necessary to allocate a whole page of memory for each intercepted function. </div></div><br>  Allow rewriting of the original function (otherwise SIGSEGV) <br><pre> <code class="python hljs">gdb.parse_and_eval(<span class="hljs-string"><span class="hljs-string">'mprotect(0x%x, %u, %d)'</span></span> % (addr &amp; <span class="hljs-number"><span class="hljs-number">-0x1000</span></span>, <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, prot))</code> </pre><br>  Call <code>Hook.hook</code> via <code>PyRun_SimpleString</code> <br><pre> <code class="python hljs">pyret = gdb.parse_and_eval(<span class="hljs-string"><span class="hljs-string">'PyRun_SimpleString("Hook.hook(\\"open\\", 0x%x, 0x%x)")'</span></span> % (addr, maddr))</code> </pre><br>  Done!  Now the call to " <code>open</code> " in the target process will be intercepted and sent to <code>python_open</code> from hook.py. <br><br><h2>  Sample files </h2><br>  Full sample files (with a little more checks, but without taking into account many nuances) <br><div class="spoiler">  <b class="spoiler_title">pyinject.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># pyinject.py import re import os RTLD_LAZY = 1 PROT_READ = 0x1 PROT_WRITE = 0x2 PROT_EXEC = 0x4 MAP_PRIVATE = 0x2 MAP_FIXED = 0x10 MAP_ANONYMOUS = 0x20 LIBPYTHON = 'libpython2.7.so' class ParamHookfile(gdb.Parameter): instance = None def __init__(self, default=''): super(ParamHookfile, self).__init__("hookfile", gdb.COMMAND_NONE, gdb.PARAM_FILENAME) self.value = default ParamHookfile.instance = self def get_set_string(self): return self.value def get_show_string(self, svalue): return svalue class CmdHook(gdb.Command): instance = None def __init__(self): super(CmdHook, self).__init__("pyinject", gdb.COMMAND_NONE) self.initialized = False CmdHook.instance = self def complete(self, text, word): matching = [s[4:] for s in dir(self) if s.startswith('cmd_') and s[4:].startswith(text)] return matching def invoke(self, subcmd, from_tty): self.dont_repeat() if subcmd.startswith("hook"): self.cmd_hook(*gdb.string_to_argv(subcmd)) elif subcmd.startswith("unhook"): self.cmd_unhook(*gdb.string_to_argv(subcmd)) else: gdb.write('unknown sub-command "%s"' % subcmd) def cmd_hook(self, *args): self.initialize() if not self.initialized: return pyret = gdb.parse_and_eval('PyRun_SimpleString("print Hook")') if long(pyret) != 0: hookfile = ParamHookfile.instance.value if not os.path.exists(hookfile): gdb.write('Use "set hookfile &lt;path&gt;"\n') return fp = gdb.parse_and_eval('fopen("%s", "r")' % hookfile) assert long(fp) != 0 pyret = gdb.parse_and_eval('PyRun_AnyFileEx(%u, "%s", 1)' % (fp, hookfile)) if long(pyret) != 0: gdb.write('Error loading "%s"\n' % hookfile) return for symbol in args: try: line = gdb.execute('info address %s' % symbol, False, True) m = re.match(r'.*?(0x[0-9a-f]+)', line) if m: addr = int(m.group(1), 16) except gdb.error: continue prot = PROT_READ | PROT_WRITE | PROT_EXEC flags = MAP_PRIVATE | MAP_ANONYMOUS # | MAP_FIXED maddr = gdb.parse_and_eval('(void*)mmap(0x%x, %d, %d, %d, -1, 0)\n' % (addr | 0x7FFFFFFF , 4096, prot, flags)) maddr = (long(maddr) &amp; 0x00000000FFFFFFFF) | (addr &amp; 0xFFFFFFFF00000000) gdb.write("mmap = 0x%x\n" % maddr) if maddr == 0: continue gdb.parse_and_eval('mprotect(0x%x, %u, %d)' % (addr &amp; -0x1000, 4096*2, prot)) pyret = gdb.parse_and_eval('PyRun_SimpleString("Hook.hook(\\"%s\\", 0x%x, 0x%x)")' % (symbol, addr, maddr)) if long(pyret) == 0: gdb.write('hook "%s" OK\n' % symbol) def cmd_unhook(self, *args): for symbol in args: pyret = gdb.parse_and_eval('PyRun_SimpleString("Hook.unhook(\\"%s\\")")' % (symbol)) if long(pyret) == 0: gdb.write('unhook "%s" OK\n' % symbol) def initialize(self): if self.initialized: return handle = gdb.parse_and_eval('dlopen("%s", %d)' % (LIBPYTHON, RTLD_LAZY)) if not long(handle): gdb.write('Cannot load library %s\n' % LIBPYTHON) return if not long(gdb.parse_and_eval('Py_IsInitialized()')): gdb.execute('call PyEval_InitThreads()') gdb.execute('call Py_Initialize()') self.initialized = True if __name__ == '__main__': ParamHookfile() CmdHook()</span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">hook.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hook.py import struct from ctypes import (CFUNCTYPE, POINTER, c_ubyte, c_int, c_char_p, c_void_p) class Hook(object): all_hooks = {} @staticmethod def cast_to_void_p(pointer): return CFUNCTYPE(c_void_p, c_void_p)(lambda x: x)(pointer) @staticmethod def register(symbol, *args): Hook.all_hooks[symbol] = Hook(symbol, *args) def __init__(self, symbol, ctype, pyfunc): self.symbol = symbol self.ctype = ctype self.pyfunc = pyfunc self.cfunc = self.ctype(self.pyfunc) self.address = 0 self.proxyaddr = 0 self.jmp = None self.memory = None self.code = None self.active = False def install(self, address, proxyaddr): print "install:", hex(address) self.address = address self.proxyaddr = proxyaddr proxymemory = (c_void_p * 1).from_address(self.proxyaddr) proxymemory[0] = Hook.cast_to_void_p(self.cfunc) self.jmp = self.get_indlongjmp(self.address, self.proxyaddr) self.memory = (c_ubyte * len(self.jmp)).from_address(self.address) self.code = list(self.memory) self.patchmem(self.jmp) self.pyfunc.orig = self.origfunc() self.active = True def uninstall(self): self.patchmem(self.code) self.active = False def origfunc(self): ofunc = self.ctype(self.address) def wrap(*args): self.patchmem(self.code) val = ofunc(*args) self.patchmem(self.jmp) return val return wrap def patchmem(self, src): for i in range(len(src)): self.memory[i] = src[i] @staticmethod def get_indlongjmp(srcaddr, proxyaddr): # 64-bit indirect absolute jump (6 + 8 bytes) # ff 25 off32 jmpq *off32(%rip) try: s = struct.pack('=BBl', 0xff, 0x25, proxyaddr - srcaddr - 6) return map(ord, s) except: print hex(proxyaddr), hex(srcaddr), hex(proxyaddr - srcaddr - 6) raise @staticmethod def hook(symbol, address, proxyaddr): h = Hook.all_hooks[symbol] if h.active: return h.install(address, proxyaddr) @staticmethod def unhook(symbol): h = Hook.all_hooks[symbol] if not h.active: return h.uninstall() def hook(symbol, ctype): def deco(func): Hook.register(symbol, ctype, func) return func return deco #int open (const char *__file, int __oflag, ...) @hook(symbol='open', ctype=CFUNCTYPE(c_int, c_char_p, c_int)) def python_open(fname, oflag): print "open: ", fname, oflag return python_open.orig(fname, oflag)</span></span></code> </pre><br></div></div>  Run example (better with absolute paths) <br><pre> <code class="bash hljs">gdb -ex <span class="hljs-string"><span class="hljs-string">'attach PID'</span></span> -ex <span class="hljs-string"><span class="hljs-string">'source /path/pyinject.py'</span></span> -ex <span class="hljs-string"><span class="hljs-string">'set hookfile /path/hook.py'</span></span> (gdb) pyinject hook open (gdb) <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/237575/">https://habr.com/ru/post/237575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237563/index.html">Supermassive black hole in the center of a small galaxy</a></li>
<li><a href="../237565/index.html">A gift from VmWare or how to block your server on hosting</a></li>
<li><a href="../237569/index.html">Cross-browser beautiful input type = "number"</a></li>
<li><a href="../237571/index.html">Choosing a name for a new Russian operating system</a></li>
<li><a href="../237573/index.html">Model S cars can now be given personal names.</a></li>
<li><a href="../237577/index.html">The evolution of IT-infrastructure of our retail - consistent "molting"</a></li>
<li><a href="../237579/index.html">How we disaccustomed outsourcing to throw the ball to the internal IT department</a></li>
<li><a href="../237581/index.html">Review of the most interesting materials on high performance (September 15-21, 2014)</a></li>
<li><a href="../237583/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ14 (September 15 - 21, 2014)</a></li>
<li><a href="../237585/index.html">Semi-automatic incrementing of the project version when working with GIT in Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>