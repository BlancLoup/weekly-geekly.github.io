<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Micro-UART for Microcontroller (ATtiny13A)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am glad to welcome again all visitors to this glorious place on the Internet to bring one more modest contribution. 

 This time, it concerns the al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Micro-UART for Microcontroller (ATtiny13A)</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" src="https://habrastorage.org/webt/ek/g0/so/ekg0sotf61ygzpweawd60u01dqg.jpeg">  I am glad to welcome again all visitors to this glorious place on the Internet to bring one more modest contribution. <br><br>  This time, it concerns the already rather hackneyed topic, around which there are always disputes, and when it comes to the point that all its implementations are either sharpened for a specific task, by a specific person, under specific conditions, or do not work at all. <br></p><br>  <b>It will be about the software implementation of UART</b> , for Atmel <b>AVR</b> microcontrollers, the intellectual property of which for some time has been owned by <b>Microchip</b> . <br><a name="habracut"></a><br><h2>  So, following the tradition, the saying </h2><br>  The thought in my head on the topic of this article has crept in for a long time, thanks to one dispute in the comments that, they say: the software UART for a microcontroller working from an internal generator is very unstable and you cannot get high accuracy at speeds above 9600 baud because of the strong drift setting frequency of this internal oscillator. <br>  Then one day, I again wanted to check this thesis (unfortunately I could not find any article where this was discussed, no discussion. Although I am sure that this was happening here on Habr√©), find out: <br><br><ul><li>  How much I can reduce the error; </li><li>  At what maximum transfer rate can the device communicate; </li><li>  Will I be able to compress the code using all my knowledge. </li></ul><br>  Thus, the initial meaning of this work was rather a sporting interest. <br>  But when the first results were obtained, I decided to demonstrate the initial size of the code on the <b>Anarchic electronics</b> channel of the Telegram messenger, and suddenly the topic began to resonate.  New people began to join the discussion, and soon the dispute returned to its normal course, the user of the channel @ RT_1_98 - very fiercely insisted on the failure of this work (for which we thank him separately, he only inflamed me more - to prove the opposite;)) Meanwhile, one of channel administrators @Byte_kgd, suggested not to stop there, but bring the work to its logical conclusion: write a receiver to the transmitter too! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the challenge was accepted ... <br><br>  <b>Without further ado, I chose a simple path.</b> <img width="300" height="280" align="right" src="https://habrastorage.org/webt/pr/s-/m6/prs-m6w32j5yh7k45q1au1gwz0m.jpeg"><br>  No, not because I'm afraid of difficulties, but because I also wanted the results to be applicable by other people, so that the code is easy to read, and thanks to the simplicity of the idea, it could be modified by other microcontrollers.  Therefore, I formed calibration delay constants for a group of frequencies from 9600 to 57600 baud, and wrote a transmitter function that sends a data byte to the line, completely refusing to interrupt the timer. <br><br>  Of course, I sat down to write in my favorite <b>IDE - Atmel Studio</b> .  In the original version, the code of the function body (in inline assembler) took about 90 bytes (45 commands), thanks to which I set the delay constants, testing the performance in the Proteus simulator. <br><br>  The performance has inspired me a lot, since I have already met the code size, less than any other implementations. <br><br>  After a bit of thinking, I rewrote the function to send strings ending in zero, which allowed sending a pre-prepared buffer of a certain size with the #define directive, and also managed to reduce the code size to 76 bytes (38 commands)!  At this point, I decided to show the test results in the Telegram, after which it was decided to write and receiver. <br><br><h2>  I collected my thoughts for a long time ... </h2><br>  One main thought haunted me: since I decided to abandon the timer interruptions in the transmitter, it would be nice to build a receiver on the same principle ... but how ?! <br>  And I decided on a desperate step: write an interrupt handler in such a way that the entire reception takes place in one call. <br><br>  Yes, this is bad practice, and yes - this is indecent behavior!  But firstly, the microcontroller's memory does not allow storing a large buffer, which is expensive for the main code, and secondly, I decided to write a handler so that it can process: <br><br><ul><li>  Buffer overflow (implemented by exiting an interrupt when the limit is reached); </li><li>  Disruption of the receive line (test emulation in Proteus, showed a complete freeze, as a result of which a decision was made to control this state); </li><li>  And, in fact, regular behavior (with the filling of the flag of successful data reception); </li></ul><br>  When writing the interrupt code was completed, I conducted tests for the stability of the reception / transmission, having built such a model in Proteus: <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/webt/tq/-y/0y/tq-y0yg71rp5f05gizp8mb-ekei.png"></div><br>  One microcontroller sent a predefined buffer with test contents: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Rx_Buf[Buf_Size]={<span class="hljs-string"><span class="hljs-string">'T'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'s'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'2'</span></span>,<span class="hljs-string"><span class="hljs-string">'3'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>,<span class="hljs-string"><span class="hljs-string">'5'</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br>  And the second one, having accepted it, compared it with the reference one, and in case of inconsistency, sent a message to the second terminal: ‚Äú <b>Error!</b> ‚Äù, Then started the simulation and went to sleep ... <br><br><img src="https://habrastorage.org/webt/1j/vh/tt/1jvhttv-l0dvnoasgwqnfnmot0y.png"><br><br><h2>  ... in the morning </h2><br>  when I woke up I was disappointed: the terminal was littered with unwanted error messages ... But when I counted them, everything turned out to be not so bad: for 9 hours of work, at a speed of 57600 baud there were 11 messages.  This means that for 3888000 bytes, no more than 143 errors occurred (in the case of a complete mismatch of the buffer). <br><br><h2>  ... So this is a success! ... </h2><br>  Indeed, the probability of error turned out to be several orders of magnitude lower, and I attributed this to the high accuracy of the Proteus simulation. <br><br>  Having revised the code of the receiver and transmitter again, I again reduced the transmitter to 60 bytes (30 commands), and optimized the receiver. <br><br>  After that, he passed the @Byte_kgd code, which ardently wanted to participate in the testing, with a slight deviation: only ATtiny2313 is available. <br><br>  And he gloatingly and pathetically told me: "... safsem narabotait! Wow! ..." <br><br><div style="text-align:center;"><img width="550" src="https://habrastorage.org/webt/7s/1d/lh/7s1dlhahp96ckictsmyqlcpo8vg.jpeg"></div><br><h2>  That's so fiasco, bro ... </h2><br>  ... The new year has come, the whole Olivier has been eaten, all the champagne has been drunk, the trees are already burning outside the window. <br>  And the code does not work ... it doesn't give in to any! <br><br>  And finally it comes to me that in the code it is necessary to cross out half of it, rewrite half, and the third half needs to be turned inside out. <br><br>  <i>And then Ostap suffered!</i>  <i>(c) I. Ilf E. Petrov.</i> <br><br>  First, the transmitter code was reduced to 54 bytes (26 commands), second, the fatal interruption error was eliminated: the flag was not reset (Proteus digested it without even reporting to the log. And this is the second inaccuracy in the simulation, which I found for MK ATtiny13A), in the third and fourth - architectural errors were eliminated, such as: incorrect return of the flag, jitter, mismatch of the duration of transmission and reception, etc.  The receiver code was rewritten with self-synchronization using the STOP bit, which undoubtedly improved the quality of reception. <br><br>  In addition, I finally got a logic analyzer, uncovered a programmer, a UART converter, and took the precious ATtiny13A from my bins, decided FIRST for all this time, to analyze the performance in the hardware! <br><br>  Looking ahead to say: <b>MIRACLE HAPPENED!</b> <br><br>  The stitched ‚Äútinka‚Äù showed ‚Äúping‚Äù in the terminal, and answered with a smile: Test012345. <br>  The use of a logic analyzer showed a discrepancy in delays in Proteus and on real hardware.  Due to this, we managed to unify the delay by one constant for the receiver and for the transmitter: <br><br><img src="https://habrastorage.org/webt/xg/uh/gb/xguhgbhncrkt9wmjppc4djic3am.jpeg"><br><br>  It also allowed us to find the theoretical limit for the maximum transmission rate under normal conditions: <br><br><img src="https://habrastorage.org/webt/6h/qj/wx/6hqjwxm8khce3tkhwnyuc72s70y.jpeg"><br><br>  I deliberately did not choose another screen, showing receiver errors that could not work at such speeds, due to the fact that the execution of the prologue and the epilogue in the interruption <s>spell</s> , have time to skip the start bit.  However, in a slightly modified version, I was able to achieve reliable reception at a speed of 512 kbaud, but due to objective reasons, I decided to leave the code as it is, with a restriction on reception / transmission of 250 kbaud. <br><br><h2>  Total </h2><br>  As a result of this very hard work, <br><br><ul><li>  <b>The result is the most compact code in the world!</b> </li><li>  <b>Non-maskable (INT0 and INT1) interrupts</b> </li><li>  <b>Not using timer interrupts</b> , freeing all PWM channels available for use </li><li>  <b>Allowing to flexibly operate the port setting</b> , choosing the necessary pins for the lines of sending and receiving data </li><li>  <b>Allows you to consistently transmit and receive data</b> at speeds from 9600 to 250,000 baud </li><li>  <b>Transfer strings from flash memory</b> , thanks to the corresponding function </li><li>  <b>Convert and transfer data in binary, hex, and decimal form</b> (for the latter two functions are implemented for transferring bytes and data words), thanks to the corresponding functions </li></ul><br><img align="right" src="https://habrastorage.org/webt/ww/oq/e0/wwoqe08mbhvd2ftoru79xymjnn8.png">  <b>This image</b> clearly shows that the demo example uses the entire available set of functions, with a total size of the demo project - 920 bytes of occupied flash memory.  With proper organization, you can use only the necessary functions, which will greatly minimize the cost for the main project, while allowing you to debug the microcontroller through the UART.  The code is easily modified for other controllers (for example - ATtiny85A), while allowing you to increase the buffer size and the number of functions used, not to the detriment of the performance and efficiency of the main task.  The code was not submitted to the library, for clarity and ease of analysis and training.  It was decided not to fully implement the buffer overflow control.  This means that during an overflow, the overflow flag is not set, instead an interrupt exit occurs, and the subsequent behavior determines the incoming flow. <br><br>  Thus, the microcontroller again goes into the interrupt and overwrites the received buffer with new data.  To avoid this, it is not necessary to feed it with portions of data that are longer than a certain buffer size.  It was decided to stop at this, after several discussions, so as not to inflate the handler code.  The main condition is met - the microcontroller does not freeze and continues to work in normal mode. <br><br>  Another deviation from the tradition at this time was the lack of code excerpts in the form of screenshots.  In the last article in the first comment there was anger on this topic :) <br>  And if so, then let the code lie on Githab, and as a result, display all the beauty in a form that is not formatted by it: <br><br>  <a href="https://github.com/Dolphin101546015/ATtiny13A-UART">Draft version 2.0 for Atmel Studio 7.0</a> <br><br>  This is the second version of the project, and the last.  Any changes that may be made will apply only to calibration delays.  At the moment, for the entire range, tests have been performed and successfully completed. <br><br>  I wish you a speedy heat attack in your homes, on your streets and in your hearts! <br>  All successes, creations, achievements! <br><br>  <i>The use for commercial purposes, the resale of the source code, the use for profit and any mercenary purposes is prohibited.</i>  <i>Source texts are distributed free of charge as they are, in case of use on other sites or other sources, the indication of the author and notification of placement is a must!</i> </div><p>Source: <a href="https://habr.com/ru/post/346980/">https://habr.com/ru/post/346980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346970/index.html">Automatic update and backup 1C using powershell</a></li>
<li><a href="../346972/index.html">Open class lesson on group work</a></li>
<li><a href="../346974/index.html">How to hack a switched off computer or execute code in Intel ME</a></li>
<li><a href="../346976/index.html">JavaScript - fill a niche between microservices and objects - ‚Äúnano-services‚Äù</a></li>
<li><a href="../346978/index.html">Development for Android and iOS: Open Day in webinar format</a></li>
<li><a href="../346982/index.html">Report from the Moscow CocoaHeads Meetup meeting December 15</a></li>
<li><a href="../346984/index.html">Java conference with English roots. Continuing mega review</a></li>
<li><a href="../346990/index.html">Disable DHT blocking in popular torrent clients</a></li>
<li><a href="../346992/index.html">Super-complete guide to publishing in Microsoft Store</a></li>
<li><a href="../346994/index.html">Conference C ++ Russia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>