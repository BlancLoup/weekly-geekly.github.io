<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mines in Haskell and Gloss: Rapid Prototyping Interactive Graphics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habrahabr, there are already quite a few good articles on Haskel, but, unfortunately, these are for the most part all sorts of introductions to the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mines in Haskell and Gloss: Rapid Prototyping Interactive Graphics</h1><div class="post__text post__text-html js-mediator-article">  On Habrahabr, there are already quite a few good articles on Haskel, but, unfortunately, these are for the most part all sorts of introductions to the OP, explanations of some theoretical pieces (such as monads, lambda calculus or families of types) and quite a few practical examples.  Without in any way detracting from their usefulness, I will try to shift the imbalance, to contribute to the thankless task of popularizing functionalism and again showing that the language is suitable not only for writing factorials and inefficient quick sorts in two lines, but also for quite practical ones. things like quick prototyping. <br><br>  The article will try to be relatively <i>real-world</i> , but not to tire the reader with volume or exotic subject areas.  ‚ÄúGraphics and games in training are always sexy,‚Äù as the great V.S. Lugovskii bequeathed, so I will outline a simple game, beloved by all the people, ‚ÄúMinesweeper‚Äù.  The development will be conducted ‚Äúfrom the top down‚Äù - this is an uncommon, but deserving close attention (like Haskel itself) methodology, about which I once read a long time ago in an <a href="http://fprog.ru/2009/issue1/dmitry-astapov-checkers/">excellent article about drafts</a> in <a href="http://fprog.ru/">the Practice of Functional Programming</a> , and since then it has sunk into me In the soul. <a name="habracut"></a><br><br><h4>  Head to foot </h4><br>  The idea is simple: we do not start with the underlying elementary types and functions, combining them into larger ones (as is usually done in everyday development in mainstream languages), but on the contrary, we describe the highest-level entities, gradually breaking them into small ones.  When the code is written by one or two programmers, and the formulation of the problem is known in advance ‚Äî or, conversely, an incomprehensible thing is prototyped, which changes a hundred times during development ‚Äî this approach, in my opinion, is better than the classical one.  Firstly, it allows us not to stray into the dead end of the implementation curve, if we suddenly started with the wrong primitives.  Secondly, it follows the <a href="http://en.wikipedia.org/wiki/KISS_principle%3F">KISS</a> principle (or rather, <a href="http://www.artlebedev.ru/kovodstvo/sections/167/">the progressive JPEG method</a> ) - you can stop at any level of development, if you are satisfied with the result, and not go into unnecessary details, which, when ‚Äúfrom the bottom up,‚Äù may seem paramount.  Thirdly, in the case of flexible prototyping, it simplifies the clarification of the problem and requirements during the development process. <br>  <i>(you can read more on <a href="http://en.wikipedia.org/wiki/Top-down_and_bottom-up_design">Wikipedia</a> )</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, a distinctive feature of haskell is that, thanks to laziness and deduction of declaration types and definitions of types and functions, you can set almost in any order, and write the code straightforwardly, almost without returning to the beginning, to change or add something ( what import modules).  Therefore, the top-down approach there is especially remarkable - you can easily begin with higher-level functions, sometimes putting stubs and adding what they call and use, only later.  Developing a small program is easy to do - write a minimum of code in the editor, periodically load it into the <a href="http://en.wikipedia.org/wiki/Read%25E2%2580%2593eval%25E2%2580%2593print_loop">REPL</a> and try to compile it successfully, then try to call the implemented functions, edit the creeping bugs and implement the necessary stubs, and so on until the working result satisfies you. <br><br>  I will not explain Haskel‚Äôs syntax, basic functions, and so on, since the article is already detailed and puffy.  Therefore, it is focused on a person who already has some experience in the language, and if you are not, start with one of the above introductions.  Instead, I will focus on the demonstration of specific libraries and explanations of how thoughts arising in the process of actual development (which I led in parallel with writing the article) fall on the code.  For the same reason, the article may look like a stream of consciousness, and I apologize in advance to those to whom this style is sick. <br><br><h4>  Minefield </h4><br>  So, let's begin.  I think no one needs to explain the rules of the Minesweeper, so we will immediately begin to implement, and restrictions will emerge along the way.  The game must run as a full binary, so the first thing we have is the entry point - as in many other languages, this is the <code>main</code> function.  She has to create the initial playing field and run the game on it: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> field = createField startGame field</code> </pre><br>  What does createField do?  Somehow creates a field, but how, so far it is not clear.  Let for a start it will have a fixed size, which we will specify in constants: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fieldSize</span></span>@(fieldWidth, fieldHeight) = (<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) mineCount = <span class="hljs-number"><span class="hljs-number">40</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> createField :: <span class="hljs-type"><span class="hljs-type">Field</span></span> createField = undefined startGame :: <span class="hljs-type"><span class="hljs-type">Field</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () startGame = undefined</code> </pre><br>  Let us leave the <code>undefined</code> plug on the implementation site, because it is not yet clear what to do with these parameters, and think about what Field is.  A field in Saper is a two-dimensional array of cells.  In Haskele there are, of course, arrays, but with variable arrays (and they will continuously click on the field continuously during the game), it‚Äôs not very convenient to work with the field.  Therefore, in order not to tinker with mutability in the IO and ST monads, we use a simple persistent alternative - a dictionary, where the keys are the positions of the cells, and the values ‚Äã‚Äãare their states: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cell</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CellState</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    import Data.Map type Cell = (Int, Int)</span></span></span></span></code> </pre><br>  What conditions can a cell have? <br><ul><li>  For starters, a cell can be open or closed, and there may be a mine on it. </li><li>  If it is open, it can be either a dial with the number of mined neighbors, or a bomb exploded, if the engineer missed. </li><li>  If closed, the sapper should be able to check or uncheck the box. </li></ul><br>  All these states must be mutually exclusive: for example, it is impossible to put a flag on an open or draw a number on a closed one.  A certain algebraic type suggests itself, the constructors of which correspond to possible states: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CellState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Closed</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hasMine</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hasFlag</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class">} </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--;  ‚Äî      | Opened (Maybe Int) --;  ‚Äî      ( Nothing,     )</span></span></span></span></code> </pre><br>  The type turned out rather clumsy, in it everything is piled up in a heap.  This option is also fully implementable;  but let us try to think again, and if we succeed, go another way. <br>  Note that two cell states are mixed here: <br><ul><li>  immutable, initially generated, internal (there is or is no mine); </li><li>  changeable visual (open or not, is there a flag or tsiferka). </li></ul><br>  Let's try to separate the visual, and the presence of mines somehow stored separately.  In this case, the closed state becomes unnecessary, since an empty cell can simply not be stored in the dictionary (by the way, everything would have to be stored in the array).  Well, we fix the above in the code: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CellState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opened</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--;  ‚Äî ,    | Mine --;   | Flag -- </span></span></span></span></code> </pre><br>  It's simple!  Minimum of options, minimum of nested parameters.  And then <code>Field</code> at the beginning of the game is just an empty <code>Map</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">createField</span></span> = <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.empty</code> </pre><br>  That is, now the field is only what is visible on the screen.  But then you need to somehow separately store the internal state - a set of mines "under" this field.  But this is even easier: mines are determined simply by the set of cells on which they stand, and during the game this value does not change at all: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mines</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cell</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--  import Data.Set</span></span></span></span></code> </pre><br>  Check whether everything is in order with the compilation - because the code has solid declarations and almost no definitions, there are no problems yet. <br><br>  Unlike the cells, the starting set of mines cannot be empty.  Since all haskell functions are clean and deterministic, to create a random set, we will have to work either in the IO monad, or drag a pseudo-random generator, or play the same field all our lives.  On the one hand, the game still runs in IO and the additional restriction does not interfere;  on the other hand, a more generalized and cleaner solution also does not hurt.  How better - the question is open, so let there be a second option.  So, we need some random generator (in Haskel, they belong to the <code>RandomGen</code> type <code>RandomGen</code> ) and the coordinate of the first <code>RandomGen</code> cell, so as not to accidentally be undermined on the first move: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">createMines</span></span> :: <span class="hljs-type"><span class="hljs-type">RandomGen</span></span> g =&gt; g -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Mines</span></span></code> </pre><br>  How to evenly choose <i>n</i> random cells of a field is a separate question.  In order not to bother, I did not find anything better, how to mix all possible cells and take <i>n</i> first ones.  Well, remove the starting one from there: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">createMines</span></span> g fst = <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Set</span></span>.fromList $ take mineCount $ shuffle g $ [(i, j) | i &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldWidth - <span class="hljs-number"><span class="hljs-number">1</span></span>] , j &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>] , (i, j) /= fst]</code> </pre><br>  The <code>shuffle</code> functions that mix the list are not in the standard compiler.  Well, an omniscient genie named <a href="http://haskell.org/hoogle">Hoogl</a> will help us.  Ask what he can tell by the shuffle keyword. <br><br><img src="//habrastorage.org/files/739/2cc/0e5/7392cc0e503e45d784b0421e63a25cfc.png"><br><br>  Yeah, there is a whole small packet of random-shuffle that specifically solves this problem.  We put it: <br><pre> <code class="hljs lua">$&gt; cabal install <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>-shuffle</code> </pre><br>  and find a function that, as a first approximation, does exactly what you need: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">shuffle'</span></span> :: <span class="hljs-type"><span class="hljs-type">RandomGen</span></span> gen =&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; gen -&gt; [a]</code> </pre><br>  She even has a signature similar to ours.  True, it takes some extra argument, which upon closer inspection turns out to be the length of the list being sorted.  Why I need it, I still do not understand (perhaps not to consider <code>length</code> again, if it is known in advance), so let's make a wrapper: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">shuffle</span></span> gl = shuffle' l (fieldWidth * fieldHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>) g <span class="hljs-comment"><span class="hljs-comment">-- import System.Random.Shuffle (shuffle'),    </span></span></code> </pre><br>  Now it can even be compiled, run and try in the REPL: <br><pre> <code class="hljs kotlin">ghci&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {g &lt;- getStdGen; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $ createMines g (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)} fromList [(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>),(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>),(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>),(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>),(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>),(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>),(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>),(<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>),(<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>),(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>),(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>),(<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>),(<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>),(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>),(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>),(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>),(<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>)]</code> </pre><br>  Fine.  Now you can go back to main and start the gameplay.  How to show a window and draw something on it strongly depends on the graphical framework used.  I will use <b>Gloss</b> , designed to create applications with simple two-dimensional vector graphics. <br><blockquote>  In the library, not so long ago, the names of some standard functions slightly changed, so if you are not going to code, make sure you have a fresh version. </blockquote><br><br><h4>  We direct gloss </h4><br>  Instead of the classic imperative functions of the form ‚Äúdraw it, then draw it‚Äù, which can be seen, for example, in the haskel linking to OpenGL, SDL and other popular graphics API, Gloss uses a proprietary OP-shnuyu idea of ‚Äã‚Äãcombinators and a combination of functions.  What Gloss can draw on the screen is a Picture, a kind of abstract picture.  It has elementary functions for creating images from simple graphic primitives (such as lines, rectangles and raster images), functions for moving and scaling images, combining several images into one, etc., etc. The result is a declarative building complex scenes from simpler ones (again, ‚Äúfrom top to bottom‚Äù): the scene drawn in the window is a picture that consists of pictures that consist of transformed pictures ... and so this time, until at the very bottom they are hidden under the hood  willow opengl.  Another important factor - in Gloss there is a small, but very proud subsystem for handling user input events (which distinguishes it from the conceptually similar, but purely static Diagrams), which is very useful to us.  You can look at simple examples on the <a href="http://gloss.ouroborus.net/">official website of the library</a> , and I will immediately use everything I need in the article. <br>  To launch interactive scenes (which, in addition to rendering, can also change over time and respond to external events), Gloss has a play function, which has an unusually bulky 7-ary type: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">play</span></span> :: <span class="hljs-type"><span class="hljs-type">Display</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Color</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; world -&gt; (world -&gt; <span class="hljs-type"><span class="hljs-type">Picture</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Event</span></span> -&gt; world -&gt; world) -&gt; (<span class="hljs-type"><span class="hljs-type">Float</span></span> -&gt; world -&gt; world) -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br>  The first two arguments are trivial (the window or fullscreen options, and the default background color).  And then the fun begins. <br>  Let us examine a little how this <code>play</code> works.  There is a scene, or a certain inner ‚Äúworld‚Äù, the state of which is stored in the value of the <code>world</code> type - this is not a type, but a type variable, therefore <code>play</code> polymorphic and can work with any state that we enter.  Three callback functions are used to work with the state. <br><ul><li>  When the engine needs to draw it, it calls the fifth parameter - a function like <code>world -&gt; Picture</code> , which turns the ‚Äústate of the world‚Äù into a picture (let's call it a <code>renderer</code> ). </li><li>  A certain number of times per second (specified by the third parameter) the world can change, for which there is a seventh argument that takes the current time, the old state and returns a new one (let's call it a renewer, or <code>updater</code> ). </li><li>  And finally, to handle external events from the user, there is a sixth argument that similarly accepts the event, the old state and returns the new state (we will call it the handler, or <code>handler</code> ). </li></ul><br>  Please note - all functions are clean, except for the <code>play</code> itself.  By the way, a similar approach with pure functions that handle different events was used in the Haskel itself in the pre-Donad era (you can read it <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf">here</a> ). <br><blockquote>  Note: if, in addition to standard events, you need to react with the outside world (for example, load files), then there is a similar function that in all its handlers works with the state of the world in the IO monad. </blockquote><br>  Let's try to describe the state of the world.  It should contain at least a field of cells and a set of mines.  However, the set of mines is unknown until the player has made the first move, so you need to somehow make a pending initialization.  The most straightforward (and far from the best) option is to add the corresponding flag and generator to the state.  To avoid using "one-time" fields, I came up with a small hack: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GameState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GS</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mines</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StdGen</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mines</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Then, if <code>mines</code> is <code>Left</code> , this means the first move, and from it we will generate a set that will become <code>Right</code> . <br>  Now you can run the game: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Graphics.Gloss.Interface.Pure.Game &lt;...&gt; startGame :: StdGen -&gt; IO () startGame gen = play (<span class="hljs-type"><span class="hljs-type">InWindow</span></span> <span class="hljs-title"><span class="hljs-title">windowSize</span></span> (240, 160)) (<span class="hljs-title"><span class="hljs-title">greyN</span></span> 0.25) 30 (<span class="hljs-title"><span class="hljs-title">initState</span></span> <span class="hljs-title"><span class="hljs-title">gen</span></span>) renderer handler updater windowSize = both (* (<span class="hljs-title"><span class="hljs-title">round</span></span> <span class="hljs-title"><span class="hljs-title">cellSize</span></span>)) fieldSize cellSize = 24 initState gen = GS createField (<span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-title"><span class="hljs-title">gen</span></span>) both f (<span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-title"><span class="hljs-title">b</span></span>) = (<span class="hljs-title"><span class="hljs-title">fa</span></span>, <span class="hljs-title"><span class="hljs-title">fb</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- ,   </span></span></code> </pre><br>  The game is static, so <code>updater</code> does nothing.  <code>handler</code> now, too, but do not set <code>undefined</code> to achieve a successful window display. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">updater</span></span> _ = id handler _ = id</code> </pre><br>  <code>renderer</code> to begin with let draws a whole field with empty white cells: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">renderer</span></span> _ = pictures [uncurry translate (cellToScreen (x, y)) $ color white $ rectangleSolid cellSize cellSize | x &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldWidth - <span class="hljs-number"><span class="hljs-number">1</span></span>], y &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>]] cellToScreen = both ((* cellSize) . fromIntegral)</code> </pre><br>  Run. <br><br><img src="//habrastorage.org/files/281/6e2/ac7/2816e2ac7ae24d18897cd1f7ad176e94.png"><br><br>  Oops - the field left in the corner.  It turns out that Gloss as the coordinate system defaults to the one adopted in mathematics, where the point (0,0) is the center of the screen and the axis <i>oy is</i> directed upwards.  Whereas in 2D-graphics, usually (0,0) is the upper left corner, and <i>oy</i> goes down.  For the same reason, all primitives are drawn relative to the center, not the angle.  Let's deal with this a little later, and first we will try to process some events. <br><br><h4>  Interactive </h4><br>  <i>An event</i> in Gloss is an algebraic type, the constructors of which are variants of events: pressing various buttons ( <code>EventKey</code> ), moving the cursor ( <code>EventMotion</code> ), changing the size of the window ( <code>EventResize</code> ), each of which carries some other specific parameters.  Thanks to the pattern-matching and partial definitions of the function in the form of clauses, quite cunning handlers of various special cases can be organized, and it looks almost like methods of the <code>OnClick(MouseEventArgs e)</code> type <code>OnClick(MouseEventArgs e)</code> in some WinForms. <br><br>  We are primarily interested in the reaction to the mouse buttons.  When the field is empty, we wanted to generate a set of mines: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handler</span></span> (<span class="hljs-type"><span class="hljs-type">EventKey</span></span> (<span class="hljs-type"><span class="hljs-type">MouseButton</span></span> <span class="hljs-type"><span class="hljs-type">LeftButton</span></span>) <span class="hljs-type"><span class="hljs-type">Down</span></span> _ mouse) gs@<span class="hljs-type"><span class="hljs-type">GS</span></span> { mines = <span class="hljs-type"><span class="hljs-type">Left</span></span> gen } = gs { mines = <span class="hljs-type"><span class="hljs-type">Right</span></span> $ createMines gen cell } <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> cell = screenToCell mouse screenToCell = both (round . (/ cellSize)) <span class="hljs-comment"><span class="hljs-comment">--        ,     </span></span></code> </pre><br>  Run.  At the slightest movement, the game falls from incomplete patterns.  Indeed - the handler handles only one special case, so you need to leave the most common clause to handle events that do not interest us: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handler</span></span> _ gs = gs</code> </pre><br>  Now the game works stably, but outwardly, nothing has changed, because the mines are not visible.  Add the opening of the cell.  In general, in the original ‚ÄúSaper‚Äù the whole area of ‚Äã‚Äãcells with zeros is automatically opened, but for the beginning (remember, keep it simple!) We will process only one cell: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handler</span></span> (<span class="hljs-type"><span class="hljs-type">EventKey</span></span> (<span class="hljs-type"><span class="hljs-type">MouseButton</span></span> <span class="hljs-type"><span class="hljs-type">LeftButton</span></span>) <span class="hljs-type"><span class="hljs-type">Down</span></span> _ mouse) gs@<span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field , mines = <span class="hljs-type"><span class="hljs-type">Right</span></span> mines } = gs { field = <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.insert cell opened field } <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> cell@(cx, cy) = screenToCell mouse opened = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cell `<span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Set</span></span>.member` mines <span class="hljs-comment"><span class="hljs-comment">--,     then Mine else Opened neighbours --  :   ,           1 neighbours = length [ () | i &lt;- [-1 .. 1], j &lt;- [-1 .. 1] , (i, j) /= (0, 0) , (cx + i, cy + j) `Data.Set.member` mines]</span></span></code> </pre><br>  Now the game can be started and clicked, but the cells are still not drawn.  We correct this mistake.  To begin with, on the site of the opened cells we will draw a number (or <code>@</code> , if there is a bomb): <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">renderer</span></span> <span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field } = pictures $ [uncurry translate (cellToScreen (x, y)) $ drawCell xy | x &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldWidth - <span class="hljs-number"><span class="hljs-number">1</span></span>], y &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> drawCell xy = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.lookup (x, y) field <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; color white $ rectangleSolid cellSize cellSize <span class="hljs-comment"><span class="hljs-comment">--  Just Mine -&gt; pictures [ color red $ rectangleSolid cellSize cellSize , scale 0.15 0.15 $ color black $ text "@" ] Just (Opened n) -&gt; pictures [ color green $ rectangleSolid cellSize cellSize , scale 0.15 0.15 $ color black $ text $ show n ]</span></span></code> </pre><br>  Let me remind you that the <code>pictures</code> combinator combines a list of several ‚Äúpictures‚Äù into one, while the drawing goes from left to right, that is, the elements in the tail of the list will be drawn over those that are at the beginning. <br><br>  Here it is also worth noting that the standard vector font in Gloss is frankly outlined and too large (so you have to reduce it with <code>scale</code> ), so as soon as possible you should replace it with raster images.  But for the time being, we will postpone it and first make the rest of the game logic, to finally see these altered states of the cells of the field.  First, the installation of checkboxes - add a clause with the processing of the right mouse button: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handler</span></span> (<span class="hljs-type"><span class="hljs-type">EventKey</span></span> (<span class="hljs-type"><span class="hljs-type">MouseButton</span></span> <span class="hljs-type"><span class="hljs-type">RightButton</span></span>) <span class="hljs-type"><span class="hljs-type">Down</span></span> _ mouse) gs@<span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field } = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.lookup coord field <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; gs { field = <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.insert coord <span class="hljs-type"><span class="hljs-type">Flag</span></span> field } <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">Flag</span></span> -&gt; gs { field = <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.delete coord field } _ -&gt; gs <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> coord = screenToCell mouse</code> </pre><br>  and, accordingly, their drawing: <br><pre> <code class="haskell hljs"> drawCell xy = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.lookup (x, y) field <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;...&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">Flag</span></span> -&gt; pictures [ color yellow $ rectangleSolid cellSize cellSize , scale <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-number"><span class="hljs-number">0.15</span></span> $ color black $ text <span class="hljs-string"><span class="hljs-string">"?"</span></span> ]</code> </pre><br>  Duplex with the creation of cells would be worth it, but I will leave it to optional. <br><br><img src="//habrastorage.org/files/b1d/2d5/058/b1d2d5058adf41efaff1a052dca803bf.png"><br><br>  The cells are opened, but the labels are also shifted, move them to the auxiliary function, which will make the text label: <br><pre> <code class="haskell hljs"> label = translate (<span class="hljs-number"><span class="hljs-number">-5</span></span>) (<span class="hljs-number"><span class="hljs-number">-5</span></span>) . scale <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-number"><span class="hljs-number">0.15</span></span> . color black . text</code> </pre><br>  In addition, the grid disappeared - after all, the filled geometric shapes do not have a frame.  It is necessary to add its drawing separately, and on top of the cells, otherwise they will overlap each other. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">renderer</span></span> <span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field } = pictures $ cells ++ grid <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> grid = [uncurry translate (cellToScreen (x, y)) $ color black $ rectangleWire cellSize cellSize | x &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldWidth - <span class="hljs-number"><span class="hljs-number">1</span></span>], y &lt;- [<span class="hljs-number"><span class="hljs-number">0</span></span> .. fieldHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>]]</code> </pre><br><h4>  Coordinate Projections </h4><br>  Now it is necessary to correct the coordinates.  Of course, you can manually transfer them from one system to another (and vice versa - because the mouse coordinates obtained in the events are not tied to the window, but to the absolute coordinate system of the scene, which can be confusing with unaccustomed), but this is tedious.  Fortunately, Gloss includes a mechanism that does this for us ‚Äî viewports.  Projection is a transformation, according to which the window is displayed on the scene plane, and it can not only be moved, but also scaled and even rotated.  In order for the field to fit entirely on the screen, our projection must simply be shifted half the field plus half the cell (since the cell is also drawn from the center, not from the corner): <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">viewPort</span></span> = <span class="hljs-type"><span class="hljs-type">ViewPort</span></span> (both (negate . (/ <span class="hljs-number"><span class="hljs-number">2</span></span>) . (subtract cellSize)) $ cellToScreen fieldSize) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--   ‚Äì     </span></span></code> </pre><br>  With <code>applyViewPortToPicture</code> you can apply a projection to any image, transforming it as necessary.  And for the inverse transformation (from the coordinate system of the image to the coordinate system of the projection), which is needed for processing the cursor position, there is an <code>invertViewPort</code> .  Correct our code accordingly: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">screenToCell</span></span> = both (round . (/ cellSize)) . invertViewPort viewPort renderer <span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field } = applyViewPortToPicture viewPort &lt;...&gt;</code> </pre><br><br><img src="//habrastorage.org/files/3b7/908/eee/3b7908eeeef74a1a973332cf1fecb4c5.png"><br><br>  Voila!  Now the window is drawn as it should, and you can even play in it.  In addition, in conjunction with projections, <b>Gloss</b> provides very simple means for scrolling and scaling the screen, which allows you to make, for example, a field of 1000x1000 cells and move along it, as in maps. <br><br>  However, it is still impossible to lose - the explosion at the mine does not affect anything, and therefore you need to add a flag to the game state, and check in the event handler: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GameState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GS</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mines</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StdGen</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mines</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gameOver</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--  ‚Äî  enum-ADT   " ", "", "" } &lt;...&gt; handler (EventKey (MouseButton LeftButton) Down _ mouse) gs@GS { field = field , mines = Right mines , gameOver = False } = gs { field = Data.Map.insert cell opened field , gameOver = exploded } where cell@(cx, cy) = screenToCell mouse (opened, exploded) = if cell `Data.Set.member` mines --,     then (Mine, True) else (Opened neighbours, False)</span></span></span></span></code> </pre><br>  Now the game after a careless step will not allow to make one more. <br><br><h4>  A little convenience </h4><br>  It remains the most interesting - recursive opening of the whole area of ‚Äã‚Äãempty cells.  Let's make it a kind of search in depth - simulate poking into neighboring cells, if there are no mines in them for sure: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handler</span></span> (<span class="hljs-type"><span class="hljs-type">EventKey</span></span> (<span class="hljs-type"><span class="hljs-type">MouseButton</span></span> <span class="hljs-type"><span class="hljs-type">LeftButton</span></span>) <span class="hljs-type"><span class="hljs-type">Down</span></span> _ mouse) gs@<span class="hljs-type"><span class="hljs-type">GS</span></span> { field = field , mines = <span class="hljs-type"><span class="hljs-type">Right</span></span> mines , gameOver = <span class="hljs-type"><span class="hljs-type">False</span></span> } = gs { field = newField , gameOver = exploded } <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> newField = click cell field exploded = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Map</span></span>.lookup cell newField <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-comment"><span class="hljs-comment">--,     -  Just Mine -&gt; True _ -&gt; False cell@(cx, cy) = screenToCell mouse click :: Cell -&gt; Field -&gt; Field click c@(cx, cy) f | c `Data.Map.member` f = f --    | c `Data.Set.member` mines = put Mine --   | otherwise = let nf = put (Opened neighbours) in if neighbours == 0 then Prelude.foldr click nf neighbourCells --  else nf where put state = Data.Map.insert c state f --  :   ,            1 neighbourCells = [ (cx + i, cy + j) | i &lt;- [-1 .. 1], j &lt;- [-1 .. 1] ] neighbours = length $ Prelude.filter (`Data.Set.member` mines) neighbourCells</span></span></code> </pre><br>  Run, poke, and ... the game hangs.  As so, because she compiled!  Alas, even Haskel is not able to insure against all runtime errors.  Specifically, such a hang often happens when a program enters an infinite loop or recursion.  And to be sure - we don‚Äôt check the way out of the field, so the search for neighbors will try to bypass the entire infinite plane.  Add restrictions: <br><pre> <code class="haskell hljs"> neighbourCells = [ (i, j) | i &lt;- [cx - <span class="hljs-number"><span class="hljs-number">1</span></span> .. cx + <span class="hljs-number"><span class="hljs-number">1</span></span>], j &lt;- [cy - <span class="hljs-number"><span class="hljs-number">1</span></span> .. cy + <span class="hljs-number"><span class="hljs-number">1</span></span>] , <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; fieldWidth , <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= j &amp;&amp; j &lt; fieldHeight ] <span class="hljs-comment"><span class="hljs-comment">--,   0 &lt;= i &lt; fieldWidth</span></span></code> </pre><br>  Now, finally, you can enjoy the result: <br><br><img src="//habrastorage.org/files/ad2/675/d7b/ad2675d7bd8d40f696c4cd39c95df356.png"><br><br><h4>  Epilogue </h4><br>  Of course, there is still room for improvement - add a magic combination of two mouse buttons (to uncover the neighbors of a cell that already has all the checkboxes), fasten the normal graphics (the same Gloss can load bitmaps), make the field size and the number of mines customizable (forwarding using the monad Reader), etc., etc. However, I hope I could show that I don‚Äôt need to be afraid of Haskel, and prototyping something simple and interactive on it in a hundred lines is quite a lifting task . <br><br>  The full code is posted on <a href="http://pastebin.com/UrL2DTGX">Pastebin</a> . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/249803/">https://habr.com/ru/post/249803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249791/index.html">Behind the Scenes of Skyforge Closed Beta</a></li>
<li><a href="../249793/index.html">Unconventional review of AngularJS</a></li>
<li><a href="../249795/index.html">The Five-Minute JavaScript Podcast, Issue 2</a></li>
<li><a href="../249797/index.html">Hi, Habravchane</a></li>
<li><a href="../249799/index.html">10 interesting facts about CDN and site speed</a></li>
<li><a href="../249805/index.html">How to create a game without programming skills</a></li>
<li><a href="../249809/index.html">Zero-day XSS vulnerability in Internet Explorer allows you to attack any sites</a></li>
<li><a href="../249811/index.html">Arduino Pro Mini + current sensor GY-712 monitor the burnout of lamps</a></li>
<li><a href="../249817/index.html">A terrible bug in the Portland Group C ++ compiler</a></li>
<li><a href="../249819/index.html">Proper handling of XAML resources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>