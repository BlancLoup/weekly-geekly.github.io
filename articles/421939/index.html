<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using SQL in Rails</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Firstly, the article is not about how I love rails, and secondly, the article is not about how I hate them. They can be treated completely differently...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using SQL in Rails</h1><div class="post__text post__text-html js-mediator-article"><p>  Firstly, the article is not about how I love rails, and secondly, the article is not about how I hate them.  They can be treated completely differently and they will become better only if they are changed.  And they can only become worse if they start to change.  Well, in general, I warned you, and you understood me. </p><br><p> One of the basic concepts of ActiveRecord is that the database is quite utilitarian and can be changed.  Well, you are sitting, writing your own models using MySQL, and suddenly you read somewhere that you can take and replace MySQL with MongoDB.  Well, not so radically, but, say, with PostgreSQL you may have reasons to replace MySQL.  Or vice versa, I have nothing against MySQL.  Here ActiveRecord claims that it is easier to do this for you, they say, before / after filters and associations are abstract enough not to worry about database queries and cares about the logic of the application.  That instead of <code>WHERE is_archived = TRUE</code> you will gladly write <code>where(is_archived: true)</code> and ActiveRecord will do everything for you.  All examples will be provided for PostgreSQL, not for MySQL, so MySQL users will have to reinvent their own bicycle. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/ff1/cfc/e53ff1cfc747b1a79b89c8139cd1d196.gif"></p><br><p>  But how not so!  In practice, it turns out that this layer of abstraction is completely full of holes, like a trough from the tale of the Golden Fish.  And that many basic features cannot be used, like comparing dates or working with arrays.  And you get scoops with forced <code>where("#{quoted_table_name}.finished_at &gt;= ?", Date.current)</code> or <code>where("#{quoted_table_name}.other_ids &lt;@ ARRAY[?]", ids)</code> .  To which ActiveRecord gives a quite conscious and logical answer: do not use it.  Instead of arrays, use a habtm connection, and if you need to compare dates, live with it.  Yes, and God forbid you skip <code>quoted_table_name</code> in such a scoop - the very first <code>includes</code> or <code>joins</code> put everything in its place.  It is easier to always and everywhere write, so as not to knock your hand. </p><a name="habracut"></a><br><p>  And, of course, as soon as you decide to interfere with ActiveRecord, there will be no way back.  Not that the odds, even the ghostly hopes for a painless transition to another database will be.  It will be much easier to print and burn this source code.  And of course, there is no other reason not to use extra database capabilities in your application.  Use on health and force others! </p><br><p>  And when it turns out that your scoops in the models folder are more than half of these extra utilities, it will become quite obvious that ActiveRecord is just a convenient wrapper for integrating one piece of code with tablets with another piece of code.  And scopes, like <code>where(is_archived: true).joins(:sprint).merge(Sprint.archived)</code> , will work fine and combining them will be no more difficult than making an egg, right? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/618/8a9/0b1/6188a90b173dcc6238fa5fa649ee3227.gif"></p><br><p>  The next stage will be denormalization.  No, denormalization, as it were, always did not disappear anywhere, but concern for her was placed on the mighty shoulders of Rails and ActiveRecord, and you know that these two guys were not distinguished by promptness and asceticism in the requirements for resources.  Suppose <code>counter_cache: true</code> is the first step to denormalization, because <code>COUNT(*) AS sprints_count</code> you will not allow ActiveRecord to do so (you don‚Äôt want to change <code>select()</code> , right?).  And <code>counter_cache</code> not far from perfect, and in some cases, the real number can be out of sync from the cached one.  Uncritically, of course, but unpleasant.  And this is only the first candidate in order to settle in the database and not load the already loaded head of the ruby-machine.  Just a couple of triggers and ready!  Firstly, when deleting and adding a new record to the plate A, you need to recalculate the number of records in plate B and that's it, right?  Well, when editing, of course, if <code>foreign_key</code> changed, because the <code>UPDATE B SET a_id = $1 WHERE id = $2</code> query <code>UPDATE B SET a_id = $1 WHERE id = $2</code> will break the counter_cache for both the old A and the new. </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> update_#{parent_table}_#{child_table}_counter_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> #{parent_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> #{counter_column} = COALESCE((</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> COUNT(id) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> #{child_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">GROUP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> #{foreign_column} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">HAVING</span></span></span><span class="pgsql"> #{foreign_column} = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}), </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> (#{parent_table}.id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">NULL</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre><br><p>  The next path of the database works will be related to the date-time.  And first, let's just <code>created_at</code> fields <code>created_at</code> and <code>updated_at</code> will serve in the database, good, it is much easier.  First we set defaults: </p><br><pre> <code class="hljs ruby"> change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:created_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> } change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:updated_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> }</code> </pre> <br><p>  And to immediately do it everywhere, you can organize a cycle on all the labels, where there are these fields.  In addition to the <code>schema_migrations</code> and <code>ar_internal_metadata</code> , of course: </p><br><pre> <code class="hljs matlab"> (tables - <span class="hljs-comment"><span class="hljs-comment">%w(schema_migrations ar_internal_metadata)).each { ... }</span></span></code> </pre> <br><p>  Everything, now the default value for these tables will be exactly the way we need it.  And now is the time to take care that the rails do not touch these fields.  This is done with two bolts in the right places.  And yes, there is an option in setting up the framework, which is responsible for this: </p><br><pre> <code class="hljs lua">Rails.application.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.active_record.record_timestamps = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  So, the next step is to update the <code>updated_at</code> field at the time of updating the record.  It's simple: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Now you need to completely get rid of <code>touch: true</code> in models.  This thing is very much like a dash target - also completely full of holes.  And I will not even explain why, because you already know all these cases.  This is not much more complicated, all you need is to update updated_at not only for yourself: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Of course, the chain of calls for such triggers will do an extra action, but in the postgame of the sane mechanism it will trigger the triggers without changing the entry itself.  You can try to make <code>SET title = title</code> , but this is no better than <code>SET updated_at = CURRENT_TIMESTAMP</code> . </p><br><p>  Exactly the same trigger will be on the insert, only it is not necessary to update the <code>updated_at</code> : </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Of course, you could try to write it with a single function, adding a check for the current event directly inside the trigger, like <code>IF TG_OP = 'UPDATE' THEN</code> , but it is preferable to make all triggers as simple as possible to reduce the likelihood of an error. </p><br><p>  You may want to somehow automate the generation of such triggers, and then you will probably need to find all foreign links between the current table and the rest.  With this request you can easily do this: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> foreign_table_name, kcu.<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.table_constraints <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tc <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.key_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> kcu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = kcu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.constraint_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ccu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> constraint_type = <span class="hljs-string"><span class="hljs-string">'FOREIGN KEY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> = <span class="hljs-string"><span class="hljs-string">'#{table_name}'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>;</code> </pre><br><p>  Another very helpful tip.  Call triggers monotonously to be able to verify that one request is available or not, for example, this query will find all touch-insert triggers: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.<span class="hljs-keyword"><span class="hljs-keyword">routines</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'touch_for_%_on_insert'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> routine_type =<span class="hljs-string"><span class="hljs-string">'FUNCTION'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> specific_schema=<span class="hljs-string"><span class="hljs-string">'public'</span></span>;</code> </pre> <br><p>  And the last thing left is the worst.  The fact is that the rails are not designed for at least some clever database and absolutely did not care if the database could change at least something other than the <code>id</code> field, and then only when inserted.  Therefore, there is no imputed mechanism to add <code>RETURNING updated_at</code> to update queries no, you will need to dive into the insides of Rails to the ears. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e2/741/5b9/5e27415b90ea63490670e7d4e2e4e758.jpg"></p><br><p>  MankiPatch turned out not so much neat, but first of all the goal was to damage the current work of the framework as little as possible. </p><br><div class="spoiler">  <b class="spoiler_title">I will quote it completely</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">module ActiveRecord module Persistence # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L729-L741 def _create_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attributes_values = attributes_with_values_for_create(attribute_names) an_id, *affected_rows = self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>._insert_record(attributes_values).dup self.id ||= an_id <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.primary_key Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @new_record = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? id <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_create_record # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L710-L725 def _update_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attribute_names = attributes_for_update(attribute_names) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attribute_names.empty? affected_rows = [] @_trigger_update_callback = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> affected_rows = _update_row(attribute_names) @_trigger_update_callback = affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>? ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_update_record <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> module ConnectionAdapters module PostgreSQL module DatabaseStatements # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L93-L96 def exec_update(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, binds = []) execute_and_clear(sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>), <span class="hljs-type"><span class="hljs-type">name</span></span>, binds) { |result| <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.wrap(result.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.first) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb#L147-L152 def <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(arel, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, pk = nil, _id_value = nil, sequence_name = nil, binds = []) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, binds = to_sql_and_binds(arel, binds) exec_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, binds, pk, sequence_name).<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>.first <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L98-L111 def sql_for_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, pk, id_value, sequence_name, binds) # :nodoc: table_ref = extract_table_ref_from_insert_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pk.nil? # Extract the <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>. Yuck. pk = primary_key(table_ref) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> returning_columns = quote_returning_column_names(table_ref, pk, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> = "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> super <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def quote_returning_column_names(table_ref, pk, action) returning_columns = [] returning_columns &lt;&lt; pk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> suppress_composite_primary_key(pk) returning_columns += ApplicationRecord.custom_returning_columns(table_ref, action) returning_columns.map { |<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>| quote_column_name(<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) table_ref = extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) returning_columns = quote_returning_column_names(table_ref, nil, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.blank? "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>[/<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>\s("[A-Za-z0-9_."\[\]\s]+"|[A-Za-z0-9_."\[\]]+)\s*<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>/im] Regexp.last_match(<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;.strip <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  The most important thing is that there is a call to <code>ApplicationRecord.custom_returning_columns</code> to find out which columns, besides id, interest us.  And this method looks something like this: </p><br><pre> <code class="hljs vhdl"> class &lt;&lt; self def custom_returning_columns(table_ref, action) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ['<span class="hljs-string"><span class="hljs-string">"schema_migrations"</span></span>', '<span class="hljs-string"><span class="hljs-string">"ar_internal_metadata"</span></span>'].include?(table_ref) res = [] res &lt;&lt; :created_at <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == :create res &lt;&lt; :updated_at res += <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"user_applications"</span></span>' [:api_token] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"users"</span></span>' [:session_salt, :password_changed_at] # ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><hr><br><p>  Instead of conclusions, we can say that, the sick head of Rails became a little less sick.  <code>counter_cache</code> processes such as <code>counter_cache</code> and <code>touch</code> will sink into oblivion and in the next article you will be able to think about something more global, such as removing hanging spaces, validating data, cascading data deletion, or paranoid deletion.  If you liked this article, of course. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/421939/">https://habr.com/ru/post/421939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421929/index.html">A year before brexit: Britain solves the problem of labor shortage through robotization</a></li>
<li><a href="../421931/index.html">The Impact of Specter, Meltdown, and Foreshadow Protection on Linux 4.19 Performance</a></li>
<li><a href="../421933/index.html">Examination of the file system HDD video recorder model QCM-08DL</a></li>
<li><a href="../421935/index.html">First impressions of the transition from Ubuntu 16.04 LTS to Ubuntu 18.04 LTS</a></li>
<li><a href="../421937/index.html">Smart City Inside - Huawei View</a></li>
<li><a href="../421945/index.html">Google and Mastercard make a secret shopping tracking deal</a></li>
<li><a href="../421947/index.html">Welcome to Android Devs Meetup September 8</a></li>
<li><a href="../421949/index.html">The suicide squad. How we recruit the most brutal junior developers</a></li>
<li><a href="../421953/index.html">Summ3r 0f h4ck: the results of a summer internship at Digital Security</a></li>
<li><a href="../421955/index.html">The Senate does not want robots to be distracted by beer. And what else to write on Friday?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>