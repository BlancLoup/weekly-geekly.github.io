<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WavPlayer - we are not looking for easy ways, we are laying them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, telephony involves voice transmission. Nobody needs a full band of 20Hz-20kHz for voice transmission, for a clear distinguishable and rec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WavPlayer - we are not looking for easy ways, we are laying them</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://datacompboy.ru/wavplayer/index.html"><img src="https://habrastorage.org/getpro/habr/post_images/3db/5cb/18e/3db5cb18e25683f46b4117f74bff8bb0.png" align="right"></a>  As you know, telephony involves voice transmission.  Nobody needs a full band of 20Hz-20kHz for voice transmission, for a clear distinguishable and recognizable voice it is quite enough up to 3.5kHz.  To be more precise, the <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D0%25B3%25D0%25BE%25D0%25BB%25D0%25BE%25D1%2581%25D0%25B0">speech frequency band</a> used in telephony is from 300 to 3400 Hz.  When compressed into a common channel, for precise allocation, guard frequencies are needed at the edges, therefore the bandwidth is 4 kHz.  When digitizing it turns out 8kHz.  Now, due to the development of the thickness of communication channels, the same Skype and others, boasting of "higher" quality, use 16kHz, and even 32kHz, which, by the way, is really practically impossible to be heard by ear during normal conversation (but quality of the communication channel, but when it bothered the marketplug). <br><br>  So, almost all the audio files that are used in telephony, recorded with 8 kHz digitization.  To speed up the processing of large streams, the compression methods used are just as simple and aimed at a decent result when applied to the desired one - speech compression.  These are simple digitization ( <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BC%25D0%25BF%25D1%2583%25D0%25BB%25D1%258C%25D1%2581%25D0%25BD%25D0%25BE-%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">PCM</a> ), simple delta codecs (ADPCM, <a href="http://ru.wikipedia.org/wiki/G.711">G711</a> ), or smart codecs ( <a href="http://ru.wikipedia.org/wiki/GSM-FR">GSM 06.10</a> ).  These formats are "native" for telephony systems - asterisk, freeswitch (and probably others too).  In these formats, data are prepared for people to play the system, and systems can record recordings into the same formats. <br><br>  However, now the web is sweeping across the planet, and people want to be able to listen to recordings of conversations, greetings, etc. on the web, where mp3 has become the ‚Äúnative‚Äù format ... <br><a name="habracut"></a><br>  As a result, for the rare ‚Äúlisten to the archive‚Äù function, a naive solution is to set up transcoding entries from the telephone format to MP3 on the server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All anything, but: <ul><li>  in mp3, the recordings become either bigger or worse; </li><li>  transcoding to mp3 requires server CPU load; </li><li>  recoding occurs after the fact, and not on the fly (although there is also a treatment for this); </li><li>  The recoded files are essentially only for the client. </li></ul><br>  Seeing this disgrace, the soul of an engineer fell ill and began to demand to do well.  And it‚Äôs not ‚Äúto do badly, and then as it was,‚Äù namely, it‚Äôs good and straightforward: after all, in fact, the codecs used in telephony are designed for a good result, and it‚Äôs extremely cheap.  So why make an expensive encoding operation in MP3, so that you can do an expensive decoding operation from an MP3 on the client just because this decoder is already there?  Let's just make this the easiest decoder on the client, and that's it! <br><br>  I was particularly surprised by the absence of these ready-made decoders.  This is how <a href="https://github.com/datacompboy/WavPlayer">WavPlayer</a> was born: a flash player for telephony files. <br><br>  What he can do: <ul><li>  GUI with jump bar for recording, GUI without it, no UI at all </li><li>  API for managing and drawing the entire interface on the JS side </li><li>  Support codecs: PCM, G.711u / a, GSM 06.10, IMA ADPCM </li><li>  Formats support: AU, WAV, several standard RAW </li></ul><br>  And recently, users have added a proxy to a standard MP3 player so that only WavPlayer can be used to play both native and transcoded archives.  (Initially, I did not do this, assuming that it is JS‚Äôs concern to use any of the flash-mp3 players, html5, or use WavPlayer). <br><br>  Anyone who reads the descriptions of each of the codecs and formats will understand that the player is as simple as a cork.  But if this were so, he would have existed a long time ago ... Therefore, I will briefly tell the story of its creation. <br><br>  To play sounds in a flash, initially only one thing was assumed: playing mp3 inserts.  Everything.  Nothing else.  Beginning with version 10, a sampleData event appeared in the flash.media.Sound interface that allows you to generate and play the generated sound.  But as befits a flash, it only does it in its own way: only 44kHz, only stereo, only 32bit floating point numbers. <br><br>  And we have - 8kHz / 16kHz integers.  If we just take the source data and just give out as-is, we get something that is not legible and has a very high frequency.  Conclusion?  It is necessary to interpolate our existing samples - to make in other words Resample. <br><br>  When resamplinging, it is important to understand that even with a simple frequency doubling, it is impossible to simply take and insert "average" numbers between two samples - the resulting sound will "whistle" very high frequencies, since instead of a smooth sinusoid we will get a saw.  Correct resampling is obtained by restoring the original smooth sound (minimizing the second derivative), and re-digitizing it at the desired frequency.  This way we get the right smooth sound with the desired sample rate. <br><br>  As I, of course, know the theory, but in practice I was very lazy, and the task was to ‚Äúplay records‚Äù quite acutely, I had to decide quickly.  I do not know the flash, and the working machine under Linux.  I looked at the size of the flash compiler - over a hundred meters, it became so broke that I decided to find an alternative to quickly and easily draw on the flash.  Quick Google gave a wonderful option - <a href="http://haxe.org/">HaXe</a> .  A simple C / java-like language that can be translated into several target platforms, including the flash I need.  He was taken. <br><br>  In general, the <a href="https://github.com/datacompboy/WavPlayer/commit/adf3f2b2f12e556c0e6bf6b0da1d1de12e4ee919">first working mock-up</a> was scrambled: <br><br>  I found a fogg project in which ogg files were manually decoded.  From there, AudioSink was taken, which implements the push interface instead of pull: the buffer to which we write, and when the flash wants the next piece of data, AudioSink gives it to it from the buffer.  Not the most optimal and beautiful implementation, but ready.  As a resampler, the implementation of a Lanczos re-sampler (of the highest quality, based on sinc functions) from OpenJDK was taken in the forehead.  The code is not the most optimal (I later implemented it in pure Action Script - I managed to speed it up almost 4 times), but it works (and I didn‚Äôt need anything else). <br>  The simplest interface: draw a triangle when it is.  At the click, play () starts and a square is drawn.  At the click, two vertical sticks are drawn. <br>  For decoding, the G711 code is taken from Sox, for the PCM code it gave birth to itself. <br><br>  And, of course, a spoon of OOP in this barrel of tyrocode: File and Decoder interfaces, which allow the player to abstract from a specific variation in the main player.  True, interfaces were born out of need, and not systematically, but when was it different?  File works like this - the input data of the file is read, and pushed through the push () method to the decoder.  As soon as all the headers are read, the decoder of the corresponding format is created inside the file, and the audio data will be pushed into it.  The ready () method begins to return true, and from this moment on all other methods of stream metadata also become valid, and you can read the audio stream data with the getSamples () request, which will return samplesAvailable () samples. <br><br>  The work of the decoder is also simple - it tells the sample the size in bytes so that the file can be cut into the necessary packages for feeding the decoder.  A decoder is sequentially used to convert the buffer data into one sample (into signed float). <br><br>  The main problem that forms is the proper feeding of the resampler.  Let me remind you that the resampler works on the principle of virtual double conversion - based on the input data, a smooth signal is restored at the input sampling frequency, which is re-digitized at the output frequency.  History is always needed to restore a signal;  therefore, first the decoder needs to be fed with silence of the desired length, for initialization.  And throw out this silence from the first answer - then we will get the correct resampling right from the beginning.  In the same way, after our data runs out, the resampler must be fed with silence after - in order to get all the recovered information. <br><br>  And this is how our company of soldiers generates exactly how much data at 44kHz in the necessary form. <br><br>  After I earned the base player, I started combing it a bit: the first thing is support for more complex codecs, specifically gsm.  It immediately became clear that not all are decoded by the sample, batch processing is needed here - so the decoder interface was redone to an incoming array + offset, the output array + offset, returning how many samples were placed on the output.  To support Raw files, most of the code is universal; it was moved to a separate general class, so as to override the minimum ‚Äî only the required parameters for it in the initializer.  The GSM decoder itself was taken as usual where it was found, simply transformed quickly into the necessary syntax.  Oddly enough - it all worked with a bang. <br><br>  At the same time, the player control interface was drawn from the JS code + download, play, and pause events were issued, allowing the player to draw the state of the player in the browser as desired.  The resulting product began to file in production.  When they started testing, some problems got out, especially in deeply adorable IE, which loaded the file in chunks, it seems like 8k or 4k ... well, the events eventually generated a ton, I had to kill the frequency of their generation. <br><br>  Unfortunately, it quickly became clear that no one has any desire to make an interface on JS.  Then it was quick and on my knee a decision was made by gui inside.  The player began to generate internal events, and WavPlayerGui was created.  His Mini heir stayed as before - all button;  plus was created Full, which has the same button on the left, and on the right is a progress bar showing the length, volume loaded, and the current position.  Well, that is, there are a few more little squares, the dimensions of which changed in response to events. <br><br>  As soon as it appeared, it became clear that, in general, it should also be beating on it.  And in general, it is completely stupid to listen to records only when you need to listen to the third minute from the 15th minute ... You need to do seek ().  The implementation of seek () in this case turned out to be the most difficult task: since we are unable to load the source file from an arbitrary position (we cannot guarantee the server‚Äôs support for the Range, and in a flash it‚Äôs not so easy to do this), we had to limit the possibilities of seek ( ) 'but only within the loaded part.  But even in this case, we do not store the full amount of data recoded to 44kHz (memory, sob, sorry), so if you need to reposition, the following happens: <br><ul><li>  we check if the seek () goes within the limits of the ready-made 44kHz data - if so, we simply do a check on the finished data. </li><li>  if out, we are looking for a sample, starting from which the playback in terms of the source stream should start </li><li>  the restyler is reinitialized by silence </li><li>  input stream is repositioned to the desired position, </li><li>  we start playing. </li></ul><br><br>  Then there were a few cosmetic modifications from those who started using it in public, and again there was a challenge - can I support IMA ADPCM.  The format is rather ugly, from the point of view of its placement into universality it turned out: the data is not per channel, but mixed up in the same place, so I had to transmit a decoded channel to the decoder as well;  at the same time, we had to endure a bit of universality for all other codecs, because the amount of output data depending on the input for all others is fixed and simple;  and here ... in general, it depends on - a clear story is required, and it is impossible to start decoding from an arbitrary place.  Accordingly, for the seek () function works like this: <br><ul><li>  we check if the seek () goes within the limits of ready-made 44kHz data - if yes, we just do a check on the finished data </li><li>  if out, we are looking for a sample, starting from which the playback in terms of the source stream should start </li><li>  looking for a sample from which to start decoding </li><li>  the restyler is reinitialized by silence </li><li>  the input stream is repositioned to the decoding position </li><li>  do decoding and throwing up to the position with which to start playing </li><li>  we start playing. </li></ul><br><br>  In general, oddly enough, it also works.  And at the moment, it is available for use by everyone: it does exactly what is needed, exactly as it should. <br>  For the full buzz, it remains only to finally do the same JS interface that I thought our web developers would do;  plus make a simple and clear example of integration, which can be put copy-paste'om in your site, because most often the problem of integration, this falls on the shoulders of a sysadmin, not a programmer ... So, to be continued. <br><br>  <a href="https://github.com/datacompboy/WavPlayer">Project on Github</a> |  <a href="http://datacompboy.ru/wavplayer/index.html">Online demo.</a> </div><p>Source: <a href="https://habr.com/ru/post/223293/">https://habr.com/ru/post/223293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223279/index.html">Zabbix. Sending a trigger with a comment</a></li>
<li><a href="../223283/index.html">Service to find music again found guilty of piracy</a></li>
<li><a href="../223287/index.html">Interview with the creator of the game River Raid, Carol Shaw</a></li>
<li><a href="../223289/index.html">New lambda features in C ++ 14</a></li>
<li><a href="../223291/index.html">Thingiverse Service - Universe for 3d printing</a></li>
<li><a href="../223301/index.html">[mind map] Specification of a good PMA</a></li>
<li><a href="../223303/index.html">A bold plan that could save the Columbia shuttle. Part 3</a></li>
<li><a href="../223305/index.html">About p2p traffic restrictions</a></li>
<li><a href="../223309/index.html">Samsung Gear App Challenge app competition</a></li>
<li><a href="../223311/index.html">How-to: Stock Market Futures Trading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>