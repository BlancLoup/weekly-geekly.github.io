<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a hot boot of C ++ code in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Link to the library at the end of the article. The article itself outlines the mechanisms implemented in the library, with medium detail. The implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a hot boot of C ++ code in Linux</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="image"></p><br><p>  * Link to the library at the end of the article.  The article itself outlines the mechanisms implemented in the library, with medium detail.  The implementation for macOS is not yet complete, but it differs little from the implementation for Linux.  This is mainly an implementation for Linux. </p><br><p>  Walking on a githaba one Saturday afternoon, I came across a <a href="https://github.com/crosire/blink">library</a> that implements updating c ++ code on the fly for windows.  I myself got off windows a few years ago, not a bit sorry, and now all programming happens on either Linux (at home) or macOS (at work).  A little googling, I found that the approach from the library above is quite popular, and msvc uses the same technique for the "Edit and continue" function in Visual Studio.  The only problem is that I have not found a single implementation under non-windows (I looked bad?).  Asked the author of the library above, whether he would make a port for other platforms, the answer was negative. </p><br><p>  I will say <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus">right away</a> that I was only interested in the option in which I would not have to change the existing project code (as, for example, in the case of <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus">RCCPP</a> or <a href="https://github.com/fungos/cr">cr</a> , where all potentially reloadable code should be in a separate dynamically loaded library). </p><br><p>  "How so?"  - I thought, and began to smoke incense. </p><a name="habracut"></a><br><h2 id="zachem">  What for? </h2><br><p>  I mainly do game devs.  Most of my work time I spend on writing game logic and layout of any visual.  In addition, I use imgui for auxiliary utilities.  My code cycle, as you probably guessed, is Write -&gt; Compile -&gt; Run -&gt; Repeat.  Everything happens pretty quickly (incremental build, all sorts of ccache, etc.).  The problem here is that this cycle has to be repeated quite often.  For example, I am writing a new game mechanics, let it be a "Jump", a suitable, controlled Jump: </p><br><p>  1. Wrote a draft implementation based on an impulse, assembled, launched.  I saw that I accidentally put an impulse every frame, not just once. </p><br><p>  2. Fixed, collected, launched, now normal.  But it would be necessary to take the absolute value of the impulse more. </p><br><p>  3. Fixed, assembled, launched, running.  But somehow felt wrong.  We must try on the basis of strength to do. </p><br><p>  4. Wrote a draft implementation based on strength, assembled, launched, running.  It would be necessary only to change the instantaneous speed at the time of the jump. <br>  ... </p><br><p> 10. Fixed, collected, launched, works.  But still not that.  Probably need to try the implementation based on the change <code>gravityScale</code> . <br>  ... </p><br><p>  20. Great, looks great!  Now we take out all the parameters in the editor for gamediz, test and fill. <br>  ... </p><br><p>  30. Jump ready. </p><br><p>  And at each iteration, you need to collect the code and in the running application to get to the place where I can jump.  It usually takes at least 10 seconds.  And if I can jump only in open areas, which still need to get to?  And if I need to be able to jump on blocks of height N units?  Here I already need to collect a test scene, which also needs to be debugged, and for which I also need to spend time.  For such iterations, a hot reload of the code would be ideal.  Of course, this is not a panacea, it is far from being suitable for everything, and even after a reboot, sometimes you need to re-create a part of the game world, and this should be taken into account.  But in many things it can be useful and can save concentration and a lot of time. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Requirements and problem statement </h2><br><ul><li>  When changing the code, the new version of all functions should replace the old versions of the same functions. </li><li>  This should work on Linux and macOS. </li><li>  This should not require changes to the existing application code. </li><li>  Ideally, this should be a library, statically or dynamically linked to the application, without third-party utilities. </li><li>  It is desirable that this library does not greatly affect the performance of the application. </li><li>  It is enough if it works with cmake + make / ninja </li><li>  It is enough if it works with debug builds (without optimizations, without cutting characters and other things) </li></ul><br><p>  This is the minimum set of requirements that an implementation must satisfy.  Looking ahead, I will briefly describe what was implemented additionally: </p><br><ul><li>  Transferring the values ‚Äã‚Äãof static variables to a new code (see section "Transferring Static Variables" to find out why this is important) </li><li>  Reboot based on dependencies (changed the heading -&gt; reassembled <del>  half-project </del>  all dependent files) </li><li>  Reload code from dynamic libraries </li></ul><br><h2 id="realizaciya">  Implementation </h2><br><p>  Up to this point, I was very far from the data domain, so I had to collect and assimilate information from scratch. </p><br><p>  At a high level, the mechanism looks like this: </p><br><ul><li>  Monitor the file system for changes in the source </li><li>  When the source changes, the library rebuilds it using the compile command that this file has already collected. </li><li>  All collected object books are linked to a dynamically loaded library. </li><li>  The library is loaded into the process address space. </li><li>  All functions from the library replace the same functions in the application. </li><li>  Static variable values ‚Äã‚Äãare transferred from application to library. </li></ul><br><p>  Let's start with the most interesting thing - the mechanism for reloading functions. </p><br><h4 id="perezagruzka-funkciy">  Reloading functions </h4><br><p>  Here are 3 more or less popular ways of replacing functions in (or almost at) runtime: </p><br><ul><li>  <a href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick">The trick with LD_PRELOAD</a> - allows you to build a dynamically loadable library with, for example, the <code>strcpy</code> function, and make it so that when you start the application, it takes my version of <code>strcpy</code> instead of the library </li><li>  Modifying <a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT tables</a> - allows you to "overload" exported functions </li><li>  <a href="https://jbremer.org/x86-api-hooking-demystified/">Function hooking</a> - allows you to redirect the flow of execution from one function to another </li></ul><br><p>  The first 2 options are obviously not suitable, since they work only with exported functions, and we do not want to mark all the functions of our application with any attributes.  Therefore, Function hooking is our option! </p><br><p>  In short, hooking works like this: </p><br><ul><li>  The address of the function is located. </li><li>  The first few bytes of the function are overwritten by unconditional transfer to the body of another function. </li><li>  ... </li><li>  Profit! <br>  In msvc for this there are 2 flags - <code>/hotpatch</code> and <code>/FUNCTIONPADMIN</code> .  The first one to the beginning of each function records 2 bytes, which do nothing, for their subsequent rewriting with a "short jump".  The second allows you to leave an empty place in front of the body of each function in the form of <code>nop</code> instructions for the "long jump" to the desired place, so in 2 jumps you can switch from the old function to the new one.  You can read more about how this is implemented in windows and msvc, for example, <a href="https://www.codeproject.com/Articles/737907/%252FArticles%252F737907%252FTaking-advantage-of-Windows-Hot-Patching-mechanism">here</a> . </li></ul><br><p>  Unfortunately, in clang and gcc there is nothing similar (at least under Linux and macOS).  In fact, this is not such a big problem, we will write directly on top of the old function.  In this case, we risk getting into trouble if our application is multi-threaded.  If usually in a multi-threaded environment, we restrict access to data by one stream while another stream modifies them, then we need to limit the ability to execute code by one stream, while another stream modifies this code.  I have not figured out how to do this, so the implementation will behave unpredictably in a multithreaded environment. </p><br><p>  There is one subtle point.  On a 32-bit system, 5 bytes is enough for us to "jump" to any place.  On a 64-bit system, if we don‚Äôt want to spoil registers, we will need 14 bytes.  The bottom line is that 14 bytes in machine code scale is quite a lot, and if there is any stub function with an empty body in the code, it is likely to be less than 14 bytes in length.  I don‚Äôt know the whole truth, but I spent some time behind the disassembler while I thought, wrote and debugged the code, and I noticed that all functions are aligned on a 16-byte boundary (debug build without optimizations, not sure about optimized code).  And this means that between the beginning of any two functions there will be at least 16 bytes, which is enough for us to ‚Äúsnag‚Äù them.  Superficial googling led <a href="https://stackoverflow.com/questions/22235236/how-much-does-function-alignment-actually-matter-on-modern-processors">here</a> , but I don‚Äôt know for sure, I was just lucky, or today all compilers are doing it.  In any case, if in doubt, simply declare a couple of variables at the beginning of the stub function so that it becomes large enough. </p><br><p>  So, we have the first bit - the mechanism for redirecting functions from the old version to the new one. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Search for functions in a shared program </h4><br><p>  Now we need to somehow get the addresses of all (not only exported) functions from our program or an arbitrary dynamic library.  This can be done quite simply using system api, if characters are not cut out of your application.  On Linux, this is api from <code>elf.h</code> and <code>link.h</code> , on macOS - <code>loader.h</code> and <code>nlist.h</code> . </p><br><ul><li>  Using <code>dl_iterate_phdr</code> we go through all the loaded libraries and, in fact, the program </li><li>  Find the address where the library is loaded </li><li>  From the <code>.symtab</code> section, <code>.symtab</code> retrieve all the information about the characters, namely the name, type, index of the section in which it lies, its size, and also we calculate its ‚Äúreal‚Äù address based on the virtual address and the library loading address </li></ul><br><p>  There is one subtlety.  When loading the elf file, the system does not load the <code>.symtab</code> section (correct it if it is wrong), and the <code>.dynsym</code> section does not suit us, because we cannot get characters with visibility <code>STV_INTERNAL</code> and <code>STV_HIDDEN</code> .  Simply put, we will not see such features: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  and such variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Thus, in the 3rd paragraph we work not with the program that <code>dl_iterate_phdr</code> gave <code>dl_iterate_phdr</code> , but with the file that we downloaded from the disk and parsed with some elf parser (or on a bare api).  So we won't miss anything.  On macOS, the procedure is similar, only the function names from the system api are different. </p><br><p>  After that we filter all characters and save only: </p><br><ul><li>  The functions that can be rebooted are <code>STT_FUNC</code> type <code>STT_FUNC</code> located in the <code>.text</code> section that have a non-zero size.  Such a filter only passes functions whose code is actually contained in this program or library. </li><li>  Static variables whose values ‚Äã‚Äãneed to be transferred are symbols of type <code>STT_OBJECT</code> , located in the <code>.bss</code> section </li></ul><br><h2 id="edinicy-translyacii">  Broadcast units </h2><br><p>  To reload the code, we need to know where to get the source code files and how to compile them. </p><br><p>  In the first implementation, I read this information from the <code>.debug_info</code> section, which contains debug information in the DWARF format.  In order for each translation unit (ET) within the DWARF to contain the compilation line of this ET, it is necessary to pass fach <code>-grecord-gcc-switches</code> when compiling.  I myself parsed DWARF library <code>libdwarf</code> , which comes with <code>libelf</code> .  In addition to the compilation command from DWARF, you can also get information about the dependencies of our ETs on other files.  But I refused this implementation for several reasons: </p><br><ul><li>  Libraries are quite weighty </li><li>  Parsing DWARF applications assembled from ~ 500 ET, with dependency parsing, took a little more than 10 seconds </li></ul><br><p>  10 seconds at the start of the application - too much.  After some deliberation, I rewrote the logic of parsing DWARF to parsing <code>compile_commands.json</code> .  This file can be generated by simply adding <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> to your CMakeLists.txt.  This way we get all the information we need. </p><br><h2 id="obrabotka-zavisimostey">  Dependency handling </h2><br><p>  Since we have abandoned DWARF, we need to find another way to handle dependencies between files.  Parse the files with your hands and look for them, you really don‚Äôt want to, and who knows more about dependencies than the compiler itself? </p><br><p>  In clang and gcc there are a number of options that generate so-called depfiles almost for free.  These files use the make and ninja build systems to resolve dependencies between files.  Depfiles have a very simple format: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  The compiler puts these files next to the object files for each ET, we need to parse them and put them into the hashmap.  Total parsing <code>compile_commands.json</code> + depfiles for the same 500 ET takes a little more than 1 second.  In order for everything to work, we need to globally add the <code>-MD</code> flag for all project files in the compile option. </p><br><p>  There is one subtlety associated with ninja.  This build system generates depfiles regardless of the presence of the <code>-MD</code> flag for its needs.  But after they are generated, it translates them into its binary format, and deletes the source files.  Therefore, when running ninja, you must pass the <code>-d keepdepfile</code> flag.  Also, for reasons unknown to me, in the case of make (with the <code>-MD</code> option), the file is named <code>some_file.cpp.d</code> , while with ninja it is called <code>some_file.cpp.od</code> .  Therefore, you need to check the availability of both versions. </p><br><h2 id="perenos-staticheskih-peremennyh">  Static variable transfer </h2><br><p>  Suppose we have such a code (a very synthetic example): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  We want to change the <code>veryUsefulFunction</code> function to: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  When restarting to the dynamic library with the new code, besides the <code>veryUsefulFunction</code> , the static variable <code>static Singleton ins;</code> will fall <code>static Singleton ins;</code>  and method <code>Singletor::instance</code> .  As a result, the program will start calling up new versions of both functions.  But static <code>ins</code> in this library has not yet been initialized, and therefore the first access to it will call the constructor of the class <code>Singleton</code> .  We certainly do not want this.  Therefore, the implementation transfers the values ‚Äã‚Äãof all such variables that it finds in the compiled dynamic library from the old code to this very dynamic library with the new code along with their <a href="https://monoinfinito.wordpress.com/2013/12/03/static-initialization-in-c/">guard variables</a> . </p><br><p>  There is one subtle and generally insoluble moment. <br>  Suppose we have a class: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  The method <code>calledEachUpdate</code> is called 60 times per second.  We change it by adding a new field: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  If an instance of this class is located in the dynamic memory or on the stack, after reloading the code, the application is likely to fall.  The allocated instance contains only the <code>m_someVar1</code> variable, but after a reboot, the method <code>calledEachUpdate</code> will try to change <code>m_someVar2</code> , changing what actually does not belong to this instance, which leads to unpredictable consequences.  In this case, the logic of transferring the state is transferred to the programmer, who must somehow save the state of the object and delete the object itself before reloading the code, and create a new object after the reboot.  The library provides events in the form of the <code>onCodePreLoad</code> and <code>onCodePostLoad</code> delegate methods that the application can handle. </p><br><p>  I do not know how (and whether it is possible) to resolve this situation in a general way, I will think.  Now this case "more or less normally" will work only for static variables, the following logic is used there: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  This is not very correct, but it is the best that I came up with. </p><br><p>  As a result, the code will behave unpredictably if the set and layout of fields in the data structures change in runtime.  The same applies to polymorphic types. </p><br><h2 id="sobiraem-vse-vmeste">  Putting it all together </h2><br><p>  How it all works together. </p><br><ul><li>  The library is iterated by the headers of all the libraries dynamically loaded into the process and, in fact, by the program itself, it parses and filters the characters. </li><li>  Further, the library tries to find the file <code>compile_commands.json</code> in the application directory and in the parent directories recursively, and gets out all the necessary information about the ET. </li><li>  Knowing the path to the object files, the library loads and parses the depfiles. </li><li>  After that, the most common directory for all files of the program source code is calculated, and monitoring of this directory starts recursively. </li><li>  When a file changes, the library looks to see if it is in a hashmap of dependencies, and if there is, it starts in the background several compilation processes of the modified files and their dependencies using the compile commands from <code>compile_commands.json</code> . </li><li>  When the program asks to reload the code (in my application, the combination <code>Ctrl+r</code> is assigned to it), the library waits for the completion of the compilation processes and links all the new object files to the dynamic library. </li><li>  Then this library is loaded into the address space of the process by the <code>dlopen</code> function. </li><li>  Information on symbols is loaded from this library, and the entire intersection of the set of symbols from this library and symbols already living in the process is either reloaded (if it is a function), or transferred (if it is a static variable). </li></ul><br><p>  It works very well, especially when you know what is under the hood and what to expect, at least at a high level. </p><br><p>  Personally, I was very surprised by the lack of such a solution for Linux, is nobody really interested in this? </p><br><p>  I will be glad to any criticism, thanks! </p><br><p>  <a href="https://github.com/ddovod/jet-live"><strong>Reference to implementation</strong></a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435260/">https://habr.com/ru/post/435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435250/index.html">How ITMO University works: a tour of our cyber-physical systems lab</a></li>
<li><a href="../435252/index.html">Jessica Livingston: ‚ÄúHow we created the Y Combinator. Emotional component "</a></li>
<li><a href="../435254/index.html">Functional error handling in Kotlin using Arrow</a></li>
<li><a href="../435256/index.html">Evaluate recruiters for cold letters</a></li>
<li><a href="../435258/index.html">We write our programming language, part 2: intermediate presentation of programs</a></li>
<li><a href="../435262/index.html">Li-Fi: The Future of the Internet</a></li>
<li><a href="../435264/index.html">Editing prices in the RMK. 1C: Trade Management 11</a></li>
<li><a href="../435268/index.html">Do not treat me, doctor</a></li>
<li><a href="../435272/index.html">Cycling phobia</a></li>
<li><a href="../435274/index.html">PVS-Studio and Bug Bounties on Free and Open Source Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>