<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recursion formulas for calculating iterative summation errors of binary numbers of limited length</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will continue the consideration of the problem of computer calculations of decimal numbers with the help of binary arithmetic, whic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recursion formulas for calculating iterative summation errors of binary numbers of limited length</h1><div class="post__text post__text-html js-mediator-article">  In this article we will continue the consideration of the problem of computer calculations of decimal numbers with the help of binary arithmetic, which was addressed in the previous topic [1].  The article discusses errors that are commonly referred to in literature as rounding errors.  And, in particular, errors that are generated as a result of the iterative summation of a large number of identical decimal numbers, represented in binary form by a limited bit space.  As a result of the research, simple recurrence relations were obtained, which allow to accurately determine the error of computer iterative calculations of the partial sums of any number of identical terms, at any iteration step. <br><a name="habracut"></a><br>  We will consider real positive binary numbers with a fixed number of L significant digits.  By a fixed number L of significant digits, we mean L digits, which are counted from left to right, starting from the highest nonzero digit.  The missing number of digits in the number to the right is padded with zeros.  So, if the number of significant digits is fixed with the value L = 5, then the number 0.0011 will have the following significant digits: 11000. If we now write our number to a 5-bit computer as a floating-point number, then the machine mantissa will be written: .11000 .  This number will be represented in the computer in a normalized form with an exponent equal to 2 ^ -2. <br><br>  A floating-point number is written in a machine word, as the product of a fractional mantissa by an exponent, the order of which indicates the position of a point in a number represented in its natural form.  If the number of digits of the mantissa number does not coincide with the number of L bits of the machine mantissa, the number is normalized by shifting the mantissa to one side or the other so that the highest nonzero digit of the number is located in the highest digit of the machine mantissa.  The order of the exponent is adjusted for the number of shifts. <br><br>  Consider the number in a natural form.  If the number of its significant digits exceeds some fixed number of L digits, then it must be converted so that the number of its significant digits becomes equal to L. This is achieved by discarding the extra low-order digits.  When discarding low-order digits, the number may be rounded to L digits, or extra low-order digits are simply truncated.  So, in the case of truncation, the binary number 10.0011, presented in its natural form, for L = 5, will be written as 10.001.  The same number, written in an exponential normalized form, will look like 0.10001 * 2 ^ 2.  Here we have two equivalent entries of the same number. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Reduction of the number presented in its natural form to a number with the number of significant digits L will be called optimization.  We introduce this concept to distinguish it from the operation of normalizing numbers written in an exponential form.  From a mathematical point of view, these are two equivalent operations. <br><br>  Next, we will consider the case of truncating the lower digits in the binary number without rounding.  The numbers will be considered presented in the natural form. <br><br>  Suppose we have a number 2 ^ p ‚â§Z &lt;2 ^ (p + 1), where p is a signed integer equal to the distance from the separating point to the highest nonzero digit in the number Z, written in its natural form.  If the highest nonzero digit is located to the left of the point, then p&gt; 0. If the digit is located to the right of the point, then p &lt;0. So, for the number Z = 0.000101 we will have p = -4 and for this case: 2 ^ (- 4) ‚â§Z &lt;2 ^ (- 3). <br>  Consider the sequence of real binary numbers X <sub>0</sub> , X <sub>1</sub> , ... X <sub>i</sub> ... lying in the intervals: <br>  2 ^ p ‚â§ X <sub>0</sub> &lt;2 ^ (1 + p) ‚â§ X <sub>1</sub> &lt;2 ^ (2 + p); ...;  2 ^ (i + p) ‚â§ X <sub>i</sub> &lt;2 ^ (i + p + 1) ... <br><br>  For example, for p = -3 we will have 2 ^ p = 2 ^ -3 = 0.001.  Our sequence will then look like 0.001 ‚â§ X <sub>0</sub> &lt;0.01 ‚â§ X <sub>1</sub> &lt;0.1, ..., 2 ^ (i -3) ‚â§ X <sub>i</sub> &lt;2 ^ (i -2) ... <br><br>  Take some real number 2 ^ (i + p) ‚â§ X <sub>i</sub> &lt;2 ^ (i + p + 1) with a limited number of L significant digits.  Next, take the sum of the k <sub>i</sub> elementary terms: Z + Z + ... = k <sub>i</sub> Z, where Z = X <sub>0</sub> , k <sub>i</sub> ‚â• 0 is an integer.  Choose k <sub>i</sub> such that 2 ^ (i + p) ‚â§ X <sub>i</sub> + k <sub>i</sub> Z &lt;2 ^ (i + p +1).  In this sum, the maximum number of k <sub>i</sub> elementary terms of Z, at which the value of the sum does not exceed the right boundary of the interval, can be found by the formula k <sub>i</sub> = ‚åä (2 ^ (i + p + 1) -X <sub>i</sub> ) / Z‚åã, where brackets ‚åã means round down to the nearest integer. <br><br>  If we now add another elementary term Z to X <sub>i</sub> + k <sub>i</sub> Z, we get X <sub>i + 1</sub> = X <sub>i</sub> + k <sub>i</sub> Z + Z = X <sub>i</sub> + Z (k <sub>i</sub> +1) ‚â• 2 ^ (i + p +1 ).  The value of the newly received amount will exceed or will be equal to the right boundary value of the interval.  Therefore, the number of digits in the number X <sub>i + 1</sub> = X <sub>i</sub> + Z (k <sub>i</sub> +1) becomes L + 1.  To fulfill the requirement that the number of significant digits be equal to L, the resulting number must be optimized, i.e.  lead to the number in which there will be L significant digits.  To do this, it is necessary to discard the younger digit.  The operation of discarding the lower digit in the number X <sub>i</sub> will be written as X <sub>i</sub> <sup>¬¨1</sup> .  For example, if in the number X = 10.0011 one small digit is discarded, then it will be written as X <sup>¬¨1</sup> = <sup>10.001</sup> .  In the general case, the entry X <sup>¬¨t</sup> will mean that among the X the t low-order bits are dropped. <br><br>  After at a certain iterative step the partial sum X <sub>i + 1</sub> = X <sub>i</sub> + Z (k <sub>i</sub> +1) exceeds the value 2 ^ (i + p +1), which we will call the right boundary value, the highest nonzero digit of the sum will be offset from a fixed point to the left.  The total number of significant digits will exceed the L number by one and the result should be optimized.  Since at the i-th iteration step as a result of the optimization, in the number X <sub>i the</sub> lower digit is discarded, the number becomes equal to X <sub>i</sub> <sup>¬¨1</sup> , then the younger digit in the term Z can also be discarded, since  it will not affect further calculations. <br><br>  For example.  Let L = 5.  Find the sum of two numbers X = 1.10111 and Z = 0.10011.  Since  the number of digits in X exceeds the value of L, it must be optimized.  After optimization we get: X <sup>¬¨1</sup> = 1.1011.  Add to this number Z = 0.1001 ** 1 **.  We <sup>get</sup> X <sup>¬¨1</sup> + Z = 1.1011 + 0.1001 ** 1 ** = 10.0100 ** 1 **.  Here the number of digits after the decimal point in the term X <sup>¬¨1 is</sup> less than the number of digits in the term Z. Therefore, the lower digit in Z, marked in bold, on the one hand, always adds up to zero, and on the other hand, the result of adding lower digits in this case is out of range L significant digits and, therefore, when truncated, does not affect the total amount.  It follows that the amount will not change if it is written as X <sup>¬¨1</sup> + Z <sup>¬¨1</sup> = 1.1011 + 0.1001 = 10.0100.  Since in this sum the number of digits exceeded the value of L, the resulting number should also be optimized.  Rejecting the lower digit, we get an optimized number of 10.010 with L = 5 significant digits. <br><br>  Thus, the values ‚Äã‚Äãof the partial sums X <sub>i</sub> and X <sub>i + 1</sub> differ by a maximum of k <sub>i</sub> elementary terms.  The number of significant digits of partial sums lying in the interval [X <sub>i</sub> , X <sub>i + 1</sub> ) is L and therefore their values ‚Äã‚Äãare calculated without rounding and, accordingly, do not introduce errors.  The addition of the (k <sub>i + 1</sub> ) -th term to the partial sum leads to the excess of the right boundary value or its equality.  If the partial sum at any iteration step exceeds or equals the right limit value, then the number of significant digits in the sum becomes equal to L + 1 and optimization is required.  After each excess of the right boundary value, the number of significant digits of elementary terms Z, participating in the formation of new partial sums, decreases by one and after the ith right boundary value, the elementary term becomes equal to Z <sup>¬¨i</sup> . <br><br>  <b>X <sub>i + 1</sub> = (X <sub>i</sub> + (k <sub>i + 1</sub> +1) Z <sup>¬¨i</sup> ) <sup>¬¨1</sup> , X <sub>0</sub> = Z, i = 0.1 ...</b> <b><br><br></b>  <b>k <sub>i + 1</sub> = ‚åä (2 ^ (p + i) -X <sub>i</sub> ) / Z <sup>¬¨i</sup> , p is a signed integer.</b> <br><br>  The iteration step number N <sub>i + 1</sub> , at which the partial sum X <sub>i + 1</sub> exceeded the right boundary value, can be determined by the recurrence relation: <br><br>  N <sub>i + 1</sub> = (k <sub>i + 1</sub> +1) + N <sub>i</sub> . <br><br>  Let us now consider what error we get in iterative summation of decimal real numbers, represented in binary form, as a result of the truncation operation. <br><br>  It is known that any decimal number X represented in binary form, after truncating the number of significant digits, can be written as X = B + g, where B is the representation of the decimal number X in binary form with a limited fixed number of significant digits, g is the absolute error representation of the number as a result of truncation.  This error can be defined as g = XB, g ‚â•0.  When summing i elementary terms, this error accumulates and becomes equal to ig. <br><br>  However, this is not the only error that is formed by the recurrent addition of the same elementary terms.  As a result of rounding or truncation, when recurrently calculating partial sums, rounding errors are also generated. <br><br>  The recurrence relations that we derived make it possible at any iteration step to obtain exact error values ‚Äã‚Äãfor calculating the sum of elementary terms that have the same values. <br><br>  Consider, for example, partial sums of elementary terms Z = 0.0011101, for which L = 5.  For the number Z, we will have p = 0.001.  Table 1 shows the results of the addition of 10 elementary terms for each iteration step. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e2c/9a5/e1a/e2c9a5e1ad814b0dac78ad894b180a18.png"></div><br>  Column 1 of the table shows the numbers i of the partial sums X <sub>i</sub> that exceeded or became equal to the right edge of the interval.  The second column shows the numbers of iterations j.  Column 3 shows the designations of the partial sums X <sub>i</sub> for a certain value of i.  Column 4 of the table shows each other under each other, respectively, the designations of the partial sums S <sub>j</sub> and the elementary terms Z <sup>¬¨i</sup> for each iteration step.  Column 5 shows each other, respectively, the values ‚Äã‚Äãof the partial sums S <sub>j</sub> and the elementary terms Z <sup>¬¨i</sup> for each iteration step.  The red font marked digits of numbers that do not participate in the formation of partial sums.  Column 6 shows the values ‚Äã‚Äãof the coefficients k <sub>i + 1</sub> +1, which are used in our recurrent formula to calculate X <sub>i + 1</sub> .  Column 7 shows each other under each other, respectively, the values ‚Äã‚Äãof the partial sums S <sub>j</sub> and the elementary terms Z <sup>¬¨i</sup> for each iteration step in decimal form.  Column 8 shows the theoretical values ‚Äã‚Äãof the sum of the elementary components of Z, provided that rounding errors are not taken into account.  Column 9 presents the values ‚Äã‚Äãof the absolute calculation errors at each iteration step, which are calculated by the formula Œî = (S <sub>j</sub> ) <sub>10</sub> - jZ <sup>¬¨0</sup> .  Column 9 presents the values ‚Äã‚Äãof relative errors calculated by the formula: Œ¥ = Œî / jZ <sup>¬¨0</sup> . <br><br>  As can be seen from the table above, even under the condition that the elementary terms are presented accurately, without representation errors, in the process of iterative summation such an error is very quickly formed that calculations at a certain iteration step become meaningless.  The reason for this error lies in the limited machine words, as well as in the normalization procedure, or, in our case, the optimization of the representation of numbers. <br><br>  Below we present Table 2, in which the values ‚Äã‚Äãof partial sums are presented during iterative summation of the decimal number 0.1 in binary form with a fixed number of significant digits for the 51 bit mantissa.  The table shows the values ‚Äã‚Äãof the partial sums at the points of exceeding the right boundary values.  The numbers in bold in the table are binary.  Non-bold numbers are numbers represented in decimal code.  This table shows the values ‚Äã‚Äãof the partial sums <b>X <sub>i</sub></b> , the values ‚Äã‚Äãof the coefficients k <sub>i + 1</sub> +1 for finding the next partial sum <b>X <sub>i + 1</sub></b> in accordance with our recurrence relations. <br><br>  The iteration step number N <sub>i + 1</sub> , at which the next partial amount exceeded the right limit value, can be determined by the recurrence relation: N <sub>i + 1</sub> = (k <sub>i + 1</sub> +1) + N <sub>i</sub> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/97c/22b/a2c/97c22ba2cc3245a397ac9393f02cc3b5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f38/5ee/6e8/f385ee6e8ef44b219b67cf565cdf53d4.png"></div><br>  As can be seen from Table 2, with the number of iterations 5368712233 already in the 6th sign of the partial sum we have the wrong number.  The absolute computation error for this case is Œî = 536871223.3-536870912.084052 = 311.215948.  And the relative error will be equal to Œ¥ = 311.215948 / 536871223.3‚âà0.0000006 = 0.00006%. <br><br>  At the same time, if we calculate the error in representing the decimal number 0.1 in binary form with 51 significant digits, then we will have: 0.1 = 0.0001100110011001100110011001100110011001100110011001100‚âà 0.09999999999999997779 <br>  Œî = 0.1-0.09999999999999997779‚âà2.221 * 10 ^ (- 17), <br>  Œ¥ = 2.221 * 10 ^ (- 17) /0.1=2.221*10 ^ (- 16) = 14 * 10 ^ (- 14)%. <br><br>  At the iteration step, equal to 5368712233, the total absolute error of the representation takes the value 5368712233 * 14 * 10 ^ (- 18) ‚âà 0.000000075.  The relative error of representation does not change at any iteration step. <br><br>  As we can see, the absolute error of representation is negligible compared to the rounding error in iterative summation. <br>  The recurrent formulas we presented here allowed us to obtain accurate calculated rounding errors in the iterative summation of a large number of identical decimal terms represented in binary code. <br><br>  The author thanks the user <a href="https://habrahabr.ru/users/mayorovp/" class="user_link">mayorovp</a> for the inaccuracies found. <br><br>  LITERATURE <br>  1. <a href="https://habrahabr.ru/post/309812/">habrahabr.ru/post/309812</a> </div><p>Source: <a href="https://habr.com/ru/post/317786/">https://habr.com/ru/post/317786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317774/index.html">Oracle In-Memory Option Performance Testing with TPC-H Benchmark</a></li>
<li><a href="../317776/index.html">CSS styles for printing that I forgot</a></li>
<li><a href="../317778/index.html">How to motivate yourself to perform pending tasks</a></li>
<li><a href="../317780/index.html">Hacking without hacking or seven ways to find resource leaks</a></li>
<li><a href="../317784/index.html">Fighting HPE Vertica loads</a></li>
<li><a href="../317788/index.html">Unit testing in modern teams</a></li>
<li><a href="../317792/index.html">Story about the first RDSFront & Meetup</a></li>
<li><a href="../317794/index.html">Security Week 50: crypto-socialization socialization, OpenVPN audit, Linux kernel vulnerability</a></li>
<li><a href="../317796/index.html">Creating tools for researching NES games</a></li>
<li><a href="../317798/index.html">Looking for familiar faces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>