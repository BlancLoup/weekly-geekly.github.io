<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to perform ancestral methods in implementing prototype inheritance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When working with inheritance, sometimes there is a desire to have a function for accessing the ancestor method (the parent class method) - in the con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to perform ancestral methods in implementing prototype inheritance</h1><div class="post__text post__text-html js-mediator-article">  When working with inheritance, sometimes there is a desire to have a function for accessing the ancestor method (the parent class method) - in the constructor (similar to the class for Javascript) or in the descendant method, because it happens that the new class overrides it.  Not just any function (method), but with a completely clear record, so that the name speaks for itself, and having access to the specified generation of ancestors (not ‚Äúgreat-great-great‚Äù, but ‚Äúgreat 3 times‚Äù). <br><br>  Let us take as a basis the method of prototypal inheritance, which is maximally effective in that it produces a minimum of actions when describing chains of inherited classes and at the same time supports the basic operations and properties of inheritance: <i>instanceof, constructor</i> .  To access the ancestor, it creates the <i>.superclass</i> property. <a name="habracut"></a>  (It is argued that this underlying approach to classes was <a href="http://stackoverflow.com/questions/2766057/what-is-happening-in-crockfords-object-creation-technique">popularized by Crockford</a> , no links could be found, but it is important that the method is thoughtful and economical. The author is unknown.) <br><br>  First we give the code of this method with our brief comments. <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inherit2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Inherited, Parent</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  var F = function(){}; F.prototype = Parent.prototype; (Inherited.prototype = new F()).constructor = Inherited; //    //   ,       Inherited.superclass = Parent.prototype; //  }</span></span></code> </pre> <br>  (Those who were previously interested in the topic of inheritance in Javascript, of course, recognized it.) It was discussed in great detail in <a href="http://javascript.ru/tutorial/object/inheritance">javascript.ru/tutorial/object/inheritance</a> , and the issue of access to ancestral methods was also highlighted: we "played around" with " <i>.constructor</i> ", closing the link to itself so that future instances of the class have the correct property <i>.constructor</i> .  But, of course, they lost the correctness of the connections between the inherited classes (yes, it did not exist, it was not laid out in the language) and were forced to create a ‚Äúbonus‚Äù property <i>.superclass</i> to be able to access the parent class. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Why do we need ancestral methods? </h3><br>  Inheritance implies ‚Äúmashing‚Äù (shielding) a property if its name in the descendant matches the name in its ancestors.  If you describe a function, and then, for example, you extend the functionality of a method in a class that inherits, then you have to rewrite some of the simplified (or just the previous, or general) functionality ‚Äî repeat it if you need it.  This is already a mess.  Well, if you had to completely change the method, but sometimes you need to repeat the old method, and then add it a little.  (Therefore, access to ancestors is more important for methods than for properties - properties are always completely rewritten.) This is where the "bonus" property " <i>.superclass</i> " <i>comes</i> in, indicating the prototype of the parent. <br><br>  For inherited classes according to the scheme A =&gt; B =&gt; C =&gt; c01.MethodX <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xa =<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xb =<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xc =<span class="hljs-number"><span class="hljs-number">1</span></span>;} A.prototype.MethodX =<span class="hljs-string"><span class="hljs-string">'protoA'</span></span>; inherit2(B, A); B.prototype.MethodX =<span class="hljs-string"><span class="hljs-string">'protoB'</span></span>; B.prototype.xx =<span class="hljs-string"><span class="hljs-string">'protoX'</span></span>; inherit2(C, B); C.prototype.MethodX = <span class="hljs-string"><span class="hljs-string">'protoC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c01 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C();</code> </pre> <br>  we obtain such methods of access to the ancestral method: <br><br><pre> <code class="javascript hljs">Alert = <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log; Alert(c01.MethodX); <span class="hljs-comment"><span class="hljs-comment">//'protoC' //  Alert(c01.constructor.prototype.MethodX); //'protoC' //    Alert(c01.constructor.prototype.superclass.MethodX); //'proto' //   Alert(c01.constructor.prototype.superclass.constructor.superclass.MethodX); //'protoA'.</span></span></code> </pre> <br>  (To see how this works, <a href="http://spmbt.kodingen.com/inherit/inherit2.htm">we look at the executable example for <i>inherit2 ()</i></a> (it won't hurt to look at Firebug).) <br>  It is inconvenient to use such calls, but it is convenient to confuse colleagues and followers: first we <i>contact</i> through <i>.constructor.prototype</i> , and then through <i>.superclass</i> , instead of saying what we want;  we can not specify the number of the depth of treatment to the ancestor.  All in all, a small function of the form is required: <br><br><pre> <code class="javascript hljs">object.ancestor(name, level) - <span class="hljs-comment"><span class="hljs-comment">//  /   ,</span></span></code> </pre> <br>  which would be put in the deepest class and could extend the functionality of new methods by ‚Äúoverwritten‚Äù methods (and no one bothers to turn to neighboring methods). <br><br>  A minor problem will remain that the context of the method ( <i>this</i> ) will be ‚Äúenriched‚Äù, belonging to the very last class to which the base classes (A and B) still do not need to know, but this is a property of reality and then - the author‚Äôs desire or unwillingness to completely rewrite ancestor method.  We can rewrite in the old-fashioned way, but we can take care in advance of the more complex, unknown to them environment understanding by primitive methods. <br><br>  We also replace the concept of ‚Äúsuperclass‚Äù (it is clear where it comes from, from Java, but this is confusing, because usually constructors are called classes, not their prototypes) with ancestor class <i><u><b>_anc</b></u></i> (ancestor).  This is exactly what the constructor should be relative to the successor, so the logic of the final function will be simpler. <br><br><h3>  What I would like to get </h3><table><tbody><tr><td>  c01 ['MethodX'] </td><td>  c01.ancestor ('MethodX', 0) </td></tr><tr><td>  c01.constructor.prototype ['MethodX'] </td><td>  c01.ancestor ('MethodX') </td></tr><tr><td>  c01.constructor.prototype._anc.prototype ['MethodX'] </td><td>  c01.ancestor ('MethodX', 2) </td></tr><tr><td>  c01.constructor.prototype._anc.prototype._anc.prototype ['MethodX'] </td><td>  c01.ancestor ('MethodX', 3) </td></tr><tr><td>  ... </td></tr></tbody></table>  At the same time, <i>c01.constructor</i> could be <i>c01._anc</i> , if with each <i>new</i> we would write this, i.e.  would create a special function instead of <i>new</i> (there is a tendency to call such a function <i>create ()</i> ), but we will not do so (for now?) to save <i>new</i> as an indicator of the creation of an object. <br><br>  The result is achieved by such a function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ancestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, level, constr</span></span></span><span class="hljs-function">)</span></span>{ level = level || (level ==<span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t =<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ? (level ? constr &amp;&amp; constr.prototype[name] || t.constructor.prototype[name] : t[name]) : <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> , name , level <span class="hljs-number"><span class="hljs-number">-1</span></span> , constr &amp;&amp; (constr.prototype._anc || constr.prototype.constructor) || t._anc <span class="hljs-comment"><span class="hljs-comment">// ( )    ); }</span></span></code> </pre> <br>  The <i>inherit3 ()</i> source code <i>has</i> also changed a bit to use the <i>._anc ()</i> function. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inherit3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Inherited, Parent</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> F = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; F.prototype = Parent.prototype; (Inherited.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> F())._anc = Parent; Inherited.prototype.constructor = Inherited; }</code> </pre> <br><h3>  The logic of the access to the ancestors. </h3><br>  We refer not to the current method definition, but to the one that was at the <i>level</i> of inheritance levels before. <br><br>  If we do not fall into the exact definition of a method, the newest of the parent methods taken at the <i>level of</i> steps before the last generation is retrieved along the chain of prototypes. <br><br>  If there are no prototypes, we fall into the ‚Äúbomb of kindness‚Äù (disservice) of the function when there should be no error of the missing property, but we always have the first method defined in the chain.  If there is no property at all, we get <i>undefined</i> at any level. <br><br>  If you do not want to have a bomb of kindness, we write a couple of fake properties when a property is not found in place of <i>constr.prototype._anc</i> - for example, ( <i>constr.prototype._anc</i> || <i>constr.fail.fail</i> ) or simply ( <i>constr.prototype._anc || fail</i> ) . <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-number"><span class="hljs-number">1</span></span>;} A.prototype.protoProp =<span class="hljs-string"><span class="hljs-string">'protoA'</span></span>; inherit3(B, A); B.prototype.protoProp =<span class="hljs-string"><span class="hljs-string">'protoB'</span></span>; inherit3(C, B); C.prototype.protoProp =<span class="hljs-string"><span class="hljs-string">'protoC'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c01 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C(); A.prototype.ancestor = ancestor; Alert(c01[<span class="hljs-string"><span class="hljs-string">'protoProp'</span></span>], c01.ancestor(<span class="hljs-string"><span class="hljs-string">'protoProp'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//'protoC protoC' Alert(c01.constructor.prototype.protoProp, c01.ancestor('protoProp')) //'protoC protoC' Alert(c01.ancestor('protoProp', 2) ); //'protoB' Alert(c01.ancestor('protoProp', 3) ); //'protoA' Alert(c01.ancestor('protoProp', 4) ); //'protoA' Alert(c01.ancestor('protoProp', 5) ); //'protoA' Alert(c01.ancestor('protoProp', 6) ); //'protoA' Alert(c01.ancestor('protoProp2', 4) ); //'undefined'</span></span></code> </pre> <br>  Look at the work of the script, twist in Firebug - <a href="http://spmbt.kodingen.com/inherit/inherit2.htm">on a demo</a> (he - with a bomb of kindness). <br>  The prototype of the descendant is required to write after inheritance, and not anywhere - a consequence of working with prototypes in <i>inherit2 ()</i> .  The prototype of a common ancestor can be changed anywhere, as shown by assigning an <i>ancestor ()</i> method after all inheritances.  In the examples, properties are used everywhere, not methods - for short, but there are no problems with specifying or executing methods in formats <br><pre> <code class="javascript hljs">c01.ancestor(<span class="hljs-string"><span class="hljs-string">'protoMethod'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  c01.ancestor('protoMethod', 3)(args) // </span></span></code> </pre> <br><h3>  What needs to be improved? </h3><br>  Everything, the task of the article is completed, can I go to sleep?  No, development never stops, and the demanding reader did not receive moral satisfaction after receiving 2 separate functions and a number of conditions of use.  In this method, the displacement of the prototype from ancestor to descendant is confusing.  After all, often objects already have prototypes, they need not to be rewritten, but to extend (extend), otherwise on the 3rd floor of inheritance we get problems and the need to rework the method. <br><br>  Why we didn‚Äôt immediately prepare the finished code as food for our readers, but force them to walk on semi-finished products?  Because this code is needed for thinking developers, they need to know how the access method works.  In the first part a skeleton is built, without any beautiful and other meat.  The skeleton structure is best seen when there is no meat on it.  Continue on the desired improvements. <br><br>  In the examples, we see that we do not rewrite the prototype (it would be wrong), but add new properties to it.  This suggests the use of the <i>extend ()</i> function to <i>extend the</i> prototype after inheritance.  So, it would be nice to have the extension function "at hand."  It is in jQuery and in many other libraries, or for the sake of speed, we can define our function in order to include it in our inheritance method.  For a basis, you can take this format, <a href="http://pietschsoft.com/post/2009/07/29/JavaScript-Easily-Extend-an-Object-Element.aspx">found on the Internet</a> : <br><pre> <code class="javascript hljs">extend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, extObj</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    if(arguments.length &gt;2) for(var a =1, aL = arguments.length; a &lt; aL; a++) arguments.callee(obj, arguments[a]) else{ for(var i in extObj) obj[i] = extObj[i]; return obj; };</span></span></code> </pre>  It is good because ‚Äúin between‚Äù allows you to use several arguments to extend the first one.  In the meantime, even this function will allow us to write not " <i>C.prototype.protoProp = 'protoC';</i> ", but <br><br><pre> <code class="javascript hljs">extend(C.prototype, {<span class="hljs-attr"><span class="hljs-attr">protoProp</span></span>: <span class="hljs-string"><span class="hljs-string">'protoC'</span></span>}); <span class="hljs-comment"><span class="hljs-comment">//    .</span></span></code> </pre> <br>  Note that we no longer need the <i>.superclass</i> ;  it is thrown out of the code. <br><br>  In addition, this method of inheritance is so <s>harshly</s> economical that it <u>does not execute constructors</u> , so we can see the properties of the constructor only where the <i>new</i> is executed ‚Äî in the <i>c01</i> object.  There is no constructor execution between classes.  Such severity is not always necessary (oh, not always).  Properties of constructors that are generated by <i>this.property</i> could be present and also participate in prototype inheritance (be a property of the prototype heir). <br><br>  About the method of remaking this approach more convenient - in the next series.  Although this one has every reason to be used - it all depends on the number of requirements for the inheritance mechanism <s>and the desire to confuse other developers with their code, for this the first option is preferable</s> . <br><br><h4>  What similar methods for classes and collections (hashes) are developers prefer? </h4><br>  A similar task, of course, was encountered among class and inheritance implementations, which can be found by saying ‚Äúcalling methods of the parent class‚Äù. <br>  <a href="http://habrahabr.ru/blogs/javascript/40909/">habrahabr.ru/blogs/javascript/40909</a> <br><br>  It has a basic <i>__parent</i> method <i>created</i> that performs the same tasks as the <i>superclass</i> method.  In it, too, it is necessary to use a multiple call, if you turn to ancestors. <br>  The library provides several more methods: <br>  <i>Mixin (A, B)</i> - adding from prototype B to prototype A, <br>  <i>Clone ()</i> - object cloning, <br>  <i>Extend ()</i> - expansion of hashes;  only for a pair of arguments. <br><br>  <i>superclass</i> does not connect to such methods: [‚ÄúhasOwnProperty‚Äù, ‚ÄúisPrototypeOf‚Äù, ‚ÄúpropertyIsEnumerable‚Äù, ‚ÄútoLocaleString‚Äù, ‚ÄútoString‚Äù, ‚ÄúvalueOf‚Äù] is a good idea. <br><br><h5>  Another example of access to ancestors (from Rezig) </h5><br>  In <a href="http://ejohn.org/blog/simple-javascript-inheritance/">ejohn.org/blog/simple-javascript-inheritance</a> (Simple JavaScript Inheritance By John Resig) we see the presence of the <i>_super</i> and <i>extend</i> method together with the special constructor <i>Class</i> , which emphasizes its class-like nature.  Here, <i>extend</i> is not an extension of the hash, but a special procedure for scrolling through the list of properties, in order to ‚Äúwipe out‚Äù put the <i>_super</i> property ‚Äî a method or property that is created if the parent has a rewritable method.  Obviously, this is a more costly mechanism.  Instead of a one-time access to the ancestral methods and accessing it only when we call it, we create a ‚Äúworkaround‚Äù method every time we construct a heir, running through the whole list of ancestor methods.  It can be justified if there are a lot of resources, we turn to ancestors more often than we create new classes.  In general, reference to ancestors is assumed in the description of functions ‚Äî a quite time-consuming method that should be effective, so the approach of writing direct links is sometimes justified.  As an alternative, we also have an appeal through links (object.) Without any costs for running through the list of methods with <i>.extend</i> . <br><br><h3>  Content of the <a href="http://habrahabr.ru/blogs/javascript/130713/">next series</a> </h3><br>  The hero, who decided alone to fill up the four-headed hydra of the reaction, is almost Hercules, but we know that the frames are drawn by a snag-programmer.  He successfully examines 4 detected problems (1 - the code is transformed into a method, 2 - an extension of the heir prototype is added, 3 - the independent use of mixed methods is possible, 4 - the format of writing codes for inheritance is improved) and solves them in one piece of code.  It turned out that the 5th problem was not solved at the same time, but let's call it non-overloading of the written code - the future short method will be able to extend any other hashes, not just the prototypes of the heirs.  The code easily guesses the source one, which we cited in this article, which will help the developers follow the development of ideas and choose their appropriate implementation.  The viewer will want to know how it happened - a single-frame review with examples will help him in this.  The code will really be more convenient.  Follow the adventures of Hercules on the pages of our newspapers. </div><p>Source: <a href="https://habr.com/ru/post/130495/">https://habr.com/ru/post/130495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130486/index.html">Google is preparing to launch an MP3 store</a></li>
<li><a href="../130488/index.html">VeriSign requires more rights to control domain names</a></li>
<li><a href="../130490/index.html">Talk mode in Google Translate for Android now supports Russian language</a></li>
<li><a href="../130492/index.html">LG laptops - returned to the Ukrainian market</a></li>
<li><a href="../130494/index.html">How I tested samsung galaxy s 2</a></li>
<li><a href="../130496/index.html">GTK + PHP application</a></li>
<li><a href="../130498/index.html">Firefox for Android will get the native interface of this OS</a></li>
<li><a href="../130499/index.html">Tovarix - product search service</a></li>
<li><a href="../130500/index.html">Sonim has released 3 new models of super-secure phones</a></li>
<li><a href="../130501/index.html">Active FreeBSD protection based on logs, sh and cron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>