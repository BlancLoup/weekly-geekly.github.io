<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Strutext C ++ word processing library - lexical implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Basic principles 
 This text is a continuation of a post about the Strutext word processing library in C ++. Here will be described the implementation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Strutext C ++ word processing library - lexical implementation</h1><div class="post__text post__text-html js-mediator-article"><h1>  Basic principles </h1><br>  This text is a continuation of a post about <a href="http://habrahabr.ru/post/240805/">the Strutext</a> word processing <a href="http://habrahabr.ru/post/240805/">library</a> in C ++.  Here will be described the implementation of the lexical level of representation of the language, in particular, the implementation of morphology. <br><a name="habracut"></a><br>  According to the author, there are the following main tasks that need to be solved when implementing the program model of the lexical level of language representation: <br><ol><li>  Selection from the source text of chains of characters that have meaning, i.e.  text representations in the form of a sequence of words. </li><li>  The identification of the selected chains as elements of lexical types. </li><li>  The definition for the selected chain of its lexical attributes (about them below). </li></ol><br>  Lexical types are usually represented as finite sets of chains of characters that have the same meaning in language sentences.  The elements of a lexical class are usually called word forms, the set of word forms itself is a paradigm, and the lexical type is called a word or a lemma.  For example, the mom lexical type consists of word forms {mom, mom, mom, ..., mom, mom, ...}. <br><br>  Lexical types are divided into syntactic categories - parts of speech.  The part of speech defines the role that the word plays in the sentence of the language.  This role is important in determining the correctness of the place of the word in the sentence and, therefore, in determining the meaning of the sentence.  Famous parts of the Russian language speech: noun, adjective, verb, adverb, etc. <br><br>  Word forms of lexical type can have properties.  Such properties are also called lexical attributes or lexical features.  The types of these properties depend on the syntactic category to which this lexical type belongs.  For example, for nouns, the case of the word form plays an important role, and there is no such attribute for verbs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What specific syntactic categories are used to group the lexical types and which lexical attributes they have depends on both the language being implemented and the specific lexical analysis model being implemented.  Below we will consider the <a href="http://aot.ru/">AOT</a> lexical model. <br><br><h2>  Lexical ambiguities </h2><br>  It may happen that in the process of extracting words from the source text, ambiguities will arise.  Here the ambiguities of the two genders are considered: <br><ol><li>  Ambiguities of the first kind arise in the process of assigning a string of symbols of a lexical type selected from the text.  Consider the example of "mom washed the frame."  Here the string of symbols ‚Äúsoap‚Äù can be the verb ‚Äúwash‚Äù, and it can also be a noun ‚Äúsoap‚Äù.  Such cases of ambiguity are also called lexical homonymy. </li><li>  Ambiguities of the second kind arise in the process of cutting the source text into chains of words.  In most natural languages, words are separated from each other by spaces, although this principle can sometimes be violated (for example, composites in German).  But programming languages ‚Äã‚Äãhave interesting examples.  Consider, for example, an expression of the form "a &gt;&gt; b" in C ++.  In classical C, this expression is interpreted unambiguously: identifier "a", right bitwise shift operator "&gt;&gt;", identifier "b".  But in recent versions of C ++, this expression can mean the end of the list of template parameters, when the last parameter also appears in the list.  In this case, the sequence of words will be as follows: the identifier "a", the end of the list of parameters of the template "&gt;", the end of the list of parameters of the template "&gt;", the identifier "b". </li></ol><br>  In this text we consider only the lexical ambiguities of the first kind. <br><br><h1>  Morphological dictionary model AOT </h1><br>  The Strutext library implements the morphological model from <a href="http://aot.ru/">AOT</a> .  Therefore we will give its description some place. <br><br>  In the AOT dictionary, each lexical type is defined by two parameters: <br><ol><li>  A string of stem (word root), to which suffixes are attached to form word forms. </li><li>  The declension paradigm number, which is a list of pairs (suffix, set of lexical features). </li></ol><br><br>  There are relatively few combinations of lexical feature sets, they are listed in a special file, and each such combination is encoded with a two-letter code.  For example: <br><pre><code class="hljs erlang"> A  ,,  A  ,,  A  ,,,<span class="hljs-number"><span class="hljs-number">2</span></span> ...  Y  ,,,,,  Y  ,,,,, ...  a  ,,<span class="hljs-number"><span class="hljs-number">1</span></span>,  a  ,,<span class="hljs-number"><span class="hljs-number">1</span></span>,  a  ,,<span class="hljs-number"><span class="hljs-number">2</span></span>, ...</code> </pre> <br>  Here the first element of each line is the two-letter dialing code, the third element is the code of the part of speech (C is a noun, P is an adjective, G is a verb, etc.), then the codes of grammatical signs are listed separated by commas. <br><br>  The dictionary description file consists of five sections, of which two sections are most important.  This is a section describing the paradigms of declension and a section of the bases (lexical types)  Each line in this section represents a declension paradigm.  In the description section of lexical types, together with the base, the declination paradigm line number is specified. <br><br>  Consider, for example, the word "Zelenka".  The lexical type of this word in the AOT dictionary is given by the string <br><pre> <code class="hljs"> 15 12 1  -</code> </pre><br>  Here, the number 15 is the declination paradigm number in the paradigm section.  This paradigm line looks like this: <br><pre> <code class="hljs mel">%*%*%*%*%*%*%*%*%*%*%*%*%*</code> </pre><br>  Each pair in the paradigm is separated from another by the ‚Äú%‚Äù symbol, and the elements of the pairs are separated from each other by the ‚Äú*‚Äù symbol.  The first pair (KA, ha) sets the word form green + ka = brilliant green and has a set of lexical attributes: ha = G C W, units, im = noun, feminine, singular, nominative.  Other paradigm pairs can be decoded accordingly. <br><br>  The word encoding method used in AOT has its advantages and disadvantages.  We will not discuss them here, we note only an interesting fact: there are lexical types with an empty base in the dictionary.  For example, the word ‚Äúperson‚Äù in the plural is represented by the word form ‚Äúpeople‚Äù, which has no common basis with the form ‚Äúperson‚Äù.  Therefore, this word has to be set by simple enumeration of word forms: <br><pre> <code class="hljs mel">%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*</code> </pre><br>  This paradigm can also be used with other words (having a non-empty root), such as the God-man and the apeman. <br><br>  Let us consider in more detail the set of syntactic categories and the corresponding lexical attributes of the AOT dictionary. <br><br><h2>  AOT syntax categories </h2><br>  As mentioned above, the syntax categories of the AOT dictionary are defined in a separate file and represent sets of strings in which the part of speech and the set of lexical attributes are specified in two-letter codes.  In the Strutext library, parts of speech and their attributes are represented as a hierarchy of classes in C ++.  Consider this implementation in more detail. <br><br>  The syntax categories of the AOT dictionary are specified in the morpho / models directory.  Models for Russian and English are presented.  Consider some fragments files morpho / models / rus_model.h, which presents a description of the model of the Russian language. <br><br>  The base class for all models is the abstract class PartOfSpeech, which contains the language label in the form of an enumerator, and also sets a virtual method for returning this label: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PartOfSpeech : private boost::noncopyable { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: /// <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> smart pointer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>. typedef boost::shared_ptr&lt;PartOfSpeech&gt; Ptr; /// <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span> tag definitions. enum LanguageTag { UNKNOWN_LANG = <span class="hljs-number"><span class="hljs-number">0</span></span> ///&lt; <span class="hljs-type"><span class="hljs-type">Unknown</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span>. , RUSSIAN_LANG = <span class="hljs-number"><span class="hljs-number">1</span></span> ///&lt; Russian <span class="hljs-keyword"><span class="hljs-keyword">language</span></span>. , ENGLISH_LANG = <span class="hljs-number"><span class="hljs-number">2</span></span> ///&lt; English <span class="hljs-keyword"><span class="hljs-keyword">language</span></span>. }; /// <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span> tag. virtual LanguageTag GetLangTag() const = <span class="hljs-number"><span class="hljs-number">0</span></span>; /// Virtual destruction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>. virtual ~PartOfSpeech() {} };</code> </pre><br><br>  From this class the base class is inherited for all syntactic categories of the Russian language: <br><pre> <code class="hljs ruby">struct RussianPos : public PartOfSpeech { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Type of smart pointer to the class object. typedef boost::shared_ptr&lt;RussianPos&gt; Ptr; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Possible parts of speech. enum PosTag { UNKNOWN_PS = <span class="hljs-number"><span class="hljs-number">0</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown part of speech. , NOUN_PS = <span class="hljs-number"><span class="hljs-number">1</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , ADJECTIVE_PS = <span class="hljs-number"><span class="hljs-number">2</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PRONOUN_NOUN_PS = <span class="hljs-number"><span class="hljs-number">3</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; - , VERB_PS = <span class="hljs-number"><span class="hljs-number">4</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;     , PARTICIPLE_PS = <span class="hljs-number"><span class="hljs-number">5</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , ADVERB_PARTICIPLE_PS = <span class="hljs-number"><span class="hljs-number">6</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PRONOUN_PREDICATIVE_PS = <span class="hljs-number"><span class="hljs-number">7</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; - , PRONOUN_ADJECTIVE_PS = <span class="hljs-number"><span class="hljs-number">8</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;   , NUMERAL_QUANTITATIVE_PS = <span class="hljs-number"><span class="hljs-number">9</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  () , NUMERAL_ORDINAL_PS = <span class="hljs-number"><span class="hljs-number">10</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;   , ADVERB_PS = <span class="hljs-number"><span class="hljs-number">11</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PREDICATE_PS = <span class="hljs-number"><span class="hljs-number">12</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PREPOSITION_PS = <span class="hljs-number"><span class="hljs-number">13</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , CONJUCTION_PS = <span class="hljs-number"><span class="hljs-number">14</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , INTERJECTION_PS = <span class="hljs-number"><span class="hljs-number">15</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PARTICLE_PS = <span class="hljs-number"><span class="hljs-number">16</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , INTRODUCTORY_WORD_PS = <span class="hljs-number"><span class="hljs-number">17</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;   , UP_BOUND_PS }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Number. enum Number { UNKNOUN_NUMBER = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown number. , SINGULAR_NUMBER = <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . , PLURAL_NUMBER = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Language. enum Lang { NORMAL_LANG = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Normal language. , SLANG_LANG = 1 , ARCHAIZM_LANG = 2 , INFORMAL_LANG = 3 }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Gender definitions. enum Gender { UNKNOWN_GENDER = <span class="hljs-number"><span class="hljs-number">0</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown gender value. , MASCULINE_GENDER = <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , FEMININE_GENDER = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , NEUTER_GENDER = <span class="hljs-number"><span class="hljs-number">0x04</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Case definition. enum Case { UNKNOWN_CASE = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>. , NOMINATIVE_CASE = <span class="hljs-number"><span class="hljs-number">1</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , GENITIVE_CASE = <span class="hljs-number"><span class="hljs-number">2</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , GENITIVE2_CASE = <span class="hljs-number"><span class="hljs-number">3</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;   , DATIVE_CASE = <span class="hljs-number"><span class="hljs-number">4</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , ACCUSATIVE_CASE = <span class="hljs-number"><span class="hljs-number">5</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , INSTRUMENTAL_CASE = <span class="hljs-number"><span class="hljs-number">6</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PREPOSITIONAL_CASE = <span class="hljs-number"><span class="hljs-number">7</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PREPOSITIONAL2_CASE = <span class="hljs-number"><span class="hljs-number">8</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;   , VOCATIVE_CASE = <span class="hljs-number"><span class="hljs-number">9</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Time. enum Time { UNKNOWN_TIME = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown time. , PRESENT_TIME = <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , FUTURE_TIME = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , PAST_TIME = <span class="hljs-number"><span class="hljs-number">0x04</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Person. enum Person { UNKNOWN_PERSON = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown person. , FIRST_PERSON = <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , SECOND_PERSON = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  , THIRD_PERSON = <span class="hljs-number"><span class="hljs-number">0x04</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Entity kind. enum Entity { UNKNOWN_ENTITY = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown entity, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ordinal words. , ABBREVIATION_ENTITY = <span class="hljs-number"><span class="hljs-number">1</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . , FIRST_NAME_ENTITY = <span class="hljs-number"><span class="hljs-number">2</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . , MIDDLE_NAME_ENTITY = <span class="hljs-number"><span class="hljs-number">3</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . , FAMILY_NAME_ENTITY = <span class="hljs-number"><span class="hljs-number">4</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Animation. enum Animation { UNKNOWN_ANIMATION = 0 , ANIMATE_ANIMATION = 0x01 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . , INANIMATE_ANIMATION = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; . }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Voice defintion. enum Voice { UNKNOWN_VOICE = 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Unknown voice. , ACTIVE_VOICE = <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  . , PASSIVE_VOICE = <span class="hljs-number"><span class="hljs-number">0x02</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt;  . }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Language tag. LanguageTag GetLangTag() const { return RUSSIAN_LANG; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Class is absract one -- virtual destruction. virtual ~RussianPos() {} /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get part of speech tag. virtual PosTag GetPosTag() const = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Serialization implementaion. virtual void Serialize(uint32_t&amp; out) const = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Desirialization implementation. virtual void Deserialize(const uint32_t&amp; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Write POS signature. static void WritePosSign(PosTag pos, uint32_t&amp; out) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Write to lower 5 bits. out |= static_cast&lt;uint32_t&gt;(pos); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Read POS signature. static PosTag ReadPosSign(const uint32_t&amp; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PosTag(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>); } };</code> </pre><br>  In the class, labels of syntactic categories are specified in the form of PosTag enumerator, and also lexical attributes are defined.  In addition to the grammatical component, the class defines the methods Serialize and Deserialize for conversion to / from the binary format.  For each syntactic type, a four-byte conversion is defined, represented by the type uint32_t. <br><br>  The RussianPos class is abstract; classes that represent specific syntactic categories are inherited from it.  For example, the class Noun defines the noun: <br><pre> <code class="hljs django"><span class="xml"><span class="xml">struct Noun : public RussianPos { Noun() : number_(UNKNOUN_NUMBER) , lang_(NORMAL_LANG) , gender_(UNKNOWN_GENDER) , case_(UNKNOWN_CASE) , entity_(UNKNOWN_ENTITY) {} /// Get part of speech tag. PosTag GetPosTag() const { return NOUN_PS; } /** * \brief Serialization implementaion. * * Binary map of the object: * 13 3 4 3 2 2 5 * ----------------------------------------------------------- * Unused | Entity | Case | Gender | Lang | Number | POS tag | * ----------------------------------------------------------- * * \param[out] ob The buffer to write to. */ void Serialize(uint32_t&amp; ob) const { ob |= static_cast</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(number_) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">5</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ob</span></span></span></span><span class="xml"><span class="hljs-tag"> |= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(lang_) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">7</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ob</span></span></span></span><span class="xml"><span class="hljs-tag"> |= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(gender_) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">9</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ob</span></span></span></span><span class="xml"><span class="hljs-tag"> |= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(case_) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">12</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ob</span></span></span></span><span class="xml"><span class="hljs-tag"> |= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(entity_) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">16</span></span></span></span><span class="xml"><span class="hljs-tag">; } /** * \</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">brief</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Desirialization</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">implementaion.</span></span></span></span><span class="xml"><span class="hljs-tag"> * * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Binary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">map</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">of</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">object:</span></span></span></span><span class="xml"><span class="hljs-tag"> * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">13</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">5</span></span></span></span><span class="xml"><span class="hljs-tag"> * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-----------------------------------------------------------</span></span></span></span><span class="xml"><span class="hljs-tag"> * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Unused</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Entity</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Case</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Gender</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Lang</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Number</span></span></span></span><span class="xml"><span class="hljs-tag"> | </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">POS</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tag</span></span></span></span><span class="xml"><span class="hljs-tag"> | * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-----------------------------------------------------------</span></span></span></span><span class="xml"><span class="hljs-tag"> * * \</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">param</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ib</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">The</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">buffer</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">write</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">to.</span></span></span></span><span class="xml"><span class="hljs-tag"> */ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">void</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Deserialize</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">uint32_t</span></span></span></span><span class="xml"><span class="hljs-tag">&amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ib</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">number_</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Number</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">((ib &amp; 0x0060) &gt;&gt; 5); lang_ = static_cast</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Lang</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">((ib &amp; 0x0180) &gt;&gt; 7); gender_ = static_cast</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Gender</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">((ib &amp; 0x0e00) &gt;&gt; 9); case_ = static_cast</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Case</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">((ib &amp; 0xf000) &gt;&gt; 12); entity_ = static_cast</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Entity</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">((ib &amp; 0x070000) &gt;&gt; 16); } Number number_; Lang lang_; Gender gender_; Case case_; Entity entity_; };</span></span></code> </pre><br>  The noun class stores lexical attributes: number, type of language (normal, anachronism, colloquial, etc.), gender, case, and a sign of the name or abbreviation. <br><br><h1>  State machines for encoding dictionaries </h1><br>  To store dictionaries, as well as efficiently extract words from a data dictionary, the Strutext library uses state machines.  State machines are specified by the corresponding C ++ types in the automata directory. <br><br>  Recall that a finite state machine is defined by a transition function, which for some pairs (state, symbol) associates a state: delta: Q x V -&gt; Q. There is one initial state in which the machine starts its work and a certain number of ‚Äúallowable‚Äù states.  The automaton reads the input string character by character, if the transition function gives a state for the current state and the character read, the automaton ‚Äútransitions‚Äù to this new state, after which the cycle of reading the new character starts anew.  The machine can stop in two cases: if there is no transition by the pair (current state, read character) and if the entire string of characters is read to the end.  In the first case, the input chain is considered not allowed by this automaton, in the second case, the chain is allowed if the automaton is in one of the allowable states after stopping. <br><br>  Thus, each time a new symbol of the input chain is read, the automaton is confronted with the task of finding a match for the pair (state, symbol) of the new state.  The Strutext library implements this search function in a separate class called Transition.  An automaton is an array of Transition objects defined for each state (automata / fsm.h): <br><pre> <code class="hljs ruby">template &lt;typename TransImpl&gt; struct FiniteStateMachine { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Type of transition table. typedef TransImpl Transitions; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> State definition. struct State { Transitions trans<span class="hljs-number"><span class="hljs-number">_</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/&lt; Move table. bool is_accepted_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; Is the state accepptable. /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Default initialization. explicit State(bool is_accepted = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) : is_accepted<span class="hljs-number"><span class="hljs-number">_</span></span>(is_accepted) {} }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Type of states' list. typedef std::vector&lt;State&gt; StateTable ... StateTable states_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>&lt; The table of states. };</code> </pre><br>  Here the parameter of the TransImpl template represents the transition function. <br><br>  The Strutext library has two ways of implementing the transition function.  One method is based on the usual std :: map (automata / flex_transitions.h), where the key is the character code and the value is the state number.  Another way (automata / flat_transitions.h) is based on a sparse array, when an array corresponding to the possible character codes is allocated.  In each element of the array is the status code.  The value zero is reserved for incorrect states, i.e.  means that there is no transition.  If the value is non-zero, then this pair (array index = character code, state number in the array cell) specifies the transition. <br><br>  The FiniteStateMachine class is not able to say anything about the input chain, except that this chain is allowed.  To store additional information about allowed chains, you need to add attributes to the allowable states.  This is done in the AttributeFsm template class.  The class takes as the parameter of the template the implementation of the transition function and the attribute type for the admitting state.  It should be noted that attributes can be attached not only to admitting states (although it is not clear whether this makes sense), but also that more than one attribute can be attached to a state, they are all stored in a vector. <br><br>  The storage of the dictionary in the finite state machine specifies a tree structure for the transition function of the finite automaton of this dictionary.  For such a structure is also used the term trie, introduced by D. Knut.  The Strutext library has an implementation of such a state machine in the file automata / trie.h: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Trans, typename <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>&gt; struct Trie : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AttributeFsm&lt;Trans, <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>&gt; { /// Chain identifier <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>. typedef <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> ChainId; /// <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> FSM <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>. typedef AttributeFsm&lt;Trans, <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>&gt; AttributeFsmImpl; /// <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> initialization. explicit Trie(size_t rsize = AttributeFsmImpl::kReservedStateTableSize) : AttributeFsmImpl(rsize) {} /// It may be base <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>. virtual ~Trie() {} <span class="hljs-comment"><span class="hljs-comment">/** * \brief Adding chain of symbols. * * \param begin Iterator of the chain's begin. * \param end Iterator of the chain's end. * \param id Chain identifier. * * \return The number of last state of the chain. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename SymbolIterator&gt; StateId AddChain(SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>, SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, const ChainId&amp; id); <span class="hljs-comment"><span class="hljs-comment">/** * \brief Adding chain of symbols. * * \param begin Iterator of the chain's begin. * \param end Iterator of the chain's end. * * \return The number of last state of the chain. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename SymbolIterator&gt; StateId AddChain(SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>, SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * \brief Search of the passed chain in the trie * * \param begin Iterator of the chain's begin. * \param end Iterator of the chain's end. * \result The reference to the list of attributes of the chain if any. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename SymbolIterator&gt; const typename AttributeFsmImpl::AttributeList&amp; <span class="hljs-keyword"><span class="hljs-keyword">Search</span></span>(SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>, SymbolIterator <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) const; };</code> </pre><br>  From the code it is clear that there are two main methods: AddChain and Search.  The latter method is noteworthy because it returns a reference to the attribute vector, i.e.  When searching, state attributes are not copied.  If the input character string is not found, then the attribute vector will be empty. <br><br>  The Strutext library also has an Aho-Korasik automaton for efficiently searching for dictionary elements in the text.  The implementation is presented in automata / aho_corasick.h.  The presentation of the principles and methods of its implementation is beyond the scope of this text, we only note that the interface is quite simple to use, and there is also an iterator over the chains found in the text. <br><br>  It should also be noted that all automata can be serialized / deserialized into std :: stream.  This allows you to store automata in files on disk, i.e.  use as dictionary stores in binary format. <br><br><h1>  Morphological analyzer </h1><br>  A morphological analyzer is a library located in the morpho / morpholib directory.  The main interface class, Morphologist, is located in the morpho / morpholib / morpho.h file. <br><br>  Before describing the interface and class implementation, we first describe the basic principles on which this implementation is based. <br><br>  First, there is a dictionary of fundamentals that are implemented in an object of the class Trie. <br>  Secondly, each basis in the admitting state is given a corresponding declination paradigm (still, this is a pairs vector (suffix, set of lexical attributes). The set of attributes is represented by an instance of the class inherited from PartOfSpeech). <br>  Thirdly, each lexical type is assigned a unique numeric identifier, the base number in the dictionary. <br><br>  Thus, in order to recognize the transmitted word form as a word, it is necessary to search the basis for the automaton (a lexical type identifier corresponding to the given basis will be found), then at the end to find the corresponding attributes.  All this must be done taking into account the ambiguities, both when searching for the foundations and when defining endings.  The search code is as follows: <br><pre> <code class="hljs lua">/** * \brief Implementation of morphological analysis of passed form. * * \param text Input text <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> encoding. * \param[out] lem_list List of lemmas within morphological attributes. */ void Analize(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; text, LemList&amp; lem_list) const { // The first phase. Go throw the passed word text, encode symbol // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> remember symbol codes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>. If found word base on // some position, remember attribute <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> position <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an each // attribute. // Try starts with empty bases typedef std::list&lt;std::pair&lt;Attribute, size_t&gt; &gt; BaseList; BaseList base_list; strutext::automata::StateId state = strutext::automata::kStartState; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bases_trie_.IsAcceptable(state)) { const typename Trie::AttributeList&amp; attrs = bases_trie_.GetStateAttributes(state); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; attrs.size(); ++i) { base_list.push_back(std::make_pair(attrs[i], <span class="hljs-number"><span class="hljs-number">0</span></span>)); } } // Permorm the first phase. std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> code_str; typedef strutext::encode::Utf8Iterator&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator&gt; Utf8Iterator; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Utf8Iterator sym_it(text.begin(), text.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()); sym_it != Utf8Iterator(); ++sym_it) { Code c = alphabet_.Encode(*sym_it); code_str += c; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != strutext::automata::kInvalidState) { state = bases_trie_.Go(state, c); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bases_trie_.IsAcceptable(state)) { const typename Trie::AttributeList&amp; attrs = bases_trie_.GetStateAttributes(state); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; attrs.size(); ++i) { base_list.push_back(std::make_pair(attrs[i], code_str.size())); } } } } // The second phase. Go throuth the found base list <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> suffixes <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> them. // If suffixes have been found <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> add them to the lemma list. lem_list.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BaseList::iterator base_it = base_list.begin(); base_it != base_list.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++base_it) { AttrMap attr; attr.auto_attr_ = base_it-&gt;first; SuffixStorage::AttrList att_list; std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix = code_str.substr(base_it-&gt;second); // If suffix is empty (empty suffix passed), add zero symbol to it. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suffix.empty()) { suffix.push_back(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (const SuffixStorage::AttrList* att_list = suff_store_.SearchAttrs(attr.line_id_, suffix)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; att_list-&gt;size(); ++i) { lem_list.push_back(Lemma(attr.lem_id_, (*att_list)[i])); } } } }</code> </pre><br>  As can be seen, the algorithm for determining is divided into two stages.  First, the basics are highlighted (here, the existence of empty basics must also be taken into account).  For each base, its position in the input chain is memorized, so that the end can be distinguished later.  At the second stage, endings are searched for that correspond to the highlighted basics.  If the ending is found in the corresponding decad paradigm of declension, then the lexical attributes of this ending are returned along with the identifier of the word. <br><br>  The Morphologist class also provides a service for the generation of word forms by the base number and the lexical attributes transferred.  The Generate method deals with this: <br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/** * \brief Generate form. * * \param lem_id The lemma identifier. * \param attrs The attributes of the form. * \return Generated text in UTF-8 encoding. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lem_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attrs)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre><br>  There is also a GenAllForms method for generating all forms of a given word and a GenMainForm method that returns the main form of a word.  For the noun, this is obviously the singular form of the nominative case. <br><br>  In the morpho / aot directory in the main.cpp file, the AOT dictionary view parser is implemented in the original format, which as a result returns a binary format representation compatible with the morphology library.  The resulting binary dictionary can be used in the Morphologist class.  The binary dictionaries themselves are not stored in the repository, but can be generated by the user if necessary.  To implement the Russian dictionary, you can use the following command: <br><pre> <code class="hljs pgsql">./<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>/bin/aot-<span class="hljs-keyword"><span class="hljs-keyword">parser</span></span> -t ../morpho/aot/rus_tabs.txt -d ../morpho/aot/rus_morphs.txt -m rus -b aot-rus.bin</code> </pre><br>  In the binary form of the dictionary, the size of the dictionary is slightly less than 20 MB. <br><br>  You can use the WordIterator class defined in utility / word_iterator.h to select word forms from source text.  This class considers words to be sequences of characters (symbols :: IsLetter).  The iterator returns the word as a unicode string.  This code can be recoded to UTF-8 using the GetUtf8Sequence function defined in encode :: utf8_generator.h. <br><br><h1>  Afterword </h1><br>  The text was quite voluminous and probably difficult to read.  The author tried to simplify the presentation, where it was only possible, but given the complexity of the material, there were probably not many such places in the text. <br><br>  Nevertheless, the author feeds hopes that the Strutext library described in the text will be useful and the work on its implementation will not be in vain. </div><p>Source: <a href="https://habr.com/ru/post/242173/">https://habr.com/ru/post/242173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242151/index.html">Alternative programming environment for Arduino - FLProg</a></li>
<li><a href="../242155/index.html">IBM launches humanitarian initiatives to combat Ebola</a></li>
<li><a href="../242159/index.html">7 things that I would like to know before entering the master / graduate school abroad</a></li>
<li><a href="../242161/index.html">The work of the web project in an unstable connection</a></li>
<li><a href="../242167/index.html">SensioLabs PHP Profiler - blackfire.io (SensioLabsProfiler)</a></li>
<li><a href="../242175/index.html">Facebook, hidden services and https certificates</a></li>
<li><a href="../242179/index.html">REST / CRUD. Am I cooking it wrong?</a></li>
<li><a href="../242185/index.html">Unified dynamic corporate signature with Postfix + alterMIME + addAttachFilter + Active Directory or MySQL logo</a></li>
<li><a href="../242187/index.html">EyeCare - relieving eye strain, treatment of myopia, accommodation spasm</a></li>
<li><a href="../242189/index.html">Dark times are coming: HabraDarkAge theme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>