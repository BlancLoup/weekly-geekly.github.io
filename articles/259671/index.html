<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast security-oriented fuzzing with AFL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have heard, and some successfully use in their development processes such a thing as static code analysis - an effective, relatively fast and oft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast security-oriented fuzzing with AFL</h1><div class="post__text post__text-html js-mediator-article">  Many have heard, and some successfully use in their development processes such a thing as static code analysis - an effective, relatively fast and often convenient way to control the quality of the code. <br>  For those who already use static code analysis, it may be interesting to try dynamic analysis at the testing stage as well.  Enough has been written about the differences in these techniques, just to remind you that static analysis is done without executing code (for example, at the compilation stage), and dynamic, respectively, during execution.  When analyzing a compiled code from a security point of view, dynamic analysis often means fuzzing.  The advantage of fuzzing is the almost complete absence of false positives, which is quite common when using static analyzers. <br><br>  ‚ÄúFuzzing is a testing technique in which non-valid, unintended or incidental data is input to the program.‚Äù ¬© Habrahabr <br><br><img src="https://habrastorage.org/files/c16/3ef/195/c163ef195f544d14b76b8cf217d75bbb.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  Recently, a fuzzer by <a href="http://lcamtuf.coredump.cx/">Michal Zalewski</a> - <a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop has</a> received great fame for its effectiveness. <br>  Its main difference is the instrumentation code at the compilation stage, performance and focus on practical application.  AFL does not use SMT solvers, which means it should be less demanding of resources, work faster, though not always more efficiently. <br>  Today I will tell you exactly how this tool can be used, and at the same time I will conduct a small experiment to compare the result of its work with the results of several static analysis tools. <br><br>  So, in order to start using a fuzzer, you need to understand whether it works in practice, as well as what exactly and how we will be phasing. <br>  For verification, I took a deliberately vulnerable version of the popular <a href="http://curl.haxx.se/">libcurl</a> library - 7.34.0. <br>  This version contains a vulnerability in the <i>sanitize_cookie_path ()</i> function described in <a href="http://curl.haxx.se/docs/adv_20150422C.html">CVE-2015-3145</a> . <br><br><img src="https://habrastorage.org/files/687/434/10b/68743410b90944eeb4858d1cda8d31b7.png" alt="bleedingeyes"><br><br>  The function incorrectly processes the input data, and passing to it a path consisting of a double quote or a null byte, libcurl will assign null bytes to the negative pointer of the <i>new_path</i> array, and will corrupt memory on the heap. <br><br><h5>  First, let's check how static analyzers respond to this vulnerability. </h5><br>  <b>Coverity</b> , <b>PVS Studio</b> and <b>Clang Static Analyzer</b> were on hand. <br><br>  In <b>clang,</b> you can do it like this: <br><br><pre><code class="hljs ruby">$ cd curl $ mkdir build-clang $ cd build-clang $ cmake -DCMAKE_C_COMPILER=<span class="hljs-regexp"><span class="hljs-regexp">/path/to</span></span><span class="hljs-regexp"><span class="hljs-regexp">/clang/ccc</span></span>-analyzer -DCMAKE_CXX_COMPILER=<span class="hljs-regexp"><span class="hljs-regexp">/path/to</span></span><span class="hljs-regexp"><span class="hljs-regexp">/clang/ccc</span></span>-analyzer -DCMAKE_BUILD_TYPE=release ../ $ scan-build -o html make</code> </pre> <br><br>  then in the <i>html</i> directory we get the result of the analysis: <br><br><img src="https://habrastorage.org/files/9dd/52c/ea6/9dd52cea63364d649981117b0c320c8d.PNG"><br><br>  <b>Coverity</b> intercepts the compiler calls, the analyzer was launched with the following parameters: <br><br><pre> <code class="hljs bash">$ cov-analyze --dir cov --all --security --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-constraint-fpp --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-single-virtual --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-fnptr --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-callgraph-metrics -j 2 --inherit-taint-from-unions --override-worker-limit</code> </pre><br><br><img src="https://habrastorage.org/files/37e/d25/a54/37ed25a54c0e43f68d8c9d9212c4a469.PNG"><br><br>  <b>PVS Studio</b> requires Windows, and in the trial version it does not show the names of the problem files, however, we already know the line and the type of error, so this will be enough for binary evaluation.  PVS was launched in monitor mode, and for simplicity, the <a href="https://github.com/blackrosezy/build-libcurl-windows">build-libcurl-windows</a> script was used. <br><br><img src="https://habrastorage.org/files/87f/d0f/b4e/87fd0fb4e45b481485735f87edab0a6b.PNG"><br>  (PVS Studio output is not all) <br><br>  <b>None of the static analyzers found a problem.</b> <br><br><h5>  Now let's look at how to start the fuzzing process. </h5><br>  First, download and assemble the AFL: <br><br><pre> <code class="hljs ruby">$ wget <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/lcamtuf.coredump.cx/afl</span></span><span class="hljs-regexp"><span class="hljs-regexp">/releases/afl</span></span>-latest.tgz $ tar xvfz afl-latest.tgz $ cd afl-<span class="hljs-number"><span class="hljs-number">1.83</span></span>b $ make $ cd llvm_mode $ make</code> </pre><br><br>  Typically, the fuzzer starts the application in a new process, then sends test data to STDIN for input or using a temporary file if the process fails - AFL will notice this and write the submitted data to the crashes directory.  An important point for successful fuzzing will be building the application using <a href="http://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a> , so the application is guaranteed to crash even when overwriting one byte of dynamic memory.  I will not write anything about ASAN, because  it has been <a href="http://2012.zeronights.ru/includes/docs/Potapenko%2520Vyukov.pdf">described many times, and has been successfully applied for a long time</a> . <br><br>  To generate tests required so-called.  corpus is the set of test data that the application processes, in the case of curl, these are valid HTTP responses from the web server. <br><br>  In the case of a known vulnerability, we have two ways - to fuzz separate functions that may seem suspicious and fuzz the entire application. <br>  In the first case, it is necessary to write a minimal wrapper to the application: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">2048</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *res = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; assert(argc == <span class="hljs-number"><span class="hljs-number">2</span></span>); FILE *f = fopen(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); assert(f); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), f); buf[len] = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len == <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(buf) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"read = %zu\n"</span></span>, len); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"in = %s\n"</span></span>, buf); <span class="hljs-comment"><span class="hljs-comment">/* call the code which smell */</span></span> res = sanitize_cookie_path(buf); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"res = %s\n"</span></span>, res); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(res); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Next, the wrapper must be instrumented, for which we will assemble it under AFL <br><br><pre> <code class="hljs swift">$ afl-clang-fast -g -fsanitize=address path_san.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> -o path_san</code> </pre><br><br>  In the inputs directory, it‚Äôs enough to put one file with a suitable URI, for example "/ xxx /". <br>  And run AFL: <br><br><pre> <code class="hljs pgsql">$ AFL_USE_ASAN=<span class="hljs-number"><span class="hljs-number">1</span></span> /<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/afl/afl-fuzz -m <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> -i inputs -o <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ./path_san @@</code> </pre><br><br>  the <i>-m none</i> parameter will disable the memory limit, and <i>@@</i> will be replaced with the name of the temporary file during fuzzing, if you do not specify this parameter, the test data will be supplied to STDIN.  Almost immediately after launching, AFL will detect crash and generate a test entry in the <i>out / crashes</i> directories. <br><br>  Fuzzing strategy of individual functions processing user input in a large project may be more effective than fuzzing the entire application, especially if unit tests have already been written for the code. <br>  However, sometimes it is useful to be able to fuzz the entire application, let's see how to do this using the same curl as an example. <br><br>  As we know, curl interacts with the server through sockets, but fuzzer does not know how to do this, which means we need to learn how to transfer data from fuzzer to curl. <br>  To do this, we substitute the connect function so that instead of creating a new connection, the result of connect returns the descriptor stdin. <br>  This can be done through LD_PRELOAD of its dynamic library, which, fortunately, is not necessary to write - you can use ready ( <a href="https://github.com/zardus/preeny">preeny</a> ). <br><br>  We collect preeny and curl: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git clone https://github.com/zardus/preeny <span class="hljs-string"><span class="hljs-string">$ </span></span>cd preeny &amp;&amp; make ... <span class="hljs-string"><span class="hljs-string">$ </span></span>cd curl <span class="hljs-string"><span class="hljs-string">$ </span></span>mkdir build <span class="hljs-string"><span class="hljs-string">$ </span></span>export <span class="hljs-type"><span class="hljs-type">CMAKE_C_FLAGS</span></span>=<span class="hljs-comment"><span class="hljs-comment">"-g -fsanitize=address"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>cmake -<span class="hljs-type"><span class="hljs-type">DCMAKE_C_COMPILER</span></span>=/path/to/afl-clang-fast -<span class="hljs-type"><span class="hljs-type">DCMAKE_CXX_COMPILER</span></span>=/path/to/afl-clang-fast -<span class="hljs-type"><span class="hljs-type">DCMAKE_BUILD_TYPE</span></span>=release ../ <span class="hljs-string"><span class="hljs-string">$ </span></span>make</code> </pre><br><br>  We put the collected binaries in one directory, create the inputs directory next to it, and in it the file with the HTTP response of the server (to increase coverage, it is better to create several). <br><br>  For example: <br><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: <span class="hljs-type"><span class="hljs-type">text</span></span>/html Content-Length: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>-Cookie: xx=xxx; <span class="hljs-type"><span class="hljs-type">path</span></span>=xx; <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>=xxx.com; httponly; secure; <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  After that, return to the directory with the application and run AFL: <br><br><pre> <code class="hljs pgsql">$ LD_PRELOAD="/path/to/preeny/x86_64-linux-gnu/desock.so" /<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/afl/afl-fuzz -m <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> -i inputs -o <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ./curl http://<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>/ <span class="hljs-comment"><span class="hljs-comment">--max-time 1 --cookie-jar /dev/null</span></span></code> </pre><br><br>  LD_PRELOAD here sets the path to SO, which will replace the connect function. <br><br>  Curl options: <br><ul><li> <code><a href="http://127.0.0.1/"></a> 127.0.0.1</code>  <code><a href="http://127.0.0.1/"></a> 127.0.0.1</code> - URL connection to which we will emulate, it is important to specify the IP address and not the domain (remember - we changed the functions and the resolution will not work, and so faster) </li><li>  <i>max-time</i> sets the maximum execution time for curl to be equal to one second (it is impossible to set less), we set it as  neither curl nor AFL close the handle </li><li>  It is important to use the <i>--cookie-jar</i> parameter,  curl will only call a vulnerable function if cookies are used. </li></ul><br><br><img src="https://habrastorage.org/files/425/c22/c04/425c22c0476d45efb4d29a962b3fde05.PNG"><br><br>  After a few minutes, AFL will find the first test data that causes the application to crash. <br><br>  Now you can make sure that the application really falls on this input. <br><br><pre> <code class="hljs coffeescript">$ LD_PRELOAD=<span class="hljs-string"><span class="hljs-string">"/path/to/preeny/x86_64-linux-gnu/desock.so"</span></span> .<span class="hljs-regexp"><span class="hljs-regexp">/curl http:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/127.0.0.1/</span></span> --max-time <span class="hljs-number"><span class="hljs-number">1</span></span> --cookie-jar /dev/<span class="hljs-literal"><span class="hljs-literal">null</span></span> &lt; out/crashes/id:<span class="hljs-number"><span class="hljs-number">000010</span></span>,sig:<span class="hljs-number"><span class="hljs-number">06</span></span>,src:<span class="hljs-number"><span class="hljs-number">000000</span></span>,op:havoc,rep:<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/972/19d/445/97219d44570e4ab4b30f25bc61c84476.PNG"><br><br>  So we learned how to use AFL to test applications. <br>  When applying fuzzing in the testing process, it is important to understand that any, even the fastest and most effective, well-coated fuzzer does not replace the code analyzer, but only complements it. <br><br>  Related links and sources: <br><br><ul><li>  <a href="http://lcamtuf.coredump.cx/afl/">lcamtuf.coredump.cx/afl</a> </li><li>  <a href="http://llvm.org/docs/LibFuzzer.html">llvm.org/docs/LibFuzzer.html</a> </li><li>  <a href="https://fuzzing-project.org/tutorial3.html">fuzzing-project.org/tutorial3.html</a> </li><li>  <a href="https://lolware.net/2015/04/28/nginx-fuzzing.html">lolware.net/2015/04/28/nginx-fuzzing.html</a> </li><li>  <a href="http://clang-analyzer.llvm.org/">clang-analyzer.llvm.org</a> </li><li>  <a href="http://www.viva64.com/ru/b/0243/">www.viva64.com/ru/b/0243</a> </li><li>  <a href="https://scan.coverity.com/">scan.coverity.com</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/259671/">https://habr.com/ru/post/259671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259653/index.html">Restore databases using Veeam Explorer for Microsoft SQL Server</a></li>
<li><a href="../259655/index.html">We write chat for the local network using C ++ Builder. Client part</a></li>
<li><a href="../259657/index.html">Why in Russia there are so few committers in large open source projects</a></li>
<li><a href="../259663/index.html">Online store trump card: online shopping usability study</a></li>
<li><a href="../259667/index.html">Installing OpenStreetMap Nominatim to find latitude and longitude at the address entered</a></li>
<li><a href="../259675/index.html">Ruby and C. Part 4. We are on friendly terms with the accelerometer, gyroscope and range finder with Raphael.js</a></li>
<li><a href="../259677/index.html">Autopilot system for radio-controlled helicopter. Part 1: The Idea</a></li>
<li><a href="../259679/index.html">Native OmniDirectional shadows implementation in DirectX11</a></li>
<li><a href="../259683/index.html">Autopilot system for radio-controlled helicopter. Part 2: Takeover</a></li>
<li><a href="../259691/index.html">Battle "Listener vs Visitor" at the stadium antlr4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>