<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How it works in the java world. Concurrentmap</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The basic principle of programming is: do not reinvent the wheel. But sometimes, to understand what is happening and how to use the tool correctly, we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How it works in the java world. Concurrentmap</h1><div class="post__text post__text-html js-mediator-article"><p>  The basic principle of programming is: do not reinvent the wheel.  But sometimes, to understand what is happening and how to use the tool correctly, we need to do it.  Today we invent ConcrurrentHashMap. </p><br><p>  First we need 2 things.  Let's start with 2 tests - the first one will say that our implementation does not have data races (in fact, we need to check whether our test is correct also by testing a deliberately incorrect implementation), we will use the second test to test performance in terms of throughput. </p><br><a name="habracut"></a><br><p>  Consider only a few methods from the Map interface: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, V value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><h3 id="thread-safety-correctness-test">  Thread-safety correctness test </h3><br><p>  It is almost impossible to write a thread safety test quite exhaustively, you need to take into account all aspects defined in Chapter <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17 of the JLS</a> , moreover, the test largely depends on <a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">the</a> hardware memory <a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">model</a> or the implementation of the JVM. </p><br><p>  For the thread-safe correctness test, we use one of the ready-made stress test libraries, such as <a href="http://openjdk.java.net/projects/code-tools/jcstress/">jcstress</a> , which will run your code, trying to find inconsistencies in the data.  Although jcstress is still marked as experimental, it is the best choice.  Why is it difficult to write your own concurrency test? Watch Shipilev's <a href="https://shipilev.net/">lecture</a> . </p><br><p>  I use <a href="https://github.com/jerzykrlk/jcstress-gradle-plugin">jstress-gradle-plugin</a> to run jstress.  The complete source code can be found <a href="">how-it-works-concurrent-map</a> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConcurrentMapThreadSafetyTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapState</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Integer&gt; map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(<span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@JCStressTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@Description</span></span>(<span class="hljs-string"><span class="hljs-string">"Test race map get and put"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Outcome</span></span>(id = <span class="hljs-string"><span class="hljs-string">"0, 1"</span></span>, expect = ACCEPTABLE, desc = <span class="hljs-string"><span class="hljs-string">"return 0L and 1L"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Outcome</span></span>(expect = FORBIDDEN, desc = <span class="hljs-string"><span class="hljs-string">"Case violating atomicity."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapPutGetTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Actor</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actor1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapState state, LongResult2 result)</span></span></span><span class="hljs-function"> </span></span>{ state.map.put(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Integer r = state.map.get(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); result.r1 = (r == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? -<span class="hljs-number"><span class="hljs-number">1</span></span> : r); } <span class="hljs-meta"><span class="hljs-meta">@Actor</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actor2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapState state, LongResult2 result)</span></span></span><span class="hljs-function"> </span></span>{ state.map.put(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); Integer r = state.map.get(<span class="hljs-string"><span class="hljs-string">"B"</span></span>); result.r2 = (r == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? -<span class="hljs-number"><span class="hljs-number">1</span></span> : r); } } <span class="hljs-meta"><span class="hljs-meta">@JCStressTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@Description</span></span>(<span class="hljs-string"><span class="hljs-string">"Test race map check size"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Outcome</span></span>(id = <span class="hljs-string"><span class="hljs-string">"2"</span></span>, expect = ACCEPTABLE, desc = <span class="hljs-string"><span class="hljs-string">"size of map = 2 "</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Outcome</span></span>(id = <span class="hljs-string"><span class="hljs-string">"1"</span></span>, expect = FORBIDDEN, desc = <span class="hljs-string"><span class="hljs-string">"size of map = 1 is race"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Outcome</span></span>(expect = FORBIDDEN, desc = <span class="hljs-string"><span class="hljs-string">"Case violating atomicity."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapSizeTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Actor</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actor1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapState state)</span></span></span><span class="hljs-function"> </span></span>{ state.map.put(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Actor</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actor2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapState state)</span></span></span><span class="hljs-function"> </span></span>{ state.map.put(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Arbiter</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arbiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapState state, IntResult1 result)</span></span></span><span class="hljs-function"> </span></span>{ result.r1 = state.map.size(); } } }</code> </pre> <br><p>  In the first test of MapPutGetTest, we have two threads running simultaneously the methods actor1 and actor2, respectively, both of them put some value in the map and check them back, if there is no data race, both streams should see the specified values. </p><br><p>  In the second MapSizeTest, we simultaneously place two different keys in the map and after checking the size - if there is no data race - the expected result should be = 2. </p><br><p>  In order to check the correctness of the test, we will execute it on a deliberately non-secure HashMap - we must observe the violation of atomicity.  If we run the test on a thread-safe ConcurrentHashMap, we should not see a violation of consistency. </p><br><p>  Results with HashMap: </p><br><pre> <code class="bash hljs">[FAILED] ru.skuptsov.concurrent.map.test.ConcurrentMapTest.MapPutGetTest Observed state Occurrences Expectation Interpretation -1, 1 293,867 FORBIDDEN Case violating atomic 0, -1 282,190 FORBIDDEN Case violating atomic 0, 1 28,013,763 ACCEPTABLE <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0 and 1 [FAILED] ru.skuptsov.concurrent.map.test.ConcurrentMapTest.MapSizeTest Observed state Occurrences Expectation Interpretation 1 1,434,783 FORBIDDEN size of map = 1 race 2 11,733,097 ACCEPTABLE size of map = 2</code> </pre> <br><p>  In the thread-safe HashMap, we see some statistical number of inconsistent results, both tests failed. </p><br><p>  Results with thread-safe ConcurrentHashMap: </p><br><pre> <code class="bash hljs">[OK] ru.skuptsov.concurrent.map.test.ConcurrentMapTest.MapPutGetTest Observed state Occurrences Expectation Interpretation 0, 1 20,195,000 ACCEPTABLE [OK] ru.skuptsov.concurrent.map.test.ConcurrentMapTest.MapSizeTest Observed state Occurrences Expectation Interpretation 2 6,573,730 ACCEPTABLE size of map = 2</code> </pre> <br><p>  ConcurrentHashMap passed the test, at least we can recognize that our test can detect some simple concurrency problems.  The same results can be checked for Collection.synchronizedMap and HashTable. </p><br><h3 id="fitst-concurrenthashmap-attempt">  Fitst ConcurrentHashMap attempt </h3><br><p>  The first naive approach is to simply synchronize each access to internal structures ‚Äî an array of buckets. </p><br><p>  In fact, we can write some parallel shell over the transmitted map provider.  Similarly, java.util.Collections.synchronizedMap, Hashtable and guava synchronizedMultimap act. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SynchrinizedHashMap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;K, V&gt; provider; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object monitor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SynchronizedHashMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;K, V&gt; provider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.provider = provider; monitor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, V value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (monitor) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> provider.put(key, value); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (monitor) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> provider.get(key); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (monitor) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> provider.size(); } } }</code> </pre> <br><p>  Changes in the non-volatile map-provider will be visible between the streams, according to the documentation: </p><br><blockquote>  There is a synchronized method for the same object.  This object is visible to all threads. </blockquote><p>  Our simplest implementation runs parallel tests, but at what price?  In each method there can be only one thread at the same time, even if we work with different keys, therefore with multi-threaded load we should not expect high performance.  Let's measure it. </p><br><h3 id="test-proizvoditelnosti">  Performance test </h3><br><p>  For performance testing, we will use the <a href="http://openjdk.java.net/projects/code-tools/jmh/">jmh</a> library. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1</span></span>, timeUnit = TimeUnit.SECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1</span></span>, timeUnit = TimeUnit.SECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(MICROSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConcurrentMapBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;Integer, Integer&gt; map; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"concurrenthashmap"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashtable"</span></span>, <span class="hljs-string"><span class="hljs-string">"synchronizedhashmap"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String type; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer writersNum; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer readersNum; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUM = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"hashtable"</span></span>: map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hashtable&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"concurrenthashmap"</span></span>: map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"synchronizedhashmap"</span></span>: map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SynchronizedHashMap&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole bh)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ExecutionException, InterruptedException </span></span>{ List&lt;CompletableFuture&gt; futures = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; writersNum; i++) { futures.add(CompletableFuture.runAsync(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; NUM; j++) { map.put(j, j); } })); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; readersNum; i++) { futures.add(CompletableFuture.runAsync(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; NUM; j++) { bh.consume(map.get(j)); } })); } CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture[<span class="hljs-number"><span class="hljs-number">1</span></span>])).get(); } }</code> </pre> <br><p><img src="https://cdn-images-1.medium.com/max/1000/1*lYrdC-u_0d0jVTBucmDdew.png" alt="image"><br>  We made sure that the performance of our SynchronizedHashMap is almost the same as java's HashTable, and it is 2 times worse than ConcurrentHashMap.  Let's try to improve performance. </p><br><h3 id="lock-striping-concurrenthashmap-attempt">  Lock-striping ConcurrentHashMap attempt </h3><br><p>  The first improvement can be based on the idea that instead of blocking access to the entire map, it is better to synchronize access only if the threads access the same baket, where the bake index = key.hashCode ()% array.length.  This method is called lock striping or fine-grained synchronization, see The <a href="http://www.amazon.com/The-Multiprocessor-Programming-Revised-Reprint/dp/0123973376">Art of Multiprocessor Programming</a> . </p><br><p>  For an array of buckets, we will need an array of locks, when starting, the size of the array of locks should be equal to the internal size of the array - this is important, because we don‚Äôt want a situation where 2 locka are responsible for one bucket of the array. </p><br><p>  For simplicity, consider a map with an unchangeable array of buckets - this means that we will not be able to expand the initial capacity (if N &gt;&gt; initialCapacity we lose the O (1) map insert insertion guarantee. We also do not need loadFactor).  Expandable cocurrent map is a separate large topic. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LockStripingArrayConcurrentHashMap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseMap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AtomicInteger count = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicInteger(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Node&lt;K, V&gt;[] buckets; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] locks; <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>({<span class="hljs-string"><span class="hljs-string">"rawtypes"</span></span>, <span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LockStripingArrayConcurrentHashMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span><span class="hljs-function"> </span></span>{ locks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[capacity]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; locks.length; i++) { locks[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); } buckets = (Node&lt;K, V&gt;[]) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node[capacity]; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = hash(key); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (getLockFor(hash)) { Node&lt;K, V&gt; node = buckets[getBucketIndex(hash)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKeyEquals(key, hash, node)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.value; } node = node.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, V value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || value == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = hash(key); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (getLockFor(hash)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucketIndex = getBucketIndex(hash); Node&lt;K, V&gt; node = buckets[bucketIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { buckets[bucketIndex] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;&gt;(hash, key, value, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); count.incrementAndGet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Node&lt;K, V&gt; prevNode = node; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (node != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKeyEquals(key, hash, node)) { V prevValue = node.value; node.value = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prevValue; } prevNode = node; node = node.next; } prevNode.next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;&gt;(hash, key, value, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); count.incrementAndGet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ... } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, Node&lt;K, V&gt; node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.hash == hash &amp;&amp; node.key == key || (node.key != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; node.key.equals(key)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key.hashCode(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBucketIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % buckets.length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLockFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locks[hash % locks.length]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash; K key; V value; Node&lt;K, V&gt; next; Node(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash, K key, V value, Node&lt;K, V&gt; next) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hash = hash; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next = next; } } }</code> </pre> <br><p>  It is important that all class fields are final - this ensures safe-publication and that no one will call methods until the final creation of an object is important to us because we have some initialization in the constructor. </p><br><p>  Source code can be found <a href="">here</a> . </p><br><p>  Test results: <br><img src="https://cdn-images-1.medium.com/max/800/1*_KS1UlGCugVKkLdOUzWBRw.png" alt="image"><br><br>  We see that fine-grained synchronization implementation is better than general locking.  The results, with one reader and one writer, are almost the same compared to ConcurrentHashMap, but when the number of streams increases, the difference is greater, especially where there are many readers. </p><br><h3 id="lock-free-concurrent-hash-map-attempt">  Lock free concurrent hash map attempt </h3><br><p>  Honestly, synchronization is not a parallel programming method, because it puts threads in a sequential queue, making it wait for another thread to complete.  And the additional cost of system context synchronization increases with an increase in the number of waiting threads, but all we want to do is a small number of instructions for changing the value of the map key. </p><br><p>  We define some requirements for a new implementation of hashmap, which in theory should improve our implementation.  And the requirements are as follows: </p><br><ol><li>  If we have 2 threads that work with different keys (write or read), we don‚Äôt want any synchronization between them (word tearing in java is denied - access to two different array fields is thread safe) </li><li>  If several threads work with the same key (write and read), we don‚Äôt want to reorder operations ( <a href="http://irl.cs.ucla.edu/~yingdi/web/paperreading/whymb.2010.06.07c.pdf">more on the causes of problems in the modern cache structure</a> ) and we need guarantees for the threads between threads, otherwise one thread may not notice the changed value by another flow.  But we don't want to block the read stream and wait for the write stream to complete. </li><li>  We do not want to block several readers by one key if there is no one writing thread among them. </li></ol><br><p>  Let's concentrate on points 2 and 3. In fact, we can make the map read completely unblocked if we can (1) volatile read array of buckets, and then go inside the bucket with (2) volatile read next node linked list until we find the desired and volatile read of the node value itself. </p><br><p>  For (2), we can simply mark the next and value fields in Node as volatile. </p><br><p>  For (1) there is no such thing as a volatile array, even if the array is declared as volatile, it does not provide volatile semantics when reading or writing elements, while simultaneously accessing the k-th element of the array, external synchronization is required, volatile is only link to array  We can use AtomicReferenceArray for this purpose, but it accepts only Object [] arrays.  Alternatively, consider using Unsafe for a volatile array read and lock-free write.  The same method is used in AtomicReferenceArray and ConcurrentHashMap. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// read array value by index private &lt;K, V&gt; Node&lt;K, V&gt; volatileGetNode(int i) { return (Node&lt;K, V&gt;) U.getObjectVolatile(buckets, ((long) i &lt;&lt; ASHIFT) + ABASE); } // cas set array value by index private &lt;K, V&gt; boolean compareAndSwapNode(int i, Node&lt;K, V&gt; expectedNode, Node&lt;K, V&gt; setNode) { return U.compareAndSwapObject(buckets, ((long) i &lt;&lt; ASHIFT) + ABASE, expectedNode, setNode); } private static final sun.misc.Unsafe U; // Node[] header shift private static final long ABASE; // Node.class size shift private static final int ASHIFT; static { try { // get unsafe by reflection - it is illegal to use not in java lib Constructor&lt;Unsafe&gt; unsafeConstructor = Unsafe.class.getDeclaredConstructor(); unsafeConstructor.setAccessible(true); U = unsafeConstructor.newInstance(); } catch (NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalAccessException e) { throw new RuntimeException(e); } Class&lt;?&gt; ak = Node[].class; ABASE = U.arrayBaseOffset(ak); int scale = U.arrayIndexScale(ak); ASHIFT = 31 - Integer.numberOfLeadingZeros(scale); }</span></span></code> </pre> <br><p>  In volatile getNode, we can now safely read values ‚Äã‚Äãwithout locks. </p><br><p>  Let's write lock-free V get (Object key) now: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = hash(key); Node&lt;K, V&gt; node; <span class="hljs-comment"><span class="hljs-comment">// volatile read of bucket head at hash index if ((node = volatileGetNode(getBucketIndex(hash))) != null) { // check first node if (isKeyEquals(key, hash, node)) { return node.value; } // walk through the rest to find target node while ((node = node.next) != null) { if (isKeyEquals(key, hash, node)) return node.value; } } return null; }</span></span></code> </pre> <br><p>  In the first attempt there was a large memory-overhead with a lock pool - in fact, we can use the same fine-grained approach with no additional memory ‚Äî just lock on the first node in the bucket, if it exists.  If it does not exist, we cannot block on a non-existent element and need some lock-free method to set the header node ‚Äî we have already written this method above ‚Äî the compareAndSwapNode method. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, V value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || value == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = hash(key); <span class="hljs-comment"><span class="hljs-comment">// no resize in this implementation - so the index will not change int bucketIndex = getBucketIndex(hash); // cas loop trying not to miss while (true) { Node&lt;K, V&gt; node; // if bucket is empty try to set new head with cas if ((node = volatileGetNode(bucketIndex)) == null) { if (compareAndSwapNode(bucketIndex, null, new Node&lt;&gt;(hash, key, value, null))) { // if we succeed to set head - then break and return null count.increment(); break; } } else { // head is not null - try to find place to insert or update under lock synchronized (node) { // check if node have not been changed since we got it // otherwise let's go to another loop iteration if (volatileGetNode(bucketIndex) == node) { V prevValue = null; Node&lt;K, V&gt; n = node; while (true) { ... simply walk through list under lock and update or insert value... } return prevValue; } } } } return null; }</span></span></code> </pre> <br><p>  Full source code <a href="">here</a> . </p><br><p>  Let's test its performance: <br><img src="https://cdn-images-1.medium.com/max/800/1*pHppGikf4S1rRWL8_6D9Ug.png" alt="image"></p><br><p>  In some cases, we are even better than ConcurrentHashMap, but this is not a completely fair comparison.  Because ConcurrentHashMap does lazy table initialization at load time and resize at least once at the boundary element threshold = initialCapacity * loadFactor.  If we run the test again with the initialCapacity elements initialized!  = N (= N / 6), the results will differ slightly: </p><br><p><img src="https://cdn-images-1.medium.com/max/800/1*kFM8eWw3c6RSCcu2j6JAPw.png" alt="image"></p><br><p>  This happened due to the fact that ConcurrentHashMap increases the initial size of the array of buckets and spends less time getting items by key, due to a decrease in the length of the linked list in the bucket. </p><br><p>  It should be noted that we did not get a full-non-bloking data structure - just like ConcurrentHashMap, although all we need is just a linked list without locks, but with resizing and simultaneously modifying data this task is not so simple. - read <a href="https://timharris.uk/papers/2001-disc.pdf">here</a> . </p><br><p>  The original java 8 ConcurrentHashMap has a number of improvements that we did not mention, for example: </p><br><ol><li>  Lazy initialization of the bucket table, which minimizes the memory footprint before first use </li><li>  Concurrent resizing bakeset array </li><li>  Counting items using LongAdder. </li><li>  Special types of nodes (starting from 1.8) - TreeBins, if the list length inside the bake grows larger than TREEIFY_THRESHOLD = 8 - the bake becomes a balanced tree with the worst search by key (O (log (Nbucket_size))) </li></ol><br><p>  It should be noted that the implementation of ConcurrentHashMap in Java 1.8 has been significantly changed from 1.7.  In 1.7, this was the idea of ‚Äã‚Äãsegments, where the number of segments is equal to the level of parallelism.  In java 8, an array of buckets is a single array. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327186/">https://habr.com/ru/post/327186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327176/index.html">Dispelling the myths about the Qt meta-object compiler</a></li>
<li><a href="../327178/index.html">The digest of interesting materials for the mobile developer # 200 (April 17-23)</a></li>
<li><a href="../327180/index.html">Dagaz: Rehearsal</a></li>
<li><a href="../327182/index.html">Vulgarisms in mechanics: the harmfulness of the term "slowing down"</a></li>
<li><a href="../327184/index.html">Selenium in 60 seconds</a></li>
<li><a href="../327190/index.html">Ways to debug JS on client</a></li>
<li><a href="../327192/index.html">The story of the creation and launch of a fun mobile game about breaking bottles on the head</a></li>
<li><a href="../327194/index.html">10 mini life hacks in Bash</a></li>
<li><a href="../327196/index.html">Architecture of modular React + Redux applications 2. Core</a></li>
<li><a href="../327198/index.html">PHP Digest number 107 - the latest news, materials and tools (April 9 - 23, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>