<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mutation Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unit tests help us make sure that the code works the way we want it. One of the test metrics is the percentage of code line coverage (Line Code Covera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mutation Testing</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/2c5/3b5/2c5/2c53b52c5d5a411bafe24eba7116b302.png" align="left">  Unit tests help us make sure that the code works the way we want it.  One of the test metrics is the <em>percentage of</em> code line <em>coverage</em> (Line Code Coverage). </p><br><p> But how correct is this indicator?  Does he have a practical meaning and can we trust him?  After all, if we remove all the <code>assert</code> lines from the tests, or simply replace them with <code>assertSame(1, 1)</code> , then we will still have 100% Code Coverage, while the tests will absolutely not test anything. </p><br><p>  How confident are you in your tests?  Do they cover all branches of your functions?  Do they even test anything? </p><br><p>  The answer to this question is given by mutational testing. </p><a name="habracut"></a><br><blockquote>  Mutation testing is a software testing method based on all sorts of changes to the source code and checking the response to these changes in the suite of automated tests.  If the tests after the code change are successfully executed, then either the code is not covered by the tests, or the written tests are ineffective.  The criterion that determines the effectiveness of a set of automated tests is called Mutation Score Indicator (MSI). </blockquote><p>  Let's introduce some concepts from the theory of mutation testing: </p><br><p>  To use this technology, we obviously must have a source code ( <strong>source code</strong> ), a certain set of tests (for simplicity, we will speak about <strong>unit tests</strong> ). </p><br><p>  After that, you can begin to change individual parts of the source code and see how the tests react to it. </p><br><p>  One change to the source code will be called <strong>Mutation</strong> .  For example, changing a binary operator <code>"+"</code> to a binary <code>"-"</code> is a code mutation. </p><br><p>  The result of the mutation is the Mutant - that is, it is a new, mutated source code. </p><br><p>  Each mutation of any operator in your code (and there are hundreds of them) leads to a new mutant, for which tests must be run. </p><br><p>  In addition to changing the <code>"+"</code> to <code>"-"</code> , there are many other mutational operators ( <strong>Mutation Operator</strong> , <strong>Mutator</strong> ) - negation of conditions, changing the return value of a function, deleting lines of code, <a href="https://infection.github.io/guide/mutators.html">etc.</a> </p><br><p>  So, mutational testing creates a multitude of mutants from your code, for each of them runs tests and checks whether they completed successfully or not.  If the tests fell, then everything is fine, they reacted to the change in the code and caught the error.  Such a mutant is considered killed ( <strong>Killed mutant</strong> ).  If the tests are successful after mutation, it means that either your code is not covered in this place with tests at all, or tests covering the mutated string are ineffective and insufficiently test this section of code.  Such a mutant is called a survivor ( <strong>Survived, Escaped Mutant</strong> ). </p><br><p>  It is important to understand that mutational testing is not a chaotic code transformation, but an absolutely predictable and understandable process that, with the same input mutational operators, always produces the same list of mutations and the resulting metrics on the same source code being tested. </p><br><p>  Consider an example.  We will use the mutational framework (MF) for PHP - <a href="https://infection.github.io/guide/">Infection</a> . </p><br><p>  Suppose we have some kind of filter that can filter a collection of users by the age of majority, written in object-oriented style: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserFilterAge</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AGE_THRESHOLD = <span class="hljs-number"><span class="hljs-number">18</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $collection)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array_filter( $collection, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $item[<span class="hljs-string"><span class="hljs-string">'age'</span></span>] &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::AGE_THRESHOLD; } ); } }</code> </pre> <br><p>  And for this filter there is a unit test: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_it_filters_adults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserFilterAge(); $users = [ [<span class="hljs-string"><span class="hljs-string">'age'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>], [<span class="hljs-string"><span class="hljs-string">'age'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>], ]; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertCount(<span class="hljs-number"><span class="hljs-number">1</span></span>, $filter($users)); }</code> </pre> <br><p>  The test is very simple - we add two users and we expect that the filter will return only one of them, which is 20 years old. </p><br><p>  Note that if you only have this test, we already have a 100% coverage of the source code of the class <code>UserFilterAge</code> .  Run a mutation test and analyze the result: </p><br><pre> <code class="bash hljs">./infection.phar --threads=4</code> </pre> <br><p><img src="https://habrastorage.org/web/7da/8f3/eeb/7da8f3eeb5bd4fd694c8aa075a9d5a4b.png"></p><br><p>  With 100% code coverage, we only have 67% MSI - this is already suspicious. </p><br><div class="spoiler">  <b class="spoiler_title">How is MSI considered</b> <div class="spoiler_text"><pre> <code class="bash hljs">Metrics: Mutation Score Indicator (MSI): 47% Mutation Code Coverage: 67% Covered Code MSI: 70%</code> </pre> <br><h4 id="mutation-score-indicator-msi">  Mutation Score Indicator (MSI) </h4><br><p>  MSI is 47%.  This means that 47% of all generated mutations did not survive (killed, timeouts, errors).  MSI is the primary metric for mutation testing.  If Code Coverage is 65%, then we get a difference of 18% and this indicates that the percentage of coverage of lines of code in this case is a bad criterion for evaluating tests. </p><br><p>  Counting formula: </p><br><pre> <code class="bash hljs">TotalDefeatedMutants = KilledCount + TimedOutCount + ErrorCount; MSI = (TotalDefeatedMutants / TotalMutantsCount) * 100;</code> </pre> <br><h4 id="mutation-code-coverage">  Mutation Code Coverage </h4><br><p>  This indicator is 67%.  In general, it should be approximately equal to the Code Coverage indicator. </p><br><p>  Counting formula: </p><br><pre> <code class="bash hljs">TotalCoveredByTestsMutants = TotalMutantsCount - NotCoveredByTestsCount; CoveredRate = (TotalCoveredByTestsMutants / TotalMutantsCount) * 100;</code> </pre> <br><h4 id="covered-code-mutation-score-indicator">  Covered Code Mutation Score Indicator </h4><br><p>  The MSI for the code that is <em>covered in tests</em> is 70%.  This criterion shows how effective your tests are in reality.  That is, this is the percentage of all killed mutants generated for the covered test code. </p><br><p>  Counting formula: </p><br><pre> <code class="bash hljs">TotalCoveredByTestsMutants = TotalMutantsCount - NotCoveredByTestsCount; TotalDefeatedMutants = KilledCount + TimedOutCount + ErrorCount; CoveredCodeMSI = (TotalDefeatedMutants / TotalCoveredByTestsMutants) * 100;</code> </pre> <br><p>  If we analyze the metrics, it turns out that MSI is 18 units less than the Code Coverage indicator.  This suggests that the tests are much less effective according to the results of mutational testing than the results of the bare Code Coverage. </p></div></div><br><p>  Let's look at the generated mutations. </p><br><p>  First mutation: </p><br><pre> <code class="diff hljs">class UserFilterAge { const AGE_THRESHOLD = 18; public function __invoke(array $collection) { return array_filter( $collection, function (array $item) { - return $item['age'] &gt;= self::AGE_THRESHOLD; + return $item['age'] &gt; self::AGE_THRESHOLD; } ); } }</code> </pre> <br><p>  The tests run for it are executed successfully.  That is, the change in the source code had absolutely no effect on the test results.  This is not what we need. </p><br><p>  Mutation testing told us that we can take and replace the condition with <code>"&gt;="</code> with <code>"&gt;"</code> , and the program will work just as well.  Remember, unit tests guarantee us that the program works the way we want it?  And once the tests have been completed successfully with such a mutated code, then we expect this behavior. </p><br><blockquote>  From this mutation it can be seen that when testing a code with conditions for intervals, one should always check the boundary values. </blockquote><p>  Let's fix the situation and kill the mutant: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@dataProvider</span></span></span><span class="hljs-comment"> usersProvider */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_it_filters_adults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $users, int $expectedCount)</span></span></span><span class="hljs-function"> </span></span>{ $filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserFilterAge(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertCount($expectedCount, $filter($users)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usersProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ [ [ [<span class="hljs-string"><span class="hljs-string">'age'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>], [<span class="hljs-string"><span class="hljs-string">'age'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>], ], <span class="hljs-number"><span class="hljs-number">1</span></span> ], [ [ [<span class="hljs-string"><span class="hljs-string">'age'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">18</span></span>], ], <span class="hljs-number"><span class="hljs-number">1</span></span> ] ]; }</code> </pre> <br><p>  We added one test for the boundary value - 18. Now, if we run the tests with the mutated code again, they will fall, since all values ‚Äã‚Äãwill be filtered out and the empty collection will return, which is naturally not true. </p><br><p>  Second mutation: </p><br><pre> <code class="diff hljs">class UserFilterAge { const AGE_THRESHOLD = 18; public function __invoke(array $collection) { - return array_filter( + array_filter( $collection, function (array $item) { return $item['age'] &gt;= self::AGE_THRESHOLD; } ); + return null; } }</code> </pre> <br><p>  It is not immediately obvious what happened.  This is a rather interesting mutational operator, replacing the function call in the expression <code>"return functionCall();"</code>  on <code>"functionCall(); return null;"</code>  . </p><br><p>  But why did such a mutation happen at all?  Is it true to return <code>null</code> when we expect a filtered <em>array</em> ?  Of course, not true, and this happens because we did not specify the type of the return value in the function.  The mf sees that the return value may be <code>null</code> , and tries to slip it.  Infection is quite clever in this regard, and if the function contains a specific type (not <code>nullable</code> , for example <code>int</code> ) of the return value, then the code will not mutate.  Analyzing this mutant, we conclude that typehint should be added: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public function __invoke(array $collection) + public function __invoke(array $collection): array</span></span></code> </pre> <br><p>  Now the method signature is absolutely clear - we pass an array to the filter, we expect an array. </p><br><p>  Run again and check the result: </p><br><p><img src="https://habrastorage.org/web/d30/18e/fa9/d3018efa9ec74a1d9a42922a991e90d6.png"></p><br><p>  The number of mutations is expected to decrease due to the addition of the return type, and all mutants are killed.  Now we have not only Code Coverage 100%, but also Mutation Code Coverage 100%, which is a much more indicative criterion for the quality of your tests. </p><br><p>  This simple example shows that even with 100% coverage of a code with tests, mutational testing can still reveal problems and, as it were, cover your code "by more than 100%." </p><br><p>  If you have not yet penetrated, consider the mutational operators more powerful - <code>PublicVisibility</code> and <code>ProtectedVisibility</code> .  Their meaning is to change the access modifier from <code>public</code> to <code>protected</code> for each method of the class (except for some magic and abstract), from <code>protected</code> to <code>private</code> . </p><br><p>  This allows you to check the need for openness methods.  If such mutants prove to be survivors, then it can be concluded that the public interface of your class may be reduced and, most likely, is redundant.  And in the case of the <code>ProtectedVisibility</code> operator, the surviving mutant says that the method should be changed to private and there is not a single heir to the class that would use / override the parent <code>protected</code> method. </p><br><p>  For example, by running Infection for a <code>FosUserBundle</code> known <code>FosUserBundle</code> , you can see that there is a public method <code>isLegacy</code> , the openness of which can be reduced. </p><br><pre> <code class="bash hljs">./infection.php --threads=4 --show-mutations --mutators=PublicVisibility,ProtectedVisibility</code> </pre> <br><p><img src="https://habrastorage.org/web/ecf/4cb/6b3/ecf4cb6b36d04458a43e25c70cd4ab41.png"></p><br><p>  In addition to these two cases with a surviving and killed mutant, there are others.  For example, a change in the cycle of the unary operator <code>"++"</code> on the counter variable to <code>"--"</code> can lead to the fact that the cycle will never end, since  will be endless.  The task of the mutation testing framework is to correctly handle such situations and mark the mutant with a special status - <strong>Timeout</strong> .  This outcome is positive and the mutant is not considered surviving. </p><br><p>  In general, we figured out the theory, now let's see what Infection is in more detail, and what alternatives are there for PHP. </p><br><h1 id="infection-php">  Infection PHP </h1><br><p>  To work, Infection requires the xDebug extension installed for Code Coverage and PHP 7.0+. </p><br><p>  <a href="https://infection.github.io/guide/installation.html">The recommended</a> installation method, with the possibility of automatic updating ( <code>infection.phar self-update</code> ), is the Phar archive. </p><br><p>  Currently, two testing frameworks are supported out of the box - PHPUnit (5, 6+) and PhpSpec. </p><br><p>  When you first start from the root of your project, an config.infon.json.dist will be created, which you can later commit to VCS.  It lists the source folder for mutations, exceptions, timeout value, etc. </p><br><p>  Mutation testing as a whole requires human analysis; therefore, after mutation is completed, all generated mutations are logged in the same folder as <code>infection-log.txt</code> . </p><br><h2 id="opcii">  Options </h2><br><p>  Of the most interesting <a href="https://infection.github.io/guide/command-line-options.html">options</a> with which Infection is launched, the following can be highlighted: </p><br><h3 id="--threads"> <code>--threads</code> </h3> <br><p>  This is the number of threads working in parallel to trigger the entire set of generated mutants.  Significantly speeds up execution time.  But there is a reservation: if your tests somehow depend on each other or use a database, using this option can lead to numerous dropped tests, which will have an extremely negative impact on the resulting metrics.  Therefore, at least look at the log at the initial stages of implementation is still worth it. </p><br><h3 id="--show-mutations"> <code>--show-mutations</code> </h3> <br><p>  Immediately displays diff with not killed mutants on the console, which allows you to instantly analyze the result and correct the test as it is written. </p><br><h3 id="--mutators"> <code>--mutators</code> </h3> <br><p>  Enumeration of mutational operators that mutate the code.  Conveniently, for example, if you want to check only the PublicVisibility and ProtectedVisibility statements. </p><br><pre> <code class="bash hljs">./infection.phar --mutators=PublicVisibility,ProtectedVisibility</code> </pre> <br><h3 id="--min-msi-i---min-covered-msi">  <code>--min-msi</code> and <code>--min-covered-msi</code> </h3><br><p>  These two options are useful if you run Infection as one of the steps to build your project on the Continious Integration server. </p><br><p>  <code>--min-msi</code> allows you to specify the minimum value (in percent) of Mutation Score Indicator.  If the specified value is less than the actual, then the build will fall.  <strong>This option causes each build to cover more lines of code.</strong> </p><br><p>  <code>--min-covered-msi</code> accordingly allows you to specify the minimum value of Covered Code MSI.  <strong>This option with every build makes writing more efficient and reliable tests.</strong> </p><br><p>  Both options can be used both individually and together. </p><br><pre> <code class="bash hljs">./infection.phar --min-msi=80 --min-covered-msi=95</code> </pre> <br><h2 id="ispolzovanie-s-travis-ci">  Use with Travis CI </h2><br><pre> <code class="bash hljs">before_script: - wget https://github.com/infection/infection/releases/download/0.5.0/infection.phar - wget https://github.com/infection/infection/releases/download/0.5.0/infection.phar.pubkey - chmod +x infection.phar script: - ./infection.phar --min-covered-msi=90 --threads=4</code> </pre> <br><p>  Each release (Phar archive) is signed with a private <code>openssl</code> key, so besides the archive itself, you also need to download the public key. </p><br><h2 id="kak-ispolzovat-mutacionnoe-testirovanie">  How to use mutation testing? </h2><br><p>  How can mutation testing be useful for you, as a developer in your work or personal projects?  How to implement it in an existing project? </p><br><h3 id="ezhednevnoe-ispolzovanie-dlya-razrabotchika">  Daily use for developer </h3><br><p>  Mutation testing can be useful in daily work when writing new tests.  The scheme of work looks like this: </p><br><ul><li>  You wrote a new functionality, for example, the same <code>UserFilterAge</code> from the example above. </li><li>  this code is already covered by tests </li><li>  to test tests, you run mutation testing only for this file </li></ul><br><pre> <code class="bash hljs">./infection.phar --threads=4 --filter=UserFilterAge.php --show-mutations</code> </pre> <br><p>  Analyze the surviving mutants and try to achieve a good indicator of Covered Code MSI - i.e.  so that the percentage of killed mutants from all generated for the code <em>covered with tests should be</em> aimed at 100. This will allow writing tests as efficiently as possible. </p><br><p>  When using MT, you will notice that you write a more concise code with most of the tests.  This will use branch coverage when all the paths of your code have been tested, instead of the usual line coverage. </p><br><h3 id="ezhednevnoe-ispolzovanie-v-proekte">  Daily use in the project </h3><br><p>  Mutation testing can be used on a Continious Integration server.  Depending on the size of the project, it can be run either on each build, or less, as an option once a day at night.  The main thing here is to analyze the result and constantly improve the quality of tests. </p><br><p>  In my opinion, by generating only a report, you cannot achieve good performance, so it is better to use the <code>--min-msi</code> and / or <code>--min-covered-msi</code> options. </p><br><p>  For example, the mutation framework Infection mutationally tests <a href="https://travis-ci.org/infection/infection/jobs/266584952">itself</a> on every build.  And if the numbers fall, the build also falls. </p><br><p>  With continuous use of MT, MSI indicators in the project will grow and you will be able to gradually increase the values ‚Äã‚Äãof the <code>--min-msi</code> and <code>--min-covered-msi</code> options. </p><br><h3 id="pochemu-inogda-nevozmozhno-dobitsya-100-msi">  Why is it sometimes impossible to achieve 100% MSI? </h3><br><p>  In mutational testing there is the concept of identical mutants.  That is, these are mutations that lead to identical code in terms of logic.  An example of such a mutation is the following code: </p><br><pre> <code class="diff hljs">public function calculateExpectedValueAt(DateTimeInterface $date) { $diffInDays = (int) $this-&gt;startedAt-&gt;diff($date)-&gt;format('%a'); $multiplier = $this-&gt;initialValue &lt; $this-&gt;targetValue ? 1 : -1; $initialAveragePerDay = $this-&gt;calculateInitialAveragePerDay(); - return $this-&gt;initialValue + ($initialAveragePerDay * $diffInDays * $multiplier); + return $this-&gt;initialValue + ($initialAveragePerDay * $diffInDays / $multiplier); }</code> </pre> <br><p>  The point is that multiplying a number and dividing a number by <code>¬±1</code> leads to an identical result, and such a mutant turns out to be a survivor. </p><br><p>  In this regard, it is not worthwhile to expect in practice for the entire code of one hundred percent MSI.  This requires a powerful system for registering identical mutants and the possibility of excluding them from the resultant metrics. </p><br><h2 id="alternativy-dlya-php">  PHP Alternatives </h2><br><p>  The only full working alternative for Infection in PHP is Humbug - this is generally the first MF in PHP.  Of the benefits, it has experimental support for mutation caching (incremental cache).  That is, if a file does not change and no tests covering its lines were deleted during the next run, the mutation does not start and the result of the last run is taken.  Theoretically, this can significantly increase the speed of work, but can lead to false positives and errors in the metrics. </p><br><p>  On the other hand, Humbug does not yet support PHPUnit 6+ and PhpSpec.  However, the main difference between Infection and Humbug at the moment is that Infection uses the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Abstract Syntax Tree (AST)</a> syntax tree.  Building AST is possible thanks to the wonderful project of Nikita Popov - <a href="https://github.com/nikic/PHP-Parser">PHP-Parser</a> . </p><br><p>  What does the use of AST?  Consider more. </p><br><p>  To begin to mutate the code, you must </p><br><ul><li>  split the code of the file into tokens (function <a href="http://php.net/manual/en/function.token-get-all.php">token_get_all ()</a> ), put them into an array </li><li>  run through the array and replace each token, if necessary, with another one, according to the mutation operator </li><li>  from the new set of tokens to assemble a new mutated source code </li></ul><br><div class="spoiler">  <b class="spoiler_title">Sample Tokens</b> <div class="spoiler_text"><pre> <code class="bash hljs">T_OPEN_TAG (<span class="hljs-string"><span class="hljs-string">'&lt;?php '</span></span>) T_BOOLEAN_AND (<span class="hljs-string"><span class="hljs-string">'&amp;&amp;'</span></span>) T_INC (<span class="hljs-string"><span class="hljs-string">'++'</span></span>) T_WHITESPACE (<span class="hljs-string"><span class="hljs-string">' '</span></span>) ...</code> </pre> </div></div><br><p>  But in fact, the process is much more complicated, because  the decision to change the token depends on several conditions. </p><br><ul><li>  Are we in a function body?  Replacing <code>T_OPEN_TAG ('&lt;?php ')</code> makes no sense </li><li>  Will the code be valid after mutation?  (for example, adding arrays <code>['a'] + ['b']</code> is a valid code. But subtracting arrays <code>['a'] - ['b']</code> is already a <a href="https://3v4l.org/402jN">Fatal Error</a> . Consequently, such a mutation is not necessary, and The MF must check if the addition token is between the arrays. </li></ul><br><p>  As a result, using an array of tokens, it is rather difficult to answer these questions in terms of code.  On the contrary, having an abstract syntax tree, it is easy to do this, using objects representing the source code ( <code>Node\Expr\BinaryOp\Plus</code> , <code>Node\Expr\BinaryOp\Minus</code> , <code>Node\Expr\Array_</code> ). </p><br><p>  Here are the implementations of a mutation operator that changes <code>"+"</code> to <code>"-"</code> with checking arrays: </p><br><div class="spoiler">  <b class="spoiler_title">Infection</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plus</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node $node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryOp\Minus($node-&gt;left, $node-&gt;right, $node-&gt;getAttributes()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldMutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node $node)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!($node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BinaryOp\Plus)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($node-&gt;left <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Array_ &amp;&amp; $node-&gt;right <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Array_) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Humbug</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Addition</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutatorAbstract</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMutation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array &amp;$tokens, $index)</span></span></span><span class="hljs-function"> </span></span>{ $tokens[$index] = <span class="hljs-string"><span class="hljs-string">'-'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array &amp;$tokens, $index)</span></span></span><span class="hljs-function"> </span></span>{ $t = $tokens[$index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_array($t) &amp;&amp; $t == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) { $tokenCount = count($tokens); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = $index + <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt; $tokenCount; $i++) { <span class="hljs-comment"><span class="hljs-comment">// check for short array syntax if (!is_array($tokens[$i]) &amp;&amp; $tokens[$i][0] == '[') { return false; } // check for long array syntax if (is_array($tokens[$i]) &amp;&amp; $tokens[$i][0] == T_ARRAY &amp;&amp; $tokens[$i][1] == 'array') { return false; } // if we're at the end of the array // and we didn't see any array, we // can probably mutate this addition if (!is_array($tokens[$i]) &amp;&amp; $tokens[$i] == ';') { return true; } } return true; } return false; } }</span></span></code> </pre> </div></div><br><p>  Obviously, using AST offers tremendous benefits.  It is easier to work with, easier to maintain and understand the code, easier to create new mutational operators and easier to analyze the code, walking along the branches of the tree. </p><br><hr><br><p>  In general, mutational testing is another means to improve the quality of your tests and the code as a whole, worth paying attention to. </p><br><p>  If you have experience using MT on real projects, or you will try Infection and find interesting errors in the code - share in the comments about any useful cases. </p><br><p>  Used Books: </p><br><ul><li>  <a href="https://leanpub.com/mutationtesting">E-book</a> on mutation testing (in English) </li><li>  <a href="http://crestweb.cs.ucl.ac.uk/resources/mutation_testing_repository/">Mutation Testing Repository</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334394/">https://habr.com/ru/post/334394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334384/index.html">Tree Tree Comparison *</a></li>
<li><a href="../334386/index.html">Postgres Pro quiz task analysis on PGDay'17</a></li>
<li><a href="../334388/index.html">Authorization form with sending an encrypted password</a></li>
<li><a href="../334390/index.html">Magento Dare to Share - Open Platform for Reports on Magento, PHP and eCommerce</a></li>
<li><a href="../334392/index.html">Putting things in order: Chrome and Firefox will end the credibility of Symantec certification center</a></li>
<li><a href="../334396/index.html">Hacking a casino through a smart aquarium and DDoS stock brokers: new attacks on finance</a></li>
<li><a href="../334398/index.html">R and Big Data: Use Replyr</a></li>
<li><a href="../334400/index.html">Biomechanics and artificial intelligence in medicine. Lecture at YaC 2017</a></li>
<li><a href="../334402/index.html">Grant for startups: online magistracy awaits the best</a></li>
<li><a href="../334404/index.html">Doctrine Specification Pattern or your reusable QueryBuilder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>