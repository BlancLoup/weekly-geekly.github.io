<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Description of the menu structure without using resources</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Each of us, of course, faced with a situation where the menu needs to be generated dynamically, directly during the execution of the pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Description of the menu structure without using resources</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Each of us, of course, faced with a situation where the menu needs to be generated dynamically, directly during the execution of the program.  This may be required for various reasons, for example, due to the presence of several resource localizations or due to a too wide variety of menu options. <br><a name="habracut"></a><br><h4>  Normal way </h4><br>  The Win32 API for this offers the functions CreateMenu (), AppendMenu () and the like.  A little bit complicated menu with submenus nested in this description is not very clear, if not to say unreadable.  Even ATL does not help: <br><pre> <code class="hljs mel">CMenu <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.CreateMenu() ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_STRING, ECmdOpen, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_STRING, ECmdClose, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_SEPARATOR) ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_STRING, ECmdTwist, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; CMenu scratchMenu ; scratchMenu.CreateMenu() ; scratchMenu.AppendMenu(MF_STRING, ECmdScratchHead, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; scratchMenu.AppendMenu(MF_STRING, ECmdScratchNose, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_POPUP, scratchMenu, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.AppendMenu(MF_STRING, ECmdLose, L<span class="hljs-string"><span class="hljs-string">""</span></span>) ;</code> </pre><br>  A large number of repetitive code tires the gaze and plunges into depression. <br><br><h4>  New way </h4><br>  I want to write briefly and clearly: <br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdOpen)</span></span></span><span class="hljs-function">] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdClose)</span></span></span><span class="hljs-function">] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">separator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdTwist)</span></span></span><span class="hljs-function">] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdScratchHead)</span></span></span><span class="hljs-function">] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdScratchNose)</span></span></span><span class="hljs-function">] ] [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ECmdLose)</span></span></span><span class="hljs-function">]</span></span></code> </pre><br>  So write to us will allow the presence of operator overloading in the C ++ language.  We will overload the "square brackets" operator to do something with the object and return a reference to the object itself: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span></span>{ node &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](...) { <span class="hljs-comment"><span class="hljs-comment">// ... return *this ; } } ;</span></span></code> </pre><br>  This will allow us to call this operator to the object as many times as necessary: <br><pre> <code class="hljs markdown">node n ; n[<span class="hljs-string"><span class="hljs-string">123</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">456</span></span>][<span class="hljs-string"><span class="hljs-string">789</span></span>] ;</code> </pre><br>  The menu can be represented in the form of a tree, which has four types of nodes: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_type</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">EEmpty</span></span>, <span class="hljs-type"><span class="hljs-type">ESeparator</span></span>, <span class="hljs-type"><span class="hljs-type">ECommand</span></span>, <span class="hljs-type"><span class="hljs-type">EPopup</span></span> } ;</code> </pre><br>  An <code>EPopup</code> node can have as many children of any type as possible; the other nodes cannot have children. <br>  It is clear that if they are to be in the same tree, then they cannot do without a common ancestor.  The <code>append()</code> method allows you to add children to the node, the <code>append_to()</code> method is needed to create a real menu when traversing our tree. <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_impl_base</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;node_impl_base&gt; node_impl_ptr ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_impl_base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~node_impl_base() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> node_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node &amp; n)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HMENU aMenu)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; } ; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;node_impl_base&gt; node_impl_ptr ;</code> </pre><br>  Also useful is a small auxiliary structure, so as not to repeat: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;node_type Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_impl</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> node_impl_base { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node_type KType = Type ; <span class="hljs-function"><span class="hljs-function">node_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KType; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node &amp; n)</span></span></span><span class="hljs-function"> </span></span>{ _ASSERT(!<span class="hljs-string"><span class="hljs-string">"not allowed"</span></span>); } };</code> </pre><br>  <code>_ASSERT</code> needed in order not to accidentally call the <code>append()</code> method for a node that cannot have children. <br>  Now we implement our nodes: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">empty_node</span></span></span><span class="hljs-class">:</span></span> node_impl&lt;EEmpty&gt;, boost::noncopyable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HMENU aMenu)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ CMenuHandle(aMenu).AppendMenu(MF_STRING); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">separator_node</span></span></span><span class="hljs-class">:</span></span> node_impl&lt;ESeparator&gt;, boost::noncopyable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HMENU aMenu)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ CMenuHandle(aMenu).AppendMenu(MF_SEPARATOR); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">command_node</span></span></span><span class="hljs-class">:</span></span> node_impl&lt;ECommand&gt;, boost::noncopyable { command_node(PCTSTR text, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id): text_(text), id_(id) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HMENU aMenu)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ CMenuHandle(aMenu).AppendMenu(MF_STRING, id_, text_); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CString text_ ; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_ ; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">popup_node</span></span></span><span class="hljs-class">:</span></span> node_impl&lt;EPopup&gt;, boost::noncopyable { popup_node(PCTSTR text): text_(text) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node &amp; n)</span></span></span><span class="hljs-function"> </span></span>{ children_.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> node(n)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HMENU aMenu)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ CMenuHandle menu ; menu.CreatePopupMenu() ; BOOST_FOREACH(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node &amp; n, children_) { n.append_to(menu) ; } CMenuHandle(aMenu).AppendMenu(MF_STRING, menu, text_) ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::ptr_vector&lt;node&gt; children_ ; CString text_ ; } ;</code> </pre><br>  The tree itself will consist of objects of the same <code>node</code> type.  The idiom "pimpl" is used, that is, node contains a pointer to a specific implementation of the node.  Pay attention to the semantics of copying and assignment: <br><pre> <code class="hljs pgsql">struct node { friend node empty() ; friend node separator() ; friend node command(PCTSTR <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> id) ; friend node popup(PCTSTR <span class="hljs-type"><span class="hljs-type">text</span></span>) ; node(): impl_(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> empty_node()) {} node(node &amp; other): impl_(other.impl_) {} // <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> node &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(node &amp; other) { impl_ = other.impl_; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *this; } // <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> node &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](node &amp; n) { impl_-&gt;append(n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *this; } node_type <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> impl_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>(); } <span class="hljs-type"><span class="hljs-type">void</span></span> append_to(HMENU aMenu) const { impl_-&gt;append_to(aMenu); } private: node(node_impl_ptr impl): impl_(impl) {} // take ownership node_impl_ptr impl_ ; } ;</code> </pre><br>  When assigning one <code>node</code> another, the implementation is transferred (the so-called move semantics).  An object from the right side becomes a dummy.  The copy constructor also works.  ( <code>std::auto_ptr</code> works in the same way). <br>  Since everything was started in order to describe a multi-level structure as a temporary object, the move-semantics saves a lot of copy operations here. <br>  By the way, since <code>node_impl_ptr</code> is <code>std::auto_ptr</code> , you could not explicitly define <code>node(node &amp; other)</code> and <code>operator=(node &amp; other)</code> , the compiler would generate them themselves. <br><br>  Now we just have to define the functions for creating nodes.  With the exception of <code>empty()</code> , they use a private constructor and are therefore declared as <code>friend</code> . <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node() ; } <span class="hljs-function"><span class="hljs-function">node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">separator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node(node_impl_ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> separator_node())) ; } <span class="hljs-function"><span class="hljs-function">node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PCTSTR text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node(node_impl_ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> command_node(text, id))) ; } <span class="hljs-function"><span class="hljs-function">node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PCTSTR text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node(node_impl_ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> popup_node(text))) ; }</code> </pre><br>  Done!  In working code, it is used like this: <br><pre> <code class="hljs bash">struct menubar { menubar(node key1, node key2) ; // ... }; SetMenuBar( menubar( <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>, IDOK), popup(L<span class="hljs-string"><span class="hljs-string">""</span></span>) [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdOpen)] [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdClose)] [separator()] [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdTwist)] [popup(L<span class="hljs-string"><span class="hljs-string">""</span></span>) [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdScratchHead)] [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdScratchNose)] ] [<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>(L<span class="hljs-string"><span class="hljs-string">""</span></span>, ECmdLose)] ) ) ;</code> </pre><br>  Thanks to the node's move-semantics, the entire structure is not copied here; instead, it is directly passed to <code>SetMenuBar()</code> . <br>  <code>menubar</code> consists of two trees, because the Windows Mobile application has two soft keys.  The implementation of <code>SetMenuBar()</code> is beyond the scope of this article, and so a lot of text has already happened :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Conclusion </h4><br>  The main goal was to show how it is possible to visually describe multi-level heterogeneous structures using only the syntax of the C ++ language.  With small extensions, this method can be applied to desktop applications with richer menu functionality. </div><p>Source: <a href="https://habr.com/ru/post/88844/">https://habr.com/ru/post/88844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../88833/index.html">Three-dimensional firstborn from ASUS</a></li>
<li><a href="../88834/index.html">IT (and not only) life in Brazil</a></li>
<li><a href="../88839/index.html">Windows 7 will be distributed to all schools for free</a></li>
<li><a href="../88840/index.html">Handgam - the best anti-stress. Solid and liquid at the same time</a></li>
<li><a href="../88841/index.html">Community for children and not only</a></li>
<li><a href="../88845/index.html">Little personal Steve Jobs</a></li>
<li><a href="../88846/index.html">Yii 1.1.2</a></li>
<li><a href="../88851/index.html">Notes beginner "switcher"</a></li>
<li><a href="../88852/index.html">David Yang (ABBYY) on how FineReader was created</a></li>
<li><a href="../88854/index.html">The first day of CloudConf 2010: impressions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>