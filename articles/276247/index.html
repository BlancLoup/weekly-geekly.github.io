<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with JSON in Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript Object Notation , or JSON for short, is the most common way to communicate with the server and retrieve information from it. It is extremel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with JSON in Swift</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://www.json.org/">JavaScript Object Notation</a> , or JSON for short, is the most common way to communicate with the server and retrieve information from it.  It is extremely popular due to its ease of use and perception. <br><br>  Consider the following JSON snippet: <br><pre><code class="objectivec hljs">[ { <span class="hljs-string"><span class="hljs-string">"person"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Dani"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-string"><span class="hljs-string">"24"</span></span> } }, { <span class="hljs-string"><span class="hljs-string">"person"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ray"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-string"><span class="hljs-string">"70"</span></span> } } ]</code> </pre> <br><a name="habracut"></a><br>  In Objective-C, parsing and deserializing JSON is fairly simple: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *json = [<span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span> JSONObjectWithData:JSONData options:kNilOptions error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *age = json[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">@"person"</span></span>][<span class="hljs-string"><span class="hljs-string">@"age"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Dani's age is %@"</span></span>, age);</code> </pre><br><br>  In Swift, this is a more complicated process due to the optional optionals types and type safety: <br><pre> <code class="objectivec hljs">var json: Array! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { json = try <span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span>.JSONObjectWithData(JSONData, options: <span class="hljs-built_in"><span class="hljs-built_in">NSJSONReadingOptions</span></span>()) as? Array } catch { print(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let item = json[<span class="hljs-number"><span class="hljs-number">0</span></span>] as? [String: AnyObject] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let person = item[<span class="hljs-string"><span class="hljs-string">"person"</span></span>] as? [String: AnyObject] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let age = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] as? Int { print(<span class="hljs-string"><span class="hljs-string">"Dani's age is \(age)"</span></span>) } } }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the code above, you need to check each object before using <b>optional binding</b> .  This will protect your code;  but the more complex the JSON, the more cumbersome the code becomes. <br><br>  In Swift 2.0, the <b>guard</b> statement was introduced in order to get rid of nested if statements: <br><pre> <code class="objectivec hljs">guard let item = json[<span class="hljs-number"><span class="hljs-number">0</span></span>] as? [String: AnyObject], let person = item[<span class="hljs-string"><span class="hljs-string">"person"</span></span>] as? [String: AnyObject], let age = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] as? Int <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print(<span class="hljs-string"><span class="hljs-string">"Dani's age is \(age)"</span></span>)</code> </pre><br>  Still verbose?  But how to simplify it? <br><br>  This article on working with JSON uses the simplest method of parsing JSON - using the popular public library <a href="https://github.com/hkellaway/Gloss">Gloss</a> . <br><br>  So, in particular, you will use Gloss for parsing and converting JSON, which holds 25 popular applications in the US App Store.  As easy as Objective-C! <br><br><h3>  Where to begin </h3><br>  <a href="">Download the starting playground</a> for this article. <br><br>  Since the user interface is not needed, we will work exclusively with the playground. <br><br>  Open the <b>Swift.playground</b> in Xcode and learn it. <br><br>  <b>Note:</b> You may notice that <b>Project Navigator</b> is closed by default.  If so, click <b>Command + 1</b> to display it.  You should be able to do so as in the image below. <br><br><img src="https://habrastorage.org/files/eae/380/873/eae3808738fe42f984a96569e6e2a40a.png"><br><br>  The playground start file contains several source and resource files that are fully focused on parsing JSON.  Pay attention to the playground structure: <br><br><ul><li>  The <b>Resources</b> folder contains resources that can be accessed through your Swift code. </li><li>  <b>topapps.json</b> : Contains a string for parsing JSON. </li><li>  The <b>Sources</b> folder contains additional source files to which your code in the playground has access.  Adding support files. <b>Swift</b> in this folder should be thought out, it will bring ease of reading your playground'a. </li><li>  <b>App.swift</b> : The structure of the old simple Swift is an application.  Your goal is to parse JSON into collections of objects. </li><li>  <b>DataManager.swift</b> : Manages data retrieval from a local network or the Internet.  Use the methods of this file to later load JSON. </li></ul><br><br>  Once you understand this playground, keep reading the article! <br><br><h3>  The primary way to parse JSON in Swift </h3><br>  First, let's start with the native way of parsing JSON in Swift - that is, without using external libraries.  With this, you will appreciate the benefits of using a library like Gloss. <br><br>  <b>Note:</b> <i>If you have already learned the disadvantages of the native JSON parsing method and want to go to Gloss, skip the next paragraph.</i> <br><br>  To give the name to the application # 1 in the App Store, analyze the provided JSON file. <br><br>  Before you start working with dictionaries, set an additional name (alias) at the top of the playground: <br><br>  typealias Payload = [String: AnyObject] <br><br>  Add the getTopAppsDataFromFileWithSuccess callback code as shown below: <br><pre> <code class="objectivec hljs">DataManager.getTopAppsDataFromFileWithSuccess { (data) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> var json: Payload! <span class="hljs-comment"><span class="hljs-comment">// 1 do { json = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions()) as? Payload } catch { print(error) XCPlaygroundPage.currentPage.finishExecution() } // 2 guard let feed = json["feed"] as? Payload, let apps = feed["entry"] as? [AnyObject], let app = apps.first as? Payload else { XCPlaygroundPage.currentPage.finishExecution() } guard let container = app["im:name"] as? Payload, let name = container["label"] as? String else { XCPlaygroundPage.currentPage.finishExecution() } guard let id = app["id"] as? Payload, let link = id["label"] as? String else { XCPlaygroundPage.currentPage.finishExecution() } // 3 let entry = App(name: name, link: link) print(entry) XCPlaygroundPage.currentPage.finishExecution() }</span></span></code> </pre><br><br>  Here is what happens: <br><ol><li>  First you deserialize the data using the NSJSONSerialization. </li><li>  You must check each index value in the JSON object to prevent nil from appearing.  Once a valid value is found, continue to search for the following objects.  Having passed all the indices, you will get the name and link values ‚Äã‚Äãwith which to work.  Note that if at least one JSON element is unexpected, the application name will not be displayed.  It is desirable to handle in this case. </li><li>  The final step is to initialize the <b>App</b> object using the <i>name</i> and <i>link</i> values ‚Äã‚Äãand output them to the console. </li></ol><br>  Save and run the playground;  You will see the following in the debugger console: <br><br><pre> <code class="objectivec hljs">App(name: <span class="hljs-string"><span class="hljs-string">"Game of War - Fire Age"</span></span>, link: <span class="hljs-string"><span class="hljs-string">"https://itunes.apple.com/us/app/game-of-war-fire-age/id667728512?mt=8&amp;uo=2"</span></span>)</code> </pre><br><br>  Yes - ‚ÄúGame of War - Fire Age‚Äù is the application # 1 in the JSON file. <br><br>  It took quite a lot of code to get the name of the first application - it's time to see how <b>Gloss can</b> handle it. <br><br><h3>  Understanding JSON object mapping </h3><br>  Object mapping is a technique for turning objects with JSON into Swift objects.  After defining model objects and mapping rules, Gloss does the hard work of doing the parsing for you. <br><br>  This method is much simpler than the one you used before: <br><ul><li>  Your code will be cleaner, it can be reused and in turn easier to maintain. </li><li>  You work more with objects, not generalized complexes and dictionaries. </li><li>  You can extend the classes of models to add additional features. </li></ul><br>  Sounds good, huh?  Let's see how it works! <br><br><h3>  JSON parsing with Gloss </h3><br>  To make everything look perfect, create a new playground <i>Gloss.playground</i> , then copy the file <i>topapps.json</i> to the <b>Resources</b> folder and the <i>DataManager.swift</i> folder and the <b>Sources</b> folder. <br><br><h4>  The introduction of Gloss in the project </h4><br>  It's pretty easy to embed Gloss into your project: <br><ol><li>  Click this link <a href="">Gloss Repo Zip File</a> and save the library in a suitable place. </li><li>  Unzip it and drag the <i>Gloss-master / Gloss / Gloss</i> folder into the <b>Sources</b> folder of your playground. </li></ol><br><br>  Your Project Navigator should look like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/604/6a9/ba9/6046a9ba96460325e4f6fec895ae2c8b.png" alt="Project Navigator"><br><br>  It's all!  Now <b>Gloss is</b> added to your project and you can start analyzing JSON without a headache! <br><br>  <b>Note:</b> <i>Gloss can also be set via Cocoapods.</i>  <i>Since the playground does not support them yet, this method can only be used when working with projects.</i> <br><br><h3>  JSON conversion to objects </h3><br>  First find out how your object relates to your JSON document. <br><br>  It is necessary that the object conforms to the Decodeable protocol, which can decode them with JSON.  To do this, <b>init init? (Json: JSON)</b> as described in the protocol. <br><br>  Notice the topapps.json structure and create a data model. <br><br>  <b>Topapps</b> <br><br>  The TopApps model is a top-level object that holds one key-value pair. <br><pre> <code class="objectivec hljs">{ <span class="hljs-string"><span class="hljs-string">"feed"</span></span>: { ... } }</code> </pre><br>  Create a new file called TopApps.swift and place it in the <b>Sources</b> folder of your playground;  add the following code: <br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TopApps: Decodable { <span class="hljs-comment"><span class="hljs-comment">// 1 public let feed: Feed? // 2 public init?(json: JSON) { feed = "feed" &lt;~~ json } }</span></span></code> </pre><br><br><ol><li>  Determine the parameters for the model.  In this case, he will be alone.  You'll add a <b>Feed</b> object later. </li><li>  When implementing a custom initializer, ensure that TopApps conforms to the protocol.  You should be surprised what a &lt;~~!  This is the Encode Operator, which is defined in the <i>Gloss'sOperators.swift</i> file.  In principle, this suggests that Gloss moves the values ‚Äã‚Äãthat belong to the feed key and encode them.  Feed is also a Decodable object;  therefore, Gloss will transfer the responsibility for encryption. </li></ol><br>  <b>Feed</b> <br>  The Feed object is very similar to the top level object.  It has two key-value pairs, but since we are only interested in 25 popular applications, there is no need to process the author object. <br><pre> <code class="objectivec hljs">{ <span class="hljs-string"><span class="hljs-string">"author"</span></span>: { ... }, <span class="hljs-string"><span class="hljs-string">"entry"</span></span>: [ ... ] }</code> </pre><br><br>  Create a new file called <i>Feed.swift</i> in the Sources folder of your playground and describe it as follows: <br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Feed: Decodable { public let entries: [App]? public init?(json: JSON) { entries = <span class="hljs-string"><span class="hljs-string">"entry"</span></span> &lt;~~ json } }</code> </pre><br><br>  <b>App</b> <br>  The most recent object to describe is an App object.  The application is presented in the form of such a scheme: <br><pre> <code class="objectivec hljs">{ <span class="hljs-string"><span class="hljs-string">"im:name"</span></span>: { <span class="hljs-string"><span class="hljs-string">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Game of War - Fire Age"</span></span> }, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: { <span class="hljs-string"><span class="hljs-string">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://itunes.apple.com/us/app/game-of-war-fire-age/id667728512?mt=8&amp;uo=2"</span></span>, ... }, ... }</code> </pre><br><br>  Create a new file called <i>App.swift</i> in the <b>Sources</b> folder of your playground and add the following code: <br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> App: Decodable { <span class="hljs-comment"><span class="hljs-comment">// 1 public let name: String public let link: String public init?(json: JSON) { // 2 guard let container: JSON = "im:name" &lt;~~ json, let id: JSON = "id" &lt;~~ json else { return nil } guard let name: String = "label" &lt;~~ container, link: String = "label" &lt;~~ id else { return nil } self.name = name self.link = link } }</span></span></code> </pre><br><br><ol><li>  Both <i>Feed</i> and <i>TopApp</i> used optional properties.  A property can only be defined as non-optional (non-optional) if the used JSON always contains values ‚Äã‚Äãto fill them in. </li><li>  It is not necessary to create an object for each component in JSON.  For example, in this case it makes no sense to create a model for in: name and id.  When working with non-optional and nested objects, do not forget to check <b>nil</b> . </li></ol><br><br>  Now that your classes are ready, you just have to let Gloss do your job! <br>  Open the playground file and add the following code: <br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> import <span class="hljs-built_in"><span class="hljs-built_in">XCPlayground</span></span> <span class="hljs-built_in"><span class="hljs-built_in">XCPlaygroundPage</span></span>.currentPage.needsIndefiniteExecution = <span class="hljs-literal"><span class="hljs-literal">true</span></span> DataManager.getTopAppsDataFromFileWithSuccess { (data) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> var json: [String: AnyObject]! <span class="hljs-comment"><span class="hljs-comment">// 1 do { json = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions()) as? [String: AnyObject] } catch { print(error) XCPlaygroundPage.currentPage.finishExecution() } // 2 guard let topApps = TopApps(json: json) else { print("Error initializing object") XCPlaygroundPage.currentPage.finishExecution() } // 3 guard let firstItem = topApps.feed?.entries?.first else { print("No such item") XCPlaygroundPage.currentPage.finishExecution() } // 4 print(firstItem) XCPlaygroundPage.currentPage.finishExecution() }</span></span></code> </pre><br><br><ol><li>  First deserialize the data using NSJSONSerialization.  We have done this before. </li><li>  Initialize an instance of a TopApps object using JSON data through the constructor. </li><li>  With the first input feed, get app # 1 </li><li>  Display the app object in the console. </li></ol><br><br>  Seriously - this is all the code we need. <br><br>  Save and run your playground;  You have again successfully received the name of the application, but in a more elegant way. <br><pre> <code class="objectivec hljs">App(name: <span class="hljs-string"><span class="hljs-string">"Game of War - Fire Age"</span></span>, link: <span class="hljs-string"><span class="hljs-string">"https://itunes.apple.com/us/app/game-of-war-fire-age/id667728512?mt=8&amp;uo=2"</span></span>)</code> </pre><br><br>  All this relates to the analysis of local data.  But how about parsing data from a remote resource? <br><br><h3>  Getting JSON from the network </h3><br>  It is time to make this project more real.  Usually, you get data from a remote resource, not from local files.  You can easily get ratings from the App Store using a network request. <br><br>  Open <i>DataManager.swift</i> and find the URL for the best applications: <br><pre> <code class="objectivec hljs">let TopAppURL = <span class="hljs-string"><span class="hljs-string">"https://itunes.apple.com/us/rss/topgrossingipadapplications/limit=25/json"</span></span></code> </pre><br>  Then add the following method to the <b>DataManager</b> implementation: <br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func getTopAppsDataFromItunesWithSuccess(success: ((iTunesData: <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>!) -&gt; Void)) { <span class="hljs-comment"><span class="hljs-comment">//1 loadDataFromURL(NSURL(string: TopAppURL)!, completion:{(data, error) -&gt; Void in //2 if let data = data { //3 success(iTunesData: data) } }) }</span></span></code> </pre><br><br>  The code above looks pretty familiar;  but instead of retrieving data from a local file, we used <b>NSURLSession</b> to retrieve data from iTunes.  Here is what exactly happens: <br><br><ol><li>  First, you call the loadDataFromURL method;  it requires a URL and a closure function that passes the NSData object. </li><li>  Using an additional binding, we make sure that the data exists. </li><li>  Ultimately, you betray the data to a successful completion, as you did before. </li></ol><br><br>  Open your playground and replace the following code: <br><pre> <code class="objectivec hljs">DataManager.getTopAppsDataFromFileWithSuccess { (data) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br>  on that <br><pre> <code class="objectivec hljs">DataManager.getTopAppsDataFromItunesWithSuccess { (data) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br><br>  Now you got the real data from iTunes. <br><br>  Save and run your playground;  you will see that the analysis of information still leads to the same final result: <br><br><pre> <code class="objectivec hljs">App(name: <span class="hljs-string"><span class="hljs-string">"Game of War - Fire Age"</span></span>, link: <span class="hljs-string"><span class="hljs-string">"https://itunes.apple.com/us/app/game-of-war-fire-age/id667728512?mt=8&amp;uo=2"</span></span>)</code> </pre><br><br>  The value above may vary, since popular App Store applications are constantly changing. <br><br>  Often, people are not interested only in TOP applications of the App Store - they want to see a list of all TOP applications.  No need to code to get them.  Just add the following code snippet: <br><pre> <code class="objectivec hljs">topApps.feed?.entries</code> </pre><br><br><h3>  Gloss - skeletons in the closet </h3><br>  It's not hard to see that Gloss does the work of parsing wonderfully - but what's behind this?  &lt;~~ is a custom operator (custom operator) for a number of Decoder.decode functions.  Gloss has built-in support for decoding many types: <br><ul><li>  Simple types (Decoder.decode) </li><li>  Decodable Models (Decoder.decodeDecodable) </li><li>  Simple arrays (Decoder.decode) </li><li>  Decodable arrays and models (Decoder.decodeDecodableArray) </li><li>  Enum (Decoder.decodeEnum) </li><li>  Enum Arrays (Decoder.decodeEnumArray) </li><li>  NSURL (Decoder.decodeURL) </li><li>  NSURL arrays (Decode.decodeURLArray) </li></ul><br><br>  <b>Note:</b> <i>If you want to learn more about <b>Custom Operators</b> , look at the article: <a href="http://www.raywenderlich.com/80818/operator-overloading-in-swift-tutorial">Operator Overloading in Swift</a> Tutorial</i> <br><br>  In this article, we looked at decoded models.  If you need something more complicated, expand the Decoder and produce your own decoding implementation. <br><br>  Of course, with the help of Gloss you can also convert objects to JSON.  If you are interested, check the <b>Encodable</b> protocol. <br><br><h3>  What's next? </h3><br>  Here is the <a href="">final playground</a> . <br><br>  You can use the playground as an initial step to create a new application;  just replace the URLs of receiving data remotely with your own URL, manage your own keys and indexes of your new JSON, and you will create a new project that will parse something, such as football results or other data received from the network. <br><br>  The development of Gloss continues <a href="https://github.com/hkellaway/Gloss">here</a> on Github, so stay tuned for the latest updates. <br><br>  Swift is still evolving, so you should follow Apple‚Äôs new documentation for future language updates. <br><br>  I hope you enjoyed this article about working with JSON.  If you have questions or comments, you can discuss them below! </div><p>Source: <a href="https://habr.com/ru/post/276247/">https://habr.com/ru/post/276247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276227/index.html">man! (C => D)</a></li>
<li><a href="../276229/index.html">Greetings from FOSDEM 2016</a></li>
<li><a href="../276235/index.html">How we stopped being afraid of UI tickets</a></li>
<li><a href="../276237/index.html">Analytics Instagram and GAE</a></li>
<li><a href="../276239/index.html">TotalView extends status monitoring for IP PBX 3CX Phone System</a></li>
<li><a href="../276249/index.html">Top free vector icon collections</a></li>
<li><a href="../276251/index.html">Procedurally generated world maps on Unity C #, part 1</a></li>
<li><a href="../276253/index.html">How programming makes it logical to express thoughts</a></li>
<li><a href="../276255/index.html">Visualize concurrency in Go with WebGL</a></li>
<li><a href="../276257/index.html">The "energy" Trojan BlackEnergy is introduced through a vulnerability in Microsoft Office 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>