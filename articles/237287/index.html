<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From sails to kraken, or how I chose a framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear readers of Habr. Everyone has long known that in the node.js universe there is a large number of frameworks for every taste and color. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From sails to kraken, or how I chose a framework</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear readers of Habr.  Everyone has long known that in the node.js universe there is a large number of frameworks for every taste and color.  Each of them satisfies its needs and contains a diverse set of possibilities and its own architecture, and sometimes, to make a choice, you need to look at each of these "animals" under the hood and conduct analytics.  In my case, a framework was needed that already had a choice of its own architecture, between 4 tools: <a href="http://krakenjs.com/">kraken.js</a> , <a href="http://sailsjs.org/">sails.js</a> , <a href="https://www.meteor.com/">meteor.js</a> and <a href="http://derbyjs.com/">derby.js</a> .  To find out how it was, please under the cat. <br><a name="habracut"></a><br><h4>  <b>Derby.js vs.</b>  <b>Meteor.js</b> </h4><br>  These two frameworks have already been <a href="http://habrahabr.ru/post/191664/">compared</a> and I decided to merge them into one section.  I will list only those qualities that seemed decisive for me in refusing these frameworks: <br><ul><li>  Both allow you to perform JavaScript and render templates both on the client and on the server, the only question is how it is determined that the client and the server; </li><li>  Integrate with MongoDB (or Redis in the case of Derby.js), which significantly reduces the scope of their application (if they were independent of data sources, I would probably accept this code organization in the project); </li><li>  Package management system in the case of meteor.js; </li><li>  The lack of documentation in the case of derby.js (you need to go into the code when you need to understand ‚Äúwhere your legs grow from‚Äù); </li></ul><br><br>  Perhaps, I would use some components or other, but on the whole the tools, no matter how praised and PR they were, seemed to me to be very specific and do not uphold the lives of the developers. <br><br><h4>  <b>Kraken.js</b> </h4><br>  Kraken.js is a MVC framework released by PayPal relatively recently, distributed as a npm module, with a primary focus on security and internationalization support in the application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Composition </h5><br>  In addition to the core, the framework includes four more modules: <br><ul><li>  <a href="https://github.com/krakenjs/lusca">Lusca</a> - responsible for security in the application </li><li>  <a href="https://github.com/krakenjs/kappa">Kappa</a> - implements a local proxy server for npm packages </li><li>  <a href="https://github.com/krakenjs/adaro">Adaro</a> - add-on for <a href="http://linkedin.github.io/dustjs/">dust.js</a> template engine <a href="http://linkedin.github.io/dustjs/">that</a> adds various tools </li><li>  <a href="https://github.com/krakenjs/makara">Makara</a> - adds support for internationalization in templates </li></ul><br>  These modules are independent of each other (with the exception of makara, which relies on the functionality of adaro) and can be connected and used in any node.js application. <br><br><h5>  Application structure </h5><br>  By its structure, the application very much resembles the structure of any MVC application, with the storage of files for their functional purpose: <br><br><pre><code class="bash hljs">/config -   /controllers -  /locales - .property-  /lib -       (  ,       npm ) /models -   /public - web-   /public/templates -     /tasks -    grunt-      grunt-config-dir /tests -     index.js -   </code> </pre> <br><br><h5>  Configuration </h5><br>  At a time when node.js has CommonJS modules with which we can implement dynamic application configuration, kraken.js uses two .json files for development and production environments, which significantly limits our capabilities.  But, despite these limitations, because  kraken.js is based on the express.js framework <a href="http://expressjs.com/">that</a> has already gained popularity among web <a href="http://expressjs.com/">developers</a> , its application can be configured using any methods you know directly in the index.js file or using a self-written module configuring the application.  In addition, there is an additional <a href="https://github.com/krakenjs/meddleware">meddleware</a> module that greatly simplifies <a href="http://expressjs.com/4x/api.html">middleware's</a> configuration in your application. <br><br><h5>  Routing </h5><br>  Here we can say that he seems to be there, and at the same time he is not.  All routing is performed manually in the controller file, whose main function is access to the router object, and it looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexModel(); router.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.render(<span class="hljs-string"><span class="hljs-string">'index'</span></span>, model); }); };</code> </pre><br><br>  This of course provides more flexibility in configuration, but you don‚Äôt think that the framework is primarily a tool that is designed to reduce the number of manual actions applied by the programmer (now probably rotten tomatoes will fly into me, but in general this is the way it is).  When your application grows to an acceptable size, managing paths with such routing will not be that pleasant either ... <br><br><h5>  Models </h5><br>  Here, the creators of the framework decided to give the developer complete freedom of choice, the fact is that the models in kraken.js are ordinary JavaScript objects with their own properties.  So, choose any ORM that you like, install it through npm and go ahead! <br><br><h5>  Templates </h5><br>  There is nothing to complain about.  The template engine supports filters, block sections, conditional constructions, in general, provides the developer with all the necessary tools and even allows to compile templates for use on the client. <br><br><h5>  Internationalization </h5><br>  Translation support is only present in templates, which significantly limits our capabilities on the server, because we can not just take and pass a dynamically assembled translation string in a template variable.  In addition, the module performing the translation itself relies on the use of .property files, the organization of which itself does not inspire much confidence in: <br><br><pre> <code class="bash hljs">index.greeting=Hello {name}! index.bye=Bye {name}!</code> </pre><br><br>  Perhaps in the case of simple sentences it still somehow works, but imagine what will happen in the case of complex sentences ... <br><br><h4>  <b>Sails.js</b> </h4><br>  Sails.js was designed and developed by <a href="http://michaelmcneil.com/">Mike McNeil</a> to create scalable real-time applications. <br><br><h5>  Composition </h5><br>  Sails.js consists of a kernel that is built from npm modules created and maintained by other developers, but among them there is one very interesting module - this is the ORM <a href="https://github.com/balderdashy/waterline">waterline</a> , which can perform database migrations in semi-automatic mode, and written specifically for sails , and easily connected to any node.js application.  In addition, the kernel has support for generating code that can be used directly from the <a href="http://sailsjs.org/">command line</a> .  In addition, there is websocket's built-in support that allows you to process a request received through a socket, like a normal request. <br><br><h5>  Application structure </h5><br><br>  The structure is very similar to the MVC application, with more detailed fragmentation in functionality. <br><br><pre> <code class="bash hljs">api/ controllers/ -  models/ -  policies/ -       ... services/ - singleton-     assets/ -        public   config/ -   tasks/ config/ - grunt- register/ -  grunt- ... views/ -  Gruntfile.js -      grunt-    app.js -    .sailsrc -    </code> </pre><br><br>  More information about the purpose of each file can be found in the <a href="http://sailsjs.org/">documentation</a> , which allows you to know its purpose with a single click on the directory or file. <br><br><h5>  Configuration </h5><br>  Sails.js is also based on express.js, but unlike kraken.js, it does not provide the developer with direct access to the application object and the entire configuration is done through .js files, which are CommonJS modules that export objects that are responsible for configuring one of kernel components.  This mechanism allows you to separate the database settings from the HTTP server settings from each other, but it severely limits the ability to configure specific properties of the application, for example, it caused me to change the default path from where the templates will be rendered.  If it comes to middleware, then you can easily connect it by placing it in the middleware section of the config / http.js file. <br><br><h5>  Routing </h5><br>  There is nothing to complain about.  Routing is configured by specifying the desired path in the config / routes.js file in the corresponding section and looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-string"><span class="hljs-string">'get /signup'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'conversion/signup'</span></span> }, <span class="hljs-string"><span class="hljs-string">'post /signup'</span></span>: <span class="hljs-string"><span class="hljs-string">'AuthController.processSignup'</span></span>, <span class="hljs-string"><span class="hljs-string">'get /login'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">view</span></span>: <span class="hljs-string"><span class="hljs-string">'portal/login'</span></span> }, <span class="hljs-string"><span class="hljs-string">'post /login'</span></span>: <span class="hljs-string"><span class="hljs-string">'AuthController.processLogin'</span></span>, <span class="hljs-string"><span class="hljs-string">'/logout'</span></span>: <span class="hljs-string"><span class="hljs-string">'AuthController.logout'</span></span>, <span class="hljs-string"><span class="hljs-string">'get /me'</span></span>: <span class="hljs-string"><span class="hljs-string">'UserController.profile'</span></span> }</code> </pre><br><br>  This mechanism is very convenient, and allows you to configure settings without specifying the HTTP method, perform template mappings without a controller, specify the data to be transferred to the template, access policies that need to be checked before giving the user access to a specific controller method. <br><br><h5>  Models </h5><br>  As mentioned above, sails.js includes a very powerful ORM, which is based on the use of adapters in various data sources that exist for many well-known databases.  The model is represented as a CommonJS module of the model's exporting properties, which will later expand the base class of the Waterline.Collection collection.  The ORM has built-in support for several additional field types that apply specific validators throughout the model‚Äôs life cycle (for more information, see the documentation), as well as the ability to specify for each model a specific database connection that will be used to write and read model data.  In addition to all this, there is built-in support for pagination, sorting, and event handlers. <br><br>  A typical example of a model file: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">connection</span></span>: <span class="hljs-string"><span class="hljs-string">'disk'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } } });</code> </pre><br><br>  When changes are made in the model structure, ORM automatically detects them at startup and if the automatic resolution of conflicts cannot be made, conducts a dialogue with the developer. <br><br><h5>  Templates </h5><br>  Sails.js has the support of most well-known template engines for embedding the use of the <a href="https://github.com/visionmedia/consolidate.js/">consolidate.js</a> library from the author of the express.js framework, which undoubtedly simplifies the use of templates in the application.  Just choose and use! <br><br><h5>  Internationalization </h5><br>  Translation support is present in sails.js throughout the entire life cycle of an application, be it a server code, a template or a .js file, because inside sails.js it uses the <a href="https://github.com/mashpie/i18n-node">i18n</a> library.  The translations themselves are added into .json files, and can be added automatically when trying to translate text that is not already in the file.  On the one hand, automatic filling creates problems for timely translation, but you can always create a grunt task that scans the contents of the necessary files and collects all the text for the translations. <br><br><h4>  <b>So what did you choose?</b> </h4><br>  Summing up, the following classification table was formed in the mind, according to the five-point system. <br><br><table border="1"><tbody><tr><th></th><th>  Confguration </th><th>  Routing </th><th>  Models </th><th>  Templates </th><th>  Internationalization </th></tr><tr><td>  Meteor.js </td><td>  3 </td><td>  five </td><td>  four </td><td>  four </td><td>  2 </td></tr><tr><td>  Derby.js </td><td>  five </td><td>  3 </td><td>  4.5 </td><td>  3 </td><td>  2 </td></tr><tr><td>  Kraken.js </td><td>  five </td><td>  2 </td><td>  five </td><td>  four </td><td>  3 </td></tr><tr><td>  Sails.js </td><td>  four </td><td>  five </td><td>  four </td><td>  five </td><td>  four </td></tr></tbody></table><br><br>  It is not difficult to guess that my choice fell on sails.js, because the structure of the project used by the framework and the possibilities it provides out of the box is closer to me in spirit.  Of course, it has drawbacks regarding configuration and internationalization, but these are the drawbacks with which in my case, you can accept or implement, if you think in accordance with the framework concept.  By this article, by no means do I incline you in the direction of this or that instrument, choose for yourself what is close to you in spirit, and may the force be with you! </div><p>Source: <a href="https://habr.com/ru/post/237287/">https://habr.com/ru/post/237287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237275/index.html">When do you need to plant trees of alternative energy?</a></li>
<li><a href="../237277/index.html">My teaching experience</a></li>
<li><a href="../237279/index.html">Bold AngularJS for team development [2/2]</a></li>
<li><a href="../237283/index.html">Platform for testing mobile applications Ubertesters: implementation experience</a></li>
<li><a href="../237285/index.html">Performance metrics for vertical search results based on a click model</a></li>
<li><a href="../237289/index.html">Security fixes iOS 8</a></li>
<li><a href="../237293/index.html">As I went to rest, but expanded my business. Turkey</a></li>
<li><a href="../237295/index.html">Virtualization‚Å∞</a></li>
<li><a href="../237297/index.html">Emoji lisp</a></li>
<li><a href="../237301/index.html">Brain Target- a program for objectifying the evaluation of the results of neurosurgical treatment of brain tumors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>