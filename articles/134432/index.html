<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In search of the fat (The Quest For FAT)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing a certain software and hardware complex, it was necessary to create a client device, which for other devices should look like a regula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In search of the fat (The Quest For FAT)</h1><div class="post__text post__text-html js-mediator-article">  When developing a certain software and hardware complex, it was necessary to create a client device, which for other devices should look like a regular USB flash drive, or if more formally, then a USB Mass Storage Device.  The device‚Äôs unusualness is that it must imitate for the outside world the FAT file system with files of sufficiently large size (2GB and more), while the files themselves on the device are, of course, absent and are on the network.  And in general these are not files, but some audio streams. <br><br>  The task, at first glance, is simple: for every request to read a block (a SCSI command), we return the contents of this block.  The block may either belong to any of the ‚Äúfiles‚Äù or contain the FAT service information. <br><a name="habracut"></a><br>  The first thought was, of course, to pack the FAT image using, for example, bzip2 and unpack it on the device as needed.  There are three problems at once: <br><br><ul><li>  A compressed file system image of the heel of 100-megabyte files and several directories takes up something around 125Kb, which exceeds the amount of RAM on the device. <br></li><li>  Bzip2, apparently, does not know anything about the sectors and works at the level of flows, therefore, it will have to be packed sector-by-sector, hence the image size will be quite outrageous: as you know, packing in small blocks is unprofitable - the overhead is large compared to the compression gain. <br></li><li>  Preparing an image (mounting an empty file, creating a file system, packing) takes a lot of time and is hardly acceptable for implementation on a server with thousands of users.  And the image itself in the process of creation requires some rather noticeable disk space. <br></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, this is not to mention generally that you have to port bzip2 to the microcontroller. <br><br>  Thus, it was necessary to invent something else. <br><br>  The task can be put as follows: it is necessary to write a code that will take some kind of file system description as an input, and return its contents to each request for a sector number.  The content is either service information or file data, which is taken from the corresponding audio stream at a given URL. <br><br>  This formulation of the question leads us to the system of rules: <br><br> <code><br>   =&gt;   <br></code> <br><br>  Note that we are talking about sectors, not ‚Äúclusters‚Äù, since a cluster is a concept of the FAT file system itself.  The devices operate at the block level, they are sectors.  Suppose our ‚Äúplaylist‚Äù contains 10 ‚Äúfiles‚Äù of 2Gb each (2Gb is a practical approach to infinity).  If each rule has a size of one byte, which, of course, is impossible, then we succeed. <br><br> <code>2*1024*1024*1024 * 10 / 512 = 41 943 040 <br></code> <br><br>  bytes to all the rules.  Somewhat more sensible.  But, of course, the rules are not unique to each sector.  We will set the rules for the ranges of sectors.  This leads us to a set of rules: <br><br> <code>  (A) =&gt;   <br>   (A,B) =&gt;   <br></code> <br><br>  Let's try to pack also the sectors themselves.  Since data compression tasks are not in front of us - the data itself is missing in the device and taken from the Web, then you just need to somehow more or less compactly present the service data of the file system itself.  At first glance, there are many duplicate sequences in this data, so we will encode as follows: repeat sequences are presented as <br><br> <code>( RLE, , ) <br></code> <br><br>  The non-repeating sequences will be represented as <br><br> <code>( Sequence,  ) <br></code> <br><br>  In addition, those sequences that we have already encoded, or parts of them would be good not to re-insert, but to refer to them.  We probably have another sequence. <br><br> <code>( , ) <br></code> <br><br>  Perhaps in the implementation process, other sequences may appear for a more compact representation of the file system structures. <br><br>  All this is very similar to the command system of a virtual machine, and since there are challenges, that is, the stack.  The simplest known virtual machine is one of the varieties of the fort.  In fact, this is the reverse. <br>  Polish entry on steroids, with the added stack of return addresses from calls, which eliminates the need to tinker with the organization of frame functions: everything is extremely simple - when returning from a call, we remove <br>  the upper word from the stack R and go to the address to which it points. <br><br>  In addition, the token threaded code (and this will be it) for the two-stack machine has a very good density, which, in this case, is very convenient for us. <br><br>  Interpreting such a code quickly, it turns out only an average of five times slower than the native code, and also very simple. <br><br>  So, we have some kind of coding system, rule system and some virtual machine on which these rules should be played. <br><br>  It remains to generate these rules from some description, get bytecode and implement the machine for its interpretation.  And only then we will see what happened. <br><br>  With the implementation of a virtual machine, the situation is simple: it will work on a microcontroller, respectively, so far there are no C options here.  True, it is possible that there is nothing to write there - it will turn out to be generated by some <br>  in a way. <br><br>  It remains the generation of the system of rules from the description, the description itself, the generation of the code and the description of the commands of this code.  In addition, it would be good to check the rules not consistently, but somehow more rationally: organize checks in the form of <br>  tree comparisons, so that the number of comparisons for each sector was of the order of the binary logarithm of the number of comparisons. <br><br>  We finished with the primary analysis, we should make a prototype and see what we can do. <br><br>  We will need to generate and, possibly, read binary data of various dimensions and finiteness (FAT service data is written in low-endian format) and work with nested data structures. <br><br>  What would it do?  C, C ++ or maybe Python?  Or Ruby?  Joke. <br>  Of course, we will do on Haskell: the task is not the easiest, some kind of performance is required, and we do not have much time.  Well, anyway, the server that will call this code is also implemented on <br>  Haskell, so the choice is quite natural. <br><br>  Let's get started <br><br>  The central thing in the system is the ‚Äúrules‚Äù.  The file system description is converted into them, code is generated from them.  We describe them: <br><br> <code>data Rule = REQ Int [Chunk] | RANGE Int Int [Chunk] deriving Show <br> data Chunk = SEQ BS.ByteString <br> | RLE Int Word8 <br> deriving (Eq, Ord) <br></code> <br><br>  In addition, there is a description of the file system itself, which consists of directories and files, with some specific features of the FAT itself. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirRoot</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class">] | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirDot</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirDotDot</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dir</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class">] | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">File</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BS</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Data</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) </span></span><br></code> </pre> <code>data Entry = DirRoot Int [Entry] | DirDot Int | DirDotDot Int | Dir Int String [Entry] | File Int String Int BS.ByteString deriving (Eq, Ord, Data, Typeable, Show) <br></code> <br><br>  Here we will stop in more detail.  The strange constructors DirDor and DirDotDot are nothing more than directories '.'  and '..', which are a surprise - are first-class, physically present directory entries.  Fortunately they <br>  they are only links and do not require cluster allocation. <br><br>  Everything else is pretty obvious: the first attribute of type constructors is a unique identifier.  He obviously can be useful to us in order to understand the firmware from which "file" the data was requested. <br><br>  The second attribute is the file name.  In the case of a file, add the same size and data.  This, of course, is not the data of the file itself, but some indication of the device firmware, where this data is taken from.  There you can write, for example, sishnuyu structure or URL stream.  Therefore ByteString. <br><br>  Now we need to somehow construct the Entry, taking into account the requirements of the file system: each directory, except the root directory, must contain the entries '.'  and '..', they must refer to their respective directories; there should be no <br>  identical record names, titles should not contain prohibited characters, and so on and so forth.  It can be seen that it is hard to create this structure manually, besides, the user of the API must do this, and he will surely confuse something and everything will break, but the matter is serious.  So it‚Äôs better to ban the import of Entry type content from our module, and provide the user with some more convenient and error-proof solution.  Something like: <br><br><pre> <code class="hljs sql">fileContents = ... fatSample2 = filesystem $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file0"</span></span> (<span class="hljs-number"><span class="hljs-number">16384</span></span>) fileContents dir <span class="hljs-string"><span class="hljs-string">"A"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file1"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) fileContents dir <span class="hljs-string"><span class="hljs-string">"C"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file3"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) fileContents <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file4"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) fileContents <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file5"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) fileContents dir <span class="hljs-string"><span class="hljs-string">"E"</span></span> $ emptyDir dir <span class="hljs-string"><span class="hljs-string">"B"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file2"</span></span> (megs <span class="hljs-number"><span class="hljs-number">50</span></span>) emptyFile <br></code> </pre> <code>fileContents = ... fatSample2 = filesystem $ do file "file0" (16384) fileContents dir "A" $ do file "file1" (megs 100) fileContents dir "C" $ do file "file3" (megs 100) fileContents file "file4" (megs 100) fileContents file "file5" (megs 100) fileContents dir "E" $ emptyDir dir "B" $ do file "file2" (megs 50) emptyFile <br></code> <br><br>  It looks good, even those who do not know the language can understand what is being described here. <br>  It is easy to implement: to generate something horrible, there is already a ready-made Writer monad. <br><br>  In addition, we will need to distribute unique identifiers, so State is also useful, where we will put some kind of counter.  Since we want to cross the State and Writer, we will not interfere with the monad transformer.  Something like this: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdT</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runF</span></span></span><span class="hljs-class"> :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriterT</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class">] (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">)) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadWriter</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class">], </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadState</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Identity</span></span></span><span class="hljs-class"> runEntryIdM :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> a -&gt; ([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class">], (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">)) runEntryIdM init f = runState (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execWriterT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) init filesystem :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> () -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class"> filesystem f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirRoot</span></span></span><span class="hljs-class"> 0 dirs where dirs = fst $ runEntryIdM (1,0) f dir :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> () -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> () file :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryInfo</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BS</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ByteString</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EntryIdM</span></span></span><span class="hljs-class"> () </span></span><br></code> </pre> <code>newtype EntryIdT ma = EntryIdT { runF :: (WriterT [Entry] (StateT (Int, Int) m)) a } deriving (Monad, MonadWriter [Entry], MonadState (Int, Int)) type EntryIdM = EntryIdT Identity runEntryIdM :: (Int, Int) -&gt; EntryIdM a -&gt; ([Entry], (Int, Int)) runEntryIdM init f = runState (execWriterT (runF f)) init filesystem :: EntryIdM () -&gt; Entry filesystem f = DirRoot 0 dirs where dirs = fst $ runEntryIdM (1,0) f dir :: String -&gt; EntryIdM () -&gt; EntryIdM () file :: String -&gt; Int -&gt; (EntryInfo -&gt; BS.ByteString) -&gt; EntryIdM () <br></code> <br><br>  Each function accepts parameters like name, size and another monadic value for constructing nested records.  Each such calculation will be launched in a separate Writer, and State will be pulled through a common one to guarantee the uniqueness of identifiers. <br><br>  So, the directory structure was set, now we need to get some rules out of it. <br><br>  To do this, you need to somehow place the data files and directories on the "disk". <br>  We assume that they are placed sequentially, first the directories, then the files: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AllocEntry</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AllocEntry</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beginSect</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">endSect</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) allocate :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ClustSize32</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Entry</span></span></span><span class="hljs-class"> -&gt; [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AllocEntry</span></span></span><span class="hljs-class">] allocate cl from = eFix . eAlloc . eOrder . filter eFilt . universe where eFilt (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">File</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class"> eFilt (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dir</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class"> eFilt (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirRoot</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class"> eFilt _ = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span><span class="hljs-class"> eOrder = uncurry (++) . partition (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isFile</span></span></span><span class="hljs-class">) eAlloc = reverse . snd . foldl fentry (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, []) fentry (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) e = let sectors = entryLen cl e `div` fatSectLen begin = n end = begin + sectors - 1 n' = n + sectors allocated = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AllocEntry</span></span></span><span class="hljs-class"> begin end e in (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n'</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">allocated</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) eFix = id </span></span><br></code> </pre> <code>data AllocEntry = AllocEntry { beginSect :: Int , endSect :: Int , entry :: Entry } deriving (Show) allocate :: ClustSize32 -&gt; Int -&gt; Entry -&gt; [AllocEntry] allocate cl from = eFix . eAlloc . eOrder . filter eFilt . universe where eFilt (File _ _ _ _) = True eFilt (Dir _ _ _) = True eFilt (DirRoot _ _) = True eFilt _ = False eOrder = uncurry (++) . partition (not.isFile) eAlloc = reverse . snd . foldl fentry (from, []) fentry (n, xs) e = let sectors = entryLen cl e `div` fatSectLen begin = n end = begin + sectors - 1 n' = n + sectors allocated = AllocEntry begin end e in (n', allocated : xs) eFix = id <br></code> <br><br>  The code as a whole is fairly obvious: take all the entries, remove the '.'  and '..' which do not have their own clusters, but only point to others, do so that the directories go first, then the files (there is no difference, but it is more logical, <br>  and even the table of contents of the volume will be read faster), we select sectors (it‚Äôs more convenient for us to work with sectors, ‚Äúclusters‚Äù is an artificial concept) and that‚Äôs all. <br><br>  It is worth noting the function of the universe module uniplate.  It allows you to list all the elements of a nested structure as a list (optionally with a list comprehension), in order to avoid the routine writing of recursive walk functions. <br><br>  For her sake, we declared the type Entry deriving (Data, Typeable) above. <br><br>  Having the files placed by sectors, we already have nothing to generate rules for them: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">generateData</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">CalendarTime</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ClustSize32</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">AllocEntry</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Rule</span></span>] generateData ct cl es = mergeRules $ execWriter $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> forM_ es $ \(<span class="hljs-type"><span class="hljs-type">AllocEntry</span></span> {beginSect = a, endSect = b, entry = e}) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">DirRoot</span></span> _ es -&gt; writeEntries ab es <span class="hljs-type"><span class="hljs-type">Dir</span></span> _ _ es -&gt; writeEntries ab es <span class="hljs-type"><span class="hljs-type">File</span></span> _ _ _ bs -&gt; tell [<span class="hljs-type"><span class="hljs-type">RANGE</span></span> ab (encodeBlock (<span class="hljs-type"><span class="hljs-type">BS</span></span>.take (fatSectLen) bs))] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ... <br></code> </pre> <code>generateData :: Maybe CalendarTime -&gt; ClustSize32 -&gt; [AllocEntry] -&gt; [Rule] generateData ct cl es = mergeRules $ execWriter $ do forM_ es $ \(AllocEntry {beginSect = a, endSect = b, entry = e}) -&gt; do case e of DirRoot _ es -&gt; writeEntries ab es Dir _ _ es -&gt; writeEntries ab es File _ _ _ bs -&gt; tell [RANGE ab (encodeBlock (BS.take (fatSectLen) bs))] where ... <br></code> <br><br>  The encodeBlock function here is able to encode a ByteString into a sequence of rules, writeEntries generates directory entries and encodes them, and mergeRule attempts to merge sector ranges of successive rules. <br><br>  Generating a single directory entry looks like this: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">entryRecordShort</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">CalendarTime</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">ATTR</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">BS</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> entryRecordShort nm size clust clk a = runPut $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putNameASCII nm <span class="hljs-comment"><span class="hljs-comment">-- Name putWord8 (fatAttrB a) -- Attr putWord8 0 -- NTRes putWord8 0 -- CrtTimeTenth putWord16le cT -- CrtTime putWord16le cD -- CrtDate putWord16le cD -- LstAccDate putWord16le cHi -- FstClusHI putWord16le cT -- WrtTime putWord16le cD -- WrdDate putWord16le cLo -- FstClusLO putWord32le (fromIntegral size) -- FileSize where ... </span></span><br></code> </pre> <code>entryRecordShort :: String -&gt; Int -&gt; Int -&gt; Maybe CalendarTime -&gt; [ATTR] -&gt; BS.ByteString entryRecordShort nm size clust clk a = runPut $ do putNameASCII nm -- Name putWord8 (fatAttrB a) -- Attr putWord8 0 -- NTRes putWord8 0 -- CrtTimeTenth putWord16le cT -- CrtTime putWord16le cD -- CrtDate putWord16le cD -- LstAccDate putWord16le cHi -- FstClusHI putWord16le cT -- WrtTime putWord16le cD -- WrdDate putWord16le cLo -- FstClusLO putWord32le (fromIntegral size) -- FileSize where ... <br></code> <br><br>  It uses the extremely useful PutM monad from Data.Binary.Put, which allows you to output data of any capacity and finish to a lazy byte string. <br><br>  So, we have the directory structure of the FAT volume, we have their placement by sector and the corresponding rules.  What is left for us? <br><br>  Here you need to step aside a bit and remember the device FAT.  If you do not go into the extra details, widely available on the web and literature, then FAT32 is designed as follows: <br><br><pre>     | BootSect | FAT32 Info | FAT1 | FAT2 | DATA |
</pre><br><br>  So far we only have rules for DATA.  FAT1 and FAT2 are cluster allocation tables.  Each file or directory (which is also a file) occupies a chain of clusters in a data region, and each cluster of a data region is represented by a 32-bit value in FAT1 and FAT2 (they are identical). <br><br>  The number of the next file cluster is recorded in each FAT cell, the last cluster is marked with a special value.  The number of the first file cluster is indicated in the directory entry.  Our data is placed sequentially, so that each cell of the chain will contain the number N + 1, where N is the previous value. <br><br>  Here, the first problem arises: for our calculated 10 x 20Gb, this table will occupy as many as 655360 32-bit values, which again exceeds the available RAM.  However, these rules cannot be compressed. <br>  our primitive packaging algorithm RLE, since there are no duplicate values.  However, since we were able to generate this sequence once, then we can probably generate it again on the device. <br><br>  A close look at it showed that the values ‚Äã‚Äãin one sector of the allocation table depend on the maximum value in the previous one, and in general the sequence is determined by the expression: <br><br><pre>     Na = BASE + (Nsect - M) * STEP
     Ni &lt;- [Na, Na + 1 ..]
</pre><br><br>  where Na is the first value for this sector, Nsect is the number of the requested sector (will be at the top of the stack of our fort machine), M, BASE and STEP are constants calculated statically, Ni is the i-th number of the sequence, and only in the sector, obviously 512/4. <br><br>  So we got a new sequence that generates a series of values ‚Äã‚Äãbased on dynamic data (sector number).  Add types for this sequence and contiguous ones: <br><br><pre> <code class="hljs pgsql">data Chunk = SEQ BS.ByteString | RLE <span class="hljs-type"><span class="hljs-type">Int</span></span> Word8 | SER Word32 Word32 | NSER Word32 <span class="hljs-type"><span class="hljs-type">Int</span></span> Word32 <span class="hljs-comment"><span class="hljs-comment">-- base offset step | CALLBACK Word8 deriving (Eq, Ord) </span></span><br></code> </pre> <code>data Chunk = SEQ BS.ByteString | RLE Int Word8 | SER Word32 Word32 | NSER Word32 Int Word32 -- base offset step | CALLBACK Word8 deriving (Eq, Ord) <br></code> <br><br>  Looking ahead, we will add another rule for callback, which should be called after generating the file data sector, so that the device firmware would take the buffer and fill it with real data. <br><br>  It would have been possible to immediately generate the table as a set of rules, but for some reason I needed it in binary form, besides, there is already a debugged function for encoding binary strings, and in direct generation it is easy <br>  make mistakes. <br><br>  This table is quite large, and in the case of a large data area and a small cluster size, poor Haskell is tight. <br><br>  At some point, the application became very bad from a large lazy Word32 list, so I had to quickly rewrite to lazy byte strings and use runPut / runGet to put 32-bit values ‚Äã‚Äãthere and extract them from there. <br><br>  Surprisingly, this led to an acceleration of about ten times and everything began to work at an acceptable speed, although, of course, you should rewrite it in such a way that it would immediately generate rules and not create data. <br>  But for the concept goes well. <br><br>  The functions of generating the table and the rules for it are omitted; they are rather large, but quite obvious: <br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClusterTable</span></span></span></span> = BS.ByteString genFAT :: ClustSize32 -&gt; Int -&gt; [AllocEntry] -&gt; ClusterTable encodeFAT :: Int -&gt; ClusterTable -&gt; [Rule] <br></code> </pre> <code>type ClusterTable = BS.ByteString genFAT :: ClustSize32 -&gt; Int -&gt; [AllocEntry] -&gt; ClusterTable encodeFAT :: Int -&gt; ClusterTable -&gt; [Rule] <br></code> <br><br>  The coding function of the table first assigns one sector REQ a (NSER _ _ _) to each sector, then considers the sectors in pairs, and if two sectors form a common sequence of values, the rule for the sector is replaced by the rule for a range of sectors, the result is quite compact for so you can bring it here: <br><br><pre> REQ 32 [SEQ [F8], RLE 2 255, SEQ [0F], RLE 3 255, SEQ [0F],
         RLE 3 255, SEQ [0F], RLE 3 255, SEQ [0F], RLE 3 255,
         SEQ [0F], RLE 3 255, SEQ [0F], RLE 3 255, SEQ [0F],
         SEQ [08], RLE 3 0, SEQ [09], RLE 3 0, SEQ [0A],
         RLE 3 0, RLE 3 255, SEQ [0F], SER 12 128]
 RANGE 33,231 [NSER 129 33,128]
 REQ 232 [SER 25601 25610, RLE 3 255, SEQ [0F], SER 25612 25728]
 RANGE 233 431 [NSER 25729 233 128]
 REQ 432 [SER 51201 51210, RLE 3 255, SEQ [0F], SER 51212 51328]
 RANGE 433 631 [NSER 51329 433 128]
 REQ 632 [SER 76801 76810, RLE 3 255, SEQ [0F], SER 76812 76928]
 RANGE 633 831 [NSER 76929 633 128]
 REQ 832 [SER 102401 102410, RLE 3 255, SEQ [0F], SER 102412 102528]
 RANGE 833 931 [NSER 102529 833 128]
 REQ 932 [SER 115201 115210, RLE 3 255, SEQ [0F], RLE 468 0]
 RANGE 933 1056 [RLE 512 0]
</pre><br><br>  It looks promising, clearly better than a two megabyte piece of data. <br>  The second copy of the table coincides up to constants, so that in the long run you can replace this sequence by subtracting the constant from the offset and calling the first table.  But this later. <br><br>  So, we have FAT1, FAT2 and DATA.  It remains to get only BootSect and FAT32 Info.  This is static binary data, so again we use Data.Binary.Put, and then we pack into the rules. <br><br>  These two modules (Put and Get) are literally irreplaceable and I personally quote them higher than the binary patterns in Erlang, although this is subjective. <br><br><pre> <code class="hljs pgsql">fatGenBoot32 :: FAT32GenInfo -&gt; BS.ByteString fatGenBoot32 <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> = addRsvd $ runPut $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">-- BOOT AREA sect0 putBytes [0xEB, 0x58, 0x90] -- 0 JmpBoot putBytes bsOEMName -- OEMName putWord16le bps -- BytesPerSec putWord8 spc -- SectPerClust putWord16le rsvd -- ReservedSecCnt putWord8 2 -- NumFATs putWord16le 0 -- RootEntCnt putWord16le 0 -- TotSec16 putWord8 0xF8 -- Media putWord16le 0 -- FAT16Sz putWord16le 0x3F -- SectPerTract putWord16le 0xFF -- NumHeads putWord32le 0 -- HiddSec putWord32le sectNum -- TotSec32 -- FAT32 Structure putWord32le fsect -- FATSz32 -- ... --    </span></span><br></code> </pre> <code>fatGenBoot32 :: FAT32GenInfo -&gt; BS.ByteString fatGenBoot32 info = addRsvd $ runPut $ do -- BOOT AREA sect0 putBytes [0xEB, 0x58, 0x90] -- 0 JmpBoot putBytes bsOEMName -- OEMName putWord16le bps -- BytesPerSec putWord8 spc -- SectPerClust putWord16le rsvd -- ReservedSecCnt putWord8 2 -- NumFATs putWord16le 0 -- RootEntCnt putWord16le 0 -- TotSec16 putWord8 0xF8 -- Media putWord16le 0 -- FAT16Sz putWord16le 0x3F -- SectPerTract putWord16le 0xFF -- NumHeads putWord32le 0 -- HiddSec putWord32le sectNum -- TotSec32 -- FAT32 Structure putWord32le fsect -- FATSz32 -- ... --    <br></code> <br><br>  We let our packer on the result, merge the rules into ranges, and get the final list of rules describing our entire file system. <br><br>  So, we have a set of rules.  It remains to generate for them a tree of comparisons and <br>  compile it all into bytecode. <br><br>  Let's start with the tree: <br><br><pre> <code class="hljs pgsql">data CmpTree = GEQ <span class="hljs-type"><span class="hljs-type">Int</span></span> CmpTree CmpTree | CODE [<span class="hljs-keyword"><span class="hljs-keyword">Rule</span></span>] deriving (<span class="hljs-keyword"><span class="hljs-keyword">Show</span></span>) mkCmpTree :: [<span class="hljs-keyword"><span class="hljs-keyword">Rule</span></span>] -&gt; CmpTree mkCmpTree r = mkTre<span class="hljs-string"><span class="hljs-string">e' rulemap where rulemap = M.fromList $ map (\x -&gt; (fsect x, x)) r splitGeq nm = let (a, b, c) = M.splitLookup nm in (a, c `M.union` (maybe M.empty (M.singleton n) b)) mkTree'</span></span> xs | M.<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> xs = CODE [] | M.size xs &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> = CODE (map snd (M.toList xs)) | otherwise = let ks = map fst $ M.toAscList xs n = ks !! (length ks `div` <span class="hljs-number"><span class="hljs-number">2</span></span>) (le, geq) = splitGeq n xs <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> GEQ n (mkTre<span class="hljs-string"><span class="hljs-string">e' le) (mkTree'</span></span> geq) <br></code> </pre> <code>data CmpTree = GEQ Int CmpTree CmpTree | CODE [Rule] deriving (Show) mkCmpTree :: [Rule] -&gt; CmpTree mkCmpTree r = mkTree' rulemap where rulemap = M.fromList $ map (\x -&gt; (fsect x, x)) r splitGeq nm = let (a, b, c) = M.splitLookup nm in (a, c `M.union` (maybe M.empty (M.singleton n) b)) mkTree' xs | M.null xs = CODE [] | M.size xs &lt; 3 = CODE (map snd (M.toList xs)) | otherwise = let ks = map fst $ M.toAscList xs n = ks !! (length ks `div` 2) (le, geq) = splitGeq n xs in GEQ n (mkTree' le) (mkTree' geq) <br></code> <br><br>  Maybe not the best option, but the rules turned out less than a hundred, you can not worry yet. <br><br>  The case for the virtual machine, a set of commands and a compiler: <br><br><pre> <code class="hljs haskell">-  ,     -     <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">OpcodeCL</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> isRLE :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> arity0 :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> arity1 :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> arity2 :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> arity3 :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> firstCode :: a lastCode :: a <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DUP</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DROP</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CONST</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CRNG</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JNZ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JZ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JGQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JNE</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JMP</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CALLT</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CALL</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RET</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOT</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NEQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GT</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LE</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RNG</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS2</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS3</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS4</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS5</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS6</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS7</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS8</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS9</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADS10</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADSN</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SER</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NSER</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NSER128</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE1</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE2</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE3</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE4</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE5</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE6</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE7</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE8</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE16</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE32</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE64</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE128</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE256</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLE512</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RLEN</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OUTLE</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OUTBE</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OUTB</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOP</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CALLN</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DEBUG</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EXIT</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Enum</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W32</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W16</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word16</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W8</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word8</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ADDR</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALabel</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Label</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AOffset</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd0</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdConst</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd1</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd2</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd3</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdArg</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdJmp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdCondJmp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opcode</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CmdLabel</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Label</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RawByte</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word8</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Label</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Label</span></span></span><span class="hljs-class">, [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cmd</span></span></span><span class="hljs-class">]) </span></span><br></code> </pre> <code>-  ,     -     class OpcodeCL a where isRLE :: a -&gt; Bool arity0 :: a -&gt; Bool arity1 :: a -&gt; Bool arity2 :: a -&gt; Bool arity3 :: a -&gt; Bool firstCode :: a lastCode :: a data Opcode = DUP | DROP | CONST | CRNG | JNZ | JZ | JGQ | JNE | JMP | CALLT | CALL | RET | NOT | EQ | NEQ | GT | LE | GQ | LQ | RNG | LOADS2 | LOADS3 | LOADS4 | LOADS5 | LOADS6 | LOADS7 | LOADS8 | LOADS9 | LOADS10 | LOADSN | SER | NSER | NSER128 | RLE1 | RLE2 | RLE3 | RLE4 | RLE5 | RLE6 | RLE7 | RLE8 | RLE16 | RLE32 | RLE64 | RLE128 | RLE256 | RLE512 | RLEN | OUTLE | OUTBE | OUTB | NOP | CALLN | DEBUG | EXIT deriving (Eq, Ord, Enum, Show) data CmdArg = W32 Word32 | W16 Word16 | W8 Word8 | ADDR Addr data Addr = ALabel Label | AOffset Int data Cmd = Cmd0 Opcode | CmdConst Word32 | Cmd1 Opcode CmdArg | Cmd2 Opcode CmdArg CmdArg | Cmd3 Opcode CmdArg CmdArg CmdArg | CmdJmp Opcode Addr | CmdCondJmp Opcode Addr | CmdLabel Label | RawByte Word8 type Label = Int type Block = (Label, [Cmd]) <br></code> <br><br>  Alas, here a simple type system of Haskell begins to be missed: I want to set compile time invariants for commands and their classes, so that, for example, you cannot create a command with the wrong opcode.  But you can‚Äôt just do it, but you don‚Äôt want to introduce a separate type for each opcode, an existential data type for the team and still use metaprogramming to generate opcodes. <br><br>  Postpone until better times, let's do what we have.  Anyway, in order to implement a virtual machine, you will have to write tests, so the errors planted will pop up there. <br><br>  So, the virtual machine command system is there, now we need to compile into it a tree of comparisons built from our rules: <br><br><pre> <code class="hljs dos">mkVMCode :: CmpTree -&gt; [Block] mkVMCode xs = normalize maxl code -- skip scanT :: CmpTree -&gt; GenM () scanT (<span class="hljs-keyword"><span class="hljs-keyword">GEQ</span></span> n left right) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> s &lt;- newLabel l &lt;- runGen' (scanT left) &gt;&gt;= withLabel r &lt;- runGen' (scanT right) &gt;&gt;= withLabel _ex &lt;- newLabel <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> s dup cnst n jgq (labelOf r) block l &gt;&gt; jmp _ex block r &gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> _ex scanT (CODE []) = op0 <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> scanT (CODE rules) = mapM_ scanR rules scanR :: Rule -&gt; GenM () scanR ( REQ n code ) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> s &lt;- newLabel code' &lt;- runGen' (scanmC code) &gt;&gt;= withLabel ex &lt;- newLabel <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> s dup cnst n jne ex block code' <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> ex scanR ( RANGE ab code ) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> s &lt;- newLabel code' &lt;- runGen' (scanmC code) &gt;&gt;= withLabel ex &lt;- newLabel <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> s dup crng ab jz ex block code' <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> ex -- skip <br></code> </pre> <code>mkVMCode :: CmpTree -&gt; [Block] mkVMCode xs = normalize maxl code -- skip scanT :: CmpTree -&gt; GenM () scanT (GEQ n left right) = do s &lt;- newLabel l &lt;- runGen' (scanT left) &gt;&gt;= withLabel r &lt;- runGen' (scanT right) &gt;&gt;= withLabel _ex &lt;- newLabel label s dup cnst n jgq (labelOf r) block l &gt;&gt; jmp _ex block r &gt;&gt; label _ex scanT (CODE []) = op0 EXIT scanT (CODE rules) = mapM_ scanR rules scanR :: Rule -&gt; GenM () scanR ( REQ n code ) = do s &lt;- newLabel code' &lt;- runGen' (scanmC code) &gt;&gt;= withLabel ex &lt;- newLabel label s dup cnst n jne ex block code' label ex scanR ( RANGE ab code ) = do s &lt;- newLabel code' &lt;- runGen' (scanmC code) &gt;&gt;= withLabel ex &lt;- newLabel label s dup crng ab jz ex block code' label ex -- skip <br></code> <br><br>  This is the favorite way to generate all sorts of things using eDSL, built on top of the Writer monad. <br><br>  The generation of a flat code from the comparison tree leads to a set of "snot", for example, to long chains of exit from the blocks: <br><br><pre> <code class="hljs vbscript">L1: ... JMP L2 L2: JMP L3 L3: JMP L4 L4: <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> <br></code> </pre> <code>L1: ... JMP L2 L2: JMP L3 L3: JMP L4 L4: EXIT <br></code> <br><br>  jumping into the next blocks and so on.  normalize eliminates these outrages, and breaks the code into blocks, each of which begins with a label and ends with an unconditional command to go to the next block.  There are no conditional or unconditional jump commands inside the block, they are valid only at the end.  We need such blocks to calculate the label offset.  After it, you can merge the blocks, getting rid of unnecessary transitions completely. <br><br>  Let's write the Show instance for our baytkod for a beautiful print of the fort and see what we get after optimizing the blocks: <br><br><pre> <code class="hljs vbscript">... L215: DUP <span class="hljs-keyword"><span class="hljs-keyword">CONST</span></span> <span class="hljs-number"><span class="hljs-number">2122</span></span> JGQ L220 DUP CRNG <span class="hljs-number"><span class="hljs-number">00000843</span></span> <span class="hljs-number"><span class="hljs-number">00000849</span></span> JZ L235 RLE512 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> L220: DUP CRNG <span class="hljs-number"><span class="hljs-number">0000084</span></span>A <span class="hljs-number"><span class="hljs-number">000</span></span>C8869 JZ L223 LOADS2 BYTE <span class="hljs-number"><span class="hljs-number">48</span></span> BYTE <span class="hljs-number"><span class="hljs-number">45</span></span> RLE2 <span class="hljs-number"><span class="hljs-number">4</span></span>C LOADS7 BYTE <span class="hljs-number"><span class="hljs-number">4</span></span>F BYTE <span class="hljs-number"><span class="hljs-number">20</span></span> BYTE <span class="hljs-number"><span class="hljs-number">57</span></span> BYTE <span class="hljs-number"><span class="hljs-number">4</span></span>F BYTE <span class="hljs-number"><span class="hljs-number">52</span></span> BYTE <span class="hljs-number"><span class="hljs-number">4</span></span>C BYTE <span class="hljs-number"><span class="hljs-number">44</span></span> RLE2 <span class="hljs-number"><span class="hljs-number">21</span></span> CALLN <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> L223: DUP CRNG <span class="hljs-number"><span class="hljs-number">000</span></span>C886A <span class="hljs-number"><span class="hljs-number">000E1869</span></span> JZ L235 RLE512 <span class="hljs-number"><span class="hljs-number">00</span></span> CALLN <span class="hljs-number"><span class="hljs-number">00</span></span> ;;       --- ,    <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> ;;  L235: <span class="hljs-keyword"><span class="hljs-keyword">EXIT</span></span> ... L0: LOADS5 BYTE <span class="hljs-number"><span class="hljs-number">02</span></span> BYTE <span class="hljs-number"><span class="hljs-number">08</span></span> BYTE <span class="hljs-number"><span class="hljs-number">20</span></span> BYTE <span class="hljs-number"><span class="hljs-number">00</span></span> BYTE <span class="hljs-number"><span class="hljs-number">02</span></span> RET ... <br></code> </pre> <code>... L215: DUP CONST 2122 JGQ L220 DUP CRNG 00000843 00000849 JZ L235 RLE512 00 EXIT L220: DUP CRNG 0000084A 000C8869 JZ L223 LOADS2 BYTE 48 BYTE 45 RLE2 4C LOADS7 BYTE 4F BYTE 20 BYTE 57 BYTE 4F BYTE 52 BYTE 4C BYTE 44 RLE2 21 CALLN 00 EXIT L223: DUP CRNG 000C886A 000E1869 JZ L235 RLE512 00 CALLN 00 ;;       --- ,    EXIT ;;  L235: EXIT ... L0: LOADS5 BYTE 02 BYTE 08 BYTE 20 BYTE 00 BYTE 02 RET ... <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not perfect, but there are no snot, the general code is partially highlighted in the procedures, a branch tree is available. </font><font style="vertical-align: inherit;">Will go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains for something to run, for this we need to implement, finally, the virtual machine itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can simply write it in C, since only opcodes change significantly, but experience shows that it is better to generate it all than to monitor the consistency of opcodes and C code. </font><font style="vertical-align: inherit;">There is no way to check this, and the situation when the compiler produces one thing, and vm wants to interpret something completely different, is quite likely. </font><font style="vertical-align: inherit;">So it's better to generate everything. </font><font style="vertical-align: inherit;">Sketch again the mini-eDSL to generate C, so as not to bother closing the brackets, indents and semicolons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again Writer, no variety ...</font></font><br><br><pre> <code class="hljs sql">stubs :: String stubs = envFile $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span> <span class="hljs-string"><span class="hljs-string">"top of the file"</span></span> put <span class="hljs-string"><span class="hljs-string">"#include &lt;stdint.h&gt;"</span></span> put <span class="hljs-string"><span class="hljs-string">"#include \"emufatstubs.h\""</span></span> defines ... stmt (pt codeType ++ op <span class="hljs-string"><span class="hljs-string">`assign`</span></span> <span class="hljs-string"><span class="hljs-string">"code"</span></span>) endl push a <span class="hljs-string"><span class="hljs-string">"n"</span></span> put <span class="hljs-string"><span class="hljs-string">"for(;;)"</span></span> braces $ indented $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> put <span class="hljs-string"><span class="hljs-string">"switch(*op)"</span></span> braces $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> forM_ codes $ \op -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> put (printf <span class="hljs-string"><span class="hljs-string">"case %s:"</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">show</span></span> op)) indented $ <span class="hljs-keyword"><span class="hljs-keyword">decode</span></span> op endl put <span class="hljs-string"><span class="hljs-string">"default:"</span></span> indented $ <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> exitLabel indented $ stmt <span class="hljs-string"><span class="hljs-string">"return 0"</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">decode</span></span> (CRNG) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> stmt (tmp0 <span class="hljs-string"><span class="hljs-string">`assign`</span></span> pop a) stmt (tmp1 <span class="hljs-string"><span class="hljs-string">`assign`</span></span> decode32) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span> <span class="hljs-string"><span class="hljs-string">"4"</span></span> stmt (tmp2 <span class="hljs-string"><span class="hljs-string">`assign`</span></span> decode32) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span> <span class="hljs-string"><span class="hljs-string">"4"</span></span> push a ( _and (tmp0 <span class="hljs-string"><span class="hljs-string">`gq`</span></span> tmp1) (tmp0 <span class="hljs-string"><span class="hljs-string">`lq`</span></span> tmp2) ) <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decode</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> stmt (tmp0 <span class="hljs-string"><span class="hljs-string">`assign`</span></span> decode32) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span> <span class="hljs-string"><span class="hljs-string">"4"</span></span> stmt (push<span class="hljs-string"><span class="hljs-string">' r pc'</span></span>) jump tmp0 ... <br></code> </pre> <code>stubs :: String stubs = envFile $ do comment "top of the file" put "#include &lt;stdint.h&gt;" put "#include \"emufatstubs.h\"" defines ... stmt (pt codeType ++ op `assign` "code") endl push a "n" put "for(;;)" braces $ indented $ do put "switch(*op)" braces $ do forM_ codes $ \op -&gt; do put (printf "case %s:" (show op)) indented $ decode op endl put "default:" indented $ exit exitLabel indented $ stmt "return 0" ... decode (CRNG) = do skip "1" stmt (tmp0 `assign` pop a) stmt (tmp1 `assign` decode32) &gt;&gt; skip "4" stmt (tmp2 `assign` decode32) &gt;&gt; skip "4" push a ( _and (tmp0 `gq` tmp1) (tmp0 `lq` tmp2) ) next decode (CALL) = do skip "1" stmt (tmp0 `assign` decode32) &gt;&gt; skip "4" stmt (push' r pc') jump tmp0 ... <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's see what we got: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFSTACK(n, t, l) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESET(a) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PTOP(a) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TOP(a) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> POP(a) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PUSH(a,v) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT(x) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMP(x, b, o) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SKIP(x, n) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PC(x, b) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECODE32(op) ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECODE8(op) ... ... DEFSTACK(a, uint32_t, 16); DEFSTACK(r, uint32_t, 8); uint32_t tmp0; uint32_t tmp1; uint32_t tmp2; uint32_t tmp3; ... uint8_t *op = code; PUSH(a, n); for(;;) { switch(*op) { ... case CRNG: SKIP(op, (1)); tmp0 = POP(a); tmp1 = DECODE32(op); SKIP(op, (4)); tmp2 = DECODE32(op); SKIP(op, (4)); PUSH(a, ((tmp0 &gt;= tmp1) &amp;&amp; (tmp0 &lt;= tmp2))); NEXT(op); ... case CALL: SKIP(op, (1)); tmp0 = DECODE32(op); SKIP(op, (4)); PUSH(r, PC(op, code)); JUMP(op, code, tmp0); ... case EXIT: goto _exit; default: goto _exit; } } _exit: return 0; ... </span></span><br></code> </pre> <code>#define DEFSTACK(n, t, l) ... #define RESET(a) ... #define PTOP(a) ... #define TOP(a) ... #define POP(a) ... #define PUSH(a,v) ... #define NEXT(x) ... #define JUMP(x, b, o) ... #define SKIP(x, n) ... #define PC(x, b) ... #define DECODE32(op) ... #define DECODE8(op) ... ... DEFSTACK(a, uint32_t, 16); DEFSTACK(r, uint32_t, 8); uint32_t tmp0; uint32_t tmp1; uint32_t tmp2; uint32_t tmp3; ... uint8_t *op = code; PUSH(a, n); for(;;) { switch(*op) { ... case CRNG: SKIP(op, (1)); tmp0 = POP(a); tmp1 = DECODE32(op); SKIP(op, (4)); tmp2 = DECODE32(op); SKIP(op, (4)); PUSH(a, ((tmp0 &gt;= tmp1) &amp;&amp; (tmp0 &lt;= tmp2))); NEXT(op); ... case CALL: SKIP(op, (1)); tmp0 = DECODE32(op); SKIP(op, (4)); PUSH(r, PC(op, code)); JUMP(op, code, tmp0); ... case EXIT: goto _exit; default: goto _exit; } } _exit: return 0; ... <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that should be. An important caveat: in order for the switch to compile into the transition table, it is necessary that the values ‚Äã‚Äãof its labels go in sequence and have no holes. And probably fit in bytes. In case of violation of these heuristics, C compilers can generate a tree of comparisons, which in this case does not suit us at all. We provided the sequence of opcodes by defining an Enum instance for our type of Opcode (see above). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What a pity that such a low-level, it would seem, C does not have in the standard ways to go to a variable address, even though GCC supports this extension. But not all interesting platforms have GCC, so we restrict ourselves to a switch-based interpretation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our virtual machine is ready. </font><font style="vertical-align: inherit;">We write tests for her. </font><font style="vertical-align: inherit;">This is easy ‚Äî let the test VM accept the bytecode stream as input, generate the contents of the buffer as a result of their interpretation, and give it to the output stream. </font><font style="vertical-align: inherit;">Each test case, therefore, will be considered passed if the contents of the buffer ultimately meet expectations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's write tests ...</font></font><br><br><pre> <code class="hljs dos">testJne = makeTest $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [l1, l2] &lt;- replicateM <span class="hljs-number"><span class="hljs-number">2</span></span> newLabel cnst <span class="hljs-number"><span class="hljs-number">1</span></span> cnst <span class="hljs-number"><span class="hljs-number">2</span></span> jne l1 <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> l1 cnst <span class="hljs-number"><span class="hljs-number">0</span></span>xCAFEBABE -- <span class="hljs-number"><span class="hljs-number">1</span></span> outle cnst <span class="hljs-number"><span class="hljs-number">1</span></span> cnst <span class="hljs-number"><span class="hljs-number">1</span></span> jne l2 cnst <span class="hljs-number"><span class="hljs-number">0</span></span>xCAFEBABE -- <span class="hljs-number"><span class="hljs-number">2</span></span> outle <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-built_in"><span class="hljs-built_in">label</span></span> l2 cnst <span class="hljs-number"><span class="hljs-number">0</span></span>xFFFFFFFF outle <br></code> </pre> <code>testJne = makeTest $ do [l1, l2] &lt;- replicateM 2 newLabel cnst 1 cnst 2 jne l1 exit label l1 cnst 0xCAFEBABE -- 1 outle cnst 1 cnst 1 jne l2 cnst 0xCAFEBABE -- 2 outle exit label l2 cnst 0xFFFFFFFF outle <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... and test cases: </font></font><br><br><pre> <code class="hljs ruby">tests = testSuite $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... test <span class="hljs-string"><span class="hljs-string">"testJne"</span></span> testJne (assert $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- getWord32le b &lt;- getWord32le <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $ a == <span class="hljs-number"><span class="hljs-number">0xCAFEBABE</span></span> &amp;&amp; b == <span class="hljs-number"><span class="hljs-number">0xCAFEBABE</span></span>) <br></code> </pre> <code>tests = testSuite $ do ... test "testJne" testJne (assert $ do a &lt;- getWord32le b &lt;- getWord32le return $ a == 0xCAFEBABE &amp;&amp; b == 0xCAFEBABE) <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the shell to run them: </font></font><br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">runTest</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Test</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> runTest path (<span class="hljs-type"><span class="hljs-type">T</span></span>{tname=nm, tcode=code, tcheck = tc})= <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bin = toBinary code (inp,out,err,pid) &lt;- runInteractiveProcess path [] <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">BS</span></span>.hPut inp bin hClose inp res &lt;- <span class="hljs-type"><span class="hljs-type">BS</span></span>.hGetContents out <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r = tc res hPutStrLn stderr (printf <span class="hljs-string"><span class="hljs-string">"test %-24s : %s"</span></span> nm (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">"PASSED"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"FAILED !"</span></span>)) return r ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> args <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ... ... -&gt; mapM_ (runTest path) tests ... ... <br></code> </pre> <code>runTest :: String -&gt; Test -&gt; IO Bool runTest path (T{tname=nm, tcode=code, tcheck = tc})= do let bin = toBinary code (inp,out,err,pid) &lt;- runInteractiveProcess path [] Nothing Nothing BS.hPut inp bin hClose inp res &lt;- BS.hGetContents out let r = tc res hPutStrLn stderr (printf "test %-24s : %s" nm (if r then "PASSED" else "FAILED !")) return r ... case args of ... ... -&gt; mapM_ (runTest path) tests ... ... <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run, fix all problems and crashes in the core (surprisingly few) </font></font><br><br><pre> <code class="hljs bash">... <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> testJgq : PASSED <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> testJne : PASSED <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> testCallRet1 : PASSED ... <br></code> </pre> <code>... test testJgq : PASSED test testJne : PASSED test testCallRet1 : PASSED ... <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and run it all together: </font></font><br><br><pre> <code class="hljs sql">... helloFile = const $ BS8.pack "HELLO WORLD!!" fatSample2 = filesystem $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file0"</span></span> (<span class="hljs-number"><span class="hljs-number">16384</span></span>) helloFile dir <span class="hljs-string"><span class="hljs-string">"A"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file1"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) helloFile dir <span class="hljs-string"><span class="hljs-string">"C"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file3"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) helloFile <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file4"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) helloFile <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file5"</span></span> (megs <span class="hljs-number"><span class="hljs-number">100</span></span>) helloFile dir <span class="hljs-string"><span class="hljs-string">"E"</span></span> $ emptyDir dir <span class="hljs-string"><span class="hljs-string">"B"</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-string"><span class="hljs-string">"file2"</span></span> (megs <span class="hljs-number"><span class="hljs-number">50</span></span>) emptyFile ... $ ./FatGen <span class="hljs-keyword"><span class="hljs-keyword">bin</span></span> | cbits/genfat <span class="hljs-number"><span class="hljs-number">1000000</span></span> &gt; fat.img <span class="hljs-number"><span class="hljs-number">521106</span></span> / <span class="hljs-number"><span class="hljs-number">1000000</span></span> ( <span class="hljs-number"><span class="hljs-number">13027</span></span> kb/s) $ fsck.vfat ./fat.img dosfsck <span class="hljs-number"><span class="hljs-number">3.0</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> Jan <span class="hljs-number"><span class="hljs-number">2010</span></span>, FAT32, LFN Free cluster summary uninitialized (should be <span class="hljs-number"><span class="hljs-number">15863</span></span>) ./fat.img: <span class="hljs-number"><span class="hljs-number">10</span></span> files, <span class="hljs-number"><span class="hljs-number">115209</span></span>/<span class="hljs-number"><span class="hljs-number">131072</span></span> clusters $ sudo <span class="hljs-keyword"><span class="hljs-keyword">mount</span></span> -o <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> ./fat.img /mnt/test2/ $ find /mnt/test2/ /mnt/test2/ /mnt/test2/FILE0 /mnt/test2/A /mnt/test2/A/FILE1 /mnt/test2/A/C /mnt/test2/A/C/FILE3 /mnt/test2/A/C/FILE4 /mnt/test2/A/C/FILE5 /mnt/test2/A/C/E /mnt/test2/B /mnt/test2/B/FILE2 <br></code> </pre> <code>... helloFile = const $ BS8.pack "HELLO WORLD!!" fatSample2 = filesystem $ do file "file0" (16384) helloFile dir "A" $ do file "file1" (megs 100) helloFile dir "C" $ do file "file3" (megs 100) helloFile file "file4" (megs 100) helloFile file "file5" (megs 100) helloFile dir "E" $ emptyDir dir "B" $ do file "file2" (megs 50) emptyFile ... $ ./FatGen bin | cbits/genfat 1000000 &gt; fat.img 521106 / 1000000 ( 13027 kb/s) $ fsck.vfat ./fat.img dosfsck 3.0.9, 31 Jan 2010, FAT32, LFN Free cluster summary uninitialized (should be 15863) ./fat.img: 10 files, 115209/131072 clusters $ sudo mount -o loop ./fat.img /mnt/test2/ $ find /mnt/test2/ /mnt/test2/ /mnt/test2/FILE0 /mnt/test2/A /mnt/test2/A/FILE1 /mnt/test2/A/C /mnt/test2/A/C/FILE3 /mnt/test2/A/C/FILE4 /mnt/test2/A/C/FILE5 /mnt/test2/A/C/E /mnt/test2/B /mnt/test2/B/FILE2 <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything works as expected: a file system image is generated, tested, and mounted. </font><font style="vertical-align: inherit;">Content corresponds to the description on our eDSL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The size of the compiled rule file is slightly more than 2Kb and can be further optimized, 2Kb is quite an acceptable size for dynamic download even via GSM / EDGE, not to mention 3G. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The performance of the fort is also optimized, not to mention that in the most extreme case it can be compiled into C and then into native processor code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a small story about the benefits of Haskella in the national economy.</font></font></div><p>Source: <a href="https://habr.com/ru/post/134432/">https://habr.com/ru/post/134432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../134425/index.html">British PR agency edited Wikipedia articles for the benefit of its clients.</a></li>
<li><a href="../134426/index.html">Broadcom is preparing a new wireless standard</a></li>
<li><a href="../134427/index.html">Yota, Dlink or hidden BotNet?</a></li>
<li><a href="../134428/index.html">Free Cheese or Multistage Sales</a></li>
<li><a href="../134431/index.html">CSS3. Work with shadows. Part 2</a></li>
<li><a href="../134433/index.html">ReactOS Digest # 3: Moving on</a></li>
<li><a href="../134436/index.html">Indicators of the popularity of various mapping systems</a></li>
<li><a href="../134438/index.html">Talk about Docsis?</a></li>
<li><a href="../134439/index.html">Object-Oriented Gin Installer Development</a></li>
<li><a href="../134440/index.html">Automation of processing video files from webcams using shell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>