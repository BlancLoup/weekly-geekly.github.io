<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multitasking in the Linux kernel: interrupts and tasklets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my previous article I addressed the topic of multithreading. It dealt with basic concepts: types of multitasking, a scheduler, scheduling strategie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multitasking in the Linux kernel: interrupts and tasklets</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c6c/410/b72/c6c410b72716448c84e60c48126dce02.jpg" alt="Cat and little brothers" align="right">  In my <a href="http://habrahabr.ru/post/219431/">previous article</a> I addressed the topic of multithreading.  It dealt with basic concepts: types of multitasking, a scheduler, scheduling strategies, a stream state machine, and so on. <br><br>  This time I want to approach the question of planning from the other side.  Namely, now I will try to tell about planning not streams, but their ‚Äúyounger brothers‚Äù.  Since the article was quite voluminous, at the last moment I decided to break it into several parts: <br><ol><li>  <b>Multitasking in the Linux kernel: interrupts and tasklets</b> </li><li>  <a href="http://habrahabr.ru/post/244155/">Multitasking in the Linux kernel: workqueue</a> </li><li>  <a href="http://habrahabr.ru/post/244361/">Protothread and cooperative multitasking</a> </li></ol><br>  In the third part, I will also try to compare all these, at first glance, different entities and extract some useful ideas.  And after a while I will talk about how we managed to put these ideas into practice in <a href="https://github.com/embox/embox">the Embox project</a> , and about how we started our OS on a small handkerchief with almost full-fledged multitasking. <br><br>  I will try to tell you in detail, describing the main API and sometimes delving into the implementation, especially focusing on the planning task. <br><a name="habracut"></a><br><h2>  Interrupts and their processing </h2><br>  A hardware interrupt ( <abbr title="interrupt request"><b>IRQ</b></abbr> ) is an external asynchronous event that comes from the hardware, suspends the program run, and transfers control to the processor to handle this event.  The hardware interrupt is processed as follows: <br><ol><li>  The current control flow is suspended, the context information is saved to return to the flow. </li><li>  The handler function ( <abbr title="interrupt service routine"><b>ISR</b></abbr> ) is executed in the context of disabled hardware interrupts.  The handler must perform the actions necessary for the interrupt. </li><li>  The equipment is informed that the interrupt has been processed.  Now it can generate new interrupts. </li><li>  The context is restored to exit the interrupt. </li></ol><br>  The handler function can be quite large, which is impermissible given that it is executed in the context of disabled hardware interrupts.  Therefore, it was decided to divide the interrupt handling into two parts (in Linux, they are called top-half and bottom-half): <br><ul><li>  Directly ISR, which is called upon interruption, performs only the most minimal work that cannot be put off until later: it collects interruption information necessary for subsequent processing, somehow interacts with the equipment, for example, blocks or clears the IRQ from the device (thanks to <a href="https://habrahabr.ru/users/jcmvbkbc/" class="user_link">jcmvbkbc</a> and <a href="https://habrahabr.ru/users/zyoma/" class="user_link">Zyoma</a> for <a href="http://habrahabr.ru/post/244071/">clarification</a> ) and plans the second part. </li><li>  The second part, where the main processing is performed, is launched in a different processor context, where hardware interrupts are enabled.  The call to this part of the handler will be made later. </li></ul><br>  So we approached deferred interrupt handling.  In Linux, the tasklet and workqueue are used for this purpose. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Tasklet </h3><br>  In short, a <b><abbr title="The name 'tasklet' is misleading: it was misleading: Alexey Kuznetsov had at the time."><b>tasklet</b></abbr></b> is something like a very small thread that does not have its own stack or context.  Such ‚Äústreams‚Äù are worked out quickly and completely.  The main features of tasklets: <br><ul><li>  tasklets are atomic, so one cannot use sleep () and such synchronization primitives as mutexes, semaphores, and so on.  But, for example, spinlock (spinning or looping) can be used; </li><li>  called in a softer context than the ISR.  In this context, hardware interrupts are enabled that force out tasklets for the duration of an ISR.  In the Linux kernel, this context is called softirq, and in addition to running tasklets, it is used by several other subsystems; </li><li>  tasklet runs on the same core as its plans.  Or rather, managed to plan it first, calling softirq, the handlers of which are always tied to the calling kernel; </li><li>  different tasklets can be executed in parallel, but at the same time it cannot be called to itself at the same time, since it is executed only on one core, the first to schedule its execution; </li><li>  tasklets are executed according to the principle of non-displacing planning, one after the other, in turn.  You can plan with two different priorities: normal and high. </li></ul><br>  Let's take a look now ‚Äúunder the hood‚Äù and see how they work.  First, the tasklet structure itself (defined in <i>&lt;linux / interrupt.h&gt;</i> ): <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tasklet_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tasklet_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  tasklet     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> state; <span class="hljs-comment"><span class="hljs-comment">/* TASKLET_STATE_SCHED  TASKLET_STATE_RUN */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">atomic_t</span></span> count; <span class="hljs-comment"><span class="hljs-comment">/*   ,  tasklet   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*func)(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   tasklet' */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* ,    func */</span></span> };</code> </pre> <br>  Before using a tasklet, you first need to initialize it: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   tasklet  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*func)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span></span>; DECLARE_TASKLET(name, func, data); DECLARE_TASKLET_DISABLED(name, func, data); <span class="hljs-comment"><span class="hljs-comment">/*  tasklet */</span></span></code> </pre><br>  Tasklets are planned simply: tasklet is placed in one of two queues, depending on priority.  Queues are organized as single-linked lists.  Moreover, each CPU has its own queues.  This is done using functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_hi_schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_hi_schedule_first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre><br>  When a tasklet is scheduled, it is set to <b>TASKLET_STATE_SCHED</b> , and it is added to the queue.  While he is in this state, to schedule it again will not work - in this case, nothing will happen.  The tasklet cannot be in several places in the planning queue at once, which is organized through the next field of the tasklet_struct structure.  This, however, is true for any lists linked through an object field, such as <i>&lt;linux / list.h&gt;</i> . <br>  At runtime, the tasklet is assigned the status <b>TASKLET_STATE_RUN</b> .  By the way, the tasklet gets out of the queue before its execution, and the <b>TASKLET_STATE_SCHED</b> state <b>is</b> removed, that is, it can be scheduled again during its execution.  This can be done either by himself or, for example, by an interrupt on another core.  In the latter case, however, he will be called only after he finishes his execution on the first core. <br><br>  Interestingly enough, the tasklet can be activated and deactivated, recursively.  The following functions are responsible for this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_disable_nosync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_disable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     tasklet' */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span></code> </pre><br>  If the tasklet is deactivated, you can still add it to the planning queue, but it will not run on the processor until it is activated again.  Moreover, if the tasklet has been deactivated several times, then it must be activated exactly the same time, the count field in the structure is just for this. <br><br>  And tasklets can be killed.  Like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_kill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tasklet_struct *t)</span></span></span></span>;</code> </pre><br>  Moreover, it will be killed only after the tasklet is completed, if it is already planned.  If suddenly the tasklet is planning itself, then you need to remember to prevent it from doing this before calling this function - this is on the programmer‚Äôs conscience. <br><br>  The most interesting features that play the role of the scheduler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct softirq_action *a)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_hi_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct softirq_action *a)</span></span></span></span>;</code> </pre><br>  Since they are almost the same, it makes no sense to provide the code for both functions.  But here it is worth looking at one of them in order to find out in more detail: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasklet_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct softirq_action *a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tasklet_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> local_irq_disable(); <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = __this_cpu_read(tasklet_vec.head); __this_cpu_write(tasklet_vec.head, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); __this_cpu_write(tasklet_vec.tail, &amp;__get_cpu_var(tasklet_vec).head); local_irq_enable(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tasklet_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>-&gt;next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasklet_trylock(t)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!atomic_read(&amp;t-&gt;count)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!test_and_clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) BUG(); t-&gt;func(t-&gt;data); tasklet_unlock(t); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } tasklet_unlock(t); } local_irq_disable(); t-&gt;next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; *__this_cpu_read(tasklet_vec.tail) = t; __this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next)); __raise_softirq_irqoff(TASKLET_SOFTIRQ); local_irq_enable(); } }</code> </pre><br>  Note the call to the tasklet_trylock () and tasklet_lock () functions.  tasklet_trylock () sets the tasklet to TASKLET_STATE_RUN status and thus blocks the tasklet, which prevents the execution of the same tasklet on different CPUs. <br><br>  These planner functions, in essence, implement cooperative multitasking, which I discussed <a href="http://habrahabr.ru/post/219431/">in</a> detail <a href="http://habrahabr.ru/post/219431/">in my article</a> .  Functions are registered as softirq handlers, which is initiated when scheduling tasklets. <br><br>  The implementation of all the above functions can be found in the <i>include / linux / interrupt.h</i> and <i>kernel / softirq.c files</i> . <br><br><h4>  To be continued </h4><br>  In the <a href="http://habrahabr.ru/post/244155/">next part</a> I will talk about a much more powerful mechanism - workqueue, which is also often used for deferred interrupt handling. <br><br>  <i>PS For publicity.</i>  <i>I also want to invite everyone who is interested in our project, to a <a href="http://codefreeze.timepad.ru/event/163097/">meeting</a> organized by codefreeze.ru ( <a href="http://habrahabr.ru/company/codefreeze/blog/243659/">announcement on Habr√©</a> ).</i>  <i>On it you can talk live, ask questions to the main villain <a href="https://habrahabr.ru/users/abondarev/" class="user_link">abondarev</a> and criticize <s>in the face</s> , in the end :)</i> </div><p>Source: <a href="https://habr.com/ru/post/244071/">https://habr.com/ru/post/244071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244061/index.html">Honeymoon Manager: Part 3</a></li>
<li><a href="../244063/index.html">Unexpected B2B sales research results [infographics]</a></li>
<li><a href="../244065/index.html">Experience of using MVVM in real projects</a></li>
<li><a href="../244067/index.html">The role of industrial design in creating a product for the electronics market</a></li>
<li><a href="../244069/index.html">PHPixie Illusion - a simple mock HTTP server for your tests.</a></li>
<li><a href="../244073/index.html">Regin Trojan: Who is spying on GSM via Windows?</a></li>
<li><a href="../244075/index.html">Fear of criticism - an excuse for wimps or a real problem for designers</a></li>
<li><a href="../244079/index.html">GPS monitoring for personal use (part 1)</a></li>
<li><a href="../244083/index.html">Temperature control in server cabinets with Arduino</a></li>
<li><a href="../244085/index.html">How we implement Open source in state-owned companies and large-scale commerce in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>