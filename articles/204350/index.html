<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Infinite scrolling in web applications with examples on AngularJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Misko Heveri, the main developer of Angulyar, once mentioned that the application is guaranteed to work without brakes, if there are no more than 100 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Infinite scrolling in web applications with examples on AngularJS</h1><div class="post__text post__text-html js-mediator-article">  Misko Heveri, the main developer of Angulyar, once mentioned that the application is guaranteed to work without brakes, if there are no more than 100 active scopes in it.  This approach is generally applicable to any applications.  In games, they do not render for a long time what the player does not see and only on the web is still considered the norm to display the entire list of several thousand items.  With the advent of js frameworks, the situation should change and the best solution would be to remove from the DOM what is not on the screen, rather than reject intermediate tags, binding and other things that facilitate development.  Therefore, I conducted a small analysis of solutions for displaying large lists.  Stumbled upon a couple of articles: <br><br><h4>  1. <a href="https://medium.com/p/463bc649c7bd">The Infinite Path of Scrolling</a> </h4><br><br>  In it, the guy says that he had an internship at Google on Angulyar‚Äôs team and was assigned to investigate this issue.  (I am glad that the developers are interested in this. I hope that we will soon see the native support of the endless scroll). <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are two solutions: good old pagination and endless scrolling.  Moreover, the infinite scrolling can both load the necessary data and delete what has already been viewed, what is implemented, for example, in the UITableView component from IOS.  The author tried to recreate this component for Angulyar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/648/6cf/e996486cf37e2012ed65e2fe3f861f27.png" alt="image"><br><br>  In his scroller, he <b>separated the logic of the main model from the logic of the actually displayed data</b> and tried to create several predefined implementations for the list, the grid of icons, the list scrolling through the columns.  But for each implementation, I had to write a lot of my code, which confused him. <br><br>  Initially, the CSS transformation was used for animation, but problems arose with it when the user returned to the data already viewed.  Therefore, he left this venture.  In order not to tinker with the indices of individual elements, it was decided to use <b>page identifiers</b> (a page is a portion of the data received), where the offset is specified as the identifier of the previous (or subsequent if we request new elements) element and the maximum number of elements we would like .  Thus, the pagination is not tied to the original state. <br><br>  It is worth noting that the component should be universal and handle the scrolling of both the <b>entire browser window</b> and <b>internal areas</b> , if the scrolling is local. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/763/341/8fa/7633418fa22d8b0b953a9521db4aa397.png" alt="image"><br><br>  The idea is to insert the first portion of the data set into an empty container (the number of elements in the portion requested from the server is configurable).  Then, when the user scrolls to the end of the buffer, a new chunk is requested.  A preloader may be displayed at the bottom at this time. <br><br>  When the user scrolls below, the items above the viewport are removed from the DOM and transferred to the pool of unused items.  When a new data arrives in response to a request to the server, the component first looks to see if there are reusable elements and either replace existing elements with new ones or create a new element.  These elements are then added to the end of the container. <br><br>  The user can scroll back (up) and the same happens in reverse order.  Items that are not visible at the end are pooled.  Other items are taken from the data store and placed before the first visible item, and deleted items are reused when we receive data. <br><br>  Deleting items as soon as they go out of the viewport is not a good idea, because  you will have to request them again if the user scrolls backwards through several elements.  It makes sense to put the recently loaded items in the cache and only very old again to request from the server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41a/bbc/95f/41abbc95fcbb8727c903452c7a119be6.png" alt="image"><br><br>  One of the most important features of the scroller is the <b>support of several templates</b> , so that there can be different elements in the stream, for example, elements with text, photos, links, etc., as in Facebook. <br><br>  Minimum HTML required for the scroller: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-scroller</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-scroller-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùpost</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">posts</span></span></span><span class="hljs-tag">‚Äù&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{post.author}}: {{post.text}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  The element with <code>ng-scroller</code> is the viewport, the element with <code>ng-scroller-repeat</code> is the container (the blue area in the diagram above) and the internal element of the template that will be duplicated and linked to the child scope created for each element. <br><br>  The <code>posts</code> key in scope, in this case, must point to a data storage object that implements the following interface for querying items.  If the key points to an array, for convenience, it gets a wrapped object that implements the required interface. <br><br><pre> <code class="javascript hljs">IScrollerDataStore { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> getRangeAfter(prev_id, length, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Error, Array</span></span></span><span class="hljs-function">)); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">next_id, length, function(Error, Array</span></span></span><span class="hljs-function">)); }</span></span></code> </pre><br><br>  If you need to display multiple templates, you should use the directives <code>ng-if</code> and <code>ng-switch</code> .  In most cases this is enough. <br><br><pre> <code class="javascript hljs">&lt;div ng-scroller&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-scroller-repeat</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">‚Äùpost</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">posts</span></span></span></span><span class="xml"><span class="hljs-tag">‚Äù&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-class</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">‚Äù{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">link:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">post.link</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">photo:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">post.photo</span></span></span></span><span class="xml"><span class="hljs-tag"> }‚Äù&gt;</span></span></span><span class="xml"> {{post.author}}: </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-if</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"post.link"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">‚Äù{{post.link}}‚Äù</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{post.link}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-if</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"post.photo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ng-src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">‚Äù{{post.photo}}‚Äù</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><br><br>  Initially, he wanted to allow developers to expand the scroller, but decided not to complicate people's lives and implement the main cases on their own.  For example, a common case is the case with the ‚ÄúLoad More‚Äù button, etc. <br><br><br><br>  In scrolling containers, often make flowing elements, such as row headers, tables, footers, rows and columns of tables, headers of a contact list, as on Instagram, which stick only when the element is the topmost visible element in the viewport. <br><br><br><br>  The first two types can be done in pure CSS.  The latter is more difficult, because  stickiness dynamically changes while scrolling. <br><br>  When he discussed a scroller with the same developer who is working on a similar component inside Google, he advised to focus on working with the <b>state of deleted items</b> , which will have to be restored later.  An example with tweets: you can click on a tweet and expand the entire conversation.  What if, scroll the open tweet down so that it is removed from the DOM, and then scroll back.  It will be necessary to restore his condition. <br><br>  You can handle this in two ways.  Either store the state in the scope of the element created using <code>ng-scroller-repeat</code> (ie <code>tweet.open = true</code> ) or somehow track the changes in the scope itself by creating a correspondence table with individual elements and restore them if the element is used again. <br><br>  At the moment, he chose the first approach as the simplest. <br><br>  <a href="https://github.com/jankuca/ng-scroller">Project on Gitkhab</a> , <a href="http://ngscroller.herokuapp.com/">demos</a> <br>  The project is obviously not finalized, but the ideas embodied in it are quite sound. <br><br><h4>  2. AngularJS Virtual Scrolling.  <a href="http://blog.stackfull.com/2013/02/angularjs-virtual-scrolling-part-1/">Part 1</a> , <a href="http://blog.stackfull.com/2013/03/angularjs-virtual-scrolling-part-2/">Part 2</a> </h4><br><br>  Here the person rewrote the <code>ng-repeat</code> directive, which he called <code>sf-repeat</code> .  Parses the problem by the example of the log of logs. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overflow: scroll; height:200px;"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ol</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"event in eventLog"</span></span></span><span class="hljs-tag">&gt;</span></span>{{event.time}}: {{event.message}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ol</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  He says that pagination in a dynamic application is a bad thing, because  when deleting / adding elements, you need to monitor so that the elements are correctly transferred through the pages, there are no duplicates or lost records. <br><br>  Trying to fix a problem with a filter. <br><br><pre> <code class="javascript hljs">angular.module(<span class="hljs-string"><span class="hljs-string">'sf.virtualScroll'</span></span>).filter(<span class="hljs-string"><span class="hljs-string">'sublist'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input, range, start</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.slice(start, start+range); }; });</code> </pre><br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overflow: scroll; height:200px;"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ol</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"event in eventLog|sublist:rows:offset"</span></span></span><span class="hljs-tag">&gt;</span></span>{{event.time}}: {{event.message}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ol</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Passing an expression to a directive is divided into two parts: the <code>event</code> value identifier and the collection <code>eventLog|sublist:rows:offset</code> identifier <code>eventLog|sublist:rows:offset</code> .  The collection ID is calculated each time during the dirty check and compared with the previous value.  Thus, only the visible range is calculated.  If the collection has changed the screen is updated and if the value in the scope has changed, the visible position of the list changes. <br><br>  It remains to give the user the ability to change the position of the scroll. <br><br>  To ensure that the range of the scrollbar attached to the container (i.e. DIV with <code>overflow: scroll</code> ) does not change, you need to deceive the browser by adding an area with empty content.  By changing the height of the empty content, we control the scroll range.  The problem is how to get the height of the content. <br><br>  Here the author proposes to take the average height of the element and multiply by the number of elements.  This rolls, but the problem in situations where the dimensions of the elements are very different, remains. <br><br>  Makes your scroll widget: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overflow: scroll; height:200px;"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sf-scroller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"y = 0 to eventLog.length"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slicePosition"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Parsing a range expression (y = 0 to eventLog.length) <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseRangeExpression</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">expression</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = expression.match(<span class="hljs-regexp"><span class="hljs-regexp">/^(x|y)\s*(=|in)\s*(.+) to (.+)$/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !match ){ <span class="hljs-comment"><span class="hljs-comment">// throw an informative Error. } return { axis: match[1], lower: match[3], upper: match[4] }; }</span></span></code> </pre><br><br>  Directive <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mod = angular.module(<span class="hljs-string"><span class="hljs-string">'sf.virtualScroll'</span></span>); mod.directive(<span class="hljs-string"><span class="hljs-string">"sfScroller"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//function parseRangeExpression ... return function(scope, element, attrs){ // ... }; });</span></span></code> </pre><br><br>  He notes the shortcomings of this approach: the developer will have to make his own scroll bar, but for the user it will not look native anyway. <br><br>  Decides to remake <code>ng-repeat</code> , parses <a href="">it</a> . <br><br>  The first thing to note is the use in the transclude directive and compilation functions.  Simpler directives use only the linking function, but <code>ng-repeat</code> needs access to the linking function, which will link the compiled elements to the new scope for each element in the collection (see the section ‚ÄúReasons for separation of the compilation and linking stages‚Äù of <a href="http://www.angular.ru/guide/directive">the developer‚Äôs guide</a> ). <br><br>  In essence, the connecting function parses the expression in <code>ng-repeat</code> and sets watch-watchers.  Observers are needed to add and remove items and synchronize with the collection, but you need to be careful when tracking the movements of items.  If you have an element that corresponds to an element in the collection, and it has some state in the DOM (a good example is a form element), then you do not want the element to be deleted and re-created just because the underlying object has moved into the collection.  This is not a trivial task, but after we have taken care of all the permutations, the code for adding new and removing existing elements becomes relatively simple. <br><br>  Decides not to save the state of the DOM element when deleting, because  the state should be stored in the model (the previous author did the same) <br><br>  Another subtlety of <code>ng-repeat</code> is that the collection can be an object and the elements will be shown using <code>for(key in collection)</code> .  Since  because of this, there are problems with the indexes and the location of elements, decides to do only arrays. <br><br>  Describes his <code>sf-repeat</code> , says that elements should come from the server in fixed portions. <br><br><img src="http://blog.stackfull.com/wp-content/uploads/2013/03/virtual-list-moving.png" alt="image"><br><br>  Explains that you need to define marks after and before which elements are added or removed.  To calculate the mark you need to specify the height of the line.  There are problems with this again, because  in the compilation / assembly phase it is impossible to determine that the element is fully rendered.  Decides to calculate the height of the CSS (explicit or maximum). <br><br>  The height of the viewport takes the same from CSS. <br><br>  Directive <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mod = angular.module(<span class="hljs-string"><span class="hljs-string">'sf.virtualScroll'</span></span>); mod.directive(<span class="hljs-string"><span class="hljs-string">"sfVirtualRepeat"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">transclude</span></span>: <span class="hljs-string"><span class="hljs-string">'element'</span></span>, <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">terminal</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">compile</span></span>: sfVirtualRepeatCompile }; <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre><br>  Compilation function <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sfVirtualRepeatCompile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, attr, linker</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ident = parseRepeatExpression(attr.sfVirtualRepeat), LOW_WATER = <span class="hljs-number"><span class="hljs-number">100</span></span>, HIGH_WATER = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">post</span></span>: sfVirtualRepeatPostLink }; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><br>  The link function evaluates the expression that defines the data set and we connect and set the observers as before, but these observers follow the upper and lower level labels that define the active range and, accordingly, the size of the collection.  In addition, the link function sets the handler for the scroll event in view, which will adjust the current active range. <br><br>  The observer algorithm can be reduced to comparing the new active range with the existing one and deciding which lines to destroy and which ones to create.  The location of elements on a specific place can be made absolute positioning or indentation of the first element.  The author has done with indentation. <br><br>  The <code>sf-virtual-repeat</code> directive is part of the <code>sf.virtualScroll</code> module on GitHub.  <a href="https://github.com/stackfull/angular-virtual-scroll">Source</a> , <a href="https://github.com/stackfull/angular-virtual-scroll-bower">bower-component</a> , <a href="http://demo.stackfull.com/virtual-scroll">demo</a> . <br><br>  The main problem with this solution is that you must use CSS. <br><br><hr><br>  The articles describe well the approaches to solving the problem of endless scrolling, but have not yet found an optimal solution.  Hope to see something useful in the comments. <br><br>  PS <a href="http://engineering.linkedin.com/linkedin-ipad-5-techniques-smooth-infinite-scrolling-html5">LinkedIn Developer Study</a> <br>  PPS <a href="http://toster.ru/q/51454">Question on Toaster</a> .  There are interesting answers </div><p>Source: <a href="https://habr.com/ru/post/204350/">https://habr.com/ru/post/204350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204326/index.html">Indian Martian probe directed towards Mars</a></li>
<li><a href="../204330/index.html">Half a kilometer rechargeable lantern</a></li>
<li><a href="../204338/index.html">We program under Pebble. Lesson One: Stupid Watches</a></li>
<li><a href="../204342/index.html">How are we trying to sell PVS-Studio to Google or the next mistakes in Chromium?</a></li>
<li><a href="../204344/index.html">The digest of news from the world of mobile development for the last week No. 32 (November 25 ‚Äî December 1, 2013)</a></li>
<li><a href="../204356/index.html">Objective-c blocks and c ++ lambdas</a></li>
<li><a href="../204362/index.html">Microsoft warns of operating CVE-2013-5065 ITW</a></li>
<li><a href="../204364/index.html">Thinkspace: Zuckerberg Factory</a></li>
<li><a href="../204368/index.html">Tube Linux-like terminal in Windows</a></li>
<li><a href="../204370/index.html">LTE in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>