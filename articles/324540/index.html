<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clustering text documents according to semantic features (part one: algorithm description)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a huge number of clustering algorithms. The main idea of ‚Äã‚Äãmost of them is to combine identical sequences into one class or cluster based on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clustering text documents according to semantic features (part one: algorithm description)</h1><div class="post__text post__text-html js-mediator-article">  There is a huge number of clustering algorithms.  The main idea of ‚Äã‚Äãmost of them is to combine identical sequences into one class or cluster based on similarity.  As a rule, the choice of algorithm is determined by the task.  As for textual data, here the compared components are sequences of words and their attributes (for example, the weight of a word in the text, the type of the named entity, tonality, etc.).  Thus, texts are initially converted into vectors with which they produce different types of manipulation.  In this case, as a rule, a number of problems arise related to: the choice of primary clusters, the dependence of the quality of clustering on the length of the text, the determination of the total number of clusters, etc.  But the most difficult problem is the lack of communication between similar texts, which use different vocabulary.  In such cases, the association should occur not only on the basis of similarity, but also on the basis of semantic contiguity or associativity. <br><br><img src="https://habrastorage.org/files/519/ab1/fe6/519ab1fe6f5a40e5bf10278d67155264.jpg"><br><a name="habracut"></a><br>  For example, <br><br>  <i>In London, they decided not to declare Russia a new cold war.</i> <i><br></i>  <i>Boris Johnson: The West is not in a state of new cold war with Russia</i> <i><br></i>  <i>In the British Foreign Ministry said that the West does not want a new cold war with Russia</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All three examples are one news, however, the vocabulary used is different.  In such cases, clustering algorithms based on lexical similarity no longer help. <br>  Problems of this type are solved in two ways: 1) compiling thesauri and 2) using various kinds of ‚Äúclever‚Äù algorithms that establish associative-semantic links between words, such as: latent-semantic analysis (LSA), probabilistic latent-semantic analysis (pLSA) , latent placement of Dirichlet (LDA), etc. <br><br>  The first way - obtaining thesauri - is rather laborious and is completely determined by the task.  This means that creating a universal thesaurus is not yet possible. <br><br>  The second way - algorithmic - also has its drawbacks.  First of all, it is the ‚Äúnebula‚Äù of the methods themselves and the non-obviousness of their use for textual data.  Say, LDA requires a condition of normal distribution, which is not always satisfied when solving linguistic problems.  As a rule, all these algorithms have a large number of parameters, the determination of which is empirical and can significantly affect the quality of the solution (for example, the reduction of the singular values ‚Äã‚Äãof the diagonal matrix in the LSA has a very non-linear effect on the result). <br><br>  We tried to circumvent a number of the above problems using the results of the Word2Vec algorithm. <br><br><h3>  Word2vec </h3><br>  The description of the algorithm can be found in <a href="https://ru.wikipedia.org/wiki/Word2vec">Wikipedia</a> or another information resource.  The algorithm was created primarily for search tasks, so it should be used directly for other linguistic purposes with care. <br><br>  The algorithm has two ways of learning and several options for demonstrating the results.  We, in particular, will be interested in presenting the result of classes ‚Äî obtaining associative semantic classes (using the k-mean, by the way). <br><br>  As the experiments show, even on small collections of several million words of use, more or less ‚Äúmeaningful‚Äù classes of words are obtained.  But how to use this result if words have no weight (for example, prepositions and ‚Äúkey‚Äù words have the same idea in such a model)?  Another problem is that classes are not perfect and, for example, service words can fall into a semantically significant class.  Use a stop list?  Then there is a risk of throwing out the baby with the water from the trough.  In general, the use of stop lists has its significant drawbacks (for example, by throwing out pronouns, we lose the Russian youth public political movement OUR; by throwing out single-letter words, we will not find information about Kommersant ‚Äî reduction of the Kommersant newspaper, etc.) . <br><br>  Finally, how many classes will be optimal for text clustering?  Does it depend on the size of the training or test sample, the subject of the text, its volume?  We will answer these key questions in the second part of the publication, but for now let's briefly describe the algorithm. <br><br><h3>  Algorithm Description </h3><br>  The idea of ‚Äã‚Äãthe algorithm in comparing not the words themselves or the sequences composed of them (the so-called n-grams), but the semantic classes into which they fall. <br><br>  Training requires a large amount of textual material (hundreds of thousands, or better tens of millions of word usage; the larger the sample, the less thematic binding of the model to the text, the less often it is necessary to adjust the model to the text).  As a result of the training, a list is obtained where a class is assigned to almost every word of the text (the number of classes is indicated at the training stage).  Then this list is based on the frequency distributions of words in the text and in the class corresponding to them, to the format: word - class - weight, smoothed by a specific algorithm.  Here the important parameters are the total number of classes and smoothing factors (in more detail in the second part of the publication). <br><br>  Here is an example of a small semantic class. <br><table><tbody><tr><td>  baby </td><td>  daughter </td></tr><tr><td>  mummy </td><td>  mother-in-law </td></tr><tr><td>  teacher </td><td>  docha </td></tr><tr><td>  baby </td><td>  relatives </td></tr><tr><td>  teacher </td><td>  younger </td></tr><tr><td>  little sister </td><td>  wife </td></tr><tr><td>  baby </td><td>  father's </td></tr><tr><td>  sister </td><td>  the former </td></tr><tr><td>  aunt </td><td>  grandmother </td></tr><tr><td>  granny </td><td>  the eldest </td></tr><tr><td>  girlfriend </td><td>  girlfriend </td></tr><tr><td>  mother </td><td>  mistress </td></tr><tr><td>  spouse </td><td>  citizen </td></tr><tr><td>  aunt </td><td>  family </td></tr><tr><td>  granddaughter </td><td>  a girl </td></tr><tr><td>  maiden </td><td>  mother's </td></tr><tr><td>  her </td><td></td></tr></tbody></table><br>  The pronoun ‚Äúher‚Äù falls into this more or less homogeneous associative-semantic class, which, in principle, is appropriate, but not informative.  It can interfere with the clustering of the material, since it will also ‚Äúdrag the blanket‚Äù over to itself in frequency.  Such ‚Äúoutliers‚Äù can be removed by further smoothing the model. <br><br>  According to the obtained model, all the words from the test sample are converted into numbers corresponding to semantic classes, and further manipulations occur only with numbers.  For clustering, a simple algorithm for comparing accumulated documents with each other is used.  Integer types (int) are compared, so the speed is quite high.  At the same time, a comparison is imposed on a number of filters, such as restrictions on the number of semantic classes in one document, the minimum number of documents in a cluster, a measure of proximity - the number of matched classes.  The logic of the algorithm is organized so that the same document can fall into different clusters (since the primary clusters are not defined).  Due to this ‚Äúfuzziness‚Äù, the primary result is a fairly voluminous set of clusters that are close in subject.  Therefore, post clustering is required, which simply combines close clusters, comparing them by the number of identical documents (by their id). <br><br>  Thus, using the above described logic, it is possible to achieve not only a high clustering rate, but also not to bother with the definition of the primary clusters, or their total number. <br><br><h3>  Results and conclusions </h3><br>  In clustering, it is difficult to talk about the quality of the result, since it strongly depends on the material being clustered.  In this sense, there is no special reason to make the ‚Äúgold‚Äù standard.  But it makes sense to check the models on different buildings for classification (which will be discussed again in the second part of the article). <br><br>  As the tests on the classification of documents by the vector method on unigrams (comparison by cosine) showed, the clustering models are almost as good as the ‚Äúwords‚Äù models.  This means that the classification ‚Äúwithout a teacher‚Äù (models in this sense are universal) can only show results a little worse than a full-fledged training with a teacher.  The deterioration is 1-10% and depends on the test material.  But this is not the goal!  It just means that the clustering models obtained using the Word2Vec algorithm are quite valid for their application on any type of material with any number of classes (in this case clusters). <br><br>  The quality of the result is determined by the filtering thresholds: for example, if we just need to identify fuzzy duplicates, then we need to set more stringent parameters;  and vice versa, if you just need to see the main topics of the material coming out, you can set softer parameters. <br><br>  In general, the algorithm is universal: it can work on any amount of material.  Although with large volumes it is better to work with windows of 10-100 thousand documents;  thus obtained primary clusters are then combined into post clustering.  The algorithm is also weakly sensitive to the length of the document: it is desirable that the ‚Äúlong‚Äù documents be semantically homogeneous (belong to the same subject). <br><br>  However, there are a number of problems with this algorithm.  First of all, it is the dependence of the result on the number of classes in the model: sometimes it can become sensitive, especially for ‚Äúweak‚Äù clusters, i.e.  clusters with a small amount of documents.  The second problem follows from the imperfect definition of semantic classes, as a result of which sometimes documents that are close in meaning fall into different clusters (differing, say, in a pair of classes).  Such problems are eliminated by an additional post association, based on the factorization of documents: the selection of named objects and the connections between them.  But this problem is solved already easier, because the number of clusters is small relative to the primary volume of documents and most of them are already merged. <br><br>  Thus, the presented algorithm has several advantages: <br><br><ul><li>  clustering occurs not by words, but by semantic classes; </li><li>  independence of the result of the length of the documents; </li><li>  independence of results from the volume of the material; </li><li>  automatic detection of the number of clusters; </li><li>  no need to identify primary clusters; </li><li>  high speed, which allows the use of this algorithm on a large flow of text messages. </li></ul><br>  Despite the fact that the algorithm is not sensitive to the volume of incoming material, it is recommended to use for clustering large streams of unstructured information, when not only the quality of clustering is important, but also the speed of obtaining the result.  For small volumes of thematically separated material (for example, pharmaceuticals, gaming chats, etc.) it is better to use thesauri, since the Word2Vec model may not contain professional terminology or highly specialized jargon. </div><p>Source: <a href="https://habr.com/ru/post/324540/">https://habr.com/ru/post/324540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324528/index.html">Yandex.Money staged a vote for the abolition of the commission for transfers between wallets</a></li>
<li><a href="../324530/index.html">A little bit about the privacy of real Git repositories.</a></li>
<li><a href="../324532/index.html">Unpredictable effects of Chrome performance optimization</a></li>
<li><a href="../324534/index.html">Why 90% of landings do not sell? How to close customer objections 2 times more effective than competitors</a></li>
<li><a href="../324538/index.html">DIY mail cluster</a></li>
<li><a href="../324544/index.html">Columnstore Index - selection from SQL Server Product Team</a></li>
<li><a href="../324546/index.html">How we created a hosting provider with our own data center (continued)</a></li>
<li><a href="../324548/index.html">.NET programming language development strategy</a></li>
<li><a href="../324550/index.html">Source Code Analysis Another World</a></li>
<li><a href="../324552/index.html">JNI and Delphi. Examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>