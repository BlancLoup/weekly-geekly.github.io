<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generate P / Invoke signatures in C #. Misuse of Interface Definition Language and OLE Automation Type Libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is NOT another article about what P / Invoke is. 

 So, let's say in a spherical C # project, you need to use any technology that is not in .NET,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generate P / Invoke signatures in C #. Misuse of Interface Definition Language and OLE Automation Type Libraries</h1><div class="post__text post__text-html js-mediator-article">  This is NOT another article about what P / Invoke is. <br><br>  So, let's say in a spherical C # project, you need to use any technology that is not in .NET, and all we have is the Windows SDK 8.1 in which there is only a set of header files for C / C ++.  We'll have to declare a bunch of types, check the correctness of alignment of structures and write various wrappers.  This is a large amount of routine work, and the risk of making a mistake.  You can of course write a parser header files ... Everything is simple and clear here except for the number of man-hours required for it.  Therefore, we discard this option and try to somehow minimize the number of necessary actions for interacting with unmanaged code. <br><br>  In addition, the resulting code will not depend on the bitness of the process, strict typing will be preserved, automatic testing will be applied. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Interaction Managed and Unmanaged Code. </h4><br>  As you know, in .NET there are 2 main ways to interact with unmanaged code: <br><ol><li>  <b>C ++ / CLI</b> : You can write a wrapper to wrap unmanaged calls into managed methods, manually convert native structures, strings, and arrays into managed objects.  Undoubtedly it is as flexible as possible, but there are more disadvantages. <br>  Firstly, this is a bunch of code, including unmanaged, respectively, the potential risk of making a mistake (only gods and liars write without bugs). <br>  Secondly, the resulting assemblies are nailed to the architecture - x64, x86, etc., respectively, if we have the entire AnyCPU project, then we have to collect the wrappers for several platforms and drag them all with us, unpacking the appropriate configurations. <br>  <s>Thirdly, it is C ++, but it is not needed.</s> <br></li><li>  <b>P / Invoke and COM</b> : Many windows components are implemented using COM.  In general, .net works acceptably with this technology.  Necessary interfaces and structures can either be manually declared independently, or, if you have a type library, you can import them from there automatically using a special tlbimp utility. <br>  And you can call exported functions from dynamic libraries by declaring extern methods with the DllImport attribute.  There is even a whole site where ads are posted for basic winapi functions. <br></li></ol><br>  Let us dwell on <a href="http://ru.wikipedia.org/wiki/Type_library">type libraries</a> .  Type libraries, as the name suggests, contain information about types, and are obtained by compiling IDL - interface definition language - a language whose syntax is damn similar to C. Type libraries are usually supplied either as separate files with the extension .tlb or built into the same DLL where are the described objects.  The tlbimp utility mentioned above generates from the type libraries a special interop assembly containing the necessary declarations for .NET. <br>  Since the syntax of IDL is similar to the declarations in the header files of the C language, the first thought that comes to mind is not to generate a type library in any way in order to further import it into a .net project?  If in the IDL file you can copy all the necessary declarations from the header files almost as it is, without thinking about converting all DWORD to uint, then this is just what you need.  But there are a number of problems: firstly, IDL does not support everything, and secondly, tlbimp does not import everything.  In particular: <br><ul><li>  IDL cannot use function pointers </li><li>  IDL cannot declare bit fields </li><li>  tlbimp does not use unsafe code, so the output of an overwhelming number of pointers will be represented by an untyped IntPtr </li><li>  If a structure is passed as an argument to a method by reference, tlbimp will declare such an argument as ref.  And if, in theory, it is implied that the address of the array should in fact be transferred there, then we go through the forest.  Of course, a zero pinned array element can be referred to as ref, it will even work, but it looks a little Indian.  In any case, due to ref, we will not be able to pass a null pointer if the argument is suddenly optional. </li><li>  Pointers to C-style null-terminated strings (a la LPWSTR) tlbimp converts to string, and if suddenly a bad COM object decides to write something to this piece of memory, the application will say ‚Äúquack‚Äù </li><li>  tlbimp imports only interfaces and structures.  Methods from DLL should be declared manually </li><li>  tlbimp generates the build but not the code.  Although not so critical </li></ul><br><br>  All problems with tlbimp are easily solved - we will not use this utility, but write our own.  But with IDL the situation is more complicated - you have to shaman.  I warn you at once: <u>since the type library will be only an intermediate link, we will forget about compatibility with any standards, good tone, etc.</u>  <u>and we will keep it all in the form in which it is more convenient for us</u> . <br><br><h4>  IDL </h4><br>  I will not elaborate on the description of this language, but only briefly list the key elements of IDL that will be used.  A full description of IDL is in <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa367091(v%3Dvs.85).aspx">msdn</a> <br><br>  The main block in the IDL file is the library.  All types that are inside it will be included in the library.  Types declared outside the library block will be included only if they are referenced by any of the library block.  For good library block should have a name and a unique identifier.  There are a number of other attributes, but we do not need any of this. <br><pre><code class="cpp hljs">[uuid(<span class="hljs-number"><span class="hljs-number">00000000</span></span><span class="hljs-number"><span class="hljs-number">-0000</span></span><span class="hljs-number"><span class="hljs-number">-0000</span></span><span class="hljs-number"><span class="hljs-number">-0000</span></span><span class="hljs-number"><span class="hljs-number">-000000000001</span></span>)] library Import { }</code> </pre>  But if you still need to force the inclusion of the type declared outside the block, you can write inside the library <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> MY_TYPE MY_TYPE;</code> </pre><br>  Inside the block are type declarations.  We need a struct, union, enum, interface, and module.  The first three are exactly the same as in C, so we will not dwell on them in detail.  It should be noted only one feature, which consists in the fact that with this declaration: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tagTEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; } TEST;</code> </pre>  the structure name will be tagTEST, and TEST is the alias which will eventually be replaced with the name.  Since many header files in the declarations of structures contain various nasty prefixes, it‚Äôs better to take some measures to avoid a mess in the names.  But in general, in IDL, just like in C, you can create any number of alias with the typedef directive. <br><br>  To declare interfaces, use the interface block.  Inside this function block: <br><pre> <code class="cpp hljs">[uuid(<span class="hljs-number"><span class="hljs-number">38B</span></span>F1A5B<span class="hljs-number"><span class="hljs-number">-65</span></span>EE<span class="hljs-number"><span class="hljs-number">-4</span></span>C5C<span class="hljs-number"><span class="hljs-number">-9B</span></span>C3<span class="hljs-number"><span class="hljs-number">-0</span></span>D8BE47E8A1F)] interface IXAudio2MasteringVoice : IXAudio2Voice { <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetChannelMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD* pChannelmask)</span></span></span></span>; };</code> </pre>  It's pretty obvious.  Of the attributes in our case, only uuid is important, which is the interface identifier. <br><br>  There is also a block module.  It can, for example, place functions from a DLL, or some constants. <br><pre> <code class="cpp hljs">[dllname(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> NativeMethods_kernel32 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UINT DONT_RESOLVE_DLL_REFERENCES = <span class="hljs-number"><span class="hljs-number">0x00000001</span></span>; [entry(<span class="hljs-string"><span class="hljs-string">"RtlMoveMemory"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlMoveMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Source, SIZE_T Length)</span></span></span></span>; }</code> </pre>  The dllname and entry attributes are important here, indicating where the method will be loaded from.  The entry can be the ordinal function instead of the name. <br><br><h4>  IDL Ads </h4><br>  Make a list of what should be taken from the header file: <br><ul><li>  Structures and unions, incl.  with bit fields </li><li>  Transfers </li><li>  Declarations of functions imported from DLL </li><li>  Interfaces </li><li>  Constants (macros declared with #define) </li><li>  Function pointers </li><li>  Alias ‚Äã‚Äãtypes declared via typedef (i.e. all DWORDs there, etc.) </li></ul><br>  Now you need to decide how to copy everything in the IDL. <br><ul><li>  <b>Structures and unions</b> : Copy as is, optionally removing only unnecessary prefixes from names. </li><li>  <b>Enumerations</b> : Similar to structures. </li><li>  <b>Declarations of functions imported from DLL</b> : Copy as is in the module module for the corresponding DLL.  Obviously, for each DLL you need to create at least one module module. </li><li>  <b>Constants (declared via #define)</b> : Of course, it doesn't work very well - you have to add a type, i.e.  the constant from the example above is actually <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DONT_RESOLVE_DLL_REFERENCES 0x00000001</span></span></code> </pre>  There are few variants - macros can not naturally get into the type library. <br>  Another problem is any structures like GUIDs declared with DEFINE_GUID.  Well, to be precise, in fact these are no constants of any kind, but global variables, but they are usually used as constants.  Here, alas, nothing.  GUIDs we can still declare as strings, but everything else will have to be handled manually. </li><li>  <b>Alias ‚Äã‚Äãtypes declared via typedef</b> (i.e. all DWORDs there, etc.): Copy as is. </li><li>  <b>Interfaces</b> : Since neither C nor C ++ support interfaces, in most header files they are declared through conditional compilation in two ways - as a class for C ++ with __declspec (uuid (x)) in one form or another and as a structure with a list of function pointers for C. We are interested in ads for C ++.  They usually look like this: <br><pre> <code class="cpp hljs">MIDL_INTERFACE(<span class="hljs-string"><span class="hljs-string">"0c733a30-2a1c-11ce-ade5-00aa0044773d"</span></span>) ISequentialStream : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IUnknown { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-comment"><span class="hljs-comment">/* [local] */</span></span> <span class="hljs-function"><span class="hljs-function">HRESULT STDMETHODCALLTYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _Out_writes_bytes_to_(cb, *pcbRead) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation][in] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _In_ ULONG cb, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _Out_opt_ ULONG *pcbRead)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-comment"><span class="hljs-comment">/* [local] */</span></span> <span class="hljs-function"><span class="hljs-function">HRESULT STDMETHODCALLTYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _In_reads_bytes_(cb) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation][in] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _In_ ULONG cb, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [annotation] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _Out_opt_ ULONG *pcbWritten)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  It is necessary to clean everything superfluous from here, so that the interface looks like this: <br><pre> <code class="cpp hljs">[uuid(<span class="hljs-number"><span class="hljs-number">0</span></span>c733a30<span class="hljs-number"><span class="hljs-number">-2</span></span>a1c<span class="hljs-number"><span class="hljs-number">-11</span></span>ce-ade5<span class="hljs-number"><span class="hljs-number">-00</span></span>aa0044773d)] interface ISequentialStream : IUnknown { <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv, ULONG cb, ULONG *pcbRead)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv, ULONG cb, ULONG *pcbWritten)</span></span></span></span>; };</code> </pre>  If you wish, you can leave the comments unchecked, and hide the SAL annotations in the [annotation (...)] attribute. <br>  Yes, we still have to perform a number of operations, but the <b>key point, like the main point of the article, is that we don‚Äôt touch the function arguments and return values</b> .  Those.  even though the original declaration changes somewhat, one can guarantee with sufficient confidence that it is correct, since all types and indirection level of pointers remain unchanged.  If we forget to clean something, it will not compile, but if it is compiled, the result will be correct because the "signatures" do not change. <br></li><li>  <b>Function Pointers</b> : Crutches start here.  We declare an interface with one method, and when converting a type library, we will convert such interfaces into delegates.  Thus, we still will not touch the arguments, and the rest of the code using this pointer will not produce compilation errors. <br>  Those.  for example this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LRESULT</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CALLBACK* WNDPROC)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span></span>;</code> </pre>  would look like this: <br><pre> <code class="cpp hljs">[uuid(C17B0B13<span class="hljs-number"><span class="hljs-number">-6E49</span></span><span class="hljs-number"><span class="hljs-number">-4268</span></span>-B699<span class="hljs-number"><span class="hljs-number">-2</span></span>D083BAE88F9) interface WNDPROC : __Delegate { <span class="hljs-function"><span class="hljs-function">LRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WNDPROC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span></span>; }</code> </pre>  In this case, __Delegate is an empty interface declared by us, by which we will distinguish such a ‚Äúfunction pointer‚Äù from ordinary interfaces.  The uuid attribute contains a random value (so as not to conflict with anything), simply without it will not compile.  Of course, it would be possible to replace all function pointers with void *, but thanks to this hack we will keep strict typing, for example, the WNDPROC lpfnWndProc field of the WNDCLASSEX structure in the type library will also be strongly typed, and <u>we only need information about the type name and indirection level of pointers</u> , because the fact that this interface doesn't matter. <br></li><li>  <b>Bit fields</b> : Although this applies to structures, I have put them in a separate paragraph, because here I will also have to be cunning.  It is necessary to each in any way bind information about the number of bits.  For example, you can do this with arrays.  And in order to understand that this is a bit field when converting a type library, add some unnecessary attribute.  For example this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DWRITE_LINE_BREAKPOINT</span></span></span><span class="hljs-class"> {</span></span> UINT8 breakConditionBefore : <span class="hljs-number"><span class="hljs-number">2</span></span>; UINT8 breakConditionAfter : <span class="hljs-number"><span class="hljs-number">2</span></span>; UINT8 isWhitespace : <span class="hljs-number"><span class="hljs-number">1</span></span>; UINT8 isSoftHyphen : <span class="hljs-number"><span class="hljs-number">1</span></span>; UINT8 padding : <span class="hljs-number"><span class="hljs-number">2</span></span>; };</code> </pre>  declare as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DWRITE_LINE_BREAKPOINT</span></span></span><span class="hljs-class"> {</span></span> [replaceable] UINT8 breakConditionBefore[<span class="hljs-number"><span class="hljs-number">2</span></span>]; [replaceable] UINT8 breakConditionAfter[<span class="hljs-number"><span class="hljs-number">2</span></span>]; [replaceable] UINT8 isWhitespace[<span class="hljs-number"><span class="hljs-number">1</span></span>]; [replaceable] UINT8 isSoftHyphen[<span class="hljs-number"><span class="hljs-number">1</span></span>]; [replaceable] UINT8 padding[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } DWRITE_LINE_BREAKPOINT;</code> </pre>  And for simplicity, we agree that if there are bit fields in the structure, then there should not be any ordinary fields there.  Then these ads: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 : <span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f1; } TEST;</code> </pre>  It will be necessary to convert to: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 : <span class="hljs-number"><span class="hljs-number">31</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f1; } TEST;</code> </pre>  But bit fields are a very big rarity, because in principle they could not have been supported at all, but replaced by the base type and already in C # do everything else manually: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f1; } TEST;</code> </pre><br></li></ul><br>  The above should be enough to transfer information about everything you might need when working with native libraries to IDL.  Of course, different classes and templates for C ++ are not taken into account here, but in any case, ninety-five percent of the contents of the header files from the Windows API can be transferred in this way.  Despite the presence of several dirty hacks, copying to IDL is still easier, faster and safer than writing wrappers in CLI or manually typing types in .NET. <br><br><h4>  Ads in C # </h4><br>  Consider now how it should look like in C #. <br><br>  We will generate unsafe code.  Firstly, for strict typing of pointers, secondly, in order not to drive data back and forth all there Marshal.PtrToStructure.  Not so much because of catching fleas on performance, but simply because with racially-correct pointers the code is stupidly simpler.  The marshalling of complex types cannot be made laconically otherwise - it will be tons of code.  I tried all the options and for a very long time I tried to find a <u>universal</u> way of not using unsafe code.  It is not there, and the refusal of unsafe is a stick in its wheels - the code will not become safer and safer, but problems will be added. <br><br>  The difference is best seen when you need to pass a structure to a function that contains a pointer to another structure, or to a string, or generally a recursive reference.  And if in the unmanaged code one pointer will then be replaced with another one and it is necessary that these changes affect the original structure in the managed code ... then even custom marshaling will not help much.  Yes, and by the way, the MarshalAs attribute is not needed and will not be used. <br><br>  In addition, the <b>use of imported ads will be as close as possible to that in C</b> , which may be able to facilitate the transfer of already written code.  It should be immediately noted that in C # to get the address of a variable, it must have a <a href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx">blittable</a> -type.  All our structures will meet these requirements.  We declare fields with arrays as fixed, for strings we will use char * / byte *, but the bool type is not blittable, so in our case we will use a structure with an int field and implicit operators to cast from / to bool to represent it.  It is necessary to dwell on the arrays inside the structures.  There are restrictions: firstly, the fixed keyword is applicable only to arrays of primitive types, therefore arrays of structures are not so declared, and secondly, only one-dimensional arrays are supported.  Regular arrays (with the MarshalAs attribute and the SizeConst option) can contain structures, but they are not blittable-type, besides they can also be only one-dimensional.  To solve this problem, for arrays we will create special structures with private fields according to the number of elements.  Such structures will have an indexer property for accessing the elements, as well as implicit operators for copying from / to managed arrays.  Pseudo-multidimensionality will be provided through access on several indices.  Those.  A 4x4 matrix will be a structure with 16 fields, and the indexer property will take the address of the first element and calculate the offset using the following formula: index1 * length1 + index2, where length1 is 4, and both indexes are numbers from 0 to 3. <br><ul><li>  Structures and associations: Structures as structures, nothing special.  For LayoutKind.Explicit and FieldOffset (0) for all fields.  Of particular note is anonymous fields with structures and associations.  The fact is that type libraries do not support this, instead they will be assigned generated names starting with __MIDL__. <br>  Structure <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; } TEST;</code> </pre><br>  In fact, it will be something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MIDL___MIDL_itf_Win32_0001_0001_0001</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; } __MIDL____MIDL_itf_Win32_0001_00010000; } TEST;</code> </pre>  Accordingly, if imported into C # as is, we get the following: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TEST { [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> __MIDL___MIDL_itf_Win32_0001_0001_0001 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> __MIDL___MIDL_itf_Win32_0001_0001_0001 __MIDL____MIDL_itf_Win32_0001_00010000; }</code> </pre>  In principle, it would be with him, but access to the field i in C is performed directly, as if this is the field of the main structure, i.e.  myVar.i, and here will be a creepy myVar.  __MIDL ____ MIDL_itf_Win32_0001_00010000.i.  It is not suitable, so for such cases we will generate properties for access directly to the fields of nested unnamed structures: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TEST { [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> __MIDL___MIDL_itf_Win32_0001_0001_0001 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> __MIDL___MIDL_itf_Win32_0001_0001_0001 __MIDL____MIDL_itf_Win32_0001_00010000; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __MIDL____MIDL_itf_Win32_0001_00010000.i; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { __MIDL____MIDL_itf_Win32_0001_00010000.i = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre>  Perhaps this approach is not without flaws, but it allows you to achieve maximum matching ads and correctly handle for example such structures: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f2; }; }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c1; } TEST;</code> </pre>  Accessing directly through the properties will allow working with the structure in almost the same way as in C. The only exception is the case when the address of the nested fields is necessary, then you have to specify the full path. <br></li><li>  Enumerations.  Everything is simple, only minor differences in syntax. <br></li><li>  Bit fields  They will look like this - an integer private variable (the type depends on the total size of the structure with bit fields) and the generated properties that perform bit operations to read / set only the corresponding bits: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DWRITE_LINE_BREAKPOINT { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> __bit_field_value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> breakConditionBefore { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((__bit_field_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { __bit_field_value = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> breakConditionAfter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((__bit_field_value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { __bit_field_value = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); } } ... }</code> </pre><br></li><li>  Function declarations imported from a DLL: As usual, the static extern methods with the DllImport attribute in the NativeMethods class </li><li>  Alias ‚Äã‚Äãtypes declared via typedef: If IDL did not randomly add any extra attributes, then alias will be replaced with the type itself when compiling the type library (see <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms221152(v%3Dvs.85).aspx">here</a> ).  And if all the same they get there, then we substitute the type that they represent instead. </li><li>  Constants: constants in the NativeConstants class.  Strings or numbers. </li><li>  Pointers to functions (which are in the form of special interfaces): We generate 2 main types: the delegate and the structure that will be the pointer itself.  In the structure, one private field is of type void *.  And through the implicit operator, implicitly cast the types from / to the delegate by calling Marshal.GetFunctionPointerForDelegate and Marshal.GetDelegateForFunctionPointer </li><li>  Interfaces: It would seem that everything is simple - I declared an interface with the ComImport attribute and it's in the bag, and in the Marshal class in bulk of methods for additional functionality. <br>  But no, it only works for COM interfaces.  And we can easily return something that does not inherit IUnknown.  For example IXAudio2Voice.  <b>And here the standard .NET mechanisms will tell you the "quack".</b>  Well, it's not scary, in stock there is a cunning knight's move - we will generate virtual method tables ourselves and call them through Marshal.GetFunctionPointerForDelegate and Marshal.GetDelegateForFunctionPointer.  There is nothing special here - the interfaces will be represented by structures, inside of which there are private structures with a set of pointers.  For each interface function, the main structure generates a method that calls the corresponding pointer via Marshal.GetDelegateForFunctionPointer.  As well as a set of implicit operators to support type casting in the case of interface inheritance.  An example would take too much space to bring it here, so everything can be viewed in the attached archive. <br></li></ul><br><br><h4>  Conversion utility </h4><br>  With theory on it all.  We proceed to practice. <br><br>  For the conversion of IDL into a type library, the midl compiler included in the Windows SDK will be responsible. <br><br>  For converting a type library to C # code will be answered by its own utility (but from it we will also run the compiler). <br><br>  I'll start with the second.  To read the contents of the type library, the standard ITypeLib2 and ITypeInfo2 interfaces are used.  Documentation can be found <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms221442(v%3Dvs.85).aspx">here</a> .  They are also used in the tlbimp utility.  The implementation of the converter is nothing interesting, so there is nothing more to tell about it.  The source code in the attached archive (and yes, I know that there are libraries for generating C # code, but it's easier without them). <br><br>  Now about compiling IDL. <br><br>  Copy the compiler files into a separate folder.  Firstly, because they will have to be modified, and secondly, in order to get rid of the Windows 8.1 SDK and not to write anywhere else any absolute paths like C: \ Program Files (x86) \ blablabla. <br>  The following files will be needed: <br>  C: \ Program Files (x86) \ Microsoft Visual Studio 12.0 \ VC \ bin \ amd64 \ 1033 \ clui.dll <br>  C: \ Program Files (x86) \ Microsoft Visual Studio 12.0 \ VC \ bin \ amd64 \ c1.dll <br>  C: \ Program Files (x86) \ Microsoft Visual Studio 12.0 \ VC \ bin \ amd64 \ cl.exe <br>  C: \ Program Files (x86) \ Microsoft Visual Studio 12.0 \ VC \ bin \ amd64 \ mspdb120.dll <br>  C: \ Program Files (x86) \ Windows Kits \ 8.1 \ bin \ x64 \ midl.exe <br>  C: \ Program Files (x86) \ Windows Kits \ 8.1 \ bin \ x64 \ midlc.exe <br>  All but clui.dll dump in one pile.  A clui.dll should be located in a subfolder of 1033. <br><br>  The process midl.exe starts another process - midlc.exe, which does all the work. <br><br>  The compiler requires the presence of a file named oaidl.idl anywhere within reach, with the IUnknown interface declared there.  For convenience of configuration, we will create a copy of this file and copy the main declarations there from the original oaidl.idl and the files to which it refers.  Although it can be limited to only the interface IUnknown, and add the rest of the ads already in use.  Place the resulting file next to the compiler. <br>  It is necessary that some of the system types will have to be corrected a little.  For example, BOOL and BOOLEAN are needed in the form of structures with one field so as not to mess with int and byte, but to support casting such a structure to bool (which, as mentioned above, is not a blittable type and therefore cannot be directly used).  It is also necessary to declare the base interface in the same place for the types denoting pointers to functions. <br><br><h4>  <s>Compiler bug fixes</s> Bypassing compiler limitations </h4><br>  The following feature was a barrel of tar: <a href="http://support.microsoft.com/default.aspx%3Fscid%3Dkb%3Ben-us%3B220137">http://support.microsoft.com/default.aspx?scid=kb;en-us;220137</a> .  Microsoft is positioning it as a feature.  On the one hand, it is logical - the main purpose of type libraries is OLE Automation, which implies support for case-insensitive languages.  On the other hand, to put it mildly, the implementation is strange - there is no connection between argument names and method or type names, why use one global list of strings instead of separate lists for type names, separate lists for method names in each type, etc.?  In any case, such a ‚Äúby design‚Äù does not suit us, because the result is a monstrous cesspool in the names, and even with automatic testing (see below) there will be problems, since this requires an exact correspondence of the names to those in the source files. <br><br>  Register-independent string comparisons are usually even the most notorious Indians rarely write from scratch, so the API function is very likely to be used. <br><br>  Armed with a debugger, we observe practical confirmation of the behavior described in KB220137: <br><br>  Inside the compiler there is a global dictionary in which strings with names are added.  If the string ‚Äúmsg‚Äù (for example, as an argument in any function) is found in the file, it will be added to the dictionary.  If the string ‚ÄúMsg‚Äù appears in the source file later (for example, the structure name), then the presence of this string in the dictionary will be performed using CompareStringA and the NORM_IGNORECASE flag.  The check will return the result that the strings are the same, the text ‚ÄúMsg‚Äù will be ignored and the compiler to the type library in both cases (both the argument name and the structure name) will write ‚Äúmsg‚Äù, although in fact they are not connected in any way.  This logic is executed depending on the value of the global variable. <br><br>  In addition, COM objects from oleaut32.dll (ICreateTypeLib, ICreateTypeInfo, etc.) are used to create a file with a type library, which also use CompareStringA to check for duplicate names.  ,  ICreateTypeInfo::SetVarName   TYPE_E_AMBIGUOUSNAME           .                    . <br><br>      ‚Äì   CompareStringA     dwCmpFlags  NORM_IGNORECASE. <br><br> Midlc.exe  CompareStringA  kernel32.dll,      CompareStringA  kernelbase.dll,  oleaut32.dll   CompareStringA  kernelbase.dll.      ,    . <br><br>   :       ,   ,   ,     ,        .        : <a href="http://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x86-x64-API-Hooking-Libra">http://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x86-x64-API-Hooking-Libra</a> (      ‚Äì    <a href="http://en.wikipedia.org/wiki/C_(programming_language)"> </a>     ). <br><br>      DLL      midlc.exe       .        DllMain. <br><br>      ,     ,    <a href="http://www.ntcore.com/exsuite.php">http://www.ntcore.com/exsuite.php</a> .   CFF Explorer   exe     Import Adder      -    (      ,       )   Rebuild Import Table  . <br><br><h4>     </h4><br>        build-event-    T4.        .           C#    .    IDL .         T4    IDL      midl-,         T4.    ,            ,      .   -    IDL      <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* &lt;#@ include file="..\InternalTools\TransformIDL.tt" #&gt; */</span></span></code> </pre>    IDL   TextTemplatingFileGenerator   Custom Tool. <br><br>      ‚Äì       . C#           T4-     .    T4   ,       ,    <u>           </u> . <br><br>  ,     .idl       . <br><br>     T4        (  ~64),           ‚ÄúCompiling transformation: An expression is too long or complex to compile ‚Äù.          : <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;# #&gt;</span></span></code> </pre><br><br><h4>  Settings </h4><br>          ,         IDL .     IUnknown.              ,      .                   IDL     . <br><br><h4>  Testing </h4><br>    : <br><ul><li>     DLL </li><li>   </li><li>      </li></ul><br>           ,       32    64  . <br><br>     .   99%    4 .          int  . <br><br>         native .       CLI (32  64).    managed-        .     : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRUCT_SIZES \ {\ { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">L"ARRAYDESC"</span></span></span><span class="hljs-meta">, sizeof(::ARRAYDESC) },\ { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">L"BLOB"</span></span></span><span class="hljs-meta">, sizeof(::BLOB) },\ { NULL, 0 }\ }\ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRUCT_OFFSETS \ {\ { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">L"ARRAYDESC.tdescElem"</span></span></span><span class="hljs-meta">, FIELD_OFFSET(::ARRAYDESC, tdescElem) },\ { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">L"ARRAYDESC.tdescElem.lptdesc"</span></span></span><span class="hljs-meta">, FIELD_OFFSET(::ARRAYDESC, tdescElem.lptdesc) },\ { NULL, 0 }\ }\</span></span></code> </pre>   : <br><pre> <code class="cpp hljs">STRUCT_SIZE structSizes[] = STRUCT_SIZES; STRUCT_OFFSET structOffsets[] = STRUCT_OFFSETS;</code> </pre>         ! <br><br>         Dictionary&lt;string, int&gt;.            .   ‚Äì     ' '  ,   ‚Äì     . <br><br>     32  64  ,      .        C#.            managed ,    Marshal.SizeOf  Marshal.OffsetOf. <br><br>    dll    LoadLibrary  GetProcAddress.   ,    ,             IDL. <br><br>          .         #include      ,   . <br><br>      ‚Äì VisualStudio      32-  64- .    .               ,        . <br><br>         - .              FieldOffset    (        ),   .  Here is an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SOCKET_ADDRESS_LIST</span></span></span><span class="hljs-class"> {</span></span> INT iAddressCount; SOCKET_ADDRESS Address[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } SOCKET_ADDRESS_LIST;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In x64, the Address array will have an offset of 8, i.e. after the iAddressCount field, padding of 4 bytes is required. At x86 it should not be. Analog in .NET will be aligned to 4 bytes on both platforms. The knight‚Äôs tricky move is as follows:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SOCKET_ADDRESS_LIST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { INT iAddressCount; [hidden] <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ___padding000; }; SOCKET_ADDRESS Address[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } SOCKET_ADDRESS_LIST;</code> </pre>      ,   ,    .NET      ‚Äì     4   32-   8   64-,   ‚Äú‚Äù   4    64- . <br>       (  #pragma pack(2)  x86  #pragma pack(16)  64)    ‚Äî 99%        1 ,    . <br><br>       x86  x64,  WSADATA.       .      ,      . <br><br>  That's all.         . <br>      ,  midl  .     VisualStudio    (  64- ). <br><br> <a href="https://github.com/HermanKirshin/PInvokeFromIDL">  </a> </div><p>Source: <a href="https://habr.com/ru/post/202282/">https://habr.com/ru/post/202282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202272/index.html">iCity is a virtual city that nobody cares about. Post Mortem to an internal startup</a></li>
<li><a href="../202274/index.html">Width of table columns or when browsers lie</a></li>
<li><a href="../202276/index.html">In-ear headphones: all about them</a></li>
<li><a href="../202278/index.html">Video surveillance in the countryside via 3G Internet</a></li>
<li><a href="../202280/index.html">Clustering web applications hosted by Amazon Web Services</a></li>
<li><a href="../202284/index.html">A brief overview of the console market</a></li>
<li><a href="../202288/index.html">Enyo 2. Introduction</a></li>
<li><a href="../202290/index.html">Cache static</a></li>
<li><a href="../202292/index.html">The first hackathon in Alpha Bank. From the scene</a></li>
<li><a href="../202300/index.html">ABBYY Lingvo.Pro: manage terminology in the clouds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>