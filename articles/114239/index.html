<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quantum Leaps QP and UML statecharts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 This article, I think, will be of interest to those who are familiar with UML state and sequence diagrams (statecharts diagram and sequence...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quantum Leaps QP and UML statecharts</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  This article, I think, will be of interest to those who are familiar with UML state and sequence diagrams (statecharts diagram and sequence diagram), as well as <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">event-oriented programming</a> (event-driven programming). <br><br><h4>  Introduction </h4><br>  The <a href="http://www.state-machine.com/downloads/index.php">QP</a> (Quantum Platform) cross-platform framework from <a href="http://www.state-machine.com/">Quantum Leaps</a> is presented by its creators as a tool for developing RTOS in C / C ++.  It will significantly increase the speed of development and reliability of applications, and also has a powerful toolkit for debugging and logging.  To all this, the fact that QP is very flexible and easy is added: it is divided into many modules, almost each of which can be implemented by building the framework itself or using the proposed solution;  A lot of settings are done during precompilation. <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage/habraeffect/23/e3/23e3d64e8733c9278e0bb51c3abf2fd1.jpg" alt="QP-components"><br><br>  A program written using QP is an implementation of a collection of UML statecharts state diagrams. <br>  The article is an implicit consideration of the QEP module, which is the basis of the framework (QEP implements event processing), and is written with the aim of encouraging further study. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Event handling system in QP </h4><br>  For the implementation of state diagrams, QP provides a UML-compatible event processing system.  But you should pay attention to one circumstance: only local transitions are supported by the framework, i.e. the transition to the substate is not accompanied by an exit event, and the transition to the superstate does not trigger the entry event.  In UML 2, for compatibility with previous versions, it was possible to make external transitions.  In earlier versions of the language, only external transitions are available: any transition is accompanied by an exit and entry event for the current and target states, respectively. <br><br><img src="https://habrastorage.org/storage/habraeffect/57/df/57dfd29f4c2109a4a7c4a7142916e4d8.png" alt="image"><br><br>  QP developer offers the following classes: <br>  <b>QFsm</b> for the implementation of a single-level finite state machine (without superstate) <br>  <b>QHsm</b> for implementing a hierarchical automaton (with superstates) <br>  The objects of these classes store the current state of the UML diagram, and have a public <code><font color="#0000ff">void</font> dispatch <font color="#008000">(</font> <font color="#0000ff">const</font> QEvent <font color="#000040">*</font> e <font color="#008000">)</font></code> method <code><font color="#0000ff">void</font> dispatch <font color="#008000">(</font> <font color="#0000ff">const</font> QEvent <font color="#000040">*</font> e <font color="#008000">)</font></code> for handling the event. <br>  QP also provides the <b>QActive</b> class, which by default is a <b>QHsm</b> extension (can be changed to <b>QFsm</b> ).  Objects of this class, called active objects, realize the possibility of an automaton operating in a separate execution thread. <br><br>  An event in QP is objects of the <b>QEvent</b> class or its heirs.  Each event is characterized by a signal ‚Äî the <i>sig</i> field, which distinguishes one type of event from another. <br><br>  A state in QP is a function (or a static method), the pointer to which has the form: <br>  <code><font color="#0000ff">typedef</font> QState <font color="#008000">(</font> <font color="#000040">*</font> QStateHandler <font color="#008000">)</font> <font color="#008000">(</font> <font color="#0000ff">void</font> <font color="#000040">*</font> me, QEvent <font color="#0000ff">const</font> <font color="#000040">*</font> e <font color="#008000">)</font></code> , where <i>me</i> is the context (automaton object), <i>e</i> is the incoming event <br><br>  The framework provides for the state three main ways to handle events: <br><ul><li>  <i>Q_HANDLED ()</i> if you just need to handle the event without making the transition; </li><li>  <i>Q_TRAN (&lt;address of the next state&gt;)</i> - make the transition; </li><li>  <i>Q_SUPER (&lt;superstate address&gt;)</i> - pass to the superstate.  Available only for QHsm machines. </li></ul><br>  QP also has special events that can be generated during the transition.  The order of occurrence of these events and the sequence of actions when making the transition are as follows: <br><ol><li>  atomic transition actions are performed; </li><li>  exit event ( <i>Q_EXIT_SIG</i> ).  Occurs in the current state when exiting.  If, in addition, there is an exit from the super-state, then an exit for this super-state occurs immediately after the exit for the current one.  The exit event can only be processed ( <i>Q_HANDLED</i> ); </li><li>  the machine goes to the target state; </li><li>  event entry ( <i>Q_ENTRY_SIG</i> ).  Occurs when entering the state.  This event can only be processed; </li><li>  an event with a <i>Q_INIT_SIG</i> signal (only for <b>QHsm</b> machines) is an initiating event.  Always arises.  It serves to make a transition ( <i>Q_TRAN</i> ) to a substate, but in principle it can also be easily processed; </li></ol><br>  General view of <b>QFsm</b> states: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">static</font> QState state1(Fsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> EVENT1_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;state2); <br> } <br> <font color="#0000ff">case</font> EVENT2_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> Q_EXIT_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> } <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  General view of <b>QHsm</b> states: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">static</font> QState state1(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> Q_INIT_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;state1_substate1); <font color="#008000">// return Q_HANDLED();</font> <br> } <br> <font color="#0000ff">case</font> EVENT1_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_TRAN(&amp;state2); <br> } <br> <font color="#0000ff">case</font> EVENT2_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> Q_EXIT_SIG: { <br> <font color="#008000">/* processing */</font> <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;superstate1); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Special events of type <i>Q_ENTRY_SIG</i> , <i>Q_INIT_SIG</i> , <i>Q_EXIT_SIG</i> exist within one state and are not delegated to the super state, they are not necessary to process them. <br><br><h4>  Example </h4><br>  Consider a system with one active object ( <i>sm</i> ) and one-sided impact on it.  In this case, you can do without the use of the multitasking module (QK) and the <b>QActive</b> class. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/67/88/67885ee2b65678d826039f7c6fc247c2.png"></a> <br><br>  Let <i>sm</i> be a state diagram that is a hierarchical finite automaton. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/cb/40/cb40ddaac942737335400718aa449020.png"></a> <br><br>  This is how you can accomplish this task using QP: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// </font> <br> <font color="#0000ff">enum</font> Signals { <br> PROCEED_SIG = Q_USER_SIG, <br> CANCEL_SIG, <br> }; <br> <br> <font color="#008000">//  ,   PROCEED_SIG</font> <br> <font color="#0000ff">struct</font> ProceedEvt : <font color="#0000ff">public</font> QEvent { <br> ProceedEvt( <font color="#0000ff">int</font> <font color="#0000ff">value</font> = 0) : <font color="#0000ff">value</font> ( <font color="#0000ff">value</font> ) { sig = PROCEED_SIG; } <br> <font color="#0000ff">int</font> <font color="#0000ff">value</font> ; <br> }; <br> <br> <font color="#008000">//  ,   CANCEL_SIG</font> <br> <font color="#0000ff">struct</font> CancelEvt : <font color="#0000ff">public</font> QEvent { <br> CancelEvt() { sig = CANCEL_SIG; } <br> }; <br> <br> <font color="#008000">//    sm</font> <br> <font color="#0000ff">class</font> Hsm : <font color="#0000ff">public</font> QHsm { <br> <font color="#0000ff">public</font> : <br> Hsm() : QHsm((QStateHandler)&amp;initial) { init(); } <br> <br> <font color="#0000ff">private</font> : <br> <font color="#008000">//  initial state</font> <br> <font color="#0000ff">static</font> QState initial(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">return</font> Q_TRAN(&amp;superState); <br> } <br> <br> <font color="#0000ff">static</font> QState superState(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> Q_ENTRY_SIG: { <br> me-&gt;count = 10; <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> Q_INIT_SIG: { <br> <font color="#0000ff">return</font> Q_TRAN(&amp;stateA); <br> } <br> <font color="#0000ff">case</font> CANCEL_SIG: { <br> <font color="#0000ff">return</font> Q_TRAN(&amp;stateC); <br> } <br> } <br> <br> <font color="#008000">/* QHsm::top -   ,</font> <br> <font color="#008000">*    Q_HANDLED(). */</font> <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br> <br> <font color="#0000ff">static</font> QState stateA(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> PROCEED_SIG: { <br> <font color="#0000ff">return</font> Q_TRAN(&amp;stateB); <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;superState); <br> } <br> <br> <font color="#0000ff">static</font> QState stateB(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> PROCEED_SIG: { <br> <font color="#0000ff">if</font> (me-&gt;count &gt; 1) { <br> me-&gt;count *= 2; <br> <font color="#0000ff">return</font> Q_TRAN(&amp;stateA); <br> } <br> ++me-&gt;count; <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> <font color="#0000ff">case</font> Q_EXIT_SIG: { <br> cout &lt;&lt; <font color="#A31515">"count = "</font> &lt;&lt; me-&gt;count &lt;&lt; endl; <br> me-&gt;count = 0; <br> <font color="#0000ff">return</font> Q_HANDLED(); <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;superState); <br> } <br> <br> <font color="#0000ff">static</font> QState stateC(Hsm* me, <font color="#0000ff">const</font> QEvent* e) { <br> <font color="#0000ff">switch</font> (e-&gt;sig) { <br> <font color="#0000ff">case</font> PROCEED_SIG: { <br> <font color="#0000ff">if</font> (static_cast&lt; <font color="#0000ff">const</font> ProceedEvt*&gt;(e)-&gt; <font color="#0000ff">value</font> == 1) { <br> <font color="#0000ff">return</font> Q_TRAN(&amp;superState); <br> } <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <font color="#0000ff">return</font> Q_SUPER(&amp;QHsm::top); <br> } <br> <br> <font color="#0000ff">int</font> count; <br> };</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Now we will create the <i>sm</i> object of the <b>Hsm</b> class (see the sequence diagram above) and process a dozen events: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> * argv[]) { <br> Hsm sm; <font color="#008000">// stateA, count = 10</font> <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; 2; ++i) { <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 10</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateA, count = 0</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 0</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 1</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 2</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateA, count = 0</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 0</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 1</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateB, count = 2</font> <br> sm.dispatch(&amp;CancelEvt()); <font color="#008000">// stateC, count = 2</font> <br> sm.dispatch(&amp;CancelEvt()); <font color="#008000">// stateC, count = 2</font> <br> sm.dispatch(&amp;ProceedEvt()); <font color="#008000">// stateC, count = 2</font> <br> sm.dispatch(&amp;ProceedEvt(1)); <font color="#008000">// stateA, count = 10</font> <br> } <br> <br> <font color="#0000ff">return</font> 0; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Conclusion </h4><br>  The rest of the UML statecharts are: initial, final, history, deep history and other pseudostates;  deferred event processing, the orthogonal state component, the hidden state, and so on ‚Äî are quite simply implemented with the help of ‚Äústate design patterns‚Äù, five of which are listed in the book, which I will discuss below. <br><br><h5>  QP benefits </h5><ul><li>  The principle of use in C is almost the same as C ++; </li><li>  is opensource, the source is well commented; </li><li>  QP has already been ported to many systems, in particular to GNU Linux systems; </li><li>  there is a QM state diagram modeling tool from Quantum Leaps; </li><li>  Quantum Leaps products are quite large <a href="http://www.state-machine.com/about/customers.php">companies</a> . </li></ul><br><h5>  About the book </h5><br>  QP comes with a big book ‚ÄúPractical UML Statecharts in C / C ++, Second Edition: Event-Driven Programming for Embedded Systems‚Äù from the <a href="http://www.linkedin.com/in/samek">founder of</a> Quantum Leaps, which is divided into 2 parts: the first one talks about how to use the framework, and the second is about how it works, how to sharpen a QP for your system, how to use a QS tracer (QSpy), and what a QP-nano is. <br><br>  Also in the tutorial are comparisons of the use of the framework, the state pattern and the switch method. <br><br>  The book is worth the money, but can be found on the Internet for the request "download for free." <br><br><h5>  Links </h5><ul><li>  <a href="https://github.com/dizel3d/habr/tree/qp1">here are</a> examples of the article; </li><li>  <a href="https://github.com/dizel3d/qpcpp">here is the</a> 32-bit QP port for GNU Linux x64. </li></ul><br></div><p>Source: <a href="https://habr.com/ru/post/114239/">https://habr.com/ru/post/114239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114233/index.html">Interface for selecting a location without using directories using Google maps</a></li>
<li><a href="../114234/index.html">Layout mailing: debriefing</a></li>
<li><a href="../114235/index.html">Reactable for iPhone and iPad</a></li>
<li><a href="../114237/index.html">Steering wheel for PC based on Wii Remote</a></li>
<li><a href="../114238/index.html">BIT-2011: Make an investor believe in you!</a></li>
<li><a href="../114240/index.html">MWC 2011: we are waiting for your questions!</a></li>
<li><a href="../114242/index.html">Clothes for the princess</a></li>
<li><a href="../114243/index.html">Huawei offers free coverage of the London Underground with a mobile network.</a></li>
<li><a href="../114244/index.html">Software generation of DOM 2 Events</a></li>
<li><a href="../114246/index.html">The first device under Chrome OS enters the European market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>