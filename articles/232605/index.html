<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>fork () vs. vfork ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Listen up 
 After all, if the stars are lit - it means - is it necessary for someone? 

 V.V. Mayakovsky, 1914 

 I do programming for embedded system...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>fork () vs. vfork ()</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Listen up <br>  After all, if the stars are lit - it means - is it necessary for someone? <br><br>  V.V. Mayakovsky, 1914 </blockquote><br><img align="right" src="https://habrastorage.org/files/9a7/afd/af0/9a7afdaf0c124d59aaeac70392fbb053.png"><br>  I do programming for embedded systems, and decided to write this article in order to better understand the problem of using the <i>fork ()</i> and <i>vfork ()</i> system calls.  The second of them is often advised not to use, but it is clear that he appeared for a reason. <br><br>  Let's see when and why it is better to use this or that challenge. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a bonus, the description of <i>vfork ()</i> / <i>fork ()</i> implementations in <a href="http://code.google.com/p/embox/">our project</a> will be given.  First of all, my interest is connected with the use of these calls in embedded systems, and the main feature of these implementations is the absence of virtual memory.  Perhaps habrovchane well versed in system programming and embedded systems, will give advice and share experiences. <br><br>  Who cares, I ask under the cat. <br><a name="habracut"></a><br>  Let's start with the definition, that is, the POSIX standard, in which these functions are defined: <br><br>  <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fork.html"><i>fork ()</i></a> creates an exact copy of the process with the exception of a few variables.  If successful, the function returns zero to the child process and the number of the child process to the parent (the processes then begin to ‚Äúlive their life‚Äù). <br><br>  <a href="http://pubs.opengroup.org/onlinepubs/009604599/functions/vfork.html"><i>vfork () is</i></a> defined as <i>fork ()</i> with the following restriction: the behavior of the function is not defined if the process created with its help performs at least one of the following actions: <br><ul><li>  Will return from the function in which <i>vfork ()</i> was called; </li><li>  Call any function except <i>_exit ()</i> or <i>exec * ()</i> ; </li><li>  Changes any data except the variable that stores the value returned by the <i>vfork ()</i> function. </li></ul><br>  In order to understand why there is a system call at all with such strong limitations, you need to figure out what an exact copy of the process is. <br><br>  <a href="http://citforum.ru/operating_systems/articles/process.shtml">One of the first links</a> in the search engine for this topic in Russian is the description of the cloning parameters of processes in Linux.  It follows that some parameters can be made common for the parent and child processes: <br><ul><li>  Address space (CLONE_VM); </li><li>  File system information (CLONE_FS); </li><li>  Open file table (CLONE_FILES); </li><li>  Table of signal handlers (CLONE_SIGHAND); </li><li>  Parent process (CLONE_PARENT). </li></ul><br>  In POSIX for <i>vfork (),</i> it is not allowed to change variables, and this suggests that it is a matter of cloning the address space.  <a href="http://window.edu.ru/resource/660/18660/files/unix.pdf">This link</a> confirms the assumption: <br><blockquote>  Unlike <i>fork ()</i> , <i>vfork ()</i> does not create a copy of the parent process, but creates an address space that is shared with the parent process until the <i>_exit</i> function or one of the <i>exec</i> functions is called. <br>  The parent process at this time stops its execution.  All the restrictions on use follow from this ‚Äî the child process cannot change any global variables or even common variables that are shared with the parent process. </blockquote><br>  In other words, if this statement is true, after calling <i>vfork ()</i> both processes will see the same data. <br>  Let's do an experiment.  If this is true, then the changes made to the data of the child process must be visible in the parent process, and vice versa. <br><br><div class="spoiler">  <b class="spoiler_title">Code testing assumption.</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> common_variable; common_variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; pid = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span> == pid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errno; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> common_variable = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_SUCCESS); } waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (common_variable) { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"vfork(): common variable has been changed."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"fork(): common variable hasn't been changed."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create_process(); }</code> </pre> </div></div><br>  If you build and run this program, we get the output: <br>  <i>fork (): common variable hasn't been changed.</i> <br><br>  When replacing <i>fork ()</i> with <i>vfork ()</i> , the output will change: <br>  <i>vfork (): common variable has changed.</i> <br><br>  Many use this property when transferring data between processes, although the behavior of such programs is not defined by POSIX.  This is likely to create problems that make it advised not to use <i>vfork ()</i> . <br><br>  Indeed, one thing is when a developer consciously changes the value of some variable, and quite another when he forgets that the child process cannot, for example, return from the function in which <i>vfork ()</i> was called (because it will destroy the stack structure of the parent process !)  And even acting consciously, as usual, you use undocumented features at your own risk. <br><br>  But a couple of less obvious problems: <br><ul><li>  The book <i>‚ÄúSecure Programming for Linux and Unix HOWTO‚Äù</i> <a href="http://www.dwheeler.com/secure-class/Secure-Programs-HOWTO/avoid-vfork.html">says</a> that even if a child does not really change any data in a high-level language code, it may not be so in computer code (for example, due to the appearance of hidden temporary variables). </li><li>  This <a href="http://ewontfix.com/7/">blog</a> analyzes the following question: what if <i>vfork ()</i> is called in a multithreaded application?  Consider the <i>vfork ()</i> implementation in Linux: the manual says that the parent process stops when it is called, but in fact it only happens with the current thread (which, of course, is easier to implement).  This means that the child process continues to run in parallel with other threads that may, for example, change the rights of the parent process.  And here everything will become very bad: we will get two processes with different rights in the same address space, which opens a security hole. </li></ul><br>  Now consider the functions of <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html">the <i>exec *</i> family</a> .  Only they (apart from <i>_exit ()</i> ) can be called in the process obtained with <i>vfork ()</i> .  They create a new address space, and then load the code and data from the specified file into it.  In this case, the old address space, in fact, is destroyed. <br>  Therefore, if the process is created using <i>fork ()</i> and then calls <i>exec * ()</i> , creating (copying) the address space when calling <i>fork ()</i> was redundant, and this is quite a laborious operation, and it may take the most time to call <i>fork. ()</i>  In Wikipedia, for example, this moment is given the most attention, and, unlike the standard, <a href="http://en.wikipedia.org/wiki/Fork_%2528system_call%2529">it is directly stated</a> : <br><blockquote>  Space for the child.  Copy of the parent process. </blockquote><br>  Of course, on most modern systems with virtual memory, no copying takes place; all pages in the memory of the parent process are simply flagged with <i>copy-on-write</i> .  However, at the same time you need to go over the entire hierarchy of tables, and this takes time. <br><br>  It turns out that the <i>vfork ()</i> call should execute faster than <i>fork ()</i> , which is also mentioned in the <a href="http://www.linuxmanpages.com/man2/vfork.2.php">LinuxMan page</a> . <br><br>  We will conduct another experiment and make sure that this is true.  Let's slightly change the previous example: add a loop to create 1000 processes, remove the common variable and display it on the screen. <br><br><div class="spoiler">  <b class="spoiler_title">The resulting code.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/types.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/wait.h&gt; static int create_process(void) { pid_t pid; int status; pid = vfork(); if (-1 == pid) { return errno; } if (pid == 0) { /* child */ exit(EXIT_SUCCESS); } waitpid(pid, &amp;status, 0); return EXIT_SUCCESS; } int main(void) { int i; for (i = 0; i &lt; 1000; i ++) { create_process(); } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  Run through the time command. <br><table><tbody><tr><td>  Output when using <i>fork ()</i> </td><td>  Output when using <i>vfork ()</i> </td></tr><tr><td><pre> <code class="bash hljs">real 0m0.135s user 0m0.000s sys 0m0.052s</code> </pre> </td><td><pre> <code class="bash hljs">real 0m0.028s user 0m0.000s sys 0m0.016s</code> </pre> </td></tr></tbody></table><br>  The result, to put it mildly, is impressive.  From launch to launch, the data will differ slightly, but still <i>vfork ()</i> will be 4 to 5 times faster. <br><br>  The conclusions are as follows: <br>  <i>fork ()</i> is a more ‚Äúheavy‚Äù call, and if <i>vfork ()</i> can be called, it is better to use it. <br>  <i>vfork ()</i> is a less secure call, and it‚Äôs easier to shoot yourself in the foot, and, accordingly, it should be applied intelligently. <br>  <i>fork ()</i> / <i>vfork ()</i> should be used where you need to create separate resources for the process (inodes, user, working folder), otherwise it is worth working with pthread *, which work even faster. <br>  <i>It is</i> better to use <i>fork ()</i> when you really need to create a separate address space.  However, it is very difficult to implement on small processor platforms without hardware support for virtual memory. <br><br>  Before turning to the second part of the article, I note that in POSIX there is a function <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/posix_spawn.html"><i>posix_spawn ()</i></a> .  This function, in fact, contains <i>vfork ()</i> and <i>exec ()</i> , and therefore avoids the problems associated with <i>vfork ()</i> , in the absence of re-creating the address space as in <i>fork ()</i> . <br><br>  Now let's move on to our <i>fork ()</i> / <i>vfork ()</i> implementation without MMU support. <br><br><h1>  Vfork implementation </h1><br>  Implementing <i>vfork ()</i> in our system, we assumed that the <i>vfork ()</i> call should occur like this: the parent goes into standby mode, and the first of <i>vfork ()</i> returns the child process, waking up the parent when calling the <i>_exit ()</i> or <i>exec * ()</i> function.  This means that a descendant can be executed on the parent stack, but with its own resources of other types: inodes, signal table, and so on. <br><br>  The storage of various types of resources in our project is a task ( <i>struct task</i> ).  It is this structure that describes all the resources of the process, including the available memory, inodes, and the list of threads that belong to this process.  A task always has a main thread - the one that is created when it is initialized.  The flow in our system is called the object of planning, more about this - <a href="http://habrahabr.ru/post/219431/">in the article of my colleague</a> .  Since the stack is controlled by a thread, not a task, we can offer two options for implementation: <br><ul><li>  Change the stack in the newly created thread to the parent's stack; </li><li>  ‚ÄúReplace‚Äù a task with a new one for the same execution thread </li></ul><br>  One way or another, the task will have to be created, or rather, to inherit it from the parent one: a clone of the signal table, environment variables, and so on will be made.  Address space, however, will not be inherited. <br><br>  Return from <i>vfork ()</i> will be performed twice: for the parent and child processes.  It means that the registers of the stack frame from which <i>vfork ()</i> was called should be saved somewhere.  You cannot do this on the stack, since the child process can wipe these values ‚Äã‚Äãat runtime.  However, the <i>vfork ()</i> signature does not imply the presence of some kind of buffer, so first the registers are stored on the stack, and only then - somewhere in the parent task.  Saving registers on the stack could be done using a system call, but we decided to do without it and did it ourselves.  Naturally, the <i>vfork ()</i> function is written in assembler. <br><div class="spoiler">  <b class="spoiler_title">Code for i386 architecture.</b> <div class="spoiler_text"><pre> <code class="hljs perl">vfork: subl $28, %esp; pushl %ds; pushl %es; pushl %fs; pushl %gs; pushl %eax; pushl %ebp; pushl %edi; pushl %esi; pushl %edx; pushl %ecx; pushl %ebx; movl PT_END(%esp), %ecx; movl %ecx, PT_EIP(%esp); pushf; popl PT_EFLAGS(%esp); movl %esp, %eax; addl $PT_END+<span class="hljs-number"><span class="hljs-number">4</span></span>, %eax; movl %eax, PT_ESP(%esp); <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> %esp; call vfork_body</code> </pre> </div></div><br>  Thus, the registers are first stored on the stack, and then the C- <i>shny</i> function <i>vfork_body () is</i> called.  As an argument, it is passed a pointer to a structure with a set of registers. <br><div class="spoiler">  <b class="spoiler_title">The mentioned structure for i386.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pt_regs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Pushed by SAVE_ALL. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ebx; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ecx; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> edx; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> esi; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> edi; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ebp; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fs; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> es; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ds; <span class="hljs-comment"><span class="hljs-comment">/* Pushed at the very beginning of entry. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> trapno; <span class="hljs-comment"><span class="hljs-comment">/* In some cases pushed by processor, in some - by us. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> err; <span class="hljs-comment"><span class="hljs-comment">/* Pushed by processor. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eip; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cs; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eflags; <span class="hljs-comment"><span class="hljs-comment">/* Pushed by processor, if switching of rings occurs. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> esp; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ss; } <span class="hljs-keyword"><span class="hljs-keyword">pt_regs_t</span></span>;</code> </pre> </div></div><br>  The <i>vfork_body ()</i> code is architecturally independent.  He is responsible for creating the task and saving the registers needed to exit. <br><div class="spoiler">  <b class="spoiler_title">Function code vfork_body ().</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__((noreturn)) vfork_body(struct pt_regs *ptregs) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">child</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child_pid; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; <span class="hljs-comment"><span class="hljs-comment">/* can vfork only in single thread application */</span></span> assert(thread_self() == task_self()-&gt;tsk_main); <span class="hljs-comment"><span class="hljs-comment">/* create task description but not start its main thread */</span></span> child_pid = task_prepare(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; child_pid) { <span class="hljs-comment"><span class="hljs-comment">/* error */</span></span> ptregs_retcode_err_jmp(ptregs, <span class="hljs-number"><span class="hljs-number">-1</span></span>, child_pid); panic(<span class="hljs-string"><span class="hljs-string">"vfork_body returning"</span></span>); } child = task_table_get(child_pid); <span class="hljs-comment"><span class="hljs-comment">/* save ptregs for parent return from vfork() */</span></span> task_vfork = task_resource_vfork(child-&gt;parent); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;task_vfork-&gt;ptregs, ptregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(task_vfork-&gt;ptregs)); res = vfork_child_start(child); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Could not start child process */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Exit child task */</span></span> vfork_child_done(child, vfork_body_exit_stub, &amp;res); <span class="hljs-comment"><span class="hljs-comment">/* Return to the parent */</span></span> ptregs_retcode_err_jmp(&amp;task_vfork-&gt;ptregs, <span class="hljs-number"><span class="hljs-number">-1</span></span>, -res); } panic(<span class="hljs-string"><span class="hljs-string">"vfork_body returning"</span></span>); }</code> </pre> </div></div><br>  A few explanations to the code. <br>  First, a multithreading check occurs (problems associated with it when using <i>vfork ()</i> , discussed above).  Then a new task is created, and if it succeeds, the registers are saved in it to return from <i>vfork ()</i> . <br>  After that, the <i>vfork_child_start ()</i> function is <i>called</i> , which, as the name implies, ‚Äústarts‚Äù the child process.  The quotes here are not random, as in fact the task can be launched later, it all depends on the specific implementation, of which there are two in our project.  Before proceeding to their description, consider the functions <i>_exit ()</i> and <i>exec * ()</i> . <br>  When they are called, the parent thread must be unblocked.  We will say that at this very moment a full-fledged launch of the child process occurs as a separate entity in the system. <br><br><div class="spoiler">  <b class="spoiler_title">Execv function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save starting arguments for the task */</span></span> task = task_self(); task_resource_exec(task, path, argv); <span class="hljs-comment"><span class="hljs-comment">/* if vforked then unblock parent and start execute new image */</span></span> vfork_child_done(task, task_exec_callback, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div>  Other functions of the <i>exec *</i> family are expressed through the <i>execv ()</i> call. <br><br><div class="spoiler">  <b class="spoiler_title">Function code _exit ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _exit(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">;</span></span> task = task_self(); vfork_child_done(task, task_exit_callback, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)status); task_start_exit(); { task_do_exit(task, TASKST_EXITED_MASK | (status &amp; TASKST_EXITST_MASK)); kill(task_get_id(task_get_parent(task)), SIGCHLD); } task_finish_exit(); panic(<span class="hljs-string"><span class="hljs-string">"Returning from _exit"</span></span>); }</code> </pre> </div></div><br>  As can be seen from the above code, in order to unlock the parent process, the <i>vfork_child_done ()</i> function is used with the handler as one of the parameters.  To implement a particular algorithm, the work must be implemented: <br><ul><li>  <i>vfork_child_start ()</i> - the function called at the beginning of the cloning process should block the parent process; </li><li>  <i>vfork_child_done ()</i> is a function that is called upon the final start of the child process, the parent process is unlocked; </li><li>  <i>task_exit_callback ()</i> - a handler for completing a child process; </li><li>  <i>task_exec_callback ()</i> - a handler for the full launch of the child process. </li></ul><br><br><h1>  First implementation </h1><br>  The idea of ‚Äã‚Äãthe first implementation is to use the same control flow besides the same stack.  In fact, in this case, you only need to ‚Äúreplace‚Äù the task for the current thread with the child one until the child task finally starts when you call <i>vfork_child_done ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Function code vfork_child_start ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_child_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct task *child)</span></span></span><span class="hljs-function"> </span></span>{ thread_set_task(thread_self(), child); <span class="hljs-comment"><span class="hljs-comment">/* mark as vforking */</span></span> task_vfork_start(child); <span class="hljs-comment"><span class="hljs-comment">/* Restore values of the registers and return 0 */</span></span> ptregs_retcode_jmp(&amp;task_resource_vfork(child-&gt;parent)-&gt;ptregs, <span class="hljs-number"><span class="hljs-number">0</span></span>); panic(<span class="hljs-string"><span class="hljs-string">"vfork_child_start returning"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> </div></div><br>  The following happens: the current execution thread (that is, the parent thread) is bound to the child process by the <i>thread_set_task ()</i> function ‚Äî for this, it suffices to change the corresponding pointer in the structure of the current thread.  This means that when accessing resources associated with a task, the thread will refer to the child's task, and not to the parent, as before.  For example, when a thread tries to find out which task a thread belongs to (the <i>task_self ()</i> function), it will receive a child task. <br><br>  After this, the child task is marked as created as a result of <i>vfork</i> , this flag will be needed in order for the <i>vfork_child_done ()</i> function to be executed as needed (more details - a little later). <br>  Then the registers saved by the <i>vfork ()</i> call are restored.  Recall that according to POSIX, the <i>vfork ()</i> call should return a value of zero to the child process, which is done by calling <i>ptregs_retcode_jmp (ptregs, 0)</i> . <br><br>  As already mentioned, when the child process <i>calls the</i> <i>_exit ()</i> or <i>execv ()</i> function, the <i>vfork_chlid_done ()</i> function must unblock the parent stream.  In addition, you need to prepare a child task for executing the required handler. <br><br><div class="spoiler">  <b class="spoiler_title">Function code vfork_child_done ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_child_done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct task *child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * (*run)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vfork_data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!task_is_vforking(child)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } task_vfork_end(child); task_start(child, run, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); thread_set_task(thread_self(), child-&gt;parent); vfork_data = task_resource_vfork(child-&gt;parent); ptregs_retcode_jmp(&amp;vfork_data-&gt;ptregs, child-&gt;tsk_id); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Handler code task_exit_callback ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_exit_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ _exit((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)arg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Handler code for task_exec_callback ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_exec_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; res = exec_call(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)res; }</code> </pre> </div></div><br>  When calling <i>vfork_child_done (),</i> you must consider the case of using <i>exec ()</i> / <i>_exit ()</i> without <i>vfork ()</i> - then you just need to exit the current function, because there is no need to unlock the parent, and you can immediately proceed to launch the child.  If the process was created using <i>vfork ()</i> , the following is done: first, the <i>is_vforking</i> flag is <i>removed</i> from the child task using <i>task_vfork_end ()</i> , then, finally, the main thread of the child task starts.  The entry point is the <i>run</i> function, which should be one of the handlers described earlier ( <i>task_exec_callback</i> , <i>task_exit_callback</i> ) - they are necessary when implementing <i>vfork ()</i> .  After that, the thread‚Äôs belonging to the task changes: instead of the child, the parent is specified again.  Finally, it returns to the parent task from the <i>vfork ()</i> call with the child process ID as the return value.  As mentioned above, this is done by calling <i>ptregs_retcode_jmp ()</i> . <br><br><h1>  The second implementation of vfork </h1><br><br>  The idea of ‚Äã‚Äãthe second implementation is to use the parent stack with a new thread that was created with the new task.  This is obtained automatically if the registers previously saved in the parent stream are restored in the child stream.  In this case, you can use this synchronization between threads, as described in the <a href="http://habrahabr.ru/post/219431">already mentioned article</a> .  This is certainly more beautiful, but also more difficult to implement, because when the parent thread is waiting, its descendant will be executed on the same stack.  This means that for the waiting time, you need to switch to some intermediate stack, where you can safely wait for the call of a child of <i>_exit ()</i> or <i>exec * ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">The vfork_child_start function code for the second implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_child_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct task *child)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class">;</span></span> task_vfork = task_resource_vfork(task_self()); <span class="hljs-comment"><span class="hljs-comment">/* Allocate memory for the new stack */</span></span> task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = sysmalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EAGAIN; } task_vfork-&gt;child_pid = child-&gt;tsk_id; <span class="hljs-comment"><span class="hljs-comment">/* Set new stack and go to vfork_waiting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!setjmp(task_vfork-&gt;env)) { CONTEXT_JMP_NEW_STACK(vfork_waiting, task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>)); } <span class="hljs-comment"><span class="hljs-comment">/* current stack was broken, can't reach any old data */</span></span> task_vfork = task_resource_vfork(task_self()); sysfree(task_vfork-&gt;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>); ptregs_retcode_jmp(&amp;task_vfork-&gt;ptregs, task_vfork-&gt;child_pid); panic(<span class="hljs-string"><span class="hljs-string">"vfork_child_start returning"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> </div></div><br>  Explanation of the code: <br>  First, space is allocated for the stack, after that the <i>pid</i> (process ID) of the child is saved, since it will be required by the parent to return from <i>vfork ()</i> . <br>  Calling <i>setjmp ()</i> will return to the stack location where <i>vfork ()</i> was called.  As already mentioned, the wait must be performed on some intermediate stack, and the switch is performed using the <i>CONTEXT_JMP_NEW_STACK ()</i> macro, which changes the current stack and transfers control to the <i>vfork_waiting ()</i> function.  It will activate the child and block the ancestor before calling <i>vfork_child_done ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Vfork_waiting code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_waiting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ochildsa</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">child</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_vfork</span></span></span><span class="hljs-class">;</span></span> parent = task_self(); task_vfork = task_resource_vfork(parent); child = task_table_get(task_vfork-&gt;child_pid); vfork_wait_signal_store(&amp;ochildsa); { task_vfork_start(parent); task_start(child, vfork_child_task, &amp;task_vfork-&gt;ptregs); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (SCHED_WAIT(!task_is_vforking(parent))); } vfork_wait_signal_restore(&amp;ochildsa); longjmp(task_vfork-&gt;env, <span class="hljs-number"><span class="hljs-number">1</span></span>); panic(<span class="hljs-string"><span class="hljs-string">"vfork_waiting returning"</span></span>); }</code> </pre> </div></div><br>  As can be seen from the code, first of all the table of signals of the child process is saved.  In fact, the <a href="http://ru.wikipedia.org/wiki/SIGCHLD"><i>SIGCHLD</i></a> signal will be redefined, which is sent when the status of the child process changes.  In this case, it is used to unlock the parent. <br><br><div class="spoiler">  <b class="spoiler_title">New SIGCHLD handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_parent_signal_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">siginfo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *siginfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *context)</span></span></span><span class="hljs-function"> </span></span>{ task_vfork_end(task_self()); }</code> </pre> </div></div><br>  Saving and restoring the signal table is done using the POSIX call <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/sigaction.html"><i>sigaction ()</i></a> . <br><br><div class="spoiler">  <b class="spoiler_title">Saving the handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_wait_signal_store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct sigaction *ochildsa)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa</span></span></span><span class="hljs-class">;</span></span> sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = vfork_parent_signal_handler; sigemptyset(&amp;sa.sa_mask); sigaction(SIGCHLD, &amp;sa, ochildsa); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Recovery handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_wait_signal_restore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sigaction *ochildsa)</span></span></span><span class="hljs-function"> </span></span>{ sigaction(SIGCHLD, ochildsa, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> </div></div><br>  After replacing the signal handler, the task is marked as being in the standby mode, in which it will remain until the present launch of the child task when calling <i>_exit ()</i> / <i>exec * ()</i> .  The <i>vfork_child_task ()</i> function is used as the entry point to the task, which restores previously saved registers and returns from <i>vfork ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Function code vfork_child_task ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vfork_child_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pt_regs</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ptregs</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">;</span></span> ptregs_retcode_jmp(ptregs, <span class="hljs-number"><span class="hljs-number">0</span></span>); panic(<span class="hljs-string"><span class="hljs-string">"vfork_child_task returning"</span></span>); }</code> </pre> </div></div><br>  When calling <i>_exit ()</i> and <i>exec * (),</i> <i>SIGCHLD</i> will be sent, and the handler of this signal will uncheck waiting for the child to run.  After that, the old <i>SIGCHLD</i> signal handler will be restored, and the control will be returned to the <i>vfork_child_start ()</i> function using <i>longjmp ()</i> .  It must be remembered that the stack frame of this function will be damaged after the execution of the child process, therefore local variables will contain not what is needed.  After releasing the previously allocated stack, the <i>vfork ()</i> function returns the number of the child task. <br><br><h1>  Vfork health check </h1><br>  To check the correct behavior of <i>vfork (),</i> we wrote a set of tests covering several situations. <br><br>  Two of them check for a valid return from <i>vfork ()</i> when calling <i>_exit ()</i> and <i>execv () as a</i> child process. <br><div class="spoiler">  <b class="spoiler_title">First test</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TEST_CASE(<span class="hljs-string"><span class="hljs-string">"after called vfork() child call exit()"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> parent_pid; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; parent_pid = getpid(); pid = vfork(); <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns -1, an error happened. */</span></span> test_assert(pid != <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns 0, we are in the child process. */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); } wait(&amp;res); test_assert_not_equal(pid, parent_pid); test_assert_equal(getpid(), parent_pid); }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Second test</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TEST_CASE(<span class="hljs-string"><span class="hljs-string">"after called vfork() child call execv()"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> parent_pid; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; parent_pid = getpid(); pid = vfork(); <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns -1, an error happened. */</span></span> test_assert(pid != <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(<span class="hljs-number"><span class="hljs-number">0</span></span>); close(<span class="hljs-number"><span class="hljs-number">1</span></span>); close(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns 0, we are in the child process. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (execv(<span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { test_assert(<span class="hljs-number"><span class="hljs-number">0</span></span>); } } wait(&amp;res); test_assert_not_equal(pid, parent_pid); test_assert_equal(getpid(), parent_pid); }</code> </pre> </div></div><br>  Another test checks the use of the same stack by the parent and child processes. <br><div class="spoiler">  <b class="spoiler_title">Third test</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TEST_CASE(<span class="hljs-string"><span class="hljs-string">"parent should see stack modifications made from child"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> pid; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; data = <span class="hljs-number"><span class="hljs-number">1</span></span>; pid = vfork(); <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns -1, an error happened. */</span></span> test_assert(pid != <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) { data = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* When vfork() returns 0, we are in the child process. */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); } wait(&amp;res); test_assert_equal(data, <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> </div></div><br><br>  However, I would like to check the correctness of the work on some real, and third-party, program, and for this, a fairly well-known <i>dropbear</i> package was <i>chosen</i> .  When configured, it checks for <i>fork ()</i> , and if it does not find it, it can use <i>vfork ()</i> .  Immediately I would like to say that this was done in order to support <i>ucLinux</i> , and not in order to improve performance. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OS was configured accordingly (for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dropbear to</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vfork ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to successfully connect to both implementations.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d9a/fcd/1d9/d9afcd1d9bae4bdead1aa45648f16c44.png"></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Also in </font></font><a href="https://code.google.com/p/embox"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our project we</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> managed to implement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork () itself</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> without using the MMU, at the moment an article is being compiled about it.</font></font></div><p>Source: <a href="https://habr.com/ru/post/232605/">https://habr.com/ru/post/232605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232595/index.html">To listen to music or not - that is the question</a></li>
<li><a href="../232597/index.html">Bookmarking Services: General Considerations and Problem Solving Example</a></li>
<li><a href="../232599/index.html">FPGA timing analysis or how I mastered Timequest</a></li>
<li><a href="../232601/index.html">Major vulnerability in WordPress and Drupal can put a site</a></li>
<li><a href="../232603/index.html">Magento step by step: REST API</a></li>
<li><a href="../232609/index.html">Escape from the office, or how we started developing our mobile game. Part 1</a></li>
<li><a href="../232613/index.html">Prospects for the development of speech recognition systems (excerpt from the study)</a></li>
<li><a href="../232615/index.html">Made with IBM: Where are IBM technologies used?</a></li>
<li><a href="../232619/index.html">In Windows 9, the Charms panel disappears and virtual desktops appear.</a></li>
<li><a href="../232623/index.html">Why is it so difficult to estimate development time (plus a task for developers)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>