<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Machine learning: what you need to know about creating strategies for trading on the exchange. Part IV</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© and in the analytical section of our site, we write a lot about financial market trends and continue to publish a series of materials on the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Machine learning: what you need to know about creating strategies for trading on the exchange. Part IV</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/itinvest/blog/281603/"><img src="https://habrastorage.org/files/da7/d55/565/da7d55565fe04e89a0e21e1e51ea42ad.jpg"></a> <br><br>  On Habr√© and in the <a href="http://www.itinvest.ru/analytics/">analytical section of our site,</a> we write a lot about financial market trends and continue to publish a series of materials on the creation of strategies for trading on the exchange, based on the articles of the author of the blog Financial Hacker.  In previous topics, we talked about the <a href="https://habrahabr.ru/company/itinvest/blog/279321/">use of</a> market <a href="https://habrahabr.ru/company/itinvest/blog/279321/">inefficiencies</a> on the example of a history with a price limit for the Swiss franc, considered <a href="https://habrahabr.ru/company/itinvest/blog/280059/">important factors</a> affecting the effectiveness of the strategy, and <a href="https://habrahabr.ru/company/itinvest/blog/281148/">discussed</a> general principles for developing model-oriented trading systems. <br><br>  Today we will talk about the <a href="http://www.financial-hacker.com/build-better-strategies-part-4-machine-learning/">use of</a> technology for these purposes date mining and machine learning. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In 1996, the computer Deep Blue first won the world chess champion.  It took another 20 years and the program AlphaGo won the series with the best player in <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE">Go</a> , losing only one game.  Deep Blue was a model-based system with a rigid set of chess rules.  AlphaGo uses Data Mining technology.  This is a neural network trained on the examples of thousands of Go games.  Unlike chess, in this game the choice of options is so huge that brute force does not help.  Therefore, the breakthrough did not occur due to the improvement of the hardware, but only thanks to the new software. <br><br>  Today we will look at the approach to using data mining to develop trading strategies that do not imply an in-depth analysis of market mechanisms.  Instead, it uses information from the price curve and other sources to search for predictable anomalies.  Machine learning or ‚Äúartificial intelligence‚Äù is not always an indispensable part of such a strategy.  In practice, the most popular and most successful application of this method is to work without attracting heaped neural networks or the support vector machine. <br><br><h4>  Principles of machine learning </h4><br>  At the core of the learning algorithm is the concept of patterns.  This is usually historical price data.  Each pattern consists of n variables x1 ... xn, usually called prediction markers (predictors) or simply parameters.  Such predictors can be the price return of the last n-divisions or a set of classical indicators, as well as any other functions of the price curve.  Each template includes a target value of y ‚Äî for example, the profit of the next transaction after the template is applied or the next price movement.  During the learning process, the algorithm learns how to get the target value based on the predictors.  This knowledge is stored in a data structure called in our case a model that is individual for each algorithm.  This model can be a function of the C language, which describes the prediction rules developed in the learning process.  Or it could be a set of connections in a neural network. <br><br><blockquote>  Training: <b>x1 ... xn, y</b> =&gt; model <br>  Prediction: <b>x1 ... xn</b> , model =&gt; <b>y</b> </blockquote><br>  Predictors must carefully process the information that is needed to predict the target value.  They must meet two formal conditions: all values ‚Äã‚Äãof these markers must be of the same order (for example, -1 ... +1 for algorithms on R or -100 ... +100 for algorithms in the Zorro language).  This means that before sending to the trading ‚Äúengine‚Äù they need to be normalized.  Secondly, the templates must be balanced, that is, evenly distributed over all values ‚Äã‚Äãof the target value.  There should be as many templates describing the winning option as losing. <br><br>  Regression algorithms predict numeric values, such as the value of the next price change.  Classification algorithms generate a class of quality templates.  For example, related to profit or loss.  A number of neural network algorithms or support vectors can work simultaneously in both versions.  Some algorithms do not need a target value to divide the templates into classes.  This is the so-called unsupervised learning, as opposed to the usual with a teacher (supervised learning). <br><br>  Whatever signals we use as financial predictions as markers, most of them will contain a lot of noise and little useful information.  Therefore, financial forecasting is the most difficult task in machine learning.  More complex algorithms do not always give a better result.  For ultimate success, the choice of predictors is critical.  In this case, the strategy of predictive analysis provides a preliminary selection algorithm that selects several useful prediction markers from a variety of options.  This selection can take place on the basis of their correlation, significance, or simply those that have passed the test. <br><br>  Next we will talk about the most popular methods of intellectual analysis used in the world of finance. <br><br><h4>  Trial and error method </h4><br>  Most of the trading systems that the company author of the blog Financial Hacker develops for its clients are not originally based on a financial model.  The customer wants to receive signals for transactions, based on specific technical indicators, filtered through indicators using even more technical indicators.  Usually, no one can really answer the question of how this mess of indicators can be a working strategy.  The answer is usually: ‚ÄúJust believe.  I have been trading by hand for many years now, and everything works. ‚Äù <br><br>  In fact, everything is.  At least in some cases.  Although many of these systems were not passed forward analysis (some - even an elementary backtest), most cope well with their tasks.  The client systematically experiments with technical indicators until he finds the right combination that works in the real market with the selected assets.  Trial and error is a classic mining approach.  It is simply made by man, not by machine.  Sometimes it gives a good result. <br><br><h4>  Candlestick patterns </h4><br>  It makes no sense to dwell on the analysis of outdated techniques, such as <a href="http://www.financial-hacker.com/seventeen-popular-trade-strategies-that-i-dont-really-understand/">Japanese candlestick patterns</a> , which were popular 200 years ago.  The modern equivalent of candlestick patterns is an indicatorless price action analysis.  In it, traders are still trying to find a pattern that predicts price movement.  But in this case, they analyze the current price curves.  For this purpose there is a set of special programs.  They select suitable patterns according to the criteria set by the user and use them to build a function.  On the Zorro system, this might look like this: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Function C returns 1 when the signal matches one of the patterns.  Otherwise, the value is 0. Using this code, you can see that this is not the fastest way to search for patterns.  Alternatively, first sort the signals by their value, then check the sort order. <br><br>  Even despite the use of data mining techniques, such price trading should have some rational basis.  One can imagine that certain sequences of price movements lead to a certain reaction of market participants.  This will be the prediction pattern.  The number of patterns will always be limited if you look closely at the sequence of adjacent candles.  The next step is to compare candles that are at a distance from each other.  We choose them arbitrarily for a sufficiently long period of time.  In this case, the number of patterns can be limitless.  But here it is easy to lose ground.  At the same time, it is difficult to imagine that the price movement can be predicted by the candlestick pattern of a week ago.  But in general, the task of finding candlestick patterns is extremely complex and fraught with many errors. <br><br><h4>  Linear regression </h4><br>  The meaning of the work of most complex machine learning algorithms is simple: you need to predict the variable target value y through a linear combination of predictors <b>x1 ... xn</b> . <br><br><img src="http://1460635481837712219577" alt="image"><br><br>  The coefficient a <sub>n is</sub> calculated to minimize the sum of squares of differences between the true value of y of the training pattern and the predicted values ‚Äã‚Äãof y using the following formula: <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_969_ed7856c03aaa30b3d00de2c31ce55dcb.png" alt="image"><br><br>  For a normal distribution of patterns, minimization is possible through a mathematical matrix, so no iteration is required.  In the case of <b>n = 1</b> with one predictor variable x, the regression formula is simplified to: <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_991.5_35d7546102a7d24475fdd489ddca9873.png" alt="image"><br><br>  This is a simple linear regression.  It is used on most trading platforms.  If y = price, and x = time, then it is often used as an alternative to moving averages.  There is also a polynomial regression, when there is still one predictor x, but there are also x2 and to a higher degree.  Thus, x <sub>n</sub> == x <sup>n</sup> . <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_982_5a129547c5d192400f5b0e9893da0bdb.png" alt="image"><br><br><h4>  Perception </h4><br>  Often this method is considered as a neural network with one neuron.  In fact, perception is the same regression function that we discussed above.  But with a binary result.  Therefore, it is also called logistic regression.  Although, in essence, this is a classification algorithm.  The <code>advise(PERCEPTRON, ‚Ä¶)</code> function <code>advise(PERCEPTRON, ‚Ä¶)</code> in Zorro generates a C code that makes a return of 100 or -100, depending on whether the predicted result is within or outside the specified threshold. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre><br>  This fragment shows that the sig array is equivalent to our prediction markers x <sub>n</sub> in the regression formula, and the numerical factors are the coefficients a <sub>n</sub> . <br><br><h4>  Neural networks </h4><br>  Linear or logistic regression can solve only linear problems.  Many simply do not work with this category of questions.  The artificial neural network (INS) is designed to solve non-linear problems.  It is a bundle of perceptrons connected in a set of layers.  Each of them is a neuron network.  Here are the input and output of such a network: <br><br><img src="http://www.texample.net/media/tikz/examples/PNG/neural-network.png" alt="image"><br><br>  The neural network is trained through coefficient recognition, which minimizes the discrepancy between the prediction template and the target template.  But now we need to use the approximation process as well.  It is usually used together with the back propagation method of error from the input data to the output, optimizing the load along the way. <br><br>  This process places two limitations.  First, neural outputs now have to be continuously differentiated functions, instead of just being perceptor thresholds.  Second: the network should not be too deep; too many hidden layers between inputs and outputs should be avoided.  This, of course, limits the complexity of the problems that a simple neural network can solve. <br><br>  If you use a neural network for trading, then you need to vary and change many parameters.  Negligence in handling them can lead to being distorted: <br><br><ul><li>  the number of hidden layers; </li><li>  the number of neurons for each hidden layer; </li><li>  the number of backward cycles, or epochs; </li><li>  learning speed, step width of one era; </li><li>  momentum; </li><li>  activation function. </li></ul><br>  The activation function simulates the perceptor threshold.  For back propagation of an error, a continuously differentiable function is needed that generates a ‚Äúsoft‚Äù step for a certain value of x.  For this, the functions <code>sigmoid</code> , <code>tanh</code> , or <code>softmax</code> are commonly used.  In our example, the function can be used to regress and predict numeric values ‚Äã‚Äãinstead of binary output. <br><br><h4>  Deep learning </h4><br>  If we are talking about a lot of hidden layers and thousands of neurons, then this is already a deep learning.  Here the standard back distribution does not work.  In the past few years there have been several popular methods of teaching such a huge system.  Usually they include the stage of pre-learning of hidden layers to achieve the desired effect.  One of the options is the Boltzmann machine, an uncontrolled classification algorithm with a special network structure where there are no connections between hidden neurons.  Sparse Autoencoder is another option; it uses the standard network structure and prepares hidden layers through the reproduction of input signals for the output of layers with as few active connections as possible.  Such methods already allow to solve serious problems.  Well, for example, to win the best go player in the world. <br><br>  Below is an example of an R script using an autoencoder with three hidden layers to determine the trading signals using the neural () function of the Zorro package: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(20,20,20), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre><br><h4>  Support Vector Machine </h4><br>  Like the neural network, the support vector machine is an advanced version of linear regression.  Take a look at this formula again: <br><br><img src="http://1460635481837712219577" alt="image"><br><br>  Prediction markers x <sub>n</sub> can be viewed as coordinates of a space with n dimensions.  By binding the target value y to a fixed value, we define a plane or, as it is also called, a hyperplane.  It separates templates with y&gt; 0 from templates with y &lt;0. The coefficient a <sub>n</sub> can be calculated as the maximum distance from the plane to the nearest template, called the reference vector.  Thus, we obtain a binary classifier with an optimal division of patterns into winning and losing ones. <br><br>  There is a small problem: usually these templates cannot be separated linearly, they are dispersed irregularly in our marker space.  We cannot put a flat plane in it.  If they could, then there is a simpler way to determine the plane - linear discriminant analysis.  But in most cases we are forced to use the trick that the support vector machine method provides: to add more dimensions to our space.  After that, the algorithm produces more markers using the kernel function, which combines any two predictors into a new marker.  The more dimensions added, the easier it is to split patterns using a hyperplane.  Then this plane is transformed back into the original space with n dimensions, overgrown with folds along the way.  In order for the kernel function not to stray and work optimally, the process must be carried out without actually calculating the parameters of such a transformation. <br><br>  The support vector method can be used not only for classification, but also for regression.  It also allows you to optimize the prediction process through the following parameters: <br><br><ul><li>  kernel function: usually use the radial basis function of the kernel, but you have a choice, you can use the polynomial, sigmoid or linear variant; </li><li>  gamma, width of the radial basis function of the nucleus; </li><li>  cost parameter C, ‚Äúfine‚Äù for incorrect classification of patterns in the learning process. </li></ul><br><h4>  Method k nearest neighbors </h4><br>  In comparison with support vectors, this is a fairly simple <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_k_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B8%25D1%2585_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25B9">algorithm</a> with a bunch of unique features.  He does not require training.  Therefore, patterns in this case is a model.  In trading systems, it allows you to learn continuously through the addition of more templates.  The method of nearest neighbors calculates the distance from the current values ‚Äã‚Äãof the markers to the nearest k-patterns.  In a space with n dimensions, this distance is calculated in the same way as in two dimensions: <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_978_e94de05774b3fd0ea092d67be51c87a5.png" alt="image"><br><br>  The algorithm simply predicts the target value based on the average value of the target variables k of the closest pattern, distributed over their inverse distances.  It can be used for both classification and regression.  The things borrowed from graphic editors (for example, an adaptive binary tree) will help to find the nearest neighbor rather quickly.  Previously, such things were often used in programming toys when it was necessary to launch self-study of the enemy‚Äôs intelligence.  You can use the knn function in R for our purposes or write your own in C. <br><br><h4>  K-medium method </h4><br>  <a href="https://ru.wikipedia.org/wiki/K-means">The k-means method</a> uses an approximation algorithm for uncontrolled classification.  It is in some way very similar to the previous method.  To separate patterns, the algorithm first places random marks k in the marker space.  Then these points are assigned all the templates that are closest to them.  Next step: these points move to the average of the nearest patterns.  And we get a new distribution of patterns, now certain patterns are getting closer to other marks.  The process is repeated until the distribution becomes unchanged.  That is, each mark will be located exactly according to the average value of the nearest templates.  Therefore, we have a class of k-patterns, each of which is in close proximity to one of the k-points.  The algorithm is simple, but it can lead to unexpectedly good results. <br><br><h4>  Naive Bayes Classifier </h4><br>  The following algorithm uses the Bayes theorem to classify patterns according to non-numeric characters (events), in the same way as the already-discussed candlestick pattern method.  Suppose we have an event X, which manifests itself in 80% of successful template cases.  What can be learned from this?  Calculate the probability of winning a variant containing X. It will not be equal to 0.8, as might be supposed.  The effect of this probability can be calculated by the Bayesian theorem: <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_976_594a9afca73ead40d379e22238e6d835.png" alt="image"><br><br>  P (Y | X) is the probability that an event Y (win) appears in all patterns containing an event X. It will be equal to the probability of occurrence of X in all winning patterns (i.e. 0.8) multiplied by the probability of occurrence of Y in all templates (in our case, 0.5, if you carefully read the tips on balancing templates) and divided by the probability of having X in all available templates. <br><br>  If we are naive in moderation and assume that all events X are independent of each other, we can calculate the overall probability that a particular pattern will be advantageous, using the following formula, using the scaling factor s: <br><br><img src="http://www.financial-hacker.com/wp-content/plugins/wpmathpub/phpmathpublisher/img/math_959.5_bd8ef81965211d915c760a5583a05734.png" alt="image"><br><br>  In order for the formula to work, you need to separate the prediction markers so that they are as independent as possible from each other.  And this is the most important obstacle to using the Bayes theorem in trading.  In most cases, the two events will, in one way or another, depend on each other. <br><br>  The Bayesian classifier method is available in the e1071 package for R. <br><br><h4>  Decision Tree and Regression Tree </h4><br>  Both trees aim at predicting the numerical values ‚Äã‚Äãof the output, based on a series of yes / no solutions.  The answer in each case depends on the presence or absence of the event (in the variant of non-numeric features) or on the comparison of the prediction marker values ‚Äã‚Äãwith a fixed threshold.  The standard tree function on Zorro will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre><br>  How does this tree come from a set of templates?  There are several methods.  Zorro prefers the Shannon-entropy method of information.  First, it checks one of the markers, say, x1.  It establishes a hyperplane according to the formula x <sub>1</sub> = t.  This plane separates the templates with the value x <sub>1</sub> &gt; t from the templates with the value x <sub>1</sub> &lt;t.  The separation threshold t is selective, so the information gain (the ratio of the information entropy of the entire space to the sum of the information entropies of the two separated subspaces) will be maximum.  This is the case when the patterns in the subspaces are more similar to each other than the patterns in the whole space. <br><br>  Then the process starts for the next marker x <sub>2</sub> , then two hyperplanes split two subspaces.  In each case, the condition for this is to compare the marker with the threshold set.  Soon we get a branched tree with thousands of comparisons.  Following the process starts in the opposite direction, we need to prune the tree, removing all solutions that do not lead to a significant increase in information.  Finally, a relatively small tree is obtained, as in the example code above. <br><br>  The decision tree can be applied in different ways.  But it cannot be used as a solution to all problems, since its dividing planes are always parallel to the axes of the marker space.  This limits the ability to make accurate predictions.  It can also be used for regression.  For example, to determine the proportion of patterns associated with a particular branch of the tree.  The Zorro tree is a regression tree.  The most common tree classification algorithm is C5.0, available in the C50 package for R. <br><br><h4>  Conclusion </h4><br>  Today there are many different methods of intellectual analysis available to traders.  But which is more effective: model-specific strategies or machine learning strategies?  Undoubtedly, the latter have a lot of advantages.  No need to worry about the microstructure of the market, the psychology of traders and other nonsense that is not expressed in numbers.  You can concentrate on pure mathematics.  Machine learning is a more sophisticated option, a more attractive way to create a trading system.  Everything speaks in his favor.  In addition to one thing: despite the rave reviews on the forums, in live trading, all this turns out to be strangely ineffective. <br><br>  Every week in specialized editions there is a new article about methods of machine learning.  The conclusions of these articles should be treated with skepticism.  Many of them promise a fantastic return rate of 70-85% profit.  If all this were true, the number of billionaires among mathematicians would be off scale.  In reality, successful strategies based on machine learning are offensively few. <br><br><h4>  Other materials on the topic of algorithmic trading in the <a href="http://www.itinvest.ru/promo/adv/">ITinvest</a> blog: </h4><br><ul><li>  <a href="https://habrahabr.ru/post/279963/">How Big Data is Used to Analyze the Stock Market</a> </li><li>  <a href="https://habrahabr.ru/post/278023/">Experiment: the creation of an algorithm for predicting the behavior of stock indices</a> </li><li>  <a href="https://habrahabr.ru/post/276943/">GPU vs CPU: Why are GPUs used to analyze financial data</a> </li><li>  <a href="https://habrahabr.ru/post/274821/">How to predict a stock price: An adaptive filtering algorithm</a> </li><li>  <a href="https://habrahabr.ru/post/271059/">Algorithms and trading on the stock exchange: Hiding large transactions and predicting the price of shares</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/281603/">https://habr.com/ru/post/281603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281593/index.html">v3.14.1592-beta2: everything you wanted to know about semantic versioning</a></li>
<li><a href="../281595/index.html">Reverse Engineering Visual Stories</a></li>
<li><a href="../281597/index.html">We write the Slack bot to get comments from VK in Python</a></li>
<li><a href="../281599/index.html">An introduction to shader programming: part 2</a></li>
<li><a href="../281601/index.html">bash + logger application warrants</a></li>
<li><a href="../281605/index.html">RESTful Visual Editor</a></li>
<li><a href="../281607/index.html">Develop HTML5 games in Intel XDK. Part 4. The system of coordinates and moving objects</a></li>
<li><a href="../281609/index.html">Create 3D CSS effects on hover using jQuery</a></li>
<li><a href="../281611/index.html">Nix as a dependency manager for C ++</a></li>
<li><a href="../281615/index.html">Oracle PaaS - present and future cloud platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>