<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Designing a RESTful API with Python and Flask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In recent years, REST (REpresentational State Transfer) has become a standard architecture in the design of web services and web APIs. 

 In this arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Designing a RESTful API with Python and Flask</h1><div class="post__text post__text-html js-mediator-article">  In recent years, REST (REpresentational State Transfer) has become a standard architecture in the design of web services and web APIs. <br><br>  In this article, I will show you how easy it is to create RESTful web services using Python and the Flask microframe. <br><br><h2>  What is REST? </h2><br>  The characteristics of the REST system are defined by the six design rules: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>Client-Server</strong> : There should be a separation between the server that offers the service and the client that uses it. </li><li>  <strong>Stateless</strong> : Each request from the client must contain all the information the server needs to fulfill the request.  In other words, the server is not required to save client status information. </li><li>  <strong>Caching</strong> : Each client request must explicitly indicate the possibility of caching the response and getting a response from the existing cache. </li><li>  <strong>Level system</strong> : The client can interact not directly with the server, but with an arbitrary number of intermediate nodes.  In this case, the client may not be aware of the existence of intermediate nodes, except for the cases of transfer of confidential information. </li><li>  <strong>Unification</strong> : Unified server software interface. </li><li>  <strong>Code on request</strong> : Servers can supply executable code or scripts to run on the client side. </li></ul><br><a name="habracut"></a><br><h2>  What is a RESTful web service? </h2><br><p>  The REST architecture is designed to conform to <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">the HTTP protocol</a> used on the Internet. </p><br><p>  Central to the concept of RESTful web services is the concept of resources.  Resources are represented by <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URIs</a> .  Clients send requests to these URIs using methods provided by the HTTP protocol, and possibly change the state of these resources. </p><br><p>  HTTP methods are designed to affect a resource in a standard way: </p><br><table><tbody><tr><th>  HTTP method </th><th>  Act </th><th>  Example </th></tr><tr><td>  Get </td><td>  Get resource information </td><td>  <a href="http://example.com/api/orders">example.com/api/orders</a> <br>  (get a list of orders) </td></tr><tr><td>  Get </td><td>  Get resource information </td><td>  <a href="http://example.com/api/orders/123">example.com/api/orders/123</a> <br>  (get order # 123) </td></tr><tr><td>  POST </td><td>  Create a new resource </td><td>  <a href="http://example.com/api/orders">example.com/api/orders</a> <br>  (create a new order from the data sent with the request) </td></tr><tr><td>  PUT </td><td>  Update resource </td><td>  <a href="http://example.com/api/orders/123">example.com/api/orders/123</a> <br>  (update order # 123 data provided with request) </td></tr><tr><td>  DELETE </td><td>  Delete resource </td><td>  <a href="http://example.com/api/orders/123">example.com/api/orders/123</a> <br>  (delete order # 123) </td></tr></tbody></table><br><br><p>  The REST design does not recommend what specifically the format of the data sent with requests should be.  The data passed in the request body can be a <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> blob, or by using arguments in the URL. </p><br><br><h2>  We design a simple web service. </h2><br><p>  When designing a web service or API, you need to determine the resources that will be available and the requests that will use this data according to the REST rules. </p><br><p>  Suppose we want to write a To Do List application and we need to design a web service for it.  The first thing we need to do is to come up with a root URL to access this service.  For example, we could come up with something like the root URL: </p><br><pre><code class="bash hljs">http://[hostname]/todo/api/v1.0/</code> </pre> <br><p>  Here I decided to include the application name and API version in the URL.  Adding the application name to the URL is a good way to share the services running on the same server.  Adding a version of the API to the URL can help if you want to upgrade in the future and introduce incompatible features in the new version and don‚Äôt want to break the running applications that run on the old API. </p><br><p>  The next step is to select the resources that will be available through our service.  We have a very simple application, we have only tasks, so our resources can only be tasks from our ToDo sheet. </p><br><p>  To access resources, we will use the following HTTP methods: </p><br><table><tbody><tr><th>  HTTP method </th><th>  URI </th><th>  Act </th></tr><tr><td>  Get </td><td>  http: // [hostname] /todo/api/v1.0/tasks </td><td>  Get task list </td></tr><tr><td>  Get </td><td>  http: // [hostname] /todo/api/v1.0/tasks/ [task_id] </td><td>  Get task </td></tr><tr><td>  POST </td><td>  http: // [hostname] /todo/api/v1.0/tasks </td><td>  Create a new task </td></tr><tr><td>  PUT </td><td>  http: // [hostname] /todo/api/v1.0/tasks/ [task_id] </td><td>  Update existing task </td></tr><tr><td>  DELETE </td><td>  http: // [hostname] /todo/api/v1.0/tasks/ [task_id] </td><td>  Delete task </td></tr></tbody></table><br><br><p>  Our task will have the following fields: </p><br><ul><li>  <strong>id</strong> : a unique identifier of the task.  Type Numeric. </li><li>  <strong>title</strong> : Brief description of the task.  String type </li><li>  <strong>description</strong> : a detailed description of the task.  Type Text. </li><li>  <strong>done</strong> : mark on the execution.  Type Boolean. </li></ul><br><br><p>  This concludes the part dedicated to the design of our service.  It remains only to realize it! </p><br><br><h2>  A brief introduction to the Flask microframe </h2><br><p>  If you read the <a href="http://habrahabr.ru/post/193242/">Flask Mega-Tutorial</a> series, you know that Flask is a simple and powerful enough Python web framework. </p><br><p>  Before we dive into the specifics of web services, let's look at how Flask applications are usually implemented. </p><br><p>  I assume that you are familiar with the basics of working with Python on your platform.  In the examples, I will use a Unix-like operating system.  In short, it means that they will work on Linux, MacOS X and even on Windows if you use <a href="http://www.cygwin.com/">Cygwin</a> .  The commands will be slightly different if you use the native version of Python for Windows. </p><br><br><p>  First, install Flask in a virtual environment.  If <code>virtualenv</code> not installed on your system, you can download it from <a href="https://pypi.python.org/pypi/virtualenv">https://pypi.python.org/pypi/virtualenv</a> . </p><br><pre> <code class="bash hljs">$ mkdir todo-api $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> todo-api $ virtualenv flask New python executable <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> flask/bin/python Installing setuptools............................done. Installing pip...................done. $ flask/bin/pip install flask</code> </pre><br><br><p>  Now that the Flask is installed, let's create a simple web application, to do this, put the following code in <code>app.py</code> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python from flask import Flask app = Flask(__name__) @app.route('/') def index(): return "Hello, World!" if __name__ == '__main__': app.run(debug=True)</span></span></code> </pre><br><br><p>  To start the application, we need to start <code>app.py</code> : </p><br><pre> <code class="bash hljs">$ chmod a+x app.py $ ./app.py * Running on http://127.0.0.1:5000/ * Restarting with reloader</code> </pre><br><br><p>  Now you can launch a web browser from type <code>http://localhost:5000</code> to see our little application in action. </p><br><p>  Simple, isn't it?  Now we will convert our application to a RESTful service! </p><br><br><h2>  Implementing a RESTful Python and Flask service </h2><br><p>  Creating a web service on Flask is surprisingly simple, much easier than building full-fledged server applications, like the one we did in the <a href="http://habrahabr.ru/post/193242/">Mega-Tutorial series</a> . </p><br><p>  There are a couple of good extensions for Flask that can facilitate the creation of RESTful services, but our task is so simple that using extensions is unnecessary. </p><br><p>  Clients of our web service will ask the service to add, delete and modify tasks, so we need an easy way to store tasks.  The obvious way to do this is to make a small database, but since the database goes beyond the topic of the article, we will do everything much easier.  To learn more about the correct use of the database with Flask, I recommend again reading my <a href="http://habrahabr.ru/post/193242/">Mega-Tutorial</a> . </p><br><br><p>  Instead of a database, we will keep a list of our tasks in memory.  This will work only if we work with the server in one thread and in one process.  Although this is normal for a development server, for a production server this would be a very bad idea and it would be better to think about using a database. </p><br><p>  Now we are ready to implement the first entry point to our web service: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python from flask import Flask, jsonify app = Flask(__name__) tasks = [ { 'id': 1, 'title': u'Buy groceries', 'description': u'Milk, Cheese, Pizza, Fruit, Tylenol', 'done': False }, { 'id': 2, 'title': u'Learn Python', 'description': u'Need to find a good Python tutorial on the web', 'done': False } ] @app.route('/todo/api/v1.0/tasks', methods=['GET']) def get_tasks(): return jsonify({'tasks': tasks}) if __name__ == '__main__': app.run(debug=True)</span></span></code> </pre><br><br><p>  As you can see, little has changed.  We created tasks in memory that are nothing more than a simple array of dictionaries.  Each record in the array has all the fields that we defined above for our tasks. </p><br><p>  Instead of using the <code>index</code> entry point, we now have a <code>get_tasks</code> function associated with the URI <code>/todo/api/v1.0/tasks</code> , for the HTTP <code>GET</code> method. </p><br><p>  Instead of text, our function sends JSON, into which Flask encodes our data structure using the <code>jsonify</code> method. </p><br><p>  Using a web browser to test a web service is not a good idea, because  Using a web browser is not so easy to generate all types of HTTP requests.  Instead, we will use <a href="http://curl.haxx.se/">curl</a> .  If you don't have <code>curl</code> installed, it‚Äôs best to do it right now. </p><br><p>  Start the web service in the same way as the demo application by running <code>app.py</code>  Now open a new console window and enter the following commands: </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 200 OK Content-Type: application/json Content-Length: 294 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 04:53:53 GMT { <span class="hljs-string"><span class="hljs-string">"tasks"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Milk, Cheese, Pizza, Fruit, Tylenol"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Buy groceries"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 2, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span> } ] }</code> </pre><br><br><p>  We just called the function of our RESTful service! </p><br><br><p>  Now let's write the second version of the GET method for our tasks.  If you look at the table above, the following will be the method that returns data from one task: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abort @app.route(<span class="hljs-string"><span class="hljs-string">'/todo/api/v1.0/tasks/&lt;int:task_id&gt;'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'GET'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task_id)</span></span></span><span class="hljs-function">:</span></span> task = filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: t[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] == task_id, tasks) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(task) == <span class="hljs-number"><span class="hljs-number">0</span></span>: abort(<span class="hljs-number"><span class="hljs-number">404</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonify({<span class="hljs-string"><span class="hljs-string">'task'</span></span>: task[<span class="hljs-number"><span class="hljs-number">0</span></span>]})</code> </pre><br><br><p>  The second function is a bit more interesting.  Here we pass the task id through the URL, and with the help of Flask we translate the <code>task_id</code> function <code>task_id</code> . </p><br><p>  With this argument we are looking for our task in the database.  If the received id is not found in the database, we will return a 404 error, which according to the HTTP specification means ‚ÄúResource Not Found‚Äù. </p><br><p>  If the task is found, we simply pack it in JSON using the <code>jsonify</code> function and send it as an answer, just as we did before sending the collection. </p><br><p>  This is what the action of this function looks like when we call it with <code>curl</code> : </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks/2 HTTP/1.0 200 OK Content-Type: application/json Content-Length: 151 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 05:21:50 GMT { <span class="hljs-string"><span class="hljs-string">"task"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 2, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span> } } $ curl -i http://localhost:5000/todo/api/v1.0/tasks/3 HTTP/1.0 404 NOT FOUND Content-Type: text/html Content-Length: 238 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 05:21:52 GMT &lt;!DOCTYPE HTML PUBLIC <span class="hljs-string"><span class="hljs-string">"-//W3C//DTD HTML 3.2 Final//EN"</span></span>&gt; &lt;title&gt;404 Not Found&lt;/title&gt; &lt;h1&gt;Not Found&lt;/h1&gt; &lt;p&gt;The requested URL was not found on the server.&lt;/p&gt;&lt;p&gt;If you entered the URL manually please check your spelling and try again.&lt;/p&gt;</code> </pre><br><br><p>  When we requested a resource with id # 2 we received it, but instead of a resource with id # 3 we received an error 404. We received such a strange error inside HTML instead of JSON, because Flask by default generates a page with error 404. Since this is a client applications will always wait for our JSON server, then we need to change this behavior: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_response @app.errorhandler(<span class="hljs-number"><span class="hljs-number">404</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">not_found</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_response(jsonify({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'Not found'</span></span>}), <span class="hljs-number"><span class="hljs-number">404</span></span>)</code> </pre><br><br><p>  So we will get a response more appropriate to our API: </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks/3 HTTP/1.0 404 NOT FOUND Content-Type: application/json Content-Length: 26 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 05:36:54 GMT { <span class="hljs-string"><span class="hljs-string">"error"</span></span>: <span class="hljs-string"><span class="hljs-string">"Not found"</span></span> }</code> </pre><br><br><p>  The following <code>POST</code> method in our list will be used to add a new task to our database: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> request @app.route(<span class="hljs-string"><span class="hljs-string">'/todo/api/v1.0/tasks'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'POST'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> request.json <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'title'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.json: abort(<span class="hljs-number"><span class="hljs-number">400</span></span>) task = { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: tasks[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'title'</span></span>: request.json[<span class="hljs-string"><span class="hljs-string">'title'</span></span>], <span class="hljs-string"><span class="hljs-string">'description'</span></span>: request.json.get(<span class="hljs-string"><span class="hljs-string">'description'</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">'done'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> } tasks.append(task) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonify({<span class="hljs-string"><span class="hljs-string">'task'</span></span>: task}), <span class="hljs-number"><span class="hljs-number">201</span></span></code> </pre><br><br><p>  Adding a new task is also quite simple.  <code>request.json</code> contains the request data, but only if it is marked as JSON.  If there is no data, or the data is in place but the value of the <code>title</code> field is missing, then the code 400 is returned, which is used to denote ‚ÄúBad Request‚Äù. </p><br><p>  Then we create a dictionary with a new task, using the id of the last task plus 1 (a simple way to ensure that the id is unique in our simple database).  We tolerate the absence of a value in the <code>description</code> field, and we assume that the <code>done</code> field when creating a task will always be <code>False</code> . </p><br><br><p>  We add a new task to our <code>tasks</code> array, then return the saved task and code 201 to the client, which in HTTP means ‚ÄúCreated‚Äù. </p><br><p>  To test a new feature, we use the following <code>curl</code> command: </p><br><pre> <code class="bash hljs">$ curl -i -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -X POST -d <span class="hljs-string"><span class="hljs-string">'{"title":"Read a book"}'</span></span> http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 201 Created Content-Type: application/json Content-Length: 104 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 05:56:21 GMT { <span class="hljs-string"><span class="hljs-string">"task"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 3, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Read a book"</span></span> } }</code> </pre><br><br><p>  Note: if you have Windows and you are using the Cygwin <code>curl</code> version of <code>bash</code> then the above command will work as expected.  If you are using the native version of <code>curl</code> from the usual command line, you'll have to podshamanit a little with double quotes: </p><br><pre> <code class="bash hljs">curl -i -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -X POST -d <span class="hljs-string"><span class="hljs-string">"{"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>title<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">":"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>Read a book<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"}"</span></span> http://localhost:5000/todo/api/v1.0/tasks</code> </pre><br><br><p>  In Windows, you use double quotes to separate the body of the request, and inside the request, double quotes to escape the third quote. </p><br><p>  Of course, after completing this request, we can get an updated list of tasks: </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 200 OK Content-Type: application/json Content-Length: 423 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 05:57:44 GMT { <span class="hljs-string"><span class="hljs-string">"tasks"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Milk, Cheese, Pizza, Fruit, Tylenol"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 1, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Buy groceries"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 2, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 3, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Read a book"</span></span> } ] }</code> </pre><br><br><p>  The remaining two functions of our web service will look like this: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['PUT']) def update_task(task_id): task = filter(lambda t: t['id'] == task_id, tasks) if len(task) == 0: abort(404) if not request.json: abort(400) if 'title' in request.json and type(request.json['title']) != unicode: abort(400) if 'description' in request.json and type(request.json['description']) is not unicode: abort(400) if 'done' in request.json and type(request.json['done']) is not bool: abort(400) task[0]['title'] = request.json.get('title', task[0]['title']) task[0]['description'] = request.json.get('description', task[0]['description']) task[0]['done'] = request.json.get('done', task[0]['done']) return jsonify({'task': task[0]}) @app.route('/todo/api/v1.0/tasks/&lt;int:task_id&gt;', methods=['DELETE']) def delete_task(task_id): task = filter(lambda t: t['id'] == task_id, tasks) if len(task) == 0: abort(404) tasks.remove(task[0]) return jsonify({'result': True})</span></span></code> </pre><br><br><p>  The <code>delete_task</code> function without surprises.  For the <code>update_task</code> function <code>update_task</code> we try to prevent errors by carefully checking the input arguments.  We must make sure that the data provided by the client is in the proper format before writing it into the database. </p><br><br><p>  The call to the task updating function with id # 2 will look like this: </p><br><pre> <code class="bash hljs">$ curl -i -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -X PUT -d <span class="hljs-string"><span class="hljs-string">'{"done":true}'</span></span> http://localhost:5000/todo/api/v1.0/tasks/2 HTTP/1.0 200 OK Content-Type: application/json Content-Length: 170 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 07:10:16 GMT { <span class="hljs-string"><span class="hljs-string">"task"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: 2, <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span> } ] }</code> </pre><br><br><h2>  We improve the interface of our service </h2><br><p>  Now the main problem with the design of our service is that customers are forced to build URIs independently based on task IDs.  This one is easy, but it gives the client knowledge of how URIs are built to access the data, which can interfere in the future if we want to make changes to the URI. </p><br><p>  Instead of the task id, we will return the full URI through which all actions with the task will be performed.  To do this, we will write a small helper function that will generate a ‚Äúpublic‚Äù version of the task sent to the client: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> url_for <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_public_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task)</span></span></span><span class="hljs-function">:</span></span> new_task = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> task: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field == <span class="hljs-string"><span class="hljs-string">'id'</span></span>: new_task[<span class="hljs-string"><span class="hljs-string">'uri'</span></span>] = url_for(<span class="hljs-string"><span class="hljs-string">'get_task'</span></span>, task_id=task[<span class="hljs-string"><span class="hljs-string">'id'</span></span>], _external=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new_task[field] = task[field] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_task</code> </pre><br><br><p>  All we do here is take a task from our database and create a new task in which all fields are identical, except for the <code>id</code> field, which is replaced by the <code>uri</code> field generated by the <code>url_for</code> function provided by Flask. </p><br><p>  When we return the task list, we run all tasks through this function before sending to the client: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/todo/api/v1.0/tasks', methods=['GET']) def get_tasks(): return jsonify({'tasks': map(make_public_task, tasks)})</span></span></code> </pre><br><br><p>  Now the client receives this list of tasks: </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 200 OK Content-Type: application/json Content-Length: 406 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 18:16:28 GMT { <span class="hljs-string"><span class="hljs-string">"tasks"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Buy groceries"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Milk, Cheese, Pizza, Fruit, Tylenol"</span></span>, <span class="hljs-string"><span class="hljs-string">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:5000/todo/api/v1.0/tasks/1"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:5000/todo/api/v1.0/tasks/2"</span></span> } ] }</code> </pre><br><br><p>  By applying this technique to the rest of the functions, we can ensure that the client always receives a URI instead of id. </p><br><h2>  Protect RESTful web service </h2><br><p>  Did you think we already finished?  Of course, we are finished with the functionality of our service, but we have a problem.  Our service is open to all, and this is not very good. </p><br><p>  We have a complete web service that manages our to-do list, but the service, in its current state, is available to everyone.  If a stranger finds out how our API works, he or she can write a new client and make a mess of our data. </p><br><p>  Many beginner guides ignore security and end here.  In my opinion this is a serious problem that must always be resolved. </p><br><p>  The simplest way to protect our web service is to let customers in after login and password authorization.  In a regular web application, you must create a login form that sends authorization data, the server processes it and makes a new session, and the user's browser receives a cookie with a session identifier.  Unfortunately, we cannot do this here, <b>stateless</b> is one of the rules for constructing REST web services and we must ask customers to send their registration data with each request. </p><br><p>  With REST, we always try to adhere to the HTTP protocol as much as we can.  Now we need to implement user authentication in the context of HTTP, which provides us with 2 options - <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">Basic</a> and <a href="http://en.wikipedia.org/wiki/Digest_access_authentication">Digest</a> . </p><br><br><p>  There is a small Flask extension written by your humble servant.  Let's install <a href="httpauth">Flask-HTTPAuth</a> : </p><br><pre> <code class="bash hljs">$ flask/bin/pip install flask-httpauth</code> </pre><br><br><p>  Now let's tell our web service to give data only to the user with the login <code>miguel</code> and the password <code>python</code> .  First, let's configure Basic HTTP authentication as shown below: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.httpauth <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPBasicAuth auth = HTTPBasicAuth() @auth.get_password <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> username == <span class="hljs-string"><span class="hljs-string">'miguel'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'python'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @auth.error_handler <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unauthorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_response(jsonify({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'Unauthorized access'</span></span>}), <span class="hljs-number"><span class="hljs-number">401</span></span>)</code> </pre><br><br><p>  The <code>get_password</code> function will return a password by username.  In more complex systems, such a function will have to climb into the database, but for one user it is not necessary. </p><br><p>  The <code>error_handler</code> function will be used to send an authorization error with incorrect data.  Just like we did with other errors, we need to configure the function to send JSON, instead of HTML. </p><br><br><p>  After setting up the authentication system, all that remains is to add the <code>@auth.login_required</code> decorator for all functions that need to be protected.  For example: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/todo/api/v1.0/tasks', methods=['GET']) @auth.login_required def get_tasks(): return jsonify({'tasks': tasks})</span></span></code> </pre><br><br><p>  If we try to request this function using <code>curl</code> we get something like this: </p><br><pre> <code class="bash hljs">$ curl -i http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 401 UNAUTHORIZED Content-Type: application/json Content-Length: 36 WWW-Authenticate: Basic realm=<span class="hljs-string"><span class="hljs-string">"Authentication Required"</span></span> Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 06:41:14 GMT { <span class="hljs-string"><span class="hljs-string">"error"</span></span>: <span class="hljs-string"><span class="hljs-string">"Unauthorized access"</span></span> }</code> </pre><br><br><p>  In order to call this feature, we must confirm our credentials: </p><br><pre> <code class="bash hljs">$ curl -u miguel:python -i http://localhost:5000/todo/api/v1.0/tasks HTTP/1.0 200 OK Content-Type: application/json Content-Length: 316 Server: Werkzeug/0.8.3 Python/2.7.3 Date: Mon, 20 May 2013 06:46:45 GMT { <span class="hljs-string"><span class="hljs-string">"tasks"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Buy groceries"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Milk, Cheese, Pizza, Fruit, Tylenol"</span></span>, <span class="hljs-string"><span class="hljs-string">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:5000/todo/api/v1.0/tasks/1"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Learn Python"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Need to find a good Python tutorial on the web"</span></span>, <span class="hljs-string"><span class="hljs-string">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:5000/todo/api/v1.0/tasks/2"</span></span> } ] }</code> </pre><br><br><p>  An authentication extension gives us the freedom to choose which functions will be shared and which ones will be protected. </p><br><p>  To protect registration information, our web service must be accessible via HTTP Secure server (...) which encrypts traffic between the client and the server and prevents third-party receipt of confidential information. </p><br><p>  Unfortunately, web browsers have a bad habit of showing a scary dialog when the request returns with an error of 401. This happens even for background requests, so if we implemented the client for the web browser, we would have to jump through hoops to prevent the browser show your windows </p><br><p>  The simple way to deceive the browser is to return any other code, instead of 401. The favorite alternative of all is 403, which means ‚ÄúForbidden‚Äù error.  Although it is quite close to the meaning of the error, it violates the standard HTTP, so it is wrong.  In particular, it would be a good decision not to use a web browser as a client application.  But in cases where the server and the client are developed together, it saves from many troubles.  To crank this trick we just need to replace the error code from 401 to 403: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@auth.error_handler def unauthorized(): return make_response(jsonify({'error': 'Unauthorized access'}), 403)</span></span></code> </pre><br><br><p>  In the client application, you also need to catch error 403. </p><br><h2>  Possible improvements </h2><br><p>  There are several ways to improve the web service we developed today. </p><br><p>  For starters, a real web service must communicate with a real database.  The data structure in memory is a very limited way of storing data and should not be used in real-world applications. </p><br><p>  Another way to improve the application is to support multiple users.  If the system supports multiple users, authentication data can be used to return personal lists to users.  In such a system, users will become the second resource.  <code>POST</code> request will register a new user in the system.  A <code>GET</code> may return user information.  <code>PUT</code> request can update user information, such as email.  A <code>DELETE</code> request will delete the user from the system. </p><br><p>  A <code>GET</code> request that returns a list of tasks can be extended in several ways.  For starters, this query can have optional arguments, such as the number of tasks per page.  Another way to make the function more convenient is to add filtering criteria.  For example, a client can request only completed tasks or tasks that start with a specific letter.  All these elements can be added to the URL as arguments. </p><br><h2>  Conclusion </h2><br><p>  You can get the finished code for the To Do List web service here: <a href="https://gist.github.com/miguelgrinberg/5614326">https://gist.github.com/miguelgrinberg/5614326</a> . </p><br><p>  I believe this was a simple and friendly introduction to the RESTful API.  If there is enough interest, I could write the second part of this article, in which we will develop a simple web client for our service. </p><br><p>  I made a client for our service: <a href="http://blog.miguelgrinberg.com/post/writing-a-javascript-rest-client">Writing a Javascript REST client</a> . </p><br><p>  An article about the same server, but using Flask-RESTful <a href="http://blog.miguelgrinberg.com/post/designing-a-restful-api-using-flask-restful">Designing a RESTful API using Flask-RESTful</a> . </p><br><p>  Miguel </p></div><p>Source: <a href="https://habr.com/ru/post/246699/">https://habr.com/ru/post/246699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246685/index.html">How normal guys go to Megu: 7 stores per month</a></li>
<li><a href="../246689/index.html">The number of working hours per week for the highest productivity - 35</a></li>
<li><a href="../246691/index.html">The practice of automating the measurement of performance indicators SED</a></li>
<li><a href="../246695/index.html">Vulnerabilities PayPal accounts, fraud refund transactions, hacking account</a></li>
<li><a href="../246697/index.html">AWS and edX offer $ 1000 for completing online course</a></li>
<li><a href="../246701/index.html">The first interview, or Why get a job is more difficult than passing an exam</a></li>
<li><a href="../246703/index.html">Development of Magento modules with application deployment through Magento Composer</a></li>
<li><a href="../246707/index.html">Parsing formulas with functions</a></li>
<li><a href="../246709/index.html">How to disable updates in Skype and advertising at the same time</a></li>
<li><a href="../246711/index.html">Named C ++ Parameters. Not useful</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>