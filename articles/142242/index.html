<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compression without loss of information. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 
 Today I want to touch on the topic of lossless data compression. Despite the fact that there were already articles on some algorithms in H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compression without loss of information. Part one</h1><div class="post__text post__text-html js-mediator-article">  Good day. <br>  Today I want to touch on the topic of lossless data compression.  Despite the fact that there were already articles on some algorithms in Habr√©, I wanted to talk about this in a little more detail. <br>  I will try to give both a mathematical description and a description in the usual way, so that everyone can find something interesting for themselves. <br><br>  In this article I will touch on the fundamental moments of compression and the main types of algorithms. <br><a name="habracut"></a><br><br><h4>  Compression.  Do we need it in our time? </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, yes.  Of course, we all understand that now we have access to both large-capacity storage media and high-speed data transmission channels.  However, at the same time, the volumes of transmitted information are growing.  If several years ago we watched 700-megabyte movies that fit on one disc, then today films in HD quality can occupy dozens of gigabytes. <br>  Of course, there is not much benefit from compressing everything.  But still there are situations in which compression is extremely useful if not necessary. <br><br><ul><li>  Sending documents by e-mail (especially large volumes of documents using mobile devices) </li><li>  When publishing documents on sites, the need to save traffic </li><li>  Saving disk space in cases when replacing or adding storage is difficult.  For example, this happens in cases where knocking out a budget for capital expenditure is not easy, and there is not enough disk space. </li></ul><br><br>  Of course, you can come up with many more different situations in which compression will be useful, but these few examples are enough for us. <br><br>  All compression methods can be divided into two large groups: lossy compression and lossless compression.  Lossless compression is used in cases where the information needs to be restored to within a bit.  This approach is the only possible compression, for example, text data. <br>  In some cases, however, exact information recovery is not required and it is allowed to use algorithms that implement lossy compression, which, unlike lossless compression, is usually easier to implement and provides a higher degree of archiving. <br><br><table><tbody><tr><td>  <b>Lossy compression</b> </td></tr><tr><td>  Better compression rates, while maintaining ‚Äúgood enough‚Äù data quality.  They are mainly used to compress analog data - sound, images.  In such cases, the unpacked file may be very different from the original at the bit-to-bit level of comparison, but it is almost indistinguishable to the human ear or eye in most practical applications. </td></tr><tr><td>  <b>Lossless compression</b> </td></tr><tr><td>  The data is restored to within a bit, which does not lead to any loss of information.  However, lossless compression usually shows the worst compression ratios. </td></tr></tbody></table><br>  So, we proceed to the consideration of lossless compression algorithms. <br><br><h4>  Universal lossless compression methods </h4><br>  In general, there are three basic options on which compression algorithms are built. <br>  <b>The first group of</b> methods is stream conversion.  This involves the description of new incoming uncompressed data through already processed.  No probabilities are calculated, the coding of symbols is carried out only on the basis of the data that have already been processed, such as in the LZ methods (named for Abraham Lempel and Jacob Ziv).  In this case, the second and further occurrences of a certain substring already known to the encoder are replaced with references to its first occurrence. <br><br>  <b>The second group of</b> methods is statistical compression methods.  In turn, these methods are divided into adaptive (or flow), and block. <br>  In the first (adaptive) version, the calculation of probabilities for new data occurs from data already processed during coding.  These methods include adaptive versions of Huffman and Shannon-Fano algorithms. <br>  In the second (block) case, the statistics of each data block is calculated separately, and added to the most compressed block.  These include static variants of Huffman, Shannon-Fano, and arithmetic coding. <br><br>  <b>The third group of</b> methods is the so-called block conversion methods.  Incoming data is divided into blocks, which are then transformed as a whole.  However, some methods, especially those based on permutation of blocks, may not lead to a significant (or even any) reduction in the amount of data.  However, after such processing, the data structure is significantly improved, and the subsequent compression by other algorithms is more successful and fast. <br><br><h5>  General principles on which data compression is based </h5><br><br>  All data compression methods are based on a simple logical principle.  If we imagine that the most common elements are encoded with shorter codes, and less frequently, longer ones, then all the data will require less space to store than if all the elements were represented by codes of the same length. <br>  The exact relationship between the frequencies of appearance of elements, and the optimal lengths of codes is described in the so-called Shannon's source coding theorem, which defines the limit of maximum lossless compression and Shannon's entropy. <br><br><h6>  A bit of math </h6><br>  If the probability of occurrence of the element s <sub>i</sub> is equal to p (s <sub>i</sub> ), then it will be most advantageous to represent this element - log <sub>2</sub> p (s <sub>i</sub> ) bits.  If during coding it is possible to ensure that the length of all elements will be reduced to log <sub>2</sub> p (s <sub>i</sub> ) bits, then the length of the entire coding sequence will be minimal for all possible coding methods.  Moreover, if the probability distribution of all elements F = {p (s <sub>i</sub> )} is constant, and the probabilities of the elements are mutually independent, then the average length of the codes can be calculated as <br><img src="https://habrastorage.org/storage2/d49/4a2/489/d494a248985cc291d158827125a3d608.png"><br><br>  This value is called the entropy of the probability distribution F, or the entropy of the source at a given point in time. <br>  However, usually the probability of the appearance of an element cannot be independent; on the contrary, it depends on some factors.  In this case, for each newly encoded element s <sub>i,</sub> the probability distribution F takes some value F <sub>k</sub> , that is, for each element F = F <sub>k</sub> and H = H <sub>k</sub> . <br><br>  In other words, it can be said that the source is in the state k, which corresponds to a certain set of probabilities p <sub>k</sub> (s <sub>i</sub> ) for all elements s <sub>i</sub> . <br><br>  Therefore, given this amendment, it is possible to express the average length of codes as <br><img src="https://habrastorage.org/storage2/057/f3a/1a3/057f3a1a3e77e0533025820d1ddf0068.png"><br>  Where P <sub>k</sub> - the probability of finding the source in the state k. <br><br>  So, at this stage, we know that compression is based on the replacement of frequently encountered elements with short codes, and vice versa, and also know how to determine the average length of codes.  But what is code, coding, and how does it occur? <br><br><h4>  Memory coding </h4><br>  Memoryless codes are the simplest codes on the basis of which data can be compressed.  In a code without memory, each character in the encoded data vector is replaced by a codeword from a prefix set of binary sequences or words. <br>  In my opinion, not the most understandable definition.  Consider this topic in more detail. <br><br>  Let some alphabet be given <img src="https://habrastorage.org/storage2/dc1/784/41e/dc178441e1baed11a814d5e40edf5d50.png">  consisting of some (finite) number of letters.  Let's call each finite sequence of characters from this alphabet (A = a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>n</sub> ) a <i>word</i> , and the number n - the length of this word. <br><br>  Let another alphabet be also given. <img src="https://habrastorage.org/storage2/0c8/80e/fbd/0c880efbdcc03a33d0eccf0edcfe88ae.png">  .  Similarly, we denote a word in this alphabet as B. <br><br>  We introduce two more notation for the set of all non-empty words in the alphabet.  Let be <img src="https://habrastorage.org/storage2/f25/9c9/cf2/f259c9cf2090a6490344296daaa67f72.png">  - the number of non-empty words in the first alphabet, and <img src="https://habrastorage.org/storage2/4ed/91b/28b/4ed91b28ba9581fee4fe52eea35b7ecf.png">  - in the second. <br><br>  Suppose also that a mapping F is given, which assigns to each word A from the first alphabet some word B = F (A) from the second.  Then the word B will be called the <i>code of the</i> word A, and the transition from the source word to its code will be called <i>coding</i> . <br><br>  Since a word can also consist of one letter, we can identify the correspondence of the letters of the first alphabet and the corresponding words from the second: <br>  a <sub>1</sub> &lt;-&gt; B <sub>1</sub> <br>  a <sub>2</sub> &lt;-&gt; B <sub>2</sub> <br>  ... <br>  a <sub>n</sub> &lt;-&gt; B <sub>n</sub> <br><br>  This correspondence is called a <i>schema</i> , and is denoted by ‚àë. <br>  In this case, the words B <sub>1</sub> , B <sub>2</sub> , ..., B <sub>n</sub> are called <i>elementary codes</i> , and the type of coding with their help is <i>alphabetic coding</i> .  Of course, most of us have come across this kind of coding, even if not knowing all the things I described above. <br><br>  So, we have defined the concepts of <i>alphabet, word, code,</i> and <i>coding</i> .  Now we introduce the concept of <i>prefix</i> . <br><br>  Let the word B have the form B = B'B ''.  Then B 'is called the beginning, or <i>prefix of the</i> word B, and B' 'is called its end.  This is a fairly simple definition, but it should be noted that for any word B, and some empty word  å (‚Äúspace‚Äù), and the word B itself, can be considered both beginnings and ends. <br><br>  So, we come close to understanding the definition of codes without memory.  The last definition that remains for us to understand is the prefix set.  The scheme ‚àë has the prefix property if for any 1‚â§i, j‚â§r, i ‚â† j, the word B <sub>i is</sub> not a prefix of the word B <sub>j</sub> . <br>  Simply put, a prefix set is a finite set in which no element is the prefix (or beginning) of any other element.  A simple example of such a set is, for example, the usual alphabet. <br><br>  So, we figured out the basic definitions.  So how does memoryless encoding happen? <br>  It occurs in three stages. <br><ol><li> An alphabet Œ® of the symbols of the original message is composed, and the symbols of the alphabet are sorted in descending order of probability in the message. </li><li>  Each character a <sub>i</sub> from the alphabet Œ® is associated with a certain word B <sub>i</sub> from the prefix set Œ©. </li><li>  Each character is encoded, followed by combining the codes into one data stream, which will be the results of compression. </li></ol><br><br>  One of the canonical algorithms that illustrate this method is the Huffman algorithm. <br><br><h4>  Huffman Algorithm </h4><br>  The Huffman algorithm uses the frequency of the appearance of identical bytes in the input data block, and sets in correspondence to frequently occurring blocks of a string of bits of shorter length, and vice versa.  This code is the minimum redundant code.  Consider the case when, regardless of the input stream, the alphabet of the output stream consists of only 2 characters - zero and one. <br><br>  First of all, when coding with a Huffman algorithm, we need to construct a scheme ‚àë.  This is done as follows: <br><ol><li>  All letters of the input alphabet are ordered in decreasing order of probability.  All words from the output stream alphabet (that is, what we will encode) are initially considered empty (recall that the output stream alphabet consists only of {0,1} characters). </li><li>  The two characters a <sub>j-1</sub> and a <sub>j of the</sub> input stream, which have the smallest probabilities of occurrence, are combined into one ‚Äúpseudo-symbol‚Äù with probability <i>p</i> equal to the sum of the probabilities of the characters included in it.  Then we append 0 to the beginning of the word B <sub>j-1</sub> , and 1 to the beginning of the word B <sub>j</sub> , which will subsequently be the character codes a <sub>j-1</sub> and a <sub>j,</sub> respectively. </li><li>  We delete these characters from the alphabet of the original message, but we add the formed pseudo-character to this alphabet (naturally, it should be inserted into the alphabet at the right place, taking into account its probability). </li></ol><br>  Steps 2 and 3 are repeated until only 1 pseudo-character is left in the alphabet, containing all the initial symbols of the alphabet.  Moreover, since at each step and for each character, the corresponding word B <sub>i</sub> changes (by adding one or zero), after this procedure is completed, each initial character of the alphabet a <sub>i</sub> will correspond to a certain code B <sub>i</sub> . <br><br>  For the best illustration, consider a small example. <br>  Suppose we have an alphabet consisting of only four characters - {a <sub>1</sub> , a <sub>2</sub> , a <sub>3</sub> , a <sub>4</sub> }.  Suppose also that the probabilities of occurrence of these symbols are equal respectively to p <sub>1</sub> = 0.5;  p <sub>2</sub> = 0.24;  p <sub>3</sub> = 0.15;  p <sub>4</sub> = 0.11 (the sum of all probabilities is obviously equal to one). <br><br>  So, we will construct the scheme for the given alphabet. <br><br><ol><li>  We combine the two characters with the smallest probabilities (0.11 and 0.15) into the pseudo-character p '. </li><li>  Remove the combined characters, and insert the resulting pseudo-character into the alphabet. </li><li>  We combine the two characters with the smallest probability (0.24 and 0.26) into the pseudo-character p ''. </li><li>  Remove the combined characters, and insert the resulting pseudo-character into the alphabet. </li><li>  Finally, combine the remaining two characters, and get the top of the tree. </li></ol><br><br>  If you make an illustration of this process, you get something like the following: <br><br><img src="https://habrastorage.org/storage2/e3e/0e0/a24/e3e0e0a24c0479e0a2f751c7eaba64b8.png"><br>  As you can see, with each union we assign codes 0 and 1 to the characters to be joined. <br>  That way, when a tree is built, we can easily get the code for each character.  In our case, the codes will look like this: <br><br>  a <sub>1</sub> = 0 <br>  a <sub>2</sub> = 11 <br>  a <sub>3</sub> = 100 <br>  a <sub>4</sub> = 101 <br><br>  Since none of these codes is a prefix of any other (that is, we have received the notorious prefix set), we can uniquely identify each code in the output stream. <br>  So, we have achieved that the most frequent symbol is encoded by the shortest code, and vice versa. <br>  If we assume that initially one byte was used to store each character, then we can calculate how much we managed to reduce the data. <br><br>  Suppose that at the input we had a line of 1000 characters in which the character a <sub>1 was</sub> encountered 500 times, a <sub>2</sub> - 240, a <sub>3</sub> - 150, and a <sub>4</sub> - 110 times. <br><br>  Initially, this line occupied 8000 bits.  After coding, we get a string long in ‚àëp <sub>i</sub> l <sub>i</sub> = 500 * 1 + 240 * 2 + 150 * 3 + 110 * 3 = 1760 bits.  So, we managed to compress the data 4.54 times, spending an average of 1.76 bits on encoding each character of the stream. <br><br>  Let me remind you that according to Shannon, the average code length is <img src="https://habrastorage.org/storage2/d49/4a2/489/d494a248985cc291d158827125a3d608.png">  .  Substituting our probabilities into this equation, we obtain an average code length of 1.75496602732291, which is very, very close to the result we obtained. <br>  However, it should be borne in mind that in addition to the data itself, we need to store the coding table, which will slightly increase the total size of the encoded data.  It is obvious that in different cases different variations of the algorithm can be used - for example, sometimes it is more efficient to use a predetermined probability table, and sometimes it is necessary to compile it dynamically by traversing compressible data. <br><br><h4>  Conclusion </h4><br>  So, in this article I tried to talk about the general principles by which lossless compression occurs, and also considered one of the canonical algorithms - Huffman coding. <br>  If the article comes to taste to the habrosocommunity, then I will gladly write a sequel, as there are many more interesting things related to lossless compression;  these are both classical algorithms and preliminary data transformations (for example, the Burrows-Wheeler transformation), and, of course, specific algorithms for compressing sound, video and images (the most interesting topic, in my opinion). <br><br><h4>  Literature </h4><br><ul><li>  Vatolin D., Ratushnyak A., Smirnov M. Yukin V. Data Compression Methods.  Device archivers, image and video compression;  ISBN 5-86404-170-X;  2003 </li><li>  D. Salomon.  Compression of data, image and sound;  ISBN 5-94836-027-X;  2004 </li><li>  <a href="http://www.wikipedia.org/">www.wikipedia.org</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/142242/">https://habr.com/ru/post/142242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142236/index.html">Playing cubes with Kinect</a></li>
<li><a href="../142238/index.html">ZFConf 2010: How It Was (video reports)</a></li>
<li><a href="../142239/index.html">1C products - service, sale from Infors</a></li>
<li><a href="../142240/index.html">SVG stacks</a></li>
<li><a href="../142241/index.html">Optimization of flatpages project on django under the minimum system requirements. Joke article</a></li>
<li><a href="../142243/index.html">How would I do BusyIndicator</a></li>
<li><a href="../142244/index.html">Do you really want to use the cancel button in your apps?</a></li>
<li><a href="../142245/index.html">Visual monitoring of a large number of objects (for example, IPTV channels) using Arduino</a></li>
<li><a href="../142247/index.html">The Pirate Bay: and .torrent files have not gone anywhere</a></li>
<li><a href="../142248/index.html">Media Piracy in Developing Economies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>