<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Million particle. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to tell you how I created, and then transferred my own particle system to the GPU. As I naively thought it would just be done (they say cho the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Million particle. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="http://atlanticfountains.com/images/access4-2.jpg" alt="image" align="left">  I want to tell you how I created, and then transferred my own particle system to the GPU.  As I naively thought it would just be done (they say cho there, move the particles, tyuyu).  In fact, it is possible to talk a lot about the nuances arising from the implementation for a long time, so I‚Äôll only talk about solving the bottleneck problems later. <br><br><h4>  Background </h4><br>  <a href="http://atlanticfountains.com/">The customer</a> develops dynamic music fountains, which are controlled via script dmx controllers.  He made the script editor himself.  But in practice, creating scripts turned out to be inconvenient, because in order to see how it turns out, you need to have a completely built and running fountain.  In addition, if the <s>designer</s> choreographer suddenly wanted to add additional nozzles for the fountain, then this is almost impossible to do.  Therefore, the customer wanted to acquire a module for modeling fountains, so that the choreographer could develop scenarios without a real fountain.  In general, I got something like this: here's a video of what <a href="">Hawaii50.wmv</a> modeled, but what came out in real life after the fountain was designed: <a href="">H5OClip.wmv</a> <br><a name="habracut"></a><br><br><h4>  Requirements </h4><br>  At the moment there is a fixed set of nozzles that behave in a certain way, as well as LED light sources.  In fact, I had to provide interfaces for each type of nozzle and for light sources, with methods for manipulating these nozzles / light sources.  There should be a scene that we can rotate in our own window using the mouse (there were also a lot of small requirements not related to a particle system, such as a grid on a plane, fountain height marks, etc.).  And of course all this is needed in real-time, that is, at least 25-30 frames per second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  First pancake </h4><br>  At first I did a simple creation of particles on the CPU, then the whole thing went to the vertex buffer, which was rendered.  When tests it all worked fine, in practice it turned out to be unsuitable.  If you look at the <a href="">H5OClip.wmv</a> video, then notice how many light sources are lit at the same time.  Often the number comes to hundreds or more.  At the same time, one source often ‚Äúcovers‚Äù several jets of fountains at once, and in fact each jet is essentially an emitter.  Now imagine that 150-200 jets simultaneously create particles.  How many particles are needed in order to portray one jet?  In practice, it was found that a tolerable display of one jet, beating at full power, requires an average of 5k particles.  And for 150 jets we get 750,000 particles.  It is clear that it is necessary to lay at least 150 jets. <br><br>  The first version worked like this.  First there was the process of creating particles.  For each particle there was a field in which the millisecond was stored, in which the particle would die.  We determine the number of particles that the emitter created for the last frame, and run from the beginning of the array until we create all the particles.  If we meet a dead particle (current time&gt; time of death), then we fill it with a new time of death, set the initial coordinates and the initial velocity.  In essence, the particle is created.  If the array ends, and not all particles are still created, then we allocate an additional piece of memory.  If you created all the particles, then run to the end of the buffer and remember the index of the last living particle.  If the index of the last living particle is much less than the length of the array, then shorten the array.  This index is useful to us in the future, so as not to run around the buffer. <br>  Then came the simultaneous process of particle motion, and filling the VBO (Vertex Buffer Object).  We run along the array, if the particle is alive - we move it and fill it in the VBO, otherwise we skip it.  We check not the whole array, but before the index of the last live particle. <br>  So VBO is ready, render it.  In practice (and then I had an Athlon 64 x2 3800, this is 2.0 Hz core), if memory serves me, then about 100-150k particles with 25-30FPS came out, which is not good. <br>  Therefore, we agree that we need to somehow manipulate the peak with 750k particles, or come up with an alternative.  Therefore, go to the second pancake. <br><br><h4>  Second pancake </h4><br><h5>  Analysis </h5><br>  First, I conducted tests that exactly eats the final FPS.  So, loads that are clearly visible: <br><ol><li>  Creation / death of new particles </li><li>  Particle motion </li><li>  Filling Vertex Buffer </li><li>  Particle render </li></ol><br>  Of course, the movement of particles turned out to be the most ‚Äúinhibited‚Äù.  In the second place was the creation / death of new particles.  The third is filling the vertex buffer.  As for the render - then everything was shaky.  Since the fountains are in 3D, they can be at different distances from the camera, and the particles must be scaled in depth.  If the camera is directed from top to bottom, so that the jets beat right into the camera, the FPS will fall.  It is understandable, because the particles were huge, and the fillrate was accordingly huge.  In the usual case, the camera never directed anyone like that (in the future I carried out optimization for such cases) and the FPS rendered almost no effect, because the GPU displays the image asynchronously and managed to cope with its work during the CPU. <br><br><h5>  Attempt to optimize </h5><br>  The first thing I decided to optimize the math of displacement.  But the mathematics was so simple that there was practically nothing to optimize.  The compiler perfectly optimized the whole thing in asm code.  Then the idea arose not to run through the array twice, but to create, move particles and fill the buffer in one pass.  No sooner said than done.  But the increase in speed could be seen only under a microscope.  With the filling of the vertex buffer, no optimizations occurred to me.  Of course, it was possible to try using one buffer for VBO and for vertices, but then it would be necessary to output dead vertices beyond the viewport, and this option seemed to me even more inhibitory.  And the overhead for filling out the VBO was scanty.  Theoretically (flops) there was still a large margin, but it was impossible to keep up with those synthetic figures. <br>  Of course, it could also be solved in the forehead, parallelized to 4 threads, set in the minimum system requirements for a CPU program with 4 cores, and a frequency per core of 2.5 GHz, but I absolutely did not like this way. <br><br><h5>  Successful optimization attempt </h5><br>  So, it is necessary to reduce the number of particles.  It is clear that the fountains located far away do not need a large number of particles.  You can draw a smaller number of particles a little larger, but if the camera approaches the fountain abruptly, then we should show more particles, everything seems logical and understandable, but the problem is that we must somehow move these most invisible particles.  Otherwise, when approaching, they will be at our starting point.  And again, we rest on the fact that on the CPU we need to manipulate with all the particles.  And what if we don‚Äôt move the particle at all, but simply calculate its position using the equation of motion. <br>  The simplest equation of motion: x = x <sub>0</sub> + v <sub>0</sub> * t + 0.5 * a * t * t.  It would be a really great option if it were not for one thing.  The customer wanted ‚Äúair friction‚Äù, because for jets with a low angle to the horizon, the simulation result was very different from the real result.  The viscous friction force F = -bV, for a single medium of the same size and shape of droplets, it can be roughly said that the acceleration from friction is a = kV, where k is a certain coefficient.  As a result, our simple equation of motion turns into a monster (the current formula in the shader: NewCoord = ((uAirFriction * aVel + G) * (exp (uAirFriction * dt) -1.0) / uAirFriction - G * dt) / uAirFriction + aCoord;).  And despite the wild formula, I have already received a tangible increase in productivity only due to the fact that I considered the position of only those vertices that I will really draw.  For fountains located at a distance of N from the camera, we take every second particle, for fountains located at a distance of 2N every fourth, etc.  The result was something of the order of 500-700k of living particles at 20-30FPS, which is quite good.  The above figure actually went out very floating, and everything depended on the location of the fountains in the frame, but in general the performance completely satisfied the needs. <br><br><h4>  Third pancake </h4><br>  Despite the fact that the task was already implemented, and the customer was satisfied, for the sake of my own sports interest, I decided to rewrite the calculations on the GPU.  So, I needed a <a href="http://steps3d.narod.ru/tutorials/r2vb-tutorial.html">render in the vertex buffer</a> .  For the vertex buffer with initial values ‚Äã‚Äã(initial position, initial speed, initial time, final time), we render the vertex buffer that stores only the current coordinates.  Then, using the resulting buffer, we render the particles themselves.  A simple implementation of a vlob (without reducing the number of particles depending on the distance) yielded 1k particles at 40-50FPS on my GF250.  Now on the CPU we only need to ‚Äúgive birth‚Äù to a particle, and there are quite a few such particles for each frame.  But to make a different number of particles, depending on the distance here is not so trivial.  After all, we get not a solid array of particles, but an array with ‚Äúholes‚Äù (holes from dead particles).  I see a couple of solutions for this case, but did not have time to implement it due to lack of time.  If it is interesting for the habrasoobshchestvo to look at further implementations, then when free time appears I will try to bake the fourth and fifth pancakes (and even with demos). <br><br><h4>  findings </h4><br><ul><li>  In particle systems, the bottleneck is by no means a bus, as I originally thought (I don‚Äôt know how for AGP, but for PCIe16 it is not noticeable), but particle movement. </li><li>  Fillrate in particle systems can significantly "gobble up" performance.  It is recommended to optimize this moment. </li><li>  Tasks that are well parallelized often ‚Äúhead-on‚Äù are solved on the GPU faster, and such bottlenecks are always better transferred to the GPU (but this does not mean that everything should be done on the GPU head-on). </li><li>  The most important conclusion, first think, then do.  First, I estimate the number of particles - I would immediately think about optimization, and the first pancake would simply not exist. </li></ul><br><br>  <b>ps I</b> apologize for the lack of code and demos.  I understand that reading the pictures is more interesting, but the versions of the old code have not been preserved, I could say from the memory of my ‚Äúsearches‚Äù.  Accordingly, there are no old screenshots / videos / demos, but the current video can be found on the customer‚Äôs site.  In the following articles I will try to correct. <br><br>  <b>upd.</b>  Filled the above video on YouTube <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/l49FkvnElNw%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhioPKlKK0Xa3A1mcmu3p6-MICrB1g" frameborder="0" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/wYvrjJm080g%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhhgyiuVeSxkHtK0poFrTg0ETchdbg" frameborder="0" allowfullscreen=""></iframe><br><br>  <b>upd2.</b>  Screen lossless quality: <br><img src="https://habrastorage.org/storage2/84e/9f0/b12/84e9f0b12da9511ef06a8d90d7590a63.png"><br>  The top screen is an attempt to add water hammer and make it more beautiful and realistic.  I consider the attempt unsuccessful due to a strong drop in performance. <br>  Lower screen - put the third pancake in the above article. </div><p>Source: <a href="https://habr.com/ru/post/151821/">https://habr.com/ru/post/151821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151814/index.html">Practical tips for efficient code inspection</a></li>
<li><a href="../151815/index.html">Application Cache API - new features and problems</a></li>
<li><a href="../151816/index.html">Such a dangerous Internet Explorer ...</a></li>
<li><a href="../151818/index.html">How to restore data in Storelab</a></li>
<li><a href="../151820/index.html">Indie Gala 9</a></li>
<li><a href="../151822/index.html">New edition of the changes in the Civil Code: open licenses, providers responsibility and other interesting points</a></li>
<li><a href="../151826/index.html">How do NFC payments work</a></li>
<li><a href="../151827/index.html">Can plain text mute IE?</a></li>
<li><a href="../151829/index.html">The familiar view for Visual Studio 2012</a></li>
<li><a href="../151831/index.html">Google Play developers from Russia can now receive bank transfers through Google Checkout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>