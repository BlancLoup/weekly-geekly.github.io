<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MySQL Performance real life Tips and Tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I promised yesterday to write an article about real cases of MySQL database optimization. 
 Today I had to get up early in the morning to realize the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MySQL Performance real life Tips and Tricks</h1><div class="post__text post__text-html js-mediator-article">  I promised yesterday to write an article about real cases of MySQL database optimization. <br>  Today I had to get up early in the morning to realize the promise. <br>  It is still difficult to maintain the centralized management of thoughts, so do not judge strictly for incidents and lapses in my article. <br><br>  Recently, one has often enough to engage in optimizing the performance of sites.  And as a rule, the "bottleneck" in the performance of these sites is precisely the database, errors in both the architecture and in the execution of requests.  Starting from the incorrect arrangement of indices, or their complete absence, the wrong (uneconomic) selection of data types for a specific field, ending with an absolutely illogical database architecture and the same illogical queries. <br><br>  In this article I will describe several techniques that were used for an application with 4 million + users and that having about 100 million + hits per day, and at the end I will describe a problem that was solved recently and maybe a highly respected community will offer me solutions to this problem more efficiently than to which I came. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  For large tables in MySQL that contain hundreds of thousands, millions of records are often critical queries for GROUP BY.  Because  in most cases, if we look at the explain of this request, we will see in the Extra field - Using temporary;  Using filesort <br>  For example: <br><br><blockquote>  <font color="black">explain</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">`tags`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">group</font> <font color="#0000ff">by</font></font> <font color="black"><br></font>  <font color="black">tag_text;</font> <br><br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Extra - Using index;  Using temporary;  Using filesort <br>  Those.  For grouping, a temporary table is used, which is then sorted, and sorting takes place without using any indexes. <br><br>  In general, if GROUP BY is present in the query, MySQL will always sort the results.  If the order of the output results is not important to us, then it is better to get rid of this operation (sorting).  This can be done by adding ‚Äúorder by null‚Äù to the request.  Total we get <br><br><blockquote>  <font color="black">explain</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">`tags`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">group</font> <font color="#0000ff">by</font></font> <font color="black"><br></font>  <font color="black">tag_text</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">order</font> <font color="#0000ff">by</font> <font color="#0000ff">null</font> ;</font> <br><br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Extra - Using index;  Using temporary; <br><br>  As a rule, grouping often passes by string data types, which is rather slow; you can achieve a significant performance gain if you can sacrifice the ‚Äúaccuracy‚Äù of the grouping, or rather the grouped values.  This can be useful in evaluating the logs or some other reports where the estimated numbers will come down. <br><br>  For example, such a query will be executed much faster than the previous <br><blockquote>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">`tags`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">group</font> <font color="#0000ff">by</font></font> <font color="black"><br></font>  <font color="black">crc32 (tag_text)</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">order</font> <font color="#0000ff">by</font> <font color="#0000ff">null</font> ;</font> <br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Sometimes a big enough problem is LIMIT in queries, I will not say here that some are pulling out 100 records, and sometimes even 1000 if they really use 10;  I will say the following - there is a benefit from the limit only when the query uses an index by the field that we sort, because  otherwise Using temporary;  Using filesort eliminates all the benefits of the limit.  Also it is necessary to avoid the following limits LIMIT 1,000,000, 25, since  1000025 records will still be selected, and only then 1000000 will be dropped.  This is often used for pagination, and many programmers are often justified by the fact that users still mostly go to new pages (the latter in chronological order), i.e.  requests with such limits are rarely performed ... Yes, users go to pages of a year or two years ago not often, but if a search bot comes to the site, it goes to all pages, and this bot, which indexes the site content, puts the database server to us. <br>  The solution to this problem, as a rule, is the calculation of the results on the previous page, for example, the last id of the record on the previous page, and the limit in the query will look something like this <br>  WHERE bla-bla AND NODE_ID&gt; id_from_previous_page ORDER BY NODE_ID LIMIT 25 <br>  well, or something like that <br>  WHERE Position BETWEEN 1000 and 1025 <br>  these designs are much faster than LIMIT 1000, 25 <br><br>  The solution to this problem proposed by% rumkin% regarding this problem. <br>  The issue with paginated navigation, taking into account the current non-love of extra GET requests, can be solved as follows: <br><br><blockquote>  <font color="black"><font color="#0000ff">SELECT</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">FROM</font></font> <font color="black"><br></font>  <font color="black">` <font color="#0000ff">table`</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">WHERE</font></font> <font color="black"><br></font>  <font color="black">id&gt; X * Y-1</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">LIMIT</font></font> <font color="black"><br></font>  <font color="black">X;</font> <font color="black"><br></font>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Where X is the number of results per page, Y is the number of the current page.  So we will do without pre-queries, GET requests and other complications. <br><br>  Some suggest horizontal solutions to solve these problems. <br>  <a href="http://en.wikipedia.org/wiki/Partition_(database)">sharding (partition)</a> But to solve the problem with pagination this is IMHO perversion that one more ... Although about sharding later ... <br><br>  Also, some people think that the SQL_NO_CACHE SQL_CALC_FOUND_ROWS construction is faster than 2 queries first with LIMIT and the second select count (*) <br>  Here you will read the revelation of this legend. <br><br>  <a href="http://www.mysqlperformanceblog.com/2007/08/28/to-sql_calc_found_rows-or-not-to-sql_calc_found_rows/">http://www.mysqlperformanceblog.com/2007/08/28/to-sql_calc_found_rows-or-not-o-sql_calc_found_rows/</a> <br><br>  I will not write about the arrangement of indices.  Much has been said about this, I will only write that so far you do not need to rely on the index merge algorithm and, if possible, replace it with composite (composite indices for several fields), you can read more about it here. <br><br>  <a href="http://www.mysqlperformanceblog.com/2008/08/22/multiple-column-index-vs-multiple-indexes/">http://www.mysqlperformanceblog.com/2008/08/22/multiple-column-index-vs-multiple-indexes/</a> <br><br>  <a href="http://dev.mysql.com/doc/refman/5.0/en/index-merge-optimization.html">http://dev.mysql.com/doc/refman/5.0/en/index-merge-optimization.html</a> <br><br>  Or sometimes it is appropriate to replace with a query with UNION (or rather, with UNION ALL, since UNION is an abbreviation of UNION DISTINCT and therefore when we combine the results of two queries with UNION, this union will run slower, this happens not because UNION ALL unlike UNION, it does not use a temporary table, in fact it uses it, only it does not recognize it (in the sense it doesn‚Äôt show it in explain), this can only be seen with show status. The fact is that UNION ALL creates a temporary table without UNIQUE KEY, and UNION DISTINCT with - hence the difference) Therefore, sometimes a query of this type can with  amb optimal variant <br><br><blockquote>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">` <font color="#0000ff">table`</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">where</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">first</font> = <font color="#A31515">'A'</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">UNION</font> <font color="#0000ff">ALL</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">` <font color="#0000ff">table`</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">where</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">second</font> = <font color="#A31515">'B'</font> <font color="#0000ff">AND</font> <font color="#0000ff">first</font> ! = <font color="#A31515">'A'</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">UNION</font> <font color="#0000ff">ALL</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">` <font color="#0000ff">table`</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">where</font></font> <font color="black"><br></font>  <font color="black">third = <font color="#A31515">'C'</font> <font color="#0000ff">and</font> <font color="#0000ff">second</font> ! = <font color="#A31515">'B'</font> <font color="#0000ff">AND</font> <font color="#0000ff">first</font> ! = <font color="#A31515">'A'</font></font> <br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  than <br><br><blockquote>  <font color="black"><font color="#0000ff">select</font></font> <font color="black"><br></font>  <font color="black">*</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">from</font></font> <font color="black"><br></font>  <font color="black">` <font color="#0000ff">table`</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">where</font></font> <font color="black"><br></font>  <font color="black">third = <font color="#A31515">'C'</font> <font color="#0000ff">OR</font> <font color="#0000ff">second</font> = <font color="#A31515">'B'</font> <font color="#0000ff">OR</font> <font color="#0000ff">first</font> = <font color="#A31515">'A'</font></font> <br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Yes, what else I wanted to write about was covering indexes, more precisely, about the queries that use them. <br>  In short, what is the essence - we work in the request, i.e.  We use as a condition (WHERE) and return (SELECT) only fields that are included in one composite index.  Total - all that the muscle needs to run through the tree of indexes and return the result.  The indices are in memory, we don‚Äôt climb into the data on the disk, everything is cool and fast. <br>  A classic example of this is a query of the form. <br><br>  SELECT user_password FROM `users` WHERE user_name = 'maghamed'; <br>  having an index on the fields (user_name, user_password) <br><br>  I will give a more non-standard example on this topic for securing the material :-) <br><br><blockquote>  <font color="black"><font color="#0000ff">SELECT</font></font> <font color="black"><br></font>  <font color="black">`log`.visitor_id,` url`.url</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">FROM</font> (</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">SELECT</font></font> <font color="black"><br></font>  <font color="black">id</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">FROM</font></font> <font color="black"><br></font>  <font color="black">log</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">WHERE</font></font> <font color="black"><br></font>  <font color="black">ip = ‚Äù127.0.0.1‚Äù</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">ORDER</font> <font color="#0000ff">BY</font></font> <font color="black"><br></font>  <font color="black">ts <font color="#0000ff">desc</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">LIMIT</font> 50.10</font> <font color="black"><br></font>  <font color="black">) l</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">JOIN</font> log</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">ON</font> (l.id = log.id)</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">JOIN</font> url</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">ON</font> (url.id = log.url_id)</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">ORDER</font> <font color="#0000ff">BY</font></font> <font color="black"><br></font>  <font color="black">TS <font color="#0000ff">DESC</font> ;</font> <br>  <font color="gray">* This source code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Although this query looks terrifying, but if we have a covering index for the fields (IP, TS, ID), the derived query will use it and execute very quickly, including the limit in it, the passage for the limit will also be performed using only the index .  After that we do self-join to connect the remaining fields of the table (visitor_id) <br><br><hr><br>  And finally, I will describe one case that not so long ago presented itself to be solved. <br>  In general, there is a site-blogger, where users write articles, news on various topics, in general, something like a habr, only more civilian orientation :-) <br>  It was necessary to create a tracking system for authors, something like google analytics.  So that the authors of the articles could see who, where and when goes to their articles.  Those.  statistics should be the total number of views for a certain time, the statistics of referrers from different sites, and the statistics of the most popular queries for which users came from search engines to this post. <br><br>  All this statistics is collected in the log and every hour the crown is transferred from the log to the database, after which a new log file is created and the statistics for the next hour are written there. <br><br>  Total that is: <br>  articles (let's call them entries, have their ID) <br>  referrals are collected and processed for each article + phrases for which people come from search engines <br>  what reports need to be generated: <br>  views in the last hour, two, 6, 12, day, week <br>  search phrases for each article at the same intervals <br>  referrals for each article for the same intervals <br>  the most "popular" search phrases for the same intervals <br>  the most "popular" referrers for the same intervals <br><br>  There was a solution that worked fine up to a certain point, but after the number of site visits increased dramatically, it began to work slowly. <br><br>  Here is the structure of the table for the report on general statistics, approximately the same tables exist for the statistics of referrers and search phrases <br><br><blockquote>  <font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> `mt_daily_entry_stats` (</font> <font color="black"><br></font>  <font color="black">`daily_entry_stats_entry_id` <font color="#0000ff">INTEGER</font> (11) UNSIGNED <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> ,</font> <font color="black"><br></font>  <font color="black">`daily_entry_stats_views` <font color="#0000ff">INTEGER</font> (11) UNSIGNED <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> ,</font> <font color="black"><br></font>  <font color="black">`daily_entry_stats_date` DATETIME <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> ,</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (`daily_entry_stats_entry_id`,` daily_entry_stats_date`),</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">KEY</font> `daily_entry_stats_date` (` daily_entry_stats_date`)</font> <font color="black"><br></font>  <font color="black">) ENGINE = InnoDB</font> <font color="gray">* This code was highlighted with <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  Well, respectively, to this table, depending on the selected statistics, the following queries were executed: <br><br><blockquote>  <font color="black"><font color="#0000ff">SELECT</font></font> <font color="black"><br></font>  <font color="black">`stats`.`daily_entry_stats_entry_id`,</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">SUM</font> (`stats`.`daily_entry_stats_views`) as` entry_stats_views`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">FROM</font></font> <font color="black"><br></font>  <font color="black">`mt_daily_entry_stats` as` stats`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">WHERE</font></font> <font color="black"><br></font>  <font color="black">`stats`.`daily_entry_stats_date`&gt; NOW () - <font color="#0000ff">INTERVAL</font> 24 <font color="#0000ff">HOUR</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">GROUP</font> <font color="#0000ff">BY</font></font> <font color="black"><br></font>  <font color="black">`stats`.`daily_entry_stats_entry_id`</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">HAVING</font></font> <font color="black"><br></font>  <font color="black">`entry_stats_views`&gt; 1000</font> <font color="gray">* This was highlighted with the <a href="http://source.virtser.net/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br><br>  This decision began to work slowly and it was necessary to understand why. <br><br>  here is the explain of this request <br><br>  select_type: SIMPLE <br>  table: stats <br>  type: range <br>  possible_keys: daily_entry_stats_date <br>  key: daily_entry_stats_date <br>  key_len: 8 <br>  ref: NULL <br>  rows: 97644 <br>  Extra: Using where;  Using temporary;  Using filesort <br><br>  1. Engine = InnoDB is used this way, it means that surrogate keys are used, which are stored directly in the same data file (unlike MyISAM, where indexes are stored in a separate file), moreover, the data is sorted by this surrogate key and it is included in the rest of the keys, therefore, it is very important that the PRIMARY KEY is as small as possible and therefore requests to tables on InnoDB using PRIMARY KEY are executed very quickly. <br><br>  What we get: there is a composite key PRIMARY KEY (`daily_entry_stats_entry_id`,` daily_entry_stats_date`) <br>  which takes 4 bytes (int) + 8 bytes (dattime) = 12 bytes <br><br>  2. Since the DATETIME data type takes up quite a lot of space (8 bytes), it is probably more appropriate that dates that fall between 1970 and 2038 should be better represented in TIMESTAMP.  But based on the line in the manual <br>  The TIMESTAMP values ‚Äã‚Äãare converted to the current time zone.  Those.  2 additional operations are performed when saving and retrieving the date.  That is best in this case, the date stored in INT <br><br>  During the solution, many solutions to the problem were proposed.  Various caching, the creation of a temporary inmemori table containing the results, so that exactly it is. <br><br>  Even experimented with sharding.  But sharding in this case was also ineffective, since  report times overlap; for example, a 12-hour report includes a 6-hour report data.  Therefore, reports for large periods also require data from several shards, and the possibility of partishig (degenerate sharding, corrected at the request of% andry%) is supported in version 5.1, which is not yet a release, so everything remains only attempts. <br><br>  After trying various options, I came up with a variant with denormalization.  Those.  it was decided to create several tables, for each of the statistics intervals - stats_hour, stats_2hour, stats_6hour, stats_12hour, stats_day <br>  then you get rid of GROUP BY ... HAVING = WHERE. <br><br>  And accordingly, when it is necessary to get statistics on some time interval, we specify the table we need. <br>  The truth has increased the number of tables for statistics.  And data is stored redundantly.  But along with caching (memcached) is quite workable. <br><br>  Moreover, it is quite simple to add / change existing intervals; all that is needed is to make changes to the cron script that fills these tables. <br>  My solution does not claim the best, it would be interesting how you would solve such a problem. <br>  I hope to read it in the comments :-) <br><br></div><p>Source: <a href="https://habr.com/ru/post/38907/">https://habr.com/ru/post/38907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../38902/index.html">MDC: beta release of a new multi-protocol messenger</a></li>
<li><a href="../38903/index.html">Do you like thumbnails of designs?</a></li>
<li><a href="../38904/index.html">Google - personal apocalypse</a></li>
<li><a href="../38905/index.html">Acapela Alyona Voice Engine</a></li>
<li><a href="../38906/index.html">Augmented Reality Barcode</a></li>
<li><a href="../38909/index.html">"Death March" Volume 2. Yordon's Second Coming</a></li>
<li><a href="../38910/index.html">End of CSS expressions</a></li>
<li><a href="../38911/index.html">Cache Theory (Part Two, Practical, Augmented)</a></li>
<li><a href="../38912/index.html">Available for download ReSharper 4.1</a></li>
<li><a href="../38914/index.html">Where better to keep a blog?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>