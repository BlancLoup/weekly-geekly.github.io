<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Crackme Analysis # 1 by PE_Kill</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 

 I haven't been researching anything for a long time, so to speak, I retired. But then I came across another hand-made article of many well...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Crackme Analysis # 1 by PE_Kill</h1><div class="post__text post__text-html js-mediator-article"><h3>  Foreword </h3><br><img src="https://habrastorage.org/storage2/07f/32a/6cb/07f32a6cbbb3abdd210d4df9b53113b8.png" align="right"><br>  I haven't been researching anything for a long time, so to speak, I retired.  But then I came across another hand-made article of many well-known in certain circles PE_Kill'a.  Because  I had the opportunity to solve his previous work in the framework of <a href="http://exelab.ru/f/contest/">CRACKL @ B Contest 2010</a> , which, in turn, was quite interesting, I decided to look at his new ‚Äúbrainchild‚Äù. <br><br>  What awaits you under the cut: fake CRC32, brute key for RC4, factorization for RSA, as well as the use of collisions for MD4 and the generation of two different messages with the same hashes.  All this and more under the cut. <br><a name="habracut"></a><br>  The article is not designed for a beginner, I will not chew all actions.  The purpose of which is to write keygen. <br><br><h3>  Introduction </h3><br>  As mentioned above, for a long time I didn‚Äôt do the locating.  Therefore, it was necessary to spend some time on the ‚Äúswing‚Äù.  Also partially restore your toolkit, because  I only have <a href="http://ollydbg.de/">OllyDbg</a> and <a href="http://www.hex-rays.com/products/ida/support/download_freeware.shtml">IDA</a> .  The latter will not be used.  And recalling his task from the contest, I was waiting for something interesting that would make me activate my brain much more than usual.  And I was not mistaken. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  To battle </h2><br><br><h3>  Receiving intelligence </h3><br>  Well, first we need <a href="http://peco.at.ua/load/0-0-0-6-20">crackme</a> itself.  We open it in Ollydbg and see that it is packed with UPX, well, now they hardly frighten anyone.  I took the path of least resistance, and unpacked it with <a href="">QUnpack</a> .  Further, following my technique developed over the years, I decided to analyze it using different crypto, hash, cheksum algorithms.  For this, I used the <a href="http://tuts4you.com/download.php%3Fview.1923">SnD Reverser Tool</a> , which told me that I had found <a href="http://ru.wikipedia.org/wiki/CRC32">CRC32</a> , <a href="http://ru.wikipedia.org/wiki/RC4">RC4</a> , <a href="http://ru.wikipedia.org/wiki/md4">MD4</a> .  Now, knowing all this, you can proceed to more active actions. <br><br><h3>  In the rear of the enemy </h3><br>  So, having finished the static analysis, we proceed to the dynamic analysis, i.e.  Let's go debug.  Again, open the crackme (hereinafter - the crack) in OllyDbg (hereinafter - olka), but not the original, but unpacked.  Press Ctrl + G and enter GetDlgItemTextA, so we go to the beginning of this function, set a breakpoint and start it.  Enter the name and some license for the test and click Check.  So we started at our stopping point, press Alt + F9 and get into the code of our quacks right after calling the function to get the name. <br><img src="https://habrastorage.org/storage2/c73/078/6a1/c730786a1fcbd45f9d904540e1546ef0.png"><br>  Then there are two checks of the length of the name, the first is that the name was entered, and the second is meaningless.  In the second check, if the length of the name is 50, we are informed that the name is long and exit.  Why it is meaningless, but because the name is obtained as follows: <br><blockquote><pre><code class="cpp hljs">GetDlgItemTextA(hDlg, IDC_NAME, szName, <span class="hljs-number"><span class="hljs-number">50</span></span>);</code> </pre> </blockquote><br>  This means that the maximum it can read is a string no longer than 50 characters, where the 50th character is the end of line character, and we have that the length of the string will never exceed 49 characters.  Similarly, with the license, but it is not critical.  After all this, there is a cherished function, in which all the most interesting happens, I called it - CheckLicense. <br><br><h3>  In enemy trenches </h3><br>  And so we are in the heart.  The first couple of functions is the translation of the characters of the license into upper case, and then the transfer of the license into an array of bytes and there is already a check on the length of the license. <br><img src="https://habrastorage.org/storage2/e70/be0/d51/e70be0d512f899820992931f07fb50ec.png"><br>  In the line feed function it will be seen that it checks the license for alphabetical compliance (0‚Äì9, AF), i.e.  A license is some kind of data array, translated into a hex, and at the end it is checked whether the resulting array is not equal to 0 √ó 90 bytes.  It follows that the license must be 0 √ó 90 * 2 = 0 √ó 120 (288) characters long. <br>  After all this, we return to the main function.  Next comes the check sum of the first 0 √ó 8C bytes of this array (hereinafter, we will call this array a license) with a 4 byte number that is at the end of the license. <br><img src="https://habrastorage.org/storage2/34b/b44/ab0/34bb44ab056b043405dac191eaff1440.png"><br>  And then there are 10 circles of manipulations with the name, the result of each circle is placed in a separate element of the array of 4 byte numbers.  Looking ahead to say that this array will be the key for RC4, so I will call it a key. <br><br>  Round 0‚Äì2: <br><img src="https://habrastorage.org/storage2/cd7/8cb/860/cd78cb86027e5df53d169ce1f3a108fd.png"><br>  All circles except Round1 are used once, therefore they were perceived by the compiler as inline functions, but round1 itself will still be used twice at the end as a kind of function for getting the control data. <br><br>  Round 3-4: <br><img src="https://habrastorage.org/storage2/20a/f6c/ee0/20af6cee0979fa52a04ad59dc1e8c474.png"><br><br>  Round 5‚Äì7: <br><img src="https://habrastorage.org/storage2/886/49f/49a/88649f49a38778e2d5ecbbda8832beeb.png"><br><br>  Round 8‚Äì9: <br><img src="https://habrastorage.org/storage2/1c5/353/842/1c53538428b77a17a2c7560d45daad07.png"><br><br>  As you can see, round9 is identical to the calculation of the control sum of the license, which was at the very beginning. <br>  After all this, with a key, by simple manipulations, we find the values ‚Äã‚Äãfor the subsequent xor of the same key.  Also, this value will be used in another check after decrypting the very first 0 √ó 8C bytes of the license using RC4 and with the key we received from the name.  And in another manipulation, the result of which we need further. <br><img src="https://habrastorage.org/storage2/0ae/b95/fb7/0aeb95fb7a9955d91d62510f13d20b32.png"><br><br>  Then we get two more values ‚Äã‚Äãthat we need next.  With XorKey, we get the number of bits to shift, and from the key we need the byte, which we should receive when shifting a certain value by the number of bits that we received above.  Well, actually the very decoding on RC4.  As I determined that this is it, well, first of all I know the list of possible algorithms that are used here, and secondly by the key initialization algorithm, who have met this algorithm more than once, I also think that I would quickly recognize it. <br><img src="https://habrastorage.org/storage2/91d/cf1/ed1/91dcf1ed16b3ea4fc7880334c0a4c95d.png"><br>  And here is the test where this value was needed.  After decryption, we should be in the License [34] (if we consider the license as an array of 4 byte values, which we will continue to do) the value is identical to XorKey.  This ends the easiest part of this crack.  It took me much more time and effort to go further. <br>  Next comes the CRC32 count of 8 bytes of the license, which should be 0xFFB97FE0.  If everything passes, then further these 8 bytes serve as a key to decrypt two hard-coded values ‚Äã‚Äãusing the RC4 algorithm and the output should receive two faces.  So, here is the first interesting place that is in the quacks.  Googling, I did not find any collisions for RC4 that would help me find the key, so the decision was made to crack.  But getting 8 bytes in the forehead is a bit silly and long.  It is good that I have already dealt with a fake CRC32 and I understood in which direction to walk.  For those who do not know, in a couple of words, it sounds like this - ‚Äúwith any data you can get the CRC32 we need, you just need to add / replace 4 necessary bytes‚Äù.  Details about this can be found <a href="http://www.rsdn.ru/article/files/classes/SelfCheck/crcrevrs.pdf">here</a> .  From here we have that now it is necessary to not 8 bytes, but 4, which makes life much easier for us.  I decided not to write abstruse brutere using different technologies, multithreading, parallelization of calculations.  I wrote a simple single-stream brutere, which on my AMD II X2 250 found the key in 15 minutes. <br>  This is what my brutera looks like: <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> key[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pkey = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;key; rc4_key skey; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rc4_data[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { fix_crc_end(pkey, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFB97FE0</span></span>); prepare_key(pkey, <span class="hljs-number"><span class="hljs-number">8</span></span>, &amp;skey); rc4_data[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xE6C5D5E1</span></span>; rc4_data[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x41C98EAB</span></span>; rc4((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)rc4_data, <span class="hljs-number"><span class="hljs-number">8</span></span>, &amp;skey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc4_data[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0xFACE0001</span></span> &amp;&amp; rc4_data[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0xFACE0002</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Key: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%02X"</span></span>, *pkey++); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (key[<span class="hljs-number"><span class="hljs-number">0</span></span>]++ &lt;= <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n\n\t\tFin!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </blockquote><br><img src="https://habrastorage.org/storage2/036/ffe/47a/036ffe47aaa13b36c3aee211fb506120.png"><br><br>  I found the right key, now I can generate keys that will pass all the checks passed above.  Knowing all this, you can present a general view of the license: <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LICENSE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> M1[<span class="hljs-number"><span class="hljs-number">0x40</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> M2[<span class="hljs-number"><span class="hljs-number">0x40</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FaceKey1; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FaceKey2; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AfterXorKey; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LicenseCheckSum; } LICENSE, *LPLICENSE;</code> </pre> </blockquote><br>  The last 4 values ‚Äã‚Äãhave already been disassembled, only the first 0 √ó 80 bytes of the license remain, looking ahead to say that these are two messages of 0 √ó 40 bytes. <br><br>  After the face immediately goes the call of the function to which the pointer to the license is transmitted, I have already signed it as <a href="http://ru.wikipedia.org/wiki/Rsa">RSA</a> .  I will try to explain a little how I understood it.  After entering inside this function, 3 identical functions go in succession, into which a pointer to the data array, its size and a pointer to the buffer with the result are passed.  This function reads from the array byte-by-byte and in reverse order, i.e.  from the last element of the array to the first.  This is very similar to the initialization of large numbers.  This is the first thing that occurred to me. <br><img src="https://habrastorage.org/storage2/893/a8e/67d/893a8e67d186c9f6119cb0d5e8652ba1.png"><br>  The second call to this function only confirmed my guess when I looked at the dump on the array from which initialization is going, I saw these cherished three bytes 01 00 01. This value is very often used as an exponent in the RSA decoding implementation.  It follows that the first function initialized the public key N. Then I pulled it from the dump and factorized it, for factorization I used <a href="http://sourceforge.net/projects/msieve/">msieve</a> under the GPU.  The key is small, only 256 bits on its factorization took a little more than 4 minutes. <br><img src="https://habrastorage.org/storage2/65e/db2/89c/65edb289cc9e3df617e398f4bc9a8014.png"><br>  I used to always try to adhere to the rule that you need to use the same libraries and classes in keygens as in the victim.  So I decided to look for clues that the library for large numbers was used for.  A little bit of tracing came across such a message, having typed in the text of the message in Google quickly found the library that is being used, it turned out to be <a href="http://www.di-mgt.com.au/bigdigits.html">BigDigits</a> . <br><img src="https://habrastorage.org/storage2/939/979/1ac/9399791ac6a1ef4ccb3ee9d3be02b88e.png"><br>  After that there is a check that the 6th element of the first message equals the same element of the second one.  And also that this value when shifting to the right on the ShiftCount bit had the low byte is the same as NeedByte.  All these two values ‚Äã‚Äãwe obtained above. <br><img src="https://habrastorage.org/storage2/896/44c/4cf/89644c4cfec5ed9e885701374974c16a.png"><br>  After that there is a check that the CRC32 of the first and second messages were not equal, then the same comparison is only a function of round1.  After everything is disassembled, you can see that there seems to be nothing special about this part of the crack, as well as the next. <br><img src="https://habrastorage.org/storage2/f64/b95/29a/f64b9529a8ba93ff703d751f8eb5620e.png"><br>  And at the very end are the MD4 hashes of the first and second messages, and if they are equal, then we successfully passed the test.  But wait, if these messages should have a different checksum for the two functions, then the messages should be different, but they should have the same hash, which does not fit. <br>  And here Google again comes into play with the query ‚Äúmd4 collisions‚Äù, and the truth about infa for MD4 is, and different, there are voluminous articles, and there are superficial ones.  And in one of these articles I find that the Chinese were able to create two different messages of 0 √ó 40 bytes with the same hashes, here it is.  Now we go to Google with the following request ‚Äúmd4 collisions sources‚Äù and true, there are sources for finding two such messages, but they were written under Linux, where the random function returns a 4-byte number, and in rand returns just 0 and RAND_MAX ( 32767).  Because of what I had problems for a long time, why it generates the wrong messages for me.  After the prompt, I rewrote the random function with Delphi, and it all worked out with a bang. <br><br><h3>  We write keygen </h3><br><br>  I will not describe all the steps in writing keygens, and only pay attention to some important points.  First we create a key for RC4 from the name, I will omit it, there is nothing complicated there, for the lazy, you can simply rip this whole part.  Next you need to find the value for the key key and poxorize the key itself, then from this value find ShiftCount and NeedByte.  This part can also be ripped, to find the desired byte, you also need to rip the table of 256 bytes.  Write the XorKey value to the license according to the structure above.  You can also write down two values, which are the key for finding faces, they will be constant and the same for all.  After that, you need to generate two messages, but the fact is that there, if you remember, the 6th element must have a certain format.  The function of generating messages itself has no parameters, but since you need to transfer two values ‚Äã‚Äãto it, it is ShiftCount and NeedByte.  We change the prototype and add a couple more lines to the code of this function itself.  It was: <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(X0[ <span class="hljs-number"><span class="hljs-number">5</span></span>] != X1[ <span class="hljs-number"><span class="hljs-number">5</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre> </blockquote><br>  And it became: <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(X0[ <span class="hljs-number"><span class="hljs-number">5</span></span>] != X1[ <span class="hljs-number"><span class="hljs-number">5</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((X0[<span class="hljs-number"><span class="hljs-number">5</span></span>] &gt;&gt; c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) != b) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre> </blockquote><br>  where c is ShiftCount, b is NeedByte. <br>  Then the messages are placed in X0 and X1, respectively.  Then we combine these messages into one big one and thrust it into RSACrypt.  The decoding itself goes in blocks of 0 √ó 20 bytes, so we will encrypt it.  But because of this, I also had problems, who do not know, the message (M is our block of 0 √ó 20 bytes) should be less than the public key (N), in cracks it is not taken into account, and it decrypts everything.  Therefore, we must take this into account.  I added a check to the encryption function, if N &lt;M, then we exit and generate new messages, because of which the license generation time is delayed to 15 seconds.  After everything has been successfully encrypted using RSA, we encrypt the entire license without the last value in the structure using RC4 with the key we received from the name.  And the last step is to calculate the checksum of the part of the license that was encrypted using RC4 and write it to the last value of the structure and translate the entire license to a hex string. <br><br>  That's all! <br><br><h2>  Materials </h2><br>  ‚Ä¢ <a href="http://www.rsdn.ru/article/files/classes/SelfCheck/crcrevrs.pdf">www.rsdn.ru/article/files/classes/SelfCheck/crcrevrs.pdf</a> - fake CRC32 <br>  ‚Ä¢ <a href="http://www.en.wikipedia.org/wiki/MD4">www.en.wikipedia.org/wiki/MD4#Collision_Attacks</a> - MD4 collisions <br>  ‚Ä¢ <a href="http://www.google.com/">www.google.com</a> <br>  ‚Ä¢ <a href="http://www.wikipedia.org/">www.wikipedia.org</a> <br><br><h2>  Sources </h2><br>  ‚Ä¢ <a href="https://github.com/reu-res/Keygen-for-CrackMe-1-by-PE_Kill">github.com/reu-res/Keygen-for-CrackMe-1-by-PE_Kill</a> - Bruter and keygen <br><br>  <strong>PS</strong> Keygen accepts Cyrillic, but it depends on how the console is configured.  I personally did not accept from the console, and if you are hard-coded, then everything is fine.  I was lazy to rewrite under the windows. </div><p>Source: <a href="https://habr.com/ru/post/135255/">https://habr.com/ru/post/135255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135248/index.html">Programming language D - continued</a></li>
<li><a href="../135249/index.html">Jack Goldman passed away - founder and director of Xerox PARC</a></li>
<li><a href="../135250/index.html">AppStore and iCloud traffic disclosure</a></li>
<li><a href="../135252/index.html">greetings from npm</a></li>
<li><a href="../135253/index.html">Configuring GNOME Shell</a></li>
<li><a href="../135256/index.html">PHP 5.4 RC4 released</a></li>
<li><a href="../135257/index.html">CSS3 exit panel with iframe inside</a></li>
<li><a href="../135258/index.html">We transfer Redmine from VPS to Heroku or how to get a free project-management tool</a></li>
<li><a href="../135259/index.html">NETCONF. Start</a></li>
<li><a href="../135262/index.html">Sort Numbers by Brainfuck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>