<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reflections on design principles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why invent all these design patterns, principles and techniques? Wouldn't it be easier to do without all this, but just to teach the developers good d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reflections on design principles</h1><div class="post__text post__text-html js-mediator-article">  Why invent all these design patterns, principles and techniques?  Wouldn't it be easier to do without all this, but just to teach the developers good design?  Or why not formalize this process and introduce clear quantitative metrics that say that one solution is definitely better than another? <br><br>  ‚ÄúRight Design‚Äù is the holy grail of young developers and young managers.  And those and others dream of finding the answer to the main question of <s>life, the universe and all such</s> software development - how to achieve high-quality design, in a short time and with a minimum of effort. <br><br>  Over time, both the young developer and the young manager will come to understand that this is impossible.  It is impossible to find a perfect abstract design, since the words ‚Äúperfect‚Äù and ‚Äúabstract‚Äù contradict each other.  Design is a constant search for a compromise between conflicting requirements: performance and readability, simplicity and extensibility, testability and integrity of the solution. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Even if we take into account that the developer always solves the right task, rather than struggling with windmills, it is impossible to say ‚Äúabstractly‚Äù what design characteristics are key here and now. <br><br>  There are formal criteria that describe the quality of a code or design: the cyclomatic complexity of methods, the depth of the inheritance hierarchy, the number of incoming and outgoing links of a class or module, the number of lines of a method, at worst.  These quantitative indicators are useful, but getting them into the specified boundaries is a necessary but not sufficient condition for a good design.  If classes are broken ineptly, and important domain abstractions are not identified, then no matter what quantitative characteristics a design has, it will never be good. <br><br>  In addition to formal criteria, there are universal notions of good design ‚Äî weak coupling (low coupling) and strong coupling (high cohesion).  These properties are useful, but too informal. <br><br>  Between formal and informal criteria are the <a href="http://sergeyteplyakov.blogspot.com/search/label/SOLID">principles of design</a> - a set of rules on which experienced designers rely.  Their goal is to describe in simple terms what is ‚Äúgood and what is bad‚Äù in terms of design: ‚ÄúThe ideal class should have only one reason for change ( <a href="http://sergeyteplyakov.blogspot.com/2014/08/single-responsibility-principle.html">SRP</a> ), have a minimal interface ( <a href="http://sergeyteplyakov.blogspot.com/2014/08/interface-segregation-principle.html">ISP</a> ), correctly implement inheritance ( <a href="http://sergeyteplyakov.blogspot.ca/2014/09/liskov-substitution-principle.html">LSP</a> ) and prevent cascading code changes as requirements change ( <a href="http://sergeyteplyakov.blogspot.ca/2014/08/open-closed-principle.html">OCP</a> ). " <br><br>  Bertrand Meyer in his book ‚ÄúAgile !: The Good, The Hype, and The Ugly‚Äù gives a sufficiently clear definition of what the design principle is [Meyer2014]: <br><br>  ‚ÄúA principle is a methodological rule that expresses a general view of software development.  A good principle is both <i>abstract</i> and refutable.  Abstractness distinguishes principle from <i>practice</i> , and refutation distinguishes principle from <i>platitude</i> (platitude).  <b>Abstractness</b> means that a principle should describe a universal rule, not a concrete practice.  <b>Refutation</b> means that a reasonable person should have the opportunity to disagree with the principle.  If no one in their right mind would dispute the proposed principle, this rule would be useful, but not interesting.  For a rule to be a principle - regardless of your opinion - you must assume the presence of people who hold the opposite point of view. ‚Äù <br><br><h4>  Levels of design principles </h4><br><img src="https://habrastorage.org/files/e75/557/162/e755571621f54e63aff0918860b1a84d.jpg"><br><br>  A developer during his professional career goes through several stages of ownership of such a tool as design principles. <br><br>  <b>At the first stage, the</b> young developer has not yet grown to abstract principles; instead, he is looking for a set of concrete practices that will enable him to get a quality solution.  "I want to hear a set of steps, a strict adherence to which will lead me to the desired result!"  At this stage, the developer is good at copying someone else's solution, and is faced with serious difficulties if the description is too abstract or does not absolutely fit his case. <br><br>  <b>At the second stage, the</b> developer begins to see what underlies the concrete practice, and why design principles are needed.  ‚ÄúYeah, this class violates the SRP because it goes to the base and contains business logic!  It turns out that he has two clear reasons for a change! ‚Äù <br><br>  Despite the increased level, it is at this stage that the most frequent use of principles or patterns for inappropriate purposes occurs.  It is easy to prove that a particular class violates this principle, but at this stage of development it is not always obvious when this violation is justified and when it is not. <br><br>  <b>At the third stage</b> , the developer (or rather, the Architect) develops an instinct and there appears a fairly clear understanding of what problem the specific design principle is intended to solve.  Since, by its definition, the principle is not unambiguous, an experienced developer has an understanding when the violation is justified, when it is possible to live with it, and when the time has come to take on the correction of the design. <br><br>  At this stage, the principles do not control the design of the application, but rather begin to play a communicative role: ‚ÄúLook, your class does too much, which means it violates SRP!  And this class has two types of clients that violates ISP! ‚Äù. <br><br>  <b>NOTE</b> <br>  In martial arts, it is customary to distinguish three stages of mastery: shu, ha, and ri ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%258E%25D1%2585%25D0%25B0%25D1%2580%25D0%25B8">Shu, Ha, Ri</a> ).  At the first stage there is a student who only repeats the movements behind the master.  At the second stage, the student begins to get rid of the rules and begins to decide himself when to follow them, and when not.  At the third stage, the rules disappear, the student becomes a master and can create these rules himself.  The same model, but somewhat under a different sauce, appeared in American culture called the <a href="http://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition">Dreyfus Model</a> . <br><br><h4>  The role of design principles </h4><br>  The application of any design principle has its price.  Crushing a class into smaller components so that it responds to SRP can lead to a blurring of logic across several classes (low cohesion), and sometimes to a drop in performance. <br><br>  Violation of the principle of open-closed may be justified by backward compatibility issues.  We can ignore the Liskov substitution principle, since inheritance does not always determine the ratio of subtypes.  The interface may be thick due to backward compatibility or ease of use.  And inversion of dependencies can easily undermine the encapsulation and lead to the full OOP of the brain. <br><br>  To effectively use the principles you need to know what problem they actually solve and whether it is relevant for you now.  Typically, the relevance of the principles increases with increasing complexity, or with an increase in the cost of making changes.  The key business logic of an application is one example of what should be isolated from the rest of the world.  Any publicly available classes should have a minimum of additional connections with the outside world and should easily allow you to do simple things.  Classes that are located at the interface of modules should be thought out better than others. <br><br>  The key to good design and efficient use of design principles is an iterative approach to design.  In the early stages, we understand little in the subject area, so all we can do is to break the modules into roles: the infrastructure is separate, the logic is separate.  At the same time, class autonomy and minimization of side effects makes the design simpler, since the number of class / module links remains strictly limited. <br><br>  As the application develops, design becomes cluttered with unnecessary patches, and our understanding of the subject area improves.  I try to avoid major refactorings, and make changes to the design in the course of its development.  Before making changes, I try to answer the question: why am I doing this?  If it‚Äôs just that the current solution violates a certain design principle, then before making changes you need to understand if there is a problem. <br><br>  The main driving force behind my changes is ultimately increased complexity.  As soon as I fail to keep the decision in my head, it is difficult to navigate around it or it is not clear where to make changes, then it is time to think about how to improve it. <br><br>  ‚ÄúThe class has become too complicated, it breaks the <a href="http://sergeyteplyakov.blogspot.com/2014/08/single-responsibility-principle.html">SRP</a> , it's time to break it into two.  Information about the inheritance hierarchy has spread all over the module, probably, it is worth hiding it behind the factory.  The class cannot be tested due to the abundance of hidden dependencies, it is time <a href="http://sergeyteplyakov.blogspot.ca/2014/09/the-dependency-inversion-principle.html">to select the class dependencies</a> . ‚Äù <br><br>  At the same time, I always check if principles or patterns didn‚Äôt lead me into the world of overdesign: did my design become easier after making changes?  Do I solve a problem that actually does not exist?  Did I get into the network of premature generalization?  Sometimes you have to perform several iterations before you can find a reasonable solution to a certain problem. <br><br><h4>  Anti-design principles </h4><br><br>  The popularity of design principles can easily play a cruel joke with you and your team.  An excessive love of principles and patterns can manifest itself in the form of over-engineering and excessive complexity.  But knowing this, we can prepare and predict how the excessive love of principles will manifest itself in the application code. <br><br>  <b>Anti-</b> <b>SRP</b> <b>- The principle of</b> <b>vague</b> <b>responsibility</b> .  Classes are divided into many small classes, as a result of which the logic is spread over several classes / modules. <br><br>  <b>Anti</b> <b>-OCP</b> <b>- The principle of factory-factories</b> .  The design is too general and extensible, there are too many levels of abstraction. <br><br>  <b>Anti</b> <b>-LCP</b> <b>- The principle of incomprehensible inheritance.</b>  The principle is manifested either in an excessive amount of inheritance, or in its complete absence, depending on the experience and views of the local chief architect. <br><br>  <b>Anti</b> <b>-ISP</b> <b>- The principle of thousands of interfaces.</b>  Interfaces of classes are broken into too many components, which makes them inconvenient for all customers to use. <br><br>  <b>Anti-DIP - The principle of inversion of consciousness</b> or <b>DI-brain.</b>  Interfaces are allocated for each class and are transmitted in batches through constructors.  Understanding where the logic is located is almost impossible. </div><p>Source: <a href="https://habr.com/ru/post/239431/">https://habr.com/ru/post/239431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239415/index.html">Jump start on October 7th. Modernizing the company's IT infrastructure using Windows Server 2012 R2</a></li>
<li><a href="../239419/index.html">Installing and running Asterisk on an Android smartphone</a></li>
<li><a href="../239421/index.html">NemerleWeb - Unique Web Framework</a></li>
<li><a href="../239423/index.html">Chrome who stole christmas</a></li>
<li><a href="../239429/index.html">Another non-discovery of life on Mars?</a></li>
<li><a href="../239433/index.html">Apache Cordova adds support for Windows 8.1 and Windows Phone 8.1</a></li>
<li><a href="../239435/index.html">Dangerous finally or waiting 5.6</a></li>
<li><a href="../239439/index.html">How an IT freelancer to become an entrepreneur. Part 2</a></li>
<li><a href="../239441/index.html">Mobile version of the site or responsive design?</a></li>
<li><a href="../239443/index.html">We receive information about the program and load it via CMD (man and apt-get for Windows?)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>