<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenCV. Search for road signs using contour analysis in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! 

 I want to share my own implementation of the road sign search algorithm. 

 Why contour analysis? 

 Contour analysis has a rather weak re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenCV. Search for road signs using contour analysis in Android</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/59/d7/5b/59d75b1c3b02d060071745.png" height="350" align="left">  Hi Habr! <br><br>  I want to share my own implementation of the road sign search algorithm. <br><br>  Why contour analysis? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Contour analysis has a rather weak resistance to interference, but the simplicity and speed allowed us to apply this approach quite successfully. <br><br><br clear="all"><br clear="all">  However, in practice, it turned out to be quite difficult to implement the search for the necessary coefficients on the Android platform (I did not try to use OpenCV widgets, instead divided the screen into frames, where the settings are on the left, the video from the back camera is on the right).  The specific implementation of the UI and project logic is available at the link below. <br><a name="habracut"></a><br>  The sequence of road sign search operations is as follows: <br><br><ul><li>  Noise reduction <br><br>  For example, through a nonlinear filter <br><br><pre><code class="cpp hljs">cv::medianBlur(original, original, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br></li><li>  Convert image from RGBA to HSV <br><br><img src="https://habrastorage.org/webt/59/d7/6b/59d76b02cf696117061141.png" height="190" align="left">  When using the HSV color model, the base red color of the road sign is more accurately distinguished based on the color tone, saturation and brightness. <br><br>  At the same time, speaking of the color tone, they usually mean color.  Saturation indicates how much the described color is diluted with white (pink, for example, is a mixture of red and white).  The concept of brightness is most difficult to describe, and with some assumptions brightness can be understood as the intensity of light. <br><br><pre> <code class="cpp hljs">cv::Mat hsv; cv::cvtColor(original, hsv, cv::COLOR_RGB2HSV); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_HSV) { *(cv::Mat*)matAddress = hsv; }</code> </pre><br></li><li>  Highlight road sign by color <br><br><img src="https://habrastorage.org/webt/59/d7/5b/59d75b1f347a9530594052.png" height="350"><br><br>  During processing, the image is divided into separate channels H, S and V, which are subsequently binarized along a certain threshold and combined by logical addition into the final matrix of the image. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::Mat&gt; channels; cv::split(hsv, channels); cv::Mat minHueThreshold = channels[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; lowerHue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_HUE_LOWER) { *(cv::Mat*)matAddress = minHueThreshold; } cv::Mat maxHueThreshold = channels[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; upperHue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_HUE_UPPER) { *(cv::Mat*)matAddress = maxHueThreshold; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_HUE) { *(cv::Mat*)matAddress = minHueThreshold | maxHueThreshold; } cv::Mat saturationThreshold = channels[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; minSaturation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_SATURATION) { *(cv::Mat*)matAddress = saturationThreshold; } cv::Mat valueThreshold = channels[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; minValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_VALUE) { *(cv::Mat*)matAddress = valueThreshold; } cv::Mat colorFiltered = (minHueThreshold | maxHueThreshold) &amp; saturationThreshold &amp; valueThreshold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_RED_FILTERED) { *(cv::Mat*)matAddress = colorFiltered; }</code> </pre><br></li><li>  Detection of the road sign on the outer contour <br><br><img src="https://habrastorage.org/webt/59/d7/5b/59d75b0f7c23a145646903.png" height="350"><br><br>  First of all, the operation of stretching is carried out, which eliminates noise and contributes to the unification of areas of the image that were separated by objects, shadows. <br><br><pre> <code class="cpp hljs">cv::Mat colorDilated; cv::dilate(colorFiltered, colorDilated, cv::Mat()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layerType == LAYER_DILATED) { *(cv::Mat*)matAddress = colorDilated; }</code> </pre><br>  To search for contours, the SimpleBlobDetector class is used, which is nothing more than a special case of the implementation of the findContours () function for round objects.  It can find external and nested contours and determine their nesting hierarchy. <br><br><pre> <code class="cpp hljs">cv::SimpleBlobDetector::Params params; params.filterByColor = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; params.filterByConvexity = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; params.filterByInertia = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; params.filterByArea = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// A = 254.46900494077 px^2      9 px params.minArea = 255; // A = 723822.94738709 px^2      480 px params.maxArea = 723823; params.filterByCircularity = true; params.minCircularity = 0.85f; cv::Ptr&lt;cv::SimpleBlobDetector&gt; detector = cv::SimpleBlobDetector::create(params); std::vector&lt;cv::KeyPoint&gt; keyPoints; detector-&gt;detect(colorDilated, keyPoints);</span></span></code> </pre><br>  In the keyPoints vector, the coordinates and the radius of the contour of the road sign are written, which are then highlighted on the screen. <br></li></ul><br>  Not to say that it works well in real-world conditions (perhaps, the detection algorithm is not the best, but it turned out to be the easiest to use).  And there are difficulties in finding the optimal coefficients (there was plenty of "hunting" for road signs in my city; I even met signs that had faded from the sun, there was no red on them at all). <br><br>  But simplicity is pleasing to the eye, so it is quite possible to find an application to contour analysis, for example, in robotics. <br><br>  From the additional buns on the experience of using OpenCV in Android: <br><br><div class="spoiler">  <b class="spoiler_title">Rotate camera image if it is flipped</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-function">JNIEXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_ru_dksta_prohibitingsigndetector_ActivityMain_rotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* *env */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jclass </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* activity */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jlong matAddress, jint angle)</span></span></span><span class="hljs-function"> </span></span>{ CV_Assert(angle % <span class="hljs-number"><span class="hljs-number">90</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; angle &lt;= <span class="hljs-number"><span class="hljs-number">360</span></span> &amp;&amp; angle &gt;= <span class="hljs-number"><span class="hljs-number">-360</span></span>); cv::Mat* mat = (cv::Mat*) matAddress; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle == <span class="hljs-number"><span class="hljs-number">180</span></span> || angle == <span class="hljs-number"><span class="hljs-number">-180</span></span>) { cv::flip(*mat, *mat, <span class="hljs-number"><span class="hljs-number">-1</span></span>); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Implementing Salt &amp; Pepper Noise</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-function">JNIEXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_ru_dksta_prohibitingsigndetector_ActivityMain_saltPepperNoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* *env */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jclass </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* activity */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jlong matAddress)</span></span></span><span class="hljs-function"> </span></span>{ cv::Mat* mat = (cv::Mat*) matAddress; cv::Mat noise = cv::Mat::zeros((*mat).rows, (*mat).cols, CV_8U); cv::randu(noise, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); cv::Mat black = noise &lt; <span class="hljs-number"><span class="hljs-number">30</span></span>; cv::Mat white = noise &gt; <span class="hljs-number"><span class="hljs-number">225</span></span>; (*mat).setTo(<span class="hljs-number"><span class="hljs-number">255</span></span>, white); (*mat).setTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, black); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Displaying video from a camera with processing in the 'picture in picture' mode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secondView) { cv::Mat miniView = colorDilated.clone(); cv::cvtColor(miniView, miniView, cv::COLOR_GRAY2RGB); cv::resize(miniView, miniView, cv::Size(), <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, cv::INTER_LINEAR); cv::Size miniSize = miniView.size(); cv::Size maxSize = original.size(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startY = maxSize.height - miniSize.height; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = startY; y &lt; maxSize.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; miniSize.width; x++) { (*(cv::Mat*)matAddress).at&lt;cv::Vec3b&gt;(cv::Point(x, y)) = miniView.at&lt;cv::Vec3b&gt;(cv::Point(x, y - startY)); } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Writing text in OpenCV</b> <div class="spoiler_text"><pre> <code class="cpp hljs">cv::Mat* mat = (cv::Mat*)matAddress; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> textStartY = TEXT_LINE_HEIGHT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> output; output &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setfill(<span class="hljs-string"><span class="hljs-string">'0'</span></span>) &lt;&lt; fpsCount &lt;&lt; <span class="hljs-string"><span class="hljs-string">" FPS"</span></span>; cv::putText(*mat, output.str(), cv::Point(TEXT_START_X, textStartY), FONT_FACE, FONT_SCALE, GREEN, TEXT_THICKNESS); output.seekp(<span class="hljs-number"><span class="hljs-number">0</span></span>); textStartY += TEXT_LINE_HEIGHT; cv::putText(*mat, getLayerTypeDesc(layerType), cv::Point(TEXT_START_X, textStartY), FONT_FACE, FONT_SCALE, GREEN, TEXT_THICKNESS);</code> </pre><br></div></div><br>  ‚Üí <a href="https://github.com/androidovshchik/ProhibitingSignDetector">Link to project</a> </div><p>Source: <a href="https://habr.com/ru/post/339506/">https://habr.com/ru/post/339506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339496/index.html">Fuel for AI: a selection of open datasets for machine learning</a></li>
<li><a href="../339498/index.html">Overview of one Russian RTOS, part 7. Means of data exchange between tasks</a></li>
<li><a href="../339500/index.html">What the Android DevOps-engineer head hurts</a></li>
<li><a href="../339502/index.html">Fintech track GenerationS - another chance for your fintech startup</a></li>
<li><a href="../339504/index.html">Generalized search for paths for AI in platformers</a></li>
<li><a href="../339508/index.html">How to run docker-voting on Swarm, Kubernetes and Nomad</a></li>
<li><a href="../339510/index.html">As we scrum scaled</a></li>
<li><a href="../339512/index.html">Uneducated youth: yes, another post from the student‚Äôs point of view</a></li>
<li><a href="../339516/index.html">Zabbix conference 2017: how was the first day</a></li>
<li><a href="../339518/index.html">The Unified State Automated Information System is not as terrible as they are frightened: what will the unique DataMobile module of the Unified State Automated Information System help retail stores with?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>