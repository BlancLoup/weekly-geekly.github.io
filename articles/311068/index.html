<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Springboard Calling Magic Functions in PHP 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will look at the optimization in a virtual machine in PHP 7 (Zend virtual machine) in detail. First, let's touch on the theory of s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Springboard Calling Magic Functions in PHP 7</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/390/96e/1e4/39096e1e44b04bd29d5f94a7dae571b5.jpg"><br><br>  In this article we will look at the optimization in a virtual machine in PHP 7 (Zend virtual machine) in detail.  First, let's touch on the theory of springboards function calls, and then find out how they work in PHP 7. If you want to fully understand everything, then it is better to have a good understanding of the work of the Zend virtual machine.  For starters, you can <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">read</a> how the VM is arranged in PHP 5, and here we will talk about the PHP 7 VM. Although it has been reworked, it works in much the same way as PHP 7. Therefore, if you figure it out in the PHP 5 VM, you will understand with VM PHP 7 will not be any difficulty. <br><a name="habracut"></a><br><h1>  It's all about recursion </h1><br>  If you have never heard of springboards, you probably didn‚Äôt touch languages ‚Äã‚Äãlike Haskell or Scala.  The function call trampoline is a trick that is usually talked about in depth programming training courses.  The task of the springboard is to prevent the recursiveness of function calls.  This is a theoretical basis.  If you do not know what recursion is, then first ask.  There is nothing difficult in it. <br><br>  There are many ways to implement the springboard mechanism in applications.  Let's start with a simple example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $n; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $n * factorial($n<span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre> <br>  The easiest way to understand recursion is in the well-known factorial function.  She has very few instructions, and above all - she calls herself. <br><br>  As you know, with every function call a lot of things happen.  At the bottom level, the compiler prepares for the call using the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B3%25D0%25BB%25D0%25B0%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BE_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B5">function calling convention</a> .  In fact, the compiler first passes the arguments and the return address to the stack, and then generates a CALL opcode that translates the processor to the first instruction of the function body.  When it is completed, the RETURN opcode is used (if it is not in the function body, it is generated by the compiler), telling the processor to get rid of the stack of arguments (the stack pointer is reset) and return to the return address. <br><br>  The problem with this model is that the stack is a part of memory, finite and small in size.  In Linux, 8 MB ( <i>ulimit -a</i> ) is usually allocated for the stack.  Recursive functions very actively use the stack, because each record at the recursive level creates a new frame in the stack.  If you get too carried away, you can fill the entire stack.  In this case, the kernel usually issues a SIGBUS signal to the processor and terminates the stack if it does not fall before this (for example, if you use <code>alloca()</code> ). <br><br>  Although the place in the stack rarely ends (except for bugs in the program), in addition to recursive functions, you can harm the creation of the stack and the subsequent destruction (when the function returns) of the call frame.  This eats away some processor cycles (for stack-oriented instructions like <code>mov</code> , <code>pop</code> , <code>push</code> and <code>call</code> ) and always implies accessing main memory.  And - it is slow.  If your program can work with a single function, without calling children, it will act faster: the processor does not need to infinitely create and delete stacks, moving blocks of memory that the program does not use directly, they are simply part of the architecture.  Today, processors usually use registers to store stack arguments or return addresses (for example, LP64 on Linux), but still avoid recursion, at least its deepest levels. <br><br><h1>  Prevent recursion </h1><br>  There are several ways to prevent recursion when calling functions.  We will use PHP to get familiar with simple ways.  A more traditional way will be studied using the springboard function, and then, using the example of the PHP source code, we consider the operation of this mechanism added to the core of PHP 7. <br><br><h3>  Tail call functions and loops </h3><br>  Recursion is a type of the cycle ‚Äúuntil XXX, I call myself‚Äù.  Consequently, the recursive function can be rewritten using a loop (sometimes even a few) without any call to itself.  However, keep in mind that this is not an easy task, it all depends on the function itself: how many times and how it calls itself. <br><br>  Fortunately, one can easily ‚Äúde-recurse‚Äù the factorial function.  To do this, we will use a method called tail-call transformation.  You can unleash the factorial function by turning it into a recursive tail call function and applying a certain rule.  Let's do the transformation first: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail_factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n, $acc = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $acc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tail_factorial($n<span class="hljs-number"><span class="hljs-number">-1</span></span>, $n * $acc); }</code> </pre><br>  Here we used the so-called battery.  At the end we have to get the tail call function.  Let me remind you: this is the name of the function, which, when it comes to returning itself, does so without performing any other operations.  That is, the return expression passes <b>only a</b> recursive function, without additional operations.  For example, re-entry with a single instruction stream (single-instruction reentrant).  Thus, the compiler optimizes the last call: the function simply returns itself, therefore, the creation of the stack is simplified by reusing the current stack frame instead of creating a new one.  We can now also convert this tail call function, the body of which is simply a loop.  Instead of calling back a function with modified arguments, you need to jump again to the beginning of the function (as a recursive call would have done), but at the same time changing the arguments so that the next cycle is executed with the correct values ‚Äã‚Äãof the arguments (as the recursive function does).  We get: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unrolled_factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n)</span></span></span><span class="hljs-function"> </span></span>{ $acc = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { $acc *= $n--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $acc; }</code> </pre><br>  This function does the same thing as the original <code>factorial()</code> , but no longer calls itself.  During runtime, this is much more productive than a recursive alternative. <br><br>  We could also use the <code>goto</code> branch: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goto_factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n)</span></span></span><span class="hljs-function"> </span></span>{ $acc = <span class="hljs-number"><span class="hljs-number">1</span></span>; f: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $acc; } $acc *= $n--; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> f; }</code> </pre><br>  Again, no recursion. <br><br>  Try running <code>factorial()</code> with a huge number: you‚Äôre running out of a stack, and you‚Äôll run into the engine‚Äôs memory limit (since the stack frames in the virtual machine are placed on the heap).  If you disable the limit ( <i>memory_limit</i> ), then PHP will crash, because neither it nor the Zend virtual machine has protection against infinite recursion.  Consequently, the process will collapse.  Now try running with the same argument <code>unrolled_factorial()</code> or even <code>goto_factorial()</code> .  The system will not fall.  It may not run too fast, but it will not fall, and the place on the stack (located on the PHP heap) will not end.  Although the speed of execution will be much higher than in the case of the recursive function. <br><br><h3>  Tailing Springboard Control Functions </h3><br>  Sometimes it happens that the function is not easy to de-cycle.  Factorial is simple, but some others are much more complicated.  For example, functions that call themselves in different places, in different conditions, and so on (like a simple implementation of <code>bsearch()</code> ). <br><br>  In such cases, a <a href="https://en.wikipedia.org/wiki/Trampoline_%2528computing%2529">springboard</a> may be needed to curb the recursion.  It will be necessary to rewrite the basic recursive function (as with de-recursion), but this time it can call itself.  We simply disguise these challenges by fulfilling them with a springboard, and not directly.  Thus, recursion will unwind if there is a flow of control (springboard), providing control over each call to our function.  You no longer have to wrestle with how to de-recurse a complex function: just wrap it and run it through a control code called a springboard. <br><br>  Let's look at an example of using this concept in PHP.  The idea is to transform our function so that the code that calls it (caller) can determine when it enters recursion and when it exits.  If you apply this to the most recursive call, then the springboard will be called by him and will manage his stack.  If he returns the result, the springboard must notice it and stop. <br><br>  Like this: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trampo_factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n, $acc = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($n == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $acc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($n, $acc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trampo_factorial($n<span class="hljs-number"><span class="hljs-number">-1</span></span>, $n * $acc); }; }</code> </pre><br>  Here the function still calls itself.  However, it does not do this directly, but wraps the recursive call into a closure.  After all, now we want to run the recursive function not directly, but through a springboard.  When he sees that the closure has returned, he starts the function.  If not closure, returns the function. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $c, ...$args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_callable($c)) { $c = $c(...$args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c; }</code> </pre><br>  Is done.  Use in a similar way: <br><br> <code>echo trampoline('trampo_factorial', 42);</code> <br> <br>  A springboard is a normal solution to the recursion problem.  If you cannot refactor a function to exclude recursive calls, then convert it to a tail call function that can be run through the springboard.  Of course, springboards work only with tail call functions, otherwise. <br><br>  When using the springboard, the functions called are run as many times as necessary, while they are not allowed to call themselves recursively.  Springboard acts as a caller.  We solved the problem of recursion in a much more versatile way that can be applied to any recursive function. <br><br>  Here I used PHP only to explain the essence of the idea to you (I think you often come across PHP as you read these lines).  But I do not recommend creating springboards in this language.  PHP is a high-level language, and such constructs are not required in daily work.  You may not often need recursive functions, and not so lightweight is a loop with the <code>is_callable()</code> call inside. <br><br>  Nevertheless, let's delve into the PHP engine and see how springboards are implemented to prevent stack recursion in the main dispatch loop (dispatch loop) of the PHP virtual machine. <br><br><h1>  Recursion in Zend virtual machine </h1><br>  I hope you have not forgotten what a <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">dispatch loop is</a> ? <br><br>  Let me refresh it in your memory.  All virtual machines are built on several common ideas, among which there is a scheduling cycle.  An infinite loop <code>opline</code> , and each iteration executes ( <code>handler()</code> ) one instruction ( <code>opline</code> ) of the virtual machine.  A lot of things can happen within this instruction, but at the end there is always a command for the loop, usually a command for moving to the next iteration (goto next).  There may also be a return command from an infinite loop or a transition command to this operation. <br><br>  By default, the engine's virtual machine dispatch loop is stored in the <code>execute_ex()</code> function.  Here is an example for PHP 7 with some optimizations for my computer (IP and FP registers are used): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_VM_FP_GLOBAL_REG </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%r14"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_VM_IP_GLOBAL_REG </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%r15"</span></span></span><span class="hljs-meta"> register zend_execute_data* volatile execute_data __asm__(ZEND_VM_FP_GLOBAL_REG); register const zend_op* volatile opline __asm__(ZEND_VM_IP_GLOBAL_REG); ZEND_API void execute_ex(zend_execute_data *ex) { const zend_op *orig_opline = opline; zend_execute_data *orig_execute_data = execute_data; execute_data = ex; opline = execute_data-&gt;opline; while (1) { opline-&gt;handler(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (UNEXPECTED(!opline)) { execute_data = orig_execute_data; opline = orig_opline; return; } } zend_error_noreturn(E_CORE_ERROR, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Arrived at end of main loop which shouldn't happen"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br>  Notice the <code>while(1)</code> structure.  What about recursion?  What's the matter? <br><br>  It's simple.  You have started a <code>while(1)</code> as part of the <code>execute_ex()</code> function.  What happens if a single instruction ( <code>opline-&gt;handler()</code> ) starts <code>execute_ex()</code> ?  Recursion will occur.  This is bad.  As usual: yes, if it is multi-level. <br><br>  When does <code>execute_ex()</code> call <code>execute_ex()</code> ?  Here I will not go too deep into the virtual machine engine, because you can miss a lot of important information.  For simplicity, we assume that this PHP function call calls <code>execute_ex()</code> . <br><br>  Each time you call a PHP function, it creates a new stack frame at the C language level and starts a new version of the dispatch loop, reentering the new <code>execute_ex()</code> call with new instructions for execution.  When this loop appears, the PHP function call is completed, which leads to the return procedure in the code.  Consequently, the current loop of the current frame on the stack ends with the return of the previous one.  Just keep in mind that this happens only in the case of PHP functions in user space.  The reason is that user-defined PHP functions are opcodes that, after starting, run in a loop.  But internal PHP functions (developed in C and located in the kernel or in extensions) do not need to execute opcodes.  These are instructions on pure C, therefore, they do not create another dispatch cycle and another frame. <br><br><h1>  Usage __call () </h1><br>  Now I will explain how to use <code>__call()</code> .  This is a PHP function from user space.  As with any user-defined function, its execution leads to a new <code>execute_ex()</code> call.  But the fact is that <code>__call()</code> can be called multiple times, creating many frames.  Every time an unknown method is called in the context of an object using <code>__call()</code> defined in its class. <br><br>  In PHP 7, the engine was optimized using additional springboard control (mastering) calls to <code>__call()</code> , as well as using prevention of recursive calls to <code>execute_ex()</code> in the case of <code>__call()</code> . <br><br>  <code> __call()</code> in PHP 5.6: <br><br><img src="https://habrastorage.org/files/14e/db9/d80/14edb9d80a8349aebe5d64d4810553a6.png"><br><br>  Here are three calls to <code>execute_ex()</code> .  This is taken from a PHP script that calls an unknown method in the context of an object, which in turn calls an unknown method in the context of another object (in both cases, the classes contain <code>__call()</code> ).  So the first <code>execute_ex()</code> is the execution of the main script (position 6 in the call stack), and at the top of the list we see the other two <code>execute_ex()</code> . <br><br>  Now run the same script in PHP 7: <br><br><img src="https://habrastorage.org/files/961/89d/d29/96189dd298b84b39bc4cddb14a4d88df.png"><br><br>  The difference is obvious: the stack frame is much thinner, and we have only one call to <code>execute_ex()</code> , that is, one dispatch cycle that controls all the instructions, including <code>__call()</code> calls. <br><br><h1>  Turning __ call () calls to springboard calls </h1><br>  In PHP 5, we called <code>execute_ex()</code> in the context of <code>__call()</code> .  That is, we have prepared a new dispatch loop to execute the currently requested <code>__call()</code> opcodes. <br><br>  Let the method called, for example, <code>fooBarDontExist()</code> be executed.  We need to put in memory a number of structures and perform a classic function call from user space.  Something like this (simplified): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_std_call_user_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INTERNAL_FUNCTION_PARAMETERS)</span></span></span><span class="hljs-function"> </span></span>{ zend_internal_function *func = (zend_internal_function *)EG(current_execute_data)-&gt;function_state.function; zval *method_name_ptr, *method_args_ptr; zval *method_result_ptr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; zend_class_entry *ce = Z_OBJCE_P(this_ptr); ALLOC_ZVAL(method_args_ptr); INIT_PZVAL(method_args_ptr); array_init_size(method_args_ptr, ZEND_NUM_ARGS()); <span class="hljs-comment"><span class="hljs-comment">/* ... ... */</span></span> ALLOC_ZVAL(method_name_ptr); INIT_PZVAL(method_name_ptr); ZVAL_STRING(method_name_ptr, func-&gt;function_name, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     :   execute_ex() */</span></span> zend_call_method_with_2_params(&amp;this_ptr, ce, &amp;ce-&gt;__call, ZEND_CALL_FUNC_NAME, &amp;method_result_ptr, method_name_ptr, method_args_ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method_result_ptr) { RETVAL_ZVAL_FAST(method_result_ptr); zval_ptr_dtor(&amp;method_result_ptr); } zval_ptr_dtor(&amp;method_args_ptr); zval_ptr_dtor(&amp;method_name_ptr); efree(func); }</code> </pre><br>  Making this call requires a lot of work.  Therefore, we often hear ‚Äútry to avoid <code>__call()</code> for the sake of better performance‚Äù (and for a number of other reasons).  It really is. <br><br>  Now about PHP 7. Remember the theory of springboard?  Here everything is about the same.  We need to avoid recursive calls to <code>execute_ex()</code> .  To do this, we derecurs the procedure, remaining in the same context as <code>execute_ex()</code> , and also redirecting (rebranch) it to its beginning, changing the necessary arguments.  Let's look again at <code>execute_ex()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_ex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_execute_data *ex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_op *orig_opline = opline; zend_execute_data *orig_execute_data = execute_data; execute_data = ex; opline = execute_data-&gt;opline; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { opline-&gt;handler(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(!opline)) { execute_data = orig_execute_data; opline = orig_opline; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } zend_error_noreturn(E_CORE_ERROR, <span class="hljs-string"><span class="hljs-string">"Arrived at end of main loop which shouldn't happen"</span></span>); }</code> </pre><br>  So, to prevent recursive calls, we need to change at least the <code>opline</code> and <code>execute_data</code> variables (contains the following opcode, and opline is the ‚Äúcurrent‚Äù opcode to execute).  When we meet <code>__call()</code> , then: <br><br><ol><li>  <code>opline</code> and <code>execute_data</code> . </li><li>  Making a return. </li><li>  Go back to the current dispatch cycle. </li><li>  We continue its implementation for our newly modified new opcodes. </li><li>  And as a result, we force him to return to the original position (therefore, we have <code>orig_opline</code> and <code>orig_execute_data</code> ; the virtual machine manager must always remember where it came from so that it can go (the branch) to wherever it goes). </li></ol><br>  This is what PHP 7 does a new opcode <code>ZEND_CALL_TRAMPOLINE</code> .  It is used wherever <code>__call()</code> calls should be made.  Let's look at the simplified version: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_VM_ENTER() execute_data = (executor_globals.current_execute_data); opline = ((execute_data)-&gt;opline); return static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CALL_TRAMPOLINE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { zend_array *args; zend_function *fbc = EX(func); zval *ret = EX(return_value); uint32_t call_info = EX_CALL_INFO() &amp; (ZEND_CALL_NESTED | ZEND_CALL_TOP | ZEND_CALL_RELEASE_THIS); uint32_t num_args = EX_NUM_ARGS(); zend_execute_data *call; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span><span class="hljs-meta"> SAVE_OPLINE(); call = execute_data; execute_data = EG(current_execute_data) = EX(prev_execute_data); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EXPECTED(fbc-&gt;type == ZEND_USER_FUNCTION)) { call-&gt;symbol_table = NULL; i_init_func_execute_data(call, &amp;fbc-&gt;op_array, ret, (fbc-&gt;common.fn_flags &amp; ZEND_ACC_STATIC) == 0); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EXPECTED(zend_execute_ex == execute_ex)) { ZEND_VM_ENTER(); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span></span></code> </pre><br>  You can see that the variables <code>execute_data</code> and <code>opline</code> effectively modified using the macro <code>ZEND_VM_ENTER()</code> .  The following <code>execute_data</code> prepared in the <code>call</code> variable, and their binding (bind) is performed by the <code>i_init_func_execute_data()</code> function.  Next, using <code>ZEND_VM_ENTER()</code> , a new iteration of the dispatching cycle is performed, which switches the variables to the next cycle, and they must go into it with a ‚Äúreturn‚Äù (the current cycle). <br><br>  The circle is closed, it's all over. <br><br>  How to get back to the main loop now?  This is done in the opcode <code>ZEND_RETURN</code> , which completes any user-defined function. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOAD_NEXT_OPLINE() opline = ((execute_data)-&gt;opline) + 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_VM_LEAVE() return static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS) { zend_execute_data *old_execute_data; uint32_t call_info = EX_CALL_INFO(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (EXPECTED(ZEND_CALL_KIND_EX(call_info) == ZEND_CALL_NESTED_FUNCTION)) { zend_object *object; i_free_compiled_variables(execute_data); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (UNEXPECTED(EX(symbol_table) != NULL)) { zend_clean_and_cache_symbol_table(EX(symbol_table)); } zend_vm_stack_free_extra_args_ex(call_info, execute_data); old_execute_data = execute_data; execute_data = EG(current_execute_data) = EX(prev_execute_data); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span><span class="hljs-meta"> LOAD_NEXT_OPLINE(); ZEND_VM_LEAVE(); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span></span></code> </pre><br>  As you can see, when returning from a call to a user-defined function, we use <code>ZEND_RETURN</code> , which replaces the next ones in the queue to execute the instructions from the previous ones from the previous call, <code>prev_execute_data</code> .  Then it loads the opline and returns to the main dispatch loop. <br><br><h1>  Conclusion </h1><br>  We considered the theory underlying the unroll of recursive function calls.  You can fix any recursive calls, but this can be very difficult.  A universal solution is the development of a springboard: a system that controls the launch of each stage of a recursive function, not allowing it to call itself and, therefore, preventing it from generating stack frames uncontrollably.  The ‚Äúspringboard‚Äù code is located in the dispatcher and controls it in order to prevent recursion. <br><br>  We also looked at the general implementation in PHP and studied the implementation of springboards in the new Zend 3 engine, which is part of PHP 7. No longer be afraid to call <code>__call()</code> call <code>__call()</code> , they work faster than in PHP 5. They do not create new frame stacks (for C-level), this is one of the improvements in the PHP 7 engine. </div><p>Source: <a href="https://habr.com/ru/post/311068/">https://habr.com/ru/post/311068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311046/index.html">We measure battery consumption on mobile devices. Experiment in Yandex</a></li>
<li><a href="../311050/index.html">RamQA First Mitap</a></li>
<li><a href="../311062/index.html">GIS utilities: establishing a secure connection and signing messages using WCF</a></li>
<li><a href="../311064/index.html">Why use UITableViewController and UICollectionViewController</a></li>
<li><a href="../311066/index.html">We make our first browser 2d game with physics</a></li>
<li><a href="../311070/index.html">Partner Workshop "1C" - Open Sunday - the full program is available.</a></li>
<li><a href="../311076/index.html">Internet of things security: progress, hype and headache</a></li>
<li><a href="../311078/index.html">Development in InterSystems Cach√© in your favorite IDE</a></li>
<li><a href="../311084/index.html">Taming asynchronous processes in Android with RxJava. Yandex experience</a></li>
<li><a href="../311086/index.html">NanoFL: Brief Feature Description</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>