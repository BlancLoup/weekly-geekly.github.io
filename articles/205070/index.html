<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Are you still boiling and comparing this with zero?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Long ago, in a far-away galaxy, the MFC library was widely used, in which a number of classes had methods comparing this with zero. Like that: 



cla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Are you still boiling and comparing this with zero?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b3a/703/f51/b3a703f518b82a33a2a7aa9e1b0f514f.jpg" align="right">  Long ago, in a far-away galaxy, the MFC library was widely used, in which a number of classes had methods comparing this with zero.  Like that: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CWindow</span></span></span><span class="hljs-class"> {</span></span> HWND handle; <span class="hljs-function"><span class="hljs-function">HWND </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSafeHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : handle; } };</code> </pre> <br>  ‚ÄúIt does not make sense,‚Äù the reader will argue.  Even as ‚Äúhas‚Äù: this code ‚Äúallows‚Äù to call the GetSafeHandle () method via the null CWindow * pointer.  This technique is used from time to time in different projects.  Consider why this is actually a bad idea. <br><a name="habracut"></a><br>  One has to start with the fact that, according to the C ++ Standard (follows from 5.2.5 / 3 of ISO / IEC 14882: 2003 (E)), calling any non-static method of any class through a null pointer leads to undefined behavior.  However, in a number of implementations, this code may well work: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DontAccessMembers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ::Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Class* object = <span class="hljs-number"><span class="hljs-number">0</span></span>; object-&gt;DontAccessMembers(); }</code> </pre><br>  This is due to the fact that during the operation of the method there are no attempts to access the members of the class, and no late binding is used to call the method.  The compiler knows which particular method of which particular class to call, and simply adds a call to this method.  In this case, this is passed as a parameter.  The effect is the same as if the method were static: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DontAccessMembers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class* currentObject)</span></span></span><span class="hljs-function"> </span></span>{ ::Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Class* object = <span class="hljs-number"><span class="hljs-number">0</span></span>; Class::DontAccessMembers(object); }</code> </pre><br>  If the method were called virtually, late binding would be necessary, which is usually implemented via a pointer to a virtual method table at the beginning of a particular object.  In this case, even to find out which method you need to call, you need to access the contents of the object, and in the case of a null pointer, this will most likely lead to a program crash. <br><br>  But we know that our method will never be called virtually, right?  In general, this code has been working there for some years. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The problem is that the compiler can use undefined behavior for optimization.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divideBy = ‚Ä¶; whatever = <span class="hljs-number"><span class="hljs-number">3</span></span> / divideBy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( divideBy == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">// THIS IS IMPOSSIBLE }</span></span></code> </pre><br>  The above code performs integer division by divideBy.  Integer division by zero leads to undefined behavior (usually to crash the program).  So, we can assume that the variable divideBy is not equal to zero, and at the compilation stage to exclude the check and optimize the code accordingly. <br><br>  Similarly, the compiler can optimize and code comparing this with zero.  In accordance with the Standard, this cannot be zero, respectively, the checks and the corresponding branches of the code can be eliminated, and this will significantly affect the code depending on the comparison of this with zero.  The compiler has the full right to ‚Äúbreak‚Äù (in fact, break it) the code CWindow :: GetSafeHandle () and generate machine code in which there is no comparison, but the class field is always read. <br><br>  So far, even the newest versions of common compilers (you can check with the <a href="http://gcc.godbolt.org/">GCC Explorer</a> service) do not perform such optimizations, so while ‚Äúeverything works‚Äù, right? <br><br>  First, you will be very unhappy when you switch to another compiler or another version of the same compiler, and you spend a lot of time to find out what about, now there is such an optimization.  Therefore, the code above is intolerable. <br><br>  Secondly, <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBaseData; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"this == 0"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"this != 0 (value: %p)"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composed1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FirstBase, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SecondBase { }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Composed1* object = <span class="hljs-number"><span class="hljs-number">0</span></span>; object-&gt;Method(); }</code> </pre><br>  Well, when compiling with Visual C ++ 9, the this pointer at the input to the method is 0x00000004, because the initially null pointer is adjusted to indicate the beginning of the sub-object of the corresponding class. <br><br>  And if you change the order of the base classes <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composed2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SecondBase, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FirstBase { }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Composed2* object = <span class="hljs-number"><span class="hljs-number">0</span></span>; object-&gt;Method(); }</code> </pre><br>  under the same conditions, this will be zero, because the beginning of the sub-object coincides with the beginning of the object in which it is included.  It turns out a wonderful class, whose method works only under the condition of the "correct" use of this class in composite objects.  Happy debugging, the Darwin Award hasn't been this close in a long time. <br><br>  It is easy to see that in the case of the class Composed1, the implicit conversion of a pointer to an object to a pointer to a sub-object works ‚Äúincorrectly‚Äù - for a null pointer to an object, the conversion gives a non-zero pointer to a sub-object.  Usually, when implementing a conversion of the same meaning, the compiler adds a check of a pointer to equality to zero.  For example, compiling such a code with undefined behavior (the Composed1 class is the same as above): <br><br><pre> <code class="cpp hljs">SecondBase* object = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;Composed1*&gt;( rand() ); object-&gt;Method();</code> </pre><br>  in Visual C ++ 9 it gives the following machine code: <br><pre> SecondBase * object = reinterpret_cast &lt;Composed1 *&gt; (rand ());
 010C1000 call dword ptr [__imp__rand (10C209Ch)] 
 010C1006 test eax, eax
 010C1008 je wmain + 0Fh (10C100Fh) 
 010C100A add eax, 4 
 object-&gt; Method ();
 010C100D jne wmain + 20h (10C1020h) 
 010C100F push offset string "this == 0" (10C20F4h) 
 010C1014 call dword ptr [__imp__printf (10C20A4h)] 
 010C101A add esp, 4 
</pre><br>  In this machine code, the second instruction is a comparison of a pointer to an object with zero; if the pointer is equal to zero, control does not pass through the add eax, 4 instruction, which shifts the pointer.  Here the implicit conversion is implemented with a check, although it was also possible to use the subsequent method call through the pointer and consider the pointer non-zero. <br><br>  In the first case (calling the subobject's class method directly through a pointer to a class object), the equality of the pointer to zero also corresponds to undefined behavior, and the test is not added here.  If, when reading a paragraph about optimizing a code with calling a method and then checking a pointer to zero, you thought it was nonsense and fantasy, it is in vain, here is a case described above in which such optimization has already been applied. <br><br>  Relying on a non-static method call through a null pointer is a bad idea.  If you need the ability to execute a method for a null pointer, you need to make the method static and explicitly pass the pointer to the object as a parameter. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/205070/">https://habr.com/ru/post/205070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205056/index.html">AirGateway - Ubiquiti access point in a matchbox</a></li>
<li><a href="../205060/index.html">Death SEO. Yandex will completely cease to consider external links.</a></li>
<li><a href="../205062/index.html">[Friday] Eloquent picture of the state of the corporate WLAN market</a></li>
<li><a href="../205064/index.html">Preliminary applications for domains in more than 600 new zones</a></li>
<li><a href="../205066/index.html">uid.me - personal pages service (technical details inside)</a></li>
<li><a href="../205072/index.html">Google returns to court to protect future programming</a></li>
<li><a href="../205074/index.html">We simulate a kettle in wind river simics</a></li>
<li><a href="../205076/index.html">Refinement of the ventilator or ventilation control from the carbon dioxide sensor</a></li>
<li><a href="../205078/index.html">How and why I started going to Management fights in Kiev</a></li>
<li><a href="../205082/index.html">The results of one study: a minute of inactivity of the average data center costs $ 7900</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>