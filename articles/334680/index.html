<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apache Curator for Apache Zookeeper features overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On duty, I have to deal with the design and development of distributed applications. Such applications often use various interprocess communication to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apache Curator for Apache Zookeeper features overview</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/0ca/0e1/6dc/0ca0e16dce8a4cc5b429095ec7228b36.png"></div><br><p>  On duty, I have to deal with the design and development of distributed applications.  Such applications often use various interprocess communication tools to organize the interaction of components.  Particular difficulties arise in the implementation of algorithms that process the associated data distributed.  To support such tasks, specialized systems of distributed coordination are used.  The most popular and widely used product is Apache <a href="http://zookeeper.apache.org/">Zookeeper</a> . <a name="habracut"></a></p><br><p>  Zookeeper is a complex product.  Despite its age, some errors are periodically detected in it.  However, this is only a consequence of its capabilities that help make life easier for many developers of distributed systems.  Next, I will look at some of the features of Zookeeper that will help you better understand its capabilities, and then go to the Apache Curator (Netflix) library, which makes the life of distributed software developers enjoyable and offers many ready-made recipes for implementing distributed coordination objects. </p><br><h2 id="apache-zookeeper">  Apache zookeeper </h2><br><p>  As previously noted, Zookeeper is a vital component of distributed systems.  The easiest way to present a Zookeeper database is a tree similar to the file system, with each element of the tree identified by (/ a / path / to / node) and storing arbitrary data in it.  Thus, using Zookeper it is quite possible to organize a hierarchical distributed data storage, as well as other interesting constructions.  The utility and prevalence of Zookeeper is provided by a number of important properties, which are listed below. </p><br><h3 id="raspredelennyy-konsensus">  Distributed consensus </h3><br><p>  Consensus is provided by the ZAB algorithm, this algorithm provides the C (consistency) and P (partition tolerance) properties of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">CAP theorem</a> , which means integrity and resistance to separation, sacrificing accessibility.  In practice, this leads to the following effects: </p><br><ol><li>  All clients see the same state, no matter on which server they request this state. </li><li>  The change of state occurs in an orderly manner, a ‚Äúrace‚Äù is impossible (for set operations, get-set operations are not atomic). </li><li>  The Zookeepr cluster can "fall apart" and become completely inaccessible, but at the same time it will become inaccessible to all. </li></ol><br><blockquote>  Consensus is the ability of a distributed system to somehow agree on its current state.  Zookeeper uses the <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab%2Bvs.%2BPaxos">ZAB</a> algorithm, often other algorithms are used - <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259F%25D0%25B0%25D0%25BA%25D1%2581%25D0%25BE%25D1%2581">Raft</a> , <br>  <a href="http://2017-07-25-apache-curator-overview-zookeeper-made-easy.html/">Raft</a> . </blockquote><br><h3 id="efemernye-uzly">  Ephemeral nodes </h3><br><p>  The client, establishing a connection with the Zookeeper cluster, creates a session.  Within the session, it is possible to create nodes that will be visible to other clients, but whose lifetime is equal to the session lifetime.  At the end of the session, these nodes will be deleted.  Such nodes have limitations - they can only be terminal and cannot have descendants, that is, you cannot have ephemeral subtrees.  Ephemeral nodes are often used for the purpose of <br>  implementation of service discovery systems. </p><br><p>  Imagine that we have several instances of the service, between which the load is balanced.  If one of the instances appears, then an ephemeral node is created for it, in which the service address is located, and in the event of a service failure, this node is deleted and can no longer be used for balancing.  Ephemeral nodes are used very often. </p><br><h3 id="podpiska-na-sobytiya-uzla">  Subscribe to host events </h3><br><p>  The client can subscribe (watch) to the events of the nodes and receive updates when any events associated with these nodes occur.  However, there is also a limitation here - after the occurrence of an event on a node, the subscription is canceled and it needs to be restored again, while obviously there is a possibility of skipping other events that occur on this node.  Due to this fact, the possibility of using this function is rather limited. </p><br><p>  For example, within the scope of the discovery services, it can be used to react to a configuration change, but it must be remembered that after installing the subscription, it is necessary to perform the operation "manually" to make sure that the state change omission did not occur. </p><br><h3 id="posledovatelnye-uzly">  Serial nodes </h3><br><p>  Zookeeper allows you to create nodes whose names are formed with the addition of successively increasing numbers, while these nodes can be ephemeral.  This feature is widely used for solving applied tasks (for example, all services of the same type register themselves as ephemeral nodes) and for implementing Zookeeper ‚Äúrecipes‚Äù, for example, <strong>fair distributed locking</strong> . </p><br><h3 id="versii-uzlov">  Node versions </h3><br><p>  Node versions allow you to determine whether a node has changed between reading and writing, that is, with the set operation, you can specify the expected version of the node, if it does not match, it means that the node has been changed by another client and the state needs to be re-read.  This mechanism allows you to implement an orderly change in the state of the data, for example, when implementing a "recipe" <strong>distributed counter</strong> . </p><br><h3 id="acl-na-uzly">  ACL on nodes </h3><br><p>  It is possible to set access restrictions for nodes defined by ACLs, which is designed to protect data from untrusted applications.  It is worth noting that, of course, ACLs do not protect against overloads that a malicious client can create, providing only a mechanism for restricting access to content. </p><br><h3 id="ttl-na-uzly">  TTL on nodes </h3><br><p>  Zookeeper allows you to set TTL nodes, after which (if there are no updates) the node will be deleted.  This functionality appeared relatively recently. </p><br><h3 id="servery-nablyudateli">  Observer Servers </h3><br><p>  It is possible to connect to a cluster of servers in observer mode, which can be used to perform read operations, which is very useful in cases where the load on the cluster generated by write operations is high.  With the use of server-observers, the problem can be solved.  The question may arise, why not just add regular nodes to the cluster?  The answer lies in the algorithm of consensus - the more nodes that allow you to write data, the longer it will take to reach a consensus and the less cluster performance will be to write.  Observer servers do not participate in consensus, and therefore do not affect the performance of write operations. </p><br><h3 id="sinhronizaciya-vremeni-na-uzlah">  Time synchronization on nodes </h3><br><p>  Zookeeper does not use external time to synchronize nodes.  This is quite a useful feature, systems that focus on the exact time are more susceptible to errors associated with its mismatch. </p><br><p>  Of course, there should be tar in the barrel of honey and it really is - Zookeeper has properties that can limit its use.  There is even an expression that quite ironically describes the difficulties of working with Zookeeper - <a href="https://medium.com/%40Pinterest_Engineering/zookeeper-resilience-at-pinterest-adfd8acf2a6b">Single Cluster of Failure</a> ¬© Pinterest, which sarcastically demonstrates the fact that, trying to get rid of a single point of failure using a distributed system using Zookeeper, you can face the situation when the very point of failure. </p><br><h3 id="baza-dannyh-zookeeper-dolzhna-pomeschatsya-v-ram">  Zookeeper database should fit in RAM </h3><br><p>  Zookeeper loads the base into memory and keeps it there.  If the database does not fit in the RAM, it will be placed in the Swap, which will lead to a significant performance degradation.  If the database is large, a server with a sufficiently large amount of RAM is required (which, however, is not a problem at the moment, when 1TB of RAM on the server is far from the limit). </p><br><h3 id="vremya-taymauta-sessii">  Session timeout </h3><br><p>  If, when setting up the client, the session timeout is incorrect, then this can lead to unpredictable consequences, which will worsen with increasing load on the cluster and the failure of some cluster nodes.  Users tend to reduce session time (30 seconds by default) to increase system convergence, since ephemeral nodes will be removed faster, but this leads to less stability of the system under load. </p><br><h3 id="degradaciya-proizvoditelnosti-ot-kolichestva-uzlov-v-klastere">  Performance degradation by the number of nodes in the cluster </h3><br><p>  Usually, a cluster uses 3 nodes that are involved in reaching consensus, the desire to add additional nodes will significantly reduce the performance of write operations.  The number of nodes must be odd (the requirement of the ZAB algorithm), respectively, the expansion of the cluster to 5, 7, 9 nodes will adversely affect performance.  If the problem is precisely in read operations, use observer nodes. </p><br><h3 id="maksimalnyy-razmer-dannyh-v-uzle">  Maximum size of data in a node </h3><br><p>  The maximum data size in a node is limited to 1MB.  In case you need to store large amounts of data, Zookeeper will not work. </p><br><h3 id="maksimalnoe-kolichestvo-uzlov-v-listinge-potomkov">  Maximum number of nodes in a descendant listing </h3><br><p> Zookepeer does not impose on how many nodes a node may have, however, the maximum size of a data packet that the server can send to the client is 4MB (jute.maxbuffer).  If a node has so many descendants that their list does not fit in one package, then, unfortunately, there is no way to get information about them.  This restriction is bypassed by organizing hierarchical pseudo-flat lists in the same way that caches are built in the file system, the names or digests of objects are broken up into parts and organized into a hierarchical structure. </p><br><p>  Despite their shortcomings, their advantages outweigh them, which makes Zookeeper an essential component of many distributed ecosystems, for example, Cloudera CDH5, or DC / OS, Apache Kafka, and others. </p><br><h2 id="zookeeper-dlya-razrabotchika">  Zookeeper for developer </h2><br><p>  Since Zookeeper is implemented using the Java language, in JVM environments its use is organic, for example, it is quite easy to start a server or even a cluster of servers from Java and use it to implement integration or smoke tests of an application without the need to deploy a third-party server.  However, the Zookeeper client API is quite low-level, which, although it allows operations, but resembles a swim against the flow of a river.  In addition, a deep understanding of the fundamentals of Zookeeper is required in order to properly implement exception handling.  For example, when I used the basic interface for working with Zookeeper, debugging and searching for errors in the distributed coordination and detection code presented rather large problems and required considerable time. </p><br><p>  However, the solution exists and was presented to the community by Netflix developer Jordan Zimmerman.  Meet <a href="http://curator.apache.org/">Apache Curator</a> . </p><br><h2 id="apache-curator">  Apache curator </h2><br><p>  On the main page of the project is a quote: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3c6/df0/b36/3c6df0b3661b1e4ae2a4ad09d4bb5cfc.png"></p><br><p>  This statement 100% reflects the essence of Curator.  Starting to use this library, I found that the code for working with Zookeeper was simple and straightforward, and the number of errors and the time to eliminate them decreased by a factor of several.  If, as it was said earlier, a standard client resembles a swim against the current, then with the curator the situation changes by 180 degrees.  In addition, within the Curator framework, a large number of ready-made recipes are sold, which I will review further below. </p><br><h3 id="bazovyy-api">  Base API </h3><br><p>  The API is designed in the form of an extremely convenient <a href="https://ru.wikipedia.org/wiki/Fluent_interface">fluid interface</a> , which allows you to simply and concisely determine the required actions.  For example (further, examples are given in the Scala language): </p><br><pre><code class="scala hljs">client .create() .orSetData() .forPath(<span class="hljs-string"><span class="hljs-string">"/object/path"</span></span>, byteArray)</code> </pre> <br><p>  which can be translated as <em>"create a node or, if it exists, just set the data for the path" / object / path "and write in it byteArray"</em> . </p><br><p>  Or, for example: </p><br><pre> <code class="scala hljs">client .create() .withMode(<span class="hljs-type"><span class="hljs-type">CreateMode</span></span>.<span class="hljs-type"><span class="hljs-type">EPHEMERAL_SEQUENTIAL</span></span>) .forPath(<span class="hljs-string"><span class="hljs-string">"/head/child"</span></span>, byteArray)</code> </pre> <br><p>  <em>"create a node of the type serial and ephemeral for the path" / head / child000000XXXX "and write into it byteArray"</em> .  A few more examples can be found on this manual <a href="http://curator.apache.org/curator-framework/index.html">page</a> . </p><br><h3 id="asinhronnye-operacii">  Asynchronous operations </h3><br><p>  Curator supports both synchronous and asynchronous mode for performing operations.  In the case of asynchronous use, the client has the type <code>AsyncCuratorFramework</code> , in contrast to the synchronous <code>CuratorFramework</code> .  And each call chain accepts the <code>thenAccept</code> method, which indicates the Callback that is called when the operation is completed.  More information about the asynchronous interface can be found on its dedicated manual <a href="https://curator.apache.org/curator-x-async/async.html">page</a> . </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> async = <span class="hljs-type"><span class="hljs-type">AsyncCuratorFramework</span></span>.wrap(client); async.checkExists().forPath(somePath).thenAccept(stat -&gt; mySuccessOperation(stat))</code> </pre> <br><blockquote>  When using Scala, the use of an asynchronous interface does not seem to be justified, since the functionality can be easily implemented using the Scala Future, which allows the code to preserve features of the scala-way development.  However, in the case of Java and other JVM languages, this interface can be useful. </blockquote><br><h3 id="podderzhka-shem-dannyh">  Data schema support </h3><br><p>  Zookeeper does not support semantics of stored data.  This means that developers are solely responsible for the formats in which data is stored and which paths they are located.  This can be inconvenient in many cases, for example, when new developers come to the project.  To solve these problems, Curator supports data schemes that allow you to set constraints on the paths and types of nodes within the paths.  The scheme created from the configuration can be presented in the Json format: </p><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/a/b/c"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ephemeral"</span></span>: <span class="hljs-string"><span class="hljs-string">"must"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sequential"</span></span>: <span class="hljs-string"><span class="hljs-string">"cannot"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"outside"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"large"</span></span> } } ]</code> </pre> <br><h3 id="podderzhka-migraciy">  Migration support </h3><br><p>  Curator migrations are a bit like Liquibase, only for the Zookeeper.  With their help, it is possible to reflect the evolution of the database in new versions of the product.  Migration consists of a set of sequentially performed operations.  Each operation is represented by some transformations over the Zookeeper database.  Curator independently monitors the application of migrations with the help of Zookeeper.  This feature can be used in the process of deploying a new version of the application.  Migration details are described on the corresponding manual <a href="http://curator.apache.org/curator-x-async/migrations.html">page</a> . </p><br><h3 id="testovyy-server-i-testovyy-klaster">  Test server and test cluster </h3><br><p>  To simplify testing, Curator allows you to integrate a server or even a cluster of Zookeeper servers into an application.  This task can be solved simply without using Curator, only with Zookeeper, but Curator provides a more concise interface.  For example, in the case of Zookeeper without Curator: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZookeeperTestServer</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">zookeperPort: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, tmp: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> properties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Properties</span></span>() properties.setProperty(<span class="hljs-string"><span class="hljs-string">"tickTime"</span></span>, <span class="hljs-string"><span class="hljs-string">"2000"</span></span>) properties.setProperty(<span class="hljs-string"><span class="hljs-string">"initLimit"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>) properties.setProperty(<span class="hljs-string"><span class="hljs-string">"syncLimit"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>) properties.setProperty(<span class="hljs-string"><span class="hljs-string">"dataDir"</span></span>, <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$tmp</span></span></span><span class="hljs-string">"</span></span>) properties.setProperty(<span class="hljs-string"><span class="hljs-string">"clientPort"</span></span>, <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$zookeperPort</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> zooKeeperServer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ZooKeeperServerMain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> quorumConfiguration = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">QuorumPeerConfig</span></span>() quorumConfiguration.parseProperties(properties) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> configuration = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ServerConfig</span></span>() configuration.readFrom(quorumConfiguration) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Thread</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() = { zooKeeperServer.runFromConfig(configuration) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span></span>= { thread.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span></span>= { thread.interrupt() } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ZookeeperTestServer</span></span>(port, tmp) s.start ... s.stop</code> </pre><br><p>  In the case of Curator: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">TestingServer</span></span>(port) s.start() ... s.stop()</code> </pre><br><h2 id="recepty-curator">  Curator Recipes </h2><br><p>  Curator recipes are the main motive of using this library for implementing distributed mechanisms of interaction between processes.  Next, we list the basic recipes that Curator supports and how they can be applied.  I did not apply some recipes in practice, therefore for them the translation as close as possible to the manual is given. </p><br><h3 id="vybor-lidera">  Leader Selection </h3><br><p>  These recipes are designed to implement a fault-tolerant process execution model, within which there is a current leader and several processes are in hot standby.  As soon as the leader ceases to perform its functions, another process becomes the leader.  There are two suitable recipes: </p><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/leader-latch.html">Leader Latch</a> , which is an analogue of CountDownLatch, which is blocked until the process has become a leader; </li><li>  <a href="http://curator.apache.org/curator-recipes/leader-election.html">Leader Election</a> , which implements the selection of a leader through a method call.  At the moment when the process becomes the leader, the method is called, the exit from which indicates the loss of leadership. </li></ol><br><h3 id="blokirovki">  Locks </h3><br><p>  Locking is one of the most important mechanisms for distributed interprocess synchronization.  Curator provides a wide range of lock objects: </p><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html">Shared Reentrant Lock</a> ‚Äî a distributed lock that a client can re-enter that has access to it; </li><li>  <a href="http://curator.apache.org/curator-recipes/shared-lock.html">Shared Lock</a> - distributed lock; </li><li>  <a href="http://curator.apache.org/curator-recipes/shared-reentrant-read-write-lock.html">Shared Reentrant Read Write Lock</a> - an object that allows separate blocking for reading and writing, while several clients can block an object for reading at the same time, the lock for writing is exclusive; </li><li>  <a href="http://curator.apache.org/curator-recipes/shared-semaphore.html">Shared Semaphore</a> - counting semaphore, through which it is easy to carry out work with a limited amount of resources, which is given by a 32-bit integer; </li><li>  <a href="http://curator.apache.org/curator-recipes/multi-shared-lock.html">Multi Shared Lock</a> is a high-level object that allows you to perform operations on several distributed locks atomically. </li></ol><br><h3 id="barery">  Barriers </h3><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/barrier.html">Barrier</a> - an object that allows a client to block access to a code section for other participants until certain conditions are met, and when they occur - unblock access, which leads to the fact that all participants can continue their execution; </li><li>  <a href="http://curator.apache.org/curator-recipes/double-barrier.html">Double Barrier</a> - the object allows you to synchronize the input of a certain number of clients in the code segment and their exit from it. </li></ol><br><h3 id="schetchiki">  Counters </h3><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/shared-counter.html">Shared Counter</a> - the usual integer counter (32 bit) with protection against the race; </li><li>  <a href="http://curator.apache.org/curator-recipes/distributed-atomic-long.html">Distributed Atomic Long</a> - <a href="http://curator.apache.org/curator-recipes/distributed-atomic-long.html">Long</a> type counter (64 bit). </li></ol><br><h3 id="keshi">  Cache </h3><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/path-cache.html">Path Cache</a> - an object that monitors a node and updates the local cache about its child nodes and optionally about their data when it changes; </li><li>  <a href="http://curator.apache.org/curator-recipes/node-cache.html">Node Cache</a> - an object that monitors the node and updates the local cache about it and its data; </li><li>  <a href="http://curator.apache.org/curator-recipes/tree-cache.html">Tree Cache</a> - an object that monitors the entire tree of children of a node and updates the local cache when it changes in the tree; </li></ol><br><h3 id="uzly">  Knots </h3><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/persistent-node.html">Persistent Node</a> - this recipe allows you to create a data node for which Curator will strive to ensure its presence and invariance, even under external influences; </li><li>  <a href="http://curator.apache.org/curator-recipes/persistent-ttl-node.html">Persistent TTL Node</a> - a recipe for creating a node, the lifetime of which is determined by the TTL, which supports the same properties as the Persistent Node; </li><li>  <a href="http://curator.apache.org/curator-recipes/group-member.html">Group Member</a> - allows you to organize a group of members. </li></ol><br><h3 id="ocheredi">  Queues </h3><br><blockquote>  I would like to note that Zookeeper is not the best candidate for organizing intensive distributed queues, if you need to ensure the passage of a large number of messages, I recommend using a specially designed solution, for example, Apache Kafka, RabbitMQ or others.  However, Curator provides a set of recipes for queuing support: </blockquote><br><ol><li>  <a href="http://curator.apache.org/curator-recipes/distributed-queue.html">Distributed Queue</a> - a normal distributed queue, allows you to put and retrieve messages in order of priority; </li><li>  <a href="http://curator.apache.org/curator-recipes/distributed-id-queue.html">Distributed Id Queue</a> - a distributed queue that with each message saves an identifier and allows you to retrieve a message from the queue by identifier with its immediate removal; </li><li>  <a href="http://curator.apache.org/curator-recipes/distributed-priority-queue.html">Distributed Priority Queue</a> - priority queue; </li><li>  <a href="http://curator.apache.org/curator-recipes/distributed-delay-queue.html">Distributed Delay Queue</a> - a queue allows you to set the time for each added item, in Unixtime format, when it becomes available for reading from the queue; </li><li>  <a href="http://curator.apache.org/curator-recipes/simple-distributed-queue.html">Simple Distributed Queue</a> - analogue of the queue, which is provided by the standard API Zookeeper. </li></ol><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The Apache Curator library is definitely worth considering to use, it is an outstanding example of engineering work and allows you to greatly simplify interaction with Apache Zookeeper.  The disadvantages of the library include a small amount of documentation, which increases the entry barrier for novice developers.  In my practice, I have repeatedly needed to study the source code of the library in order to understand exactly how this or that recipe works.  However, it also has a positive effect - a deep understanding of the implementation allows you to make fewer logical errors based on assumptions. </p><br><p>  It should be noted that the Curator developers recommend that you study the Zookeeper documentation before you start using the library.  This is a very sensible advice, because Zookeeper is a product, for the effective use of which it is necessary to understand exactly how it functions, and not just to know its API.  These costs will certainly pay off, and in the hands of an experienced engineer, the capabilities of Zookeeper allow you to create reliable and productive distributed systems. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334680/">https://habr.com/ru/post/334680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334670/index.html">Math pack for Android - "Micro-Math" - now open source</a></li>
<li><a href="../334672/index.html">JetBrains MPS for those interested # 3</a></li>
<li><a href="../334674/index.html">How not to distract yourself from work. Tips and slak bot</a></li>
<li><a href="../334676/index.html">Leaflet 1.xx vs Openlayers 4.xx Part 2. How maps are drawn</a></li>
<li><a href="../334678/index.html">Writing a bot for Slack in Python</a></li>
<li><a href="../334682/index.html">Rapid deployment containers</a></li>
<li><a href="../334684/index.html">Juniper Node Slicing and Universal Chassis</a></li>
<li><a href="../334688/index.html">Flash is dead: who's next?</a></li>
<li><a href="../334690/index.html">Galley hackathon</a></li>
<li><a href="../334692/index.html">Implement security in the development of a large project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>