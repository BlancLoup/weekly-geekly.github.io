<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Machine learning for business and marketing"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Data science is becoming an integral part of any marketing activity, and this book is a living portrait of digital transformations in marketing. Data ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Machine learning for business and marketing"</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/piter/blog/460375/"><img src="https://habrastorage.org/webt/gq/td/mc/gqtdmc8joactk6gu7xrzcdr0f4i.jpeg" align="left" alt="image"></a>  Data science is becoming an integral part of any marketing activity, and this book is a living portrait of digital transformations in marketing.  Data analysis and intelligent algorithms automate time-consuming marketing tasks.  The decision-making process becomes not only more perfect, but also faster, which is of great importance in a constantly accelerating competitive environment. <br><br>  ‚ÄúThis book is a living portrait of digital transformations in marketing.  It shows how data science becomes an integral part of any marketing activity.  It describes in detail how approaches based on data analysis and intelligent algorithms contribute to the deep automation of traditionally labor-intensive marketing tasks.  The decision-making process is becoming not only more perfect, but also faster, which is important in our constantly accelerating competitive environment.  This book must be read by data processing specialists and marketing specialists, and it‚Äôs better if they read it together. ‚ÄùAndrey Sebrant, director of strategic marketing, Yandex. <br><a name="habracut"></a><br><h3>  Excerpt  5.8.3.  Hidden factors models </h3><br>  In the joint filtering algorithms discussed so far, most of the calculations are performed on the basis of individual elements of the rating matrix.  Proximity-based methods estimate missing ratings directly from known values ‚Äã‚Äãin the rating matrix.  Model-based methods add an abstraction layer on top of the rating matrix, creating a predictive model that captures certain patterns in the relationship between users and elements, but the training of the model is still highly dependent on the properties of the rating matrix.  As a result, these methods of co-filtering usually face the following problems: <br><br>  The matrix of ratings can contain millions of users, millions of elements and billions of known ratings, which creates serious problems of computational complexity and scalability. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The matrix of ratings, as a rule, is very rarefied (in practice, about 99% of ratings may be absent).  This affects the computational stability of the recommendation algorithms and leads to unreliable estimates when the user or the element has no really similar neighbors.  This problem is often exacerbated by the fact that most of the basic algorithms are focused either on users or on elements, which limits their ability to capture all types of similarities and relationships available in the rating matrix. <br><br>  The data in the rating matrix is ‚Äã‚Äãusually highly correlated due to the similarities of users and items.  This means that the signals available in the rating matrix are not only sparse, but also redundant, which exacerbates the scalability problem. <br><br>  The above considerations indicate that the original matrix of ratings may not be the most optimal representation of signals, and other alternative representations that are more suitable for co-filtering purposes should be considered.  To explore this idea, let‚Äôs go back to the starting point and think a bit about the nature of recommendation services.  In essence, a recommendation service can be viewed as an algorithm that predicts ratings based on some measure of similarity between the user and the element: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/bc/6n/atbc6no-aj2vssp1mrgyctgu_oy.png" alt="image"></div><br>  One way to determine this measure of similarity is to use the approach of hidden factors and map users and elements to points in a certain k-dimensional space so that each user and each element is represented by a k-dimensional vector: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9e/ck/no/9eckno4ntrf2yl0hw1q2tr2irbk.png" alt="image"></div><br>  Vectors should be constructed so that the corresponding dimensions p and q are comparable with each other.  In other words, each dimension can be considered as a sign or concept, that is, puj is a measure of the proximity of the user u and the concept of j, and qij, respectively, is a measure of the element i and the concept of j.  In practice, these dimensions are often interpreted as genres, styles, and other attributes that apply simultaneously to users and elements.  The similarity between the user and the element and, accordingly, the rating can be defined as the product of the corresponding vectors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k3/1w/9w/k31w9wqmwas5pfvhr8_mopo7ibg.png" alt="image"></div><br>  Since each rating can be decomposed into a product of two vectors belonging to a concept space that is not directly observed in the initial rating matrix, p and q are called hidden factors.  The success of this abstract approach, of course, depends entirely on how the hidden factors are defined and constructed.  To answer this question, we note that expression 5.92 can be rewritten in a matrix form as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2i/bp/j9/2ibpj9pmptpun2amylvxf41okjw.png" alt="image"></div><br>  where P is an n √ó k matrix assembled from vectors p, and Q is an m √ó k matrix assembled from q vectors, as shown in Fig.  5.13.  The main goal of the collaborative filtering system is usually to minimize the error of rating prediction, which allows us to directly define the optimization problem relative to the matrix of hidden factors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9h/nm/mx/9hnmmxregnvn9snp9empxqf91qk.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z-/vl/nu/z-vlnuz-v9git5dmm0nj79etl5g.png" alt="image"></div><br>  If we assume that the number of hidden dimensions k is fixed and k ‚â§ n and k ‚â§ m, the optimization problem 5.94 reduces to the low-rank approximation problem, which we considered in Chapter 2. To demonstrate the approach to the solution, let us assume for a moment that the rating matrix is ‚Äã‚Äãcomplete.  In this case, the optimization problem has an analytical solution in terms of singular decomposition (Singular Value Decomposition, SVD) of the rating matrix.  In particular, using the standard SVD algorithm, the matrix can be decomposed into the product of three matrices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/ic/x0/7zicx0iwp156hctp6t7axd5bzu4.png" alt="image"></div><br>  where U is an n √ó n matrix orthonormal in columns, Œ£ is a n √ó m diagonal matrix, and V is an m √ó m matrix orthonormal in columns.  The optimal solution of problem 5.94 can be obtained in terms of these factors, truncated to k of the most significant dimensions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/i-/os/mwi-oskhgcs-ehf_bhepytyo_os.png" alt="image"></div><br>  Consequently, hidden factors that are optimal in terms of prediction accuracy can be obtained by singular decomposition, as shown below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/ih/yl/ucihyltxuqye29vkocknsbzyguw.png" alt="image"></div><br>  This model of hidden factors, based on SVD, helps to solve the problems of co-filtering described in the beginning of the section.  First, it replaces a large matrix of n √ó m ratings with matrices of n √ó k and m √ó k factors, which are usually much smaller, because in practice the optimal number of hidden dimensions k is often small.  For example, there is a case in which the rating matrix with 500,000 users and 17,000 elements was fairly well approximated using 40 measurements [Funk, 2016].  Further, SVD eliminates the correlation in the matrix of ratings: the matrix of hidden factors, defined by the expression 5.97, are orthonormal in columns, that is, the hidden measurements are not correlated.  If, which is usually true in practice, SVD also solves the problem of sparseness, because the signal present in the original rating matrix is ‚Äã‚Äãeffectively concentrated (remember that we choose the k dimensions with the highest signal energy) and the matrix of hidden factors are not sparse.  Figure 5.14 illustrates this property.  The proximity-based user-based algorithm (5.14, a) collapses the sparse rating vectors for a given element and a given user to get a rating score.  The model of hidden factors (5.14, b), on the contrary, estimates the rating by convolving two vectors of reduced dimension and with a higher energy density. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/te/fm/v3tefmto-k2yf54og0xn4rpbxlq.png" alt="image"></div><br>  The approach just described looks like a well-balanced solution to the problem of hidden factors, but in fact it has a serious disadvantage due to the assumption of the completeness of the rating matrix.  If the rating matrix is ‚Äã‚Äãsparse, which is almost always the case, the standard SVD algorithm cannot be applied directly, since it is not able to handle the missing (undefined) elements.  The simplest solution in this case is to fill the missing ratings with some default value, but this can lead to a serious shift in the forecast.  Moreover, it is inefficient from a computational point of view, because the computational complexity of such a solution is equal to the SVD complexity for the full n √ó m matrix, while it is desirable to have a method with complexity proportional to the number of known ratings.  These problems can be solved using the alternative decomposition methods described in the following sections. <br><br><h3>  5.8.3.1.  Decomposition without limits </h3><br>  The standard SVD algorithm is an analytical solution to the problem of low-rank approximation.  However, this problem can be viewed as an optimization problem, and universal optimization methods can also be applied to it.  One of the simplest approaches is to use the gradient descent method to iteratively refine the values ‚Äã‚Äãof hidden factors.  The starting point is to determine the cost function J as a residual forecast error: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g8/d_/gk/g8d_gkpksz8-d3wyg0xs9ca60a8.png" alt="image"></div><br>  Note that this time we do not impose any restrictions, such as orthogonality, on the matrix of hidden factors.  Calculating the gradient of the cost function with respect to hidden factors, we get the following result: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/_l/cu/jn_lcurj48vk0kuluh8mojadgcy.png" alt="image"></div><br>  where E is the residual error matrix: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/wt/at/6zwtat7l4h9qoo0fq7ejzatlobi.png" alt="image"></div><br>  The gradient descent algorithm minimizes the cost function by moving at each step in the negative direction of the gradient.  Therefore, it is possible to find hidden factors that minimize the square of the error in forecasting the rating by iteratively changing the matrices P and Q to convergence, in accordance with the following expressions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/uw/gu/f9uwguspa118fw__nuchwxu1ycy.png" alt="image"></div><br>  where Œ± is the learning rate.  The disadvantage of the gradient descent method is the need to calculate the entire matrix of residual errors and simultaneously change all the values ‚Äã‚Äãof the hidden factors in each iteration.  An alternative approach, which may be better suited for large matrices, is stochastic gradient descent [Funk, 2016].  The stochastic gradient descent algorithm uses the fact that the total prediction error J is the sum of errors for individual elements of the rating matrix, so the general gradient J can be approximated by a gradient at one data point and alter the hidden factors elementwise.  The full realization of this idea is shown in algorithm 5.1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/c5/ct/lec5ctumggjq0twtb30wnamvj0g.png" alt="image"></div><br>  The first stage of the algorithm is the initialization of matrices of hidden factors.  The choice of these initial values ‚Äã‚Äãis not very important, but in this case the uniform distribution of the energy of the known ratings among randomly generated hidden factors is chosen.  The algorithm then sequentially optimizes the dimensions of the concept.  For each measurement, he repeatedly rounds up all ratings in the training set, predicts each rating using the current values ‚Äã‚Äãof the hidden factors, estimates the error and adjusts the values ‚Äã‚Äãof the factors in accordance with expressions 5.101.  The optimization of the measurement is completed by the condition of convergence, after which the algorithm proceeds to the next measurement. <br><br>  Algorithm 5.1 helps overcome the limitations of the standard SVD method.  It optimizes hidden factors by cycling through individual data points, and thus avoids problems with missing ratings and algebraic operations with giant matrices.  The iterative approach also makes stochastic gradient descent more convenient for practical applications than gradient descent, which modifies whole matrices with expressions 5.101. <br><br><h3>  EXAMPLE 5.6 </h3><br>  In essence, the approach based on hidden factors is a whole group of methods for teaching perceptions that can identify patterns that are implicitly present in the rating matrix and represent them explicitly in the form of concepts.  Sometimes concepts have a quite meaningful interpretation, especially high-energy ones, although this does not mean that all concepts always have a meaningful meaning.  For example, the application of the matrix decomposition algorithm to a movie rating database can create factors approximately corresponding to psychographic measurements, such as melodrama, comedy, a horror film, etc. We illustrate this phenomenon with a small numerical example that uses the rating matrix from Table.  5.3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xw/6a/vu/xw6avuizjd2x8aku8k-0r89ieem.png" alt="image"></div><br>  First, we subtract the global mean Œº = 2.82 from all the elements to center the matrix, and then we perform the algorithm 5.1 with k = 3 hidden measurements and the learning rate Œ± = 0.01 to get the following two matrixes of factors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k-/rr/vd/k-rrvde1sezar3qo0e2vqfb7jh8.png" alt="image"></div><br>  Each row in these matrices corresponds to a user or movie, and all 12 row vectors are depicted in Figure.  5.15.  Note that the elements in the first column (the first vector of concepts) have the largest values, and the values ‚Äã‚Äãin the subsequent columns gradually decrease.  This is explained by the fact that the first vector concept captures as much signal energy as possible using one dimension, the second vector concept captures only part of the residual energy, etc. Further, note that the first concept can be semantically interpreted as the drama axis - action movie, where the positive direction corresponds to the genre of the action movie, and the negative direction - to the genre of drama.  The ratings in this example have a high correlation, so it is clearly seen that the first three users and the first three films have large negative values ‚Äã‚Äãin the first vector-concept (drama films and users who like such films), while the last three users and the last three films have large positive values ‚Äã‚Äãin the same column (action films and users who prefer this genre).  The second dimension in this particular case corresponds mainly to the bias of the user or element, which can be interpreted as a psychographic attribute (is the criticality of the user's judgment? Film popularity?).  The remaining concepts can be regarded as noise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z0/s6/t9/z0s6t9vbnwdtgonx0p6rswo_ufe.png" alt="image"></div><br>  The resulting factor matrices are not completely orthogonal in the columns, but tend to orthogonality, because this follows from the optimality of the SVD solution.  This can be seen by considering the works of PTP and QTQ, which are close to diagonal matrices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/zr/sf/pbzrsfbqm0hjvmoqgh1xlurslnm.png" alt="image"></div><br>  Matrices 5.103 are essentially a predictive model that can be used to evaluate both known and absent ratings.  Estimates can be obtained by multiplying two factors and adding back the global average: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qg/du/d2/qgdud2i8fqm_ut6doi-8jnpllq8.png" alt="image"></div><br>  The results accurately reproduce known and predict the missing ratings in accordance with intuitive expectations.  The accuracy of the estimates can be increased or decreased by changing the number of measurements, and the optimal number of measurements can be determined in practice by cross-checking and choosing a reasonable compromise between computational complexity and accuracy. <br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/recommend/product/mashinnoe-obuchenie-dlya-biznesa-i-marketinga%3F_gs_cttl%3D120%26gs_direct_link%3D1%26gsaid%3D82744%26gsmid%3D29789%26gstid%3Dc">the publisher's website.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610926/978544610926_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610926/978544610926_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley a 25% discount on coupon - <b>Machine Learning</b> <br><br>  Upon payment of the paper version of the book, an e-book is sent to the e-mail. </div><p>Source: <a href="https://habr.com/ru/post/460375/">https://habr.com/ru/post/460375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460355/index.html">Saving drowning people - our business: how to deal with demotivation in a team</a></li>
<li><a href="../460359/index.html">Young Game Designer 2 Course: Balancing Progression and Dynamics Without Mathematics</a></li>
<li><a href="../460361/index.html">Large FAQ on the cybersecurity of medical information systems</a></li>
<li><a href="../46037/index.html">jQuery in Action in Russian already on sale</a></li>
<li><a href="../460373/index.html">"Under the hood" Turbo Pages: architecture of fast loading web pages technology</a></li>
<li><a href="../460381/index.html">What is assertiveness and why is it needed?</a></li>
<li><a href="../460383/index.html">Screen transitions in Legend of Zelda use the undocumented features of NES</a></li>
<li><a href="../460387/index.html">SELinux Beginner's Guide</a></li>
<li><a href="../460393/index.html">Background: what to expect from Fedora Silverblue</a></li>
<li><a href="../460397/index.html">Quick start with WebComponents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>