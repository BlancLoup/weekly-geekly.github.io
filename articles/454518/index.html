<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wasmer: the fastest go-library for running WebAssembly code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly (wasm) is a portable binary instruction format. The same wasm code can be executed in any environment. In order to support this statement,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wasmer: the fastest go-library for running WebAssembly code</h1><div class="post__text post__text-html js-mediator-article">  WebAssembly (wasm) is a portable binary instruction format.  The same wasm code can be executed in any environment.  In order to support this statement, every language, platform and system must be able to execute such code, making it as fast and safe as possible. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/454518/"><img src="https://habrastorage.org/webt/6b/ba/7g/6bba7gvszh2fqjm_zupvfk90fea.png"></a> <a name="habracut"></a><br>  <a href="https://github.com/wasmerio/wasmer">Wasmer</a> is a medium for executing a wasm code written in <a href="https://www.rust-lang.org/">Rust</a> .  Obviously, wasmer can be used in any Rust application.  The author of the material, the translation of which we are publishing today, says that he and other participants in the Wasmer project have successfully implemented this wasm-execution environment in other languages: <br><br><ul><li>  In <a href="https://github.com/wasmerio/wasmer/tree/master/lib/runtime-c-api">C and C ++,</a> this is implemented through bindings. </li><li>  In PHP, it is an extension of <a href="https://github.com/wasmerio/php-ext-wasm">php-ext-wasm</a> . </li><li>  In Python, this <a href="https://pypi.org/project/wasmer/">wasmer</a> package published in PyPi, which is being worked on in the <a href="https://github.com/wasmerio/python-ext-wasm">python-ext-wasm repository</a> . </li><li>  In Ruby, these are heme <a href="https://rubygems.org/gems/wasmer">wasmer</a> , which can be found on RubyGems.  Its code is in the <a href="https://github.com/wasmerio/ruby-ext-wasm">ruby-ext-wasm repository</a> . </li></ul><br>  Here we will discuss a new project - <a href="https://github.com/wasmerio/go-ext-wasm">go-ext-wasm</a> , which is a library for Go, designed to execute a binary wasm code.  As it turned out, the go-ext-wasm project is much faster than other similar solutions.  But let's not get ahead.  Let's start with a story about how to work with him. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#3AC1EF">Calling wasm functions from Go</font> </h2><br>  First, install a wasmer in the Go environment (with cgo support). <br><br><pre><code class="go hljs">export CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">1</span></span>; export CC=gcc; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> install github.com/wasmerio/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-ext-wasm/wasmer</code> </pre> <br>  The <a href="https://github.com/wasmerio/go-ext-wasm">go-ext-wasm project</a> is a regular Go library.  When working with this library, the <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> construction is used <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> . <br><br>  Now we will start practice.  We write a simple program that is compiled into wasm.  Let's use for this, for example, Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   x + y }</code> </pre> <br>  The file with the program is called <code>simple.rs</code> , as a result of the compilation of this program, the file <a href="">simple.wasm is obtained</a> . <br><br>  The following program, written in Go, performs the function <code>sum</code> from a wasm file, passing in the form of arguments the numbers 5 and 37: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (   <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>   wasm <span class="hljs-string"><span class="hljs-string">"github.com/wasmerio/go-ext-wasm/wasmer"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-comment"><span class="hljs-comment">//   WebAssembly.   bytes, _ := wasm.ReadBytes("simple.wasm")   //    WebAssembly.   instance, _ := wasm.NewInstance(bytes)   defer instance.Close()   //    `sum`   WebAssembly.   sum := instance.Exports["sum"]   //        Go.   //   ,      ,  .   result, _ := sum(5, 37)   fmt.Println(result) // 42! }</span></span></code> </pre> <br>  Here, a program written in Go calls a function from a wasm-file, which was obtained as a result of compiling code written in Rust. <br><br>  So, the experiment was a success, we successfully executed the WebAssembly code in Go.  It should be noted that data type conversion is automated.  Those Go values ‚Äã‚Äãthat are passed to the wasm code are cast to the WebAssembly types.  What the wasm function returns is cast to Go types.  As a result, working with functions from wasm files in Go looks the same as working with ordinary Go functions. <br><br><h2>  <font color="#3AC1EF">Calling Go functions from WebAsse assembly code</font> </h2><br>  As we saw in the previous example, WebAsse-modules are able to export functions that can be called externally.  This is the mechanism that allows the wasm code to be executed in various environments. <br><br>  In this case, WebAssembly modules themselves can work with imported functions.  Consider the following program written in Rust. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { sum(x, y) } + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  <code>import.rs</code> file with it <code>import.rs</code> .  As a result of its compilation in WebAssembly, you get code that can be found <a href="">here</a> . <br><br>  The exported function <code>add1</code> calls the function <code>sum</code> .  There is no implementation of this function, only its signature is defined in the file.  This is the so-called extern-function.  For WebAssembly, this is an imported function.  Its implementation must be imported. <br><br>  We implement the <code>sum</code> function using Go.  For this we need to use <a href="https://blog.golang.org/c-go-cgo">cgo</a> .  Here is the resulting code.  Some comments, which are descriptions of the main code fragments, are numbered.  Below we talk about them in more detail. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// // 1.    `sum` (   cgo). // // #include &lt;stdlib.h&gt; // // extern int32_t sum(void *context, int32_t x, int32_t y); import "C" import (   "fmt"   wasm "github.com/wasmerio/go-ext-wasm/wasmer"   "unsafe" ) // 2.    `sum`    ( cgo). //export sum func sum(context unsafe.Pointer, x int32, y int32) int32 {   return x + y } func main() {   //   WebAssembly.   bytes, _ := wasm.ReadBytes("import.wasm")   // 3.     WebAssembly.   imports, _ := wasm.NewImports().Append("sum", sum, C.sum)   // 4.     WebAssembly  .   instance, _ := wasm.NewInstanceWithImports(bytes, imports)   //    WebAssembly.   defer instance.Close()   //    `add1`   WebAssembly.   add1 := instance.Exports["add1"]   //   .   result, _ := add1(1, 2)   fmt.Println(result)   // add1(1, 2)   // = sum(1 + 2) + 1   // = 1 + 2 + 1   // = 4   // QED }</span></span></code> </pre> <br>  Let's sort this code: <br><br><ol><li>  The signature of the <code>sum</code> function is defined in C (see the comment above the <code>import "C"</code> command). </li><li>  The implementation of the <code>sum</code> function is defined in Go (note the <code>//export</code> line ‚Äî such a mechanism cgo uses to link the code written in Go to the code written in C). </li><li>  <code>NewImports</code> is the API used to create WebAssembly imports.  In this code, <code>"sum"</code> is the name of the function imported by WebAssembly, <code>sum</code> is the pointer to the Go function, and <code>C.sum</code> is the pointer to the cgo function. </li><li>  And finally, <code>NewInstanceWithImports</code> is a constructor designed to initialize the module WebAssembly with imports. </li></ol><br><h2>  <font color="#3AC1EF">Reading data from memory</font> </h2><br>  The WebAssembly instance has linear memory.  Let's talk about how to read data from it.  Let's start, as usual, with a Rust-code, which we call <code>memory.rs</code> . <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_hello</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> {   <span class="hljs-string"><span class="hljs-string">b"Hello, World!\0"</span></span>.as_ptr() }</code> </pre> <br>  The result of compiling this code is in the <code>memory.wasm</code> file, which is used below. <br><br>  The <code>return_hello</code> function returns a pointer to a string.  The line ends, as in C, with a null character. <br><br>  Now go to the Go side: <br><br><pre> <code class="go hljs">bytes, _ := wasm.ReadBytes(<span class="hljs-string"><span class="hljs-string">"memory.wasm"</span></span>) instance, _ := wasm.NewInstance(bytes) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> instance.Close() <span class="hljs-comment"><span class="hljs-comment">//    `return_hello`. //      . result, _ := instance.Exports["return_hello"]() //      . pointer := result.ToI32() //    . memory := instance.Memory.Data() fmt.Println(string(memory[pointer : pointer+13])) // Hello, World!</span></span></code> </pre> <br>  The <code>return_hello</code> function returns a pointer as an <code>i32</code> value.  We get this value by calling <code>ToI32</code> .  Then we retrieve the data from memory using <code>instance.Memory.Data()</code> . <br><br>  This function returns a memory slice of an instance of WebAssembly.  It can be used like any Go slice. <br><br>  We, fortunately, know the length of the line we want to read, so to read the necessary information, it is enough to use the construction of <code>memory[pointer : pointer+13]</code> .  Then the read data is converted to a string. <br><br>  <a href="">Here is</a> an example that shows more advanced memory handling mechanisms when using WebAssembly code in Go. <br><br><h2>  <font color="#3AC1EF">Benchmarks</font> </h2><br>  The go-ext-wasm project, as we have just seen, has a convenient API.  Now it's time to talk about its performance. <br><br>  Unlike PHP or Ruby, in the world of Go, there are already solutions for working with wasm code.  In particular, we are talking about the following projects: <br><br><ul><li>  <a href="https://github.com/perlin-network/life">Life</a> from Perlin Network - WebAssembly interpreter. </li><li>  <a href="https://github.com/go-interpreter/wagon">Wagon</a> from Go Interpreter - WebAssembly interpreter and toolkit. </li></ul><br>  In the <a href="https://medium.com/wasmer/php-ext-wasm-migrating-from-wasmi-to-wasmer-4d1014f41c88">material</a> about the php-ext-wasm project, the <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/nbody.html">n-body</a> algorithm was used to study performance.  There are many other algorithms that are suitable for studying the performance of code execution environments.  For example, this is the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a> algorithm (recursive version) and <a href="https://en.wikipedia.org/wiki/Pollard%2527s_rho_algorithm">the Pollard œÅ-algorithm</a> used in Life.  This is the Snappy compression algorithm.  The latter successfully works with go-ext-wasm, but not with Life or Wagon.  As a result, he was removed from the test suite.  Test code can be found <a href="https://github.com/wasmerio/go-ext-wasm/tree/master/benchmarks">here</a> . <br><br>  During the tests, the latest versions of the studied projects were used.  Namely, it is Life 20190521143330‚Äì57f3819c2df0 and Wagon 0.4.0. <br><br>  The numbers shown in the diagram reflect the averaged values ‚Äã‚Äãobtained after 10 test runs.  The study used a MacBook Pro 15 "2016 with an Intel Core i7 2.9 GHz processor and 16 GB of memory. <br><br>  Test results are grouped along the X axis according to the types of tests.  The y-axis shows the time in milliseconds required to run the test.  The lower the index, the better. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/8c2/321/8108c23213493ab6ade095909770b58e.png"><br>  <i><font color="#999999">Comparison of Wasmer, Wagon and Life performance using implementations of various algorithms</font></i> <br><br>  The Life and Wagon platforms, on average, give roughly the same results.  Wasmer, on average, is 72 times faster. <br><br>  It is important to note that Wasmer supports three backends: <a href="https://github.com/wasmerio/wasmer/tree/master/lib/singlepass-backend">Singlepass</a> , <a href="https://github.com/wasmerio/wasmer/tree/master/lib/clif-backend">Cranelift</a> and <a href="https://github.com/wasmerio/wasmer/tree/master/lib/llvm-backend">LLVM</a> .  The backend used by default in the Go library is Cranelift ( <a href="https://github.com/CraneStation/cranelift">here</a> you can find out more about it).  Using LLVM will give performance close to native, but it was decided to start with Cranelift, since this backend gives the best balance between compile time and program execution time. <br><br>  <a href="https://medium.com/wasmer/a-webassembly-compiler-tale-9ef37aa3b537">Here</a> you can read about different backends, their pros and cons, about the situations in which they should be used. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  The open source project <a href="https://github.com/wasmerio/go-ext-wasm">go-ext-wasm</a> is a new Go-library designed for executing binary wasm-code.  It includes the <a href="https://github.com/wasmerio/wasmer">Wasmer</a> runtime <a href="https://github.com/wasmerio/wasmer">environment</a> .  Its first version includes an API, the need for which occurs most often. <br>  Performance tests showed that Wasmer, on average, was 72 times faster than Life and the Wagon. <br><br>  <b>Dear readers!</b>  Do you plan to use the capabilities for executing a wasm code in Go using go-ext-wasm? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/454518/">https://habr.com/ru/post/454518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454506/index.html">Entropic - the new distributed package registry for Node.js</a></li>
<li><a href="../45451/index.html">Notebook furniture</a></li>
<li><a href="../454512/index.html">Report from breakfast with Charles Wetzerell, author of the cult book "Etudes for Programmers"</a></li>
<li><a href="../454514/index.html">Developing a simple music synthesizer on ATMEGA8</a></li>
<li><a href="../454516/index.html">How to get a good text for 200 rubles</a></li>
<li><a href="../454520/index.html">Recommendations for writing clean code in JavaScript</a></li>
<li><a href="../454522/index.html">Node.js: managing the memory available to applications running in containers</a></li>
<li><a href="../454524/index.html">Repair Headphone Headband Samsung Level On Pro</a></li>
<li><a href="../45453/index.html">iLike is looking for a buyer</a></li>
<li><a href="../454530/index.html">DJI has created an Octocopter that can shoot movies.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>