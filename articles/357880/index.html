<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arduino programmable relay</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea is trivial, I needed a controller to manage the load in the house: 
 1. Boiler heating. 
 2. Accumulative boiler for water supply. 
 3. Pump ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arduino programmable relay</h1><div class="post__text post__text-html js-mediator-article">  The idea is trivial, I needed a controller to manage the load in the house: <br>  1. Boiler heating. <br>  2. Accumulative boiler for water supply. <br>  3. Pump in the well. <br><br>  I read a lot of fascinating articles on the topic of XX on Arduino, reading which clearly stated in my head the thought ‚ÄúI want Arduino‚Äù.  Having estimated the cost of components and ready-made solutions, I considered a clear benefit from the implementation of Arduino. <br><br><img src="https://habrastorage.org/files/f47/5e3/d1e/f475e3d1ebb24a6ebee7ee1bf41d74e9.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  So, the minimum program: </h4><br>  1. 4 relays, clock (RTC), LCD screen; <br>  2. Modes of operation of each relay: on, off, daily timer, one-time on; <br>  3. Control buttons for setting the time and relay modes; <br><br>  The house has a two-tariff counter, so the boiler heats the water from 23 to 7 in the morning.  Heating is similar: two out of three heating elements, according to my idea, will be switched on at night.  Temperature control is still native to the standard remote.  A one-time switch-on as a reserve will go to the pump, we program the switch-on, for example, to set the tank or pump the well, after which the relay goes off.  The main feature: made a complete device, controlled by buttons, and does not require connection to a PC. <br><a name="habracut"></a><br>  Of course, I wanted to hang everything in the future on the controller, since for heating it is advisable to make 3 operating modes: day from 7 to 23 in order to save, night, warming up for the morning off from 5..6 to 7. But for now the minimum program is implemented. <br><br><h4>  Hardware: </h4><br>  In the manufacture there was a task to get the product as cheap as possible, therefore the collective farm was present as much as possible.  Ali ordered a starter kit for arduino Uno R3, 4 relay module, I2C 20 * 4 LCD screen, RTC DS1307 I2C clock, Dht21 digital temperature and humidity sensor. <br><br>  Since all this saw the first time had to learn.  General concepts learned using Google from: <br>  <a href="http://habrahabr.ru/company/masterkit/blog/257747/">http://habrahabr.ru/company/masterkit/blog/257747/</a> <br>  <a href="http://arduino.ru/Reference">http://arduino.ru/Reference</a> <br><br>  I can not make a beautiful connection scheme, nothing.  In Fritzing for example, from components only the microcontroller. <br><br>  Connecting relays and buttons did not cause problems, only turned on pull-up resistors.  This is in the manual.  The link <a href="https://arduino-info.wikispaces.com/LCD-Blue-I2C">https://arduino-info.wikispaces.com/LCD-Blue-I2C#v3</a> helped in connecting the LCD screen.  It took a trimmer resistor adjustment, the screen ‚Äúout of the box‚Äù did not burn at all, which caused me a little confusion. <br><br>  The clock required only a battery, connected according to the standard scheme <a href="http://zelectro.cc/RTC_DS1307_arduino">http://zelectro.cc/RTC_DS1307_arduino</a> <br><br>  Clock synchronization with a computer did not.  When starting, it checks if the date is less than 2000 or more than 2100, the clock setting menu is displayed. <br><br>  Connection of several buttons to the analog input is described at <a href="http://arduino.net.ua/Arduino_articles/Arduino_proekty/Podkljuchenie%2520knopok%2520k%2520odnomu%2520analogovomu%2520vhodu/">http://arduino.net.ua/Arduino_articles/Arduino_proekty/Podkljuchenie%20knopok%20k%20odnomu%20analogovomu%20vhodu/</a> link, in the same place it is described how to enable pull-up resistors ‚ÄúpinMode (A2, INPUT_PULLUP); " <br><br>  The controls are classic, ‚Äúmonitor‚Äù: buttons ‚Äúmenu‚Äù, ‚Äú+‚Äù, ‚Äú-‚Äù, ‚Äúset‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">Assembly process (with photo)</b> <div class="spoiler_text">  I took the mounting plate on 6 machines: <br><br><img src="https://habrastorage.org/files/bf5/215/358/bf5215358ee842f9add7d6ba59357a49.jpg" alt="image"><br><br>  Put the mounting racks under the modules: <br><br><img src="https://habrastorage.org/files/d1e/3ef/e78/d1e3efe782684d50837ab0b07d011ee0.jpg" alt="image"><br><br>  Screw relay, clock, controller: <br><br><img src="https://habrastorage.org/files/171/7ee/052/1717ee0529cc41c497af99de24183d8a.jpg" alt="image"><br><br>  From the printer took a couple of rollers and some kind of sleeve.  The sleeve is glued on double-sided tape.  They will be mounted another board, more on that below. <br><br>  The power supply unit took from some kind of router Dlink, 5V 2A, did not begin to wrestle with the USB cable directly to it: <br><br><img src="https://habrastorage.org/files/cd0/8fc/778/cd08fc7781b14cb8b8f57c62d1312600.jpg" alt="image"><br><br>  Cut out plastic panel for mounting the screen: <br><br><img src="https://habrastorage.org/files/32f/ef2/18a/32fef218a54d4477b834e755510ac448.jpg" alt="image"><br><br>  Installed the screen.  Secured with mounting racks, under the keyboard - screw.  Racks are selected in height with the expectation that they will rest against the cover of the shield, giving the rigidity of the structure.  A sleeve on the relay block prevents the board from being pushed down when the buttons are pressed. <br><br><img src="https://habrastorage.org/files/08a/2f0/5a8/08a2f05a8bbc45acac35a81ed8bdeb16.jpg" alt="image"><br><br>  The buttons were originally planned to be connected to digital inputs, but suddenly I found a keyboard module from the monitor, which came up as a native one (a <a href="">diagram of the buttons from the monitor</a> ). <br><br>  The keyboard is glued to a double-sided tape through a gasket to lift the board over the bottom right screw.  The buttons press a match through the holes.  Ideally, drill holes and insert normal pushers.  Maybe I will do it in a cold winter evening, and now it was necessary to urgently implement a relay for heating water. <br><br>  Photos of the finished device: <br><img src="https://habrastorage.org/files/322/f6c/23f/322f6c23f74e4983967c03d9a7ea8e35.jpg" alt="image"><br><img src="https://habrastorage.org/files/2f7/8c5/cf1/2f78c5cf1e6b4de692bae01511426e88.jpg" alt="image"><br><br>  A flashing LED is also present. <br></div></div><br><br>  At the moment, the relay is hanging "on snot", controls the boiler, the final installation will be made after the installation of wiring and contactors for the heating boiler.  Phase from the pads, too, must be removed, of course, when installing the wiring.  Now there is no time, it is necessary to do outdoor chores.  The cost of parts amounted to about 2 thousand rubles. <br><br><h4>  Software part: </h4><br>  The software part was not easy: it took 90% of the time to write the menu, the usable code was managed only with the third version of the firmware. <br><br>  The first approach grew out of test samples for parts verification.  A classic example of procedural programming, development has not received.  I had to remember the principles of writing a good, valid code that would be amenable to subsequent reading and editing. <br><br>  The second approach was to translate the code into OOP principles.  The basis was a certain class TMenu, from which the menu elements were inherited directly. <br><br>  In short.  The CurrentMenu pointer is assigned the address of the current menu item. The main class items are the ItemIsValue bit, which determines whether the current item is a submenu or a changeable value and the OnKey (), Increment (), Decrement () and Print () functions.  Also the menu class contains a pointer to the parent menu and an array of pointers.  In general, the use of inheritance made it possible to make an arbitrary multi-level menu, in principle, we can say that this is a dynamic menu, only in this implementation it is formed once during initialization.  In any case, the code is easily edited, menu items are added.  Cruel reality put me in my place.  In UNO R3 for all this luxury is not enough memory. <br><br>  The third approach is the second pruning.  The main difference is that a specific menu class object contains either nested menus or variables ‚Äî editable values, the type of which is specified by the class. <br><br>  So, the class is defined: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMenu</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: byte _ItemsCount; TMenu *Parent; String *MenuName; boolean ItemIsValue; byte CurrentItem; TMenu **Items; String *ItemsName; <span class="hljs-function"><span class="hljs-function">byte </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemsCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TMenu *NewItem)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte KeyNum)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">DateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DateTime OldDate, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Increment, byte DatePart)</span></span></span></span>; };</code> </pre> <br><br>  The class contains: <br>  - the number of menu items (submenu or variable), a pointer to the parent menu (if the pointer is 0, then reached the top); <br>  - <b>MenuName the</b> name of the menu; <br>  - <b>ItemIsValue is</b> described above. <br>  - the position number of the cursor in the menu ( <b>CurrentItem</b> ); <br>  - pointer to array of pointers <b>Items</b> .  Addresses submenu.  If the menu contains editable items, this value is 0; <br>  - the <b>Print ()</b> function is called from the loop loop on behalf of the current menu ‚ÄúCurrentMenu-&gt; Print ();‚Äù thus the screen with the necessary text is drawn. <br>  - the <b>OnKey</b> function <b>(byte KeyNum) is</b> also called from the loop in the contact bounce block, also <b>known</b> as the keyboard decoder from the monitor. <br>  - functions <b>ChangeItem (byte value)</b> , <b>virtual void Increment (void)</b> , <b>virtual void Decrement (void)</b> are called from <b>OnKey ()</b> and process the buttons "+" and "-".  <b>ChangeItem ()</b> is a <b>batch of</b> menu items, <b>Increment ()</b> and <b>Decrement ()</b> are polymorphic, a batch of values ‚Äã‚Äãfor the current variable. <br>  - the <b>CheckDateTime</b> function <b>(DateTime OldDate, int Increment, byte DatePart)</b> checks the entered date and time.  The viscose year and the number of days in the month of 28/29, 30, 31 are recognized. Based on the logic, the current date, +1 or -1, and the index of the date / time part (0 - year, 5 - second) are passed to the function <br><br>  Menu navigation is implemented by assigning the address of an object to the CurrentMenu pointer: <br>  - CurrentMenu = CurrentMenu-&gt; Items [CurrentMenu-&gt; CurrentItem];  enter selected menu <br>  - CurrentMenu = CurrentMenu-&gt; Parent;  go to previous menu <br><br><h5>  Work Logic: </h5><br>  The loop loop continuously polls the keyboard, checks the relay settings and flashes the LED. <br><br>  <b>The keyboard is</b> polled as a rudiment and digital inputs 2-6 (menu, -, +, set), the values ‚Äã‚Äãof the analog ports are converted to these codes. <br>  - when you press the "menu" button outside the menu, the menu is called up; otherwise, the menu will go up; <br>  - pressing "+" or "-" causes a cyclic reassembly of menu items or a cyclic change of the current parameter.  When you press the "'set" button, enter the selected menu or save the variable value to flash with simultaneous selection of the next value. <br><br>  The bounce is suppressed programmatically, each button is assigned a push and release counter, which increases if pressed or released.  The survey is carried out 3 times with an interval of 15 ms.  The push or release count is incremented by 1 or reset.  Thus, the chattering of both pressing and releasing is recognized.  The release state is fixed for one-time operation when the button is held. <br><br>  <b>In the relay settings</b> , the operation mode is checked, in the ‚ÄúDaily‚Äù mode, only time is entered and verified, to the nearest minute.  The on time is correctly recognized as longer than the off time, for example, turning on at 23 and turning off at 7. In the ‚ÄúOn‚Äù mode, the date and time are set.  For convenience of setting, I plan to connect the fifth button and set the function for setting the current date and time in edit mode to it. <br><br>  This is in brief.  Small class functions are declared, usually when class is declared, header files and libraries are not used.  The code is so small. <br><br><div class="spoiler">  <b class="spoiler_title">Program code</b> <div class="spoiler_text">  #include &lt;EEPROM.h&gt; <br><br>  #include &lt;DHT.h&gt; <br>  #include &lt;Wire.h&gt; <br>  #include &lt;LiquidCrystal_I2C.h&gt; <br>  #include &lt;RTClib.h&gt; <br>  #define LEFT 0 <br>  #define CENTER 1 <br>  #define RIGHT 2 <br><br>  #define RelayModesCount 4 <br>  #define KeyFirst 2 <br>  #define KeyLast 6 <br><br>  LiquidCrystal_I2C lcd (0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE); <br>  RTC_DS1307 RTC;  // RTC Modul <br>  DHT dht (7, DHT21);  // pin, type <br>  volatile boolean Blinker = true; <br>  volatile long BlinkerTime; <br>  volatile byte ButtonPress [8]; <br>  const String RelayModeNames [] = {"OFF", "ON", "Once", "Daily"}; <br><br>  int aKey1 = 0; <br>  int aKey2 = 0; <br><br>  DateTime NowDate; <br><br>  boolean DoBlink (void) <br>  { <br>  boolean Result = false; <br>  long NBlinkerTime = millis (); <br>  if (blinker) <br>  { <br>  if (NBlinkerTime - BlinkerTime&gt; 200) <br>  { <br>  digitalWrite (8, HIGH); <br>  BlinkerTime = NBlinkerTime; <br>  Blinker = false; <br>  Result = true; <br>  } <br>  } <br>  else <br>  { <br>  if (NBlinkerTime - BlinkerTime&gt; 300) <br>  { <br>  digitalWrite (8, LOW); <br>  BlinkerTime = NBlinkerTime; <br>  Blinker = true; <br>  } <br><br>  } <br>  return Result; <br>  } <br>  String BlinkString (String string, byte Cur, byte ItemsCount) <br>  { <br>  String result = string; <br>  byte len = string.length (); <br>  if (! Blinker &amp;&amp; Cur == ItemsCount) <br>  { <br>  for (byte i = 0; i &lt;len; i ++) result.setCharAt (i, ''); <br>  } <br>  return result; <br>  } <br><br>  / ************************************************* ************************************************** ***** / <br>  / ********************************** Class declaration ************* ********************************* / <br>  / ************************************************* *************************************= ***** / <br><br>  class TMenu <br>  { <br>  public: <br>  byte _ItemsCount; <br>  TMenu * Parent; <br>  String * MenuName; <br>  boolean ItemIsValue; <br>  byte CurrentItem; <br><br>  TMenu ** Items; <br>  String * ItemsName; <br>  // byte ItemsCount (void); <br>  byte ItemsCount (void) { <br>  return _ItemsCount; <br>  }; <br>  bool AddItem (TMenu * NewItem); <br><br>  virtual void Print (void); <br>  void OnKey (byte KeyNum); <br>  void ChangeItem (byte value); <br><br>  virtual void Increment (void); <br>  virtual void Decrement (void); <br><br>  virtual void OnSet (void); <br>  DateTime CheckDateTime (DateTime OldDate, int Increment, byte DatePart); <br>  }; <br><br>  class TNoMenu: public TMenu <br>  { <br>  public: <br>  void Print (void); <br>  TNoMenu (TMenu * ParentMenu) { <br>  MenuName = 0; <br>  CurrentItem = 0; <br>  _ItemsCount = 0; <br>  Parent = ParentMenu; <br>  Items = 0; <br>  ItemsName = 0; <br>  ItemIsValue = false; <br>  }; <br>  void Increment (void) {}; <br>  void Decrement (void) {}; <br>  void OnSet (void) {}; <br><br>  }; <br><br>  class TSelectMenu: public TMenu <br>  { <br>  public: <br>  void Print (void); <br>  TSelectMenu (TMenu * ParentMenu, String NewName) { <br>  MenuName = new String (NewName); <br>  CurrentItem = 0; <br>  _ItemsCount = 0; <br>  Parent = ParentMenu; <br>  Items = 0; <br>  ItemsName = 0; <br>  ItemIsValue = false; <br>  }; <br>  void Increment (void) {}; <br>  void Decrement (void) {}; <br>  void OnSet (void) {}; <br>  }; <br><br>  class TTimeMenu: public TMenu <br>  { <br>  public: <br>  void Print (void); <br>  DateTime * SetDateTime; <br>  long OldDateTime; <br>  TTimeMenu (TMenu * ParentMenu, String NewName, DateTime * ParamDate) { <br>  MenuName = new String (NewName); <br>  CurrentItem = 0;  _ItemsCount = 6;  Parent = ParentMenu;  Items = 0;  ItemsName = 0; <br>  ItemIsValue = true;  OldDateTime = millis (); <br>  SetDateTime = ParamDate; <br>  }; <br>  void Increment (void) { <br>  * SetDateTime = CheckDateTime (* SetDateTime, 1, CurrentItem); <br>  }; <br>  void Decrement (void) { <br>  * SetDateTime = CheckDateTime (* SetDateTime, -1, CurrentItem); <br>  }; <br>  void OnSet (void) { <br>  RTC.adjust (* SetDateTime); <br>  }; <br>  void SecondTimer (void) { <br>  long TmpDateTime = millis ();  if (TmpDateTime - OldDateTime&gt; 1000) { <br>  OldDateTime = TmpDateTime; <br>  * SetDateTime = * SetDateTime + 1; <br>  }; <br>  }; <br>  }; <br>  class TRelayMenu: public TMenu <br>  { <br>  public: <br>  byte RelayNumber; <br>  byte RelayMode; <br>  // byte Shedule = 0; <br>  boolean oncebit; <br>  DateTime RelayOn; <br>  DateTime RelayOff; <br>  TRelayMenu (TMenu * ParentMenu, byte NewNumber, String NewName) { <br>  MenuName = new String (NewName); <br>  CurrentItem = 0;  _ItemsCount = 11;  Parent = ParentMenu;  Items = 0;  ItemsName = 0;  ItemIsValue = true, OnceBit = false; <br>  RelayNumber = NewNumber; <br>  RelayMode = 0; <br>  RelayOn = DateTime (2015, 1, 1, 23, 00, 00); <br>  RelayOff = DateTime (2015, 1, 1, 07, 00, 00); <br>  }; <br>  void Print (void); <br>  void Increment (void) { <br>  if (! CurrentItem) { <br>  RelayMode ++; <br>  if (RelayMode&gt; = RelayModesCount) RelayMode = 0; <br>  } <br>  else if (CurrentItem &lt;6) RelayOn = CheckDateTime (RelayOn, 1, CurrentItem - 1); <br>  else RelayOff = CheckDateTime (RelayOff, 1, CurrentItem - 6); <br>  }; <br>  void Decrement (void) { <br>  if (! CurrentItem) { <br>  RelayMode--; <br>  if (RelayMode&gt; 127) RelayMode = RelayModesCount - 1; <br>  } <br>  else if (CurrentItem &lt;6) RelayOn = CheckDateTime (RelayOn, -1, CurrentItem - 1); <br>  else RelayOff = CheckDateTime (RelayOff, -1, CurrentItem - 6); <br>  }; <br><br>  boolean CheckDaily (void); <br><br>  void OnSet (void) { <br>  ///// here you need to write the relay in memory <br><br>  byte p_address = RelayNumber * 16; <br>  EEPROM.write (p_address, RelayMode); <br><br>  EEPROM.write (p_address + 1, byte (RelayOn.year () - 2000)); <br>  EEPROM.write (p_address + 2, byte (RelayOn.month ())); <br>  EEPROM.write (p_address + 3, byte (RelayOn.day ())); <br>  EEPROM.write (p_address + 4, byte (RelayOn.hour ())); <br>  EEPROM.write (p_address + 5, byte (RelayOn.minute ())); <br><br>  EEPROM.write (p_address + 6, byte (RelayOff.year () - 2000)); <br>  EEPROM.write (p_address + 7, byte (RelayOff.month ())); <br>  EEPROM.write (p_address + 8, byte (RelayOff.day ())); <br>  EEPROM.write (p_address + 9, byte (RelayOff.hour ())); <br>  EEPROM.write (p_address + 10, byte (RelayOff.minute ())); <br>  }; <br>  }; <br><br>  / ************************************************* ************************************************** ***** / <br>  / ******************************** End of class declaration ************** ***************************** / <br>  / ************************************************* ************************************************** ***** / <br><br>  TMenu * CurrentMenu = 0; <br>  TNoMenu * NoMenu = 0; <br>  TSelectMenu * SelectMenu; <br>  TTimeMenu * TimeMenu; <br><br>  TRelayMenu * RelayMenu [4]; <br><br>  / ************************************************* ************************************************** ****************************************** / <br>  / ************************************************* ************************************************** ****************************************** / <br>  / ************************************************* ************************************************** ****************************************** / <br>  void setup () <br>  { <br>  NoMenu = new TNoMenu (0); <br>  SelectMenu = new TSelectMenu (NoMenu, "NoMenu"); <br>  TimeMenu = new TTimeMenu (SelectMenu, "Time Setup", &amp; NowDate); <br><br>  SelectMenu-&gt; AddItem (TimeMenu); <br><br>  byte p_address; <br>  DateTime DTFlesh; <br>  for (int i = 0; i &lt;4; i ++) <br>  { <br>  // here you need to add loading parameters from the flash <br>  RelayMenu [i] = new TRelayMenu (SelectMenu, i, ‚ÄúRelay‚Äù + String (i + 1)); <br>  SelectMenu-&gt; AddItem (RelayMenu [i]); <br><br>  p_address = i * 16; <br><br>  RelayMenu [i] -&gt; RelayMode = EEPROM.read (p_address); <br><br>  DTFlesh = DateTime (int (EEPROM.read (p_address + 1) + 2000), EEPROM.read (p_address + 2), EEPROM.read (p_address + 3), EEPROM.read (p_address + 4), EEPROM.read (p_address + 5), 0); <br>  RelayMenu [i] -&gt; RelayOn = RelayMenu [i] -&gt; CheckDateTime (DTFlesh, 0, 0); <br><br>  DTFlesh = DateTime (int (EEPROM.read (p_address + 6) + 2000), EEPROM.read (p_address + 7), EEPROM.read (p_address + 8), EEPROM.read (p_address + 9), EEPROM.read (p_address + 10), 0); <br>  RelayMenu [i] -&gt; RelayOff = RelayMenu [i] -&gt; CheckDateTime (DTFlesh, 0, 0); <br>  } <br><br>  for (byte i = KeyFirst; i &lt;KeyLast; i ++) <br>  { <br>  pinMode (i, INPUT);  // Keypad 2- ‚Äúmenu‚Äù 3 - "-" 4 - "+" 5- "SET" <br>  digitalWrite (i, HIGH);  // setup Resistor input2Vcc <br>  ButtonPress [i] = true; <br>  } <br>  pinMode (8, OUTPUT);  // LED <br>  pinMode (9, OUTPUT); <br>  for (byte i = 10; i &lt;14; i ++) <br>  { <br>  pinMode (i, OUTPUT);  // relay i <br>  digitalWrite (i, HIGH); <br>  } <br><br>  pinMode (A2, INPUT_PULLUP); <br>  pinMode (A3, INPUT_PULLUP); <br><br>  Serial.begin (9600);  // Used to type in characters <br>  digitalWrite (8, LOW); <br>  digitalWrite (9, HIGH); <br><br>  lcd.begin (20, 4);  // initialize the lcd for 20 chars 4 lines and turn on backlight <br>  RTC.begin (); <br><br>  lcd.noBacklight (); <br>  delay (150); <br>  lcd.backlight (); <br><br>  NowDate = RTC.now (); <br>  // check time <br>  if (NowDate.year ()&gt; 2000 &amp;&amp; NowDate.year () &lt;2114 &amp;&amp; <br>  NowDate.month ()&gt; 0 &amp;&amp; NowDate.month () &lt;13 &amp;&amp; <br>  NowDate.day ()&gt; 0 &amp;&amp; NowDate.day () &lt;32 &amp;&amp; <br>  NowDate.hour ()&gt; = 0 &amp;&amp; NowDate.hour () &lt;24 &amp;&amp; <br>  NowDate.minute ()&gt; = 0 &amp;&amp; NowDate.minute () &lt;60 &amp;&amp; <br>  NowDate.second ()&gt; = 0 &amp;&amp; NowDate.second () &lt;60) <br>  { <br>  CurrentMenu = NoMenu; <br>  } <br>  else <br>  { <br>  lcd.setCursor (2, 1); <br>  lcd.print (‚ÄúClock Failure!‚Äù); <br>  delay (700); <br>  RTC.adjust (DateTime (2015, 1, 1, 00, 00, 00)); <br>  CurrentMenu = TimeMenu; <br>  } <br><br>  } <br><br>  void loop () <br>  { <br>  / ********* KEYPAD BUNCLE, 5 keys, from 2 to 6 ********* / <br>  byte NButtonPress [8] = {0, 0, 0, 0, 0, 0, 0, 0}; <br>  byte NButtonRelease [8] = {0, 0, 0, 0, 0, 0, 0, 0}; <br>  const byte ButtonTry = 3; <br><br>  aKey1 = analogRead (2); <br>  aKey2 = analogRead (3); <br>  byte aKeyNum = 0; <br><br>  / **************** check for key pressed or released *************** / <br>  for (byte i = 0; i &lt;3; i ++) <br>  { <br>  delay (15); <br>  if (aKey1 &lt;64) aKeyNum = 2; // AnalogKey 1 = Dig2 <br>  else if (aKey1 &lt;128) aKeyNum = 6; // Analog key 3 = D4 <br>  else if (aKey1 &lt;256) aKeyNum = 4; // key 5 = d6 <br>  else if (aKey2 &lt;64) aKeyNum = 1; // key 6 = menu <br>  else if (aKey2 &lt;128) aKeyNum = 3; // analogkey 2 = D3 <br>  else if (aKey2 &lt;256) aKeyNum = 5; // key 4 = d5 <br>  else aKeyNum = 0;  // no key <br><br>  for (byte j = KeyFirst; j &lt;KeyLast; j ++) // Read ports 2 ... 6 <br>  { <br>  if (digitalRead (j) == LOW || aKeyNum == j) <br>  { <br>  NButtonPress [j] ++; <br>  NButtonRelease [j] = 0; <br>  } <br>  else <br>  { <br>  NButtonPress [j] = 0; <br>  NButtonRelease [j] ++; <br>  delay (5); <br>  } <br>  } <br><br>  } <br>  / *************** Do key process ****************** / <br>  // byte m; <br><br>  for (byte j = KeyFirst; j &lt;KeyLast; j ++) <br>  { <br>  if (NButtonPress [j]&gt; = ButtonTry &amp;&amp; ButtonPress [j] == false) <br>  { <br>  ButtonPress [j] = true; <br>  CurrentMenu-&gt; OnKey (j); <br>  } <br>  else <br>  { <br>  if (NButtonRelease [j]&gt; = ButtonTry &amp;&amp; ButtonPress [j] == true) <br>  { <br>  ButtonPress [j] = false; <br>  } <br>  } <br>  } <br>  / ***************** Relay Check ******************** / <br><br>  CurrentMenu-&gt; Print (); <br>  DoBlink (); <br>  } <br><br>  void LcdPrint (byte string, String str, byte Align) <br>  { <br>  byte StrTrim1; <br>  byte StrTrim2; <br>  lcd.setCursor (0, string);  // Start at character 0 on line 0 <br>  switch (Align) <br>  { <br>  case RIGHT: <br><br>  break; <br><br>  case CENTER: <br>  StrTrim1 = byte ((20 - str.length ()) / 2); <br>  StrTrim2 = 20 - str.length () - StrTrim1; <br>  for (byte k = 0; k &lt;StrTrim1; k ++) lcd.print (""); <br>  lcd.print (str); <br>  for (byte k = 0; k &lt;StrTrim2; k ++) lcd.print (""); <br>  break; <br><br>  default: <br>  lcd.print (str); <br>  StrTrim1 = 20 - str.length (); <br>  for (byte k = 0; k &lt;StrTrim1; k ++) lcd.print (""); <br>  } <br>  } <br><br>  void TNoMenu :: Print (void) <br>  { <br>  NowDate = RTC.now (); <br>  String ddate; <br>  Ddate = "R1-" + RelayModeNames [RelayMenu [0] -&gt; RelayMode] + "R2-" + RelayModeNames [RelayMenu [1] -&gt; RelayMode]; <br>  LcdPrint (0, Ddate, CENTER); <br>  Ddate = "R3-" + RelayModeNames [RelayMenu [2] -&gt; RelayMode] + "R4-" + RelayModeNames [RelayMenu [3] -&gt; RelayMode]; <br>  LcdPrint (1, Ddate, CENTER); <br>  Ddate = String (NowDate.year ()) + "/" + String (NowDate.month ()) + "/" + String (NowDate.day ()) + "" + String (NowDate.hour ()) + " : "+ String (NowDate.minute ()) +": "+ String (NowDate.second ()); <br>  LcdPrint (2, Ddate, CENTER); <br>  Ddate = "Temp" + String (int (dht.readTemperature ())) + "C, Hum" + String (int (dht.readHumidity ())) + "%"; <br>  LcdPrint (3, Ddate, CENTER); <br><br>  RelayCheck (); <br>  } <br><br>  void TTimeMenu :: Print (void) <br>  { <br>  SecondTimer (); <br>  String Ddate = BlinkString (String ((* SetDateTime) .year ()), CurrentItem, 0) + "/" + <br>  BlinkString (String ((* SetDateTime) .month ()), CurrentItem, 1) + "/" + <br>  BlinkString (String ((* SetDateTime) .day ()), CurrentItem, 2) + ""; <br>  LcdPrint (1, Ddate, CENTER); <br>  Ddate = BlinkString (String ((* SetDateTime) .hour ()), CurrentItem, 3) + ":" + <br>  BlinkString (String ((* SetDateTime) .minute ()), CurrentItem, 4) + ":" + <br>  BlinkString (String ((* SetDateTime) .second ()), CurrentItem, 5); <br>  LcdPrint (2, Ddate, CENTER); <br><br>  LcdPrint (3, "", CENTER); <br>  RelayCheck (); <br>  } <br><br>  void TMenu :: OnKey (byte KeyNum) <br>  { <br>  switch (KeyNum) <br>  { <br>  case 3: // - if (ItemIsValue) Decrement (); <br>  else ChangeItem (-1); <br>  break; <br>  case 4: // + <br>  if (ItemIsValue) Increment (); <br>  else ChangeItem (1); <br>  break; <br>  case 5: // SET <br>  if (ItemIsValue) <br>  { <br>  OnSet (); <br>  ChangeItem (+1); <br>  } <br>  else // enter the submenu <br>  { <br>  if (Items &amp;&amp; ItemsCount ()) <br>  { <br>  if (CurrentMenu-&gt; ItemsCount ()) <br>  { <br>  CurrentMenu = CurrentMenu-&gt; Items [CurrentMenu-&gt; CurrentItem]; <br>  CurrentMenu-&gt; CurrentItem = 0; <br>  } <br>  } <br>  } <br>  break; <br>  default: // 2 -menu <br>  if (Parent) CurrentMenu = CurrentMenu-&gt; Parent;  // (TMenu *) &amp; NoMenu; <br>  else <br>  { <br>  CurrentMenu = SelectMenu; <br>  CurrentMenu-&gt; CurrentItem = 0; <br>  } <br>  } <br>  } <br><br>  void TMenu :: ChangeItem (byte value) <br>  { <br>  CurrentItem + = value; <br>  if (CurrentItem&gt; 128) CurrentItem = ItemsCount () - 1; <br>  else if (CurrentItem&gt; ItemsCount () - 1) CurrentItem = 0; <br>  } <br><br>  boolean TMenu :: AddItem (TMenu * NewItem) <br>  { <br>  if (! Items) Items = new TMenu * [_ ItemsCount = 1]; <br>  else Items = (TMenu **) realloc ((void *) Items, (_ItemsCount = _ItemsCount + 1) * sizeof (void *)); <br>  Items [_ItemsCount - 1] = NewItem; <br>  } <br><br>  DateTime TMenu :: CheckDateTime (DateTime OldDate, int Increment, byte DatePart) <br>  { <br>  int DTmin [6] = {2000, 1, 1, 0, 0, 0}; <br>  int DTmax [6] = {2199, 12, 31, 23, 59, 59}; <br><br>  int DT [6]; <br>  int diff; <br><br>  DT [0] = OldDate.year (); <br>  DT [1] = OldDate.month (); <br>  DT [2] = OldDate.day (); <br>  DT [3] = OldDate.hour (); <br>  DT [4] = OldDate.minute (); <br>  DT [5] = OldDate.second (); <br>  DT [DatePart] = DT [DatePart] + Increment; <br><br>  if (DT [1] == 1 || DT [1] == 3 || DT [1] == 5 || DT [1] == 7 || DT [1] == 8 || DT [1] ] == 10 || DT [1] == 12) DTmax [2] = 31; <br>  else if (DT [1] == 2) <br>  { <br>  if ((DT [0]% 4 == 0 &amp;&amp; DT [0]% 100! = 0) || (DT [0]% 400 == 0)) DTmax [2] = 29; <br>  else DTmax [2] = 28; <br>  } <br>  else DTmax [2] = 30; <br><br>  for (byte i = 0; i &lt;6; i ++) <br>  { <br>  if (DT [i]&gt; DTmax [i]) DT [i] = DTmin [i]; <br>  else if (DT [i] &lt;DTmin [i]) DT [i] = DTmax [i]; <br>  } <br><br>  return DateTime (DT [0], DT [1], DT [2], DT [3], DT [4], DT [5]); <br><br>  } <br><br>  void TSelectMenu :: Print (void) <br>  { <br>  NowDate = RTC.now (); <br>  byte shift = 0; <br>  if (CurrentItem&gt; 3) shift = CurrentItem - 3; <br>  for (byte i = 0; i &lt;4; i ++) <br>  { <br>  if ((CurrentItem - shift) == i) // &amp; &amp; Blinker) <br>  { <br>  LcdPrint (i, "&gt;&gt;" + * (Items [i + shift] -&gt; MenuName) + "&lt;&lt;", CENTER); <br>  } <br>  else LcdPrint (i, * (Items [i + shift] -&gt; MenuName), CENTER); <br>  } <br>  RelayCheck (); <br>  } <br><br>  void TRelayMenu :: Print (void) <br>  { <br><br>  String DData; <br>  NowDate = RTC.now (); <br>  LcdPrint (0, (* MenuName) + "[" + BlinkString (RelayModeNames [RelayMode], CurrentItem, 0) + "]", CENTER); <br>  DData = "On:"; <br>  switch (RelayMode) <br>  { <br>  case 3: // Daily <br>  // DData = DData + ""; <br>  if (CurrentItem&gt; 0 &amp;&amp; CurrentItem &lt;4) CurrentItem = 4; <br>  break; <br>  default: <br>  DData = DData + BlinkString (String (RelayOn.year (), DEC), CurrentItem, 1) + "/" + BlinkString (String (RelayOn.month (), DEC), CurrentItem, 2) + <br>  "/" + BlinkString (String (RelayOn.day (), DEC), CurrentItem, 3); <br>  } <br>  DData = DData + "" + BlinkString (String (RelayOn.hour (), DEC), CurrentItem, 4) + ":" + BlinkString (String (RelayOn.minute (), DEC), CurrentItem, 5); <br>  LcdPrint (1, DData, CENTER); <br>  DData = "Off:"; <br>  switch (RelayMode) <br>  { <br>  case 3: // Daily <br>  // DData = DData + ""; <br>  if (CurrentItem&gt; 5 &amp;&amp; CurrentItem &lt;9) CurrentItem = 9; <br>  break; <br>  default: <br>  DData = DData + BlinkString (String (RelayOff.year (), DEC), CurrentItem, 6) + "/" + BlinkString (String (RelayOff.month (), DEC), CurrentItem, 7) + <br>  "/" + BlinkString (String (RelayOff.day (), DEC), CurrentItem, 8); <br>  } <br>  DData = DData + "" + BlinkString (String (RelayOff.hour (), DEC), CurrentItem, 9) + ":" + BlinkString (String (RelayOff.minute (), DEC), CurrentItem, 10); <br>  LcdPrint (2, DData, CENTER); <br>  LcdPrint (3, "", CENTER); <br>  } <br><br>  boolean TRelayMenu :: CheckDaily (void) <br>  { <br>  int TimeOn = 60 * int (RelayOn.hour ()) + int (RelayOn.minute ()); <br>  int TimeOff = 60 * int (RelayOff.hour ()) + int (RelayOff.minute ()); <br>  int NowTime = 60 * int (NowDate.hour ()) + int (NowDate.minute ()); <br>  boolean result;  // true = on time is longer than off time <br>  if (TimeOn&gt; TimeOff) <br>  { <br>  if (NowTime &lt;= TimeOff || NowTime&gt; = TimeOn) result = true; <br>  else result = false; <br>  } <br>  else <br>  { <br>  if (NowTime &lt;= TimeOff &amp;&amp; NowTime&gt; = TimeOn) result = true; <br>  else result = false; <br>  }; <br>  return result; <br><br>  } <br><br>  void RelayCheck (void) <br>  { <br>  boolean OnceBitCheck; <br>  for (byte i = 0; i &lt;4; i ++) <br>  { <br>  switch (RelayMenu [i] -&gt; RelayMode) <br>  { <br>  case 1: // relay 0n <br>  digitalWrite (i + 10, LOW); <br><br>  break; <br>  case 2: // Once; <br>  OnceBitCheck = (NowDate.unixtime ()&gt; RelayMenu [i] -&gt; RelayOn.unixtime () &amp;&amp; NowDate.unixtime () &lt;RelayMenu [i] -&gt; RelayOff.unixtime ()); <br><br>  if (OnceBitCheck) RelayMenu [i] -&gt; OnceBit = true; <br>  else if (RelayMenu [i] -&gt; OnceBit) <br>  { <br>  RelayMenu [i] -&gt; RelayMode = 0; <br>  byte p_address = RelayMenu [i] -&gt; RelayNumber * 16; <br>  EEPROM.write (p_address, RelayMenu [i] -&gt; RelayMode); <br>  } <br>  digitalWrite (i + 10,! OnceBitCheck); <br>  break; <br>  case 3: // Daily <br>  digitalWrite (i + 10,! (RelayMenu [i] -&gt; CheckDaily ())); <br>  break; <br>  default: // relay 0ff <br>  digitalWrite (i + 10, HIGH); <br>  } <br>  } <br>  } <br></div></div><br><br>  That turned out to be an odd job that saved me from having to get up at 7 am and go to bed at 23, while not forgetting to click the toggle switches.  I do not pretend to industrial standards, I did not encapsulate the data in the code, I also left global variables. <br><br>  There were concerns about the accuracy of the clock, but so far no significant deviations have been noticed. <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/357880/">https://habr.com/ru/post/357880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357858/index.html">The Ministry of Communications and the Ministry of Foreign Affairs will create an autonomous DNS root server system in the BRICS countries</a></li>
<li><a href="../357860/index.html">Yandex.Catalog stops accepting applications and closes soon</a></li>
<li><a href="../357862/index.html">How to make Push notifications in Safari browser on macOS</a></li>
<li><a href="../357864/index.html">Roskomnadzor will conduct an "experiment" on blocking Zello Internet radio in Russia</a></li>
<li><a href="../357866/index.html">Roskomnadzor continues to destroy the Internet: it's Google's turn</a></li>
<li><a href="../357882/index.html">Laser link between two Arduino Morse code</a></li>
<li><a href="../357884/index.html">Forecaster Class for Weather Station or Weather Predictor</a></li>
<li><a href="../357886/index.html">Arduino: TV viewing time limit using RFID RC522 and</a></li>
<li><a href="../357888/index.html">DMX-512 Channel Level Transmission Visualization</a></li>
<li><a href="../357890/index.html">We process lines on Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>