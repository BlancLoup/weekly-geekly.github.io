<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the Linux kernel boot process</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 While Leonid is preparing for his first open lesson in our course ‚ÄúLinux Administrator‚Äù , we continue to talk about loading the Linux kernel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the Linux kernel boot process</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  While <a href="https://otus.pw/aXJQ/">Leonid</a> is preparing for his first <a href="https://otus.pw/499x/">open lesson</a> in our course <a href="https://otus.pw/SASj/">‚ÄúLinux Administrator‚Äù</a> , we continue to talk about loading the Linux kernel. <br><br>  Go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Understanding the operation of a system that functions without failures - preparing for the elimination of inevitable breakdowns <br><br>  The oldest joke in the field of open source software is a statement that ‚Äúthe code documents itself‚Äù.  Experience shows that reading the source code is like listening to weather forecasts: intelligent people will still go out and look at the sky.  The following are tips for checking and investigating the boot of Linux systems using familiar debugging tools.  An analysis of the boot process of a system that works well prepares users and developers to eliminate the inevitable failures. <br><br>  On the one hand, the boot process is surprisingly simple.  The kernel of the operating system (kernel) runs single-threaded and synchronous on one core (core), which may seem understandable even to a pitiful human mind.  But how does the kernel run itself?  What are the functions of initrd ( <a href="https://ru.wikipedia.org/wiki/Initrd">disk in memory for initial initialization</a> ) and boot loaders?  And wait, why is the LED on the Ethernet port always on? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Read on to get answers to these and some other questions;  The code for the described demos and exercises is also available on <a href="https://github.com/chaiken/LCA2018-Demo-Code">GitHub</a> . <br><br>  <b>Start of loading: state OFF</b> <br><br>  <i><b>Wake-on-lan</b></i> <br><br>  A state of OFF means the system has no power, right?  The seeming simplicity is deceptive.  For example, the Ethernet LED is on even in this state, because wake-on-LAN is on in your system (WOL, wake-up on [signal from] local network).  Make sure to write: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Where instead may be, for example, eth0 (ethtool is in Linux packages with the same name).  If the ‚Äúwake-on‚Äù in the output shows g, remote hosts can boot the system by sending <a href="https://ru.wikipedia.org/wiki/Wake-on-LAN">MagicPacket</a> .  If you do not want to remotely turn on your system yourself and give this opportunity to others, disable WOL in the system BIOS menu, or using: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  The processor that responds to MagicPacket can be a <a href="https://lwn.net/Articles/630778/">Baseboard Management Controller</a> (BMC) or part of a network interface. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub and Minix</b></i> <br><br>  The BMC is not the only microcontroller (MCU) that can ‚Äúlisten‚Äù to a nominally turned off system.  On x86_64 systems, there is the Intel Management Engine (IME) software package for remote system management.  A wide range of devices, from servers to laptops, have technology that <a href="https://www.youtube.com/watch%3Fv%3DiffTJ1vPCSo%26index%3D65%26list%3DPLbzoR-pLrL6pISWAq-1cXP4_UZAyRtesk">has features such</a> as KVM Remote Control or Intel Capability Licensing Service.  According to <a href="https://www.intel.com/content/www/us/en/support/articles/000025619/software.html">Inte</a> l's <a href="https://www.intel.com/content/www/us/en/support/articles/000025619/software.html">own tool</a> , <a href="https://security-center.intel.com/advisory.aspx%3Fintelid%3DINTEL-SA-00086%26languageid%3Den-fr">IME has unpatched vulnerabilities.</a>  Bad news - disable IME is difficult.  Trammell Hudson created <a href="https://github.com/corna/me_cleaner">the me_cleaner project, which erases</a> some of the most egregious IME components, such as the embedded web server, but at the same time there is a chance that using the project will turn the system on which it is running into a brick. <br><br>  The IME firmware and the System Management Mode (SMM) program, which follows it on boot, are based on <a href="https://lwn.net/Articles/738649/">the Minix operating system</a> and run on a separate Platform Controller Hub processor, rather than the main system CPU.  Then SMM launches the Universal Extensible Firmware Interface (UEFI) program on the main processor, which <a href="https://lwn.net/Articles/699551/">has already been written about more than once</a> .  The Coreboot group launched at Google the excitingly ambitious <a href="https://trmm.net/NERF">Non-Extensible Reduced Firmware (NERF) project</a> , which aims to replace not only UEFI, but also the early components of the Linux user space, for example, systemd.  And while we are waiting for results, Linux users can purchase laptops from Purism, System76 or Dell, on which <a href="https://www.extremetech.com/computing/259879-dell-now-shipping-laptops-intels-management-engine-disabled">IME is disabled</a> , plus, we can hope for laptops with a <a href="https://lwn.net/Articles/733837/">64-bit ARM processor</a> . <br><br>  <i><b>Loaders</b></i> <i><b><br></b></i> <br>  What besides running booted spyware does boot firmware do?  The task of the loader is to provide the just-enabled processor with the necessary resources to run a general-purpose operating system like Linux.  During power up, there is not only virtual memory, but DRAM until the time when its controller is raised.  The boot loader then turns on the power supplies and scans the buses and interfaces to find the kernel image and root filesystem.  Popular boot loaders, for example, U-Boot and GRUB, have support for common interfaces like USB, PCI and NFS, as well as other more specialized embedded devices such as NOR and NAND flash.  Loaders also interact with hardware security devices, such as the <a href="https://linuxplumbersconf.org/2017/ocw/events/LPC2017/tracks/639">Trusted Platform Module (TPM)</a> , to establish a trust chain from the beginning of the download. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Run the U-boot bootloader in the sandbox on the build server.</i> <br><br>  The popular open source <a href="http://www.denx.de/wiki/DULG/Manual">U-Boot</a> downloader is supported on systems from Raspberry Pi to Nintendo devices, motherboards and Chromebooks.  There is no system log, and if something goes wrong, there may not even be a console output.  To facilitate debugging, the U-Boot team provides a sandbox for testing patches on the build host or even in the Continuous Integration system.  On a system where the usual development tools like Git and the GNU Compiler Collection (GCC) are installed, it‚Äôs easy to understand the U-Boot sandbox. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  That's all: you launched U-Boot on x86_64 and can test tricky features, for example, repartition of <a href="https://github.com/chaiken/LCA2018-Demo-Code">dummy storage devices</a> , TPM-based key manipulation and hot plug (hotplug) of USB devices.  The U-Boot sandbox can be single-stage as part of the GDB debugger.  Development using a sandbox is 10 times faster than testing by rewriting the loader onto the board, plus the ‚Äúbrick‚Äù sandbox can be restored by pressing Ctrl + C. <br><br>  <b>Kernel startup</b> <br><br>  <i><b>Supply booting kernel</b></i> <br><br>  After completing his tasks, the loader switches to the kernel code that it loaded into main memory, and starts its execution, passing all the command line parameters that the user specified.  What is the core program?  file / boot / vmlinuz shows that this is a bzImage.  There is <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">a extract-vmlinux tool in the</a> Linux source tree that can be used to decompress a file: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  The kernel is an <a href="http://man7.org/linux/man-pages/man5/elf.5.html">Executable and Linking Format (ELF)</a> binary file, just like the Linux user-space program.  This means that we can use commands from the binutils package, such as readelf, to study it.  Compare, for example, the following conclusions: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  The list of sections in binary files is mostly similar. <br><br>  So, the kernel should run other ELF Linux binaries ... But how are user-space programs running?  In the <code>main()</code> function, right?  Not really. <br><br>  Before launching the function <code>main()</code> programs need the execution context, including heap- (heap) and stack- (stack) memory, plus file descriptors for <code>stdio</code> , <code>stdout</code> and <code>stderr</code> .  User-space programs get these resources from the standard library ( <code>glibc</code> for most Linux systems).  Consider the following: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  ELF binary files have an interpreter, just like Bash and Python scripts.  But it does not need to be clarified through <code>#!</code>  , as in scripts, because ELF is a proprietary Linux format.  The ELF interpreter supplies the binary file with all the necessary resources by calling the <code>_start()</code> function, which is available in the <code>glibc</code> source package, which can be studied through <a href="https://github.com/chaiken/LCA2018-Demo-Code/commit/e543d9812058f2dd65f6aed45b09dda886c5fd4e">GDB</a> .  The kernel obviously does not have an interpreter, and it must supply itself, but how? <br><br>  An investigation of the launch of a kernel with GDB provides an answer to this question.  First, install the kernel debug package, which contains an uncut version of <code>vmlinux</code> , for example, <code>apt-get install linux-image-amd64-dbg</code> .  Or compile and install your own kernel from some source, for example, following the instructions from the excellent <a href="https://kernel-team.pages.debian.net/kernel-handbook/">Debian Kernel Handbook</a> .  <code>gdb vmlinux</code> , followed by the <code>info files</code> , shows the ELF section <code>init.text</code> .  Specify the start of program execution in <code>init.text</code> with <code>l *(address)</code> , where address is the hex start of <code>init.text</code> .  GDB will indicate that the x86_64 kernel is run in the <code><a href="">arch/x86/kernel/head_64.S</a></code> , where we find the build function <code>start_cpu0()</code> and the code that explicitly creates the stack and unpacks the zImage before calling the <code>x86_64 start_kernel()</code> function.  ARM 32-bit kernels have similar <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> is architecture independent, so the function is in the kernel <code>init/main.c</code>  We can say that <code>start_kernel()</code> is the real <code>main()</code> function of Linux. <br><br>  <b>From start_kernel () to PID 1</b> <br>  <i><b>Kernel hardware manifest: ACPI tables and device trees</b></i> <br><br>  When loading, the kernel needs hardware information in addition to the type of processor for which it was compiled.  The instructions in the code are supplemented with configuration data that is stored separately.  There are two main methods of data storage: Device Tree and <a href="http://events.linuxfoundation.org/sites/events/files/slides/x86-platform.pdf">ACPI tables</a> .  The kernel learns from these files what hardware needs to be run on each boot. <br><br>  For embedded devices, the device tree (DM) is the manifest of the installed hardware.  The DU is a file that is compiled at the same time as the kernel source and is usually located in / boot along with <code>vmlinux</code> .  To see what is in a binary device tree on an ARM device, simply use the <code>strings</code> command from the binutils package in the file whose name is <code>/boot/*.dtb</code> , because <code>dtb</code> means the binary file of the device tree (Device-Tree Binary).  The remote control can be changed by editing the JSON-like files of which it is composed and by restarting the special dtc compiler provided with the kernel source.  The remote control is a static file whose path is usually passed to the kernel by loaders on the command line, but in recent years a <a href="http://lwn.net/Articles/616859/">device tree overlay</a> has been added where the kernel can dynamically load additional fragments in response to hotplug events after loading. <br><br>  The x86 family and many ARM64 business-level devices use an alternative Advanced Configuration and Power Interface mechanism ( <a href="http://events.linuxfoundation.org/sites/events/files/slides/x86-platform.pdf">ACPI</a> , advanced configuration and power management interface).  Unlike the remote control, the ACPI information is stored in the virtual file system <code>/sys/firmware/acpi/tables</code> , which is created by the kernel at launch through a call to the built-in ROM.  To read ACPI tables, use the <code>acpidump</code> command from the <code>acpica-tools</code> package.  Here is an example: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>ACPI tables on Lenovo laptops are ready for Windows 2001.</i> <br><br>  Yes, your Linux system is ready for Windows 2001 if you want to install it.  ACPI has both methods and data, in contrast to the DU, which is more similar to the hardware description language.  ACPI methods continue to be active after loading.  For example, if you run the acpi_listen command (from the apcid package) and then close and open the lid of the laptop, you will see that the ACPI functionality has continued to work all this time.  Temporary and dynamic <a href="https://www.mjmwired.net/kernel/Documentation/acpi/method-customizing.txt">rewriting of ACPI tables</a> is possible, but for a permanent change you will need to interact with the BIOS menu on the boot or flashing the ROM.  Instead of such difficulties, you may simply need to <a href="https://www.coreboot.org/Supported_Motherboards">install coreboot</a> , a replacement for open source firmware. <br><br>  From start_kernel () to user space <br><br>  The code in <code><a href="">init/main.c</a></code> is surprisingly easy to read and, oddly enough, still carries the original copyright of Linus Torvalds (Linus Torvalds) from 1991-1992.  Strings found in <code>dmesg | head</code>  <code>dmesg | head</code> running system mainly originates from this source file.  The first CPU is registered by the system, global data structures are initialized, the scheduler, interrupt handlers (IRQs), timers, and the console come up one by one.  All timestamps before running <code>timekeeping_init()</code> are zero.  This part of the kernel initialization is synchronous, that is, execution occurs only in one thread.  Functions are not executed until the last one is completed and returned.  As a result, the output of <code>dmesg</code> will be fully reproducible even between two systems, as long as they have the same remote control or ACPI tables.  Linux also behaves like a real-time operating system (RTOS, real-time operating system) running on an MCU, for example, QNX or VxWorks.  This situation is stored in the <code>rest_init()</code> function, which is called by <code>start_kernel()</code> at the time of its completion. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Brief description of the early kernel boot process</i> <i><br></i> <br>  A modestly named <code>rest_init()</code> creates a new thread that starts <code>kernel_init()</code> , which in turn calls <code>do_initcalls()</code> .  Users can monitor <code>initcalls</code> by adding <code>initcalls_debug</code> to the kernel command line.  As a result, you will get the <code>dmesg</code> entity each time the <code>initcall</code> function <code>initcall</code> .  <code>initcalls</code> pass through seven consecutive levels: early, core, postcore, arch, subsys, fs, device, and late.  The most visible part of <code>initcalls</code> for users is the definition and installation of processor peripherals: buses, network, storage, displays, and so on, accompanied by the loading of their core modules.  <code>rest_init()</code> also creates a second thread in the boot processor, which starts by running <code>cpu_idle()</code> while the scheduler distributes its work. <br><br>  <code>kernel_init()</code> also sets <a href="http://free-electrons.com/pub/conferences/2014/elc/clement-smp-bring-up-on-arm-soc">symmetric multiprocessing</a> (SMP).  In modern kernels, this moment can be found in the dmesg output by the line ‚ÄúBringing up secondary CPUs ...‚Äù.  The SMP then makes the ‚Äúhot plug‚Äù of the CPU, which means that it manages its lifecycle using state machines that are conditionally similar to those used in devices like auto-detecting USB memory sticks.  The kernel power management system often turns off individual cores (core), and wakes them up as needed, so that the same hotplug CPU code is called on an unoccupied machine time after time.  Look at how the power management system calls the hotplug CPU using <a href="http://www.brendangregg.com/ebpf.html">a BCC tool</a> called <code>offcputime.py</code> . <br><br>  Notice that the code in <code>init/main.c</code> almost finished executing at the moment <code>smp_init()</code> launched.  The boot processor has completed most of the one-time initialization that other cores do not need to repeat.  However, threads must be created for each core (core) in order to manage interrupts (IRQs), workqueue, timers, and power events on each one.  For example, look at the threads of the processors that serve softirqs and workqueues with the <code>ps -o psr.</code> command <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  where the PSR field means ‚Äúprocessor‚Äù.  Each core must have its own timers and hotplug cpuhp handlers. <br><br>  And finally, how does user space run?  Toward the end, <code>kernel_init()</code> looking for an <code>initrd</code> that can start the <code>init</code> process on its behalf.  If not, the kernel itself executes <code>init</code> .  Why then may need <code>initrd</code> ? <br><br>  <i><b>Early user space: who ordered the initrd?</b></i> <br><br>  In addition to the device tree, another path to the file, optionally provided to the kernel on boot, belongs to the <code>initrd</code> .  <code>initrd</code> often located in / boot along with the bzImage vmlinuz file in x86, or with a similar uImage and device tree for ARM.  The list of <code>intrd</code> contents can be viewed using the <code>lsinitramfs</code> tool, which is part of the <code>initramfs-tools-core</code> package.  The initrd distribution image contains minimal directories <code>/bin</code> , <code>/sbin</code> and <code>/etc</code> , as well as kernel modules and files in <code>/scripts</code> .  Everything should look more or less familiar, since the <code>initrd</code> is mostly similar to the simplified Linux root file system.  This similarity is a bit deceptive, since almost all executable files in <code>/bin</code> and <code>/sbin</code> inside ramdisk are symlinks to the <a href="https://www.busybox.net/">BusyBox binary</a> , which makes the / bin and / sbin directories 10 times smaller than in <code>glibc</code> . <br><br>  Why try to create an <code>initrd</code> if the only thing it does is load some modules and run <code>init</code> in the usual root filesystem?  Consider an encrypted root filesystem.  Decryption may depend on loading the kernel module stored in the root file system <code>/lib/modules</code> ... and, as expected, in the <code>initrd</code> .  A crypto module can be statically compiled into the kernel, and not loaded from a file, but there are several reasons to refuse it.  For example, static compilation of a kernel with modules may make it too large to fit in the available storage, or static compilation may violate the terms of the software license.  Not surprisingly, storage, network, and HID (human input devices) drivers can also be presented in an <code>initrd</code> ‚Äî in fact, any code that is not an essential part of the kernel that is required to mount the root file system.  Also in the initrd, users can store <a href="https://www.mjmwired.net/kernel/Documentation/acpi/initrd_table_override.txt">their own ACPI table code</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Fun with a rescue shell and custom initrd.</i> <br><br>  <code>initrd</code> also great for testing file systems and storage devices.  Put the testing tools in the <code>initrd</code> and run the tests from memory, not from the object under test. <br><br>  Finally, when <code>init</code> running, the system is running!  Since the secondary processors are already running, the machine has become an asynchronous, paged, unpredictable, and high-performance creature that we all know and love.  Indeed, <code>ps -o pid,psr,comm -p</code> shows that the user-space <code>init</code> process is no longer running on the boot processor. <br><br>  <b>Total</b> <br><br>  The Linux boot process sounds forbidden, given the amount of affected software, even on the simplest embedded device.  On the other hand, the boot process is quite simple, since the excessive complexity caused by preemptive multitasking, RCU and race condition is absent here.  Paying attention only to the kernel and PID 1, you can lose sight of the great work done by the loaders and auxiliary processors to prepare the platform for launching the kernel.  The kernel is certainly different from other Linux programs, but using tools to work with other ELF binary files will help you better understand its structure.  Exploring a workable boot process will prepare for future failures. <br><br>  THE END <br><br>  We are waiting for your comments and question, as usual, or here, or in our <a href="https://otus.pw/499x/">open lesson</a> , where Leonid will take the rap. </div><p>Source: <a href="https://habr.com/ru/post/425505/">https://habr.com/ru/post/425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425493/index.html">Configuring MikroTik hAP mini for IPTV Beeline</a></li>
<li><a href="../425497/index.html">Tutu PHP Meetup # 2: Live Event Broadcast</a></li>
<li><a href="../425499/index.html">HyperX Impact DDR4 - SO-DIMM, which could! Or why in a laptop 64 GB of memory with a frequency of 3200 MHz?</a></li>
<li><a href="../425501/index.html">A / V tests on Android from A to Z</a></li>
<li><a href="../425503/index.html">Cassandra Sink for Spark Structured Streaming</a></li>
<li><a href="../425507/index.html">Parsim Wikipedia for NLP tasks in 4 teams</a></li>
<li><a href="../425511/index.html">Unobvious features of Rotativa for generating PDF in an ASP.NET MVC application</a></li>
<li><a href="../425513/index.html">Deputies seriously undertook the taxation of miners</a></li>
<li><a href="../425515/index.html">Apple blocks the possibility of independent repair of new MacBook models</a></li>
<li><a href="../425517/index.html">How Yandex created a global precipitation forecast using radars and satellites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>