<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make the game run at 60fps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine the task: you have a game, and you need it to work at 60 fps on a 60 Hz monitor. Your computer is fast enough for rendering and updating to ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make the game run at 60fps</h1><div class="post__text post__text-html js-mediator-article">  Imagine the task: you have a game, and you need it to work at 60 fps on a 60 Hz monitor.  Your computer is fast enough for rendering and updating to take an insignificant amount of time, so you turn on vsync and write this game cycle: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Very simple!  Now the game works with 60fps and everything goes like clockwork.  Is done.  Thank you for reading this post. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Well, obviously, that is not so good.  What if someone has a weak computer that cannot render the game with enough speed to ensure 60fps?  What if someone bought one of those cool new 144 Hz monitors?  What if it is disabled in the vsync driver settings? <br><a name="habracut"></a><br>  You might think: I need somewhere to measure time and provide an update with the correct frequency.  It is quite simple to do this - it is enough to accumulate time in each cycle and perform an update every time it exceeds the threshold of 1/60 second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Done, nowhere easier.  In fact, there are a lot of games in which the code essentially looks that way.  But it's not right.  This is suitable for adjusting timings, but leads to problems with stuttering and other mismatches.  Such a problem is very often encountered: frames are displayed not exactly 1/60 of a second;  even when vsync is turned on, there is always a slight noise in the time of their display (and exactly the OS timer).  Therefore, there will be situations when you render a frame, and the game believes that the time for the re-update has not come yet (because the battery is late for a tiny share), so it simply repeats the same frame again, but now the game is late for the frame, therefore it performs a double update.  Here and twitching! <br><br>  Googling, you can find a few ready-made solutions to eliminate this twitching.  For example, a game can use a variable, rather than a constant time step, and just completely abandon the batteries in the timing code.  Or you can implement a constant time step with the interpolating renderer, described in Glenn <a href="https://gafferongames.com/post/fix_your_timestep/" rel="nofollow noopener">Fieder‚Äôs</a> rather famous article ‚Äú <a href="https://gafferongames.com/post/fix_your_timestep/" rel="nofollow noopener">Fix Your Timestep</a> ‚Äù.  Or you can remake the timer code so that it is a bit more flexible, as described in the post " <a href="http://www.slickentertainment.com/2016/06/" rel="nofollow noopener">Frame Timing Issues</a> " by Slick Entertainment (unfortunately, this blog is no longer there). <br><br><hr><br><h3>  Fuzzy timings </h3><br>  The Slick Entertainment method with ‚Äúfuzzy timings‚Äù in my engine was the easiest to implement, because it did not require changes in the logic of the game and rendering.  So in <a href="https://store.steampowered.com/app/583470/The_End_Is_Nigh/" rel="nofollow noopener">The End is Nigh,</a> I used it.  It was enough just to insert it into the engine.  In fact, it simply allows the game to update "a little earlier," to avoid problems with timing mismatch.  If vsync is turned on in the game, it simply allows you to use vsync as the main timer, and provides a smooth picture. <br><br>  This is how the update code looks now (the game ‚Äúcan work‚Äù at 62 fps, but it still processes each time step as if it works at 60fps. I don‚Äôt quite understand why limit it so that the battery values ‚Äã‚Äãdo not fall below 0, but without This code does not work).  You can interpret it like this: ‚Äúthe game is updated with a fixed step, if rendered in the interval from 60fps to 62fps‚Äù: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  If vsync is turned on, then it essentially allows the game to work with a fixed pitch, which coincides with the monitor refresh rate, and provides a smooth picture.  The main problem here is that when vsync is disabled, the game will run a <i>little</i> faster, but the difference is so insignificant that no one will notice it. <br><br>  Speedrunners.  Speedrunners will notice.  Soon after the release of the game, they noticed that some people in the speed-run record lists had a worse time, but by calculation it turned out to be better than others.  And the immediate cause of this was the lack of timings and disabling vsync in the game (or 144 Hz monitors).  Therefore, it became obvious that you need to turn off this fuzziness when disabling vsync. <br><br>  Oh, but we can't check whether vsync is disabled.  In the OS, there are no calls for this, and although we can request from the application to enable or disable vsync, in fact it depends entirely on the OS and the graphics driver.  The only thing you can do is to render a bunch of frames, try to measure the time it takes to complete this task, and then compare whether they take approximately the same time.  That's what I did for <a href="https://store.steampowered.com/app/583470/The_End_Is_Nigh/" rel="nofollow noopener">The End is Nigh</a> .  If the game does not include vsync with a frequency of 60 Hz, then it rolls back to the original frame timer with ‚Äústrict 60 fps‚Äù.  In addition, I added a parameter to the configuration file that forces the game not to use fuzziness (mainly for speedrunners who need exact time) and added an accurate handler for the in-game timer for them, which allows using autosplitter (this is a script that works with the atomic time timer). <br><br>  Some users still complained about the occasional jerking of individual frames, but they seemed so rare that they could be explained by OS events or other external causes.  Nothing really scary.  Right? <br><br>  Looking through my recent timer code, I noticed something strange.  The battery shifted, each frame took a little longer than 1/60 of a second, so the game periodically thought that it was late for the frame and performed a double update.  It turned out that my monitor runs at 59.94 Hz, not 60 Hz.  This meant that every 1000 frames he had to perform a double update in order to ‚Äúcatch up‚Äù.  However, it is very easy to fix - it is enough to change the interval of allowable frame rates (not from 60 to 62, but from 59 to 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  The problem described above with disabled vsync and high-frequency monitors still persists, and the same solution applies (rollback to the strict timer if the monitor is <i>not</i> synchronized vsync to 60). <br><br>  But how do you know if this is the right solution?  How to make sure that it will work correctly on all combinations of computers with different types of monitors, with vsync disabled and enabled, and so on?  It is very difficult to monitor all these timer problems in the head, and to understand what causes out of sync, strange cycles and the like. <br><br><h3>  Monitor simulator </h3><br>  Trying to come up with a reliable solution to the ‚Äúproblem of the 59.94 Hertz monitor‚Äù, I realized that I could not simply carry out tests and tests, hoping to find a reliable solution.  I needed a convenient way to test different attempts at writing a quality timer and a simple way to check if it caused a twitch or a time shift in different monitor configurations. <br><br>  <a href="https://github.com/TylerGlaiel/MonitorSim" rel="nofollow noopener">Monitor Simulator</a> appears on the scene.  This is a ‚Äúdirty and fast‚Äù code written by me, simulating ‚Äúmonitor operation‚Äù, and in fact outputting to me a bunch of numbers that give an idea of ‚Äã‚Äãthe stability of each timer being tested. <br><br>  For example, for the simplest timer, the following values ‚Äã‚Äãare displayed from the beginning of the article: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  First, the code displays for each vsync emulated number of the number of "updates" of the game cycle after the previous vsync.  Any values ‚Äã‚Äãother than solid 1 result in a jerky picture.  At the end of the code displays the accumulated statistics. <br><br>  When using a ‚Äúfuzzy timer‚Äù (with an interval of 60‚Äì62fps) on a 59.94 Hertz monitor, the code displays the following: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  The frame jerking occurs very rarely, so it can be difficult to notice with so many 1. But the output statistics clearly show that the game has performed several double updates here, which leads to jerking.  In the revised version (with an interval of 59‚Äì61 fps), there are 0 missing or double updates. <br><br>  You can also disable vsync.  The remaining statistics become unimportant, but it clearly shows me the value of the ‚Äútime shift‚Äù (the system time shift relative to where the game time should be). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  That is why, with vsync disabled, you need to switch to a strict timer, otherwise these discrepancies accumulate over time. <br><br>  If I assign the rendering time a value of .02 (i.e., for rendering, I need ‚Äúmore than a frame‚Äù), then again I get a twitch.  Ideally, the game pattern should look like 202020202020, but it is a bit uneven. <br><br>  In this situation, this timer behaves a little better than the previous one, but it becomes more and more complicated and harder to figure out how and why it works.  But I can just shove the tests into this simulator and check how they behave, and you can understand the reasons later.  Samples and errors, baby! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>‚Äì<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  You can download <a href="https://github.com/TylerGlaiel/MonitorSim" rel="nofollow noopener">a monitor simulator</a> and independently check various methods for counting timings.  <a href="https://twitter.com/TylerGlaiel" rel="nofollow noopener">Email me</a> if you find something better. <br><br>  I am not 100% satisfied with my decision (it still requires a ‚Äúvsync recognition‚Äù hack and there may be some twitching when out of sync), but I think it is almost as good as trying to implement a game cycle with a fixed pitch.  Part of this problem arises because it is very difficult to determine the parameters of what is considered ‚Äúacceptable‚Äù here.  The main difficulty lies in the trade-off between the time shift and double / missing frames.  If you run a 60 Hz game on a 50 Hz PAL monitor ... what would be the right decision?  Do you want wild jerking, or noticeably slower game play?  Both options seem bad. <br><br><h3>  Separated rendering </h3><br>  In the previous methods I described what I call ‚Äúfixed-step rendering‚Äù (lockstep rendering).  The game updates its state, then renders, and when rendering, it always displays the most recent state of the game.  Rendering and updating are connected together. <br><br>  But you can separate them.  This is exactly what the method described in the post " <a href="https://gafferongames.com/post/fix_your_timestep/" rel="nofollow noopener">Fix Your Timestep</a> " <a href="https://gafferongames.com/post/fix_your_timestep/" rel="nofollow noopener">does</a> .  I will not repeat, you definitely should re-read this post.  This is (as I understand it) the ‚Äúindustry standard‚Äù used in AAA games and engines such as Unity and Unreal (however, in intense active 2D games, they usually prefer to use a fixed pitch (lockstep), because sometimes the accuracy that this method). <br><br>  But if we briefly describe Glenn's post, then it simply describes the update method with a fixed frame rate, but the rendering interpolates between the ‚Äúcurrent‚Äù and ‚Äúprevious‚Äù game state, and the current battery value is used as the interpolation value.  With this method, you can render with any frame rate and update the game with any frequency, and the picture will always be smooth.  No twitching, works universally. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  So, elementary.  Problem solved. <br><br>  Now you just need to do so that the game could render the interpolated states ... but wait, in fact, this is not at all easy.  In Glenn's post, it is simply assumed that this can be done.  It is easy enough to cache the previous position of the game object and interpolate its movements, but the state of the game includes much more than anything else.  It is necessary to take into account in it the state of animation, the creation and destruction of objects, and a whole lot more. <br><br>  Plus, in the logic of the game, it is necessary to take into account whether the object is teleported or should be smoothly moved so that the interpolator does not make false assumptions about the path made by the game object to its current position.  This chaos can occur with turns, especially if in one frame the rotation of an object can change more than 180 degrees.  And how to handle the created and destroyed objects? <br><br>  At the moment I'm just working on this task in my engine.  In fact, I just interpolate the movements, and leave everything else as it is.  You will not notice jerking if the object does not move smoothly, so skipping animation frames and desynchronizing the creation / destruction of an object down to one frame will not become a problem if everything else is done smoothly. <br><br>  However, it is strange that, in essence, this method renders the game in a state that is late by 1 state of the game from where the simulation is now located.  This is imperceptible, but it can connect with other sources of delays, for example, input delay and monitor refresh rate, so those who need the most responsive gameplay (I'm talking about you, speedrunners) are likely to prefer to use lockstep in the game. <br><br>  In my engine, I just give a choice.  If you have a 60 Hz monitor and a fast computer, then it is best to use lockstep with vsync enabled.  If the monitor has a non-standard refresh rate, or your weak computer cannot constantly render 60 frames per second, then turn on frame interpolation.  I want to call this option ‚Äúunlock framerate‚Äù (‚Äúunlock frame rate‚Äù), but people might think that it simply means ‚Äúturn on this option if you have a good computer‚Äù.  However, this problem can be solved later. <br><br>  In fact, <i>there is a</i> method to work around this problem. <br><br><h3>  Updates with variable time steps </h3><br>  Many people asked me why not just update the game with a variable time step, and theorists often say: ‚Äúif the game is written RIGHT, then you can just update it with an arbitrary time step‚Äù. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  No oddities with timings.  No strange interpolation rendering.  It's simple, everything works. <br><br>  So, elementary.  Problem solved.  And now forever!  The best result is impossible to achieve! <br><br>  Now it is enough just to make the game logic work with an arbitrary time step.  It's simple, just replace all the code: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  on this: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  and replace the following code: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  on this: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  and replace the following code: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  on this: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... well, wait a minute <br><br>  Where does all this come from? <br><br>  The last part is literally copied from the auxiliary code of my engine, which performs ‚Äúreally correct, independent of frame rate movement with friction limiting speed‚Äù.  There is a little rubbish in it (these multiplications and divisions by 60).  But this is the ‚Äúcorrect‚Äù version of the code with a variable time step for the previous fragment.  I calculated it for more than an hour with the help of <a href="https://www.wolframalpha.com/" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Now they may ask me why not do this: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  And although it seems to work, in fact, so wrong.  You can check it yourself.  Perform two updates with deltaTime = 1, then perform one update with deltaTime = 2, and the results will be different.  Usually we want the game to work in concert, so such discrepancies are not welcome.  This is probably a fairly good solution if you know for sure that deltaTime is always approximately equal to one value, but then you need to write code that ensures updates are performed at some constant frequency and ... yes.  True, now we are trying to do everything "CORRECT". <br><br>  If such a tiny piece of code unfolds into monstrous mathematical calculations, then imagine more complex patterns of motion, in which many interacting objects participate, and so on.  Now you can clearly see that the "correct" solution is unrealizable.  The maximum that we can achieve is a ‚Äúrough approximation‚Äù.  Let's forget about it for now, and let's say that we really have a ‚Äúreally correct‚Äù version of the motion functions.  Great, right? <br><br>  Actually, no.  Here is a real example of the problem that I had with this in <a href="https://store.steampowered.com/app/246920/Bombernauts/" rel="nofollow noopener">Bombernauts</a> .  A player can jump about 1 tile, and the game takes place in a grid of blocks into 1 tile.  To land on the block, the character‚Äôs feet must rise above the top surface of the block. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  But since collision detection is performed here in discrete steps, if the game works with a low frame rate, sometimes the legs will not reach the surface of the tile, even though they follow the same motion curve, and instead of lifting the player will slide off the wall. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Obviously, this problem is solved.  But it illustrates the kinds of problems that we encounter when trying to properly implement the work of the game cycle with a variable time step.  We lose coherence and determinism, so we have to get rid of the replay functions of the game by recording the player‚Äôs input, deterministic multiplayer and the like.  For reflex-based fast 2D games, consistency is extremely important (and hello to speedrunners again). <br><br>  If you try to adjust the time steps so that they are neither too large nor too small, then lose the main advantage gained from the variable time step, and you can safely use the other two methods described here.  The game will not be worth the candle.  Too much extra effort will be invested in the game logic (implementation of the correct mathematics of motion), and it will take too many victims in the field of determinacy and consistency.  I would use this method only for a musical rhythm game (in which the equations of motion are simple and maximum responsiveness and smoothness are required).  In all other cases, I will choose a fixed update. <br><br><hr><br><h3>  Conclusion </h3><br>  Now you know how to make the game run at a constant frequency of 60fps.  This is trivially simple, and no one else should have problems with it.  There are <a href="https://habr.com/ru/post/419043/">no other problems</a> complicating this task. </div><p>Source: <a href="https://habr.com/ru/post/442528/">https://habr.com/ru/post/442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442516/index.html">A guide to using pandas for analyzing large data sets.</a></li>
<li><a href="../442520/index.html">Case Saving 300,000 p. per month on contextual advertising</a></li>
<li><a href="../442522/index.html">Intuitive RL (Reinforcement Learning): An Introduction to Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../442524/index.html">How to increase security in personal identification and access control systems</a></li>
<li><a href="../442526/index.html">The history of Soviet cassette players (part two): Walkman boom, gadget for the KGB and tape recorders</a></li>
<li><a href="../442530/index.html">Wireshark 3.0.0: review of innovations</a></li>
<li><a href="../442532/index.html">Video recorders for video surveillance - for free</a></li>
<li><a href="../442536/index.html">Connect external mailboxes to Zimbra</a></li>
<li><a href="../442540/index.html">March 14, Tesla Inc will show a new electric car</a></li>
<li><a href="../442542/index.html">SmartMail Conf: the first conference of Mail.ru Mail on machine learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>