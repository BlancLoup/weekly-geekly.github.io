<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java shared memory and off-heap caching</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last week, a successful experiment was launched to launch a new solution for download service. One fairly modest server (2 x Intel Xeon E5620, 64 GB R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java shared memory and off-heap caching</h1><div class="post__text post__text-html js-mediator-article">  Last week, a successful experiment was launched to launch a new solution for download service.  One fairly modest server (2 x Intel Xeon E5620, 64 GB RAM) running a proprietary Java application took over eight Tomcat loads, serving more than 70,000 HTTP requests per second with a total bandwidth of 3000 Mb / s.  Thus, all Odnoklassniki traffic associated with user emoticons was processed by one server. <br><br>  It is quite natural that high loads required non-standard solutions.  In a series of articles on the development of high-load Java server, I will talk about the problems we had to face and how we overcame them.  Today we will talk about caching images outside the Java Heap and using Shared Memory in Java. <br><a name="habracut"></a><br><br><h4>  Caching </h4><br>  Since drawing images for each request from the storage is not an option, and there is no question of storing pictures on the disk (the disk queue will become a server bottleneck much earlier), you must have a fast cache in the application's memory. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The cache requirements were as follows: <br><ul><li>  <b>64-bit keys, byte array values:</b> image identifier - an integer of type long, and data - a picture in PNG, GIF or JPG format with an average size of 4 KB; </li><li>  <b>In-process, in-memory:</b> for maximum access speed, all data is in the process memory; </li><li>  <b>RAM utilization:</b> all available RAM is allocated to the cache; </li><li>  <b>Off-heap:</b> 50 GB of data placed in the Java Heap would be problematic; </li><li>  <b>LRU or FIFO:</b> obsolete keys may be supplanted by newer ones; </li><li>  <b>Concurrency:</b> simultaneous use of cache in a hundred threads; </li><li>  <b>Persistence: the</b> application can be restarted while preserving already cached data. </li></ul><br>  The fastest way to access memory outside of Heap from Java is through the <code>sun.misc.Unsafe</code> class, since  its <code>getLong/putLong</code> methods are JVM intrinsics, that is, their calls are replaced by the JIT compiler into just one machine instruction.  Cache persistence between application launches is achieved using <nobr><a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2584%25D0%25B0%25D0%25B9%25D0%25BB%25D0%25B0_%25D0%25BD%25D0%25B0_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">memory-mapped files</a></nobr> .  However, it was extremely undesirable to associate the cache with a real file on the disk (performance would be badly affected by disk access), so the application‚Äôs address space displays not a real file, but a <nobr><a href="http://en.wikipedia.org/wiki/Shared_memory">shared memory</a></nobr> object.  In this case, of course, the cache will no longer be non-volatile, but, most importantly, will allow you to restart the application without losing data. <br><br><h4>  Shared memory </h4><br>  In Linux, Shared Memory objects are implemented using a special file system mounted to <code>/dev/shm</code> .  So, for example, the POSIX function <code>shm_open("name", ...)</code> equivalent to the <code>open("/dev/shm/name", ...)</code> system call.  Thus, in Java we can work with Linux shared memory as with ordinary files.  The following code snippet will open a shared memory object named image-cache with a size of 1 GB.  If an object with the same name does not exist, a new one will be created.  It is important that after the completion of the application the object will remain in memory and will be available the next time it is launched. <br><br><pre> <code class="java hljs"> RandomAccessFile f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RandomAccessFile(<span class="hljs-string"><span class="hljs-string">"/dev/shm/image-cache"</span></span>, <span class="hljs-string"><span class="hljs-string">"rw"</span></span>); f.setLength(<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024L</span></span>);</code> </pre><br>  Now the created file object should be mapped into the address space of the process and get the address of this memory location. <br><br><h4>  Method 1. Legal, but defective </h4><br>  Let's use the Java NIO API: <br><br><pre> <code class="java hljs"> RandomAccessFile f = ... MappedByteBuffer buffer = f.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, f.length());</code> </pre><br>  The main disadvantage of this method is that it is impossible to display files larger than 2 GB, as described in the Javadoc to the map:  <font color="#4D7386">must be non-negative and no greater than Integer.MAX_VALUE.</font> <br><br>  You can work with the received memory section either using standard ByteBuffer methods or directly through Unsafe, by pulling out the memory address using Reflection: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getByteBufferAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Field f = Buffer.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"address"</span></span>); f.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.getLong(buffer); }</code> </pre><br>  Such a MappedByteBuffer <a href="http://bugs.sun.com/view_bug.do%3Fbug_id%3D4724038">does not have a</a> publicly available unmap method, however there is a semi-legal way to free memory without calling GC: <br><br><pre> <code class="java hljs"> ((sun.nio.ch.DirectBuffer) buffer).cleaner().clean();</code> </pre><br><br><h4>  Method 2. Completely in Java, but using "secret knowledge" </h4><br>  In Oracle JDK, there is a class <code>sun.nio.ch.FileChannelImpl</code> with private methods <code>map0</code> and <code>unmap0</code> , which are not limited to 2 GB.  <code>map0</code> directly returns the address of the ‚Äújammed‚Äù section, which is even more convenient for us if we use Unsafe. <br><br><pre> <code class="java hljs"> Method map0 = FileChannelImpl.class.getDeclaredMethod( <span class="hljs-string"><span class="hljs-string">"map0"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class); map0.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> addr = (Long) map0.invoke(f.getChannel(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0L</span></span>, f.length()); Method unmap0 = FileChannelImpl.class.getDeclaredMethod( <span class="hljs-string"><span class="hljs-string">"unmap0"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class); unmap0.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); unmap0.invoke(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, addr, length);</code> </pre><br>  Such a mechanism will work both in Linux and under Windows.  Its only drawback is the lack of a possibility to select a specific address where the file will be ‚Äúzamaplen‚Äù.  This may be necessary if there are absolute references to memory addresses inside the same cache in the cache: such links will become invalid if you display the file at a different address.  There are two ways out: either keep relative references as an offset from the beginning of the file, or resort to calling the native code via JNI or JNA.  The <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html">mmap</a> system calls in Linux and <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366763(v%3Dvs.85).aspx">MapViewOfFileEx</a> in Windows allow you to specify a preferred address where to file a file. <br><br><h4>  Caching algorithm </h4><br>  The key to cache performance, and the download server as a whole, is the cache search algorithm, i.e.  <code>get</code> method  The <code>put</code> method in our script is called much less often, but it should not be too slow either.  I want to present our solution for fast thread-safe FIFO cache in a continuous fixed-size memory area. <br><br>  All memory is divided into segments of the same size - a basket of hash tables, over which keys are evenly distributed.  In its simplest form <br><br><pre> <code class="java hljs"> Segment s = segments[key % segments.length];</code> </pre><br><img src="https://habrastorage.org/storage2/525/431/a85/525431a85a5ed7196be002eb5f266412.png"><br><br>  Segments may be many - a few thousand.  Each of them is mapped to <code>ReadWriteLock</code> .  Simultaneously with the segment can work either an unlimited number of readers, or only one writer. <br><br>  An interesting detail: the use of standard <code>ReentrantReadWriteLock'</code> led to a loss of 2 GB in the Java Heap.  As it turned out, there is an <a href="http://bugs.sun.com/bugdatabase/view_bug.do%3Fbug_id%3D6625723">error</a> in JDK 6 that leads to excessive memory consumption by the <code>ThreadLocal</code> tables in the implementation of <code>ReentrantReadWriteLock</code> .  Although the JDK 7 bug has already been fixed, in our case we replaced the voracious <code>Lock</code> with <code>Semaphore</code> .  By the way, here's a little exercise for you: <br>  <font color="#4D7386">How to implement ReadWriteLock with Semaphore?</font> <br><br>  So the segment.  It consists of an index area and a data area.  An index is an ordered array of 256 keys, immediately followed by an array of 256 references to values.  The link sets the offset inside the segment to the beginning of the data block and the length of this block in bytes. <br><br><img src="https://habrastorage.org/storage2/629/d4d/059/629d4d059ac9293d4a1a76d2c19c92b8.png"><br><br>  The data blocks, that is, the actual images themselves, are aligned along an eight-byte boundary for optimal copying.  The segment also stores the number of keys in it and the address of the next data block for the <code>put</code> method.  New blocks are written one after another according to the circular buffer principle.  As soon as the place in the segment ends, the recording starts from the beginning of the segment over the earlier data. <br><br>  The getter algorithm is extremely fast and simple: <br><ol><li>  the key hash calculates the segment in which the search will be performed; </li><li>  in the index area, a key is searched for by a binary search; </li><li>  if the key is found, from the array of links the offset is obtained, along which the data are located. </li></ol><br>  The keys are written for a reason in a row in one selected area: this contributes to placing the index in the processor cache, ensuring the maximum speed of the binary key search. <br><br>  The <b>put</b> method is also simple: <br><ol><li>  the key hash calculates the segment; </li><li>  reads the address of the next block of data and calculates the address of the next block by adding the size of the object being written, taking into account the alignment; </li><li>  if the segment is full, a linear search on the array of links will find and delete from the index the keys whose data will be overwritten by the next block; </li><li>  the value represented by the byte array is copied to the data area; </li><li>  binary search is a place in the index where the new key is inserted. </li></ol><br><br><h4>  Work speed </h4><br>  Of course, besides ours, there are a number of other solutions for caching data outside of the Java Heap, both free and paid.  Of the most famous are <nobr><a href="http://ehcache.org/">Terracota Ehcache</a></nobr> (with in-memory off-heap storage) and <a href="http://commons.apache.org/jcs/">Apache Java Caching System</a> .  It is with them that we compared our own algorithm.  The experiments were conducted on Linux JDK 7u4 64-bit and consisted of three scenarios: <br><ul><li>  <b>put:</b> write 1 million values ‚Äã‚Äãin size from 0 to 8 KB each; </li><li>  <b>get:</b> search by key 1 million values; </li><li>  <b>90% get + 10% put:</b> combining get / put in a ratio that is close to the practical cache usage scenario. </li></ul><br>  The results of measurements are shown in the table.  As you can see, both Ehcache and JCS are several times inferior in performance to the described algorithm. <br><br><img src="https://habrastorage.org/storage2/913/ba7/d4c/913ba7d4c6086a0d3e92143ec3b3c41c.png"><br><br>  However, it is worth noting that the described algorithm, being designed to solve the problem of image caching, does not cover many other scenarios.  For example, the <code>remove</code> and <code>replace</code> operations, although they can be easily implemented, will not free memory occupied by the same values. <br><br><h4>  Where to look? </h4><br>  Sources of the caching algorithm using Shared Memory on github: <br>  <a href="https://github.com/odnoklassniki/shared-memory-cache">https://github.com/odnoklassniki/shared-memory-cache</a> <br><br><h4>  Where to listen? </h4><br>  At the <a href="http://jug.ru/">JUG.RU</a> meeting in St. Petersburg, which will take place on July 25, 2012, <a href="https://habrahabr.ru/users/apangin/" class="user_link">apangin</a> will share the experience of developing a high-load Java server, will talk about typical problems and unconventional techniques. <br><br><h4>  What's next? </h4><br>  In the following articles, I will tell you how to write an <a href="http://ru.wikipedia.org/wiki/Remote_Procedure_Call">RPC</a> server that processes tens of thousands of requests per second, and I will also talk about an alternative serialization method that is several times higher than the standard Java mechanisms in performance and traffic volume.  Stay with us! </div><p>Source: <a href="https://habr.com/ru/post/148139/">https://habr.com/ru/post/148139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148134/index.html">OOP. Unhurried conversation near the cooler</a></li>
<li><a href="../148135/index.html">Man: evolution of technology or technology of evolution?</a></li>
<li><a href="../148136/index.html">Practice ITIL for a small company. Change management</a></li>
<li><a href="../148137/index.html">UCS2 or UCS4? - pyodbc and work with utf16 data in MSSQL</a></li>
<li><a href="../148138/index.html">Time sinks and the fight against them</a></li>
<li><a href="../148140/index.html">Substitution of XMLHttpRequest or not touching the tons of ready-made js-code to change the behavior of all ajax requests</a></li>
<li><a href="../148142/index.html">Android stopwatch with Python + sl4a + fullScreenUI</a></li>
<li><a href="../148144/index.html">Load balancing on PPTP / L2TP MPD5 servers</a></li>
<li><a href="../148151/index.html">SQL injection for beginners. Part 1</a></li>
<li><a href="../148155/index.html">Queryfeed - RSS feeds from Twitter and Facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>