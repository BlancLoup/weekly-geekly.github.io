<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QEMU.js: now in earnest and with WASM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time I decided, for the sake of laughter, to prove the reversibility of the process and learn how to generate JavaScript (or rather, Asm.j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QEMU.js: now in earnest and with WASM</h1><div class="post__text post__text-html js-mediator-article"><p>  Once upon a time I decided, for the sake of laughter, to <em>prove the reversibility of the process</em> and learn how to generate JavaScript (or rather, Asm.js) from machine code.  QEMU was chosen for the experiment, some time later an article was written on Habr.  In the comments, I was advised to redo the project on WebAssembly, and I myself didn‚Äôt want to throw the <em>almost finished</em> project myself ... The work was going, but very slowly, and now, recently in that article a <a href="https://habr.com/ru/post/315770/">comment</a> appeared on the topic "So how did it all end?".  In my detailed response, I heard "It pulls on the article."  Well, since pulls, there will be an article.  Maybe someone will come in handy.  From it, the reader will learn some facts about the QEMU code generation device backend, as well as how to write the Just-in-Time compiler for the web application. </p><a name="habracut"></a><br><h2 id="zadachi">  Tasks </h2><br><p>  Since I had already learned how to port QEMU to JavaScript somehow, this time it was decided to do it according to the mind and not repeat old mistakes. </p><br><h3 id="oshibka-nomer-raz-otvetvitsya-ot-point-release">  Error number one: tap off point release </h3><br><p> My first mistake was to branch off my version from upstream version 2.4.1.  Then it seemed to me a good idea: if point release exists, then it is probably more stable than the simple 2.4, and even more so the <code>master</code> branch.  And since I planned to add a fair amount of my bugs, I didn‚Äôt need strangers at all.  So it probably happened.  But bad luck: QEMU does not stand still, and at some point there even announced optimization of the generated code by 10 percent. "Yeah, I'm dead now," I thought <del>  and broken off </del>  .  Here we must digress: due to the single-threaded nature of QEMU.js and the fact that the original QEMU does not imply the absence of multithreading (that is, the possibility of simultaneous operation of several unrelated code paths, and not just ‚Äúzayuzat all cores‚Äù is critical), the main stream functions had to "turn out" to be able to call outside.  This created some natural problems with the merger.  However, the fact that some of the changes from the <code>master</code> branch, with which I tried to merge my code, were also cherry picked in point release (and, therefore, in my branch) too, probably would not have added convenience. </p><br><p>  In general, I decided that a prototype still makes sense. <del>  throw out </del>  disassemble for parts and build a new version from scratch on the basis of something fresher and now from the <code>master</code> . </p><br><h3 id="oshibka-nomer-dva-tlp-metodologiya">  Mistake number two: TLP methodology </h3><br><p>  In essence, this is not a mistake, in general - just a feature of creating a project in conditions of complete misunderstanding as ‚Äúwhere and how to move?‚Äù, And in general ‚Äúwill we get there?‚Äù.  Under these conditions, <em>tyap-bloop programming</em> was a viable option, but, naturally, I didn‚Äôt want to repeat it at all unnecessarily.  This time I wanted to do it according to my mind: atomic commits, deliberate code changes (rather than ‚Äústringing random characters together until it compiles (with warnings)‚Äù, as Linus Torvalds once said about someone, if you believe Wikisitnik), etc. </p><br><h3 id="oshibka-nomer-tri-ne-znaya-brodu-lezt-v-vodu">  Mistake number three: not knowing ford climb into the water </h3><br><p>  I didn‚Äôt get rid of this even now, but now I decided to go not along the path of the least resistance, and make it ‚Äúadult‚Äù, namely, write my TCG backend from scratch, so as not to say ‚ÄúYes, this, Of course, slowly, but I can‚Äôt control everything - TCI is so written ... ".  Besides, initially it seemed like an obvious solution, since <em>I am generating the binary code</em> .  As the saying goes, ‚ÄúGent <strong>y</strong> assembled, yes not that‚Äù: the code, of course, is binary, but the control cannot simply be transferred to it - it must be explicitly shoved into the browser for compilation, resulting in some object from the JS world, which still need to save somewhere.  However, on <del>  normal </del>  RISC architectures, as I understand it, a typical situation is the need to explicitly reset the instruction cache for the regenerated code ‚Äî if this is not what we need, then, in any case, it‚Äôs close.  In addition, from my last attempt, I learned that the control in the middle of the translation unit does not seem to be transferred, so we don‚Äôt really need the bytecode interpreted from any offset, and we can simply generate a function on TB. </p><br><h2 id="prishli-i-pnuli">  Came and kicked </h2><br><p>  Although I started rewriting the code back in July, the magic Pendel sneaked up unnoticed: usually letters from GitHub come as notifications about replies to Issues and Pull requests, and here, <em>suddenly the</em> mention in the thread <a href="https://github.com/WebAssembly/binaryen/issues/1494">Binaryen as a qemu backend</a> in context, ‚ÄúHere it is‚Äî he did something like that, maybe he would say something. ‚Äù  It was about using the related Emscripten <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> library to create a WASM JIT.  Well, I said that you have an Apache 2.0 license there, and QEMU as a whole is distributed under GPLv2, and they are not very compatible.  Suddenly it turned out that the license can be <em>somehow corrected</em> (I don‚Äôt know: maybe, change, maybe double licensing, maybe something else ...).  This, of course, made me happy, because by that time I had already looked closely at the WebAssembly <a href="http://webassembly.github.io/spec/core/binary/index.html">binary format</a> , and I was somehow sad and incomprehensible.  There was also a library, which would devour base blocks with a transition graph, and issue a baytkod, and even launch it itself in the interpreter, if necessary. </p><br><p>  Then there was another <a href="https://marc.info/%3Fl%3Dqemu-devel%26m%3D154688067607265%26w%3D2">letter</a> on the QEMU mailing list, but this is more likely to the question, ‚ÄúAnd who needs it at all?‚Äù.  And it <strong>suddenly</strong> turned out to be necessary.  At a minimum, it is possible to scrape together such possibilities of use, if it works more or less quickly: </p><br><ul><li>  launching something tutorial without installation at all </li><li>  Virtualization on iOS, where, according to rumors, the only application eligible for code generation on the fly is the JS engine (is it true?) </li><li>  demonstration of mini-OS - single-disk, built-in, all sorts of firmware, etc ... </li></ul><br><h2 id="osobennosti-brauzernoy-sredy-vypolneniya">  Browser runtime features </h2><br><p>  As I said, QEMU is tied to multithreading, but not in the browser.  Well, that is, how not ... At first, it was not there at all, then WebWorkers appeared - as far as I understand, this is multithreading, based on the transfer of messages <strong>without</strong> mutually <strong>variable variables</strong> .  Naturally, this creates significant problems when porting existing code based on a shared memory model.  Then, under public pressure, it was implemented and it was called <code>SharedArrayBuffers</code> .  It was gradually introduced, celebrated its launch in different browsers, then they celebrated the new year, and then Meltdown ... Then they came to the conclusion that you don‚Äôt blush ‚Äî don‚Äôt blush the time dimension, but with the help of a shared memory and a counter incrementing flow, you‚Äôll still <a href="https://security.stackexchange.com/questions/177033/how-can-sharedarraybuffer-be-used-for-timing-attacks">get pretty sure</a> .  So disconnected multithreading with shared memory.  It seems that it was later turned back on, but as it became clear from the first experiment, there is life without it, and if so, we will try to do it without laying down on multithreading. </p><br><p>  The second feature is the impossibility of low-level manipulations with the stack: you can not just take, save the current context and switch to a new one with a new stack.  The call stack is managed by the JS virtual machine.  It would seem, what's the problem, since we still decided to manage the former threads completely manually?  The fact is that block I / O in QEMU is implemented through cortinas, and here low-level stack manipulations would be useful to us.  Fortunately, Emscipten already contains a mechanism for asynchronous operations, even two: <a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a> and <a href="https://emscripten.org/docs/porting/emterpreter.html">Emterpreter</a> .  The first works through a significant swelling of the generated JavaScript code and is no longer supported.  The second is the current "correct way" and works through the generation of bytecode for its own interpreter.  It works, of course, slowly, but it does not inflate the code.  True, the support for corutin for this mechanism had to be contributed independently (there were already corortines written under Asyncify and there was an implementation of approximately the same API for Emterpreter, it was just necessary to connect them). </p><br><p>  At the moment, I have not yet had time to divide the code into WASM compiled and interpreted using Emterpreter, so block devices are not working yet (see the next series, as they say ...).  That is, in the end, you should get this funny layered something: </p><br><ul><li>  interpretable block I / O.  Well, what do you really expect emulated NVMe with native performance?  :) </li><li>  statically compiled QEMU master code (translator, other emulated devices, etc.) </li><li>  dynamically compiled guest code in WASM </li></ul><br><h2 id="osobennosti-ishodnikov-qemu">  QEMU source features </h2><br><p>  As you probably already guessed, the emulation code of guest architectures and the code for generating host machine instructions from QEMU are separate.  In fact, there is even a little more cunning: </p><br><ul><li>  there are guest architectures </li><li>  There are <em>accelerators</em> , namely, KVM for hardware virtualization on Linux (for compatible guest and host systems), TCG for JIT code generation anywhere.  Starting with QEMU 2.9, support for the HAXM hardware virtualization standard on Windows has appeared ( <a href="https://wiki.qemu.org/Hosts/W32">details</a> ) </li><li>  if TCG is used, and not hardware virtualization, then it has separate support for code generation for each host architecture, as well as a universal interpreter </li><li>  ... and around it all - emulated peripherals, user interface, migration, record-replay, etc. </li></ul><br><p>  <em>By the way, did you know:</em> QEMU can emulate not only a computer as a whole, but also a processor for a separate user process in a host core, which is used, for example, by an AFL fuser for the instrumentation of binaries.  Perhaps someone wants to port this QEMU mode of operation to JS?  ;) </p><br><p>  Like most long-standing free software, QEMU is built via <code>configure</code> and <code>make</code> .  Suppose you decide to add something: TCG-backend, implementation of threads, something else.  Do not be in a hurry to rejoice / be horrified (underline the necessary) the perspective of communication with Autoconf - in fact, QEMU's <code>configure</code> seems to be self-written and is not generated from anything. </p><br><h2 id="webassembly">  WebAssembly </h2><br><p>  So what is this thing - WebAssembly (aka WASM)?  This is a replacement for Asm.js, now no longer pretending to be valid JavaScript code.  On the contrary, it is purely binary and optimized, and even just writing an integer into it is not very simple: it is stored for compactness in <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a> format. </p><br><p>  You may have heard about the relooping algorithm for Asm.js - this is the restoration of ‚Äúhigh-level‚Äù flow control instructions (i.e. if-then-else, loops, etc.), which have been sharpened by JS engines, from the low-level LLVM IR, closer to the machine code executed by the processor.  Naturally, the QEMU intermediate representation is closer to the second.  It would seem, here it is, the baytkod, the end of torment ... And then the blocks, if-then-else and cycles! .. </p><br><p>  And therein lies another reason why Binaryen is useful: it can naturally accept high-level blocks that are close to what will be stored in WASM.  But he can also issue a code from the graph of base blocks and transitions between them.  Well, I already said that it hides behind a convenient C / C ++ API storage format for WebAssembly. </p><br><h2 id="tcg-tiny-code-generator">  TCG (Tiny Code Generator) </h2><br><p>  TCG <a href="https://github.com/qemu/qemu/blob/master/tcg/README">was originally a</a> backend for the C compiler. Then it apparently could not stand the competition with GCC, but eventually found its place in QEMU as a code generation mechanism for the host platform.  There is also a TCG backend that generates some abstract baytkod, which is immediately executed by the interpreter, but I decided to use it this time.  However, the fact that QEMU already has the ability to enable the transition to the generated TB via the <code>tcg_qemu_tb_exec</code> function <code>tcg_qemu_tb_exec</code> out to be very useful to me. </p><br><p>  To add a new TCG backend to QEMU, you need to create a subdirectory <code>tcg/&lt; &gt;</code> (in this case, <code>tcg/binaryen</code> ), and there are two files in it: <code>tcg-target.h</code> and <code>tcg-target.inc.c</code> and <a href="https://github.com/atrosinenko/qemujs/blob/abeace64b1e5b52a6ab17bdd4a0e08eb911e98d2/configure">prescribe</a> everything This is a matter of <code>configure</code> .  You can put other files there, but, as you can guess from the names of these two, they will both be included somewhere: one as a normal header file (it is included in <code>tcg/tcg.h</code> , and that one in other files in the <code>tcg</code> directories, <code>accel</code> and not only), the other - only as a code snippet in <code>tcg/tcg.c</code> , but it has access to its static functions. </p><br><p>  Having decided that I would spend too much time on the detailed proceedings, as it is arranged, I simply copied the ‚Äúskeletons‚Äù of these two files from another implementation of the backend, honestly indicating this in the license header. </p><br><p>  The <code>tcg-target.h</code> contains mainly settings in the form <code>tcg-target.h</code> <code>#define</code> s: </p><br><ul><li>  how many registers and how wide is the target architecture (we have - how much we want, so much is - the question is more than what will be generated in a more efficient code by the browser on the "very target" architecture ...) </li><li>  alignment of host instructions: on x86, and in TCI, instructions are not aligned at all, I'm going to put code and not instructions at all in the buffer, but pointers to the structures of the Binaryen library, therefore I will say: 4 bytes </li><li>  what optional instructions can generate a backend - we include everything we find in Binaryen, let the rest of the accelerator be broken down into simpler ones </li><li>  what is the size of the TLB cache asks for the backend.  The fact is that in QEMU everything is serious: although there are helpers that implement load / store taking into account the guest MMU (and where is it now without it?), They retain their broadcast cache as a structure, which processing can be easily embedded straight into the broadcast blocks.  The question is which offset in this structure is most effectively handled by a small and fast sequence of commands. </li><li>  here you can tweak the assignment of one or two reserved registers, enable the TB call through the function and optionally describe a couple of small <code>inline</code> functions like <code>flush_icache_range</code> (but this is not our case) </li></ul><br><p>  The <code>tcg-target.inc.c</code> , of course, usually much larger in size and contains several required functions: </p><br><ul><li>  initialization, which specifies, among other things, restrictions on what instruction with which operands can work.  Impudently copied by me from another backend </li><li>  function that accepts a single inner bytecode statement </li><li>  here you can put auxiliary functions, and also here you can use static functions from <code>tcg/tcg.c</code> </li></ul><br><p>  For myself, I chose the following strategy: in the first words of the next translation block, I wrote down four pointers: a start mark (some value in the <code>0xFFFFFFFF</code> neighborhood, which determined the current TB state), a context, a generated module, and a magic number for debugging.  First, the label was set to <code>0xFFFFFFFF - n</code> , where <code>n</code> is a small positive number, and with each execution through the interpreter it increased by 1. When it reached <code>0xFFFFFFFE</code> , the compilation took place, the module was saved in the function table, imported into a small ‚Äústarter‚Äù, into which the execution went away from <code>tcg_qemu_tb_exec</code> , and the module was removed from the QEMU memory. </p><br><p>  Paraphrasing the classics, ‚ÄúA crutch, how much of this sound for Proger's heart is intertwined ...‚Äù.  However, the memory flowed away somewhere.  And it was a memory driven by QEMU!  I had a code that, when I wrote down the next instruction (well, that is, the pointer), deleted the one to which it was at this place earlier, but it did not help.  In fact, in the simplest case, QEMU allocates memory at startup and writes the generated code there.  When the buffer ends, the code is discarded, and the next one begins to be written in its place. </p><br><p>  After studying the code, I realized that the crutch with the magic number made it possible not to fall on the destruction of the heap, freeing up something that was not on the uninitialized buffer on the first pass.  But who rewrites the buffer to bypass my function then?  As the developers of Emscripten advise, having rested against the problem, I ported the resulting code back into the native application, set Mozilla Record-Replay on it ... In general, as a result, I understood a simple thing: for each block, there is a <code>struct TranslationBlock</code> with its description.  Guess where ... That's right, directly in front of the block, right in the buffer.  Realizing this, I decided to tie it with crutches (at least a few), and just threw out the magic number, and transferred the remaining words to the <code>struct TranslationBlock</code> , making a simply connected list that you can quickly go through when resetting the broadcast cache and freeing the memory. </p><br><p>  Some crutches remain: for example, marked pointers in the code buffer - some of them are simply <code>BinaryenExpressionRef</code> , that is, they look at expressions that need to be linearly put into the generated base unit, part is the condition of transition between the BBs, part is where to go.  Well, there are already prepared blocks for Relooper, which need to be connected according to the conditions.  In order to distinguish them, the assumption is that they are all aligned at least four bytes, so you can safely use the lower two bits under the label, you just need to remember to remove it if necessary.  By the way, such labels are already used in QEMU to indicate the reason for leaving the TCG cycle. </p><br><h2 id="ispolzovanie-binaryen">  Use Binaryen </h2><br><p>  Modules in WebAssembly contain functions, each of which contains a body, which is an expression.  Expressions are unary and binary operations, blocks consisting of lists of other expressions, control flow, etc.  As I said, the control flow is organized here as high-level branches, cycles, function calls, etc.  Arguments are passed to functions not on the stack, but explicitly, as in JS.  There are global variables, but I have not used them, so I will not tell about them. </p><br><p>  Functions also have local variables numbered from zero, of type: int32 / int64 / float / double.  In this case, the first n local variables are the arguments passed to the functions.  Please note that even though everything is not quite low-level in terms of control flow, but whole numbers still do not carry the sign / unsigned attribute: how the number behaves depends on the operation code. </p><br><p>  Generally speaking, Binaryen provides a <a href="https://github.com/WebAssembly/binaryen/wiki/Compiling-to-WebAssembly-with-Binaryen">simple C-API</a> : you create a module, you create expressions <strong>in it</strong> - unary, binary, blocks from other expressions, control flow, etc.  Then you create a function whose body you want to specify an expression.  If you, like me, have a low-level transition graph, the relooper component will help you.  As far as I understand, you can use high-level flow control in a block as long as it does not go beyond the block limit ‚Äî that is, you can do the internal branch of the fast path / slow path inside the embedded TLB cache processing code, but you cannot interfere with the outer control flow - no .  When you release a relooper, its blocks are released, when you release a module ‚Äî the expressions, functions, etc., that are highlighted in its <em>arena</em> , disappear. </p><br><p>  However, if you want to interpret the code on the go without unnecessary creations and deletions of the interpreter instance, it may make sense to bring this logic to a file in C ++, and from there directly manage the entire C ++ library API, bypassing the ready-made wrappers. </p><br><p>  So, to generate code, you need </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    (  ) BinaryenSetAPITracing(0); BinaryenSetOptimizeLevel(3); BinaryenSetShrinkLevel(2); //   BinaryenModuleRef MODULE = BinaryenModuleCreate(); //    ( ,   ) helper_type BinaryenAddFunctionType(MODULE, "helper-func", BinaryenTypeInt32(), int32_helper_args, ARRAY_SIZE(int32_helper_args)); // (int23_helper_args ^W ) //  -  // ...     -  :) //    BinaryenAddFunction(MODULE, "tb_fun", tb_func_type, func_locals, FUNC_LOCALS_COUNT, expr); BinaryenAddFunctionExport(MODULE, "tb_fun", "tb_fun"); ... BinaryenSetMemory(MODULE, (1 &lt;&lt; 15) - 1, -1, NULL, NULL, NULL, NULL, NULL, 0, 0); BinaryenAddMemoryImport(MODULE, NULL, "env", "memory", 0); BinaryenAddTableImport(MODULE, NULL, "env", "tb_funcs"); //       assert (BinaryenModuleValidate(MODULE)); BinaryenModuleOptimize(MODULE);</span></span></code> </pre> <br><p> ‚Ä¶    ‚Äî ,     ,   ‚Äî   . </p><br><p>    --,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>]; BinaryenModuleOptimize(MODULE); BinaryenSetMemory(MODULE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = BinaryenModuleWrite(MODULE, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); BinaryenModuleDispose(MODULE); EM_ASM({ var <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Module(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uint8Array(wasmMemory.buffer, $<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>)); var fptr = $<span class="hljs-number"><span class="hljs-number">2</span></span>; var instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Instance(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, { <span class="hljs-string"><span class="hljs-string">'env'</span></span>: { <span class="hljs-string"><span class="hljs-string">'memory'</span></span>: wasmMemory, <span class="hljs-comment"><span class="hljs-comment">// ... } ); //       instance! }, buf, sz);</span></span></code> </pre> <br><p>  -     QEMU  JS        ,    (     ),     .    ,         translation block,   ,           <code>struct TranslationBlock</code> . </p><br><p> , <a href="https://atrosinenko.github.io/qemujs-demo/new/shell.html"></a> <em>(    )</em>     Firefox.  Chrome  <em>-  </em>  ,  -       WebAssembly,          ... </p><br><p>     . ,    ,   - .  ,    <em> </em>    . ,      WebAssembly  ,       JS,      ,     ,     . </p><br><p> <strong><strong> :</strong></strong>     32- ,         Binaryen, -     -   2  32-  .   ,     Binaryen       .   ? </p><br><div class="spoiler"> <b class="spoiler_title">-</b> <div class="spoiler_text"><p>      ,     ¬´ ,   32- Linux?¬ª        .    ,   : 1  2 Gb. </p></div></div><br><div class="spoiler"> <b class="spoiler_title">- (  )</b> <div class="spoiler_text"><p>       .    ,    ‚Äî   <strong></strong>   .  ¬´ :    ,     ...¬ª. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2gbubble.c // Usage: LD_PRELOAD=2gbubble.so &lt;program&gt; #include &lt;sys/mman.h&gt; #include &lt;assert.h&gt; void __attribute__((constructor)) constr(void) { assert(MAP_FAILED != mmap(1u &gt;&gt; 31, (1u &gt;&gt; 31) - (1u &gt;&gt; 20), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)); }</span></span></code> </pre> <br><p> ‚Ä¶  Valgrind-, ,  , ,  , Valgrind       :) </p><br><p> <em>, -   ,     ...</em> </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/451306/">https://habr.com/ru/post/451306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451296/index.html">Announced ML.NET 1.0</a></li>
<li><a href="../451298/index.html">How to make a game console with the case, ordering a single PCB</a></li>
<li><a href="../4513/index.html">The founder of "MegaFon" asks for protection from the Russian minister</a></li>
<li><a href="../451300/index.html">How to solve the traveling salesman problem?</a></li>
<li><a href="../451304/index.html">The ‚Äútip‚Äù from Yandex: how to maximize profits on a paid subscription</a></li>
<li><a href="../451310/index.html">Did you miss the CCP?</a></li>
<li><a href="../451314/index.html">Production of printed circuit boards LUT'om from A to Z</a></li>
<li><a href="../451316/index.html">About one faculty of physics</a></li>
<li><a href="../451318/index.html">Announced Dart 2.3: optimized for user interface development</a></li>
<li><a href="../451320/index.html">Why open firmware is important for safety</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>