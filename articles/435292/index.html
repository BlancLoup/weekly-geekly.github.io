<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What did the PDP-11 teach us?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CG Bell, WD Strecker, ‚ÄúWhat We Have Learned from the PDP-11,‚Äù ‚Äú3rd Annual Symposium on Computer Architecture Conference Proceedings, pp. l-14, 1976. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What did the PDP-11 teach us?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bt/ex/g2/btexg2j_gmcvjxnfpjn4x3jbxs4.png"><br>  <i>CG Bell, WD Strecker, ‚ÄúWhat We Have Learned from the PDP-11,‚Äù ‚Äú3rd Annual Symposium on Computer Architecture Conference Proceedings, pp.</i>  <i>l-14, 1976.</i> <br><br>  This article I chose today is a retrospective of computer design.  This is one of a series of articles by Gordon Bell with various collaborators describing the development, growth, and sudden replacement of the company's iconic product line, the PDP-11 minicomputers. <br><a name="habracut"></a><br><ul><li>  CG Bell, R. Cady, H. McFarland, B. Delagi, J. O'Laughlin, R. Noonan and W. Wulf, ‚ÄúA New Architecture for Mini-Computers - The DEC PDP-11,‚Äù Proceedings of the Sprint Joint Computer Conference, pp.  657-675, AFIPS Press, 1970. </li><li>  CG Bell, WD Strecker, ‚ÄúWhat We Have Learned from the PDP-11,‚Äù ‚Äú3rd Annual Symposium on Computer Architecture Conference Proceedings, pp.  l-14, 1976. </li><li>  WD Strecker, ‚ÄúVAX-11/780: A Virtual Addressing of the DEC PDP-11 Family,‚Äù Proceedings of the National Computer Conference, pp.  967-980, AFIPS Press, 1978. </li><li>  CG Bell, WD Strecker, ‚ÄúRetrospective: What we have learned from the VAX and Alpha,‚Äù Proceedings of the 25th Annual International Symposium on Computer Architecture, pp.  6-10, 1998. </li></ul><br>  This year we celebrate the 60th anniversary of the foundation of the company that produced the PDP-11.  It's been 40 years since this article was written, and I thought it would be interesting to do a retrospective of Bell's articles from our modern point of view. <br><br><img src="https://habrastorage.org/webt/ef/p_/vy/efp_vyyz1an5rfis3axmot-vf5i.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What was Digital Equipment Corporation? </h3><br>  To imagine the time when the article was written, we first need to talk a little about the company that launched PDP-11, Digital Equipment Corporation from Maynard, Massachusetts.  More commonly known as DEC. <br><br><img src="https://habrastorage.org/webt/vw/er/6w/vwer6wfpzv4-ppq7-xfxqjcnoqc.jpeg"><br><br>  DEC was founded in 1957 by Ken Olsen and Harlan Anderson.  Olsen and Anderson worked together at the Lincoln Laboratory at the Massachusetts Institute of Technology, where they noticed that students queued for hours to use the <a href="http://museum.mit.edu/150/23">TX-0</a> , an experimental interactive computer designed by Wes Clark <br><br><div class="spoiler">  <b class="spoiler_title">one</b> <div class="spoiler_text">  Clark continued to develop TX-0 in TX-2 and later joined DEC as head of the LINC <br></div></div><br><img src="https://habrastorage.org/webt/u-/p_/lm/u-p_lmwp4ly-4rjqdbq6bvjayuc.jpeg"><br><br>  This is TX-0. <br><br><img src="https://habrastorage.org/webt/so/de/vr/sodevrwmacb_y7v65biysm1xxom.jpeg"><br><br>  Let's compare it with something like the IBM 704, a computer of the time that most students ignored. <br><br><div class="spoiler">  <b class="spoiler_title">2</b> <div class="spoiler_text">  After the presentation, someone suggested that students' dislike for IBM could be based on a lack of budget for the computer time of this system. <br></div></div><br>  What Olsen and Anderson found was that the desire to use an interactive computer was so strong that there was a market for "small" computers designed for this role. <br><br><img src="https://habrastorage.org/webt/nc/eo/ab/nceoabpycn2zpif7o01ykcgjj5k.jpeg"><br><br>  DEC first offered the PDP-1, an efficient commercial version of the TX-0. <br><br>  <i><b>Amendment</b> : Michael Chaponis, head of the PDP-1 restoration project, kindly wrote me the following:</i> <i><br><br></i>  <i>Whirlwind and PDP-1 have a 5-bit opcode, TX-0 started with a 2- or 3-bit opcode, but this value increased with an increase in the memory capacity of the TX-2.</i>  <i>Comparing the order of the PDP-1 and Whirlwind codes reveals that the PDP-1 is a cheaper and somewhat improved version of the Whirlwind architecture.</i> <i><br><br></i> <ul><li>  Improvement: indirect addressing added. </li><li>  Cheaper: The live register is removed and the subroutine call instruction is added, and the shift counter is removed due to the fact that the instructions for integer multiplication and division are replaced by instructions for the multiplication step and the division step, which make the shift by one bit.  The biggest decrease in the price of the PDP-1 compared to Whirlwind was due to a change in the design of logic and design. </li></ul><br>  The contrast between the PDP-1 and IBM 704 was great, but several years earlier small and slow interactive computers, such as the Librascope LGP-30 and Bendix G-15, had already appeared, and they were sold in similar quantities. <br><br>  It should also be noted that the name PDP is an acronym for ‚ÄúProgrammed Data Processor‚Äù, since a computer at that time was understood to be large, complex and expensive machines, and venture capitalists could not support DEC if they produced ‚Äúcomputers‚Äù <br><br><div class="spoiler">  <b class="spoiler_title">3</b> <div class="spoiler_text">  For PDP-1 was written by one of the first computer games, " <a href="https://www.computerhistory.org/pdp-1/spacewar/">Spacewar</a> " by Steve Russell <br></div></div><br>  Following the success of the PDP-1, DEC offered several computer families, many of which were designed, at least in part, by Gordon Bell. <br><br><h3>  Introduction </h3><br>  <i>The computer is not fully defined by the architecture;</i>  <i>it reflects the technological, economic and humanitarian aspects of the time and place where it was designed and built.</i>  <i>The finished computer is a product of its era.</i> <br><br>  Right from the very beginning, Bell lets us know that for the success of any computer project you need not to build the world's best abstract computer, but to build the right computer, taking into account the context. <br><br>  <i>In this chapter, we will look at the PDP-11: creation goals, architecture, various implementations, and the people who created it.</i>  <i>We will study its design, starting with the specifications of the architecture, and consider how they were influenced by technology, organization of development, sales, application, organization of production and the nature of end users.</i> <br><br>  At this time, in 1976, Bell was the head of the DEC development for almost four years.  It is clear that he views the success of the PDP-11 in the broader context of the market, whose needs they were to satisfy, and which further influenced the evolution of the entire PDP-11 family. <br><br>  Sustained in the spirit of Bell's words, this presentation focuses on two aspects of the article, on technology and on people. <br><br><h3>  The Basics: Design Thought </h3><br>  Bell begins with this observation. <i>By its nature, computer engineering is focused on achieving the goal of creating the final product.</i>  <i>Therefore, it is difficult to build long-term plans.</i> <br><br>  These are principles of agile.  While.  25 years before Snowbird and writing agile manifest.  When it was written, DEC was no longer a start-up struggling for its existence, it was a mature company with several successful product lines on the market, and Bell says that the need to produce a minimum viable product is more important than all other long-term plans. <br><br>  Like IBM / 360, the PDP-11 was not designed as a single computer model, but as a series of models, with software written for a small PDP-11 compatible with a large one. <br><br>  <i>‚ÄúThe term‚Äú architecture ‚Äùis used here to describe the attributes of a system as seen by a programmer, i.e.</i>  <i>conceptual structure and functional behavior, not to describe the organization of data flows and control, logical design and physical implementation. ‚Äù- GM Amdahl GA Blaauw and FP Brooks Jr.</i>  <i>Architecture of the IBM System / 360, 1964</i> <br><br>  Due to the open nature of the PDP-11, anything that interprets instructions in accordance with the processor specification is PDP-11, and DEC, as soon as the PDP-11 market warmed up, began to build implementations of this architecture, they had several groups, some of which built fast and expensive computers, while others designed slower for a lower price. <br><br>  <i>Despite the evolutionary planning style, the PDP-11 became successful on the market: over 20,000 pieces were sold in six years, during which they were on the market (1970-1975).</i>  <i>Design in this case is not so important: a large and aggressive marketing organization, armed with software to correct architectural flaws and omissions, can save almost any design.</i> <br><br>  Here, Bell in his article asks the question: did the PDP-11 have a good design, or simply gained an advantage due to hyperactive marketing?  In order to answer his own question, Bell examines the product in terms of the design criteria that he and his collaborators identified six years earlier. <br><br><h3>  Address space </h3><br>  The first weakness of microcomputers was the limited address space.  The biggest and most common mistake was to make a computer design that does not have sufficient address space for addressing and memory management. <br><br>  Minicomputers of that era had a 12-bit address space, which made it possible to address only 4096 addresses, each of which stored a 12-bit word. <br><br>  It should be noted that the word "minicomputer", which later came to denote the physical size, was originally derived from the phrase "minimal computer".  A canonical example was the PDP-8, the previous DEC model, which had a total of eight instructions. <br><br><img src="https://habrastorage.org/webt/vi/me/co/vimecoj2x5aezvsojy6vza9erdi.jpeg"><br><br>  The reason for the tiny address space was the price.  Memory was extremely expensive in the 60s and early 70s, when every bit consisted of a tiny magnetic core that was woven into a grid of control conductors. <br><br>  The cores were arranged in a panel, in this case 4096 bits, which were connected in piles to get the word, thus 4096 words of memory consisted of 16 million rings ( <i>here, obviously, an error in the original text, 4096 words * 16 bits = 65536 rings Transl.</i> ), each of which was, at least partially, manually assembled.  Now it is clear why the memory was so expensive. <br><br><img src="https://habrastorage.org/webt/cm/fg/jp/cmfgjpj8yor6yj6qy6r6efh8og4.png"><br><br>  Bell and other PDP-11 designers knew that core prices would continue to fall, and that semiconductor memory, although not as cost effective at that time, would continue to fall in price per stored byte.  Thus, the amount of memory that a customer can afford to buy will increase over time, as users tend to buy "systems for the same price in dollars."  But still, <br><br>  <i>The PDP-11 followed this bad tradition of saving on address bits, but it was saved by the principle that good design could survive at least one major change.</i> <br><br>  Even taking into account the developers' predictions, Bell noted that less than two years have passed since the PDP-11 architecture was launched, as it was necessary to include a memory management module in the architecture to provide access to a larger, 18-bit address space at the cost of increased software complexity .  After a few years, another 4 bits were added. <br><br>  In fairness, although Bell reproached himself for hindsight, the tradition of making insufficient address space continues to this day.  Remember the 640K limit in DOS?  Remember the battles with himem.sys?  Faced a situation where a 32-bit program requires more than 2 GB of data? <br><br>  So no one is perfect. <br><br><h3>  Not enough registers </h3><br>  <i>The second weakness of minicomputers was the tendency for an insufficient number of registers.</i>  <i>This was corrected in the PDP-11, which had eight 16-bit registers.</i>  <i>Later, six 32-bit registers were added for floating point arithmetic.</i>  <i>A larger number of registers could increase the task context switching time.</i> <br><br>  It was not unusual, even for mainframes of the time, to provide only one register - the battery.  If additional registers were provided, they were used only as index registers, not as general registers. <br><br>  It is also interesting to note Bell's remark that redundant registers can be inconvenient for the user.  In the early 1970s, the most common was programming machines directly in assembler. <br><br>  There is a strong relationship between the number of registers in the architecture, the number of address bits, and the size of the instruction.  All of these factors are caused by insufficient memory, and it made sense to carefully think through the instruction set. <br><br>  In Von Neumann's machines (which almost all computers of the 60s were), the program and data share the same, limited address space, and the inefficient program wasted not only computer time, but also memory.  A slow program can be tolerated, but if the program does not fit in memory, it was fatal, that is, the method of encoding instructions should be as efficient as possible. <br><br>  Let's consider a very common case of moving from one memory location to another.  How many bits do you need to describe this operation?  Here is one of the possible implementations: <br><br><pre><code class="plaintext hljs">MOV addr addr</code> </pre> <br>  You need 16 bits for the source address, another 16 for the destination address, and a certain number of bits to encode the MOV instruction itself.  Let there be a total of 40 bits, it is not a multiple of 16, which means a complex 2.5-bit encoding of instructions.  However, what if we load the address into the register? <br><br><pre> <code class="plaintext hljs">MOV (R0), (R1)</code> </pre> <br>  In this case, we only need to describe the registers, the PDP-11 has 8 registers, and only 3 bits are enough to describe the register, plus a few bits per operator description.  Such a command will easily fit into a 16-bit word, and does not require complex coding of instructions with variable length. <br><br><img src="https://habrastorage.org/webt/ud/dt/01/uddt01pifmvr1f_nkkop39uzxr0.png"><br><br>  In fact, the PDP-11 uses 6 bits per register, and 4 bits per operation if the instruction has two operands. <br><br><h3>  Hardware stack </h3><br>  <i>The third weakness of minicomputers was insufficient hardware support for the stack.</i>  <i>In PDP-11, an auto-increment and auto-decrement address mechanism was implemented.</i>  <i>This solution is unique to the PDP-11 and has proven to be extremely useful.</i>  <i>(And this decision was copied by developers of other systems.)</i> <br><br>  Nowadays, it is difficult to imagine equipment that does not have a stack, but in fact the stack is not very important unless you are using recursion. <br><br>  The design of the PDP-11 dates back to 1969, and if we look at the programming languages ‚Äã‚Äãof the time, FORTRAN and COBOL, they did not support the recursive function call.  The sequence of the function call included storing the return address in the empty word at the beginning of the procedure, which made recursion impossible. <br><br><img src="https://habrastorage.org/webt/9t/a0/jg/9ta0jg3ud742lxb5ayw93pfv-ke.png"><br><br>  PDP-11 defines the stack pointer as we understand it today as a register controlled by PUSH and POP operations, but the PDP-11 went further and allowed any register to work as a stack pointer by adding an auto-increment / decrement modifier to the operand registers. <br><br>  For example, one instruction: <br><br><pre> <code class="plaintext hljs">MOV R4, -(R6)</code> </pre> <br>  reduce the value in R6 by two, then store the value of R4 at the address stored in R6.  Thus, in the PDP-11 assembler, we place the value on the stack.  If any of you programmed under ARM, this should be familiar to you. <br><br>  This means that there is no need for dedicated PUSH or POP instructions, it saves instruction space, allows you to use any register as a stack pointer, although traditionally the stack pointer is R6, and is used by the hardware when making a subroutine call. <br><br><h3>  Interrupt latency </h3><br>  <i>The fourth weakness of minicomputers of the time is limited interrupt support and slow context switching, and this problem was solved using the UNIBUS vector interrupt controller with direct connection of device interrupts.</i> <br><br>  At this point in the life of DEC, almost all of its products had a PDP-10 architecture, the DEC mainframe, which was designed for interactive applications, laboratories, and process control.  The response to interrupts, the delay between the activation of the interrupt signal and the start of interrupt processing, is key to achieving high real-time performance. <br><br>  In the PDP-11, the interrupt device provides the address of the interrupt handler.  Bell honestly writes about this: <br><br>  <i>The main mechanism is very fast, it requires only four memory access cycles from the time when the interrupt was requested to the moment the first interrupt handler instruction was executed.</i> <br><br><h3>  Character support </h3><br>  <i>The fifth weakness of most minicomputers was the poor support for strings, which was solved in PDP-11 by the ability to directly address bytes.</i> <br><br>  The importance of supporting lines and characters began to increase during the 1960s, when solutions for science and business began to appear.  The dominant encoding method at that time was a 6-bit character set, which provided enough space for uppercase letters, numbers from 0 to 9, a space and a few punctuation enough to print financial reports. <br><br><img src="https://habrastorage.org/webt/4j/7a/2i/4j7a2igan6lbjg_1rs05pxmoeus.jpeg"><br><br>  Since the memory was very expensive, placing one character in a 12-bit or 18-bit word was simply unacceptable, and the characters were packed into words. <br><br>  This improves storage efficiency, but is difficult for operations such as moving, comparing, and merging, which must take into account that the character may be in the lower or upper part of the word, which increases the amount of expensive memory occupied by the program. <br><br>  The problem was solved in the PDP-11, the machine could operate with both 16-bit words and the gaining popularity of 8-bit bytes.  Expanding the character length by two bits simplified string operations and made it easier to adapt to the increasingly popular 7-bit ASCII standard, which DEC was at the time.  Bell ends this paragraph like this: <br><br>  <i>Despite the fact that the string processing instructions were missing from the hardware, the usual string operations (moving, comparing, concatenating) could be programmed as a very short cycle.</i> <br><br>  And this is actually the case.  It was possible to write a copy procedure in just two instructions, assuming that the source address and the destination address are in the registers. <br><br><pre> <code class="plaintext hljs">loop: MOVB (src)+, (dst)+ BNE loop</code> </pre> <br>  This code takes advantage of the fact that the MOV command sets flags.  The cycle will continue until the value in the source address becomes zero, and in this place the control will proceed to the next instruction.  That is why C lines end in zero. <br><br><h3>  ROM </h3><br>  <i>The sixth weak point of minicomputers was the inability to use ROM, and the PDP-11 did not have this drawback.</i>  <i>Most of the code written for the PDP-11 was ‚Äúclean‚Äù and allowed the programmer to re-enter without special efforts, which allowed using the ROM directly.</i> <br><br>  In process control applications, in which programs are relatively fixed, they must load the program each time from magnetic tape or punched tape, which is expensive.  You must purchase and maintain rarely used I / O devices.  More convenient when the program is always present in the computer.  However, due to the strong memory limits and the lack of hardware support for the stack, self-modifying code was often unavoidable, which seriously limited the use of the ROM.  Bell with deserved pride says that the PDP-11 has changed the situation. <br><br><h3>  Primitive I / O Capabilities </h3><br>  <i>The seventh weakness of minicomputers was the primitive I / O capabilities.</i> <br><br>  During the late 60s, when the PDP-11 was developed, I / O devices were very expensive.  Mainframes of the time used the so-called channel I / O, in which the CPU sent a small program to the channel controller, which executed the program and reported the result.  The program could, for example, download data from a magnetic tape or punch a punched card. <br><br>  Channel I / O was important, it allowed us to unload the processor from I / O operations, and to perform I / O actions at the same time, which increases processor utilization.  The downside was that channel I / O required a separate CPU in each channel controller, which increased the cost of the entire system quite significantly. <br><br><img src="https://habrastorage.org/webt/i8/5d/p-/i85dp-32llbfdd4hxev4ixfzcs0.jpeg"><br><br>  In the minicomputer world, I / O was usually performed directly on the CPU, usually with the help of specialized instructions, hard-coded for each specific device, such as a tape drive or a console printer. <br><br>  The PDP-11 introduced something unusual, memory mapped I / O.  It was not such memory-mapped I / O, which you can use with the mmap (2) system call, but simply the convention that some memory addresses are not just memory cells, and their contents are mapped onto boards inserted into the backplane, which in DEC was called UNIBUS. <br><br><img src="https://habrastorage.org/webt/zg/bx/9i/zgbx9il5qoyr81cc_zkpbxarjza.jpeg"><br><br>  For example, the value recorded in 777566 <div class="spoiler">  <b class="spoiler_title">four</b> <div class="spoiler_text">  Addresses are given in the octal system, as was the case on previous 12, 18, and 36-bit DEC machines. </div></div>  will be written to the device connected to the console, usually the printing terminal. <br><br><img src="https://habrastorage.org/webt/0p/_r/wk/0p_rwkprbziqlerzwca8rwp0ulo.jpeg"><br><br>  If you read the value from the address 777570, you got the value entered by the switches on the front panel.  This was often used to configure the bootloader. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  Similarly, the RK05 drive was addressed by writing the sector number to which you want to access the address 777412, the address where you want to write the data, to 777410, and the number of words to 777406. Then set the zero bit at 777404 to 1 ( bit GO), and the drive will transfer the required number of words directly into memory. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  My favorite device was the KW11-L timer.  Writing bit 6 at 777546 triggers an interrupt every 20 ms.  Why is it 20 ms?  Because this is the frequency period of the AC <br><br><div class="spoiler">  <b class="spoiler_title">five</b> <div class="spoiler_text">  If you ordered a car for a region with a frequency of 60 Hz, it had a different number (partnumber) <br></div></div><br>  Yes, like a domestic clock, the PDP-11 counted time by periods of mains voltage. <br><br><h3>  High programming cost </h3><br>  <i>The ninth weakness of minicomputers was the high cost of programming.</i>  <i>Many users programmed in assembly language without convenient editors and IDE, file systems and debuggers available on large systems.</i>  <i>The PDP-11 was not able to overcome this drawback, although more complex systems were built on the basis of the PDP-11 than on previous models, the PDP-8 and PDP-15.</i> <br><br>  Because of their minimalistic nature, minicomputers did not provide a convenient environment for developing programs.  Often used tedious toggle switches, or, perhaps, editing and assembling programs on another, large computer, and transfer them to paper tape. <br><br>  It was similar to how microcontrollers are programmed today, we edit the program on a large workstation, compile the target binary file, and transfer it to the microcontroller‚Äôs flash memory. <br><br><img src="https://habrastorage.org/webt/ep/kq/lh/epkqlhrntlqhzoejdeaownpnmws.jpeg"><br><br>  However, it seems that Bell did not know about the work of Thompson and Richie, who were busy building their own software environment on the PDP-11 in New Jersey. <br><br><h3>  People who built the design </h3><br>  Let's go to the second section: people <br><br>  This section is most interesting to me as a history buff, because studying the history of computers, like any other historical subject, is basically studying the history of people and the context in which they made decisions. <br><br>  Bell notes that although computers are based on technology, they are created by people, and therefore he devoted this section to describing the dynamics of the DEC group during the development of the PDP-11. <br><br>  <i>Problems faced by computer developers can be divided into two parts: problems due to inexperience and problems of a systemic nature.</i> <br><br>  Here Bell recalls the words of Fred Brooks from his most recent book, The <a href="https://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959">Mythical Man-Month</a> . <br><br>  Brooks, the head of the OS / 360 project, has been struggling for years to create a unified general-purpose operating system that can work on all IBM / 360 models, which was the goal of the project.  Brooks's words were fresh in his memory when he wrote this paragraph. <br><br><h3>  Chronology of design </h3><br>  This section is a window into the work of the DEC Corporation in the late 1960s. <br><br>  The internal organization of design teams at DEC for many years has varied between market orientation and product orientation.  When the company grew by 30 or 40% per year, there was a need for constant reorganization.  At any particular time, about a third of the employees worked for the company for less than a year. <br><br>  Raise your hands if this is familiar to you. <br><br>  <i>During the development of the PDP-11, the company was structured around product lines.</i>  <i>The company's developers were organized into small groups: PDP-10 group, PDP-15 group (18-bit machine), PDP-8 group, PDP-8 / S subgroup, LINC-8 group.</i>  <i>Each group included marketers and engineers responsible for product development, software and hardware.</i>  <i>As a result of such an organization, experience in architecture was divided into groups.</i> <br><br>  Bell devotes some time to reviewing each group, listing its strengths and weaknesses, and their contribution to PDP-11.  I will not list all of this here, with one exception. <br><br>  <i>The PDP-10 group was the strongest in the company.</i>  <i>they built big, powerful, time-sharing machines.</i>  <i>She was in many ways a separate division of the company, with a minimal amount of interaction with other groups.</i>  <i>Although the PDP-10 group as a whole had the best understanding of how the system architecture works, they did not have a clue about the range of systems, it was interesting for them to build only high-speed computers.</i> <br><br>  Recently, I worked in a software company, in which one or two of the oldest products made almost all the company's profits, and I understand Bell‚Äôs position well.  The PDP-10 was a DEC version of the mainframe, very fast, and available only at one fixed price. <br><br>  <i>The first works on the creation of a 16-bit computer began under the management of the PDP-15 manager, a marketer with engineering experience.</i>  <i>The first project was called PDP-X, and included the specifications of a number of machines.</i>  <i>It was a family of machines, and it was better designed than the later PDP-11, but it was not particularly innovative.</i>  <i>Unfortunately, the group manager blamed the management that their project was potentially as complex as the PDP-10 (this was not the case), and that he was confident that the project had failed, and therefore no one else wanted to do other large computers other than a single large computer. the company.</i> <br><br>  And here Bell gives us a good lesson: if your competencies are in the same chain as the projects of other managers, they have an effective tool to kill your project before it enters the market. <br><br>  <i>In retrospect, the people involved in the development of the PDP-X appeared to be at the same time working on the development of Data General.</i> <br><br>  This could not have been noticed by an ordinary reader, but this is a reference to the ‚Äútreacherous eight‚Äù Shockley a decade earlier. <br><br><div class="spoiler">  <b class="spoiler_title">6</b> <div class="spoiler_text">  This group included Robert Noyce and Gordon Moore, who left Fairchild ten years later and founded their own company, Intel. <br></div></div><br>  Edson de Castro, PDP-8 product manager, and PDP-X project leader left DEC, with several people from his team, to form the Data General.  It is not clear from the records whether de Castro left because the PDP-X was discontinued, or his departure was the last straw that killed the project.  In any case, the result was obvious, as Bell writes. <br><br>  <i>When the PDP-X project was closed, the DCM project began (Desk Calculator Machine, the code name chosen for privacy).</i>  <i>Design and planning were done erratically, because Data General competed with its very small 16-bit computer.</i> <br><br>  Data General did not compete with DEC with its 16-bit Nova in the market for which the PDP-8 was developed and which de Castro knew like the back of his hand: rack-mounted laboratory equipment <br><br><img src="https://habrastorage.org/webt/7j/z0/ha/7jz0hacw75yjku2enc4pbz3pgoy.jpeg"><br><br>  12-bit PDP-8 vs Data General's 16-bit Nova <br><br><img src="https://habrastorage.org/webt/dt/gl/5l/dtgl5lnjei8r8hyf3ec33ufgioo.jpeg"><br><br><h3>  PDP-11: ratings </h3><br>  The last part of the article compares the PDP-11 with its predecessors, and then Bell proceeds to evaluate the PDP-11 architecture itself.  The biggest breakthrough was UNIBUS. <br><br>  <i>Overall, the UNIBUS tire exceeded all expectations.</i>  <i>Hundreds of types of storage devices and peripherals could be connected to it, it became the standard architectural component of systems in the price range from $ 3K to $ 100K (1975).</i> <br><br><h3>  What is UNIBUS? </h3><br><img src="https://habrastorage.org/webt/tf/jd/ow/tfjdowtglv5wihs8_bnuuht-11i.jpeg"><br><br>  The earliest commercial computers were developed as a set of modules connected to the backplane with wired connections.  At the time of the lamps, this was necessary because the lamps were unreliable and the modules needed to be replaced quickly. <br><br><img src="https://habrastorage.org/webt/i3/je/cz/i3jeczdmrf1xtwgbhwzdazbcwzw.jpeg"><br><br>  Later, the desire to build a computer from standard modules led to the construction of generalized logical blocks connected with a complex backplane. <br><br>  Here is an example of early DEC modules. <br><br><img src="https://habrastorage.org/webt/pg/dl/sv/pgdlsv83s3hiyinvvjjygywglyq.jpeg"><br><br>  You could mount them on a complex backplane with wired connections, and build a computer out of them, in this case the PDP-8. <br><br>  UNIBUS is a development of previous DEC developments and is an abstraction of an idealized control bus.  The availability of medium integration components eliminates the need for a complex backplane and moves the main complexity into modules that are installed in the backplane.  This makes it possible to build standard modules that connect to a computer. <br><br>  <i>The UNIBUS bus, as a standard, was a component of the architecture that allows you to build easily configurable systems.</i>  <i>Any company, not only DEC, can easily make components that interact with the bus.</i>  <i>Good tires create a good engineering environment in which people can concentrate on structured design.</i>  <i>UNIBUS created a secondary industry that offered alternative sources of memory supplies and peripherals.</i>  <i>Except for the IBM 360 bus, UNIBUS was the most common bus standard in the computer industry.</i> <br><br>  Before the advent of UNIBUS, what kind of input-output devices the minicomputer could support was determined only by its developers.  How to interact with devices was rigidly defined by the logic circuits of the computer.  With the advent of UNIBUS, a wide field was opened for customization of the computer by the end user and a field for experiments. <br><br><h3>  What did the PDP-11 teach us? </h3><br><img src="https://habrastorage.org/webt/nn/e5/ex/nne5exbe74glx2ouw6c_m5ynxxm.jpeg"><br><br>  Bell's retrospective is completed at the time when the article was written, i.e.  in 1976-77, but from our point of view, forty years later, the influence of the PDP-11 was enormous. <br><br><h3>  RISC </h3><br>  Initially, when the PDP-11 was not yet developed, and, moreover, was not considered as a RISC machine, this term did not exist before it was introduced by John Coke in 1976 with respect to the IBM 801. However, for everyone who had programming experience ARM processors, modern RISC processors, their similarity is obvious.  Just as the design of programming languages ‚Äã‚Äãis a process of both evolutionary development and borrowing, the same thing happens with the design of a system of commands. <br><br>  PDP-11        -,      -,       .  ,    -,  Intel 8080     Z80. <br><br><h3>  UNIX </h3><br> PDP-11        . PDP-11  ,         UNIX  Bell Labs <br><br><div class="spoiler">  <b class="spoiler_title">7</b> <div class="spoiler_text"> UNIX     <a href="https://www.bell-labs.com/usr/dmr/www/hist.html">PDP-7</a> .  1970    PDP-11/20,    PDP-11/45. <br></div></div><br>  PDP-11 UNIX  .  PDP-11   ,   ,     .    ,     int  16 ,   - PDP-11. <br><br> UNIX     (pipes), ¬´  ¬ª   . <br><br><h3> VAX-11/780 </h3><br>   ,    ,   PDP     ,         PDP-11. <br><br>     , 1977,    PDP-11, VAX-11,   ‚Äúvirtual address extension‚Äù. <br><br><h3>  BSD </h3><br> UNIX     1974 ,    ,        BSD ‚Äî Berkley Systems Distribution. <br><br> Berkeley UNIX    VAX   1980-      DEC-   VMS. Berkeley UNIX    ,     ,  Sun Microsystems,    Self,      Java. <br><br> UNIX          80-    ¬´ UNIX-¬ª   BSD-,    . <br><br><h3> NeXT </h3><br> 4BSD,     ,       NeXT   .  Apple  NeXT  1997 , NextSTEP    BSD   Darwin, OSX  iOS. <br><br><h3> Windows NT </h3><br>    ,     ,  DEC   . <br><br>  ,    VAX VMS,            ,    VAX,   Microsoft  1988,      ,    Windows NT. ,    Windows    VMS, ,   . <br><br><h3> Xerox Alto </h3><br>       ,  Data General Nova      ,    , ,   ,   Apple Macintosh. <br><br><h3> Data General Nova </h3><br>   Data General  DEC    32- ,      ,   1981   ,   " <a href="https://www.amazon.com/Soul-New-Machine-Tracy-Kidder-ebook/dp/B005HG4W9W">The Soul of a New Machine</a> ". <br><br><h3>     PDP-11? </h3><br>      ,    , PDP-11      . <br><br>  , ,  ,  ,     PDP-11. <br><br>    <br><br><h3>   </h3><br> <a href="https://dave.cheney.net/2014/01/23/what-did-devops-mean">What did devops mean ?</a> <br> <a href="https://dave.cheney.net/2015/05/12/introducing-gb">Introducing gb, a project based build tool for the Go programming language</a> <br> <a href="https://dave.cheney.net/2014/01/24/avr11-how-to-add-256-kilobytes-of-ram-to-an-arduino">avr11: how to add 256 kilobytes of ram to an Arduino</a> <br> <a href="https://dave.cheney.net/2015/10/09/padding-is-hard">Padding is hard</a> </div><p>Source: <a href="https://habr.com/ru/post/435292/">https://habr.com/ru/post/435292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435282/index.html">Sales of vinyl and magnetic tapes are growing.</a></li>
<li><a href="../435284/index.html">Microchips that make life easier for thousands of Swedes</a></li>
<li><a href="../435286/index.html">How I saved Mars or a small quest on python</a></li>
<li><a href="../435288/index.html">A swarm of satellites as a replacement for large orbital telescopes</a></li>
<li><a href="../435290/index.html">Learning English is an unpopular opinion.</a></li>
<li><a href="../435294/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ346 (January 1 - 6, 2019)</a></li>
<li><a href="../435296/index.html">Hall of Fame Consumer Electronics: Stories of the Best Gadgets of the Last 50 Years, Part 3</a></li>
<li><a href="../435298/index.html">"Radar" Google Soli continues to evolve</a></li>
<li><a href="../435300/index.html">Subjective vision of an ideal programming language</a></li>
<li><a href="../435302/index.html">Prototype code. Lecture on FrontTalks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>