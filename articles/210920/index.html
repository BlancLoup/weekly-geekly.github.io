<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stored functions. Pros and cons</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Using the stored functions of the DBMS to implement business logic, or part of it, has always been a stumbling block. On the one hand, DBA barricades ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stored functions. Pros and cons</h1><div class="post__text post__text-html js-mediator-article">  Using the stored functions of the DBMS to implement business logic, or part of it, has always been a stumbling block.  On the one hand, DBA barricades and database programmers, on the other, backend developers. <br>  I would risk incurring anger from both camps, but still sum up the pros and cons and present my thoughts on when to write code in stored functions, and when to bring it out. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/1be/e78/9b41bee78705c88f5342008f720279a0.jpg"><br><a name="habracut"></a><br><br>  Let's start with the arguments against: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Smearing business logic </h4><br>  This, in fact, is not a problem of DBMS and HF, as a tool - this is the problem of their incorrect use.  The DB programmer may want to describe all the logic of the action being implemented in the stored function - indeed, because all the data is at hand.  If a programmer succumbs to temptation, and his manager does not mind, in the future there may be problems with the narrowness of the interface with the external system (for example, with the application server) - you have to add new parameters, complicate logic, etc.  This may even lead to the emergence of "duplicate" HF with slightly different functionality. <br><br><h4>  The paucity of the language of the DBMS </h4><br>  There is such a thing.  Traditional languages ‚Äã‚Äãfor writing HF pl / sql, t-sql, pl / pgsql are quite primitive compared to modern general-purpose languages.  It is worth noting that it is possible to write HF in more advanced languages, such as Java in Oracle or Python in postgresql. <br><br><h4>  Intolerance to stored functions </h4><br>  This refers to the incompatibility of the dialects of procedural languages ‚Äã‚Äãof different DBMS.  Multi-platform is just at the level - thanks to the support of different operating systems and architectures in the DBMS itself and the independence of the built-in languages ‚Äã‚Äãfrom the external platform.  Here again, the decision depends on the specifics of the project.  If the project is replicable, and you do not control the platform (the classic example is CMS), then you need portability and the use of HF will only add a headache.  If the project is unique, or the implementations will be unified (for example, in different branches of one company), then the intolerance between different DBMS can be forgotten. <br><br><h4>  The lack of the necessary skills of the team and the high "cost" of the relevant specialists </h4><br>  This, in my opinion, the most serious argument against the use of HF.  It all depends on the scale of the project.  Roughly speaking, the use of stored code on the DBMS side is justified in medium-large enterprise projects.  If the project is smaller - not worth the candle.  If the project is hugely overloaded, then the architecture with HF and RDBMS will be confronted with scaling problems - here it is necessary to use a specific storage and data processing approach. <br><br>  Now the pros: <br><br><h4>  Speed </h4><br>  When processing even small amounts of data in an external application, we spend additional time on transmitting over the network and converting data into the format we need.  In addition, the data processing algorithms are already built in, debugged and tested in the DBMS, and your programmers have no reason to practice inventing bicycles. <br><br><h4>  Hiding the data structure </h4><br>  With the growth and evolution of the software system, the data scheme can and should change.  A well-designed software interface on the HF will allow you to change the data scheme without changing the code of external applications (of which there may be several).  This naturally implies the separation of the roles of developers who work with the database and know its structure, and developers of external applications who only need to know the provided API.  When using dynamic SQL on the application side, additional layers of database software abstractions, various ORMs, are introduced for such a separation. <br><br><h4>  Flexible access rights management </h4><br>  It is a good practice to restrict the user, under which the client application ‚Äúwalks‚Äù into the base, in such a way that he does not have rights to read and change any objects.  Only performs the functions allowed to it.  Thus, you can tightly control what actions are available to the client, reducing the likelihood of data integrity problems due to an error in the client application. <br><br><h4>  Lower probability of SQL injection </h4><br>  When using dynamic SQL on the part of the client program, the client program transmits the SQL commands to the DBMS as strings generated in the code.  When forming these lines, the programmer must be extremely careful to prevent the possibility of unintended modification of the SQL command.  When using HF, SQL code on the application side is usually static, and looks like a simple HF call, the parameters of which are not passed in strings, but through placeholders (: variable) through the binding mechanism.  Of course, this does not exclude the possibility of SQL injection completely (after all, it is possible to concatenate a string passed in a parameter with the text of a dynamically executed SQL query in HF), but it significantly reduces its probability. <br><br><h4>  SQL reuse </h4><br>  Implementing the logic of working with data in the stored layer, we get our usual hierarchical model of reusing SQL code. <br>  When using dynamic SQL, query reuse is difficult. <br>  For example, suppose there is a system A based on HF and a system B based on dynamic SQL.  In both systems, there is a function to get the price of the product get_price.  In case A, this is a stored function or display (view), in case B, for example, a java procedure that executes a SQL query via JDBC.  There is a task - to get the total value of goods in stock.  In case A, we join get_price directly into a query that receives a list of goods in stock (if get_price - view or HF in SQL, such as in PostgreSQL, the optimizer expands the inline query - this turns out one query that quickly finds the amount) . <br>  In case B, there are two options - either run on the cursor with a sample of goods in stock and call get_price n times (which means that the entire sample should be transmitted over the network to the client) or forget about reuse and write a subquery duplicating the one that was already written in get_price.  Both options are bad. <br><br><h4>  Simple SQL Debugging </h4><br>  Debugging is simplified (in comparison with a heterogeneous procedure external code + sql) <br>  In systems with dynamic SQL (any ORM), even the simple task of finding a problem piece of SQL can be difficult. <br>  Semantic and syntactic SQL verification at compile time. <br>  Ability to profile functions and search for bottlenecks. <br>  The ability to trace an already running and running system. <br>  Automatic dependency control - when entity definition is changed, dependent entities are disabled. <br><br><h4>  When to write business logic in the database? </h4><br><h5>  If the processing speed is important </h5><br>  Processing data directly at the place of storage often provides a significant increase in processing speed.  Such optimizations become possible, such as, for example, aggregations at the data storage level ‚Äî the data from the array is not even transferred to the DBMS server, let alone the client. <br><br><h5>  When data integrity and consistency are important </h5><br>  In stored functions with explicit transaction and lock management, it is easier to ensure data integrity and operation atomicity.  Of course, all this can be implemented outside, but this is a separate and big work. <br><br><h5>  The data has a complex but well-established structure. </h5><br>  Flat and weakly interconnected structures often do not require the full wealth of processing tools offered by the DBMS.  For them, you can use ultra-fast key-value storage and caching in memory. <br>  Difficultly organized, highly connected hierarchical and network structures are a clear indication that your knowledge of RDBMS will be useful! <br><br><h4>  When to take the code out? </h4><br><h5>  Work with external data </h5><br>  If the specifics of the system is such that the data coming in for processing outside (from sensors, from other systems) is greater than the data stored in the database, then many advantages of the database, as programming platforms are lost.  It turns out to be easier to process the incoming data from the outside and save the result in the database, than to first push everything into the database, and then process it.  Here the same principle is observed - to process data as close as possible to the source, which we talked about earlier in relation to the processing of data already stored in the database. <br><br><h5>  Complex algorithms </h5><br>  Sophisticated or highly optimized numerical impact crusher algorithms are best written in more suitable languages.  The embedded languages ‚Äã‚Äãof the RDBMS are very powerful (in the sense that they are high-level, not flexible), but due to this they have a high overhead. <br><br><h5>  Highload </h5><br>  In super-heavily loaded systems, conventional approaches to transaction serialization and server cluster synchronization become a bottleneck.  Such systems are characterized by unique solutions for specific tasks, universal and powerful RDBMS systems are often too slow with loads of hundreds of thousands of competitive transactions per second. <br><br>  The conclusion is that there is no clear algorithm.  Each time the decision remains for the architects and the manager and it depends on whether the project is bogged down with problems with race conditions and inconsistency of NoSQL data, problems with performance and debugging of ORM requests, or will run into problems of scaling DBMS using stored functions.  Therefore - make the right decisions :) </div><p>Source: <a href="https://habr.com/ru/post/210920/">https://habr.com/ru/post/210920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210910/index.html">Under pressure from Google, Samsung will remove its work and native apps from Android</a></li>
<li><a href="../210912/index.html">Facebook saved $ 1.2 billion with Open Compute implementation</a></li>
<li><a href="../210914/index.html">Overview of the active stylus HEX3 Nota</a></li>
<li><a href="../210916/index.html">First February - Day of Help</a></li>
<li><a href="../210918/index.html">DevCon 2014 Conference - What Can We Tell Now</a></li>
<li><a href="../210922/index.html">The new head of Microsoft will be Satya Nadella</a></li>
<li><a href="../210924/index.html">North Korean Red Star OS goes to Macs</a></li>
<li><a href="../210926/index.html">Development for Android in NetBeans IDE without plug-ins. Part 2</a></li>
<li><a href="../210930/index.html">As I classes in Vim wrote</a></li>
<li><a href="../210932/index.html">ODR - On-Demand Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>