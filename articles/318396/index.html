<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prefer SRW-blocking to critical sections.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article explains why when developing Win32 applications, the Slim Reader / Writer Lock (SRWL) mechanism is often preferable to classic critical s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prefer SRW-blocking to critical sections.</h1><div class="post__text post__text-html js-mediator-article">  This article explains why when developing Win32 applications, the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa904937(v%3Dvs.85).aspx">Slim Reader / Writer Lock (SRWL) mechanism is</a> often preferable to classic <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v%3Dvs.85).aspx">critical sections</a> . <br><br><h3>  Lightness </h3><br>  The SRWL object occupies only 8 bytes in memory on the x64-architecture, while the critical section is 40 bytes.  The critical section requires initialization and deinitialization through calls to the OS kernel functions, while the SRWL is initialized by simply assigning the SRWLOCK_INIT constant to it, and there are no costs for deleting anything at all.  Using SRWL generates a more compact code and uses less RAM when working. <br><br>  If you have 100,000 objects that require some internal synchronization, the memory savings will already be substantial.  The performance gain from avoiding unnecessary cache misses will be even more tangible.  In modern processors (starting with <a href="https://en.wikipedia.org/wiki/Nehalem_(microarchitecture)">Intel Nehalem</a> , released in 2008th), one <a href="https://en.wikipedia.org/wiki/CPU_cache">cache line</a> is 64 bytes.  If you use 40 of them on the synchronization object, this will significantly affect the performance of access to small objects in your software. <br><a name="habracut"></a><br><h3>  Speed </h3><br>  First of all, keep in mind that the SRWL implementation in the OS kernel has been significantly reworked over the previous few years.  If you are reading a benchmark on the Internet regarding measuring the speed of various synchronization primitives in Windows OS, pay attention to the date of writing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the critical section and SRWL for some time spinning in a loop in user mode, and only then go into standby mode in the kernel.  Only the critical section allows you to customize the timeout in user mode. <br><br>  I have not investigated the details of the implementation deeper.  Also, I never tried to conduct the right benchmark in order to fully correctly compare the speeds of the critical sections and the SRWL.  It is very difficult to build a theoretically sound and practically useful benchmark at the same time. <br><br>  But I replaced critical sections with SRWL in my applications about 20 times in different scenarios.  SRWL was always faster (or at least not slower) and often gave a visible performance boost. <br><br>  I will not give specific numbers here.  The amount of work when locking a lock, the granularity of locks, the level of parallelism, the ratio of reads and writes, cache usage, processor load and other factors have too much influence on the final result. <br><br>  I will not argue that SRWL is absolutely always faster than critical sections.  In each case, profiling is necessary to clarify the whole picture. <br><br><h3>  SRWL lack of reentrancy </h3><br>  This is not a bug, but a feature. <br><br>  If we do not have reenterability of locks, this immediately leads to more transparent public contracts, requires caution when making decisions about the seizure and release of the lock, which ultimately allows us to avoid deadlocks.  Well, at least until you do stupid things, like calling a callback inside a locked lock. <br><br>  Reentrant locks, of course, are also useful.  For example, when you are trying to add parallelism to some old code and do not want to get too deep into its refactoring.  The original POSIX mutex <a href="https://groups.google.com/forum/%3Fhl%3Den">was created reentrant by accident</a> .  One can only imagine how many problems associated with parallel code and locks could be happily avoided if the reentrant synchronization primitives did not become mainstream. <br><br>  A stream that the same SRWL tries to capture for recording twice will catch itself in deadlock.  This type of error is easy to identify and correct right at the time of the first appearance.  Just look at the tackle - there will be all the necessary information.  There is no influence of timings and parallel streams. <br><br>  Recursive read locks also caused deadlocks before, well, at least I'm sure about 90% of this :).  If I'm not mistaken, Microsoft has quietly changed the behavior either in some kind of update, or when moving from Win8 to Win10 and now there is no deadlock.  Unfortunately, this has complicated the search for errors related to reentrancy.  Erroneously inserted read locks lead to unpleasant bugs in cases where the internal lock is released too early.  Perhaps even worse, an external lock can release a lock taken by another reader.  <a href="https://msdn.microsoft.com/en-us/library/hh916381.aspx">Microsoft SAL annotations for locks</a> can theoretically help to detect this type of problem at the compilation stage, but I personally have never tried them in practice. <br><br><h3>  Parallel reading </h3><br>  Parallel reading in practice happens quite often.  The critical section does not support parallelism in this case. <br><br><h3>  Write performance problems </h3><br>  <a href="https://en.wikipedia.org/wiki/Readers%25E2%2580%2593writer_lock">The downside to the</a> advantage of parallel reading is the fact that the write lock cannot be obtained until all the read locks are released.  Moreover, the SRWL does not guarantee a write request for a record, no preferences at all, or even fairness in order to issue a blocking right (new read locks can be successfully captured while the write lock will continue to be pending).  On the one hand, critical sections are not better in this respect (priorities for capturing reading or writing cannot be set there either), but on the other hand, due to the lack of the possibility of parallel captures for reading, the problem will occur less frequently. <br><br>  The Windows Task Scheduler <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms685100(v%3Dvs.85).aspx">provides some fairness</a> in terms of providing resources to all threads.  This helps in blocking a resource in one thread to complete the wait cycle in user mode in all other threads.  But, since the algorithm of the work of the scheduler is not part of any public contract, it is not necessary to write any code for its current implementation. <br><br>  If the continuity of the progress in writing is important, then neither the critical section nor the SRWL are suitable as a synchronization mechanism.  Other constructs, such as a reader-writer queue, may be the preferred mechanism. <br><br><h3>  Competition at runtime </h3><br>  <a href="https://msdn.microsoft.com/en-us/library/dd504907.aspx">concurrency :: reader_writer_lock</a> gives more stringent guarantees of priorities than SRWL and is designed specifically to work in conditions of frequent captures.  It has its price.  In my experience, this synchronization primitive is significantly slower than critical sections and SRWL, and also takes up more memory space (72 bytes). <br><br>  Personally, I think it is too redundant to perform individual tasks (jobs) only to attempt to capture a lock, but, probably, it will suit someone. <br><br><h3>  Wrong cache hit </h3><br>  <a href="https://en.wikipedia.org/wiki/False_sharing">An erroneous cache hit is</a> much more likely for SRWL than for critical sections - again, because of the difference in size (8 bytes versus 40).  If a critical section enters the cache, then its 40 bytes occupy most of the 64-byte cache lines, which excludes the possibility of another critical section falling into it.  If you are creating an array of locks - try to take into account the size of the cache line of your platform. <br><br>  On this, however, should not concentrate ahead of time.  Even SRWL rarely get into the same cache line.  This happens only when a very large number of threads simultaneously modify some relatively small number of objects.  If you have, for example, several thousand small objects, it is hardly worth it because of the probability of an erroneous blocking in the cache to significantly change their size - the game, as a rule, is not worth the candle.  Certainly, of course, can only be asserted after profiling each individual situation. <br><br><h3>  OS kernel bug </h3><br>  I have to mention a bug in the Windows kernel that caused me to lose faith in SRWL and indeed in Windows a little.  Several years ago, my colleagues and I began to notice strange bugs, when some streams sometimes could not capture one or another SRWL.  This happened mainly on dual-core processors, but sometimes, very rarely, and on single-core ones as well.  Debugging showed that at the time of attempting to capture, no other thread held this lock.  What is even more surprising, an instant later in the same thread, an attempt to capture the same lock was already successful.  After a long study, I managed to reduce the playback time of this bug from several days to half an hour.  In the end, I proved that this is a problem in the OS kernel, which also applies to IOCP. <br><br>  From the moment of detection of a bug to the release of the <a href="https://support.microsoft.com/en-us/kb/3036169">hotfix,</a> 8 months passed and, of course, it took some time to distribute the update to user PCs. <br><br><h3>  findings </h3><br>  Most locks protect information in some objects from accidental simultaneous access from different threads.  Here the key word is ‚Äúrandom‚Äù, since the requirement of precisely simultaneous access is rarely intentionally programmed.  Both the critical section and the SRWL have good performance when capturing and releasing the currently free interlock.  In this case, the overall size of the protected object comes to the fore.  If the object is small enough to get into the same cache line with the lock, this immediately gives a performance boost.  At 32 bytes, the smaller size of the SRWL is the main reason to use it for this purpose. <br><br>  For code scenarios, when the lock in most cases at the time of the capture attempt will be already taken, it is impossible to make such unequivocal conclusions.  This requires measurement of each optimization made.  But in this case, the capture and release rate of the lock itself is unlikely to be a bottleneck in the code.  At the head of the corner will be a reduction in the time the code inside the lock.  Everything that can be done before or after blocking should be done there.  Consider using several separate locks instead of one.  Try to pull the necessary data before calling the lock (this gives a chance that the code inside the lock will work faster, because it will get it from the cache).  Do not allocate memory in the global heap inside the lock (try using any allocator with preallocation of memory).  And so on. <br><br>  Finally, non-reentrant locks are much easier to read in code.  Reentrant locks are a kind of ‚Äúgoto concurrency‚Äù because they complicate the understanding of the current state of locking and the causes of deadlocks. </div><p>Source: <a href="https://habr.com/ru/post/318396/">https://habr.com/ru/post/318396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318386/index.html">Creating an editor quest and dialogs for the Unreal engine: Part 2 technical aspects</a></li>
<li><a href="../318388/index.html">Backup network spheres (samba) in Linux based on Windows Server Backup</a></li>
<li><a href="../318390/index.html">How to talk with assholes. 7 strategies for communicating with inappropriate people</a></li>
<li><a href="../318392/index.html">The digest of interesting materials for the mobile # 185 developer (December 19-25)</a></li>
<li><a href="../318394/index.html">Camouflage and video game feedback</a></li>
<li><a href="../318398/index.html">And again about recursive queries</a></li>
<li><a href="../318400/index.html">We search and download unpopular and old files on the Internet</a></li>
<li><a href="../318404/index.html">The digest of fresh materials from the world of frontend for the last week ‚Ññ242 (December 18 - 25, 2016)</a></li>
<li><a href="../318406/index.html">Google: Security Keys - the best way to secure your account</a></li>
<li><a href="../318410/index.html">PHP Digest number 99 - the results of 2016 and a selection of interesting links (December 11 - 25, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>