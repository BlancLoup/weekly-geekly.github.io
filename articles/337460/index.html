<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS works: about the V8 internals and code optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[We advise you to read] Other 19 parts of the cycle  Part 1: Overview of the engine, execution time mechanisms, call stack 
 Part 2: About the V8 inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS works: about the V8 internals and code optimization</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br>  Before you - the second material from the series, dedicated to the features of the work of JavaScript on the example of the V8 engine.  The <a href="https://habrahabr.ru/company/ruvds/blog/337042/">first</a> dealt with the V8 runtime mechanisms and the call stack.  Today we will delve into the features of V8, thanks to which the source code in JS becomes an executable program, and share tips on optimizing the code. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/337460/"><img src="https://habrastorage.org/web/943/041/288/9430412889624157ba2482b65b11d955.jpg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">About JS engines</font> </h2><br>  A JavaScript engine is a program, or in other words, an interpreter, that executes code written in JavaScript.  The engine can be implemented using various approaches: as a normal interpreter, as a dynamic compiler (or JIT compiler), which, before executing the program, converts the source code in JS into byte code of a certain format. <br><br>  Here is a list of popular implementations of JavaScript engines. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://en.wikipedia.org/wiki/V8_%2528JavaScript_engine%2529">V8</a> is an open source engine written in C ++, developed by Google. <br></li><li>  <a href="https://en.wikipedia.org/wiki/Rhino_%2528JavaScript_engine%2529">Rhino</a> - this open source engine supports the Mozilla Foundation, it is completely written in Java. <br></li><li>  <a href="https://en.wikipedia.org/wiki/SpiderMonkey_%2528JavaScript_engine%2529">SpiderMonkey</a> is the very first JS engine that appeared in the past, which was used in the Netscape Navigator browser, and today in Firefox. <br></li><li>  <a href="https://en.wikipedia.org/wiki/JavaScriptCore">JavaScriptCore</a> is another open source engine known as Nitro and developed by Apple for the Safari browser. <br></li><li>  <a href="https://en.wikipedia.org/wiki/KJS_%2528KDE%2529">KJS</a> is a KDE JS engine that developed Harry Porten for the Konqueror browser included in the KDE project. <br></li><li>  <a href="https://en.wikipedia.org/wiki/JScript">Chakra (JScript9)</a> is an Internet Explorer engine. <br></li><li>  <a href="https://en.wikipedia.org/wiki/Chakra_%2528JavaScript_engine%2529">Chakra (JavaScript)</a> is a Microsoft Edge engine. <br></li><li>  <a href="https://en.wikipedia.org/wiki/Nashorn_%2528JavaScript_engine%2529">Nashorn</a> is an open source engine that is part of OpenJDK, which Oracle does. <br></li><li>  <a href="https://en.wikipedia.org/wiki/JerryScript">JerryScript</a> is a lightweight engine for the Internet of things. <br></li></ul><br>  In this article we will focus on the features of the V8. <br><br><h2>  <font color="#3AC1EF">Why was the V8 engine created?</font> </h2><br>  The open source engine V8 was created by Google, it is written in C ++.  The engine is used in the Google Chrome browser.  In addition to what distinguishes V8 from other engines, it is used in the popular Node.js server environment. <br><img src="https://habrastorage.org/getpro/habr/post_images/486/f41/b75/486f41b75341debfac4fa3aff0d0da6a.png"><br>  <i><font color="#999999">V8 logo</font></i> <br><br>  When designing V8, developers set out to improve JavaScript performance in browsers.  In order to achieve high speed program execution, V8 translates the JS code into more efficient machine code without using an interpreter.  The engine compiles JavaScript code into machine instructions during program execution, implementing a dynamic compilation mechanism, like many modern JavaScript engines, for example, SpiderMonkey and Rhino (Mozilla).  The main difference is that V8 does not use bytecode or any intermediate code when executing JS programs. <br><br><h2>  <font color="#3AC1EF">About the two compilers used in V8</font> </h2><br>  The internal structure of the V8 has changed with the release of version 5.9, which appeared only recently.  Before that, he used two compilers: <br><br><ul><li>  full-codegen is a simple and very fast compiler that produces relatively slow machine code. <br></li><li>  Crankshaft is a more complex optimizing JIT compiler that generates well-optimized code. <br></li></ul><br>  There are several threads inside the engine: <br><br><ul><li>  The main thread that does what you can expect from it: reads the original JS code, compiles it and executes it. <br></li><li>  A compilation flow that optimizes code while the main thread is running. <br></li><li>  The profiler thread, which tells the system which methods the program spends the most time on, as a result, Crankshaft can optimize these methods. <br></li><li>  Multiple threads that support garbage collection. <br></li></ul><br>  During the first execution of the JS code, the V8 uses the full-codegen compiler, which directly, without any additional transformations, translates the JavaScript code compiled by it into machine code.  This allows you to very quickly start the execution of machine code.  Please note that V8 does not use an intermediate bytecode representation of the program, thus eliminating the need for an interpreter. <br><br>  After the code has worked for some time, the profiler thread will collect enough data so that the system can figure out which methods need to be optimized. <br><br>  Next, in another thread, the optimization starts with Crankshaft.  It converts an abstract JavaScript syntax tree into a high-level representation using the static single-assignment (SSA) model.  This presentation is called Hydrogen.  Crankshaft then attempts to optimize the Hydrogen control flow graph.  Most optimizations are done at this level. <br><br><h2>  <font color="#3AC1EF">Embed code</font> </h2><br>  The first optimization of the program is to embed as much code as possible into the call sites in advance.  Embedding code is the process of replacing a function call command (the line where the function is called) on its body.  This simple step allows you to make the following optimizations more productive. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05d/a01/726/05da01726cdd03f6d9336bd1d1e49c2e.png"></div><br>  <i><font color="#999999">The function call is replaced with its body.</font></i> <br><br><h2>  <font color="#3AC1EF">Hidden Classes</font> </h2><br>  JavaScript is a prototype based language: there are no classes here.  Objects here are created using the cloning process.  In addition, JS is a dynamic programming language, which means that after creating an instance of an object, you can add new properties to it and remove existing properties from it. <br><br>  Most JS interpreters use structures resembling dictionaries (based on using <a href="http://en.wikipedia.org/wiki/Hash_function">hash functions</a> ) to store information about the location of property values ‚Äã‚Äãof objects in memory.  Using such structures makes retrieving property values ‚Äã‚Äãin JavaScript more difficult than non-dynamic languages ‚Äã‚Äãsuch as Java and C #.  In Java, for example, all object properties are determined by the object scheme that does not change after compiling a program, they cannot be added or removed dynamically (it should be noted that C # has a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic">dynamic</a> type, but here we can ignore this).  As a result, property values ‚Äã‚Äã(or pointers to these properties) can be stored, with a fixed offset, as a continuous buffer in memory.  The offset step can be easily determined based on the type of the property, while in JavaScript this is not possible, since the type of the property can change during the execution of the program. <br><br>  Since using dictionaries to find out the addresses of object properties in memory is very inefficient, V8 uses another method instead: hidden classes.  Hidden classes are similar to ordinary classes in a typical object-oriented programming language, such as Java, except that they are created during program execution.  Let's see how it all works, in the following example: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  When <code>new Point(1, 2)</code> is called, V8 creates the hidden class <code>C0</code> . <br><img src="https://habrastorage.org/web/3d0/84e/665/3d084e665eff4c868f6abc09a6cb5cf1.jpg"><br>  <i><font color="#999999">First hidden class C0</font></i> <br><br>  So far, before the execution of the constructor, the <code>Point</code> object has no properties, so the class <code>C0</code> empty. <br><br>  As soon as the first command in the <code>Point</code> function is executed, V8 will create a second hidden class, <code>C1</code> , which is based on <code>C0</code> .  <code>C1</code> describes the memory location (relative to the object pointer) where the <code>x</code> property can be found.  In this case, the x property is stored at <a href="https://en.wikipedia.org/wiki/Offset_%2528computer_science%2529">offset</a> 0, which means that if we consider the <code>Point</code> object in memory as a continuous buffer, the first offset corresponds to property <code>x</code> .  In addition, V8 will add information about the transition to class <code>C1</code> to class <code>C0</code> , where it is stated that if the <code>x</code> property is added to the <code>Point</code> object, the hidden class needs to be changed from <code>C0</code> to <code>C1</code> .  The hidden class for the <code>Point</code> object, as shown in the figure below, has now become a <code>1</code> class. <br><br><img src="https://habrastorage.org/web/4f8/210/0d4/4f82100d46b84183a50a626111de2c5f.jpg"><br>  <i><font color="#999999">Every time a new property is added to an object, information about the transition to the new hidden class is added to the old hidden class.</font></i>  <i><font color="#999999">Transitions between hidden classes are important because they allow objects that are created in the same way to have the same hidden classes.</font></i>  <i><font color="#999999">If two objects have a common hidden class and the same property is added to them, the transitions ensure that both objects receive the same new hidden class and all the optimized code that comes with it.</font></i> <br><br>  This process is repeated when <code>this.y = y</code> command is <code>this.y = y</code> (again, this is done inside the <code>Point</code> function, after the above command for adding the <code>x</code> property). <br><br>  A new hidden class is created here, <code>C2</code> , and the information about the transition is added to the <code>C1</code> class, where it is indicated that if the property <code>y</code> added to the <code>Point</code> object (this is an object that already contains the <code>x</code> property), then the hidden object class should change to <code>C2</code> . <br><br><img src="https://habrastorage.org/web/80d/221/e49/80d221e494cc43cb8865b81df04be730.jpg"><br>  <i><font color="#999999">Transition to use class C2 after adding a property to the object y</font></i> <br><br>  Transitions between hidden classes depend on the order in which properties are added to an object.  Take a look at this sample code: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); p1.a = <span class="hljs-number"><span class="hljs-number">5</span></span>; p1.b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); p2.b = <span class="hljs-number"><span class="hljs-number">7</span></span>; p2.a = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br>  In this situation, it can be assumed that the objects <code>p1</code> and <code>p2</code> will have the same hidden class and the same transition tree of hidden classes.  However, in fact it is not.  Property <code>a</code> added to <code>p1</code> first, and then property <code>b</code> .  In the <code>p2</code> object, first add the property <code>b</code> , and then - <code>a</code> .  As a result, objects <code>p1</code> and <code>p2</code> will have different hidden classes - the result of different paths of transitions between hidden classes.  In such cases, it is much better to initialize dynamic properties in the same order so that hidden classes can be reused. <br><br><h2>  <font color="#3AC1EF">Built-in caches</font> </h2><br>  V8 uses a different technique to optimize the execution of dynamically typed languages, called the built-in call cache.  Built-in caching is based on observation, which is that repeated calls to the same method tend to occur using objects of the same type.  More details about this can be found <a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches">here</a> .  If you don‚Äôt have time to go into it too deeply, reading the above material, here we present the concept of embedded caching in just a few words. <br><br>  So how does all this work?  V8 maintains a cache of object types, which we passed as a parameter to recently called methods, and uses this information to make an assumption about the types of objects that will be passed as parameters in the future.  If V8 was able to make a correct assumption about the type of object that will be passed to the method, it can skip the process of figuring out how to access object properties and, instead, use the stored information from previous calls to the hidden object class. <br><br>  How are the concepts of hidden classes and built-in call caches related?  When a method is invoked for an object, the V8 engine must refer to the hidden class of this object in order to determine the offset for accessing a particular property.  After two successful invocations of the same method to the same hidden class, V8 omits the operation of accessing the hidden class and simply adds information about the displacement of the property to the object pointer itself.  When making calls to this method in the future, V8 <i><font color="#999999">assumes</font></i> that the hidden class has not changed and goes straight to the memory address for a particular property, using the offset saved after previous calls to the hidden class.  This greatly increases the speed of code execution. <br><br>  In-built call caching, moreover, is the reason why it is so important that objects of the same type use common hidden classes.  If you create two objects of the same type, but with different hidden classes (as was done in the example above), V8 will not be able to use built-in caching, since even though the objects are of the same type, their corresponding hidden classes are assigned properties. <br><br><img src="https://habrastorage.org/web/c28/006/adf/c28006adf58644e19ca0487ca318dfdd.jpg"><br>  <i><font color="#999999">Before us are objects of the same type, but their properties a and b were created in a different order and have a different offset</font></i> <br><br><h2>  <font color="#3AC1EF">Compile into machine code</font> </h2><br>  Once the Hydrogen graph is optimized, Crankshaft translates it into a low-level representation called Lithium.  Most Lithium implementations are system dependent.  At this level, for example, register allocation occurs. <br><br>  As a result, the Lithium representation is compiled into machine code.  Then what happens is called a stack replacement (on-stack replacement, OSR).  Before compiling and optimizing methods in which a program spends a lot of time, you will need to work with their non-optimized options.  Then, without interrupting the work, V8 transforms the context (stack, registers) so that you can switch to an optimized version of the code.  This is a very difficult task, considering that among other optimizations, V8 initially performs embedding of the code.  V8 - not the only engine that can do this. <br><br>  What if optimization failed?  From this there is a defense - the so-called de-optimization.  It is aimed at reverse transformation, returning the system to the use of non-optimized code in the event that the assumptions made by the engine and underlying the optimization, no longer correspond to reality. <br><br><h2>  <font color="#3AC1EF">Garbage collection</font> </h2><br>  For garbage collection, the V8 uses the traditional ‚Äúmark-and-sweep‚Äù genealogical approach to mark and clean up previous generations of code.  The marking phase involves stopping the execution of javascript.  In order to control the load on the system created by the garbage collector and make code execution more stable, V8 uses an incremental labeling algorithm: instead of bypassing the entire heap, it tries to mark everything that it can bypassing only part of the heap.  Then normal code execution resumes.  The next pass of the garbage collector along the pile begins where the previous one ended.  This allows for very short pauses during normal code execution.  As already mentioned, the separate threads deal with the cleaning phase. <br><br><h2>  <font color="#3AC1EF">Ignition and TurboFan</font> </h2><br>  With the release of this year V8 version 5.9.  A new code execution pipeline was introduced.  This pipeline allows you to achieve even greater performance improvements and significant memory savings, moreover, not in tests, but in real JavaScript applications. <br><br>  The new system is based on <a href="https://github.com/v8/v8/wiki/Interpreter">the Ingnition interpreter</a> and the latest <a href="https://github.com/v8/v8/wiki/TurboFan">TurboFan</a> optimizing compiler.  Details on these new V8 mechanisms can be found in <a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html">this</a> article. <br><br>  With the release of V8 5.9 full-codegen and Crankshaft (the technologies that have been used in V8 since 2010) will no longer be used.  The V8 team develops new tools, trying to keep up with new JavaScript features and implement the optimizations needed to support these features.  The transition to new technologies and the abandonment of support for old mechanisms means the development of V8 in the direction of a simpler and more well-managed architecture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73e/e4a/0c4/73ee4a0c446f749e046cf7ac43e65678.png"></div><br>  <i><font color="#999999">Performance test enhancements for browser and server JS use cases</font></i> <br><br>  These improvements are just the beginning.  The new code execution pipeline based on Ignition and TurboFan opens the way to further optimizations that will improve JavaScript performance and make V8 more economical. <br><br>  We looked at some of the features of V8, and now we will give some tips on code optimization.  In fact, by the way, all this can be easily derived from what we have said above. <br><br><h2>  <font color="#3AC1EF">Approaches to optimizing JavaScript code for V8</font> </h2><br><ol><li>  <b>The order of properties of objects</b> .  Always initialize the properties of objects in the same order.  It is necessary for identical objects to use the same hidden classes, and, as a result, optimized code. <br></li><li>  <b>Dynamic properties</b> .  Adding properties to objects after creating an object instance will change the hidden class and slow down the methods that have been optimized for the hidden class used by objects earlier.  Instead of adding properties dynamically, assign them in the object's constructor. <br></li><li>  <b>Methods</b>  Code that calls the same method several times will run faster than code that calls several different methods once (due to embedded caches). <br></li><li>  <b>Arrays</b>  Avoid sparse arrays whose keys are not consecutive numbers.  A sparse array, that is, an array, some of the elements of which are missing, will be treated by the system as a hash table.  To access the elements of such an array requires more computing resources.  In addition, try to avoid early allocation of memory for large arrays.  It is better if their size increases as needed.  And finally, do not delete the elements in the arrays.  Because of this, they turn into sparse arrays. <br></li><li>  <b>Numbers</b>  V8 represents numbers and pointers to objects using 32 bits.  It uses one bit to determine if a certain 32-bit value is a pointer to an object (flag - 1), or an integer (flag - 0), which is called a small integer (SMall Integer, SMI) because that its length is 31 bits.  If more than 31 bits are needed to store a numeric value, V8 will pack the number, turning it into a double precision number and creating a new object to put that number into it.  Try to use signed 31-bit numbers wherever possible in order to avoid the resource-intensive operations of packing numbers into JS objects. <br></li></ol><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We, in SessionStack, try to follow the above principles when writing JS-code.  We hope, having a little understood how the internal mechanisms of the V8 work, and taking into account what we have said above, you can improve the quality and performance of your programs. <br><br>  Dear readers!  What tips for JS code optimization can you share? </div><p>Source: <a href="https://habr.com/ru/post/337460/">https://habr.com/ru/post/337460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337450/index.html">CSS immersion: font metrics, line-height and vertical-align</a></li>
<li><a href="../337452/index.html">Record of the webinar ‚ÄúHow expert information and a model for predicting malicious behavior help protect companies‚Äù</a></li>
<li><a href="../337454/index.html">A set of useful tips for the effective use of FreeIPA</a></li>
<li><a href="../337456/index.html">The Internet of Things is Popular: Why We Stop Walking the Dogs</a></li>
<li><a href="../337458/index.html">15 years at ISDEF: the experience of the oldest participant</a></li>
<li><a href="../337464/index.html">let's live in peace</a></li>
<li><a href="../337466/index.html">Data Science Week 2017: The market is becoming more mature</a></li>
<li><a href="../337468/index.html">Creating an IT self-service portal using the example of MS SCCM and ServiceNow integration. Part 2</a></li>
<li><a href="../337470/index.html">Don't growl at a freelancer</a></li>
<li><a href="../337472/index.html">Bug hunters: ASCON testers pass the test with tricky questions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>