<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ Type Classes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It has already been described how to implement monads in C ++ without type classes . I want to show how you can implement type classes using the monad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ Type Classes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/93f/362/32d/93f36232da88c1dec217327c77cf6982.gif" align="right"><br>  It has already been described <a href="http://habrahabr.ru/post/205026/">how to implement monads in C ++</a> without <a href="http://en.wikipedia.org/wiki/Type_class">type classes</a> .  I want to show how you can implement type classes using the monad as an example. <br>  This technique is widely used in the Scala language, but can also be used in C ++.  I briefly described it as an illustration of the difficulties of a <a href="http://habrahabr.ru/post/204124/">unified library description</a> , but now I will demonstrate its implementation. <br>  It should be noted that type classes are used not only in declarative languages ‚Äã‚Äãlike Haskell and Mercurry, but they are reflected in rather classical Go and Rust. <br>  This technique is also suitable for implementing multi methods from Common Lisp and Clojure. <br><br>  I haven't taken C ++ in my hands for six years, so the code may not be ideal and not use new (useful) features. <br>  In addition, I completely ignore the problem of memory management - C ++ practitioners will do it better than me. <br>  The efficiency of the code was checked on gcc 4.7.3. <br><br><a name="habracut"></a><br>  The main idea of ‚Äã‚Äãtype classes is to separate the interface implementation from the data structure.  The same interface can be used to work with completely different data structures, and for each data type must be implemented separately.  Code using this interface is not required to know the details of its implementation. <br>  With complexity monads, it adds that this interface is implemented for a generic type that is parameterized by another type. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The interface implementation must be stored somewhere, and we only have classes for this: <br><pre><code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stddef.h&gt;</span></span></span><span class="hljs-meta"> template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;typename _&gt;</span></span></span><span class="hljs-meta"> class M&gt; class monadVTBL { public: template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename v, typename x&gt;</span></span></span><span class="hljs-meta"> static M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> bind(M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;x&gt;</span></span></span><span class="hljs-meta">, M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta">(*)(x)); template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename v&gt;</span></span></span><span class="hljs-meta"> static M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> mreturn(v); }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;typename _&gt;</span></span></span><span class="hljs-meta"> class M, typename v, typename x&gt; M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> bind(M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;x&gt;</span></span></span><span class="hljs-meta"> i, M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta">(*f)(x), monadVTBL</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;M&gt;</span></span></span><span class="hljs-meta"> *tbl = NULL) { return monadVTBL</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;M&gt;</span></span></span><span class="hljs-meta">::bind(i, f); } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;typename _&gt;</span></span></span><span class="hljs-meta"> class M, typename v&gt; M</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> mreturn(vi, monadVTBL</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;M&gt;</span></span></span><span class="hljs-meta"> *tbl = NULL) { return monadVTBL</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;M&gt;</span></span></span><span class="hljs-meta">::mreturn(i); }</span></span></code> </pre> <br>  As we see, the implementation is passed to the functions using it as an additional parameter with the default value.  In this case, we need only the type of this parameter (for this reason it is always NULL), and we could transfer it to a local variable.  The use of the parameter provides additional flexibility, which, with some effort, will save memory on instantiating templates (functions will have to be hidden in classes that inherit the implementation of generalized functions through void *) and will be useful for implementing multi-methods. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">&lt;char&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mreturn&lt;M,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(c+<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  A fairly simple function using the monad. <br>  On Haskell, she will crawl <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">inc</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; m <span class="hljs-type"><span class="hljs-type">Char</span></span> inc c = return (succ c)</code> </pre><br>  return here means completely different than in C ++. <br><br>  We now turn to the implementation of the monad IO.  The objects that the monad interface works with in this case are I / O operations.  In Haskell, these are normal values; in C ++, they will be modeled by classes. <br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename v&gt;</span></span></span><span class="hljs-meta"> class IOop { public: virtual v run() = 0; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename v&gt;</span></span></span><span class="hljs-meta"> class IOm { public: IOop</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> *op; IOm(IOop</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> *o) { op = o; } v run() { op-&gt;run(); } };</span></span></code> </pre><br>  The run method performs this operation (in Haskell, in fact, it is called by the runtime system on the main object). <br>  The IOm container class is needed to hide the type of operation, which can be of variable size. <br>  As we see, these classes do not connect anything other than the name with monads, and they don‚Äôt know anything about monads.  This is an important advantage of type classes over ordinary classes that need to know their interface. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getChar</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOop&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: getChar() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getchar(); } } _getChar[<span class="hljs-number"><span class="hljs-number">1</span></span>]; IOm&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; getChar(_getChar); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class"> {</span></span> } unit; unit Unit; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putChar</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOop&lt;unit&gt; { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> v; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: _putChar(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c) { v = c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> unit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">putchar</span></span>(v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOm</span></span></span><span class="hljs-class">&lt;unit&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putChar</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">) {</span></span> IOm&lt;unit&gt; o(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _putChar(c)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; };</code> </pre><br>  And here are two specific I / O operations ‚Äî get the character from the standard input and output the character to the standard output.  As well as a function that turns a character into an operation that outputs it. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> v&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mconst</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOop&lt;v&gt; { vr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: mconst(vx) { r=x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> v </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } };</code> </pre><br>  This class implements the monadic ‚Äúreturn‚Äù operation, which in this case creates an I / O operation, which always ‚Äúinputs‚Äù a constant. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> v, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> i&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbind</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOop&lt;v&gt; { IOop&lt;i&gt; *s; IOm&lt;v&gt; (*f)(i); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">v </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*f)(s-&gt;run()).run(); } mbind(IOop&lt;i&gt; *x, IOm&lt;v&gt; (*g)(i)) { s=x; f=g; } };</code> </pre><br>  And this operation "&gt;&gt; =", which links the monad with the generator of the new monad. <br><br><pre> <code class="hljs ruby">template&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">monadVTBL</span></span></span><span class="hljs-class">&lt;IOm&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOm</span></span></span><span class="hljs-class">&lt;v&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOm</span></span></span><span class="hljs-class">&lt;i&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOm</span></span></span><span class="hljs-class">&lt;v&gt;(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">)) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOm</span></span></span><span class="hljs-class">&lt;v&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbind</span></span></span><span class="hljs-class">&lt;v,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">));</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } template&lt;typename v&gt; static IOm&lt;v&gt; mreturn(vx) { IOm&lt;v&gt; r(new mconst&lt;v&gt;(x)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } };</code> </pre><br>  And here is the most important thing - specialization of the monad implementation for IO. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> i&gt; IOm&lt;unit&gt; ignNL(iv) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind&lt;IOm,unit,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(mreturn&lt;IOm,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>),putChar); }</code> </pre><br>  This is an IO generator that ignores the result of the previous monad and prints '\ n'. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ign</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () ign _ = putChar '\n'</code> </pre><br>  For IO (and some other monads, for example parsers), ignoring the previous monad is quite a popular operation and for it there is a function: <br><pre> <code class="haskell hljs">(&gt;&gt;) :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; ma -&gt; mb -&gt; mb a &gt;&gt; b = a &gt;&gt;= \_ -&gt; b</code> </pre><br><br>  And now let's check how it all works: <br><pre> <code class="hljs xml">bind<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IOm,unit,unit</span></span></span><span class="hljs-tag">&gt;</span></span>(bind<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IOm,unit,char</span></span></span><span class="hljs-tag">&gt;</span></span>(bind<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IOm,char,char</span></span></span><span class="hljs-tag">&gt;</span></span>(getChar,inc),putChar),ignNL<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">unit</span></span></span><span class="hljs-tag">&gt;</span></span>).run();</code> </pre><br>  We read a character from standard input, increment it, print it, and print a newline. <br><br>  And now we are implementing the monad interface for another class that knows even less about monads. <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt;</span></span></span><span class="hljs-meta"> template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename v&gt;</span></span></span><span class="hljs-meta"> class myvector: public std::vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;v&gt;</span></span></span><span class="hljs-meta"> { };</span></span></code> </pre><br>  Unfortunately, the std :: vector template has two parameters (the second is responsible for the allocation policy and can be substituted by default).  Modern gcc does not allow it to be transferred to a template that waits for a template with one parameter (if memory serves me, before there were no such strictness).  So you have to create a simple wrapper. <br><br><pre> <code class="hljs ruby">template&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">monadVTBL</span></span></span><span class="hljs-class">&lt;myvector&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myvector</span></span></span><span class="hljs-class">&lt;v&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myvector</span></span></span><span class="hljs-class">&lt;i&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myvector</span></span></span><span class="hljs-class">&lt;v&gt;(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">)){ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myvector</span></span></span><span class="hljs-class">&lt;v&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(typename myvector&lt;i&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:iterator</span></span> it = x.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(); it != x.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++it) { myvector&lt;v&gt; c = f(*it); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(typename myvector&lt;v&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:iterator</span></span> i = c.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(); i != c.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++i) { e.push_back(*i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; } template&lt;typename v&gt; static myvector&lt;v&gt; mreturn(vx) { myvector&lt;v&gt; e; e.push_back(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; } };</code> </pre><br>  The functionality of the monad std :: vector is similar to the functionality of the monad List in Haskell. <br><br>  We try how it works: <br><br><pre> <code class="hljs cpp"> myvector&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; x; x.push_back(<span class="hljs-string"><span class="hljs-string">'q'</span></span>); x.push_back(<span class="hljs-string"><span class="hljs-string">'w'</span></span>); x.push_back(<span class="hljs-string"><span class="hljs-string">'e'</span></span>); myvector&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; z = bind&lt;myvector,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(x,inc); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> myvector&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;::iterator i = z.begin(); i != z.end(); ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *i; }</code> </pre><br>  For such functionality, the ‚Äúfunctor‚Äù type class would be enough, but I did not want to invent a more complex example. </div><p>Source: <a href="https://habr.com/ru/post/205482/">https://habr.com/ru/post/205482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205466/index.html">Development of Windows 8.1 applications on XAML / –° #. Part 3. Toolbars</a></li>
<li><a href="../205472/index.html">turbofilm.tv blocked</a></li>
<li><a href="../205476/index.html">Rake using common .dll</a></li>
<li><a href="../205478/index.html">Virtual Trading: the first step in the stock market</a></li>
<li><a href="../205480/index.html">ADI method for direct observation of exoplanets - how it works</a></li>
<li><a href="../205484/index.html">Hood timer</a></li>
<li><a href="../205486/index.html">Intel 8051. 30 years in devices, devices and soft toys</a></li>
<li><a href="../205490/index.html">IT was not expected</a></li>
<li><a href="../205492/index.html">CodeIgniter is more beautiful thanks to Bonfire</a></li>
<li><a href="../205494/index.html">As an ordinary field, it has become an ultra-modern Google data center priced at one and a half billion dollars.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>