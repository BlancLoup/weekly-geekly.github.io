<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Badoo PHP framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The code of our site has seen more than one version of PHP. He was repeatedly supplemented, corresponded, modified, refactored - in general, he lived ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Badoo PHP framework</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d7d/e0f/a46/d7de0fa460e940ceb32301b5799e3b3c.jpg" align="left">  The code of our site has seen more than one version of PHP.  He was repeatedly supplemented, corresponded, modified, refactored - in general, he lived and developed his life.  At this time, new best practices, approaches, frameworks and other similar phenomena appeared and disappeared in the world, facilitating the life of a developer and ready to solve all the main problems arising in the process of creating websites. <br>  In this article we will talk about our path: how the code was originally organized, what problems arose and how the current framework appeared. <br><br><h4>  What happened </h4><br>  The project began to do in 2005.  Then there were no hard and fast rules for writing code and a clearly structured framework.  The code was written by several developers, they were easily guided and supported by it, each adding something different.  At that time, the frameworks that are currently known were only being created, so there were few examples to follow.  So we can say that our framework was formed spontaneously. <br><br>  From an architectural point of view, it looked like this: there were page objects inherited from a whole hierarchy of base classes responsible for initializing the environment, session, user, etc.  Each page itself decided when, how and what to display, redirect, etc.  In the hierarchy of base classes, many auxiliary functions were collected for initializing and generating standard page blocks, checking users, displaying intermediate promotional pages, etc.  Over time, most of them were redefined by heirs beyond recognition, which at times complicated both the understanding of how the site works and the code support itself. <br><a name="habracut"></a><br>  There were packages ‚Äî sets of classes that pages accessed to retrieve data or process in some way.  There were presentations that were responsible for templating and outputting.  In the usual case, each page received some data, passed them to the View class, which placed them into the structure of the blitz-template and output them.  It so happened that each page had its own template (there was no base one), and it differed in the set of plug-in scripts, styles and the central part. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In principle, it looked like a regular MVC-like scheme.  But without a clear organization of the code and with an increase in the number of developers, such code has become increasingly difficult to maintain. <br><br>  What, in fact, did not suit us and needed to be improved? <br><br>  <b>1. Use global context and static variables.</b> <br>  On the one hand, it is convenient when you can get a global object from anywhere in the code.  On the other hand, it becomes dependent, connectivity increases.  With the beginning of unit testing, we realized that such code is terribly hard to test: the first test easily breaks the next one, it is necessary to follow this very tightly.  In addition, code that uses global objects, and does not have only input and output, requires many mock objects for testing. <br><br>  <b>2. Most connected controllers with views.</b> <br>  Data preparation often took place for a specific View, i.e., for a specific template.  Entire hierarchies of controllers inherited from each other, collect data for a blitz pattern in parts.  Maintaining this code is extremely difficult.  Creating a version with a completely different template (for example, a mobile version) sometimes became almost an impossible task, so it was easier to write everything from scratch. <br><br>  <b>3. The use of public properties as the norm.</b> <br>  Initially, PHP did not support private properties of objects.  Since our code has a fairly large history, there are many places left where properties are declared through var, and a lot of code that uses it.  It is quite normal to meet an object that is transferred to another object, and that one establishes something or produces some manipulations with the properties of the first one.  Such code is very difficult to understand and debug.  Ideally, you should always do getters and setters for class properties - this will save a lot of time and nerves for you and your colleagues! <br><br>  <b>4. Associative arrays as a container for passing parameters.</b> <br>  The big problem for us was that the data obtained from one source is transferred to some kind of handler or controller, and on the way there anything can be written in unlimited quantities.  As a result, all this is constantly overgrown with new parameters and in this form is sent to the View class.  Although it would be better to use some type or interface to avoid chaos. <br><br>  <b>5. The lack of a single entry point.</b> <br>  Each page is a separate php file containing a class inherited from the base one.  If the input data in such a scheme can be controlled in one place, then it will be extremely difficult to do something massively at the output.  Establishing a route other than the name of a folder, file, or containing variables requires editing nginx configs.  This complicates testing in a standard workflow, requires additional access and is more difficult to maintain with a large number of developers. <br><br><h4>  New tasks for the framework </h4><br>  Naturally, we wanted to solve most of the above problems.  We wanted to be able to "out of the box" display the same data in a different representation (JSON, mobile or web version).  Prior to this, the problem was solved only by a set of IFs in each specific case. <br><br>  Of course, the new framework should have been fairly easily compatible with the old code, and not cause the developers difficulties during the transition.  That is why we did not switch to popular frameworks, but only used some of the ideas from them.  It would be much more difficult to retrain everyone to write for a particular popular framework.  In addition, we have a lot of code, standard components sharpened for us, which are in any framework, and we would not have to carry out a very simple integration. <br><br>  When designing, we tried to make the framework as convenient as possible for the developer to make it easy to use auto-substitutions, code generation and other useful functions that speed up and simplify development and, importantly, refactoring. <br><br><h4>  What is the architecture of the framework? </h4><br>  Based on global environment variables, a Request object is created, which is passed to the application to receive a response. <br><br><pre><code class="php hljs">$Request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request($_GET, $_POST, $_COOKIE, $_SERVER); $App = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(); $Response = $App-&gt;handle($Request); $Response-&gt;send();</code> </pre> <br>  In the course of operation, the application generates the "Received request", "Found controller", "Received data", "Caught an exception", "Render data", "Received response" events. <br><br><pre> <code class="php hljs">$Dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventDispatcher(); $Dispatcher-&gt;setListeners($Request-&gt;getProject()-&gt;loadListeners()); $RequestEvent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event_ApplicationRequest($Request); $Dispatcher-&gt;dispatch($RequestEvent);</code> </pre><br>  For each event there is a set of subscribers who react in a special way.  For example, Listener_Router on the client (mainly on HTTP_USER_AGENT) and the value REQUEST_URI finds the controller (for example, Controller_Mobile_Index) and sets it to the event object.  After dispatching this event, the application either calls the controller it finds or throws the Exception_HttpNotFound exception, which will be output as a response from the 404 server. Example list of subscribers: <br><br><pre> <code class="php hljs">$listeners = [ \Framework\Event_ApplicationRequest::class =&gt; [ [\Framework\Listener_Platform::class, <span class="hljs-string"><span class="hljs-string">'onApplicationRequest'</span></span>], [\Framework\Listener_Client::class, <span class="hljs-string"><span class="hljs-string">'onApplicationRequest'</span></span>], [\Framework\Listener_Router::class, <span class="hljs-string"><span class="hljs-string">'onApplicationRequest'</span></span>], ], ];</code> </pre><br>  Each controller is a separate class with a set of methods - action-s.  The framework finds a corresponding class and method on the route map, creates an Action object (for convenience, instead of a callable array).  Example route map: <br><br><pre> <code class="php hljs">$routes = [ Routes::PAGE_INDEX =&gt; [ <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; [Controller_Index::class, <span class="hljs-string"><span class="hljs-string">'actionIndex'</span></span>], ], Routes::PAGE_PROFILE =&gt; [ <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/profile/{user_login}'</span></span>, <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; [Controller_Profile::class, <span class="hljs-string"><span class="hljs-string">'actionProfile'</span></span>], ], ];</code> </pre><br>  In the route array are the base classes.  If the class has an inheritor for the current client, then it will be used.  Route names in constants allow you to conveniently generate URLs anywhere in the project. <br><br>  Then the event ‚Äúcontroller found‚Äù is dispatched.  The behavior of the subscribers of this event can be controlled from the controller. <br><br><pre> <code class="php hljs">$ActionEvent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event_ApplicationAction($Request, $RequestEvent-&gt;getAction()); $Dispatcher-&gt;dispatch($ActionEvent);</code> </pre><br>  For example, for all controllers accessed by JavaScript, we automatically check the request-token to protect against CSRF vulnerabilities.  A separate class Listener_WebService is responsible for this.  But there are services for which we do not need it.  In this case, the controller inherits the Listener_WebServiceTokenCheckInterface interface and implements the checkToken method: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($method_name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  Here $ method_name is the name of the controller method to be called. <br><br>  For working with data (for example, loading from a database) we have packages that are sets of classes combined in one application area.  The controller receives data from the packets and, instead of using an array to transfer data to the View, sets it into a ViewModel object ‚Äî in fact, into a container with a set of setters and getters.  Due to this, inside the View it is always known what data is transferred.  If the data set changes, all uses of the ViewModel class methods can be easily found and corrected as needed.  If it were an array, we would have to search around the repository, and then among all the entries, especially if the array key is called a simple and common word, for example, ‚Äúname‚Äù. <br><br>  Although such an abundance of classes may seem superfluous, but in a large project with a large number of developers, this greatly helps with the support of the code.  At first, we made it possible to set the data immediately in View, but quickly abandoned it, because we may have more than one project that requires the same controller, but the data is displayed differently.  In any case, you will have to create a ViewModel and make additional View, so it‚Äôs better to write a little more code right away, which will save you from refactoring and additional testing in the future.  Now we are considering different options for optimization, since many developers believe that there is a lot of code. <br><br>  Based on the received data, View prepares the final result - this is a string or a special ParseResult object.  This is done to implement deferred rendering: all the data is first prepared, and only then the final rendering is done all at once.  The most frequent case is the creation of a page based on a blitz-template and some data inserted into it.  In this case, the ParseResult object will contain the name of the template and an array with data ready for templating, which you need at the right time to send to Blitz and get the resulting HTML.  Data for templating can contain nested ParseResult objects, so the final rendering is recursive.  Here you want to warn you against using the array_walk_recursive function: it goes not only in arrays, but also in public properties of objects.  In this regard, some pages have fallen from memory until we have made our own simple recursive function: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayWalkRecursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data, $function)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_array($data)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_user_func($function, $data); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $k =&gt; $item) { $data[$k] = arrayWalkRecursive($item, $function); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $data; }</code> </pre><br>  Since the communication between PHP and JavaScript is very close, we have implemented appropriate support for it.  Each View object is a specific block on the site: header, sidebar, footer, central part, etc.  For each block or component there can be its own JavaScript handler, which is configured using a specific data set - js_vars.  For example, settings for a comet connection are sent via js_vars, through which various updates come - counters, pop-up notifications, etc.  All such data is transmitted through a single point defined in the blitz-template: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> $vars = {{JS_VARS}}; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In addition, we have controllers that are only accessed by JS and receive as a result JSON.  We call them web services.  Relatively recently, we began to describe the protocol of communication PHP and JS using Google Protocol Buffers (protobuf).  Based on proto-files, PHP-classes with a set of setters are generated that automatically validate the data set in them, which allows one to formalize the agreement between the front-end and back-end developers in an optimal way.  Below is an example of a proto file for describing the overlay and using the PHP class generated from it: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> base; message Ovl { optional <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> html = <span class="hljs-number"><span class="hljs-number">1</span></span>; optional <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> url = <span class="hljs-number"><span class="hljs-number">2</span></span>; optional <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br><pre> <code class="php hljs">$Ovl = \GPBJS\base\Ovl::createInstance(); $Ovl-&gt;setHtml($CloudView); $Ovl-&gt;setType(<span class="hljs-string"><span class="hljs-string">'cloud'</span></span>);</code> </pre><br>  At the output we get JSON: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"$gpb"</span></span>:<span class="hljs-string"><span class="hljs-string">"base.Ovl"</span></span>,<span class="hljs-string"><span class="hljs-string">"html"</span></span>:<span class="hljs-string"><span class="hljs-string">"here goes html"</span></span>,<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"cloud"</span></span>}</code> </pre><br>  Among other things, the data for JS may be HTML, derived from blitz templates.  Each block sets js_vars from the root, and they recursively merge into one structure using the array_replace_recursive function.  An example of a structure ready for rendering: <br><br><pre> <code class="hljs php">ParseResult Object ( [js_vars:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [Sidebar] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [show_menu] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ) [Popup] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [html] =&gt; ParseResult Object ( [js_vars:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> () [template:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; popup.tpl [tpl_data:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [name] =&gt; Alex ) ) ) ) [template:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; index.tpl [tpl_data:<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [title] =&gt; Main page ) )</code> </pre><br>  Usually the controller prepares one block on the site - its central part, and the remaining blocks either hide or show, or change their behavior in a certain way depending on the current controller.  To control all the ‚Äúframe‚Äù of the page, a Layout object is used (roughly speaking, this is the base View object), which sets the building blocks and the central part to the ParseResult object for the base template.  To declare which Layout will be used, the controller inherits the special HasLayoutInterface interface and implements the getLayout method. <br><br>  In addition to assembling the entire page, Layout has an additional function: it forms the result in the form of JSON for ‚Äúseamless‚Äù transitions between pages.  Our website has been working for quite a long time as a web application: transitions between pages are performed without reloading the entire page, only certain elements change (URL, title, central part, certain blocks are shown or hidden). <br><br><h4>  Integration </h4><br>  The first and one of the most difficult tasks in the transition to a new framework was the need to create a unified initialization of the site.  Initially, we checked the work on one of the simple pages and started from the old framework where all initialization was performed. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommonPage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ \Framework\Application::run(); <span class="hljs-comment"><span class="hljs-comment">//    } } $TestPage = new TestPage(); $TestPage-&gt;init(); //    $TestPage-&gt;run();</span></span></code> </pre><br>  To make an independent launch of the new framework and leave a single initialization, it was necessary to take everything that happens in init () into separate classes and use both there and there.  This was done in stages, and in the end we got about 40 classes. <br><br>  After that, for the sample, we transferred several small projects.  One of the first was the translation for our Chrome browser extension ( <a href="https://chrome.google.com/webstore/detail/badoo-notifications-exten/gngmhdpofjbdiecihebaaooakicnjjmc%3Fhl%3Den">Badoo Chrome Extension</a> ).  And the first big project was the site <a href="http://hotornot.com/">Hot Or Not</a> , entirely written in the new framework.  We are currently moving to our main <a href="http://badoo.com/">Badoo</a> website. <br><br>  Projects fully implemented on the new framework work through the front controller, that is, the single entry point - index.phtml.  For badoo.com we have a lot of rules in nginx, the last of which sends to the profile.  Those.  badoo.com/something will either open something‚Äôs user profile, or return 404. That‚Äôs why, until the profile is completely transferred to the new framework, we still have a lot of * .phtml files that contain only the launch of the framework. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/*... includes ...*/</span></span> \Framework\Application::run();</code> </pre><br>  Earlier in these files was the code on the old framework.  After refactoring, the code was transferred to the controllers of the new framework, but the files themselves cannot be deleted.  They must exist in order for nginx to run them and not send a request for a profile. <br><br><h4>  Conclusion </h4><br>  As a result, we decided to have a fairly large amount of problems: we created a single entry point, removed many levels of inheritance, minimized the use of the global context as much as possible, the code became more object and typed.  Basically, the changes affected the routing and the whole process of web scripts, from the request to the server response.  Also, a radically new data presentation system has appeared.  We tried to create a unified scheme for data access, but have not yet found a solution that would completely suit us.  But the result can be safely considered as a confident step towards convenient development and support of the code. <br><br>  Alexander <a href="http://habrahabr.ru/users/treg/">Treg</a> Treger, developer. </div><p>Source: <a href="https://habr.com/ru/post/238987/">https://habr.com/ru/post/238987/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238971/index.html">Watch the Microsoft broadcast from the Game Developer Conference.</a></li>
<li><a href="../238973/index.html">Results of the first round of the Russian AI Cup</a></li>
<li><a href="../238975/index.html">HTC One M8 Max: 5.5 inch display, Snapdragon 805 and Android L</a></li>
<li><a href="../238977/index.html">IB in American. Part 3. What is a basic set of controls and how to determine the criticality of systems?</a></li>
<li><a href="../238981/index.html">Samsung began mass production of 3.2 TB 3D V-NAND SSD-memory for servers with NVMe interface</a></li>
<li><a href="../238989/index.html">Live photos of the new Motorola Nexus leaked to the network</a></li>
<li><a href="../238991/index.html">The first hackathon Yandex.Money in St. Petersburg</a></li>
<li><a href="../238995/index.html">Dell's four-legged employee</a></li>
<li><a href="../238997/index.html">IT artifacts of our back room</a></li>
<li><a href="../238999/index.html">Microsoft is collecting suggestions for improving Internet Explorer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>