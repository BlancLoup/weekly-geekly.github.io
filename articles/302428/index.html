<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Model-View in QML. Part Four: C ++ Models</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the main purpose of QML is to create interfaces, in accordance with the MVC template, it implements representation and control. For the implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Model-View in QML. Part Four: C ++ Models</h1><div class="post__text post__text-html js-mediator-article"><p>  Since the main purpose of QML is to create interfaces, in accordance with the MVC template, it implements representation and control.  For the implementation of the model, C ++ is completely logical.  Here we will have much less restrictions and we will be able to implement a model of any complexity.  In addition, if a significant part of the program is written in C ++ and the data comes from there, then it is best to place the model in the same place. </p><br><p>  From the use of such a model can scare the apparent complexity of implementation.  I will not argue with the fact that C ++ is not the easiest language.  It is more complicated QML and requires more care not to shoot yourself in the foot, it is a fact.  Despite this, in practice, not everything is so scary. </p><br><p>  First, let's not forget that we do not write in pure C ++, but using Qt.  Such things as parent-child in QObject, implicit sharing for containers, signals and slots, QVariant and many other things greatly simplify and automate the work with memory, which saves the developer from the mass of headaches and increases reliability.  Sometimes you even get the impression that you write in a dynamic programming language.  This also reduces the gap between QML and C ++, making the transition between them more or less smooth. </p><br><p>  Secondly, all QML models ultimately lead to these C ++ models, only we get a simplified version and not the maximum speed.  If you already have an understanding of how to work with models on QML, then it will be easier to handle C ++ models.  We will simply learn a little more low-level information in the process, at the same time understanding how it all works will improve. </p><br><p>  In general, mastering C ++ models is very much worth it.  This applies in particular to QAbstractItemModel, with which we will begin. </p><br><p>  Model-View in QML: </p><br><ul><li>  <a href="http://habrahabr.ru/post/181712/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/181712/">Part zero, introductory</a> </li><li>  <a href="http://habrahabr.ru/post/184416/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/184416/">Part One: Predefined Component Views</a> </li><li>  <a href="http://habrahabr.ru/post/190090/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/190090/">Part Two: Custom Submissions</a> </li><li>  <a href="http://habrahabr.ru/post/195706/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/195706/">Part Three: Models in QML and JavaScript</a> </li><li>  Model-View in QML.  Part Four: C ++ Models <a name="habracut"></a></li></ul><br><h3>  1. C ++ - QAbstractItemModel Model </h3><br><p>  This is the standard model from the Qt Model-View framework.  This class has rich capabilities and allows you to build models of varying complexity. </p><br><p>  There are three base classes for such models.  QAbstractTableModel represents the data in the form of a table, the row and column numbers are used to access the data.  QAbstractListModel presents the data in the form of a list and, one may say, is a special case of the previous model with one column. </p><br><p>  QAbstractItemModel, on the contrary, is a more generalized version.  Each element of the table can also have children, also organized as a table.  Thus, using this table, you can organize a tree structure.  In Qt, there is an accepted rule that child elements can only have elements of the first column and using Qt views such as QTreeView needs just such a format, but no one forbids organizing a model as conveniently as possible.  As an example of such a model, you can use the QFileSystemModel class.  The first column is the file or directory names.  Items in this column can also have children if this is a directory.  The remaining columns contain various information about the file - size, modification time, etc.  This data structure can be found in any file manager: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1d9/363/e8a/1d9363e8ad3b45e9a68dedb8d7e7684f.png"></div><br><p>  Between the model and the presentation, you can insert a special proxy model.  Such models intercept calls to the main model and can hide certain elements, change their order, influence the acquisition and recording of data, etc.  Qt has a ready-made QSortFilterProxyModel class that can represent model data in sorted and / or filtered form.  If its functionality is not enough, you can create your own proxy model, inheriting from this class or from QAbstractProxyModel. </p><br><p>  Views in QML can only display lists.  With the help of VisualDataModel you can navigate through the tree structure, but we can only display items of the current level.  If the data needs to be stored in a tree and at the same time displayed in QML, then you should either use VisualDataModel or write your own proxy model that will turn this tree into a list. </p><br><p>  In order to create our own model, we need to inherit from one of the base classes for the models and determine the required methods for this model.  I will describe briefly what needs to be done, more information can be obtained <a href="https://doc.qt.io/qt-5/model-view-programming.html">in the documentation</a> .  We will consider in order of increasing complexity. </p><br><p>  For the list model, you need to create a derived class from QAbstractListModel and define such methods: </p><br><ul><li>  rowCount () - returns the number of rows, in our case this is the number of elements; </li><li>  data () - returns the data of the element; </li><li>  roleNames () - returns a list of roles that are available in the delegate.  The following roles are defined by default: display, decoration, edit, toolTip, statusTip, and whatsThis.  In the fourth version of Qt, instead of overriding this function, you had to call the function setRoleNames (), which set the desired role names. </li></ul><br><p>  This is sufficient if you do not plan to edit the model data with the help of the delegate.  Edited model will be discussed a little later. </p><br><p>  For the table model, another columnCount () method is added, which returns the number of columns.  Table views in QML use elements from the first column and, when displayed, assign the roles of this element as columns.  Thus, the table in QML is implemented using the same list and the tabular model is hardly worth using. </p><br><p>  If we need a model with a tree structure, we use QAbstractItemModel.  This model will need to further define the following functions: </p><br><ul><li>  parent () - returns the index of the parent element; </li><li>  index () - returns the index of the item. </li></ul><br><p>  In Qt models, accessing elements goes through special indexes - objects of type QModelIndex.  They contain the row and column number, the index of the parent element and some additional data.  The root element of the model has an invalid QModelIndex () index.  So if we have a simple list or table - all elements have a parent element like this.  In the case of a tree, only the top-level elements will have such a parent.  The index () function obtains the index of the parent and the row and column number of the element; it must return the index of the element.  Indexes are created using the createIndex () function. </p><br><p>  In fact, difficulties begin when we need nesting, and everything is quite simple. </p><br><p>  As an example, consider the model list.  The data will be stored in the same object as a list of strings.  We will also make the add () function, which will add another element to the model and mark it with the special macro Q_INVOKABLE so that it can be called from QML. </p><br><p>  Class definition: </p><br><pre><code class="hljs vbscript">#include &lt;QAbstractListModel&gt; #include &lt;QStringList&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TestModel : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QAbstractListModel { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: enum Roles { ColorRole = Qt::UserRole + <span class="hljs-number"><span class="hljs-number">1</span></span>, TextRole }; TestModel(QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); virtual <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> rowCount(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; virtual QVariant data(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;index, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> role) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; virtual QHash&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, QByteArray&gt; roleNames() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Q_INVOKABLE void add(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QStringList m_data; };</code> </pre> <br><p>  We define the two roles ColorRole and TextRole and use values ‚Äã‚Äãfor them greater than Qt :: UserRole - this is where the reserved values ‚Äã‚Äãfor Qt end.  Accordingly, for user roles it is necessary to use values ‚Äã‚Äãstarting from Qt :: UserRole. </p><br><p>  Implementing class methods: </p><br><pre> <code class="hljs cpp">TestModel::TestModel(QObject *parent): QAbstractListModel(parent) { m_data.append(<span class="hljs-string"><span class="hljs-string">"old"</span></span>); m_data.append(<span class="hljs-string"><span class="hljs-string">"another old"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TestModel::rowCount(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.size(); } QVariant TestModel::data(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;index, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!index.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (role) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ColorRole: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(index.row() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-string"><span class="hljs-string">"orange"</span></span> : <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TextRole: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.at(index.row()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } } QHash&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, QByteArray&gt; TestModel::roleNames() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QHash&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, QByteArray&gt; roles = QAbstractListModel::roleNames(); roles[ColorRole] = <span class="hljs-string"><span class="hljs-string">"color"</span></span>; roles[TextRole] = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roles; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TestModel::add() { beginInsertRows(QModelIndex(), m_data.size(), m_data.size()); m_data.append(<span class="hljs-string"><span class="hljs-string">"new"</span></span>); endInsertRows(); m_data[<span class="hljs-number"><span class="hljs-number">0</span></span>] = QString(<span class="hljs-string"><span class="hljs-string">"Size: %1"</span></span>).arg(m_data.size()); QModelIndex index = createIndex(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index, index)</span></span></span></span>; }</code> </pre> <br><p>  Because QML accesses roles using string names instead of integer constants, we define names for them: color and text.  Before adding, we call the special function beginInsertRows (), which will emit the necessary signals so that the view is aware of what the addition of elements is about and where they will be added.  And after, we call the endInsertRows () function, which again will emit signals that elements have been added to the model.  All additions need to be wrapped in this way.  There are similar functions for removing and moving items. </p><br><p>  In the add () function, we change the text of the first element so that it shows the number of elements in the list.  After that, we issue a dataChanged () signal to inform the viewer about this.  The signal is transmitted by the parameters of the initial and final index of the changed data (we have the same).  The index is obtained using the createIndex () function, which is passed the parameters of a row, column, and a pointer to private data.  As the latter, a pointer to an object with data is usually used, but in our case, you can simplify and always use NULL. </p><br><p>  As a QML program, let's rewrite the second example.  C ++ - the model is implemented as a plug-in (plugin).  At the beginning of the file, add its import: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TestModel <span class="hljs-number"><span class="hljs-number">1.0</span></span></code> </pre> <br><p>  Create an object of this type and use it as a model: </p><br><pre> <code class="javascript hljs">TestModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel }</code> </pre> <br><p>  After launching the program and adding several elements, we get something like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b06/a27/9a0/b06a279a004a44e0b2b0fb3d89096748.png"></div><br><p>  To edit the model data in the delegate, a standard interface is provided and to use it, it is necessary to override the setData () method in our model.  The ability to edit QAbstractItemModel data from QML appeared in Qt 5. </p><br><p>  Add to the header file such declarations: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> role)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Qt::<span class="hljs-function"><span class="hljs-function">ItemFlags </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre> <br><p>  and in the definition implementation file: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bool</span></span> TestModel::setData(const QModelIndex &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, const QVariant &amp;<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } switch (<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ColorRole: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; // This property can <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TextRole: m_data[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>()] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.toString(); break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } emit dataChanged(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, QVector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;() &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } Qt::ItemFlags TestModel::flags(const QModelIndex &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.isValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Qt::ItemIsEnabled; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QAbstractListModel::flags(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) | Qt::ItemIsEditable; }</code> </pre> <br><p>  We added to the model the ability to edit the text property directly from the delegate using similar code: </p><br><pre> <code class="javascript hljs">model.text = <span class="hljs-string"><span class="hljs-string">"Some new text"</span></span></code> </pre> <br><p>  Edit the delegate from our example and add the following element to it: </p><br><pre> <code class="javascript hljs">MouseArea { anchors.fill: parent onDoubleClicked: model.text = <span class="hljs-string"><span class="hljs-string">"Edited"</span></span> }</code> </pre> <br><p>  Now with a double click on the element, its text will change to "Edited". </p><br><p>  The Qt :: ItemIsEditable flag is used for Qt mappings to indicate that an item can be edited, so the flags () method must be overridden.  At present, this flag is not checked in QML and the model will be editable without installing it, but I would recommend not to neglect it, since  In future versions, checking for this may be added. </p><br><h3>  2. C ++ lists </h3><br><p>  As a model, you can use lists of strings or objects of type QObject. </p><br><p>  Let's make a simple class with a property of type QStringList: </p><br><pre> <code class="hljs kotlin">#include &lt;QObject&gt; #include &lt;QStringList&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public QObject { Q_OBJECT Q_PROPERTY</span></span></span></span>(QStringList <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> READ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> CONSTANT) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestModel(QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); QStringList <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; TestModel::TestModel(QObject *parent): QObject(parent) { } QStringList TestModel::<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QStringList() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"orange"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>; }</code> </pre> <br><p>  We use a slightly modified first example.  Importing and creating a model object is exactly the same as in the previous example.  But instead of the object itself, its property is used as a model: </p><br><pre> <code class="javascript hljs">model: dataModel.data</code> </pre> <br><p>  and the element index is used as text: </p><br><pre> <code class="javascript hljs">text: model.index</code> </pre> <br><p>  Such a list works just like a JavaScript array.  Accordingly, this is a passive model and the addition / deletion of elements does not affect the representation. </p><br><h3>  3. QQmlListProperty </h3><br><p>  This class allows you to make a list that can be filled in both C ++ and QML.  Filling in QML is performed statically when an object is created (as is done with a ListModel).  In C ++, you can add / remove elements, so if you make a special method and mark it with the Q_INVOKABLE macro, you can also do it from QML. </p><br><p>  Lists of this type can store objects of type QObject and types derived from it.  In the type it is necessary to determine all the properties that will be used (using Q_PROPERTY). </p><br><p>  Consider an example of such an object. </p><br><pre> <code class="hljs mel">#include &lt;QObject&gt; class Element : public QObject { Q_OBJECT Q_PROPERTY(QString <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> READ <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> WRITE setColor NOTIFY colorChanged) Q_PROPERTY(QString <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> READ <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> WRITE setText NOTIFY textChanged) public: explicit Element(QObject *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>); QString <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>() const; void setColor(QString <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>); QString <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>() const; void setText(QString <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); signals: void colorChanged(QString <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>); void textChanged(QString <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); private: QString m_color; QString m_text; }; Element::Element(QObject *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QObject(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) { } QString Element::<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_color; } void Element::setColor(QString <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_color == <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_color = <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">emit</span></span> colorChanged(m_color); } QString Element::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_text; } void Element::setText(QString <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_text == <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_text = <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">emit</span></span> textChanged(m_text); }</code> </pre> <br><p>  We created a simple class containing two properties ‚Äî color and text, getters, setters, and notifiers for them. </p><br><p>  In order for objects of this type to be used in a QQmlListProperty, this type must be visible in QML.  To do this, you need to register this type using the qmlRegisterType () function.  I use the C ++ plugin, so I register this type in a special handler, along with the model: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TestModelPlugin::registerTypes(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *uri) { qmlRegisterType&lt;TestModel&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"TestModel"</span></span>); qmlRegisterType&lt;Element&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Element"</span></span>); }</code> </pre> <br><p>  In order to use QQmlListProperty, you need to create a property of type QQmlListProperty in some object, where T is the type of objects to be stored.  In our case, there will be a property of type QQmlListProperty. <br></p><p>  The QQmlListProperty constructor takes as arguments the methods that the QML engine will invoke when working with the list.  These are methods for adding and retrieving an item, getting the number of items, and clearing the list.  Only the first is obligatory, but it is better to define them all. </p><br><p>  So, the class code of our model: </p><br><pre> <code class="hljs kotlin">#include &lt;QObject&gt; #include &lt;QQmlListProperty&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public QObject { Q_OBJECT Q_PROPERTY</span></span></span></span>(QQmlListProperty&lt;Element&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> READ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> NOTIFY dataChanged) Q_CLASSINFO(<span class="hljs-string"><span class="hljs-string">"DefaultProperty"</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestModel(QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); QQmlListProperty&lt;Element&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>(); Q_INVOKABLE void add(); signals: void dataChanged(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: static void appendData(QQmlListProperty&lt;Element&gt; *list, Element *value); static int countData(QQmlListProperty&lt;Element&gt; *list); static Element *atData(QQmlListProperty&lt;Element&gt; *list, int index); static void clearData(QQmlListProperty&lt;Element&gt; *list); QList&lt;Element*&gt; m_data; }; TestModel::TestModel(QObject *parent): QObject(parent) { Element *element = new Element(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); element-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"color"</span></span>, <span class="hljs-string"><span class="hljs-string">"lightgreen"</span></span>); element-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"eldest"</span></span>); m_data &lt;&lt; element; } QQmlListProperty&lt;Element&gt; TestModel::<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QQmlListProperty&lt;Element&gt;(static_cast&lt;QObject *&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), static_cast&lt;void *&gt;(&amp;m_data), &amp;TestModel::appendData, &amp;TestModel::countData, &amp;TestModel::atData, &amp;TestModel::clearData); } void TestModel::add() { Element *element = new Element(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); element-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"color"</span></span>, <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>); element-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"new"</span></span>); m_data.append(element); emit dataChanged(); } void TestModel::appendData(QQmlListProperty&lt;Element&gt; *list, Element *value) { QList&lt;Element*&gt; *<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = static_cast&lt;QList&lt;Element*&gt; *&gt;(list-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;append(value); } int TestModel::countData(QQmlListProperty&lt;Element&gt; *list) { QList&lt;Element*&gt; *<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = static_cast&lt;QList&lt;Element*&gt; *&gt;(list-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;size(); } Element *TestModel::atData(QQmlListProperty&lt;Element&gt; *list, int index) { QList&lt;Element*&gt; *<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = static_cast&lt;QList&lt;Element*&gt; *&gt;(list-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;at(index); } void TestModel::clearData(QQmlListProperty&lt;Element&gt; *list) { QList&lt;Element*&gt; *<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = static_cast&lt;QList&lt;Element*&gt; *&gt;(list-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); qDeleteAll(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;begin(), <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;end()); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;clear(); }</code> </pre> <br><p>  As in the example with QAbstractItemModel, there is a add () method for adding items and an item is also added to the constructor. </p><br><p>  In the data () method, an object of type QQmlListProperty is created.  In the constructor, he gets a parent (QObject), a pointer to private data, which will be available in the functions for working with the list and the functions themselves.  In all functions, the first argument is a pointer to an object of type QQmlListProperty which, in the data property, contains our private data.  I put there a list in which Element objects are actually stored. </p><br><p>  The signal for the data property is needed so that when adding / removing objects in the course of the presentation, they will receive information about changes in the model.  After such a signal, the display will reread the entire model. </p><br><p>  To demonstrate this model, take a slightly modified second example. </p><br><p>  Connect C ++ plugin: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ListProperty_Plugin <span class="hljs-number"><span class="hljs-number">1.0</span></span>  : TestModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel data: [ Element { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> text: <span class="hljs-string"><span class="hljs-string">"old"</span></span> }, Element { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"lightgray"</span></span> text: <span class="hljs-string"><span class="hljs-string">"another old"</span></span> } ] }</code> </pre> <br><p>  The data property is defined as a regular list.  Since we registered the type Element, such objects can now be created in QML.  It is worth noting that the definition of elements of the data array here does not replace those elements that already exist.  These elements will be added to the one defined in the constructor of the TestModel class. </p><br><p>  As a model, not the TestModel object itself is used, but the same data property: </p><br><pre> <code class="javascript hljs">model: dataModel.data</code> </pre> <br><p>  The data in the delegate is available through modelData: </p><br><pre> <code class="javascript hljs">color: modelData.color</code> </pre> <br><p>  and </p><br><pre> <code class="javascript hljs">text: modelData.text</code> </pre> <br><p>  Elements can be added to the data property only statically, so we use the add () function we write for this: </p><br><pre> <code class="javascript hljs">onClicked: dataModel.add()</code> </pre> <br><p>  As a result, we get something like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2e1/091/e1d/2e1091e1d83c4e63b3b968b055eda4a4.png"></div><br><p>  In the TestModel class, we specified data as the default property (using the Q_CLASSINFO directive).  This allows us to define Element objects directly in the TestModel object and they themselves will be added to the desired property.  So you can simplify the definition of a model and rewrite it like this: </p><br><pre> <code class="javascript hljs">TestModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel Element { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> text: <span class="hljs-string"><span class="hljs-string">"old"</span></span> } Element { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"lightgray"</span></span> text: <span class="hljs-string"><span class="hljs-string">"another old"</span></span> } }</code> </pre> <br><p>  Thus, using QQmlListProperty, you can implement the active model without using the QAbstractItemModel classes.  If a large amount of data is not intended and they should not change frequently, such a model is fine. </p><br><h3>  Summary </h3><br><p>  Model development is an important part of not only QML programming, but programming as a whole.  As Fred Brooks said: ‚ÄúShow the flowcharts, hide the tables and I will be puzzled, show me your tables and, most likely, I will not need flowcharts, they will be obvious‚Äù.  That data is a central topic in programming.  Designing data structures and accessing them is a crucial task and largely determines the architecture of the program. </p><br><p>  Knowing the tools we covered in this and the previous section will help you organize your data in the most appropriate way, and then around the data and the program itself.  Since the concept of Model-View is one of the fundamental ones in QML, these tools are enough. </p><br><p>  I looked at various ways to create models.  From my own experience I can say that the most used are QAbstractItemModel, ListModel, and JavaScript arrays.  So I recommend them to pay attention first of all. </p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302428/">https://habr.com/ru/post/302428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302418/index.html">Teamviewer user accounts hacked</a></li>
<li><a href="../302420/index.html">Mary Miker Report on Internet Trends 2016</a></li>
<li><a href="../302422/index.html">Reflections on the evaluation of commits and robot programmers</a></li>
<li><a href="../302424/index.html">The final release of the browser Vivaldi 1.2</a></li>
<li><a href="../302426/index.html">Broadcaster for MacBook. Facebook Edition</a></li>
<li><a href="../302430/index.html">Habrahabr articles citation graph</a></li>
<li><a href="../302432/index.html">We use HTML and WebBrowser control as a UI for ordinary windows applications in C #</a></li>
<li><a href="../302438/index.html">Creating a blog on symfony 2.8 lts [Part 3]</a></li>
<li><a href="../302442/index.html">Deployer - convenient and flexible application deployment</a></li>
<li><a href="../302448/index.html">‚ÄúNo longer means better‚Äù: counterintuitive case from Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>