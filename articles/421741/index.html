<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why did a person from the Java world become an ardent supporter of Node.js and JavaScript?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="David Harron, the author of the material we are translating today, asked the following question: ‚ÄúShould a person who worked for more than 10 years at...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why did a person from the Java world become an ardent supporter of Node.js and JavaScript?</h1><div class="post__text post__text-html js-mediator-article">  David Harron, the author of the material we are translating today, asked the following question: ‚ÄúShould a person who worked for more than 10 years at Sun Microsystems, in the Java SE team, think only about Java bytecode and create instances of abstract interfaces until the last breath? ".  He asked this question in relation to himself, and for him the Node.js platform, after Java, turned out to be like a breath of fresh air.  David says that when he was fired from Sun in January 2009 (right before the takeover of this Oracle company), he learned about Node.js.  This technology has hooked him.  What does ‚Äúhooked‚Äù mean?  Since 2010, he has written a lot about programming for Node.js.  Namely, he wrote several books, including Node.js Web Development, the fourth edition of which was published this year.  He prepared a lot of small materials about Node.js published on the Internet.  In fact, he devoted a lot of time and effort talking about the Node.js platform and the possibilities of JavaScript.  Why was it that the person who used to do Java exclusively was so fascinated with Node.js and JavaScript? <br><br> <a href="https://habr.com/company/ruvds/blog/421741/"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/04b/29b/a7f04b29bb9ae083524906ac68f0d47b.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">About Java</font> </h2><br>  Working at Sun, I believed in Java technology.  I gave reports on JavaONE, participated in the development of the java.awt.Robot class, organized the event Mustang Regressions Contest (this was a contest aimed at finding errors in Java 1.6), helped launch the project ‚ÄúDistributions License for Java‚Äù, which served as the answer to the question about Linux distributions of the JDK before the appearance of OpenJDK.  Later, I played some role in the launch of the OpenJDK project.  Along the way, for about 6 years, I have been posting blog materials on java.net (now this site is closed).  These were 1-2 articles per week devoted to significant events in the Java ecosystem.  A significant role in my work was played by protecting Java from those who predicted this technology would have a bleak future. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/adb/964/0d9adb9644509d8a25f21ebda093c506.jpg"><br>  <i><font color="#999999">This award, the Duke Award, was given to particularly distinguished Sun employees.</font></i>  <i><font color="#999999">I got it after I organized the Mustang Regressions Contest</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What happened to the man who did so much about everything related to Java?  As a matter of fact, here I want to tell you about how I turned from a Java follower into a hot supporter of Node.js and JavaScript. <br><br>  I must say that what happened to me cannot be called a complete rejection of Java.  I, over the past 3 years, have written quite a lot of Java code, have used Spring and Hibernate.  Although I really like what I am doing in this area (I work in the solar industry, I do what I like to do, for example - I write requests for working with data from the energy sector), Java programming is now in my eyes lost its former glory. <br><br>  Two years of development using Spring allowed me to clearly understand one important thing: trying to hide complex mechanisms does not lead to simplicity, it only leads to the appearance of even more complex structures. <br><br>  Here, in brief, are the main ideas that I will touch on in this material: <br><br><ul><li>  Java programs are full of template code that hides the programmer‚Äôs intentions. </li><li>  Working with Spring and Spring Boot gave me a good lesson, which is that trying to hide complex mechanisms leads to more complex structures. </li><li>  The Java EE platform was a project created, so to speak, by ‚Äúuniversal effort‚Äù that covers absolutely all the needs of developing enterprise applications.  As a result, the Java EE platform turned out to be prohibitively complex. </li><li>  Developing with Spring is, until a certain point, a pleasant occupation.  This illusion disappears on that day when an exception emerges from the depths of a certain subsystem about which you have never heard, which is completely impossible to understand, and it takes at least three days to find out what the problem is. </li><li>  What kind of auxiliary mechanisms that create an unnecessary load on the system need a framework that can ‚Äúwrite‚Äù code for programmers? </li><li>  Although IDEs like Eclipse are powerful applications, they are a measure of the complexity of the Java ecosystem. </li><li>  Node.js platform emerged as a result of the efforts of one person aimed at improving his vision of lightweight, event-driven architecture. </li><li>  It seems that the JavaScript community enthusiastically perceives the ideas of getting rid of the template code, which allows programmers to express their intentions as clearly as possible. </li><li>  As a solution to the problem of hell callbacks in JS, there is the async / await construction, which is an example of the rejection of the template code and contributes to the clarity of expression of the programmers' intentions. </li><li>  Programming for Node.js is a pleasure. </li><li>  JavaScript does not have strong typing specific to Java.  This is the blessing and curse of the tongue.  This makes it easier to write code, but in order to verify its correctness, you have to spend more time on testing. </li><li>  The package management system provided by npm / yarn is easy and pleasant to use.  She is no match for Maven. </li><li>  Both Java and Node.js offer excellent performance.  This goes against the myth, according to which JavaScript is a slow language, the use of which leads to poor performance of the Node.js platform. </li><li>  Performance Node.js relies on Google‚Äôs efforts to improve V8, the engine that drives the speed of Chrome‚Äôs browser. </li><li>  The fierce competition between manufacturers of browser-based JS engines contributes to the development of JavaScript, and this is very beneficial to Node.js. </li></ul><br><h2>  <font color="#3AC1EF">About Java Development Issues</font> </h2><br>  Some tools or objects are the result of many years of efforts by engineers to improve them.  Programmers experience different ideas, remove unnecessary attributes, and as a result they get entities that have only what is needed to solve a certain task.  Often these technologies have something inherent in a very attractive simplicity that hides powerful capabilities.  This is not applicable to Java. <br><br>  Spring is a popular framework for developing Java-based web applications. <br><br>  The main goal of Spring, and, in particular, Spring Boot, is to provide an opportunity to use a pre-configured Java EE stack.  The programmer who uses Spring should not, in order to create a complete system, take care of servlets, permanent data storage systems, application servers, and it is not yet known about anything.  All these concerns are shifted to Spring‚Äôs shoulders, and the programmer is writing code that implements the logic of the application.  For example, the JPARepository mechanisms are responsible for generating database queries for methods that look like <code>findUserByFirstName</code> .  The programmer does not have to write the code of such methods.  It is enough to pass the description of the method to the system, and Spring will do the rest. <br><br>  All this sounds very good, it is pleasant to work in such a style, but - until some surprise happens. <br><br>  I mean a situation where, for example, a Hibernate <code>PersistentObjectException</code> exception comes in with the message <code>detached entity passed to persist</code> .  What does it mean?  It took several days to figure it out.  As it turned out, to describe everything in a very simplified way, this means that the JSON data received at the REST endpoint has ID fields with some values.  Hibernate, again, without going into details, seeks to control ID values, and, as a result, throws out the above-described obscure exception.  There are thousands of such error messages that are confusing and difficult to read.  Considering the fact that there are whole cascades of subsystems based on each other in Spring, the Spring stack looks like a sworn enemy programmer who watches him and waits for the programmer to make the slightest mistake, and when this happens, he throws exceptions that are not compatible with normal operation of the application. <br><br>  Next, you can immediately recall the longest stack traces.  They represent several screens full of all sorts of abstract methods.  Spring obviously creates the configuration needed to implement what is expressed in the code.  Such a level of abstraction undoubtedly requires a considerable amount of auxiliary logic, which is aimed at finding everything necessary for the operation of the code, for example, in order to execute queries.  And long stack traces are not necessarily bad.  Such things are, rather, a symptom, leading to the question of how much auxiliary mechanisms create a load on the system. <br><br>  How does the <code>findUserByFirstName</code> method <code>findUserByFirstName</code> , given that the programmer did not write the code for such a method?  The framework needs to parse the name of the method, understand the programmer‚Äôs intention, create something like an abstract syntax tree, generate some SQL code, and so on.  How does all this load the system?  And all this exists only so that the programmer does not need to write code? <br><br>  After you have to go through a few dozen times through something like a search for the meaning of the error described above, spending weeks trying to solve secrets, which, by and large, you shouldn‚Äôt guess, you can come to the same conclusion that I came to .  Its meaning is that the attempt to hide complex mechanisms does not lead to simplicity, it only leads to the emergence of even more complex structures.  The Node.js platform is much simpler. <br><br>  The ‚ÄúCompatibility Matters‚Äù slogan concealed a great idea, according to which the most important feature of the Java platform was backward compatibility.  We took it seriously, putting on t-shirts images similar to the one you can see below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2a/cd5/c40/b2acd5c404b3bc69c4d3af9da1fd6952.jpg"><br>  <i><font color="#999999">Backward compatibility is very important.</font></i> <br><br>  Of course, this level of attention to backward compatibility can be a source of constant anxiety, and from time to time it is useful to move away from old mechanisms that no longer benefit. <br><br><h2>  <font color="#3AC1EF">Java and Node.js</font> </h2><br>  Spring and Java EE are overly complex.  The Node.js platform on their background is perceived as a breath of fresh air.  The first thing you notice about getting acquainted with Node.js is Ryan Dahl‚Äôs approach to developing the platform‚Äôs core.  His experience told him that platforms using threads are needed to create complex, heavyweight systems.  He was looking for something else, and spent a couple of years improving the set of basic mechanisms embodied in Node.js.  The result is a lightweight system that characterizes a single thread of execution, an inventive use of anonymous JavaScript functions as asynchronous callbacks, and a runtime library that originally implements asynchronous mechanisms.  The initial message when creating such a system was to provide high-performance event handling with the delivery of these events to the callback function. <br><br>  Further, an important feature of Node.js is the use of JavaScript.  There is a feeling that those who write to JS have a tendency to get rid of the template code, which makes it possible to clearly describe the intentions of the programmer. <br><br>  As an example of the differences between Java and JavaScript, consider the implementation of listener functions (observers).  In Java, to work with listeners, you need to create a specific instance of an abstract interface.  This entails the use of cumbersome language constructs that hide the essence of what is happening.  How to discern the intention of the programmer, hidden under the covers of the template code? <br><br>  JavaScript uses simple anonymous functions instead.  When implementing a listener, you do not need to look for a suitable abstract interface.  It is enough, without the need to use a variety of auxiliary texts, to write the necessary code. <br><br>  So, here is one important idea that can be derived from the analysis of the mechanisms described above: most programming languages ‚Äã‚Äãhide the programmer's intentions, which leads to the fact that the code is difficult to understand. <br><br>  The solution for using callback functions offered by Node.js looks very attractive.  But it is not without problems. <br><br><h2>  <font color="#3AC1EF">Problem solving and problem solving</font> </h2><br>  In JavaScript, there have long been two problems associated with asynchronous programming.  The first is what is called callback hell in Node.js.  This problem lies in the fact that, in the course of development, it is easy to fall into a trap, built of deeply nested callback functions, where each level of nesting complicates the program, as well as processing the results of the code and errors.  There was another problem related to this, the essence of which is that the JavaScript language mechanisms did not help the programmer to properly express the ideas of asynchronous code execution. <br><br>  To simplify asynchronous development in JS, several libraries have emerged.  But this is another example of an attempt to hide complex mechanisms, which only leads to the appearance of even more complex structures. <br><br>  Consider an example: <br><br><pre> <code class="hljs lua">const async = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'async'</span></span>); const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); const cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filez, fini)</span></span></span></span> { async.eachSeries(filez, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filenm, next)</span></span></span></span> {   fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);     process.<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>();     });   }); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) fini(err);   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fini(); }); }; cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(err.stack); });</code> </pre> <br>  This is a nondescript imitation of the Unix <code>cat</code> .  The <code>async</code> library is excellent in simplifying asynchronous call sequences.  However, its use requires a large amount of template code that hides the programmer‚Äôs intent. <br><br>  In essence, this code contains a loop.  It is not written as a normal cycle, it does not use natural constructions describing cycles.  Further, the results of executing the code and the errors it generates do not go where it would be right for them.  They are locked in callbacks, and this is inconvenient.  But, before the introduction of ES2015 / 2016 standards in Node.js, nothing better could be done. <br><br>  If we rewrite this code taking into account new features, which, in particular, are available in Node.js 10.x, we get the following: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>).promises; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filenmz</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filenm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> filenmz) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fs.readFile(filenm, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     process.stdout.write(data, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, (err) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err);       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resolve();     });   }); } } cat(process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>)).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err.stack); });</code> </pre> <br>  In this example, we used the <code>async/await</code> construct.  Here the same asynchronous mechanisms are presented as in the previous example, but here the usual structures used in the organization of cycles are used.  Working with the results and errors looks quite normal.  Such code is easier to read and write.  This approach makes it easy to understand the intent of the programmer. <br><br>  The only drawback is that <code>process.stdout.write</code> does not have a Promise interface; as a result, this mechanism cannot be used in async functions without wrapping it in promise. <br><br>  Now we can conclude that the problem of hell callbacks in JavaScript was solved in a way that differs from trying to hide complex mechanisms.  Instead, changes were made to the language, which solved the problem itself and saved us from the inconvenience caused by the need to use large amounts of sample code in the temporary solution.  In addition, using the async / await mechanism, the code simply became more beautiful. <br><br>  We started this section with a discussion of the lack of Node.js, but an excellent solution to the problem of callback hell led to the fact that talking about shortcomings turned into a conversation about the strengths of Node.js and JavaScript. <br><br><h2>  <font color="#3AC1EF">Strong typing, interfaces, and imaginary code clarity</font> </h2><br>  In those days, when I was engaged in protecting Java from all sorts of attacks, I stressed that strong typing allows you to write huge applications.  At that time, the development of monolithic systems was in progress (there were no microservices, there was no Docker, and so on).  Since Java is a strongly typed language, the Java compiler helps the programmer avoid many problems by preventing him from compiling the wrong code. <br><br>  JavaScript, unlike Java, is not distinguished by strong typing.  From this we can make an obvious conclusion that the programmer does not know exactly which objects he has to work with.  How can a programmer know what to do, for example, with some object obtained from somewhere? <br><br>  The reverse side of strong Java typing is the need to constantly perform template actions.  The programmer constantly performs type casting or checks that everything is exactly as expected.  The developer spends time writing code, does it with exceptional accuracy, uses considerable amounts of patterned constructions, and hopes that all this will help him save time by detecting and correcting early errors. <br><br>  The problem of programming in a language with strict typing is so great that a programmer, with virtually no options, has to use a large, complex IDE.  A simple code editor is not enough here.  The only way to keep a Java programmer in adequate condition (with the exception of pizza) is to constantly show him drop-down lists containing the available fields of objects or descriptions of method parameters.  This and other supporting mechanisms of IDEs such as Eclipse, NetBeans, or IntelliJ help in creating classes, facilitates refactoring and solving other problems. <br><br>  And ... I will not talk about Maven.  This is just a dreadful tool. <br><br>  In JavaScript, variable types are not specified when they are declared, type casting is usually not used, and so on.  As a result, the code is easier to read, but this state of affairs also means the risk of programming errors that are difficult to detect. <br><br>  Whether the above applies to Java pluses or minuses depends on the point of view. <br><br>  Ten years ago, I thought that all these difficulties justify themselves by giving the programmer more confidence in the code he writes.  Today, I believe that strict typing increases the amount of work a programmer has and projects are much easier to develop in the same way as in JavaScript. <br><br><h2>  <font color="#3AC1EF">Fighting bugs with small modules that are easy to test</font> </h2><br>  Node.js pushes the programmer to split his projects into small fragments, into so-called modules.  Perhaps this fact will seem insignificant to you, but it partially solves the problem we just mentioned. <br><br>  Here are the main characteristics of the module: <br><br><ul><li>  Independence.  The module combines interconnected code into a single entity. </li><li>  Clear boundaries.  The code inside the module is protected from interfering with any external mechanisms. </li><li>  Explicit export.  By default, the module code and data are not exported.  The developer independently decides which functions and data should be made publicly available. </li><li>  Explicit import.  When developing a module, a programmer decides on which modules it will depend on. </li><li>  Potential independence.  Modules can be made publicly available, in a very broad sense of the word, by publishing them in npm, or, if they are intended for the internal needs of the company, by publishing in closed repositories.  This makes it easy to use the same modules in different applications. </li><li>  Easy to understand code.  The fact that the modules are small in size makes it easier to read and understand their code, it opens the way for free discussion about them. </li><li>  Facilitate testing.  A small module, if implemented correctly, is easily modularly tested. </li></ul><br>  All this makes Node.js modules entities with clearly defined boundaries whose code is easy to write, read and test. <br><br>  However, anxiety when working with JavaScript is caused by the fact that the lack of strong typing can easily lead to the fact that the code will do something wrong.  In a small module aimed at solving some kind of narrow problem with clear boundaries, ‚Äúsomething is not right‚Äù can affect only the code of the module itself.  This leads to the fact that problems that can be caused by the lack of strong typing turn out to be locked in the module boundaries. <br><br>  Another solution to the problem of dynamic typing in JavaScript is to thoroughly test the code. <br><br>  The developer has to take a serious approach to testing, which takes away from him some of the benefits that come from the simplicity of the JS development process.  Testing systems created by a JS programmer should find those errors that, developed by something like Java, could automatically find a compiler.  You are writing tests for your JS applications? <br><br>  For those who need a static typing system in JavaScript, it may be helpful to have a look at TypeScript.  I do not use this language, but I have heard many good things about it.  It is compatible with JavaScript and extends the language with a type control system and other useful features. <br><br>  As a result, we can say that the use of a modular approach to development is the strength of Node.js and JavaScript. <br><br><h2>  <font color="#3AC1EF">Package management</font> </h2><br>  I feel bad at the thought of Maven, so I can‚Äôt even write about it normally.  And, as I understand it, Maven, without compromise, either love or hate. <br><br>  The problem here is that in the Java environment there is no complete package management system.  Maven packages exist, you can work with them normally, they are supported by Gradle.  But how work with them is organized is not close to what the package management system for Node.js gives the developer. <br><br>  In the world of Node.js, there are two excellent package managers that work closely with each other.  At first, the only such tool was the npm repository and the command line tool of the same name. <br><br>  Thanks to npm, we have a great scheme for describing package dependencies.  Dependencies can be strict (for example, it is stated that version 1.2.3 of a certain package is needed only), or specified with several degrees of freedom - up to <code>*</code> , which means using the most recent version of a certain package. <br><br>  The Node.js community has published hundreds of thousands of packages in the npm repository.  In this case, using packages that are not in npm is as easy as packages from npm. <br><br>  The npm system turned out so successful that not only Node.js server product developers use it, but also front-end programmers.  Previously, there were tools like Bower used to manage packages.  Bower was deprecated, and now you can find that all JS libraries for frontend development exist in the form of npm packages.  Many support tools for client development, such as the Vue.js CLI and Webpack, are written as Node.js applications. <br><br>  Another package management system for Node.js, yarn, loads packages from the npm repository and uses the same configuration files.  The main advantage of yarn over the npm package manager is its higher speed. <br><br>  The npm repository, regardless of whether you are working with it using the npm package manager or using the yarn package manager, is a powerful basis for making development for Node.js so simple and enjoyable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/382/891/5db382891911a53615838db26c67936c.png"></div><br>  <i><font color="#999999">Once, after I helped in the development of java.awt.Robot, I was inspired to create this thing.</font></i>  <i><font color="#999999">While the official Duke image consists of curves, RoboDuke is built from straight lines.</font></i>  <i><font color="#999999">Only the elbow joints of this robot are round.</font></i> <br><br><h2>  <font color="#3AC1EF">Performance</font> </h2><br>  Java,  JavaScript     .          -,    ,    .  ,   ,  -       . <br><br>   Java,   JavaScript      .    Java   Node.js,        .     JavaScript         .         -. <br><br> JDK Sun/Oracle  HotSpot ‚Äî  ,     -.        ,      ,    ,    ,     ,    . HotSpot ‚Äî   ,     . <br><br>    JavaScript,       ,     JS-,   , ,    -  . ,    JavaScript           .    ,   ,    . , ,     Google Docs,     .    JS    . <br><br> Node.js     ,      V8  Google Chrome. <br><br>      <a href="https://youtu.be/YqOhBezMx1o"></a>   ,  Google,     V8,         .     ,  V8   Crankshaft  Turbofan. <br><br>   ‚Äî  ,     ,       R  Python.  ,     ,        .  JavaScript,   ,   ,           <a href="https://youtu.be/1ORaKEzlnys"> </a>  JavaScript. <br><br>  <a href="https://youtu.be/YB-kfeNIPCE"></a>       JavaScript  , TensorFlow.js. API     API TensorFlow  Python,      .    , ,       ,        . <br><br> <a href="https://youtu.be/Fbhhc4jtGW4"></a>     IBM,        Node.js,  ,   ,   Docker/Kubernetes.       ,       Node.js    Spring Boot.       -,        .  ,      Node.js  , ,  ,   V8. <br><br>   ,  Node.js      .      . - ,   Node.js     ,     . ,    ¬´Node.js Web Development¬ª,   ,      : <br><br><ul><li>   ‚Äî             . </li><li>          ,   Node.js     . </li><li>       . </li></ul><br>   JavaScript    ,          Node.js.    ‚Äî    Node.js-.      Node.js-   <code>node-gyp</code> ,      . <a href="https://youtu.be/Pfbw4YPrwf4"></a> ,     Rust-  Node.js. <br><br> WebAssembly   ,    ,   JavaScript,     . WebAssembly  ,    JavaScript-.  <a href="https://youtu.be/hYrg3GNn1As"></a>         WebAssembly   Node.js. <br><br><h2> <font color="#3AC1EF"> -</font> </h2><br>  - (Rich Internet Applications, RIA)        .    ,  ,     (  ) JS-,      . <br><br>   ,     20  . Sun  Netscape    Java-  Netscape Navigator. JavaScript , ,      Java-.     ,      Java-,   ‚Äî Java-.       ,                .      . <br><br>    JavaScript     ,          .       RIA,  ,   -  Java      -. <br><br>    ,   RIA   .  Node.js       , ,      ,      .    JavaScript. <br><br>  Here are some examples: <br><br><ul><li>   Google Docs (    ),        ,    . </li><li>  ,  React, Angular  Vue.js,    ,   HTML, CSS  JavaScript. </li><li> Electron ‚Äî   Node.js   Chromium.      -  .          ,  Visual Studio Code, Atom, GitKraken,  Postman. </li><li>    Electron/NW.js   , -, ,  React, Angular,  Vue,     <a href="https://blog.sourcerer.io/creating-a-markdown-editor-previewer-in-electron-and-vue-js-32a084e7b8fe"> </a> . </li></ul><br>  Java,       ,   -  -,   JavaScript.  , , -      Sun Microsystems.    Sun   ,      .      .   Java-    ,       Java   Java Web Start.       Java-  Webstart-. <br><br>          Java, ,  , IDE NetBeans  Eclipse      .      Java  ,         ,   Java. <br><br>    JavaFX. <br><br>  JavaFX, 10  ,    Sun   iPhone. ,        Java,    , ,    .         Flash      iOS.     . JavaFX    ,        ,     .       -  React, Vue.js   . <br><br>    JavaScript  Node   Java. <br><br>    Java,  -    JavaONE.        Java  . ,  ,    ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdb/5d1/736/bdb5d1736a9e8f66394d50ef11063389.jpg"><br> <i><font color="#999999"> Java</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/0c6/da4/0640c6da4b0defa291a2b6516f2d2606.png"><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>          .       ¬´P-¬ª (Perl, PHP, Python)  Java,      Node.js,   Ruby, Haskell, Go, Rust,   .            . <br><br>     ,  , ,    Java,    Node.js,  ,    ,    Node.js-.  Java   ,    Node.js    . ,  ,  ,    Java,    . <br><br>      . , ,        Node.js  - ,    - .           . ,      XBRL-.        XBRL   Python,  ,   ,   Python. ,  ,           ,        . <br><br>  <b>Dear readers!</b>  ,     ,   JavaScript  -  ,   -    Node.js,       . <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/421741/">https://habr.com/ru/post/421741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421731/index.html">How much software costs to build: what is the budget for developing an application</a></li>
<li><a href="../421733/index.html">Tackle and do: why it is sometimes useful to score for analysis and simply develop</a></li>
<li><a href="../421735/index.html">"Viruses" in extensions on the example of FastProxy</a></li>
<li><a href="../421737/index.html">The American company has been chipping its employees for a year. Why this could be the future</a></li>
<li><a href="../421739/index.html">How did I replace RxJava with quicksies in my project and why you probably should also do it</a></li>
<li><a href="../421745/index.html">How Ubisoft created its Starlink hybrid gaming kit: Battle for Atlas</a></li>
<li><a href="../421747/index.html">Parktronic on Arduino</a></li>
<li><a href="../421749/index.html">‚ÄúExtremely few people actually write backend on Kotlin‚Äù - an interview with Pasha Finkelstein</a></li>
<li><a href="../421751/index.html">Top Free Editors for Development and Documentation: Atom</a></li>
<li><a href="../421753/index.html">Video review DJI Mavic 2 Zoom and 2 Pro. Testing cameras and new features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>