<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Labyrinths: classification, generation, search for solutions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This classic post describes in detail the most popular ways of creating and passing mazes. The article is divided into four parts: classification, gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Labyrinths: classification, generation, search for solutions</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>This classic post describes in detail the most popular ways of creating and passing mazes.</i>  <i>The article is divided into four parts: classification, generation algorithms, labyrinth solving algorithms, and other operations with mazes.</i> <br><br><h2>  Labyrinth classification </h2><br>  Labyrinths in general (and therefore the algorithms for their creation) can be divided into seven different classifications: dimensions, hyperdimensionality, topology, tessellation, routing, texture and priority.  The labyrinth can use one element from each class in any combination. <a name="habracut"></a><br>  <b>Dimension:</b> the dimension class essentially determines how many dimensions in space the maze fills.  There are the following types: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Two-dimensional</b> <b>:</b> most labyrinths, both paper and real, have this dimension, that is, we can always display a plan of the maze on a piece of paper and move along it without crossing any other maze corridors. </li><li>  <a href="http://www.astrolog.org/labyrnth/maze/3d.txt"><b>Three-dimensional</b></a> <b>: the</b> three-dimensional labyrinth has several levels;  in it (at least in the orthogonal version), except for four sides of the world, the aisles can go down and go up.  The 3D maze is often visualized as an array of 2D levels with up and down stairs. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Higher dimensions</b> <b>:</b> you can create four-dimensional mazes and even more multi-dimensional.  Sometimes they are visualized as 3D labyrinths with ‚Äúportals‚Äù leading through the fourth dimension, for example, portals to the ‚Äúpast‚Äù and ‚Äúfuture‚Äù. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Interlacings</b> <b>:</b> labyrinths with interlacings are essentially two-dimensional (or, more precisely, 2.5-dimensional) labyrinths, in which, however, the aisles can overlap each other.  When displayed, it is usually quite obvious where the dead ends are and how one passage is above the other.  Labyrinths from the real world, in which there are bridges that connect one part of the maze with another, are partly interlacing. </li></ul><br>  <b>Hyper-Dimensionality:</b> classification by hyperdimension corresponds to the dimension of an object moving through a maze, and not the maze itself.  There are the following types: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Non-hyperlabirinths</b> <b>:</b> Almost all labyrinths, even those created in high dimensions or having special rules, are usually non-hyperlabirinths.  In them we work with a point or a small object, for example, a ball or the player himself, who move from point to point, and the paved route forms a line.  At each point there is an easily calculated number of choices. </li><li>  <b><a href="http://www.astrolog.org/labyrnth/hypermaz.htm">Hyper-mazes:</a></b> Hyper-mazes are labyrinths in which the object to be solved is not just a point.  The standard hyperlabirinth (or a first-order hyperlabirinth) consists of a line that, when moved along a path, forms a surface.  The hyperlabyrinth can only exist in 3D or in a medium with a higher dimension, and the entrance to the hyperlabyrinth is often not a point, but a line.  The hyperlabyr is fundamentally different because it takes into account and simultaneously works with several parts along the line, and at any given time there is a practically infinite number of states and variants of what can be done with the line.  The solution line is infinite, or its end points are outside of the hyper-maze to avoid line-to-point compression, because in this case it can be considered a non-hyper-maze. </li><li>  <b>Hyper-hyperlabing:</b> hyperlabing can be of arbitrarily high dimension.  The hyper-hyperlabing (or second-order hyper-labyrinth) again increases the dimension of the object being solved.  Here the solvable object is a plane that, when moving along the path, forms a three-dimensional figure.  The hyper-hyperlabirint can exist only in 4D or higher dimensional environments. </li></ul><br>  <b>Topology: A topology</b> class describes the geometry of a maze space in which it exists as a whole.  There are the following types: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Common</b> <b>:</b> This is a standard maze in Euclidean space. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: the</b> term "planair" describes any maze with an unusual topology.  This usually means that the edges of the maze are connected in an interesting way.  Examples: labyrinths on the surface of a cube, labyrinths on the surface of the Mobius strip and labyrinths equivalent to those on the torus, where the left and right, upper and lower sides are connected in pairs. </li></ul><br>  <b>Tessellation: the</b> classification of the geometry of the individual cells that make up the maze.  Existing types: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonal</b> <b>:</b> This is a standard rectangular grid in which cells have aisles that intersect at right angles.  In the context of tessellation, they can also be called gamma-mazes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> Delta mazes are made up of connected triangles, and each cell can have up to three passes connected to it. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>:</b> sigma mazes are composed of connected hexagons;  each cell can have up to six passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Theta</b> <b>:</b> theta labyrinths consist of concentric circles of aisles in which the beginning or end is in the center, and the other is on the outer edge.  Cells usually have four possible aisle junctions, but there may be more due to the larger number of cells in the outer rings of the aisles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Ypsilon</b> <b>: The</b> upsilon labyrinths consist of connected octagons or squares, each cell can have up to eight or four passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: The</b> Zeta Maze is located on a rectangular grid, only in addition to the horizontal and vertical aisles are allowed diagonal passes at a 45 degree angle. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Omega</b> <b>: The</b> term "omega" refers to almost any maze with constant non-orthogonal tessellation.  Delta, sigma, theta, and upsilon labyrinths are of this type, as are many other schemes that can be devised, for example, a maze consisting of pairs of right triangles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Crack</b> <b>:</b> crack labyrinth is an amorphous labyrinth without constant tessellation, in which walls and aisles are located at random angles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fractal</b> <b>: A</b> fractal labyrinth is a labyrinth made up of smaller labyrinths.  A fractal labyrinth of nested cells is a labyrinth, in each cell of which other labyrinths are located, and this process can be repeated several times.  An infinitely recursive fractal labyrinth is a true fractal in which the contents of a labyrinth copy itself, creating essentially an infinitely large labyrinth. </li></ul><br>  <b>Routing: Routing</b> classification is probably the most interesting aspect of maze generation.  From is associated with the types of passes within the geometry defined in the categories described above. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> A maze without loops or closed chains and without unreachable areas is called ‚Äúideal.‚Äù  Also called a maze with a single connection (simply-connected Maze).  From each point there is exactly one path to any other point.  The maze has only one solution.  From the point of view of programming, such a maze can be described as a tree, connecting many cells or vertices. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Braid</b> <b>:</b> Braided means that there are no dead ends in the maze.  Also called a maze with multiple connections (purely multiply connected Maze).  In such a maze, passages are used that close up and return to each other (hence the name ‚Äúwoven‚Äù), they force you to spend more time walking in circles instead of falling into dead ends.  A quality woven labyrinth can be much more complex than a perfect maze of the same size. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single route (Unicursal)</b> <b>:</b> single <b>route</b> means a labyrinth without forks.  The single-path labyrinth contains one long, wriggling passage that changes direction throughout the labyrinth.  It is not very complicated only if you do not accidentally turn back halfway and return to the beginning. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Sparse: a</b> rarefied labyrinth does not make passes through each cell, that is, some of them are not created.  This implies the presence of unattainable areas, that is, it is in some sense opposite to the woven maze.  A similar concept can be applied when adding walls, so you can get an uneven maze with wide aisles and rooms. </li><li>  <b>Partially woven:</b> Partially woven labyrinth is a mixed labyrinth, in which there are loops and dead ends.  The word ‚Äúwoven‚Äù can be used to quantify, that is, a ‚Äúlabyrinth with strong weaving‚Äù is a labyrinth with many loops or recessed walls, and there are only a few in the ‚Äúlabyrinth with weak weaving‚Äù. </li></ul><br>  <b>Texture: Texture</b> classification describes the style of aisles with different routing and geometry.  Texture is not just parameters that can be turned on or off.  Here are some examples of variables: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Bias</b> <b>:</b> In a labyrinth with displaced passages, straight aisles tend to go more in one direction than in others.  For example, in a labyrinth with high horizontal displacement, we will have long passes from left to right, and only short passes from top to bottom connecting them.  Such a maze is usually more difficult to pass "across the fibers." </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Spans</b> <b>: The</b> ‚Äúspans‚Äù indicator determines how long long passes will take before the turns are forced.  In a labyrinth with a low span, there will be no straight passages longer than three or four cells, and it will look very random.  In the labyrinth with a high rate of passage over the course of the labyrinth there will be a large percentage of long passes, which will make it look like a microchip. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elite: The</b> maze "elite" indicator determines the length of the decision regarding the size of the maze.  Elite labyrinths usually have a short, direct solution, and in non-elite labyrinths the solution goes through a large part of the area of ‚Äã‚Äãthe maze.  A quality elite maze can be much more difficult than non-elite. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Symmetry</b> <b>: a</b> symmetrical labyrinth has symmetric passages, for example, in the symmetry of rotation about the center, or reflected along the horizontal or vertical axes.  A labyrinth can be partially or completely symmetrical, and can repeat a pattern any number of times. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogeneity: a</b> homogeneous algorithm generates all possible mazes with equal probability.  A maze can be called having a uniform texture if it looks like a typical maze generated by a homogeneous algorithm.  Theoretically, a non-uniform algorithm can also generate all possible labyrinths in any space, but not with equal probability.  Heterogeneity can go even further - it is possible the existence of labyrinths that the algorithm will never generate. </li><li>  <b>Fluidity (River):</b> ‚Äúfluidity‚Äù means that when creating a labyrinth, the algorithm will search and clean up neighboring cells (or walls) to the current one, that is, it will flow (hence the term ‚Äúfluidity‚Äù) into still uncreated parts of the maze, like water.  In an ideal maze with a lower turnover index, there will usually be a lot of short dead ends, and in a more fluid maze there will be fewer dead ends, but they will be longer. </li></ul><br>  <b>Priority:</b> this classification shows that labyrinth creation processes can be divided into two main types: adding walls and cutting passages.  Usually, when generating it, it comes down only to the difference in algorithms, and not to noticeable differences in the labyrinths, but still it is useful to take this into account.  The same maze is often generated in both ways: <br><br><ul><li>  <b>Adding Walls:</b> Algorithms for which walls are a priority start from a blank area (or external border), adding walls to the process.  In the real world, real labyrinths made up of hedges, floors, or wooden walls are definitely adding walls. </li><li>  <b>Cutting aisles: the</b> algorithms, whose priority is the aisles, start with a solid block and, in the process, cut aisles in it.  In the real world, such labyrinths are mine tunnels or labyrinths inside pipes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Pattern:</b> Of course, labyrinths can simultaneously cut out passages and add walls;  some computer algorithms do that.  A pattern of a maze is a graphic image that is not a maze, which in the fewest steps turns into a real maze, but still retains the texture of the original graphic template.  Complex maze styles, such as intersecting spirals, are easier to implement in your computer as templates, rather than trying to create the correct maze, while at the same time preserving its style. </li></ul><br>  <b>Other: The</b> above is by no means an exhaustive list of all possible classes or elements within each class.  These are only the types of labyrinths that I created myself.  Notice that almost every type of labyrinth, including labyrinths with special rules, can be expressed as a directed graph with a finite number of states and a finite number of choices in each state, and this is called <a href="http://www.astrolog.org/labyrnth/equivlnt.htm"><b>labyrinth equivalence</b></a> .  Here are a few other classifications and types of labyrinths: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Directionality</b> <b>:</b> you can only move in certain directions in one direction.  From the point of view of programming, such a labyrinth will be described by a directed graph, in contrast to an undirected graph describing all other types. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentation</b> <b>: a</b> maze may have different parts corresponding to different classes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labyrinths of infinite length:</b> we can create an infinitely long labyrinth (a finite number of columns and any number of rows), but at the same time keep in memory only one part of the maze, ‚Äúscrolling‚Äù from one end to another and destroying the previous lines when creating the next.  One example is a modified version of the Hunt and Kill algorithm.  You can imagine a potentially endless labyrinth in the form of a long film, made up of individual frames.  Only two consecutive frames are stored in memory at a time.  Let's run the Hunt and Kill algorithm, although it creates bias inclined to the top frame, so it ends first.  After completion, the frame is no longer needed; you can print it out or do something else with it.  Anyway, we discard it, make a partially created lower frame with a new upper frame and clear the new lower frame.  We repeat the process until we decide to stop, after which we wait until Hunt And Kill completes both frames.  The only limitation is that the labyrinth will never have a path branching out into the entrance for a length of more than two frames.  The simplest way to create an infinite maze is the Eller algorithm or the Sidewinder algorithm, because they already create mazes one line at a time, so you can simply allow them to add lines to the maze indefinitely. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="image"><br><br></b>  <b>Virtual fractal labyrinths:</b> virtual is a maze in which the entire maze is not stored in memory at the same time.  For example, it can store only a portion of the 100x100 aisles near your location in a simulation where you walk through a large maze.  Expansion of nested fractal labyrinths can be used to create virtual labyrinths of enormous size, for example, billion per billion passes.  If we built a real copy of the maze of a billion to a billion passes (with a distance of six feet between the passes), then it would fill the surface of the Earth more than 6000 times!  Consider a maze of 10 <sup>9</sup> by 10 <sup>9</sup> passes, or a nested maze with just 9 levels.  If we want to have at least a part of 100x100 in size around us, then it is enough to create at the lowest level a sub-maze of 100x100 passes and seven 10x10 mazes in which it is embedded in order to know exactly where the walls are within the part of 100x100.  (In fact, it‚Äôs better to have four neighboring parts of 100x100 in size, forming a square in case you are near the edge or corner of the part, but the same concept applies.) To ensure the maze remains constant and unchanged when moving along it, we have the formula defining a random generating number (seed) for each coordinate at each nesting level.  Virtual fractal labyrinths are similar to the Mandelbrot fractal, in the images of which it exists virtually, and we need to visit a certain coordinate at a high enough magnification.  so he manifested. </li></ul><br><h2>  Algorithms for creating labyrinths </h2><br>  Here is a list of generalized algorithms for creating various classes of labyrinths described above: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> to create a standard perfect maze it is usually necessary to ‚Äúgrow‚Äù it, ensuring there are no loops and no isolated areas.  We start with the outer wall and randomly add a fragment of the wall relating to it.  We continue to randomly add wall segments to the labyrinth, but check that each new segment touches one end of the existing wall and its other end is in the still uncreated part of the maze.  If you add a wall segment, both ends of which are separated from the rest of the maze, this will create an unconnected wall with a loop around, and if you add a segment, both ends of which touch the maze, then this will create an unattainable area.  This is the method of adding walls;  almost the same way as cutting passages, in which parts of the passages are cut in such a way that only one end touches the existing passage. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Wicker</b> <b>:</b> to create a labyrinth without dead ends, in fact, you need to add wall segments to the labyrinth randomly, but make sure that each new added segment does not create a dead end.  I create them in four stages: (1) I start from the outer wall, (2) walk around the maze and add separate wall segments that touch each wall top so that there are no open rooms or small pillars in the labyrinth, (3) go around all possible wall segments in random order, adding a wall where it does not create a dead end, (4) or start the procedure for removing isolated areas at the end so that the maze is correct and has a solution, or I do smarter in step (3) and do so that the wall is added only when it cannot lead to  molded area. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single route</b> <b>:</b> One way to create a random single route maze is to create a perfect maze, close the exit so that only one entrance remains, and then add walls dividing each passage into two parts.  This turns each impasse into a U-shaped turn, and we have a single-route passage, starting and ending at the beginning of the original maze, which will follow the same path as moving along the wall of the original maze.  The new single-route labyrinth will have twice the size relative to the original ideal maze.  You can add small tricks so that the beginning and the end are not always next to each other: when creating the perfect maze, we will never add segments that connect to the right or bottom walls, so the resulting maze will have a simple solution that follows the wall.  Put the entrance in the upper right corner, and after splitting it in half to create one route, remove the right and the bottom walls.  The result is a single-route maze, starting in the upper right corner and ending in the lower left. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br></b>  <b>Sparse:</b> sparse labyrinths are created by the decision not to grow a maze in areas that will violate the rule of sparseness.  For a holistic implementation of this, when selecting a new cell to be cut, first check all the cells located in the semicircle of the selected cell radius located in front of the current direction.  If one of these cells is already part of the maze, then we do not allow to look at these cells, because otherwise they will be too close to the existing cell, which means they will turn the maze into un-thinned. </li><li>  <a href="http://www.astrolog.org/labyrnth/maze/3d.txt"><b>3D</b></a> <b>:</b> three-dimensional labyrinths and labyrinths of higher dimension can be created in the same way as a standard two-dimensional perfect maze, only from each cell one can randomly move to six, and not four orthogonal cells.  Because of the extra dimensions in these mazes, aisle cutting is usually used. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Intertwined</b> <b>:</b> intertwined labyrinths are essentially created as ideal labyrinths with cutting passages, only when cutting passages we are not always limited to the existing passage, because we have the opportunity to go under it and still maintain the ideality of the maze.  In a monochrome raster image, an interlaced maze can be represented in four lines per pass (two lines per pass is enough for a standard perfect maze): one line for the passage itself, and the other three lines clearly show when another neighboring passage goes under it and does not simply form a dead end next to the first pass.  For the sake of aesthetics, before cutting under the ready-made passage, you can look ahead to be sure.  that you can continue cutting while under it;  so you can avoid dead ends, located directly under the other passages.  Also, after cutting under the passage, you can invert the pixels adjacent to the intersection so that new passages pass over the old ones, and not under them. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  ¬´¬ª        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     ¬´¬ª    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  ‚Äî  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     ‚Äî       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many ways to create perfect mazes, and each one has its own characteristics. </font><font style="vertical-align: inherit;">Below is a list of specific algorithms. </font><font style="vertical-align: inherit;">All of them described the creation of a maze by cutting out passages, however, unless otherwise indicated, each can also be done by adding walls:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursive backtracker </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     ¬´¬ª   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b>  ()</b> <b>:</b>      ,     .      .     (   ,       ).       ,    ,      ,      .   ,      .          (    ),    .   ,    ,           log(n).     ,      ,         .       seed        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br> <b>  ()</b> <b>:</b>       .    ,     .     ,   .    .     ,    ,     ,      .   ,      .         ,      ,             .           .            ,     ,       ,   ,         ,   . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br> <b>  ()</b> <b>:</b>       ,  ,     .     ,      .     .           : (1) "":         , (2) "":           ,     ,    ¬´¬ª,  (3) "":      ,          ¬´¬ª .    ,   ¬´¬ª,        ¬´¬ª.    ¬´¬ª           ¬´¬ª .    ¬´¬ª   ¬´¬ª        ¬´¬ª  ¬´¬ª.  ,     ¬´¬ª  (     ¬´¬ª ,  ,   ¬´¬ª).         ,        .         ,   :     ,       ,             ,   .  ,   ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br> <b> -</b> <b>:</b>     ,   ,            .  ,       .         .      ,        .     ,       .        ,   ,    . ( ,           ,   ,          .)     ,    ,        ,        .  -         ,   ,     .          ,    ,         ,         .       ,      , .., ,       ,       ,     .           ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br> <b> </b> <b>:</b>     -,         ( ,         ),      .       .       .   ,          ,    ,   .         ,,          ,     . ,             ,          .        ,        .  ,      .       ,   -,              ,           .         -,         .  ,           ,         ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br> <b> Hunt and kill</b> <b>:</b>   ,        ,                .      ,    ,              .     recursive backtracker,        .     ¬´¬ª    ,          .           .  ,    ¬´¬ª   .          ,    ,   recursive backtracker.          ,     ¬´¬ª.    - ,      ,    ,   .       ,       ,   ,  recursive backtracker. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br> <b>  <br>  (Growing tree algorithm)</b> <b>:</b>   ,      .      .         .             .       ,     .  ,      .    ,              . ,      ,      recursive backtracker.     ,     ,     .      ,   ,         ,  ,    .      ,       ,       ,     .        ,       ,     . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br> <b>   (Growing forest algorithm)</b> <b>:</b>    ,    ,     .      ,       ,  .    ,      ¬´¬ª;  ,      ,     .      ,     ¬´¬ª   ¬´¬ª.    ¬´¬ª          ¬´¬ª ,      ¬´¬ª     .         ,   ,      ,   ,      .        ¬´¬ª ,       ¬´¬ª.  ,     ¬´¬ª.       ,    .     ,        ¬´¬ª   ¬´¬ª,     .         ,     ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Heller's algorithm</b> <b>:</b> this is a special algorithm, because it is not only the fastest of all others, but also has no obvious bias or flaws;  in addition, when creating it, memory is used most efficiently.  It doesn‚Äôt even require that the entire maze be in memory, it uses a volume proportional to the size of the line.  It creates a maze line by line, after the generation of the string is completed, the algorithm no longer takes it into account.  Each cell in the row is contained in the set;  two cells belong to the same set if there is a path between them through the already created maze.  This information allows you to cut passes in the current line without creating loops or isolated areas.  In fact, this is quite similar to the Kruskal algorithm, only here it is formed one line at a time, while Kraskal looks through the entire maze.  Creating a string consists of two parts: we randomly connect adjacent cells within a row, i.e.  cut horizontal passes, then randomly connect the cells between the current and next lines, i.e.  cut vertical passages.  When cutting horizontal passes, we do not connect cells that are already in the same set (because otherwise a loop will be created), and when cutting vertical passes we must connect a cell if it has a unit size (because if we leave it, it will create an isolated area).  When cutting horizontal passages, we connect cells, if they are in the same set (because there is now a path between them), and when cutting vertical passages when we are not connected to a cell, we place it into a separate set (because now it is separated from the rest of the maze ).  The creation begins with the fact that before connecting the cells in the first row, each cell has its own set.  Creation is completed after the cells are connected in the last row.  There is a special completion rule: by the time of completion, each cell must be in the same set to avoid isolated areas.  (The last line is created by combining each of the pairs of neighboring cells that are not yet in the same set.) It‚Äôs best to implement the set using a cyclic doubly linked list of cells (which can be just an array that binds the cells to pairs of cells on both sides of the same set), allowing perform inserting, deleting and checking the presence of neighboring cells in one set in constant time.  The problem with this algorithm is the imbalance in the processing of different edges of the maze;  To avoid stains in textures, you need to make the connection and skip the connection of the cells in the correct proportions. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Recursive division:</b> this algorithm is somewhat similar to recursive backtracking, because in both of them stacks are used, only it works not with aisles, but with walls.  We start by creating a random horizontal or vertical wall intersecting the accessible area in a random row or column, and place random spaces along it.  Then we recursively repeat the process for the two subdomains generated by the dividing wall.  For best results, you should add a deviation in the choice of horizontal or vertical based on the proportions of the area, for example, an area whose width is twice the height should be more often divided by vertical walls.  This is the fastest algorithm without deviations in directions, and often it can even compete with labyrinths based on binary trees, because it creates several cells at the same time, although it has an obvious drawback in the form of long walls that intersect the interior of the labyrinth.  This algorithm is a kind of nested fractal labyrinths, but instead of constantly creating labyrinths of fixed-size cells with labyrinths of the same size inside each cell, it randomly divides a given area into a random-sized labyrinth: 1x2 or 2x1.  Recursive division cannot be used to cut aisles, because it leads to the creation of an obvious solution that either follows along the outer edge, or otherwise intersects the inside. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labyrinths based on binary trees</b> <b>:</b> in fact, these are the simplest and fastest of the possible algorithms, but the mazes that are created have a texture with very high bias.  For each cell, we cut a passage either up or left, but never in both directions.  In the wall version, a wall segment is added for each vertex, leading down or to the right, but not in both directions.  Each cell is independent of all other cells, because we do not need to check the state of any other cells when creating it.  Therefore, this is a true algorithm for generating labyrinths with no memory, not limited by the size of the labyrinths being created.  In fact, this is a binary tree, if we consider the upper left corner as a root, and each node or cell has one unique parent node, which is a cell above or to the left of it.  Labyrinths based on binary trees are different from the standard ideal mazes, because more than half of the cell types cannot exist in them.  For example, there will never be intersections in them, and all dead ends have passages leading up or to the left and never leading down or to the right.  Labyrinths tend to have passages leading diagonally from the upper left to the lower right corner, and along them it is much easier to move from the lower right to the upper left corner.  You can always move up or left, but never simultaneously in both directions, so you can always deterministically move diagonally up and left without colliding with barriers.  You will have the opportunity to choose and get into dead ends by moving down and to the right.  Keep in mind that if you turn the binary tree maze upside down and count the aisles as walls, and vice versa, the result will essentially be another binary tree. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br></b>  <b>Sidewinder Labyrinths:</b> This simple algorithm is very similar to the binary tree algorithm, but a bit more complicated.  The labyrinth is generated one line at a time: for each cell, it is randomly selected whether to cut a passage leading to the right.  If the passage is not cut, then we consider that we have just completed a horizontal passage formed by the current cell and all the cells on the left that cut the passages leading into it.  Randomly select one cell along this passage and cut a passage leading up from it (this should be the current cell if the neighboring cell has not cut the passage).  While the labyrinth of a binary tree always rises up from the leftmost cell of a horizontal passage, the sidewinder maze rises up from a random cell.  In the binary tree, the labyrinth in the upper and left edges has one long passage, and in the sidewinder labyrinth there is only one long passage along the upper edge.  Like the binary tree labyrinth, the sidewinder maze can be error-free and deterministically solved from the bottom up, because there will always be exactly one pass leading up in each row.  The sidewinder maze solution never loops or visits the same line more than once, but it "squirms from side to side."  The only cell type that cannot exist in the sidewinder maze is a dead end with a downward walkway, because it will be against the rule that every pass that leads upwards returns us to the beginning.  Sidewinder mazes are prone to the appearance of an elite solution, in which the right path turns out to be very straightforward, but next to it there are many long error paths leading from top to bottom. </li></ul><br><table><tbody><tr><td>  <b>Algorithm</b> </td><td>  <b>% dead ends</b> </td><td>  <b>Type of</b> </td><td>  <b>A priority</b> </td><td>  <b>Is there biasedness?</b> </td><td>  <b>Homogeneous?</b> </td><td>  <b>Memory</b> </td><td>  <b>Time</b> </td><td>  <b>% solutions</b> </td></tr><tr><td>  Single route </td><td>  0 </td><td>  Tree </td><td>  Walls </td><td>  Yes </td><td>  Never </td><td>  N ^ 2 </td><td>  379 </td><td>  100.0 </td></tr><tr><td>  Recursive Backtracker </td><td>  ten </td><td>  Tree </td><td>  The walkways </td><td>  Yes </td><td>  Never </td><td>  N ^ 2 </td><td>  27 </td><td>  19.0 </td></tr><tr><td>  Hunt and kill </td><td>  11 (21) </td><td>  Tree </td><td>  The walkways </td><td>  Yes </td><td>  Never </td><td>  0 </td><td>  100 (143) </td><td>  9.5 (3.9) </td></tr><tr><td>  Recursive division </td><td>  23 </td><td>  Tree </td><td>  Walls </td><td>  Yes </td><td>  Never </td><td>  N * </td><td>  ten </td><td>  7.2 </td></tr><tr><td>  Binary tree </td><td>  25 </td><td>  Lots of </td><td>  Both </td><td>  Not </td><td>  Never </td><td>  0 * </td><td>  ten </td><td>  2.0 </td></tr><tr><td>  Sidewinder </td><td>  27 </td><td>  Lots of </td><td>  Both </td><td>  Not </td><td>  Never </td><td>  0 * </td><td>  12 </td><td>  2.6 </td></tr><tr><td>  Eller's algorithm </td><td>  28 </td><td>  Lots of </td><td>  Both </td><td>  Not </td><td>  Not </td><td>  N * </td><td>  20 </td><td>  4.2 (3.2) </td></tr><tr><td>  Wilson's algorithm </td><td>  29 </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Yes </td><td>  N ^ 2 </td><td>  48 (25) </td><td>  4.5 </td></tr><tr><td>  Aldous-Brodera Algorithm </td><td>  29 </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Yes </td><td>  0 </td><td>  279 (208) </td><td>  4.5 </td></tr><tr><td>  Kruskal Algorithm </td><td>  thirty </td><td>  Lots of </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  33 </td><td>  4.1 </td></tr><tr><td>  Prima algorithm (true) </td><td>  thirty </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  160 </td><td>  4.1 </td></tr><tr><td>  Prima algorithm (simplified) </td><td>  32 </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  59 </td><td>  2.3 </td></tr><tr><td>  Prima algorithm (modified) </td><td>  36 (31) </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  thirty </td><td>  2.3 </td></tr><tr><td>  Growing a tree </td><td>  49 (39) </td><td>  Tree </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  48 </td><td>  11.0 </td></tr><tr><td>  Growing forest </td><td>  49 (39) </td><td>  Both </td><td>  Both </td><td>  Yes </td><td>  Not </td><td>  N ^ 2 </td><td>  76 </td><td>  11.0 </td></tr></tbody></table><br>  This table briefly presents the characteristics of the algorithms for creating ideal mazes described above.  For comparison, a single-route maze algorithm has been added (theoretically, single-route mazes are ideal).  Explanation of columns: <br><br><ul><li>  <b>Dead End:</b> This is an approximate percentage of cells that are dead ends in a maze created using this algorithm in the case of an orthogonal 2D maze.  The algorithms in the table are sorted by this field.  Usually, when adding walls, the percentage is the same as when cutting passages, but if they are significantly different, then the percentage when adding walls is shown in brackets.  The value for the tree growing algorithm actually varies from 10% (if the newest cell is always chosen) to 49% (we always choose the oldest cell).  With a sufficiently high pass rate, the number of dead ends of the Recursive Backtracker can fall below 1%.  The highest probable percentage of dead ends in a two-dimensional orthogonal ideal maze is 66%: this will be a single-route passage with a bunch of dead ends of unit length on both sides of it. </li><li>  <b>Type:</b> there are two types of algorithms for creating perfect mazes: a tree-based algorithm grows a maze like a tree, always adding to what it already has and having the correct perfect maze at each stage.  The set-based algorithm performs constructions where it wants, tracking parts of the maze, connected to each other, to connect everything and create the right maze at the time of completion.  Some algorithms, such as the forest growing algorithm, use both approaches simultaneously. </li><li>  <b>Priority:</b> most algorithms can be implemented either as cutting passes, or as adding walls.  Very few can be implemented only as one or the other approach.  In single-route labyrinths, the addition of walls is always used, because they involve splitting the aisles by walls into two parts, but the basic labyrinth can be created in any way.  Recursive Backtracker cannot be implemented with the addition of walls, because in this case it tends to create a solution path that follows the outer edge, and the entire inner part of the labyrinth is connected to the border with a single pass.  Similarly, recursive division can be realized only through the addition of walls, because this algorithm performs the division in half.  Strictly speaking, for the same reason, Hunt and Kill can be realized only through cutting passages, however, it can also use the addition of walls, if special efforts are made to give equal growth inwards from all walls of the borders. </li><li>  <b>Lack of bias:</b> does the algorithm equally perceive all directions and sides of the maze so that subsequent analysis of the maze cannot detect any bias of the passages.  The binary tree algorithm is extremely biased, it is easy to move in one corner and difficult to the opposite.  Sidewinder is also offset, it is easy to move to one edge and difficult to the opposite.  Eller's algorithm is prone to creating passages, roughly synchronizing the starting or ending edges.  There is no bias in Hunt and Kill if the hunt is conducted column by column, and also line by line to avoid slight bias along one axis. </li><li>  <b>Uniformity:</b> Does the algorithm generate all possible labyrinths with equal probability?  ‚ÄúYes‚Äù means that the algorithm is completely homogeneous.  ‚ÄúNo‚Äù means that the algorithm can potentially generate all possible labyrinths within any space, but not with equal probability.  ‚ÄúNever‚Äù means that there are possible labyrinths that the algorithm can never generate.  Note that only algorithms with complete lack of bias can be completely homogeneous. </li><li>  <b>Memory: the</b> amount of additional memory or stack needed to implement the algorithm.  Efficient algorithms require only the maze's bitmap, while others require a memory size proportional to one row (N) or proportional to the number of cells (N ^ 2).  Some algorithms do not even need to remember the whole maze, and they can add parts of the maze indefinitely (such algorithms are marked with an asterisk).  Heller's algorithm needs the amount of memory to store the string, but it doesn‚Äôt need more, because it is enough to store only one line of the maze.  The Sidewinder algorithm also needs to store only one line of the maze, while the binary tree only needs to track the current cell.  Recursive division requires a stack up to the size of a string, but it does not need to look at the maze's bitmap. </li><li>  <b>Time:</b> this parameter gives an idea of ‚Äã‚Äãhow much time it takes to create a maze using this algorithm, the smaller the number, the faster it works.  Unlike other units of measurement, here the numbers are relative to each other (the fastest algorithm is assigned a speed of 10), because time depends on the size of the maze and the speed of the computer.  The numbers of the table are taken when creating the mazes from the 100x100 aisles in the latest version of Daedalus.  Usually the creation by adding walls takes as much time as it takes to cut aisles, but if the values ‚Äã‚Äãare very different, then the time to add the walls is indicated in brackets. </li><li>  <b>Solution:</b> this is the percentage of cells in the labyrinth through which its solution passes for a typical maze created by an algorithm.  Here it is assumed that the labyrinth consists of 100x100 passes.  and the beginning and end are in opposite corners.  This parameter is an indicator of the "tortuosity" of the solution.  The maximum tortuosity has one-route labyrinths, because the solution passes through the entire labyrinth.  The smallest possible tortuosity has a binary tree, in which the solution simply crosses the maze and never deviates or stops moving towards the end.  Typically, the creation by adding walls has the same properties as cutting aisles, but if the values ‚Äã‚Äãare very different, then the percentage in the case of adding walls is indicated in brackets. </li></ul><br><h2>  Algorithms for solving labyrinths </h2><br>  There are many ways to solve labyrinths, and each of them has its own characteristics.  Here is a list of specific algorithms: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br>  <b>Following the walls (Wall follower)</b> <b>:</b> this is a simple algorithm for solving labyrinths.  The priority for him is a passing maze object (‚Äúyou‚Äù), it is always very fast and does not use additional memory.  We start to go along the aisles and when reaching the fork, always turn right (or always left).  To apply such a maze solution in the real world, you need to put your hand on the right (or left) wall and constantly keep it on the wall in the process of passing the maze.  If desired, you can mark already visited cells and cells that have been visited twice.  In the end, you can go back to the decision, following only the cells visited once.  This method does not necessarily find the shortest solution, and it does not work at all if the target is located in the center of the maze and is surrounded by a closed circuit, because you will walk around the center and eventually come to the beginning.  Following along the wall in the 3D maze can be realized in a deterministic way by projecting 3D passes on the 2D plane, i.e.  pretending that the upstairs passages actually lead to the north-west, and the downward paths lead to the south-east, and then apply the usual rules for following along the walls. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br>  <b>Pledge Algorithm</b> <b>:</b> This is a modified version of the following along the wall, capable of jumping between the "islands" to solve those labyrinths that follow the walls are not capable of.  This is a guaranteed way to reach the outer edge of any 2D maze from any point inside, but it is not able to perform the inverse task, i.e.  find a solution inside the maze.  It is well suited to be realized with the help of a robot escaping from a maze, because it can get out of any maze without marking and not remembering the way.  We start with a choice of direction and, if possible, always move in that direction.  Having rested against the wall, we begin to follow along it, until we can again go in the chosen direction.  It should be noted that the following along the wall must begin with the far wall, which we rested.  If at this point the passage makes a turn, then it can lead to a turn in the middle of the passage and return the same way we came.  When following along the wall, we count the number of turns made, for example, turning left is -1, and turning right is 1. We stop following along the walls and start moving in the chosen direction only when the total amount of turns made is equal, i.e.  if you turned 360 degrees or more, then we continue to follow along the wall until we unravel.  The calculation ensures that sooner or later we will reach the distant part of the "island" in which we are at the moment and jump to the next island in the chosen direction, after which we will continue to jump between the islands until we rest on the border wall, after which the following along the walls    .  ,             ,           .      ,    ‚Äî    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      ¬´¬ª      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   ¬´¬ª, ,     ,  ¬´¬ª, ,       .  ,         ,    ¬´¬ª;    ¬´¬ª       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Tr√©maux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  ‚Äî   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   ‚Äî   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   ¬´¬ª ,          (      ),   ¬´¬ª  , ,     .      ¬´¬ª,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   ¬´¬ª ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    ¬´¬ª ,          (  ).   ¬´ ¬ª       (   ),       ,   .      ¬´¬ª,     ,       ,   ,     . ( ,    ¬´¬ª,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  one </td><td>  Not </td><td>  You </td><td>  /  </td><td>  Not </td><td>  Yes </td><td>  Not </td></tr><tr><td> Wall Follower </td><td>  one </td><td>  Not </td><td>  You </td><td>  /  </td><td>  Yes </td><td>  Yes </td><td>  Yes </td></tr><tr><td>   </td><td>  one </td><td>  Not </td><td>  You </td><td>  /  </td><td>  Yes </td><td>  Yes </td><td>  Yes </td></tr><tr><td>   </td><td>  one </td><td>  Yes </td><td> + </td><td>  Not </td><td>  Yes </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursive Backtracker </font></font></td><td>  one </td><td>  Yes </td><td>  You </td><td>  Not </td><td>  Yes </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tremo Algorithm </font></font></td><td>  one </td><td>  Yes </td><td>  You </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inside / over </font></font></td><td>  Not </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dead end filler </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All + </font></font></td><td>  Not </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Above </font></font></td><td>  Not </td><td>  Yes </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cul-de-sac Filler </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All + </font></font></td><td>  Not </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Above </font></font></td><td>  Not </td><td>  Yes </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blind Alley Sealer </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All + </font></font></td><td>  Yes </td><td>  Labyrinth </td><td>  Not </td><td>  Not </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blind Alley Filler </font></font></td><td>  Everything </td><td>  Yes </td><td>  Labyrinth </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Above </font></font></td><td>  Not </td><td>  Yes </td><td>  Not </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collision solver </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the shortest </font></font></td><td>  Yes </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You + </font></font></td><td>  Not </td><td>  Not </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for the shortest paths </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the shortest </font></font></td><td>  Yes </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You + </font></font></td><td>  Not </td><td>  Yes </td><td>  Not </td><td>  Yes </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finding the shortest path </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 shortest </font></font></td><td>  Yes </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You + </font></font></td><td>  Not </td><td>  Yes </td><td>  Not </td><td>  Yes </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This table briefly lists the characteristics of the maze-solving algorithms described above. </font><font style="vertical-align: inherit;">By these criteria, it is possible to classify and evaluate algorithms for solving labyrinths. </font><font style="vertical-align: inherit;">Explanation of columns:</font></font><br><br><ul><li> <b>:</b>       ,   .        .  ,  ()       . Dead end filler  cul-de-sac filler (  blind alley sealer     )   ,      ,        ,      ¬´+¬ª. </li><li> <b>:</b>        .  Random mouse  ¬´¬ª,      ,   wall follower     ¬´¬ª,       ,     .  dead end filler  cul-de-sac filler  ¬´¬ª,           . </li><li> <b>:</b>      :   ¬´¬ª (  )    .    ,       (   ¬´¬ª)    (¬´+¬ª)          .    ,          . </li><li> <b> :</b>        ,     ,     .   ,   ¬´¬ª,    ,    (  ),  ,   ,    ,     .            . </li><li> <b>  :</b>      .   ,       ,     ,     ,         . Wall follower,             . Recursive backtracker  shortest path(s) finder     . </li><li> <b>  :</b>         .                    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is the decision process considered fast? </font><font style="vertical-align: inherit;">The most efficient algorithms just look at each cell of the maze only once, or they can completely skip parts of it. </font><font style="vertical-align: inherit;">The execution time should be proportional to the size of the maze, or O (n ^ 2), where n is the number of cells along one side. </font><font style="vertical-align: inherit;">Random mouse is slow because its completion is not guaranteed, and the blind alley filler potentially solves a maze from each fork.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other maze operations </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition to creating and solving labyrinths, you can perform other operations with them: </font></font><br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br> :</b>  ¬´  ¬ª,      ,         Fill  FloodFill.  FloodFill   ,      ,     .  ,       ,  FloodFill  ,     .  ,      ,  FloodFill  ,      ,        .          ¬´¬ª    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br>    (Isolation remover):</b>    ,        ,        .   ,       .    ,     .   (   ,      )    ,    .         ,        ,      .         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br>  :</b>    ,            ,               .        ,      ,  .    ,    .   (   ,       )        .         ,    ,        ,     .                ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br> <b>  </b> <b>:</b>       ,       .   ,       ,    ,        ,    .  ,      ,   .       ,        .           ,    blind alley sealer (    ,            ).   ,    ,   . </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm implementations </font></font></h2><br><ul><li> <a href="http://www.astrolog.org/labyrnth/daedalus.htm"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daedalus</font></font></b></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all the above algorithms for creating and solving mazes are implemented in Daedalus, a free and downloadable Windows program. </font><font style="vertical-align: inherit;">Daedalus comes with full source code.</font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/445378/">https://habr.com/ru/post/445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445362/index.html">The book "Distributed Systems. Design Patterns ¬ª</a></li>
<li><a href="../445366/index.html">How to speed up encryption in accordance with GOST 28147-89 on a Baikal-T1 processor due to a SIMD unit</a></li>
<li><a href="../445368/index.html">Load testing games with a couple of hundreds of thousands of virtual users</a></li>
<li><a href="../445370/index.html">TSDB Analysis in Prometheus 2</a></li>
<li><a href="../445372/index.html">Machine Vision vs Human Intuition: Algorithms for Disruption of Object Recognition</a></li>
<li><a href="../445380/index.html">Modern PHP is beautiful and productive.</a></li>
<li><a href="../445384/index.html">Mission "Chang'e-4" - scientific equipment on the landing module and the satellite transponder</a></li>
<li><a href="../445390/index.html">Idea normal person or why we chose Monaco</a></li>
<li><a href="../445392/index.html">MyTarget Dynamic Remarketing: Non-Personal Product Tips</a></li>
<li><a href="../445394/index.html">Changes in 3D secure protocol: we meet 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>