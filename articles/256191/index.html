<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Virtual memory organization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrahabr! 

 In the previous article, I talked about vfork () and promised to talk about the implementation of the fork () call both with and wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Virtual memory organization</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/f89/94f/b9d/f8994fb9def84ba4882b9f1405a6eb49.jpg">  Hi, Habrahabr! <br><br>  In the <a href="http://habrahabr.ru/company/embox/blog/232605/">previous article,</a> I talked about <i>vfork ()</i> and promised to talk about the implementation of the <i>fork ()</i> call both with and without MMU support (the latter, of course, with significant restrictions).  But before going into the details, it would be more logical to start with a virtual memory device. <br><br>  Of course, many have heard about the MMU, page tables and TLB.  Unfortunately, materials on this topic usually consider the hardware side of this mechanism, mentioning the mechanisms of the OS only in general terms.  I want to make out the specific software implementation in the <a href="https://github.com/embox/embox">Embox</a> project.  This is just one of the possible approaches, and it is easy enough to understand.  In addition, it is not a museum piece, and if you wish, you can get under the hood of the OS and try to change something. <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  Any software system has a logical memory model.  The simplest of them is the same as physical, when all programs have direct access to the entire address space. <br>  With this approach, programs have access to the entire address space, not only can "interfere" with each other, but can also lead to the failure of the entire system - for this it is enough, for example, to wipe a piece of memory in which the OS code is located.  In addition, sometimes physical memory may simply not be enough for all the necessary processes to work simultaneously.  Virtual memory is one of the mechanisms for solving these problems.  This article discusses how to work with this mechanism from the operating system on the example of <a href="https://github.com/embox/embox">the Embox OS</a> .  All functions and data types mentioned in the article can be found in the source code of our project. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A number of listings will be given, and some of them are too cumbersome to be placed in the article in its original form, therefore, if possible, they will be shortened and adapted.  Also in the text there will be references to functions and structures that are not directly related to the subject of the article.  A brief description will be given for them, and more complete information on implementation can be found on the project wiki. <br><br><h1>  General ideas </h1><br>  Virtual memory is a concept that avoids the use of physical addresses using virtual ones instead, and this gives a number of advantages: <br><ul><li>  Expansion of real address space.  A part of virtual memory can be preempted onto a hard disk, and this allows programs to use more RAM than they actually are. </li><li>  Creating isolated address spaces for various processes, which increases the security of the system, and also solves the problem of attachment of the program to certain memory addresses. </li><li>  Setting different properties for different parts of memory plots.  For example, there may be an immutable chunk of memory visible to several processes. </li></ul><br>  In this case, the entire virtual memory is divided into chunks of constant size, called pages. <br><br><h2>  Hardware support </h2><br>  <abbr title="Memory Management Unit - memory management unit">The MMU</abbr> is a hardware component of a computer through which all requests to the memory made by the processor ‚Äúpass‚Äù.  The task of this device is address translation, memory caching management and its protection. <br><br>  The appeal to memory is well described in <a href="http://habrahabr.ru/post/211150/">this habrostate</a> .  It occurs as follows: <br><blockquote>  The processor provides a virtual address for MMU input. <br>  If the MMU is turned off, or if the virtual address is in an untranslated region, then the physical address is simply equated to virtual <br>  If the MMU is enabled and the virtual address is in the broadcast area, the address is translated, that is, the virtual page number is replaced with the physical page number corresponding to it (the same offset within the page): <br>  If the entry with the desired virtual page number is in the TLB [Translation Lookaside Buffer], then the physical page number is taken from it. <br>  If there is no necessary record in the TLB, then it is necessary to look for it in the page tables that the operating system places in the non-translated RAM area (so that there is no TLB miss when processing the previous slip).  The search can be implemented both in hardware and in software - through an exception handler, called a page fault.  The found entry is added to the TLB, after which the command that caused the TLB miss is executed again. <br></blockquote><br>  Thus, when a program accesses a particular section of memory, address translation is performed in hardware.  The software part of working with the MMU is the formation of page tables and work with them, the allocation of memory areas, the installation of certain flags for the pages, as well as the processing of the page fault, an error that occurs when there is no page in the display. <br><br>  The article will mainly consider a three-level memory model, but this is not a fundamental limitation: to obtain a model with more levels, you can act in a similar way, and the features of working with fewer levels (for example, in the x86 architecture there are only two levels ) will be reviewed separately. <br><br><h2>  Software support </h2><br>  For applications, working with virtual memory is invisible.  This transparency is provided by the presence in the kernel of the OS of the corresponding subsystem that performs the following actions: <br><ul><li>  Allocating physical pages from some reserved area of ‚Äã‚Äãmemory </li><li>  Making appropriate changes to the virtual memory table </li><li>  Comparison of virtual memory plots with the processes that allocated them </li><li>  Projecting a physical memory region to a virtual address </li></ul><br>  These mechanisms will be discussed in detail below, after introducing several basic definitions. <br><br><h2>  Virtual address </h2><br>  <i>Page Global Directory</i> (hereinafter - <i>PGD</i> ) - a table (hereinafter - the same as the directory) of the highest level, each entry in it - a link to the <i>Page Middle Directory</i> ( <i>PMD</i> ), whose records, in turn, refer to the table <i>Page Table Entry</i> ( <i>PTE</i> ).  Entries in <i>PTE</i> refer to real physical addresses, and also store page status flags. <br><br>  That is, with a three-level memory hierarchy, the virtual address will look like this: <br><img src="https://habrastorage.org/files/c0e/592/40c/c0e59240cf4949eaaf92369a86cde211.png"><br><br>  The values ‚Äã‚Äãof the <i>PGD</i> , <i>PMD</i> and <i>PTE</i> fields are the indices in the respective tables (i.e., the shifts from the beginning of these tables), and the <i>offset</i> is the offset of the address from the beginning of the page. <br><br>  Depending on the architecture and paging mode, the number of bits allocated to each of the fields may vary.  In addition, the page hierarchy itself may have a number of levels other than three: for example, there is no <i>PMD</i> on x86. <br><br>  To ensure portability, we defined the boundaries of these fields using the constants: <i>MMU_PGD_SHIFT</i> , <i>MMU_PMD_SHIFT</i> , <i>MMU_PTE_SHIFT</i> , which in the above diagram are equal to 24, 18 and 12, respectively, their definition is given in the header file <a href="">src / include / hal / mmu.h.</a>  In the following, this particular example will be considered. <br><br>  Based on the <i>PGD</i> , <i>PMD,</i> and <i>PTE</i> shifts, the corresponding address masks are calculated. <br><pre><code class="hljs lisp">#define MMU_PTE_ENTRIES (<span class="hljs-number"><span class="hljs-number">1</span></span>UL &lt;&lt; (<span class="hljs-name"><span class="hljs-name">MMU_PMD_SHIFT</span></span> - MMU_PTE_SHIFT)) #define MMU_PTE_MASK ((<span class="hljs-name"><span class="hljs-name">MMU_PTE_ENTRIES</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; MMU_PTE_SHIFT) #define MMU_PTE_SIZE (<span class="hljs-number"><span class="hljs-number">1</span></span>UL &lt;&lt; MMU_PTE_SHIFT) #define MMU_PAGE_SIZE (<span class="hljs-number"><span class="hljs-number">1</span></span>UL &lt;&lt; MMU_PTE_SHIFT) #define MMU_PAGE_MASK (<span class="hljs-name"><span class="hljs-name">MMU_PAGE_SIZE</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><br>  These macros are given in the same header file. <br><br>  To work with virtual tables of virtual memory, pointers to all <i>PGDs</i> are stored in a certain area of ‚Äã‚Äãmemory.  In <i>addition</i> , each task stores the context of <i>mm mm_context</i> , which, in fact, is an index in this table.  Thus, for each task there is one <i>PGD</i> table, which can be defined using <i>mmu_get_root (ctx)</i> . <br><br><h2>  Pages and work with them </h2><br><h3>  Page size </h3><br>  In real (that is, not in training) systems, pages from 512 bytes to 64 kilobytes are used.  Most often, the page size is determined by the architecture and is fixed for the entire system, for example - 4 KiB. <br><br>  On the one hand, with a smaller page size, memory is less fragmented.  After all, the smallest unit of virtual memory that can be allocated to a process is one page, and programs rarely need an integer number of pages.  So, in the last page that the process requested, most likely there will be unused memory, which, however, will be allocated, which means it is used inefficiently. <br><br>  On the other hand, the smaller the page size, the larger the size of the page tables.  Moreover, when shipping to the HDD and reading pages from the HDD, it will be faster to write several large pages than many small ones of the same total size. <br><br>  Special attention is given to the so-called big pages: huge pages and large pages <sup><a href="http://en.wikipedia.org/wiki/Page_%2528computer_memory%2529">[wikis]</a></sup> . <br><table><tbody><tr><td>  Platform </td><td>  Normal page size </td><td>  Page size as large as possible </td></tr><tr><td>  x86 </td><td>  4KB </td><td>  4MB </td></tr><tr><td>  x86_64 </td><td>  4KB </td><td>  1GB </td></tr><tr><td>  IA-64 </td><td>  4KB </td><td>  256MB </td></tr><tr><td>  PPC </td><td>  4KB </td><td>  16GB </td></tr><tr><td>  SPARC </td><td>  8KB </td><td>  2GB </td></tr><tr><td>  ARMv7 </td><td>  4KB </td><td>  16MB </td></tr></tbody></table><br>  Indeed, the use of such pages increases the memory overhead.  However, the performance gains of programs in some cases can go up to 10% <sup>[ <a href="http://www.vmware.com/files/pdf/large_pg_performance.pdf">link</a> ]</sup> , which is explained by the smaller size of the page directories and the more efficient operation of the TLB. <br><br>  In the future, we will focus on pages of normal size. <br><br><h2>  Page Table Entry Device </h2><br>  In an Embox project, the <i>mmu_pte_t</i> type is a pointer. <br>  Each <i>PTE</i> entry must refer to some physical page, and each physical page must be addressed to some <i>PTE</i> entry.  Thus, in <i>mmu_pte_t</i> , <i>MMU_PTE_SHIFT</i> bits remain unoccupied, which can be used to maintain the state of the page.  The specific address of the bit responsible for a particular flag, as well as the set of flags in general, depends on the architecture. <br><br>  Here are some of the flags: <br><ul><li>  MMU_PAGE_WRITABLE - Is it possible to change the page </li><li>  MMU_PAGE_SUPERVISOR - Super User / User Space </li><li>  MMU_PAGE_CACHEABLE - Should I Cach </li><li>  MMU_PAGE_PRESENT - Is this directory entry in use? </li></ul><br>  You can remove and set these flags using the following functions: <br>  <i>mmu_pte_set_writable (), mmu_pte_set_usermode (), mmu_pte_set_cacheable (), mmu_pte_set_executable ()</i> <i><br></i> <br>  For example: <i>mmu_pte_set_writable (pte_pointer, 0)</i> <br><br>  You can set several flags at once: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vmem_set_pte_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_pte_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pte, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vmem_page_flags_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span></span></code> </pre> <br>  Here, vmem_page_flags_t is a 32-bit value, and the corresponding flags are taken from the first <i>MMU_PTE_SHIFT</i> bits. <br><br><h2>  Translation of virtual address to physical </h2><br>  As mentioned above, when addressing memory, address translation is done in hardware, however, explicit access to physical addresses may be useful in some cases.  The principle of finding the right room is, of course, the same as in the MMU. <br><br>  In order to get a physical address from a virtual address, you need to go through the chain of tables <i>PGD, PMD</i> and <i>PTE</i> .  The <i>vmem_translate ()</i> function <i>performs</i> these steps. <br>  First it is checked whether the pointer to the <i>PMD</i> directory is in the <i>PGD</i> .  If so, the <i>PMD</i> address is calculated, and then the <i>PTE</i> is found in the same way.  After allocating the physical address of the page from the <i>PTE,</i> you need to add an offset, and after that the desired physical address will be obtained. <br><br><div class="spoiler">  <b class="spoiler_title">Source code of the vmem_translate function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mmu_paddr_t</span></span> vmem_translate(<span class="hljs-keyword"><span class="hljs-keyword">mmu_ctx_t</span></span> ctx, <span class="hljs-keyword"><span class="hljs-keyword">mmu_vaddr_t</span></span> virt_addr) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pgd_idx, pmd_idx, pte_idx; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pgd_t</span></span> *pgd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pmd_t</span></span> *pmd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pte_t</span></span> *pte; pgd = mmu_get_root(ctx); vmem_get_idx_from_vaddr(virt_addr, &amp;pgd_idx, &amp;pmd_idx, &amp;pte_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mmu_pgd_present(pgd + pgd_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } pmd = mmu_pgd_value(pgd + pgd_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mmu_pmd_present(pmd + pmd_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } pte = mmu_pmd_value(pmd + pmd_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mmu_pte_present(pte + pte_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mmu_pte_value(pte + pte_idx) + (virt_addr &amp; MMU_PAGE_MASK); }</code> </pre> </div></div><br>  Explanation of the function code. <br>  <i>mmu_paddr_t</i> is the physical address of the page, the purpose of <i>mmu_ctx_t</i> has already been discussed above in the ‚ÄúVirtual Address‚Äù section. <br><br>  Using the <i>vmem_get_idx_from_vaddr ()</i> function, the shifts are in the <i>PGD, PMD,</i> and <i>PTE</i> tables. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vmem_get_idx_from_vaddr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_vaddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> virt_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pgd_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pmd_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pte_idx)</span></span></span><span class="hljs-function"> </span></span>{ *pgd_idx = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>) virt_addr &amp; MMU_PGD_MASK) &gt;&gt; MMU_PGD_SHIFT; *pmd_idx = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>) virt_addr &amp; MMU_PMD_MASK) &gt;&gt; MMU_PMD_SHIFT; *pte_idx = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>) virt_addr &amp; MMU_PTE_MASK) &gt;&gt; MMU_PTE_SHIFT; }</code> </pre> <br><img src="//habrastorage.org/files/bc0/aa7/f63/bc0aa7f6368e427e9d05ee63622e1f7f.png"><br><h2>  Working with Page Table Entry </h2><br><br>  There are a number of functions for working with entries in the page table, as well as with the tables themselves: <br><br>  These functions return 1 if the corresponding structure has the <i>MMU_PAGE_PRESENT</i> bit <i>set.</i> <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_pgd_present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_pgd_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pgd)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_pmd_present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_pmd_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pmd)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mmu_pte_present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_pte_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pte)</span></span></span></span>;</code> </pre> <br><br><h2>  Page Fault </h2><br>  Page fault is an exception that occurs when accessing a page that is not loaded into physical memory ‚Äî either because it was preempted, or because it was not allocated. <br>  In general-purpose operating systems, when processing this exception, the required page is searched on the external storage medium (hard disk, for example). <br><br>  In our system, all pages to which the process has access are considered to be present in memory.  For example, the corresponding segments .text, .data, .bss;  a bunch;  and so on are displayed in tables when the process is initialized.  Data associated with threads (for example, a stack) is displayed in the process tables when creating threads. <br><br>  Pushing pages into external memory and reading them in the case of a page fault is not implemented.  On the one hand, this makes it impossible to use more physical memory than it actually is, but on the other hand, it is not an actual problem for embedded systems.  There are no restrictions that make the implementation of this mechanism impossible, and if desired, the reader can try himself in this matter :) <br><br><h1>  Memory allocation </h1><br>  For virtual pages and for physical pages that can be used when working with virtual memory, some place in RAM is statically reserved.  Then, when allocating new pages and directories, they will be taken from this particular place. <br>  The exception is a set of pointers to PGD for each process (MMU process contexts): this array is stored separately and used when creating and destroying the process. <br>  Highlighting pages <br>  So, you can select a physical page using <i>vmem_alloc_page</i> <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vmem_alloc_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> page_alloc(virt_page_allocator, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  The <i>page_alloc ()</i> function <i>searches</i> for a section of memory from the N unallocated pages and returns the physical address of the beginning of this section, marking it as occupied.  In the above code, virt_page_allocator refers to a section of memory reserved for allocating physical pages, and 1 indicates the number of pages needed. <br>  Selection tables <br>  The type of the table ( <i>PGD, PMD, PTE</i> ) does not matter during allocation.  Moreover, the selection of tables is also performed using the page_alloc () function, only with a different allocator ( <i>virt_table_allocator</i> ). <br><br><h1>  Memory areas </h1><br>  After adding pages to the appropriate tables, you need to be able to match the memory sections with the processes to which they relate.  In our system, the process is represented by a task structure containing all the necessary information for the OS to work with the process.  All physically accessible areas of the process address space are recorded in a special repository: task_mmap.  It is a list of descriptors of these areas (regions) that can be mapped to virtual memory, if appropriate support is included. <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emmap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *brk; <span class="hljs-keyword"><span class="hljs-keyword">mmu_ctx_t</span></span> ctx; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dlist_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">marea_list</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br>  <i>brk</i> is the largest of all the physical addresses of the repository, this value is necessary for a number of system calls that will not be considered in this article. <br>  <i>ctx</i> is the task context, the use of which was discussed in the ‚ÄúVirtual Address‚Äù section. <br>  <i>The struct dlist_head</i> is a pointer to the beginning of a doubly linked list whose organization is similar to the <a href="http://isis.poly.edu/kulesh/stuff/src/klist/"><i>Linux Linked List</i></a> . <br><br>  For each allocated area of ‚Äã‚Äãmemory marea structure is responsible. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">marea</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> end; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> flags; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> is_allocated; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dlist_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mmap_link</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br>  The fields of this structure have speaking names: addresses of the beginning and end of this section of memory, flags of the region of memory.  The mmap_link field is needed to maintain the doubly linked list mentioned above. <br><br><pre> <code class="hljs rust">void mmap_add_marea(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emmap</span></span></span></span> *mmap, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">marea</span></span></span></span> *marea) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">marea</span></span></span></span> *ma_err; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ma_err = mmap_find_marea(mmap, marea-&gt;start)) || (ma_err = mmap_find_marea(mmap, marea-&gt;end))) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } dlist_add_prev(&amp;marea-&gt;mmap_link, &amp;mmap-&gt;marea_list); }</code> </pre> <br><h1>  Mapping of virtual memory areas to physical ones (Mapping) </h1><br>  Earlier it was described how the allocation of physical pages, what data about virtual memory relates to the task, and now everything is ready to talk about the direct mapping of virtual memory sections to physical ones. <br><br>  Mapping virtual memory plots to physical memory implies making appropriate changes to the hierarchy of page directories. <br><br>  It is understood that some part of the physical memory is already allocated.  In order to highlight the corresponding virtual pages and link them to the physical, use the function vmem_map_region () <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vmem_map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_ctx_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_paddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_vaddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> virt_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vmem_page_flags_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = do_map_region(ctx, phy_addr, virt_addr, reg_size, flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { vmem_unmap_region(ctx, virt_addr, reg_size, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  As parameters, the task context, the start address of the physical memory location, and the start address of the virtual location are transmitted.  The <i>flags</i> variable contains flags that will be set for the corresponding entries in <i>PTE</i> . <br><br>  The main work is done by <i>do_map_region ()</i> .  It returns 0 on success and an error code otherwise.  If an error occurred during mapping, then some of the pages that managed to stand out need to be rolled back through the changes using the vmem_unmap_region () function, which will be discussed later. <br><br>  Consider the function <i>do_map_region () in</i> more detail. <br><br><div class="spoiler">  <b class="spoiler_title">The source code of the do_map_region () function</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_ctx_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_paddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> phy_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_vaddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> virt_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vmem_page_flags_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mmu_pgd_t</span></span> *pgd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pmd_t</span></span> *pmd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pte_t</span></span> *pte; <span class="hljs-keyword"><span class="hljs-keyword">mmu_paddr_t</span></span> p_end = phy_addr + reg_size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pgd_idx, pmd_idx, pte_idx; <span class="hljs-comment"><span class="hljs-comment">/* Considering that all boundaries are already aligned */</span></span> assert(!(virt_addr &amp; MMU_PAGE_MASK)); assert(!(phy_addr &amp; MMU_PAGE_MASK)); assert(!(reg_size &amp; MMU_PAGE_MASK)); pgd = mmu_get_root(ctx); vmem_get_idx_from_vaddr(virt_addr, &amp;pgd_idx, &amp;pmd_idx, &amp;pte_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pgd_idx &lt; MMU_PGD_ENTRIES; pgd_idx++) { GET_PMD(pmd, pgd + pgd_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pmd_idx &lt; MMU_PMD_ENTRIES; pmd_idx++) { GET_PTE(pte, pmd + pmd_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pte_idx &lt; MMU_PTE_ENTRIES; pte_idx++) { <span class="hljs-comment"><span class="hljs-comment">/* Considering that address has not mapped yet */</span></span> assert(!mmu_pte_present(pte + pte_idx)); mmu_pte_set(pte + pte_idx, phy_addr); vmem_set_pte_flags(pte + pte_idx, flags); phy_addr += MMU_PAGE_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phy_addr &gt;= p_end) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ENOERR; } } pte_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; } pmd_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Auxiliary Macros</b> <div class="spoiler_text"><pre> <code class="hljs tex">#define GET_PMD(pmd, pgd) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>if (!mmu_pgd_present(pgd)) { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>pmd = vmem_alloc_pmd_table(); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>if (pmd == NULL) { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>return -ENOMEM; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>mmu_pgd_set(pgd, pmd); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} else { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>pmd = mmu_pgd_value(pgd); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} #define GET_PTE(pte, pmd) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>if (!mmu_pmd_present(pmd)) { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>pte = vmem_alloc_pte_table(); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>if (pte == NULL) { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>return -ENOMEM; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>mmu_pmd_set(pmd, pte); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} else { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>pte = mmu_pmd_value(pmd); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>}</code> </pre></div></div><br>  Macros <i>GET_PTE</i> and <i>GET_PMD</i> are needed for better readability of the code.  They do the following: if in the memory table the pointer we need does not refer to the existing record, we need to select it, if not, then simply follow the pointer to the next record. <br><br>  At the very beginning, you need to check whether the size of the region, physical and virtual addresses are aligned to the page size.  After that, the <i>PGD</i> corresponding to the specified context is determined and shifts from the virtual address are extracted (this has already been discussed in more detail above). <br>  Then the virtual addresses are sequentially sorted, and the corresponding physical address is attached to them in the corresponding <i>PTE</i> records.  If there are no records in the tables, they will be automatically generated when calling the above-mentioned macros <i>GET_PTE</i> and <i>GET_PMD</i> . <br><br><h1>  Unmapping </h1><br>  After a section of virtual memory has been mapped to physical memory, sooner or later it will have to be released: either in case of an error or in the case of a process shutdown. <br>  Changes that must be made to the structure of the memory page hierarchy are made using the <i>vmem_unmap_region ()</i> function. <br><br><div class="spoiler">  <b class="spoiler_title">Source code of the vmem_unmap_region () function</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vmem_unmap_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_ctx_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mmu_vaddr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> virt_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> free_pages)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mmu_pgd_t</span></span> *pgd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pmd_t</span></span> *pmd; <span class="hljs-keyword"><span class="hljs-keyword">mmu_pte_t</span></span> *pte; <span class="hljs-keyword"><span class="hljs-keyword">mmu_paddr_t</span></span> v_end = virt_addr + reg_size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pgd_idx, pmd_idx, pte_idx; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *addr; <span class="hljs-comment"><span class="hljs-comment">/* Considering that all boundaries are already aligned */</span></span> assert(!(virt_addr &amp; MMU_PAGE_MASK)); assert(!(reg_size &amp; MMU_PAGE_MASK)); pgd = mmu_get_root(ctx); vmem_get_idx_from_vaddr(virt_addr, &amp;pgd_idx, &amp;pmd_idx, &amp;pte_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pgd_idx &lt; MMU_PGD_ENTRIES; pgd_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mmu_pgd_present(pgd + pgd_idx)) { virt_addr = binalign_bound(virt_addr, MMU_PGD_SIZE); pte_idx = pmd_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } pmd = mmu_pgd_value(pgd + pgd_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pmd_idx &lt; MMU_PMD_ENTRIES; pmd_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mmu_pmd_present(pmd + pmd_idx)) { virt_addr = binalign_bound(virt_addr, MMU_PMD_SIZE); pte_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } pte = mmu_pmd_value(pmd + pmd_idx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; pte_idx &lt; MMU_PTE_ENTRIES; pte_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (virt_addr &gt;= v_end) { <span class="hljs-comment"><span class="hljs-comment">// Try to free pte, pmd, pgd if (try_free_pte(pte, pmd + pmd_idx) &amp;&amp; try_free_pmd(pmd, pgd + pgd_idx)) { try_free_pgd(pgd, ctx); } return; } if (mmu_pte_present(pte + pte_idx)) { if (free_pages &amp;&amp; mmu_pte_present(pte + pte_idx)) { addr = (void *) mmu_pte_value(pte + pte_idx); vmem_free_page(addr); } mmu_pte_unset(pte + pte_idx); } virt_addr += VMEM_PAGE_SIZE; } try_free_pte(pte, pmd + pmd_idx); pte_idx = 0; } try_free_pmd(pmd, pgd + pgd_idx); pmd_idx = 0; } try_free_pgd(pgd, ctx); }</span></span></code> </pre> </div></div><br>  All parameters of the function, except the last, should be already familiar.  <i>free_pages</i> is responsible for whether page records should be deleted from the tables. <br><br>  <i>try_free_pte, try_free_pmd, try_free_pgd</i> are auxiliary functions.  When deleting the next page, it may become clear that the directory containing it could become empty, which means that it should be deleted from memory. <br><br><div class="spoiler">  <b class="spoiler_title">Source code of try_free_pte, try_free_pmd, try_free_pgd functions</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> try_free_pte(mmu_pte_t *pte, mmu_pmd_t *pmd) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> pte_idx = <span class="hljs-number"><span class="hljs-number">0</span></span> ; pte_idx &lt; MMU_PTE_ENTRIES; pte_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmu_pte_present(pte + pte_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MMU_PTE_SHIFT != MMU_PMD_SHIFT mmu_pmd_unset(pmd); vmem_free_pte_table(pte); #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> try_free_pmd(mmu_pmd_t *pmd, mmu_pgd_t *pgd) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> pmd_idx = <span class="hljs-number"><span class="hljs-number">0</span></span> ; pmd_idx &lt; MMU_PMD_ENTRIES; pmd_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmu_pmd_present(pmd + pmd_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MMU_PMD_SHIFT != MMU_PGD_SHIFT mmu_pgd_unset(pgd); vmem_free_pmd_table(pmd); #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> try_free_pgd(mmu_pgd_t *pgd, mmu_ctx_t ctx) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> pgd_idx = <span class="hljs-number"><span class="hljs-number">0</span></span> ; pgd_idx &lt; MMU_PGD_ENTRIES; pgd_idx++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmu_pgd_present(pgd + pgd_idx)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } // Something missing vmem_free_pgd_table(pgd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </div></div><br>  View Macros <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MMU_PTE_SHIFT != MMU_PMD_SHIFT ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  needed just for the case of a two-level hierarchy of memory. <br><br><h1>  Conclusion </h1><br>  Of course, this article is not enough to organize work with the MMU from scratch, but I hope it will at least help OSDev to those who find it too complicated. <br><br>  PS All with the beginning of the <a href="https://vk.com/mmweek">week Mat-Mech</a> :) </div><p>Source: <a href="https://habr.com/ru/post/256191/">https://habr.com/ru/post/256191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256179/index.html">Online broadcast Microsoft Developer Tour in Novosibirsk April 22</a></li>
<li><a href="../256181/index.html">Google, eBay and AliExpress will store personal data of Russians on servers in the Russian Federation</a></li>
<li><a href="../256183/index.html">Its cloud image storage in 30 minutes</a></li>
<li><a href="../256187/index.html">RAD Studio XE8 World Tour in Kazan, St. Petersburg and Tbilisi</a></li>
<li><a href="../256189/index.html">Characteristics of microservices, applications and systems</a></li>
<li><a href="../256193/index.html">Localization of WPF applications on the fly</a></li>
<li><a href="../256197/index.html">Step-by-step instructions on how to implement uploading files to the server without reloading the page in PHP + Javascript</a></li>
<li><a href="../256199/index.html">Analysis of ARPD on the example of several small mobile applications and games</a></li>
<li><a href="../256201/index.html">CLRium: continue the tour of the cities. Ekaterinburg and Peter</a></li>
<li><a href="../256203/index.html">How and why do I write articles on Habrahabr. Personal experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>