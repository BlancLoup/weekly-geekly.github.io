<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We optimize the web with Vitaly Friedman, - compression, images, fonts, HTTP / 2 features and Resource Hints</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We offer you a selection of all kinds of life hacking and tricks to optimize the amount of downloadable code and files, as well as the overall acceler...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We optimize the web with Vitaly Friedman, - compression, images, fonts, HTTP / 2 features and Resource Hints</h1><div class="post__text post__text-html js-mediator-article">  We offer you a selection of all kinds of life hacking and tricks to optimize the amount of downloadable code and files, as well as the overall acceleration of loading web pages. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rgHLV2fe-2I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The article is based on the transcript of a speech by Vitaly Friedman from Smashing Magazine at the December conference of Holy JS 2017 Moscow. <br><a name="habracut"></a><br>  So that we would not be bored with you, I decided to submit this story in the format of a small game, calling it Responsive Adventures. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3d/635/f35/c3d635f3533095f0d4d89e88ec32e6f5.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The game will have five levels, and we start with a simple level - compression. <br><br><h2>  Level 1 - Compression </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/3a4/8a5/c2d/3a48a5c2dae5e30f785c035431ff4501.png"><br><br>  Compression is compression, and for example, images, text, fonts, and so on can be compressed into a frontend.  If there is a need to optimize the page as much as possible in terms of text, then in practice they usually use the library to compress gzip data.  The most common gzip implementation is zlib, which uses a combination of LZ77 and Huffman encoding algorithms. <br><br>  Usually we are interested in how much the library should compress, because the better it does, the more time this process takes.  Usually we choose either fast compression, or good, because at the same time fast and good compression is impossible to achieve.  But as developers, we take care of two aspects: the size of files and the speed of compression / decompression - for static and dynamic web content. <br><br>  There are data compression algorithms Brotli and Zopfli.  Zopfli can be considered as more efficient, but at the same time slower version of gzip.  Brotli is a new lossless compression and decompression format. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/803/475/d3a/803475d3a8534b0eaba3182dbcdb4494.png"><br><br>  In the future we will be able to use Brotli.  But now not all browsers support it, and we need full support. <br><br><h2>  Brotli and Zopfli </h2><br><ol><li>  Brotli is much slower in data compression compared to gzip, but provides much better compression. <br></li><li>  Brotli is an open source lossless compression format. <br></li><li>  Brotli decompression is fast - comparable to zlib. <br></li><li>  Brotli gives an advantage when working with large files with slow connections. <br></li><li>  Brotli squeezes more efficiently by 14-39%. <br></li><li>  Ideal for HTML, CSS, JavaScript, SVG and all text. <br></li><li>  Brotli support is limited to HTTPS connections. <br></li><li>  Zopfli is often used for on-the-fly compression, but it is a good alternative for compressing static content once. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/a6b/5f4/cd7/a6b5f4cd7b5d3df2e492311f4fc2a546.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/c59/0ed/3a3c590edd9048639546d4067b565bff.png"><br><br><h2>  Brotli / Zopfli compression strategy </h2><br>  The strategy is as follows: <br><br><ol><li>  Precompression of static resources using Brotli + Gzip. <br></li><li>  Compress with Brotli HTML on the fly with a compression level of 1-4. <br></li><li>  Check Brotli support on CDN (KeyCDN, CDN77, Fastly). <br></li><li>  Use Zopfli if it is not possible to install / maintain Brotli on the server. <br></li></ol><br><h2>  Level 2 - Images </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f48/6d9/63b/f486d963bb88a13e7b42e12adebb7581.png"><br><br>  But what will we do with the images? <br><br>  Let's imagine you have a good landing page with fonts and images.  It is necessary that the page loads very quickly.  And we are talking about the extreme level of image optimization.  This is a problem, and it is not contrived.  We prefer not to talk about it, because, unlike JS, images do not block rendering of the page.  In fact, this is a big problem, because the size of images increases over time.  Now there are already 4K screens running, soon there will be 8K. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25b/78a/3b1/25b78a3b13b8bc18e596be5e77d3591a.png"><br><br>  In general, 90% of users see 5.4 MB of images on a page - that‚Äôs a lot.  This is a problem that needs to be resolved. <br><br>  We specify the problem.  What if you have a big picture with a transparent shadow, as in the example below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/328/988/a7f/328988a7f86051621ac5d280c63890af.png"><br><br>  How to squeeze it?  After all, png is hard enough, and after compression the shadow will not look very good.  What format to choose?  JPEG?  Shadow will also not look good enough.  What can be done? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/515/2e1/0645152e1264528173a6e2df52dc29a4.png"><br><br>  One of the best options is to divide the images into two components.  The basis of the image is placed in jpeg, and the shadow in png.  Next, connect the two pictures in svg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/494/d56/68f/494d5668fa6332d39df7e323f6a34666.png"><br><br>  Why is it good?  Because the image, which weighed 1.5 MB, now takes 270 KB.  This is a big difference. <br><br>  But there are a couple more tricks.  Here is one of them. <br><br>  Take two images that are visually displayed on a website with the same proportions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/342/d78/325/342d7832539456d2a949a50a98f41b50.png"><br><br>  The first is with very poor quality, it has a real and visual size of 600 x 400 px, and below it is the same, but visually reduced to 300 x 200 px. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/e5c/1da/a25e5c1da8453656df775f76a24dd216.png"><br><br>  Let's compare this image with an image that has a real size of 300 x 200 px, but saved at 80% quality. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/e08/c2b/0c6e08c2b908cbe8b5e3ce8acdb8561d.png"><br><br>  Most users are not able to distinguish these images, but the picture on the left weighs 21 KB, and on the right, 7 KB. <br><br>  There are two problems: <br><br><ul><li>  the one who decides to save the picture will keep it in bad quality <br></li><li>  the browser will have to zoom in or out <br></li></ul><br>  An interesting test that used this technique was conducted by the Swedish online journal Aftonbladet.  The initial image quality setting was set at 30%. <br><img src="https://habrastorage.org/getpro/habr/post_images/016/480/e35/016480e35cfb065342b8416e8b70b07e.png"><br>  As a result, their main page with 40 images using this technique took 450 KB.  Impressive! <br><br>  Here is another good technique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0f/30b/28f/b0f30b28f8d9f2bf41d3063ff01b6d0c.png"><br><br>  We have a picture, and we need to reduce its size.  Due to what it will be better to shrink?  Contrast!  What if you remove or reduce it significantly, and then return it with the help of CSS filters?  But again, the one who wants to download this picture will face poor quality. <br><br>  This technique can achieve great results.  Here are some examples: <br><img src="https://habrastorage.org/getpro/habr/post_images/a61/adc/e8d/a61adce8dbe4386e7beecaa2c2119ce7.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/f55/ddf/07b/f55ddf07bd3766e7f33a7da1de8e0d1e.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/786/5c5/6e1/7865c56e159078b85e3d8e1a0a57c377.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/dad/064/932/dad064932849f278083956226d941002.png"><br>  Everything would be fine, but what about the additional rendering delays?  After all, the browser has to apply filters to the image.  But here everything is quite positive: 27 ms versus 23 ms without the use of filters - the difference is insignificant. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/827/672/1cd/8276721cd1d5fe63d10a1ecff2332eb5.png"><br><br>  Filters are supported everywhere except IE. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/e78/7ac/ba7e787ac3e7bf30d3efce7f22c7b307.png"><br><br>  What other tricks are there?  Compare two photos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/3d8/8c5/d963d88c5ac2023938380fe839f76a0e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7b/f9b/c84/b7bf9bc842846d190a8b8de279632a3d.png"><br><br>  The difference is the blurring of irrelevant details of the photo, which allows you to reduce the size to 147 KB.  But this is not enough!  Let's go into JPEG encoding.  Suppose you have a consistent and progressive jpeg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5d/957/dad/f5d957dadfb2c3a9ae097d16a4acf87c.png"><br><br>  Sequential JPEG is loaded on the page line by line, progressive - at first in poor quality all at once, and then the quality gradually improves. <br><br>  If you look at how encoders work, you can see several levels of scanning. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42a/e57/be3/42ae57be30bce6ad7d2cae10e9d101fa.png"><br><br>  Many different levels of scanning are in this file.  Our goal, as a developer, is to show immediately detailed information about this picture.  Then you can make sure that Ships Fast and Shows Soon are with some kind of coefficients that can fit the picture better, and then at the first level we will see the structure, and not just something blurry.  And on the second - almost everything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bf/207/5ae/8bf2075ae90eb431aace97fb926c98de.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/674/9af/bd8/6749afbd854295fdc6b138e19de0975f.png"><br><br>  There are libraries and utilities that allow you to do these tricks: Adept, mozjpeg or Guetzli. <br><br><h2>  Level 3 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/1f4/042/2f7/1f40422f757ef7fdaaaec40655c97dc5.png"><br><br>  I remember seven or ten years ago - I wanted fonts, added font-face and was done.  And now, no, you need to think what I want to do and how to download.  So, what is the best method to choose for downloading fonts? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80c/aea/a32/80caeaa32dfe5afba09a5235a4fb1635.png"><br><br>  We can use font-face syntax to avoid common pitfalls along the way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/7ba/0fe/6797ba0fe98db23543b2160e3731fc6c.png"><br><br>  If we want to support only more or less normal browsers, then we can write even shorter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3de/5d6/5b8/3de5d65b8941a769d02ebc59fef89bd1.png"><br><br>  What happens when we have this font-face in css?  Browsers see if there is an indication of the font in the body or somewhere else, and if so, then the browser starts loading it.  And we have to wait. <br><br>  If the fonts are not yet cached, they will be queried, loaded, and applied, moving the rendering back. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83c/f39/971/83cf39971a8a08909c41cf14842c25fc.png"><br><br>  But different browsers act differently.  There are FOUT and FOIT mapping approaches. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7dc/916/ca8/7dc916ca8314b035d8099359456f58fa.png"><br><br>  FOIT (Flash of Invisible Text) - nothing is displayed until the fonts are loaded. <br><br>  FOUT (Flash Unstyled Text) - the content is displayed immediately with default fonts, and then the necessary fonts are loaded. <br><br>  Usually browsers wait for font downloads for three seconds, and if they do not have time to load, default fonts are substituted.  There are browsers that do not wait.  But the most annoying thing is that there are browsers that wait until it stops.  Will not work!  There are many different options for how to get around this.  One of them is CSS Font Loading API.  Create a new font-face in JS.  If the fonts are loaded, then we hang them in the appropriate places.  If not loaded, hang the standard. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79c/ac2/363/79cac2363cecac80111b57165308a2e6.png"><br><br>  We can also use new properties in CSS, for example, font-rendering, which allows us to emulate either FOIT or FOUT, but in fact we don‚Äôt even need them, because there is a Font Rendering Optional. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f9f/da8/ee0f9fda8abfb14397dcb67b2e34c7ad.png"><br><br>  There is another way - critical FOFT with a Data URI.  Instead of loading via the JavaScript API, a web font is embedded directly in the markup as an embedded Data URI. <br><br>  Two-step rendering: first roman font, and then the rest: <br><br><ul><li>  Download full fonts with all weights and styles <br></li><li>  Minimum subset of fonts (AZ, 0-9, punctuation) <br></li><li>  Use sessionStorage for back visits <br></li><li>  Download the Roman Subscript first. <br></li></ul><br>  This method will block the initial display, but since we embed only a small subset of the plain font, this is a small price to eliminate FOUT.  However, this method has the fastest strategy for downloading fonts to date. <br><br>  I thought that you could do even better.  Instead of using sessionStorage, we embed a web font in the markup and use Service Workers. <br><br>  For example, we have some kind of font, but we don‚Äôt need it all.  And we are not doing subsetting, but choosing what is needed for this page.  For example, we take italic, reduce it, first load it, display it on the page, and it will look like normal, bold be like normal, everything will be like normal.  Then everything is loaded as needed.  Next, do subsetting and send it to the Service Workers. <br><br>  Then, when the user comes to the page for the first time, we check the availability of the font, if not, then we immediately display the text, asynchronously load this font and add it to the Service Workers, for short.  When the user enters the second time, the font for the idea should already be in Service Workers.  Next, we check if it is there and if so, then we immediately take it from there, and if not, then all these actions occur again. <br><br>  There is a caching problem here.  What is the probability that someone comes to your site and has all the files that should be in the cache are present in it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a0/ba6/7be/5a0ba67beae0179425ab571317566452.png"><br><br>  The image above demonstrates the results of a 2007 survey that says that 40-60% of users have an empty cache, and 20% of all page views occur with an empty cache.  Why is that?  Because browsers do not know how to cache?  No, we just visit a large number of sites and if everything is cached, the drive of a PC or smartphone would fill up very quickly. <br><br>  Browsers delete from the cache what they consider no longer necessary. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2d/50a/7c1/b2d50a7c1847d822a6a2a205959e1dbc.png"><br><br>  Let's look at the example of Chrome, what happens in it when we try to open any page on the web.  If you look at the fonts line, you can see that the fonts are in memory cache or HTTP cache at best in 70% of cases.  In fact, these are unpleasant numbers.  If the fonts are downloaded again each time, each time the user comes to the site and watches the change of font style.  From the point of view of the UX is not very good. <br><br>  Care must be taken to ensure that the fonts actually remain in the cache.  We used to rely on local storage, but now it is more reasonable to rely on Service Workers.  Because if I put something in Service Workers, then it will be there. <br><br>  What else can you do?  You can use unicode-range.  Many people think that there is a dynamic subsetting, that is, we have a font, it is dynamically parsed, and only the specified part in the unicode-range is loaded.  In fact, this is not the case, and the entire font is loaded. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf3/001/0ce/cf30010cecf7ef2a6604ae077398a00f.png"><br><br>  Indeed, this is useful when we have unicode-range, for example, for Cyrillic and for English text.  Instead of downloading a font that has English and Russian texts, we can break it into several parts and load Russian, if we have Russian text on the page, and do the same with English. <br><br>  What else can you do?  There is a cool thing that you need to use always and everywhere - preload. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7c/b69/76e/b7cb6976e44174ad4f73f4e9c41dfee4.png"><br><br>  Preload allows you to load resources at the beginning of the page load, which in turn makes it less likely to block rendering of the page.  This approach improves performance. <br><br>  We can also use font-display: optional.  This is a new property in css.  How does it work? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/134/620/475/1346204758e3f9f5e34c7fdc4e89c787.png"><br><br>  Font-display has several meanings.  Let's start with the block.  This property sets the font lock for three seconds, during which the font loads, then the font is replaced and then directly displayed. <br><br>  The swap property works much the same, but with some exceptions.  The browser immediately renders the text with a spare font, and when the specified is loaded, it will be replaced. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c1/e3c/a00/5c1e3ca00274ffd9e186bcf5399dad7b.png"><br><br>  Fallback sets a small blocking period of 100 ms, the replacement period will be 3 seconds, after which the font will be replaced.  If during this time the font is not loaded, the browser will draw the text with a spare font. <br><br>  And finally we come to optional.  The blocking period is 100 ms, if during this time the font has not loaded, the text is displayed immediately.  If you have a slow connection, the browser may stop loading the font.  When the font is loaded, you will still see the default font.  To see the prescribed font, you must reload the page. <br><br><h2>  Level 4 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/a7d/535/861/a7d535861a58591160adb09b3c482c16.png"><br><br>  There are many techniques that we used before the advent of http / 2, for example, concatenation, sprites, etc.  But with the advent of http / 2, the need to use them has disappeared, because unlike http / 1.1, the new version loads almost everything at once, which is great, because you can use many additional features. <br><br>  In theory, the transition to http / 2 promises us 64% (23% on mobile) faster loading pages.  But in practice, everything works more slowly. <br><br>  If a large part of your target audience constantly comes to the resource, being in a bus, car, etc., then it is quite possible that http / 1.1 will be in a better position. <br><br>  Look at the test results below.  It shows that in some situations http / 1.1 is faster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f6/bc5/631/1f6bc56319acdf40c4e7fc0599f94771.png"><br><br>  There are wonderful features for http / 2, for example, HPACK, which should be used always and everywhere, and also server push.  But there is a small problem.  It occurs depending on the browser and server.  Suppose we load the page, we have no server push. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d35/fbc/fa9/d35fbcfa9e8d89d02adc0ae8e0906cc5.png"><br><br>  If the page is reloaded, then everything is in the cache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aba/1b4/684/aba1b4684f1b1be54f0949172dfb06a5.png"><br><br>  But if we make server push, then our css will reach the user much faster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/047/cba/f52/047cbaf5272d5a8f82b68a10dc8a6a10.png"><br><br>  But it also means that even if the css is in the cache, they will still be sent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/517/914/c5e/517914c5ed6cd06f2f2bc40cafeac451.png"><br><br>  That is, if you push a lot of files from the server, they will be loaded many times. <br><br>  Go ahead.  There are some recommended time frames for loading pages.  For example, for an average device on android it is five seconds.  This is not so much, considering that, for example, we have 3G. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/890/d77/8f5890d77ec770024744f1aec70890b1.png"><br><br>  If you look at the recommended size limit for uploads that is required to start rendering, which Google mentions, it is 170 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f15/bda/340/f15bda3401617654e0ba961ef8dd0500.png"><br><br>  Therefore, when it comes to frameworks, we need to think about parsing, compiling, network quality, runtime costs, etc. <br><br>  There are various ways to upload files, for example, the classic way, which is a bit outdated - scout.  We get the file scout.js, it is in html, we load it.  Its task is to make the rest of the environment as cacheable as possible and at the same time timely report on changes in it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b54/19c/e57/b5419ce57479334395425d0e6cdc6c51.png"><br><br>  This means that this file needs a little time to store in the cache, and if something changes in the environment, then scout immediately initiates an update.  This is an effective way, because every time we do not need to load and replace html. <br><br>  What to do with http / 2?  After all, we know that we can send as many files as we like and there is no need to combine them into packets.  Let's load 140 modules then, why not?  Actually, this is a very bad idea.  First, if we have a lot of files, and we do not use a library, for example gzip for compression, then the files will be larger.  Secondly, browsers are not yet optimized for such workflows.  As a result, we began to experiment and look for the right amount, and it turned out that it is optimal to send about 10 packets. <br><br>  Packages are best packaged, based on the frequency of file updates: often updated in some packages, and rarely updated in others, in order to avoid unnecessary downloads.  For example, libraries to pack with utilities, etc.  Nothing special.  And what to do with css, how to download it?  Server push is not suitable here. <br><br>  In the beginning, we all downloaded as minimized files, then we thought that a part should be loaded into critical css, because we only have 14 KB, and they need to be loaded as quickly as possible.  Began to do loadCSS, write logic, then add display: none. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12b/afe/8ca/12bafe8caea7d5f3a1f480c1bdd242f0.png"><br><br>  But it all looked somehow bad.  In http / 2, they thought that it was necessary to split, minify and load all files.  It turned out that the best option was the one in the image below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/216/389/be1/216389be1b3f7372f561b03eed6a0ca2.png"><br><br>  Unusually!  This option works well in Chrome, poorly in IE, in Firefox the work slowed down a bit as they changed the rendering.  Thus, we have improved the speed of work for 120 ms. <br><br>  If you look at work with progressive css and without.  Then with progressive css everything loads faster, but in parts, but without using it more slowly, because  The css is located in the header and blocks the page as js. <br><br><h2>  Level 5 </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/38f/f72/b4c/38ff72b4c991b8993f5f01eb98de57cb.png"><br><br>  And the last level, which I can not tell you - Resource Hints.  This is a great feature that allows you to do many useful things.  Lets go through some of them. <br><br><h3>  Prefetch </h3><br>  Prefetch - indicates to the browser that we will need one or another file soon, and the browser loads it with a low priority. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"prefetch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(url)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/1b8/f2f/f8e/1b8f2ff8eefeb6098b68ae7909dc1d32.png"><br><br><h3>  Prerender </h3><br>  Prerender - this function no longer exists, but it helped make the page prerender earlier.  Perhaps she will have an alternative ... <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"prerender"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(url)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/fd7/9d7/62f/fd79d762f92ea282985342d81ca462dc.png"><br><br><h3>  Dns-prefetch </h3><br>  Dns-prefetch also speeds up the page loading process.  Using dns-prefetch assumes that the browser pre-loads the server address of the specified domain name. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dns-prefetch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(url)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/c9b/fd8/ed3/c9bfd8ed3bbd6f0f0d0a95c0c0e90a41.png"><br><br><h3>  Preconnect </h3><br>  Preconnect allows you to do a preliminary handshake with specified servers. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"preconnect"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(url)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/1b5/ace/c8f/1b5acec8f1e54087fe3196f2c1c63bbf.png"><br><br><h3>  Preload </h3><br>  Preload - tells the browser which resources need to be preloaded with high priority.  Preload can be used for scripts and fonts. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"preload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(url)"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"(type)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/62c/c96/1e6/62cc961e6b8295df4c2cefe00d33d3fa.png"><br><br>  I remember in 2009 I read the article " <a href="http://googlecode.blogspot.ru/2009/09/gmail-for-mobile-html5-series-reducing.html">Gmail for Mobile HTML5 Series: Reducing Startup Latency</a> ", and she changed my views on the classic rules.  See for yourself!  We have a JS code, but we don‚Äôt need it all right now.  So why don't we comment out most of the JS code, and then, when necessary, uncomment and execute it in eval? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/591/6f5/a4d/5916f5a4de844132d8f96b6529650039.png"><br><br>  And the reason why they did this is because the average smartphone parsing time is 8-9 times longer than the last iPhone. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/2ad/8a2/6762ad8a2721e73247c362836e1adf59.png"><br><br>  Let's turn to statistics.  To parse a 1 MB code on an average phone, you need 4 seconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/27b/a81/d2c27ba811a5875ad9114e64bcf94047.png"><br><br>  This is a lot!  But we don't need 1 MB right away.  If you again refer to the statistics, it turns out that the sites use only 40% of the JS-code from what they downloaded. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/6b7/5d4/e306b75d4bbb6e5a605fdd516c843940.png"><br><br>  And we can use preload instead of eval for the same situations. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> preload = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"link"</span></span>); link.href= <span class="hljs-string"><span class="hljs-string">"myscript.js"</span></span> ; link.rel= <span class="hljs-string"><span class="hljs-string">"preload"</span></span>; link.as= <span class="hljs-string"><span class="hljs-string">"script"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(link);</code> </pre><br>  That is, we store the file in the cache, and then, when necessary, we add it to the page. <br><br><hr><br>  So, this is only half of what Vitaly Friedman planned to share.  The remaining pieces and lifehacks will be in deciphering his second performance at HolyJS 2017 Moscow, which we will also prepare and post in our blog. <br><br>  And if you like the wrong side of JS just as we do, you will surely be interested in these reports at our May conference <a href="https://holyjs-piter.ru/">HolyJS 2018 Piter</a> , the key ones of which we again <a href="https://holyjs-piter.ru/">wrote</a> Vitaly Friedman's story: <br><br><ul><li>  <a href="https://holyjs-piter.ru/talks/2r1yg7w0no4ekomossmq8k/">New Advenures In Front-End, Season 2</a> (Vitaly Friedman, Smashing Magazine) </li><li>  <a href="https://holyjs-piter.ru/talks/11q1jiaid6uoeuieqqa4mk/">RxJS: Performance and memory leaks in a large application</a> (Evgeny Pozdnyakov Exadel) </li><li>  <a href="https://holyjs-piter.ru/talks/2tmryuscgwykqms0ouqees/">Meinim crypt in the browser: WebWorkers, GPU, WebAssembly and other good things</a> (Denis Radin, Evolution Gaming) </li><li>  <a href="https://holyjs-piter.ru/talks/4vxicrybq84iyqiwkigyko/">JavaScript debugging using Chrome DevTools</a> (Alexey Kozyatinsky, Google) </li><li>  <a href="https://holyjs-piter.ru/talks/6jl89tfvg8mseuyawmya0q/">What to expect from JavaScript in 2018?</a>  (Mikhail Poluboyarinov, Health Samurai) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/354890/">https://habr.com/ru/post/354890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354880/index.html">Is it possible to consciously refuse functional programming?</a></li>
<li><a href="../354882/index.html">LAppS application server for microservice architecture</a></li>
<li><a href="../354884/index.html">The city falls asleep, hackers wake up</a></li>
<li><a href="../354886/index.html">ReactiveValidation: data validation in WPF</a></li>
<li><a href="../354888/index.html">Practice implementing Cisco ISE. Engineer's look</a></li>
<li><a href="../354892/index.html">Commenting code: good, bad, evil</a></li>
<li><a href="../354894/index.html">MIT course "Computer Systems Security". Lecture 1: "Introduction: threat models", part 2</a></li>
<li><a href="../354896/index.html">MIT course "Computer Systems Security". Lecture 1: "Introduction: threat models", part 3</a></li>
<li><a href="../354898/index.html">Fractal manifold method in Data Science problems</a></li>
<li><a href="../354902/index.html">As I wrote a graphic bot and what it turned into</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>