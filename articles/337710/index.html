<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>History 13 places on Highload Cup 2017</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On August 11, Mail.Ru announced the next HighloadCup contest for  system programmers  backend-developers. 


 In short, the task was as follows: Docke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>History 13 places on Highload Cup 2017</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/ccc/a10/7e3/ccca107e387c4c52b96afcea8f2ab1fa.jpg" alt="Image"></p><br><p>  On August 11, Mail.Ru <a href="https://habrahabr.ru/company/mailru/blog/335384/">announced</a> the next <a href="https://highloadcup.ru/">HighloadCup</a> contest for <del>  system programmers </del>  backend-developers. </p><br><p>  In short, the task was as follows: Docker, 4 cores, 4 GB of memory, 10 GB HDD, <a href="https://highloadcup.ru/media/condition/howto.html">api set</a> , and you need to answer requests in the least amount of time.  Language and technology stack unlimited.  The <a href="https://github.com/yandex/yandex-tank">Yandex-tank</a> with the phantom engine served as a testing system. </p><br><p>  How in such conditions to get to the 13th place in the final, and this article will be. </p><a name="habracut"></a><br><h1>  Formulation of the problem </h1><br><p>  Detailed description of the task can be found in the <a href="https://habrahabr.ru/post/337076/">publication of</a> one of the participants on Habr√©, or on the official page of the <a href="https://highloadcup.ru/media/condition/howto.html">competition</a> .  How testing was done is written <a href="https://highloadcup.ru/about/">here</a> . </p><br><p>  Api consisted of 3 get requests for just returning records from the database, 2 get requests for aggregating data, 3 post requests for data modification, and 3 post requests for adding data. </p><br><p>  The following conditions were immediately negotiated, which made life much easier: </p><br><ul><li>  no network loss (data go through loopback) </li><li>  data is guaranteed to be stored in memory </li><li>  no competing post requests (i.e. there will not be a simultaneous attempt to change the same entry) </li><li>  Post and get requests never go at the same time (either only get requests or only post requests) </li><li>  data is never deleted, but only modified or added </li></ul><br><p>  The requests were divided into 3 parts: first, get-requests for the original data, then a series of post-requests for adding / changing data, and the last most powerful series of get-requests for the modified data.  The second phase was very important, because  incorrectly adding or changing data, you could get a lot of errors in the third phase, and as a result - a large fine.  At this stage, the last stage contained a linear increase in the number of requests from 100 to 2000rps. </p><br><p>  Another condition was that one request is one connection, i.e.  no keep-alive, but at some point they refused it, and all get-requests went with keep-alive, post-requests were each for a new connection. </p><br><p>  My dream has always been and is Linux, C ++ and system programming (although the reality is terrible), and I decided not to deny myself anything and dive into this pleasure with my head. </p><br><h1>  Go </h1><br><p>  Since  I knew about highload a little less than nothing, and I was hoping to the last that I didn‚Äôt have to write my own web server, the first step to solving the problem was to find a suitable web server.  My eyes caught on <a href="https://github.com/facebook/proxygen">proxygen</a> .  In general, the server was supposed to be good - who else knows as much about hoolad as facebook? </p><br><p>  The source code contains <a href="httpserver/samples">several examples of</a> how to use this server. </p><br><pre><code class="hljs cpp">HTTPServerOptions options; options.threads = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(FLAGS_threads); options.idleTimeout = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">60000</span></span>); options.shutdownOn = {SIGINT, SIGTERM}; options.enableContentCompression = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; options.handlerFactories = RequestHandlerChain() .addThen&lt;EchoHandlerFactory&gt;() .build(); <span class="hljs-function"><span class="hljs-function">HTTPServer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(options))</span></span></span></span>; server.bind(IPs); <span class="hljs-comment"><span class="hljs-comment">// Start HTTPServer mainloop in a separate thread std::thread t([&amp;] () { server.start(); });</span></span></code> </pre> <br><p>  And for each accepted connection, the factory method is called. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoHandlerFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public RequestHandlerFactory { public: // ... RequestHandler* onRequest</span></span></span></span>(RequestHandler*, HTTPMessage*) noexcept <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new EchoHandler(stats_.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); } <span class="hljs-comment"><span class="hljs-comment">// ... private: folly::ThreadLocalPtr&lt;EchoStats&gt; stats_; };</span></span></code> </pre> <br><p>  From <code>new EchoHandler()</code> for every request I suddenly ran down a chill on my back, but I did not attach any importance to this. </p><br><p>  <code>EchoHandler</code> itself must implement the <a href="https://github.com/facebook/proxygen/blob/master/proxygen/"><code>proxygen::RequestHandler</code></a> : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> proxygen::RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;proxygen::HTTPMessage&gt; headers)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;folly::IOBuf&gt; body)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEOM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpgrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proxygen::UpgradeProtocol proto)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proxygen::ProxygenError err)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> <br><p>  Everything looks good and beautiful, just manage to process incoming data. <br>  I implemented the routing with <code>std::regex</code> , since the api set is simple and small.  Responses are generated on the fly using <code>std::stringstream</code> .  At the moment I did not bother with performance, the goal was to get a working prototype. </p><br><p>  Since the data is stored in memory, it means that they need to be stored in memory! <br>  The data structures looked like this: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Location</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> place; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> country; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> city; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> data; data &lt;&lt; <span class="hljs-string"><span class="hljs-string">"{"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"id\":"</span></span> &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"place\":\""</span></span> &lt;&lt; place &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\","</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"country\":\""</span></span> &lt;&lt; country &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\","</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"city\":\""</span></span> &lt;&lt; city &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\","</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"distance\":"</span></span> &lt;&lt; distance &lt;&lt; <span class="hljs-string"><span class="hljs-string">"}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data.str()); } };</code> </pre> <br><p>  The initial version of the "database" was: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryStorage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, T*&gt; Map; InMemoryStorage(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, T&amp;&amp; data, T** pointer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_list&lt;T&gt;&gt; buckets_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Map&gt; bucket_indexes_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; bucket_mutexes_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryStorage</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:InMemoryStorage() : buckets_(BUCKETS_COUNT), bucket_indexes_(BUCKETS_COUNT), bucket_mutexes_(BUCKETS_COUNT) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryStorage</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:Add(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id, T&amp;&amp; data, T** pointer) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucket_id = id % BUCKETS_COUNT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); Map&amp; bucket_index = bucket_indexes_[bucket_id]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = bucket_index.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != bucket_index.end()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } buckets_[bucket_id].emplace_front(data); bucket_index.emplace(id, &amp;buckets_[bucket_id].front()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointer) *pointer = &amp;buckets_[bucket_id].front(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryStorage</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:Get(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucket_id = id % BUCKETS_COUNT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); Map&amp; bucket = bucket_indexes_[bucket_id]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = bucket.find(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != bucket.end()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it-&gt;second; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br><p>  The idea was as follows: indices, by condition, a 32-bit integer, which means no one bothers to add data with arbitrary indices within this range (oh, how wrong I was!).  Therefore, I had BUCKETS_COUNT (= 10) repositories to reduce the wait time on the thread mutex. </p><br><p>  Since  there were requests for data sampling, and it was necessary to quickly search for all the places the user visited, and all the reviews left for the places, then indices were needed <code>users -&gt; visits</code> and <code>locations -&gt; visits</code> . </p><br><p>  The following code was written for the index, with the same ideology: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiIndex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MultiIndex() : buckets_(BUCKETS_COUNT), bucket_mutexes_(BUCKETS_COUNT) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, T* pointer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucket_id = id % BUCKETS_COUNT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); buckets_[bucket_id].insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(id, pointer)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Replace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> old_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_id, T* val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucket_id = old_id % BUCKETS_COUNT; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> range = buckets_[bucket_id].equal_range(old_id); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = range.first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it != range.second) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;second == val) { buckets_[bucket_id].erase(it); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ++it; } } bucket_id = new_id % BUCKETS_COUNT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); buckets_[bucket_id].insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(new_id, val)); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T*&gt; GetValues(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bucket_id = id % BUCKETS_COUNT; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(bucket_mutexes_[bucket_id]); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> range = buckets_[bucket_id].equal_range(id); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = range.first; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T*&gt; result; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it != range.second) { result.push_back(it-&gt;second); ++it; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_multimap</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, T*&gt;&gt; buckets_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; bucket_mutexes_; };</code> </pre> <br><p>  Initially, the organizers laid out only test data with which the database was initialized, and there were no examples of requests, so I started testing my code using <a href="https://insomnia.rest/">Insomnia</a> , which made it easy to send and modify requests and watch the answer. </p><br><p>  A little later, the organizers took pity on the participants and laid out the cartridges from the tank and the full data of rating and test attacks, and I wrote a simple <a href="https://github.com/evgsid/hlcup_tank">script</a> that allowed me to test locally the correctness of my decision and helped a lot in the future. </p><br><h1>  Highload start </h1><br><p>  And finally, the prototype was completed, the tester said locally that everything is OK, and it is time to send your solution.  The first launch was very exciting, and he showed that something was wrong ... </p><br><p><img src="https://habrastorage.org/web/e91/8d3/12a/e918d312a5cf40f4ba9b53ce29dc541c.jpeg" alt="first attempt"></p><br><p><img src="https://habrastorage.org/web/5f9/a56/bc2/5f9a56bc2ec84026a7c4a7986c5ed17b.jpeg" alt="graph"></p><br><p>  My server did not hold the load at 2000rps.  The leaders at this moment, as I recall, times were of the order of hundreds of seconds. </p><br><p>  Then I decided to check if the server is coping with the load at all, or if these are problems with my implementation.  I wrote a code that simply gave an empty json to all requests, ran a rating attack, and saw that proxygen itself could not cope with the load. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">onEOM</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">noexcept</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">override</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxygen</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ResponseBuilder</span></span>(downstream_) .<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(200, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">header</span></span>(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">body</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">sendWithEOM</span></span>(); }</code> </pre> <br><p>  This is how the diagram of the 3rd phase looked. </p><br><p><img src="https://habrastorage.org/web/9d8/499/93a/9d849993acae4c97b5885a8be645abef.jpeg" alt="proxygen fail"></p><br><p>  On the one hand, it was nice that this was still not a problem in my code, on the other, the question arose: what to do with the server?  I was still hoping to avoid writing my own, and decided to try something else. </p><br><p>  The next test was <a href="https://github.com/ipkn/crow">Crow</a> .  I‚Äôll say right away that I really liked it, and if suddenly in the future I need a plus http-server, then it will be him.  header-based server, I just added it to my project instead of proxygen, and rewrote the request handlers a bit to get them working with the new server. </p><br><p>  Using it is very simple: </p><br><pre> <code class="hljs php">crow::SimpleApp app; CROW_ROUTE(app, <span class="hljs-string"><span class="hljs-string">"/users/&lt;uint&gt;"</span></span>).methods(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>_method, <span class="hljs-string"><span class="hljs-string">"POST"</span></span>_method) ( [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crow::request&amp; req, crow::response&amp; res, uint32_t id) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.method == crow::HTTPMethod::GET) { get_handlers::GetUsers(req, res, id); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { post_handlers::UpdateUsers(req, res, id); } }); app.bindaddr(<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>).port(<span class="hljs-number"><span class="hljs-number">80</span></span>).multithreaded().run();</code> </pre> <br><p>  If there is no suitable description for api, the server itself sends 404, if there is a necessary handler, then in this case it gets the uint-parameter from the request and passes it as a parameter to the handler. </p><br><p>  But before using the new server, taught by bitter experience, I decided to check whether it copes with the load.  As in the previous case, I wrote a handler that returned an empty json to any request, and sent it to rating shelling. <br>  Crow managed, he kept the load, and now I had to add my logic. </p><br><p><img src="https://habrastorage.org/web/e02/8fd/cce/e028fdccee0f45b39831c84ed1c8c3c4.jpeg" alt="Crow win"></p><br><p>  Since  the logic was already written, then adapting the code to the new server was quite simple.  Everything worked out! </p><br><p><img src="https://habrastorage.org/web/c42/d1a/dbe/c42d1adbe3474e5c8c7e718079c05386.jpeg" alt="Crow first result"></p><br><p>  100 seconds is already something, and you can begin to engage in the optimization of logic, rather than searching for a server. </p><br><p>  Since  my server was still generating responses using <code>std::stringstream</code> , I decided to get rid of it first.  At the time of adding the record to the database, a line was immediately formed that contained the full response with the header, and at the time of the request gave it. <br>  At this stage, I decided to add the header completely in response for two reasons: </p><br><ul><li>  remove <code>write()</code> </li><li>  There is only 200 MB of data, there is enough memory </li></ul><br><p>  Another problem that many copies were broken about in the telegram in the telegram and by me personally is the filter of users by age.  By the condition of the problem, the age of users was stored in the unix timestamp, and in the queries it came in the form of full years: <code>fromAge=30&amp;toAge=70</code> .  How do years lead to seconds?  Consider a leap year or not?  And if the user was born on February 29? </p><br><p>  The result was a code that solved all these problems in one fell swoop: </p><br><pre> <code class="hljs perl">static time_t t = g_generate_time; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> get <span class="hljs-keyword"><span class="hljs-keyword">time</span></span> now static struct tm now = (*<span class="hljs-keyword"><span class="hljs-keyword">localtime</span></span>(&amp;t)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (search_flags &amp; QueryFlags::FROM_AGE) { tm from_age_tm = now; from_age_tm.tm_year -= from_age; time_t from_age_t = mktime(&amp;from_age_tm); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user-&gt;birth_date &gt; from_age_t) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } }</code> </pre> <br><p>  The result was a two-fold increase in performance, from 100 seconds to 50 seconds. <br>  Not bad at first glance, but at that moment the leaders had less than 20 seconds, and I was somewhere in the 20-40 place with my result. </p><br><p>  At this point, two more observations were made: </p><br><ul><li>  data indices are always in order from 1 without gaps </li><li>  index sizes were approximately 1M for Users and Locations, and 10M for Visits. </li></ul><br><p>  It became clear that hashes, mutexes and buckets for data storage are not needed, and the data can be perfectly stored by index in the vector, which was done.  The final version can be seen <a href="">here</a> (a part of the code for processing indexes was additionally added to the final if they suddenly exceed the limit). </p><br><p>  There seemed to be no obvious points that would strongly influence the performance in my logic.  Most likely, with the help of optimizations, you could throw off a few more seconds, but you had to fold half. </p><br><p>  I again began to rest against the work with the network / server.  Having run through the server sources, I came to a disappointing conclusion - when sending, 2 unnecessary copying of data took place: first into the internal buffer of the server, and then again into the buffer for sending. </p><br><h1>  I want to ride my bicycle ... </h1><br><p>  There is nothing more helpless, irresponsible and immoral in the world than to start writing your own web server.  And I knew that pretty soon I would plunge into it. </p><br><p>  And this moment has come. <br>  When writing your server, several assumptions were made: </p><br><ul><li>  tank shoots through a loopback, and therefore there are no losses </li><li>  the packages from the tank are very small, so they can be read into one read () </li><li>  my answers are also small, so they will be written in one write () call, and the call to write will not be blocked </li><li>  only valid get and post requests come from the tank </li></ul><br><p>  In general, it was possible to honestly support read () and write () in several pieces, but the current version worked, so it remained "for later". </p><br><p>  After a series of experiments, I stopped at the following architecture: blocking accept () in the main thread, adding a new socket to the epoll, and <code>std::thread::hardware_concurrency()</code> threads listen to one epollfd and process the data. </p><br><pre> <code class="hljs ruby">unsigned int thread_nums = std::thread::hardware_concurrency(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thread_nums; ++i) { threads.push_back(std::thread([epollfd, max_events]() { epoll_event events[max_events]; int nfds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { nfds = epoll_wait(epollfd, events, max_events, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; nfds; ++n) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } } })); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { int sock = accept(listener, NULL, NULL); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... struct epoll_event ev; ev.events = EPOLLIN <span class="hljs-params"><span class="hljs-params">| EPOLLET |</span></span> EPOLLONESHOT; ev.data.fd = sock; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, sock, &amp;ev) == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"epoll_ctl: conn_sock"</span></span>); exit(EXIT_FAILURE); } }</code> </pre> <br><p>  <code>EPOLLET</code> guarantees that only one stream will be awakened, and also that if there are unread data in the socket, the <code>epoll</code> per socket will not work until all of them are read to <code>EAGAIN</code> .  Therefore, the next recommendation for using this flag is to make the socket non-blocking and read until the error returns.  But as indicated in the assumptions, the requests are small and read in one call to <code>read()</code> , there is no data left in the socket, and the <code>epoll</code> worked fine for the arrival of new data. </p><br><p>  Here I made one mistake: I used <code>std::thread::hardware_concurrency()</code> to determine the number of threads available, but it was a bad idea because this call returned 10 (number of cores on the server), and only 4 cores were available in the docker .  However, this had little effect on the result. </p><br><p>  I used <a href="http-parser">http-parser</a> for http parsing (Crow also uses it), libyuarel for parsing <a href="https://github.com/jacketizer/libyuarel">URLs</a> , and <a href="https://github.com/jacketizer/libyuarel">qs_parse</a> for decoding parameters in a query query.  qs_parse is also used in Crow, it can parse the URL, but it so happens that I only used it to decode the parameters. </p><br><p>  Having rewritten my implementation in this way, I managed to throw off another 10 seconds, and now my result was 40 seconds. </p><br><h1>  MOAR HIGHLOAD </h1><br><p>  Until the end of the competition, a week and a half remained, and the organizers decided that 200Mb of data and 2000rps were not enough, and they increased the size of the data and the load 5 times: the data began to occupy 1GB in unpacked form, and the intensity of the shelling increased to 10000rps on the 3rd phase. </p><br><p>  My implementation, which kept all the answers, stopped getting into memory, making many write () calls to write an answer in parts, also seemed like a bad idea, and I <a href="">rewrote my decision</a> to use writev (): there was no need to duplicate data during storage and writing was done using a <a href="">single system call</a> (an improvement for the final was also added here: writev could write 1024 iovec array elements at a time, and <a href="">my implementation</a> for <code>/users/&lt;id&gt;/locations</code> was very iovec-expensive, and I added the ability to split the data record on 2 pieces). </p><br><p>  Having sent my implementation to the launch, I got fantastic (in a good way) 245 seconds, which allowed me to be in 2nd place in the results table at that time. </p><br><p>  Since the test system is subject to large randomization, and the same solution can show different times, and rating attacks could be launched only 2 times a day, it is unclear which of the following improvements led to the final result, and which did not. </p><br><p>  For the rest of the week I did the following optimizations: </p><br><p>  Replaced call chain calls </p><br><pre> <code class="hljs php">DBInstance::GetDbInstance()-&gt;GetLocations()</code> </pre> <br><p>  on the pointer </p><br><pre> <code class="hljs">g_location_storage</code> </pre> <br><p>  Then I thought that an honest http-parser for get-requests is not needed, and for a get-request you can immediately take a URL and not take care of anything else.  Fortunately, the fixed tank requests allowed it.  Also here the moment is noteworthy that you can spoil the buffer (write <code>\0</code> to the end of the URL, for example).  Libyuarel works in the same way. </p><br><pre> <code class="hljs cs">HttpData http_data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'G'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* url_start = buf + <span class="hljs-number"><span class="hljs-number">4</span></span>; http_data.url = url_start; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* it = url_start; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> url_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*it++ != <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ++url_len; } http_data.url_length = url_len; http_data.method = HTTP_GET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { http_parser_init(parser.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), HTTP_REQUEST); parser-&gt;data = &amp;http_data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nparsed = http_parser_execute( parser.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), &amp;settings, buf, readed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nparsed != readed) { close(sock); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } http_data.method = parser-&gt;method; } Route(http_data);</code> </pre> <br><p>  Also in the telegram in the telegram, the question was raised that only the number of fields in the header is checked on the server, and not their contents, and the headers were mercilessly cut: </p><br><pre> <code class="hljs tex">const char* header = "HTTP/1.1 200 OK<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">r</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>" "S: b<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">r</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>" "C: k<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">r</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>" "B: a<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">r</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>" "Content-Length: ";</code> </pre> <br><p>  It seems a strange improvement, but on many requests the size of the response was significantly reduced.  Unfortunately, it is not known whether it has given at least some increase. </p><br><p>  All these changes led to the fact that the best time in the sandbox is up to 197 seconds, and it was 16th place <a href="https://highloadcup.ru/media/ckeditor/2017/09/02/rating.html">at the time of closure</a> , and in the <a href="https://highloadcup.ru/rating/round/2/">final</a> 188 seconds, and 13th place. </p><br><p><img src="https://habrastorage.org/web/820/e4c/481/820e4c481ab748ada964680bb029b40c.jpeg" alt="final"></p><br><p>  The solution code is completely located here: <a href="https://github.com/evgsid/highload_solution">https://github.com/evgsid/highload_solution</a> </p><br><p>  Decision code at the time of the final: <a href="https://github.com/evgsid/highload_solution/tree/final">https://github.com/evgsid/highload_solution/tree/final</a> </p><br><h1>  Magic pill </h1><br><p>  And now let's talk a little about magic. </p><br><p>  The <a href="https://highloadcup.ru/media/ckeditor/2017/09/02/rating.html">first 6 places in the ranking</a> stood out in the sandbox: they had time ~ 140 seconds, and the next ~ 190 and further time gradually increased. </p><br><p>  It was obvious that the first 6 people found some kind of magic pill. <br>  I tried sendfile and mmap as an experiment to exclude copying from userspace -&gt; kernelspace, but the tests showed no performance gain. </p><br><p>  And here are the last minutes before the final, decision making is closed, and the leaders share the magic pill: <strong>BUSY WAIT</strong> . <br>  Other things being equal, a solution that gave 180 seconds with <code>epoll(x, y, z, -1)</code> using <code>epoll(x, y, z, 0)</code> gave immediately 150 seconds or less.  Of course, this is not a production solution, but it greatly reduces delays. </p><br><p>  A good article about this can be found here: <a href="https://blog.cloudflare.com/how-to-achieve-low-latency/">How to achieve low latency with 10Gbps Ethernet</a> . </p><br><p>  My decision, the best result of which was 188 in the final, when using the busy wait immediately showed 136 seconds, which would be the 4th time in the final, and 8th place in the sandbox at the time of this writing. </p><br><p>  Here is the best solution graph: </p><br><p><img src="https://habrastorage.org/web/d15/c04/d0b/d15c04d0b2f64e1190acd6d37c2890f6.jpeg" alt="ideal"></p><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text"><p>  In fact, the busy wait should be used very carefully.  My solution, when the main thread accepts connections, and 4 streams only process data from sockets, when using busy wait, the post-phase began to sink a lot, because accept didn‚Äôt have enough CPU time, and my decision was very slow.  Reducing the number of processing threads to 3 completely solved this problem. </p></div></div><br><h1>  Conclusion </h1><br><p><del>  The master of ceremonies is good, and the competitions are interesting. </del></p><br><p>  It was very cool!  These were unforgettable 3 weeks of system programming.  Thanks to my wife and children that they were on vacation, otherwise the family would be close to divorce.  Thanks to the organizers who did not sleep at night, helped the participants and fought with the tank.  Thanks to the participants who gave a lot of new ideas and pushed for new solutions. </p><br><p>  I look forward to the next contest! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337710/">https://habr.com/ru/post/337710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337698/index.html">Writing operator for Kubernetes at Golang</a></li>
<li><a href="../337700/index.html">10 interesting innovations in JUnit 5</a></li>
<li><a href="../337702/index.html">From Toronto to Tomsk: summing up and planning future seminars on microelectronics in Russia</a></li>
<li><a href="../337704/index.html">Moving Java forward faster</a></li>
<li><a href="../337708/index.html">DevOps with Kubernetes and VSTS. Part 2: Cloud History</a></li>
<li><a href="../337712/index.html">Parrot Security OS - an alternative to Kali Linux</a></li>
<li><a href="../337714/index.html">The book "Security Audit Information Systems"</a></li>
<li><a href="../337716/index.html">How to switch to gRPC, saving REST</a></li>
<li><a href="../337718/index.html">Creating and normalizing dictionaries. Choose the best, remove too much</a></li>
<li><a href="../337720/index.html">10 years of Computer Science club</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>