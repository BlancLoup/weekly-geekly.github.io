<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why write your React Data Grid in 2019</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I am involved in the development of an ECM system. And in a small series of articles I want to share our experience and history of developin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why write your React Data Grid in 2019</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I am involved in the development of an ECM system.  And in a small series of articles I want to share our experience and history of developing my React Data Grid (hereinafter referred to as a grid), namely: </p><br><ul><li>  why we abandoned the finished component </li><li>  what problems and tasks we faced when developing our grid </li><li>  What profit does the development of its grid </li></ul><br><h3 id="predystoriya">  Prehistory </h3><br><p>  Our system has a web application in which users work with lists of documents, search results, directories.  Moreover, the lists can be either small (10 employees) or very large (50,000 contractors).  To display these lists, we developed our grid: </p><br><p><img src="https://habrastorage.org/webt/1m/v3/py/1mv3pyhnf7emxc6xs2h8lcv8dis.png" alt="image"></p><a name="habracut"></a><br><p>  When we first started developing a web application, I wanted to find a ready library for displaying a grid that can do everything we need: sort and group records, drag and stretch columns, work with multiple selections, filter and calculate totals by columns, portionwise upload data from the server and display tens of thousands of records. </p><br><p>  Let me explain the last requirement ‚Äúto display tens of thousands of records‚Äù.  In grids this requirement is implemented in several ways: paging, infinity scrolling, virtual scrolling. </p><br><p>  The paging and infinity scrolling approaches are common on web sites, you use them every day.  For example, paging on Google: </p><br><p><img src="https://habrastorage.org/webt/v5/5q/vz/v55qvz8wjlhqmp-jfzievdnjvxe.png" alt="image"></p><br><p>  Or infinity scrolling in the same Google in pictures, where the next portion of pictures is loaded when you scroll through the first portion: </p><br><p><img src="https://habrastorage.org/webt/bs/r7/qk/bsr7qkhgokj6ezk3qlagzkkgdaq.png" alt="image"></p><br><p>  But virtual scrolling (I will call virtual scrolling hereafter) is rarely used on the web, its main difference from infinity scrolling is the ability to quickly scroll very large lists to any place.  In this case, only the data visible to the user will be loaded and displayed. </p><br><p><img src="https://habrastorage.org/webt/wf/j8/ct/wfj8ctaao00cbfi1txsytvpqwae.png" alt="image"></p><br><p>  For our web application, we wanted to use virtual scrolling.  I agree that scrolling to any place in the list of 10,000 entries is rather a fictional case.  However, arbitrary scrolling within 500‚Äì1000 records is a live case. </p><br><p>  When virtual scrolling is implemented, the software management API of this scrolling is often implemented.  This is a very important feature.  Software scrolling is used, for example, to position a highlighted entry in the middle of the screen when opening a directory: </p><br><p><img src="https://habrastorage.org/webt/ny/up/na/nyupnajuldvlpnb294u203xvy-w.png" alt="image"></p><br><p>  Let's return to the requirements.  What else we needed: </p><br><ul><li>  Virtual scrolling management software API </li><li>  Customizing the appearance of the grid (rows, columns, context menu) so that the grid does not look foreign in our application. </li><li>  Support technologies we use: react, redux and flexbox </li><li>  That grid worked in ie11 </li></ul><br><p>  In general, there were many requirements. </p><br><h3 id="popytka-pervaya-2016-god-devextreme-javascript-data-grid">  Attempt the first (2016).  DevExtreme JavaScript Data Grid </h3><br><p>  Not long examining existing libraries, we stumbled upon DevExtreme JavaScript Data Grid.  According to the functional requirements, this grid covered all our needs and had a very presentable appearance.  However, the technological requirements are not suitable (not react, not redux, not flexbox).  At that time, DevExtreme had no react grid. </p><br><p>  Well, let not react, we decided, for that the grid is beautiful and functional, we will use it.  And they added the library to their project.  It turned out we added 3 MB of scripts. </p><br><p>  For a couple of weeks, we integrated the grid into our web application and enhanced the basic functionality: </p><br><ul><li>  Wrapped over the grid to make it friends with react and redux </li><li>  We lifted virtual scrolling and portion loading of data from our web server </li><li>  Implemented sorting and selection </li></ul><br><p>  In the course of screwing up the grid, two serious problems emerged and a whole heap of less serious ones. </p><br><h3 id="pervaya-sereznaya-problema">  The first serious problem </h3><br><p>  Making friends with DevExtreme JavaScript Data Grid with redux is very difficult.  We managed to manage the settings of the columns and the selection of records through redux, but storing the batch-loaded data in redux and performing CRUD operations on them through redux is unrealistic.  I had to make a crutch that, bypassing redux, manipulated the grid data.  The crutch turned out to be complex and fragile.  It was the first alarm bell that the grid does not suit us, but we continued to screw it. </p><br><h3 id="vtoraya-sereznaya-problema">  The second serious problem </h3><br><p>  No virtual scrolling management API.  We couldn‚Äôt refuse software scrolling management, we had to override the DevExtreme sources and find the internal scrolling management API.  Of course, this API had a mountain of restrictions, because it was designed for internal use.  As a result, we achieved that the internal API more or less worked on our cases, but, again bypassing redux, and again a bunch of crutches. </p><br><h3 id="menee-sereznye-problemy">  Less serious problems </h3><br><p>  Less serious problems surfaced constantly, because the standard DevExtreme JavaScript Data Grid functionality weren‚Äôt completely matched, and we tried to correct it: </p><br><ol><li>  Stretching the DevExtreme grid height doesn't work.  I had to write a hack to teach DevExtreme to do it (perhaps in recent versions there are no problems with this). </li><li>  When the focus is not in the grid, it is impossible to control the selection of lines through the keyboard (and we needed it).  I had to write my keyboard controls. </li><li>  When changing the composition of columns and changing data, we had a problem of data blinking (with virtual scrolling turned on). </li><li>  The problem of a large number of requests at the first showing of the grid.  It was especially noticeable when we managed scrolling through the internal API. </li><li>  It is difficult to customize some parts of the UI grid.  For example, there was a desire to draw line management actions over the selected line of the grid (delete a line, copy, open a card).  But how to twist it in DevExtreme was not clear, and even using react: <br><img src="https://habrastorage.org/webt/yo/zv/9b/yozv9boc174n-rxmbdsxoham4g8.png" alt="image"></li><li>  It is difficult to categorize the sorting (we wanted to sort by data that is not displayed in the grid, and not buried in the columns). </li><li>  Crutches are required for screwing the react components into grid cells (because the grid is not on react). </li><li>  No DevExtreme code typing (flow / typescript). </li><li>  The problem of speed during long virtual scrolling. </li><li>  The problem of speed when stretching / rearranging columns (after a long virtual scrolling). </li><li>  Grid scripts size - 3 MB. </li></ol><br><p>  Although the DevExtreme grid in terms of functionality contained everything we needed, but almost all the standard functionality wanted to be rewritten.  During its use, hundreds of lines of difficult to understand code were added, which tried to solve problems of interaction with redux and react, it was difficult to use a non-react grid in the react application. </p><br><h3 id="otkaz-ot-devextreme-poisk-alternativ">  Rejection of DevExtreme.  Search for alternatives </h3><br><p>  After some time using DevExtreme, it was decided to abandon it.  Throw out all the hacks, complex code, as well as 3 MB of DevExtreme scripts.  And find or write a new grid. </p><br><p>  This time, we were more attentive to the study of existing grids.  MS Fabric DetailsList, ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid, KendoUI Grid were studied. <br>  The requirements remain the same, but they have already formed into a list that is understandable to us. </p><br><p>  Technology Requirements: </p><br><ul><li>  react </li><li>  redux </li><li>  flexbox </li></ul><br><p>  Requirements for functionality: </p><br><ul><li>  Virtual scrolling (with the ability to show tens of thousands of entries) </li><li>  Scrolling management API </li><li>  Grid data and settings storage in redux </li><li>  Portion loading of data from the web server </li><li>  Column management (stretching / rearranging / visibility control) </li><li>  Sorting + Filtering by Column </li><li>  Multiple selection </li><li>  Like-search backlit </li><li>  Horizontal scrolling </li><li>  Keyboard operation </li><li>  Context menu (on line, on empty area, on columns) </li><li>  Support ie11, edge, chrome, ff, safari </li></ul><br><p>  By this time, the first version of DevExtreme React Grid has already appeared, but we immediately discarded it for the following reasons: </p><br><ul><li>  Virtual scrolling is not supported in ie11 </li><li>  Virtual scrolling does not work in conjunction with batch loading of data from the server (although there seems to be some workaround). </li><li>  And most importantly, I didn‚Äôt want to step on the same rake when I wanted to rewrite half of the standard third-party grid functionality. </li></ul><br><p>  Analysis of existing solutions showed that there is no ‚Äúsilver bullet‚Äù.  Grid, which would close all our requirements, does not exist.  It was decided to write our grid, which we will develop in terms of functionality in the direction we need, and be friends with the technologies needed by our product. </p><br><h3 id="razrabotka-svoego-react-data-grid">  Develop your React Data Grid </h3><br><p>  Grid development started with prototypes, where we tried the most difficult topics for us: </p><br><ul><li>  virtual scrolling </li><li>  storing all grid data in redux </li></ul><br><h3 id="virtual-scrolling">  Virtual scrolling </h3><br><p>  The most difficult was to make a virtual scrolling.  In a big way, it is made in one of 3 ways: </p><br><p> <strong>1. Page-based virtualization</strong> <br>  Data is drawn in chunks - pages.  When scrolling, visible pages are added, invisible ones are deleted.  The page consists of 20-60 lines (usually the size is customized).  In this way, the products went: DevExtreme JavaScript Data Grid, MS Fabric DetailsList. </p><br><p><img src="https://habrastorage.org/webt/h7/tf/5l/h7tf5lynlgmje6wunlcowkeabqa.png" alt="image"></p><br><p>  <strong>2. Line Virtualization</strong> <br>  Only visible lines are drawn.  As soon as the line leaves the screen, it is immediately deleted.  This way went the products: ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid. </p><br><p><img src="https://habrastorage.org/webt/9j/zs/bh/9jzsbhqw0_up5gnkt2g7cw3uth0.png" alt="image"></p><br><p>  <strong>3. Canvas</strong> <br>  All lines and their contents are drawn using Canvas.  So did Google Docs. </p><br><p><img src="https://habrastorage.org/webt/12/f_/hd/12f_hdydog5ponrdm9filxne_1u.png" alt="image"></p><br><p>  When developing the grid, we made prototypes for all three variants of virtualization (even for Canvas).  And they chose paged virtualization. </p><br><h3 id="pochemu-otkazalis-ot-drugih-variantov">  Why abandoned other options? </h3><br><p>  Line-by-line virtualization had problems with rendering speed in the prototype.  As soon as the contents of the lines became complicated (a lot of text, highlighting, trimming, icons, a large number of columns, and flexbox everywhere), it became expensive to add / delete lines several times a second.  Of course, the results also depend on the browser (we did support, including for ie11, edge): </p><br><p><img src="https://habrastorage.org/webt/fe/4v/xh/fe4vxhw7r5zjwqqezc7rmxubmmm.png" alt="image"></p><br><p>  The Canvas version was very seductive in rendering speed, but time consuming.  It was suggested to draw everything: text, text wrap, text trimming, highlighting, icons, dividing lines, selection, indents.  Make a reaction to pressing the mouse buttons on the Canvas, highlighting the lines when you hover the cursor.  At the same time, on top of the Canvas should be put some Dom-elements (showing hints, "pop-up actions" above the line).  Still needed to solve the problem of blur text and icons in the Canvas.  All this is long and difficult to do.  Although we mastered the prototype.  In this case, any customization of rows and cells in the future we would have resulted in greater complexity. </p><br><h4 id="plyusy-postranichnoy-virtualizacii">  Pluses of virtualization virtualization </h4><br><p>  The selected page-based virtualization had advantages over line-by-line, which determined its choice: </p><br><ul><li>  If the page is already rendered, then scrolling inside the page is cheap (the DOM tree does not change when scrolling).  Line-by-line virtualization with any minor scrolling requires changing the DOM tree, and this is expensive when the DOM tree is complex and flexbox is used everywhere. </li><li>  For small lists (&lt;200 entries), pages can be not deleted, only added.  Sooner or later, all pages will be built, and scrolling will be completely free (in terms of rendering time). </li></ul><br><h4 id="vybor-razmera-stranicy">  Select page size </h4><br><p>  A separate question is the choice of page size.  Above, I wrote that the size is customizable and is usually 20-60 lines.  A large page is drawn for a long time, a small one leads to frequent display of a ‚Äúwhite screen‚Äù when scrolling.  Experimentally, the page size was 25 lines.  However, for ie11, the size has been reduced to 5 lines.  It feels like the interface in IE is more responsive if you draw many small pages with small delays than one large one with a large delay. </p><br><h4 id="react-i-virtual-scrolling">  React and virtual scrolling </h4><br><p>  Page-based virtualization needed to be implemented using react.  For this, several tasks had to be solved: </p><br><p>  <strong>Task 1. How to add / delete pages through react when scrolling?</strong> </p><br><p>  To solve this problem introduced the concept: </p><br><ul><li>  page model </li><li>  page view </li></ul><br><p>  A model is information on which to build a presentation.  A view is a React component. </p><br><p><img src="https://habrastorage.org/webt/ud/da/qi/uddaqigdtketfoh6cwk6lnklcpo.png" alt="image"></p><br><p>  In essence, the task of virtualization after that was reduced to manipulating page models: keeping a list of page models, adding and deleting models when scrolling.  And according to the list of models through react, build / rebuild the mapping: </p><br><p><img src="https://habrastorage.org/webt/4m/sr/g0/4msrg0gy9qwsv9u-8ljjqhzllwa.png" alt="image"></p><br><p>  In the course of implementation, the rules for working with page models were formed: </p><br><ul><li>  Pages should be added one by one.  After each addition, give time to draw.  It is acceptable to add 1 page every 300-500ms - this is a situation of fast scrolling.  If you add, for example, 5 pages at once, then the user will hang up the interface on their construction. </li><li>  Pages do not need to keep dozens.  Example of a problem situation: 20 pages are displayed, the user goes to another list and all 20 pages need to be deleted at once.  Deleting a large number of pages is an expensive operation, stripping the DOM of a tree will take 1 second.  To avoid this, it is better to keep no more than 10 pages at a time. </li><li>  For any manipulation of the columns (permutation, addition, deletion, stretching) it is better to remove the pages invisible to the user in advance.  This will avoid expensive rebuilding of all rendered pages. </li></ul><br><p>  <strong>Task 2. How to display scollbar?</strong> </p><br><p>  Virtual scrolling assumes that a scrollbar is available, which takes into account the sizes of the list and allows scrolling to any place: </p><br><p><img src="https://habrastorage.org/webt/lo/rc/ut/lorcutgz7bcopbjltcnziudkgks.png" alt="image"></p><br><p>  How to display such a scollbar?  The simplest solution is to draw an invisible div of the desired size instead of real data.  And already on top of this div display the visible pages: </p><br><p><img src="https://habrastorage.org/webt/pp/_x/vg/pp_xvgowd1qtrnyigxnszou0xnw.png" alt="image"></p><br><p>  <strong>Task 3. How to monitor the size of the viewport?</strong> </p><br><p>  Viewport is the visible data area of ‚Äã‚Äãthe grid.  Why keep track of its size?  To calculate the number of pages to display to the user.  Suppose we have a small page size (5 lines) and a large screen resolution (1920x1080).  How many pages should be displayed to the user to close the entire viewport? </p><br><p><img src="https://habrastorage.org/webt/tt/g3/sx/ttg3sxfvvuf320ydcwe6esbukp4.png" alt="image"></p><br><p>  You can solve this problem if you know the height of the viewport and the height of one page.  Now let's complicate the task, suppose the user dramatically changes the scale in the browser - sets 50%: </p><br><p><img src="https://habrastorage.org/webt/s8/47/mt/s847mtipiappdqe0qqsli_yvj14.png" alt="image"></p><br><p>  The situation with the scale shows that it is not enough to know the size of the viewport once, the size must be monitored.  And now we‚Äôll completely complicate the task: html elements don‚Äôt have a resize event to which you can subscribe and track the size.  Resize is only for the window object. </p><br><p>  The first thing that comes to mind is to use a timer and constantly poll the height of the html element.  But there is an even better solution that we saw in DevExtreme JavaScript Data Grid: create an invisible iframe, stretch it to the grid size and subscribe to the resize event in iframe.contentWindow: </p><br><p><img src="https://habrastorage.org/webt/fa/gi/ta/fagitaw870f5ahtworjownk__mk.png" alt="image"></p><br><p><img src="https://habrastorage.org/webt/dd/m9/tq/ddm9tqblgsmpwepcc7_gq7g32sm.png" alt="image"></p><br><h3 id="rezyume">  Summary </h3><br><p>  PS This is not the end.  In the next article I will tell how we made friends with our redux grid. </p><br><p>  To get a full-fledged virtual scrolling, many other tasks had to be solved.  But those described above were themselves interesting.  Here are a few more tasks that came up too: </p><br><ul><li>  Take into account the direction and speed of scrolling when adding / deleting pages. </li><li>  Consider changing data to minimize rebuilding of page models.  For example, they deleted one line, or added a line, what to do with the already rendered pages?  All thrown out, or some leave?  There is room for optimization. </li><li>  When changing the selection rebuild the minimum required number of pages. </li></ul><br><p>  If you have questions about the implementation, you can write them in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457504/">https://habr.com/ru/post/457504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457490/index.html">Aysioshechka from Zuckerberg - briefly and in the Libra case</a></li>
<li><a href="../457494/index.html">‚ÄúAnd if I don‚Äôt know math, am I hopeless?‚Äù - experts answer frequently asked questions about the professions in Data Science</a></li>
<li><a href="../457496/index.html">"Find the five differences." Scalable Generation Difference - New Test Portion</a></li>
<li><a href="../4575/index.html">Monster.com told Runet the first "boo"</a></li>
<li><a href="../457500/index.html">How we did the autopilot for the service station</a></li>
<li><a href="../457508/index.html">Raising a child vs Machine learning: compares a young mother</a></li>
<li><a href="../457510/index.html">Use mcrouter to scale memcached horizontally.</a></li>
<li><a href="../457512/index.html">Logical replication between PostgreSQL versions</a></li>
<li><a href="../457514/index.html">Nevangary</a></li>
<li><a href="../457516/index.html">Writing a threat model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>