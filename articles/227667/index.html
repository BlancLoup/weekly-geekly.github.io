<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing (soccer) games using MonoGame</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone wants to develop games, and this is not surprising: they are popular and sell well. Who does not want to become famous and rich by making the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing (soccer) games using MonoGame</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/f1a/820/d43/f1a820d4350d4d647cd295fde1b253f2.png">  Everyone wants to develop games, and this is not surprising: they are popular and sell well.  Who does not want to become famous and rich by making the next Angry Birds or Halo?  In reality, however, game development is one of the most difficult tasks in programming, because in the game you need to pick up such a combination of graphics, sound and gameplay so that it captures the user. <br>  To make life easier for game developers, a variety of frameworks are created, not only for C and C ++, but also for C # and even JavaScript.  One of these frameworks is Microsoft XNA, which uses Microsoft DirectX technology and allows you to create games for Xbox 360, Windows, and Windows Phone.  Microsoft XNA is no longer evolving, but at the same time, the Open Source community offered another option - MonoGame.  Let's take a closer look at this framework using the example of a simple football (what is this?) Game. <br><a name="habracut"></a><br><h4>  What is MonoGame? </h4>  MonoGame is an open source implementation of the XNA API not only for Windows, but also for Mac OS X, Apple iOS, Google Android, Linux and Windows Phone.  This means that you can create games immediately under all these platforms with minimal changes.  Ideal for those making plans to capture the world! <br>  You don't even need Windows to develop with MonoGame.  You can use MonoDevelop (open source cross-platform IDE for Microsoft .NET languages) or cross-platform IDE Xamarin Studio to work on Linux and Mac. <br>  If you are a Microsoft .NET developer and use Microsoft Visual Studio daily, MonoGame can be installed there.  At the time of this writing, the latest stable version of MonoGame was 3.2, which is installed in Visual Studio 2012 and 2013. <br><br><h4>  Create the first game </h4>  To create the first game, in the template menu, select MonoGame Windows Project.  Visual Studio will create a new project with all the necessary files and links.  If you run the project, you will get something like this: <br>  Boring, isn't it?  Nothing, this is just the beginning.  You can start developing your game in this project, but there is one nuance.  You cannot add any objects (images, sprites, fonts, etc.) without converting them to MonoGame compatible format.  To do this, you need something from the following: <br><ul><li>  Install XNA Game Studio 4.0 </li><li>  Install Windows Phone 8 SDK </li><li>  Use an external program like the XNA content compiler </li></ul><br>  So, in Program.cs you have the function Main.  It initializes and launches the game. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var game = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Game1()) game.Run(); }</code> </pre> <br>  Game1.cs is the core of the game.  You have two methods that are called 60 times per second: Update and Draw.  With Update you recalculate the data for all elements of the game;  Draw, respectively, implies the drawing of these elements.  Note that the time for iteration of the cycle is given quite a bit - only 16.7 ms.  If there is not enough time to perform the cycle, the program will skip several Draw methods, which, naturally, will be noticeable in the picture. <br>  For example, we will create a football game ‚Äúscore a penalty.‚Äù  The kick will be controlled by our touch, and the computer ‚Äúgoalkeeper‚Äù will try to catch the ball.  The computer selects a random location and speed "goalkeeper."  Points are considered to be our usual way. <br><br><h4>  Add content to the game </h4>  The first step in creating a game is to add content.  Let's start with the field pattern and the ball pattern.  Create two PNG patterns: the fields (below) and the ball (on the KDPV). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/b08/0cd/0e3/b080cd0e3532c676d64893ea1f8ae766.png"><br><br>  To use these images in the game, they need to compile.  If you are using the XNA Game Studio or the Windows Phone 8 SDK, you need to create an XNA content project.  Add pictures to this project and assemble it.  Then go to the project directory with copy the resulting .xnb files into your project.  XNA Content Compiler does not require a new project, objects in it can be compiled as needed. <br>  When .xnb files are ready, add them to the Content folder of your game.  Create two fields in which we will store the ball and field textures: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Texture2D _backgroundTexture; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Texture2D _ballTexture;</code> </pre><br><br>  These fields are loaded in the LoadContent method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> use this.Content to load your game content here _backgroundTexture = Content.Load&lt;Texture2D&gt;("SoccerField"); _ballTexture = Content.Load&lt;Texture2D&gt;("SoccerBall"); }</span></span></code> </pre><br>  Now draw the textures in the Draw method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ GraphicsDevice.Clear(Color.Green); <span class="hljs-comment"><span class="hljs-comment">// Set the position for the background var screenWidth = Window.ClientBounds.Width; var screenHeight = Window.ClientBounds.Height; var rectangle = new Rectangle(0, 0, screenWidth, screenHeight); // Begin a sprite batch _spriteBatch.Begin(); // Draw the background _spriteBatch.Draw(_backgroundTexture, rectangle, Color.White); // Draw the ball var initialBallPositionX = screenWidth / 2; var √≠nitialBallPositionY = (int)(screenHeight * 0.8); var ballDimension = (screenWidth &gt; screenHeight) ? (int)(screenWidth * 0.02) : (int)(screenHeight * 0.035); var ballRectangle = new Rectangle(initialBallPositionX, √≠nitialBallPositionY, ballDimension, ballDimension); _spriteBatch.Draw(_ballTexture, ballRectangle, Color.White); // End the sprite batch _spriteBatch.End(); base.Draw(gameTime); }</span></span></code> </pre><br>  This method fills the screen with green, and then draws the background and the ball on the penalty point.  The first method spriteBatch Draw draws the background, fitted to the size of the window, the second method draws the ball on the penalty point.  There is no movement here yet - you need to add it. <br><br><h4>  Ball movement </h4>  To move the ball, you need to recalculate its location in each iteration of the cycle and draw it in a new location.  Let's calculate the new position in the Update method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your update logic here _ballPosition -= 3; _ballRectangle.Y = _ballPosition; base.Update(gameTime); }</span></span></code> </pre><br>  The position of the ball is updated in each cycle by subtracting 3 pixels.  The variables _screenWidth, _screenHeight, _backgroundRectangle, _ballRectangle and _ballPosition are initialized in the ResetWindowSize method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetWindowSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _screenWidth = Window.ClientBounds.Width; _screenHeight = Window.ClientBounds.Height; _backgroundRectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _screenWidth, _screenHeight); _initialBallPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_screenWidth / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, _screenHeight * <span class="hljs-number"><span class="hljs-number">0.8f</span></span>); var ballDimension = (_screenWidth &gt; _screenHeight) ? (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(_screenWidth * <span class="hljs-number"><span class="hljs-number">0.02</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(_screenHeight * <span class="hljs-number"><span class="hljs-number">0.035</span></span>); _ballPosition = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_initialBallPosition.Y; _ballRectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_initialBallPosition.X, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_initialBallPosition.Y, ballDimension, ballDimension); }</code> </pre><br>  This method resets all variables depending on the window size.  It is called in the Initialize method. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your initialization logic here ResetWindowSize(); Window.ClientSizeChanged += (s, e) =&gt; ResetWindowSize(); base.Initialize(); }</span></span></code> </pre><br>  This method is called in two places: at the beginning and every time the window is resized.  If you run the program, you will notice that the ball moves straight, but does not stop with the end of the field.  You need to move the ball when it flies into the goal with the following code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your update logic here _ballPosition -= 3; if (_ballPosition &lt; _goalLinePosition) _ballPosition = (int)_initialBallPosition.Y; _ballRectangle.Y = _ballPosition; base.Update(gameTime); }</span></span></code> </pre><br>  The _goalLinePosition variable is also initialized in the ResetWindowSize method. <br><pre> <code class="cpp hljs">_goalLinePosition = _screenHeight * <span class="hljs-number"><span class="hljs-number">0.05</span></span>;</code> </pre><br>  In the Draw method, you also need to remove all calculations: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ GraphicsDevice.Clear(Color.Green); var rectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _screenWidth, _screenHeight); <span class="hljs-comment"><span class="hljs-comment">// Begin a sprite batch _spriteBatch.Begin(); // Draw the background _spriteBatch.Draw(_backgroundTexture, rectangle, Color.White); // Draw the ball _spriteBatch.Draw(_ballTexture, _ballRectangle, Color.White); // End the sprite batch _spriteBatch.End(); base.Draw(gameTime); }</span></span></code> </pre><br>  The movement of the ball is perpendicular to the goal line.  If you want to move the ball at an angle, create the _ballPositionX variable and increase it (to move to the right) or decrease (to move to the left).  Another best option is to use Vector2 to position the ball: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your update logic here _ballPosition.X -= 0.5f; _ballPosition.Y -= 3; if (_ballPosition.Y &lt; _goalLinePosition) _ballPosition = new Vector2(_initialBallPosition.X,_initialBallPosition.Y); _ballRectangle.X = (int)_ballPosition.X; _ballRectangle.Y = (int)_ballPosition.Y; base.Update(gameTime); }</span></span></code> </pre><br>  If you run the program now, you will see that the ball flies at an angle.  The next task is to attach finger control. <br><img src="//habrastorage.org/files/632/1d0/456/6321d045613e464b978f50a11779745e.png"><br><br><h4>  We implement management </h4>  In our game, control is exercised with a finger.  The movement of the finger sets the direction and force of impact. <br>  In MonoGame, sensory data is obtained using the TouchScreen class.  You can use raw data or Gestures API.  Raw data provides more flexibility because you have access to all of the information, the Gestures API transforms raw data into gestures, and you can filter only those that you need. <br>  In our game, we need only a click and, since the Gestures API supports this movement, we will use it.  First of all, let‚Äôs indicate with what gesture we will use: <br><pre> <code class="cpp hljs">TouchPanel.EnabledGestures = GestureType.Flick | GestureType.FreeDrag;</code> </pre><br>  Only clicks and dragging will be handled.  Next, in the Update method, we will process gestures: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TouchPanel.IsGestureAvailable) { <span class="hljs-comment"><span class="hljs-comment">// Read the next gesture GestureSample gesture = TouchPanel.ReadGesture(); if (gesture.GestureType == GestureType.Flick) { ‚Ä¶ } }</span></span></code> </pre><br>  Enable click in the Initialize method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your initialization logic here ResetWindowSize(); Window.ClientSizeChanged += (s, e) =&gt; ResetWindowSize(); TouchPanel.EnabledGestures = GestureType.Flick; base.Initialize(); }</span></span></code> </pre><br>  Until now, the ball rolled all the time while the game was being played.  Use the _isBallMoving variable to tell the game when the ball is moving.  In the Update method, when a click is detected, set _isBallMoving to True and the motion will begin.  When the ball recounts the goal line, set _isBallMoving to False and return the ball to its original position: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add your update logic here if (!_isBallMoving &amp;&amp; TouchPanel.IsGestureAvailable) { // Read the next gesture GestureSample gesture = TouchPanel.ReadGesture(); if (gesture.GestureType == GestureType.Flick) { _isBallMoving = true; _ballVelocity = gesture.Delta * (float)TargetElapsedTime.TotalSeconds / 5.0f; } } if (_isBallMoving) { _ballPosition += _ballVelocity; // reached goal line if (_ballPosition.Y &lt; _goalLinePosition) { _ballPosition = new Vector2(_initialBallPosition.X, _initialBallPosition.Y); _isBallMoving = false; while (TouchPanel.IsGestureAvailable) TouchPanel.ReadGesture(); } _ballRectangle.X = (int) _ballPosition.X; _ballRectangle.Y = (int) _ballPosition.Y; } base.Update(gameTime); }</span></span></code> </pre><br>  The speed of the ball is no longer constant; the program uses the _ballVelocity variable to set the speed along the x and y axes.  Gesture.Delta returns movement change since the last update.  To calculate your click speed, multiply this vector by TargetElapsedTime. <br>  If the ball moves, the _ballPosition vector changes based on the speed (in pixels per frame) until the ball reaches the goal line.  The following code stops the ball and removes all gestures from the input queue: <br><pre> <code class="cpp hljs">_isBallMoving = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TouchPanel.IsGestureAvailable) TouchPanel.ReadGesture();</code> </pre><br>  Now if you start the ball, it will fly in the direction of the click and with its speed.  However, there is one problem: the program does not look where the click occurred on the screen.  You can click anywhere and the ball will start moving.  The solution is to use raw data, get a touch point and see if it is near the ball.  If yes, the gesture sets the _isBallHit variable: <br><pre> <code class="cpp hljs">TouchCollection touches = TouchPanel.GetState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touches.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].State == TouchLocationState.Pressed) { var touchPoint = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.X, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.Y); var hitRectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_ballPositionX, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_ballPositionY, _ballTexture.Width, _ballTexture.Height); hitRectangle.Inflate(<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>); _isBallHit = hitRectangle.Contains(touchPoint); }</code> </pre><br>  Then the movement starts only if _isBallHit is True: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TouchPanel.IsGestureAvailable &amp;&amp; _isBallHit)</code> </pre><br>  There is another problem.  If you hit the ball too slowly or in the wrong direction, the game will end, as the ball will not cross the goal line and will not return to its original position.  It is necessary to set the limit time of the ball.  When the timeout is reached, the game starts again: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gesture.GestureType == GestureType.Flick) { _isBallMoving = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _isBallHit = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _startMovement = gameTime.TotalGameTime; _ballVelocity = gesture.Delta*(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) TargetElapsedTime.TotalSeconds/<span class="hljs-number"><span class="hljs-number">5.0f</span></span>; } ... var timeInMovement = (gameTime.TotalGameTime - _startMovement).TotalSeconds; <span class="hljs-comment"><span class="hljs-comment">// reached goal line or timeout if (_ballPosition.Y &lt;' _goalLinePosition || timeInMovement &gt; 5.0) { _ballPosition = new Vector2(_initialBallPosition.X, _initialBallPosition.Y); _isBallMoving = false; _isBallHit = false; while (TouchPanel.IsGestureAvailable) TouchPanel.ReadGesture(); }</span></span></code> </pre><br><h4>  Adding a goalkeeper </h4>  Our game works - we will now make it more difficult by adding a goalkeeper who will move after we hit the ball.  The goalkeeper is a picture in PNG format, we first compile it. <br><img src="//habrastorage.org/files/8eb/ea5/238/8ebea52383ab4be0a7bd9ef66c806735.png"><br>  The goalkeeper is loaded in the LoadContent method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a new SpriteBatch, which can be used to draw textures. _spriteBatch = new SpriteBatch(GraphicsDevice); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> use this.Content to load your game content here _backgroundTexture = Content.Load&lt;Texture2D&gt;("SoccerField"); _ballTexture = Content.Load&lt;Texture2D&gt;("SoccerBall"); _goalkeeperTexture = Content.Load&lt;Texture2D&gt;("Goalkeeper"); }</span></span></code> </pre><br>  Draw it in the Draw method. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ GraphicsDevice.Clear(Color.Green); <span class="hljs-comment"><span class="hljs-comment">// Begin a sprite batch _spriteBatch.Begin(); // Draw the background _spriteBatch.Draw(_backgroundTexture, _backgroundRectangle, Color.White); // Draw the ball _spriteBatch.Draw(_ballTexture, _ballRectangle, Color.White); // Draw the goalkeeper _spriteBatch.Draw(_goalkeeperTexture, _goalkeeperRectangle, Color.White); // End the sprite batch _spriteBatch.End(); base.Draw(gameTime); }</span></span></code> </pre><br>  _goalkeeperRectangle is the goalkeeper's rectangle in the window.  It is changed in the Update method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ _ballRectangle.X = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _ballPosition.X; _ballRectangle.Y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _ballPosition.Y; _goalkeeperRectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(_goalkeeperPositionX, _goalkeeperPositionY, _goalKeeperWidth, _goalKeeperHeight); base.Update(gameTime); }</code> </pre><br>  The _goalkeeperPositionY, _goalKeeperWidth and _goalKeeperHeight fields variables are updated in the ResetWindowSize method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetWindowSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ _goalkeeperPositionY = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (_screenHeight*<span class="hljs-number"><span class="hljs-number">0.12</span></span>); _goalKeeperWidth = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(_screenWidth * <span class="hljs-number"><span class="hljs-number">0.05</span></span>); _goalKeeperHeight = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(_screenWidth * <span class="hljs-number"><span class="hljs-number">0.005</span></span>); }</code> </pre><br>  The initial position of the goalkeeper is in the center of the window in front of the goal line: <br><pre> <code class="cpp hljs">_goalkeeperPositionX = (_screenWidth - _goalKeeperWidth)/<span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  The goalkeeper starts moving with the ball.  He performs harmonic oscillations from side to side: <br>  <i>X = A * sin (at + Œ¥),</i> <br>  Where A is the oscillation amplitude (goal width), t is the oscillation period, and Œ¥ is a random variable so that the player cannot predict the goalkeeper‚Äôs movement. <br>  Odds are calculated at the moment of hitting the ball: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gesture.GestureType == GestureType.Flick) { _isBallMoving = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _isBallHit = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _startMovement = gameTime.TotalGameTime; _ballVelocity = gesture.Delta * (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)TargetElapsedTime.TotalSeconds / <span class="hljs-number"><span class="hljs-number">5.0f</span></span>; var rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _aCoef = rnd.NextDouble() * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; _deltaCoef = rnd.NextDouble() * Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br>  The coefficient a is the goalkeeper‚Äôs speed, a number between 0 and 0.005, representing a speed between 0 and 0.3 pixels per second.  The delta factor is a number between 0 and œÄ / 2.  When the ball moves, the position of the goalkeeper is updated: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isBallMoving) { _ballPositionX += _ballVelocity.X; _ballPositionY += _ballVelocity.Y; _goalkeeperPositionX = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_screenWidth * <span class="hljs-number"><span class="hljs-number">0.11</span></span>) * Math.Sin(_aCoef * gameTime.TotalGameTime.TotalMilliseconds + _deltaCoef) + (_screenWidth * <span class="hljs-number"><span class="hljs-number">0.75</span></span>) / <span class="hljs-number"><span class="hljs-number">2.0</span></span> + _screenWidth * <span class="hljs-number"><span class="hljs-number">0.11</span></span>); ‚Ä¶ }</code> </pre><br>  The amplitude of movement is _screenWidth * 0.11 (gate width).  Add (_screenWidth * 0.75) / 2.0 + _screenWidth * 0.11 to the result so that the goalkeeper moves in front of the goal. <br><br><h4>  Checking whether the ball is caught and adding an account </h4>  To check whether the ball is caught or not, you need to see if the rectangles of the goalkeeper and the ball intersect.  We do this in the Update method after calculating the positions: <br><pre> <code class="cpp hljs">_ballRectangle.X = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_ballPosition.X; _ballRectangle.Y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_ballPosition.Y; _goalkeeperRectangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(_goalkeeperPositionX, _goalkeeperPositionY, _goalKeeperWidth, _goalKeeperHeight); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_goalkeeperRectangle.Intersects(_ballRectangle)) { ResetGame(); }</code> </pre><br>  ResetGame returns the game to its original state: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetGame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _ballPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_initialBallPosition.X, _initialBallPosition.Y); _goalkeeperPositionX = (_screenWidth - _goalKeeperWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; _isBallMoving = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _isBallHit = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TouchPanel.IsGestureAvailable) TouchPanel.ReadGesture(); }</code> </pre><br>  Now you need to check whether the ball hit the goal.  Do this when the ball crosses the line: <br><pre> <code class="cpp hljs">var isTimeout = timeInMovement &gt; <span class="hljs-number"><span class="hljs-number">5.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ballPosition.Y &lt; _goalLinePosition || isTimeout) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isGoal = !isTimeout &amp;&amp; (_ballPosition.X &gt; _screenWidth * <span class="hljs-number"><span class="hljs-number">0.375</span></span>) &amp;&amp; (_ballPosition.X &lt; _screenWidth * <span class="hljs-number"><span class="hljs-number">0.623</span></span>); ResetGame(); }</code> </pre><br>  To add account management, you need to add a new object to the game - a font with which numbers will be written.  A font is an XML file that describes the font: type, size, style, etc.  In the game we will use this font: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">XnaContent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:Graphics</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Xna.Framework.Content.Pipeline.Graphics"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Asset</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Graphics:FontDescription"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FontName</span></span></span><span class="hljs-tag">&gt;</span></span>Segoe UI<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FontName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Size</span></span></span><span class="hljs-tag">&gt;</span></span>24<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Size</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spacing</span></span></span><span class="hljs-tag">&gt;</span></span>0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spacing</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UseKerning</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UseKerning</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">Regular</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CharacterRegions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CharacterRegion</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Start</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Star</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">End</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">End</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CharacterRegion</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CharacterRegions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Asset</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">XnaContent</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  You must compile this font and add the resulting XNB file to the Content folder of your project: <br><pre> <code class="cpp hljs">_soccerFont = Content.Load&lt;SpriteFont&gt;(<span class="hljs-string"><span class="hljs-string">"SoccerFont"</span></span>);</code> </pre><br>  In ResetWindowSize, reset the account position: <br><pre> <code class="cpp hljs">var scoreSize = _soccerFont.MeasureString(_scoreText); _scorePosition = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_screenWidth - scoreSize.X) / <span class="hljs-number"><span class="hljs-number">2.0</span></span>);</code> </pre><br>  To store the score, we define two variables: _userScore and _computerScore.  _userScore increases when a player scores a goal, _computerScore - when a player misses, the time limit expires or the goalkeeper catches the ball. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ballPosition.Y &lt; _goalLinePosition || isTimeout) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isGoal = !isTimeout &amp;&amp; (_ballPosition.X &gt; _screenWidth * <span class="hljs-number"><span class="hljs-number">0.375</span></span>) &amp;&amp; (_ballPosition.X &lt; _screenWidth * <span class="hljs-number"><span class="hljs-number">0.623</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isGoal) _userScore++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _computerScore++; ResetGame(); } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_goalkeeperRectangle.Intersects(_ballRectangle)) { _computerScore++; ResetGame(); }</code> </pre><br>  ResetGame recreates the text of the account and sets its position: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetGame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _ballPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_initialBallPosition.X, _initialBallPosition.Y); _goalkeeperPositionX = (_screenWidth - _goalKeeperWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; _isBallMoving = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _isBallHit = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _scoreText = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"{0} x {1}"</span></span>, _userScore, _computerScore); var scoreSize = _soccerFont.MeasureString(_scoreText); _scorePosition = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_screenWidth - scoreSize.X) / <span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TouchPanel.IsGestureAvailable) TouchPanel.ReadGesture(); }</code> </pre><br>  _soccerFont.MeasureString measures the length of the counting string, this value is used to calculate the position.  The score is drawn in the Draw method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GameTime gameTime)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// Draw the score _spriteBatch.DrawString(_soccerFont, _scoreText, new Vector2(_scorePosition, _screenHeight * 0.9f), Color.White); // End the sprite batch _spriteBatch.End(); base.Draw(gameTime); }</span></span></code> </pre><br><h4>  Stadium lights </h4>  As a final touch, we‚Äôll add lights to the game to turn on the stadium lights when it‚Äôs dark inside.  Let's use for this the light sensor, which is now in many ultrabooks and transformers.  To enable the sensor, you can use the Windows API Code Pack for the Microsoft .NET Framework, but we will go another way: using the WinRT Sensor API.  Although this API is written for Windows 8, it can also be used in desktop applications. <br>  Select your project in Solution Explorer, right-click and select Unload Project.  Then press the right button again - Edit project.  In the first PropertyGroup, add the TargetPlatFormVersion tag: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Condition</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" '$(Configuration)' == '' "</span></span></span><span class="hljs-tag">&gt;</span></span>Debug<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FileAlignment</span></span></span><span class="hljs-tag">&gt;</span></span>512<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FileAlignmen</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetPlatformVersion</span></span></span><span class="hljs-tag">&gt;</span></span>8.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetPlatformVersion</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Press the right button again and select Reload Project.  Visual Studio will reload the project.  When you add a new link to the project, you will see the Windows tab in the Reference Manager, as shown in the figure. <br><img src="//habrastorage.org/files/d78/aac/244/d78aac2444854165a7e0e5136542b66e.png"><br>  Add a link to Windows in the project.  It will also require adding a reference to System.Runtime.WindowsRuntime.dll. <br>  Now let's write the detection code of the light sensor: <br><pre> <code class="cpp hljs">LightSensor light = LightSensor.GetDefault(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (light != null) {</code> </pre><br>  If the sensor is present, you will get a nonzero value that you can use to determine the lightness: <br><pre> <code class="cpp hljs">LightSensor light = LightSensor.GetDefault(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (light != null) { light.ReportInterval = <span class="hljs-number"><span class="hljs-number">0</span></span>; light.ReadingChanged += (s,e) =&gt; _lightsOn = e.Reading.IlluminanceInLux &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre><br>  If the reading is less than 10, the _lightsOn variable is True and the background will be drawn somewhat differently.  If you look at spriteBatch in the Draw method, you will see that its third parameter is color.  Previously, we always used white, but the background color does not change.  If you use any other color, the background color will change.  Choose green when the lights are off and white when on.  Let's make changes to the Draw method: <br><pre> <code class="cpp hljs">_spriteBatch.Draw(_backgroundTexture, rectangle, _lightsOn ? Color.White : Color.Green);</code> </pre><br>  Now our field will be dark green when the lights are off and light green when turned on. <br><img src="//habrastorage.org/files/1e3/f68/8c4/1e3f688c4df14ce4a88177794c561aa4.png"><br>  The development of our game is over.  Of course, it is necessary to finish something in it: to come up with an animation when the ball is hammered, to add a ball bounce from the bar and so on.  Let it be your homework. <br>  <a href="https://software.intel.com/en-us/articles/developing-games-with-monogame">Original article on Intel Developer Zone</a> </div><p>Source: <a href="https://habr.com/ru/post/227667/">https://habr.com/ru/post/227667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227655/index.html">Tools of IT departments of large companies: how to get rid of chaos and count every penny</a></li>
<li><a href="../227657/index.html">Authorities in the Irkutsk region banned from using Google</a></li>
<li><a href="../227659/index.html">How we provided communication "Sapsan" and "Allegro"</a></li>
<li><a href="../227661/index.html">The State Duma is going to impose restrictions on payment systems</a></li>
<li><a href="../227665/index.html">Sourcebuster JS: JavaScript Site Sourcing Module</a></li>
<li><a href="../227669/index.html">Mars rover Curiosity completed the main scientific mission</a></li>
<li><a href="../227671/index.html">We Are the Dwarves! - domestic tactical action on Kickstarter</a></li>
<li><a href="../227675/index.html">IPega PG-9025 Gamepad Review: Turning an Android-Smartphone into a Portable Console</a></li>
<li><a href="../227679/index.html">The fall of the last intellectual bastion: is a computer chess player really stronger than a man?</a></li>
<li><a href="../227683/index.html">Umbraco CMS MVC - own controller and beautiful url</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>