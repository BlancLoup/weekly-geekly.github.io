<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extract audio data from a wav file to UWP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we present material from our long-time partners, the Music Paradise company, who, as you remember, have already shared with Habr the secrets of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extract audio data from a wav file to UWP</h1><div class="post__text post__text-html js-mediator-article">  Today we present material from our long-time partners, the Music Paradise company, who, as you remember, have already shared with Habr the secrets of creating music applications in our joint article ‚Äú <a href="https://habrahabr.ru/company/everydaytools/blog/319290/">Implementing social services in a non-game application</a> ‚Äù.  This time, specialists from the team will talk about the specifics of implementing the basic functions of the Audio Editor utility, originally written for <a href="http://go.everydaytools.mobi/9AICaU">iOS</a> and <a href="http://go.everydaytools.mobi/ysPxlb">Mac</a> devices, on a new platform - <a href="http://go.everydaytools.mobi/dfyFaN">Windows</a> - and about the method they used in the adaptation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/921/8a3/bd1/9218a3bd178e4ac38dba994dc657271f.png"></div><br><br>  ‚ÄúIn this article, we will look at one of the most accessible ways to get audio data from a file.  Extracting audio data is a cornerstone for all developers who take the first steps in working with sound, but attention is paid to it surprisingly little.  The problem is felt especially acutely when trying to find ready-made solutions or instructions for UWP on the Internet: in most cases you do not get an answer at all, or you have to be content with outdated solutions.  Meanwhile, when working with sound, data extraction has a meaningful meaning, giving the developer the opportunity to edit data: copy, add, modify, by applying effects, visualize them on the user's screen.  It is about visualization today that will be discussed.  Despite the existence of special libraries for working with audio data in the NuGet gallery, we will build the application logic on self-processing bytes of the audio file.  Thus, in the process we will learn more about the structure of the wav file and make sure in practice that working with audio data is not that difficult. <br><a name="habracut"></a><br>  So, to achieve the goal, namely to build a graphical display of the audio wave, we first need to extract the data.  The process will be described on the example of a wav file, since it is one of the most convenient audio formats for work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, we all understand that the world of digital audio is too large to be able to reduce everything to work with a single format.  Therefore, we will immediately stipulate an additional step: in case we got a file of any other format, we first of all convert it to wav.  Do not worry, this process usually does not take a lot of time from the device. <br><br>  Implement the simplest interface by adding two buttons to MainPage.xaml: <br><br><pre><code class="cpp hljs">&lt;StackPanel HorizontalAlignment=<span class="hljs-string"><span class="hljs-string">"Center"</span></span> VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Center"</span></span>&gt; &lt;Button Width=<span class="hljs-string"><span class="hljs-string">"250"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"50"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Choose Audio File"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"ChooseFile_Click"</span></span> Margin=<span class="hljs-string"><span class="hljs-string">"0,10,0,10"</span></span>/&gt; &lt;Button Width=<span class="hljs-string"><span class="hljs-string">"250"</span></span> Height=<span class="hljs-string"><span class="hljs-string">"50"</span></span> Background=<span class="hljs-string"><span class="hljs-string">"Green"</span></span> Content=<span class="hljs-string"><span class="hljs-string">"Build And Save Image File"</span></span> Click=<span class="hljs-string"><span class="hljs-string">"BuildAndSaveImageFile_Click"</span></span> Margin=<span class="hljs-string"><span class="hljs-string">"0,10,0,10"</span></span>/&gt; &lt;/StackPanel&gt;</code> </pre> <br>  We describe the algorithm that will be performed by clicking on the button ‚ÄúChoose Audio File‚Äù.  To do this, add the following lines to MainPage.xaml.cs: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> StorageFile currentFile; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PlottingGraphImg imgFile; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChooseFile_Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object sender, RoutedEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ var picker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Windows.Storage.Pickers.FileOpenPicker(); picker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.MusicLibrary; picker.FileTypeFilter.Add(<span class="hljs-string"><span class="hljs-string">".mp4"</span></span>); picker.FileTypeFilter.Add(<span class="hljs-string"><span class="hljs-string">".mp3"</span></span>); picker.FileTypeFilter.Add(<span class="hljs-string"><span class="hljs-string">".wav"</span></span>); StorageFile file = await picker.PickSingleFileAsync(); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToWaveFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToWaveFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageFile sourceFile)</span></span></span><span class="hljs-function"> </span></span>{ MediaTranscoder transcoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MediaTranscoder(); MediaEncodingProfile profile = MediaEncodingProfile.CreateWav(AudioEncodingQuality.Medium); CancellationTokenSource cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-comment"><span class="hljs-comment">//Create temporary file in temporary folder string fileName = String.Format("TempFile_{0}.wav", Guid.NewGuid()); StorageFile temporaryFile = await ApplicationData.Current.TemporaryFolder.CreateFileAsync(fileName); currentFile = temporaryFile; if (sourceFile == null || temporaryFile == null) { return; } try { var preparedTranscodeResult = await transcoder.PrepareFileTranscodeAsync(sourceFile, temporaryFile, profile); if (preparedTranscodeResult.CanTranscode) { var progress = new Progress&lt;double&gt;((percent) =&gt; { Debug.WriteLine("Converting file: " + percent + "%"); }); await preparedTranscodeResult.TranscodeAsync().AsTask(cts.Token, progress); } else { Debug.WriteLine("Error: Convert fail"); } } catch { Debug.WriteLine("Error: Exception in ConvertToWaveFile"); } }</span></span></code> </pre> <br>  <i>Note</i> : this method can also be used for video formats, which is also very useful sometimes. <br><br>  Now that the user wav-file has become available, it is necessary to get audio data from it, for which we started all this.  To do this, you have to understand the structure of the file.  We don‚Äôt see any point in going into theory much - there‚Äôs more than enough information on the Internet, you can always get the information you are interested in there.  We limit ourselves to defining the general structure of the file in order to clarify the logic of further implementation. <br><br>  So, the structure of an uncompressed audio file in Pulse Code Modulation (PCM) format is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/802/e78/c4f/802e78c4ff1b4cc6b439aef5429e19f0.png"></div><br>  We now turn to the actual algorithm for obtaining audio data.  In work we will rely on the <a href="https://msdn.microsoft.com/en-us/library/ff827591.aspx">following resource</a> . <br><br>  We describe a class with the symbolic name "WavFile": <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WavFile</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> PathAudioFile { get; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ticksInSecond = <span class="hljs-number"><span class="hljs-number">10000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TimeSpan duration; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TimeSpan Duration { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> duration; } } <span class="hljs-meta"><span class="hljs-meta">#region AudioData private List</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;float&gt; floatAudioBuffer = new List&lt;float&gt;(); #endregion public WavFile(string _path) { PathAudioFile = _path; ReadWavFile(_path); } public float[] GetFloatBuffer() { return floatAudioBuffer.ToArray(); } private void ReadWavFile(string filename) { try { using (FileStream fileStream = File.Open(filename, FileMode.Open)) { BinaryReader reader = new BinaryReader(fileStream); // RIFF int chunkID = reader.ReadInt32(); int fileSize = reader.ReadInt32(); int riffType = reader.ReadInt32(); // Format int fmtID; long _position = reader.BaseStream.Position; while (_position != reader.BaseStream.Length - 1) { reader.BaseStream.Position = _position; int _fmtId = reader.ReadInt32(); if (_fmtId == 544501094) { fmtID = _fmtId; break; } _position++; } int fmtSize = reader.ReadInt32(); int fmtCode = reader.ReadInt16(); int channels = reader.ReadInt16(); int sampleRate = reader.ReadInt32(); int byteRate = reader.ReadInt32(); int fmtBlockAlign = reader.ReadInt16(); int bitDepth = reader.ReadInt16(); if (fmtSize == 18) { int fmtExtraSize = reader.ReadInt16(); reader.ReadBytes(fmtExtraSize); } int dataID = reader.ReadInt32(); int dataSize = reader.ReadInt32(); byte[] byteArray = reader.ReadBytes(dataSize); int bytesInSample = bitDepth / 8; int sampleAmount = dataSize / bytesInSample; float[] tempArray = null; switch (bitDepth) { case 16: Int16[] int16Array = new Int16[sampleAmount]; System.Buffer.BlockCopy(byteArray, 0, int16Array, 0, dataSize); IEnumerable&lt;float&gt; tempInt16 = from i in int16Array select i / (float)Int16.MaxValue; tempArray = tempInt16.ToArray(); break; default: return; } floatAudioBuffer.AddRange(tempArray); duration = DeterminateDurationTrack(channels, sampleRate); } } catch { Debug.WriteLine("File error"); return; } } private TimeSpan DeterminateDurationTrack(int channels, int sampleRate) { long _duration = (long)(((double)floatAudioBuffer.Count / sampleRate / channels) * ticksInSecond); return TimeSpan.FromTicks(_duration); } }</span></span></span></span></code> </pre><br>  <i>Note</i> : this method will give us the opportunity not only to visualize audio data, but also to edit them.  By the way, the reverse process of saving data is easy to organize; to do this, simply use the FileStream class again and write the data to the file in sequence. <br><br>  <i>Note</i> : you most likely have already noticed that when describing the algorithm, we retreated from the above described structure of the wav file.  This is due to the fact that the file obtained by converting has a slightly different structure.  In particular, a section is added that is of no great importance to us ‚Äî it stores id, size, and format information, followed by a sequence of zero bytes.  The skipping of the unnecessary section occurs by looping through the bytes in the loop and comparing them with the value 544501094 (this is the necessary value of the Subchunk1Id field, from which the Format section begins).  Such a search is necessary for the reason that the above-mentioned structure is approximate, but not mandatory, and is sometimes rejected from it. <br><br>  Finally, having received the data, we can proceed to the final step - the construction of the schedule.  Here there are several ways, we give two of the most common: <br><br><ol><li>  Image building using geometric shapes. </li><li>  Create bitmaps. </li></ol><br>  Let us dwell on them in more detail.  Regardless of resource-intensiveness, the first way to build an image is popular on the Web when demonstrating certain examples of working with audio tracks.  It is probably not bad for building small graphs, but it becomes irrational when it comes to displaying the image of a wave of the entire audio track as a whole.  Therefore, this option does not suit us. <br><br>  The second method is less resource intensive and involves the use of unsafe code.  According to the result of the work, we will get an image that we can use in our application or, for example, save it to a hard disk for further use. <br><br>  Instructions on how to work with a bitmap in the UWP are available <a href="https://docs.microsoft.com/ru-ru/windows/uwp/audio-video-camera/imaging">here</a> .  Describing our logic of building an image of an audio file, we will largely rely on this material. <br><br>  Add to the project the structure and class described above: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicalWavePlot</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> peakValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GraphicalWavePlot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> peakValue )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.peakValue = peakValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckArea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightImg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Oh = heightImg / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y0 = Oh - Math.Abs(minValue) * Oh / peakValue; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y1 = Oh + maxValue * Oh / peakValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (pos &gt; y0 &amp;&amp; pos &lt; y1); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlottingGraphImg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;GraphicalWavePlot&gt; waveSamples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GraphicalWavePlot&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SoftwareBitmap softwareBitmap; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WavFile wavFile; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color backgroundColor = Color.FromArgb(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> backgroundColor; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { backgroundColor = value; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color foregroundColor = Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color ForegroundColor { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foregroundColor; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { foregroundColor = value; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> image_width; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ImageWidth { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image_width; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { image_width = value; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> image_height; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ImageHeight { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image_height; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { image_height = value; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlottingGraphImg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WavFile _wavFile, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _image_width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _image_height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wavFile = _wavFile; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image_width = _image_width; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image_height = _image_height; BuildImage(); CreateGraphicFile(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xPos = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval = <span class="hljs-number"><span class="hljs-number">1</span></span>; var yScale = ImageHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] readBuffer = wavFile.GetFloatBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samplesPerPixel = readBuffer.Length / ImageWidth; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> negativeLimit = readBuffer.Take(readBuffer.Length).Min(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> positiveLimit = readBuffer.Take(readBuffer.Length).Max(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> peakValue = (positiveLimit &gt; negativeLimit) ? (positiveLimit) : (negativeLimit); peakValue *= <span class="hljs-number"><span class="hljs-number">1.2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; readBuffer.Length; i += samplesPerPixel, xPos += interval) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] partBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[samplesPerPixel]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthPartBuffer = ((i + samplesPerPixel) &gt; readBuffer.Length) ? (readBuffer.Length - i) : (samplesPerPixel); Array.Copy(readBuffer, i, partBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, lengthPartBuffer); var min = partBuffer.Take(samplesPerPixel).Min(); var max = partBuffer.Take(samplesPerPixel).Max(); waveSamples.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphicalWavePlot(minValue: min, maxValue: max, peakValue: peakValue)); } } [ComImport] [Guid(<span class="hljs-string"><span class="hljs-string">"5B0D3235-4DBA-4D44-865E-8F1D0E4FD04D"</span></span>)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] unsafe interface IMemoryBufferByteAccess { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out byte* buffer, out uint capacity)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> unsafe </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateGraphicFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ softwareBitmap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SoftwareBitmap(BitmapPixelFormat.Bgra8, ImageWidth, ImageHeight); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BitmapBuffer buffer = softwareBitmap.LockBuffer(BitmapBufferAccessMode.Write)) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var reference = buffer.CreateReference()) { byte* dataInBytes; uint capacity; ((IMemoryBufferByteAccess)reference).GetBuffer(out dataInBytes, out capacity); <span class="hljs-comment"><span class="hljs-comment">// Fill-in the BGRA plane BitmapPlaneDescription bufferLayout = buffer.GetPlaneDescription(0); for (int i = 0; i &lt; bufferLayout.Width; i++) { for (int j = 0; j &lt; bufferLayout.Height; j++) { Color tempColor = waveSamples[i].CheckArea(j, ImageHeight) ? ForegroundColor : BackgroundColor; //Blue dataInBytes[bufferLayout.StartIndex + bufferLayout.Stride * j + 4 * i + 0] = (byte)tempColor.B; //Green dataInBytes[bufferLayout.StartIndex + bufferLayout.Stride * j + 4 * i + 1] = (byte)tempColor.G; //Red dataInBytes[bufferLayout.StartIndex + bufferLayout.Stride * j + 4 * i + 2] = (byte)tempColor.R; //Alpha dataInBytes[bufferLayout.StartIndex + bufferLayout.Stride * j + 4 * i + 3] = (byte)tempColor.A; } } } } } public async Task SaveGraphicFile(StorageFile outputFile) { using (IRandomAccessStream stream = await outputFile.OpenAsync(FileAccessMode.ReadWrite)) { BitmapEncoder encoder = await BitmapEncoder.CreateAsync(BitmapEncoder.JpegEncoderId, stream); encoder.SetSoftwareBitmap(softwareBitmap); encoder.BitmapTransform.InterpolationMode = BitmapInterpolationMode.Fant; encoder.IsThumbnailGenerated = true; try { await encoder.FlushAsync(); } catch (Exception err) { switch (err.HResult) { case unchecked((int)0x88982F81): //WINCODEC_ERR_UNSUPPORTEDOPERATION // If the encoder does not support writing a thumbnail, then try again // but disable thumbnail generation. encoder.IsThumbnailGenerated = false; break; default: throw err; } } if (encoder.IsThumbnailGenerated == false) { await encoder.FlushAsync(); } } } }</span></span></code> </pre> <br>  <i>Note</i> : Do not forget to allow the use of unsafe code in the project properties (right-click on the project, select Properties in the console menu that appears, then activate the Build tab in the window that opens and tick the Allow unsafe code field, see below). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/97a/c88/a9a/97ac88a9abd94d96b06d04af92fd6966.png" width="700"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f5d/e3b/90d/f5de3b90d10944fea0c692c8322152a1.png" width="700"></div><br>  So, we have considered the scheme of receiving audio data and plotting.  All that's left is to call it from the MainPage class.  To do this, we need the ‚ÄúBuild And Save Image File‚Äù button, after clicking on which, the algorithm we work will be launched.  To implement it, to the lines entered in MainPage.xaml.cs earlier, add the method presented above: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildAndSaveImageFile_Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object sender, RoutedEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ WavFile wavFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WavFile(currentFile.Path.ToString()); imgFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlottingGraphImg(wavFile, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); FileSavePicker fileSavePicker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSavePicker(); fileSavePicker.SuggestedStartLocation = PickerLocationId.PicturesLibrary; fileSavePicker.FileTypeChoices.Add(<span class="hljs-string"><span class="hljs-string">"JPEG files"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() { <span class="hljs-string"><span class="hljs-string">".jpg"</span></span> }); fileSavePicker.SuggestedFileName = <span class="hljs-string"><span class="hljs-string">"image"</span></span>; var outputFile = await fileSavePicker.PickSaveFileAsync(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputFile == null) { <span class="hljs-comment"><span class="hljs-comment">// The user cancelled the picking operation return; } await imgFile.SaveGraphicFile(outputFile); }</span></span></code> </pre> <br>  Check the project for errors and not added libraries, and then run it.  According to the result of the work, we get this image for the selected audio file. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c9e/a8b/b38/c9ea8bb380314f72b86f71832f8a93d2.jpg"></div></div><p>Source: <a href="https://habr.com/ru/post/325828/">https://habr.com/ru/post/325828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325818/index.html">Quick Start: Overview of Core Deep Learning Framework</a></li>
<li><a href="../325820/index.html">Interview with Global Marketing Programs Manager at JetBrains by Michael Vinck</a></li>
<li><a href="../325822/index.html">Sandbox technology. Check Point SandBlast. Part 2</a></li>
<li><a href="../325824/index.html">Management of risks. Part 1</a></li>
<li><a href="../325826/index.html">Where is the "Lock Button"?</a></li>
<li><a href="../325830/index.html">What is Apache Ignite / GridGain for, using the example .NET & C #</a></li>
<li><a href="../325836/index.html">Kotlin + Rx2: A reactive and functional approach to the development of mobile applications</a></li>
<li><a href="../325838/index.html">Organization of adaptive layout in BEM with SCSS</a></li>
<li><a href="../325840/index.html">Ways of de-anonymization of community leaders and Vkontakte applications</a></li>
<li><a href="../325842/index.html">Analysis of level schemes for improving multiplayer shooters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>