<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clojure - transducers, reducers and other dregs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, transducers have received a certain fame - a new feature from the not yet released Clojure 1.7. At the time of this writing, Slojure 1.7-alp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clojure - transducers, reducers and other dregs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ad6/d73/4fe/ad6d734fe68142f39603c9688b28f972.jpg" align="left">  Recently, <a href="http://clojure.org/transducers">transducers</a> have received a certain fame - a new feature from the not yet released Clojure 1.7.  At the time of this writing, Slojure 1.7-alpha5 is relevant, but a fair amount of transducer ports in various languages ‚Äã‚Äãhave already appeared: <a href="https://github.com/abingham/python-transducers">Python</a> , <a href="https://github.com/cognitect-labs/transducers-ruby">Ruby</a> , <a href="">JavaScript</a> , <a href="https://github.com/mtdowling/transducers.php">PHP</a> , <a href="https://github.com/cognitect-labs/transducers-java">Java</a> , <a href="https://github.com/kirkshoop/transducer">C ++</a> , <a href="">Lua</a> , <a href="https://github.com/sfwc/erlang-transducers">Erlang</a> .  And ... it is a little discouraging.  After all, for a long time (even in Clojure 1.5), the <a href="http://clojure.org/reducers">reducers</a> library was <a href="http://clojure.org/reducers">added</a> . So, nobody specifically said about the reduers, did not port anything anywhere, although they seem to do similar things ... Or not? <br><br>  Let's see why we needed all these reducers &amp; transducers in Clojure (do we really need them?), How they work, how to use them ... And finally find out if it is time to throw reducers into a landfill. <a name="habracut"></a><br><br>  It would be wrong to describe concepts arising in Clojure outside the context of this language.  Therefore, there will be a lot of Clojure listings.  But there will be no matan.  In general, the initial knowledge of Clojure is relevant (especially the concept of <a href="http://habrahabr.ru/post/160235/">sequences</a> ), but to know Haskell is not necessary.  I also warn you in advance that all the listed listings for standard functions are in fact greatly changed, sometimes even ‚Äúslightly‚Äù broken.  All for the benefit of simplification.  Oh yeah, that <a href="https://www.youtube.com/watch%3Fv%3D6mTbuzafcII">burrito</a> in the picture. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Roll up ... </h2><br>  So, Clojure is a functional language, which means an <a href="https://clojuredocs.org/clojure.core/doseq">ordinary</a> <a href="https://clojuredocs.org/clojure.core/while">imperative</a> <a href="https://clojuredocs.org/clojure.core/recur">cycle is</a> not good. <br>  Well, okay, we didn‚Äôt really want to - there is a functionally <a href="https://clojuredocs.org/clojure.core/reduce">reduce</a> ! <br><br><pre><code class="plaintext hljs">(defn my-reduce ([rf coll] ;;     (if-let [s (seq coll)] (my-reduce rf (first s) (next s)) (rf))) ([rf acc coll] (if-let [[x &amp; xs] (seq coll)] (recur rf (rf acc x) xs) acc)))</code> </pre> <br>  In fact, <code>reduce</code> , of course, is implemented <a href="">somewhat differently</a> , but for us this is not important now, we forget.  The function <code>rf</code> (let's call its reduction function) here takes two arguments: the first is a kind of ‚Äúsliding state‚Äù;  the second is an element from the <code>coll</code> .  If the initial state is not specified, then <code>(first coll)</code> or <code>(rf)</code> .  Run across the entire <code>coll</code> collection, for each element we call <code>rf</code> , while ‚Äúdragging‚Äù the state <code>acc</code> .  When the items have run out, just return the <code>acc</code> . <br><br>  A small example.  Suppose we have a list of strings, we want to calculate their total length. <br>  Here is the imperative code with the loop: <br><br><pre> <code class="plaintext hljs">(defn length-of-strings [strings] (with-local-vars [acc 0] ;; -,  Clojure   ! (doseq [c strings] (var-set acc (+ @acc (count c)))) ;;    @acc))</code> </pre><br>  The loop state is a simple counter <code>acc</code> (number).  At each iteration, we set it equal <code>(+ @acc (count c))</code> . <br>  And now one more time, only through <code>reduce</code> : <br><br><pre> <code class="plaintext hljs">(defn length-of-strings [coll] (my-reduce (fn ([acc c] (+ acc (count c)))) ;;  - 0 ;;   coll))</code> </pre><br>  If you temporarily forget about laziness, you can implement many primitive operations, like <code>map</code> or <code>filter</code> . <br><br><pre> <code class="plaintext hljs">(defn my-map [f coll] (my-reduce (fn [acc c] (conj acc (fc))) [] coll)) (defn my-filter [p coll] (my-reduce (fn [acc c] (if (pc) (conj acc c) acc)) [] coll))</code> </pre><br>  For the implementation of <code>take</code> reduced variant will no longer fit - the loop always runs through the entire sequence (this is not Haskell, where everything is lazy). <br><br>  In order to overcome this drawback, version 1.5 added a special <s>crutch</s> marker <a href="">reduced</a> and its corresponding predicate <code>reduced?</code>  .  At the same time rewrote <code>reduce</code> , getting something like this: <br><br><pre> <code class="plaintext hljs">(defn my-reduce ([rf coll] (if-let [s (seq coll)] (my-reduce rf (first s) (next s)) (rf))) ([rf acc coll] (if-let [[x &amp; xs] (seq coll)] (let [ret (rf acc x)] (if (reduced? ret) @ret (recur rf ret xs))) acc)))</code> </pre><br>  As soon as the reduction function returns <code>(reduced ...)</code> , the cycle ends and the value of <code>@ret</code> . <br><br><pre> <code class="plaintext hljs">(defn take-r [n coll] (my-reduce (fn [[n1 acc] c] (if (pos? n1) [(dec n1) (conj acc c)] (reduced acc))) [n []] coll)) ;;    ! (take-r 5 (range)) ;; =&gt; [0 1 2 3 4]</code> </pre><br>  It is impossible not to recall the wonderful function of <a href="https://clojuredocs.org/clojure.core/reductions">reductions</a> .  In essence, this is an analogue of <code>reduce</code> , only returns a <i>lazy</i> list of all intermediate values ‚Äã‚Äãof <code>acc</code> , and not just the last.  It is very convenient to use when debugging.  We write the step of the algorithm in the form of a function, run <code>reduce</code> on the collection with input data.  If suddenly something is wrong, replace <code>reduce</code> with <code>reductions</code> , run it in the REPL and get all intermediate steps.  With cycles it will not be so easy - debugging crutches will have to be crammed, which is not very convenient. <br><br>  Sometimes <code>reductions</code> useful in and of themselves, which factorials are there to calculate: <br><br><pre> <code class="plaintext hljs">;; =&gt; **   (def factorials (reductions *' (cons 1 (map inc (range))))) (nth factorials 20) ;; =&gt; 2432902008176640000</code> </pre><br>  Clojure uses <a href="http://clojure.org/sequences">sequences</a> to traverse collections.  If we decide to run through a vector, hash table, or simple iterator, then a fair amount of temporary objects will be created on the heap. <br><br>  The obvious optimization that asks in such a situation is to implement a specialized variant of <code>reduce</code> for those collections for which this makes sense.  Well, if the collection does not lend itself to such optimization, then use the standard implementation, similar to the one shown at the beginning of the article.  For this there is a special protocol <a href="">clojure.core.protocol / CollReduce</a> .  When a collection object supports it, this implementation will be used inside <code>clojure.core/reduce</code> .  Therefore, <code>reduce</code> in Clojure is usually faster than a similar <code>doseq</code> loop. <br><br><h2>  Transformers </h2><br>  A transformer is a function that takes a single reduction function and returns a new one. <br>  For example, here's a "increase by 1" transformer: <br><br><pre> <code class="plaintext hljs">(defn inc-t [rf] (fn [acc c] (rf acc (inc c)))) ;;     (reduce + 0 (map inc [1 2 3 4])) ;; =&gt; 14 (reduce (inc-t +) 0 [1 2 3 4]) ;; =&gt; 14</code> </pre><br>  You can somewhat generalize this case by allowing instead of <code>inc</code> to specify any function: <br><br><pre> <code class="plaintext hljs">(defn map-t [f] (fn [rf] (fn [acc c] (rf acc (fc))))) (def inc-t (map-t inc)) (def dec-t (map-t dec)) ;; ... (reduce (inc-t +) 0 [1 2 3 4]) ;; =&gt; 14</code> </pre><br>  And here, for example, the ‚Äúfilter‚Äù transformer: <br><br><pre> <code class="plaintext hljs">(defn filter-t [pred] (fn [rf] (fn [acc c] (if (pred c) (rf acc c) acc)))) (def odd?-t (filter-t odd?)) (def even?-t (filter-t even?)) ;;  (reduce (even?-t *) 1 [1 2 3 4]) ;; =&gt; 8</code> </pre><br>  Is it possible to combine several transformers?  Of course! <br><br><pre> <code class="plaintext hljs">(defn odd?-inc-t [rf] (odd?-t (inc-t rf))) ;; ..    (def odd?-inc-t (comp (filter-t odd?) (map-t inc))) ;;   .. (def odd?-inc-t (comp (fn [rf] (fn [acc c] (if (odd? c) (rf acc c) acc))) (fn [rf] (fn [acc c] (rf acc (inc c)))))) ;;      (defn odd?-inc-t [rf] (fn [acc c] (if (odd? c) (rf acc (inc c)) acc))) ;;   (reduce * 1 (-&gt;&gt; [1 2 3 4 5] (filter odd?) (map inc))) ;; =&gt; 48 (reduce (odd?-inc-t *) 1 [1 2 3 4 5]) ;; ==&gt; 48</code> </pre><br>  It is worth noting that the transformers are in the "reverse" order.  If we want the collection elements to be processed by a transformer <code>A</code> before they fall into <code>B</code> , then we need to glue them together as <code>(comp AB)</code> .  And now focus: <br><br><pre> <code class="plaintext hljs">(def cc (vec (range 1000000))) (time (reduce + 0 (-&gt;&gt; cc (filter odd?) (map inc)))) ;; "Elapsed time: 171.390143 msecs" ;; =&gt; 250000500000 (time (reduce ((comp (filter-t odd?) (map-t inc)) +) 0 cc)) ;; "Elapsed time: 93.246015 msecs" ;; =&gt; 250000500000</code> </pre><br>  Here's how, a tangible increase in speed on level ground!  All, of course, depends on many details and various nuances, so in reality, the gain may be different.  In general, I want to say that you should not take this piece of code as a benchmark. <br><br>  But in general, the results are not surprising.  When using <code>map</code> and <code>filter</code> , 2 intermediate sequences are created.  We run through the source vector, create a temporary list of filtered values.  Then we run through this list and build another one, but with larger elements.  And, finally, we run over it already, summing up the values. <br><br>  On the other hand, the version with transformers does not create any temporary collections.  Instead, <code>odd?</code> immediately applied over the source elements <code>odd?</code>  and <code>inc</code> . <br><br><h2>  Where are my reducers? </h2><br>  And everything was fine until version 1.5 introduced the new standard library <code>clojure.core.reducers</code> .  Exactly, a <a href="">separate library</a> will have to be explicitly imported.  It also announced its own versions of <code>map</code> , <code>filter</code> , <code>take-while</code> , and others.  And, of course, they are not compatible with regular versions of <code>clojure.core</code> .  Therefore, it is better to write <code>(require '[clojure.core.reducers :as r])</code> instead of simple <code>(use 'clojure.core.reducers)</code> . <br><br>  So, what is a reducer?  Briefly and stupidly: a reducer is any object by which you can redraw.  Any collection in terms of <code>clojure.core.reducers</code> is a reducer.  Hash table - reducer.  And <code>java.lang.String</code> reducer.  Well, <code>nil</code> , of course, <a href="">too</a> .  Let's see the definition: <br><br><pre> <code class="plaintext hljs">(defn reducer [coll xf] ;; `xf` -   (reify clojure.core.protocols/CollReduce (coll-reduce [this f1] (let [f2 (xf f1)] (clojure.core.protocols/coll-reduce coll f2 (f2)))) (coll-reduce [this f1 init] (let [f2 (xf f1)] (clojure.core.protocols/coll-reduce coll f2 init)))))</code> </pre><br>  Here the collection <code>coll</code> is taken, and a new one is returned, on which you can run <code>reduce</code> , and only that.  Neither add an element, nor delete, nor even walk through the elements.  But before each launch of <code>reduce</code> reduction function will be passed through the transformer <code>xf</code> . <br><br><pre> <code class="plaintext hljs">(def nums [1 2 3 4 5]) (def nums+1 (reducer nums inc-t)) (reduce + 0 nums) ;; =&gt; 15 (reduce + 0 nums+1) ;; =&gt; 20</code> </pre><br>  As already mentioned, the reducers library has its own <code>map</code> , <code>filter</code> , <code>take-while</code> and similar variants.  All of them accept a reducer and return a new one to which the corresponding transformer is ‚Äúattached‚Äù. <br><br>  So it could look like <code>clojure.core.reducers/map</code> (it, of course, looks very <a href="">different</a> ): <br><br><pre> <code class="plaintext hljs">(def map-r [f coll] (reducer coll (map-t f)))</code> </pre><br>  And now a few examples of how all this stuff can be used: <br><br><pre> <code class="plaintext hljs">(require '[clojure.core.reducers :as r]) (def nums [1 2 3 4 5 6 7 8]) (type (map inc nums)) ;; =&gt; clojure.lang.LazySeq (reduce conj [] (map inc nums)) ;; =&gt; [2 3 4 5 6 7 8 9] (type (r/map inc nums)) ;; =&gt; clojure.core.reducers$folder$reify__1234 ;; -  sequence (reduce conj [] (r/map inc nums)) ;; =&gt; [2 3 4 5 6 7 8 9] ;;      (reduce conj [] (r/filter odd? nums)) ;; =&gt; [1 3 5 7] (reduce + 0 (-&gt;&gt; nums (r/map inc) (r/map inc))) ;; =&gt; 52 ;; ~~ (+ 0 (inc (inc 1)) (inc (inc 2)) ...) (reduce + 0 (-&gt;&gt; nums (r/filter odd?) (r/map inc))) ;; =&gt; 20 ;; ~~ (+ 0 (inc 1) (inc 3) ...)</code> </pre><br><h2>  Parallel </h2><br>  To be honest, ‚Äúreducers‚Äù was called so in vain.  "Folders" would be more correct.  Indeed, in addition to the <code>CollReduce</code> protocol (which appeared long before reducers), another, more important, <code>CollFold</code> protocol is declared in the library: <br><br><pre> <code class="plaintext hljs">(defprotocol CollFold (coll-fold [coll n combinef reducef]))</code> </pre><br>  In principle, it is very similar, only the reduct functions are now two, and the incomprehensible argument <code>n</code> has also been added.  Idea: for some collections you can run in several streams.  Briefly: we divide it into blocks of about <code>n</code> elements in size, each piece is collapsed with <code>#(reduce reducef (combinef) %)</code> , then the list of results (one per block) is collapsed again, but with <code>#(reduce combinef %)</code> . <br><br>  A reducer that can collapse itself in parallel is called a <a href="">folder</a> . <br>  Only 2 standard collections support the <code>CollFold</code> protocol - vectors and hash tables. <br><br><pre> <code class="plaintext hljs">(def v (vec (range 10000000))) ;; ,  1  (time (reduce + v)) ;; "Elapsed time: 648.897616 msecs" ;; =&gt; 49999995000000 ;;    (time (r/coll-fold v 512 + +)) ;; "Elapsed time: 187.414147 msecs" ;; =&gt; 49999995000000</code> </pre><br>  All standard reducers, for which it makes sense, implement <code>CollFold</code> .  This, for example, <code>r/map</code> , <code>r/filter</code> , <code>r/mapcat</code> , <code>r/flatten</code> .  On the other hand, <code>r/take</code> , <code>r/take-while</code> , <code>r/drop</code> do not support parallelization.  The above is the implementation of <code>r/map</code> .  Here is its updated version: <br><br><pre> <code class="plaintext hljs">(def map-r [f coll] ;;   `reducer`  `folder` (folder coll (map-t f)))</code> </pre><br>  There is no need to use <code>coll-fold</code> directly - there is a wrapper for everyday needs.  It sets the default value for <code>n</code> (block size) to 512. In general, the hint is clear - reducers are clearly intended for large collections (&gt; 1K items).  And again: do not use <code>coll-fold</code> directly, call <code>fold</code> . <br><br>  Ah, there is still <a href="">foldcat</a> .  A kind of accelerated (due to multithreading) option <code>#(reduce conj [] %)</code> .  This function <a href="">returns clojure.core.reducers.Cat</a> objects that implement <code>Counted</code> , <code>Sequable</code> , and <code>CollFold</code> . <br><br><pre> <code class="plaintext hljs">(r/map inc [1 2 3]) ;; =&gt; #&lt;reducers$folder$reify__..... ;;   ** ? ;; ..     `reduce`  (reduce conj [] (r/map inc [1 2 3])) ;; =&gt; [2 3 4] ;;    ... (def v (vec (range 1000000))) (time (count (reduce conj [] (r/map inc v)))) ;; "Elapsed time: 90.124397 msecs" ;; =&gt; 1000000 ;; -  ,    `foldcat` (time (count (r/foldcat (r/map inc v)))) ;; "Elapsed time: 25.054988 msecs" ;; =&gt; 1000000 (time (count (r/foldcat (r/map inc (r/foldcat (r/map inc v)))))) ;; "Elapsed time: 32.054988 msecs" ;; =&gt; 1000000 ;;  `foldcat`, ,  foldable (, ) (satisfies? r/CollFold (r/foldcat [])) ;; =&gt; true</code> </pre><br><h2>  On the scene rush ... </h2><br>  Unlike viewers, transducers are no longer a separate library.  It is rather a concept (read the idea) that will be integrated directly into the <code>clojure.core</code> module.  We are waiting for this good in version 1.7 (quite a bit left). <br><br>  Briefly: transducers are the same transformers, only <s><a href="https://github.com/clojure/core.async/commit/81fc946a4d80dd57f641282831e72ae0d829f1b0">after re-branding</a></s> otherwise named.  Well, almost: the reduct functions can now take not only 0 and 2 arguments, but also 1. And the transducer, respectively, is a function from 0-1-2-ary reduct function to 0-1-2-ary new . <br><br><pre> <code class="plaintext hljs">(def typical-transducer (fn [rf] (fn ([] ...) ;;    ([acc] ...) ;; ... ([acc c] ...))) ;; ,    ,    ;;   `map-t`,  33%   (defn map-t-improved [f] (fn [rf] (fn ([] (rf)) ;;   ([acc] (rf acc)) ;;   ([acc c] (rf acc (fc)))))) ;;  `c`  `(fc)`</code> </pre><br>  The 0-ary reduct function, as before, can be called if an initial element is needed.  Option 2-ary is used for the reduction itself.  And the 1-ary variant is called at the very end of the whole work (at the end of <code>reduce</code> ).  It is needed in those cases when you need to "add" new elements for the latter. <br><br>  Example: a <a href="">dedupe</a> transducer skipping replays from the collection: <br><br><pre> <code class="plaintext hljs">(defn my-dedupe [] (fn [rf] ;; , ! (let [prev (atom ::none)] (fn ;;   - ([] (rf)) ([acc] (rf acc)) ([acc c] (let [p @prev] (reset! prev c) (if (= pc) acc (rf acc c)))))))) (def rf ((my-dedupe) +)) (reduce rf 0 [1 1, 2 2, 3, 1 1]) ;; =&gt; 7 (reduce rf 0 [1 1, 2 2, 3, 1 1]) ;; =&gt; 6 ;; ... `rf`  ,    2 </code> </pre><br>  Thin moment - our transducer returns a new reduct function.  Moreover, this reduct function has a mutable state and is able to do essentially 3 different things (1 each for arity).  <s>Well, just some kind of object.</s>  But at the same time, the transducer itself does not have a state, it only acts as a certain factory. <br><br>  As an example of using the 1-ary variant of the reduction function, <a href="">partition-all is given</a> .  Simplified implementation: <br><br><pre> <code class="plaintext hljs">(defn partition-all-t [n] (fn [rf] (let [buffer (java.util.ArrayList. n)] ;; ! (fn ([] (rf)) ([acc] (if (.isEmpty buffer) ;;    -   (rf acc) ;; ... (let [v (vec (.toArray buffer)) ;;     acc' (rf acc v)] ;;    2- `rf` ;;       (rf acc')))) ([acc c] (.add buffer c) (if (= n (.size buffer)) ;;    - ""  (let [v (vec (.toArray buffer))] (.clear buffer) (rf acc v)) ;;  -    acc)))))) ;;  ,   (   ,  (conj) =&gt; []) (reduce ((partition-all-t 3) conj) (range 10)) ; &gt;&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IPersistentCollection ;;  ... ;;  ,    []... (reduce ((partition-all-t 3) conj) [] (range 10)) ;; =&gt; [[0 1 2] [3 4 5] [6 7 8]] ;; ,  ...</code> </pre><br>  Hmm ... Neither the 0-ary or the 1-ary options <code>((partition-all-t 3) conj)</code> have ever been called - the usual <code>reduce</code> knows nothing about all these innovations.  It calls the 0-ary variant only if the collection is empty, 1-ary does not call at all. <br><br>  Therefore, we created a new function <code>transduce</code> .  Here it is, in contrast to the ‚Äúobsolete‚Äù <code>reduce</code> , it always calls <code>(rf)</code> , unless the initial state is explicitly specified.  And this function is guaranteed to call <code>(rf acc)</code> , and <i>exactly once</i> .  And <code>transduce</code> itself calls our transducer and hides the mutable reduct function from our eyes.  In other words, all the dirty work (in terms of side effects) is done ‚Äúunder the hood‚Äù. <br><br><pre> <code class="plaintext hljs">;;    ,      (transduce (partition-all-t 3) conj (range 10)) ;; =&gt; [[0 1 2] [3 4 5] [6 7 8] [9]] ;; ... ! ;;   ( ) (transduce (comp (filter odd?) (partition-all-t 3)) conj (range 10)) ;; =&gt; [[1 3 5] [7 9]]</code> </pre><br>  And what if to try <code>transduce</code> instead of <code>reduce</code> use? <br><br><pre> <code class="plaintext hljs">(reduce (identity -) 0 [1 2 3 4]) ;; =&gt; -10 ;; ~~ (- (- (- (- 0 1) 2) 3) 4) (transduce identity - 0 [1 2 3 4]) ;; =&gt; 10 ;;  !</code> </pre><br>  It turns out that direct replacing <code>reduce</code> with <code>transduce</code> does not work - the new requirement of the 1-ary reduct function interferes.  In our example, after the end of the calculations, <code>transduce</code> calls <code>(- acc)</code> , which changes the sign of the result to the opposite.  Complement will help <a href="">fix the</a> situation: <br><br><pre> <code class="plaintext hljs">((completing -) 3 2) ;; =&gt; 1 ((identity -) 1) ;; =&gt; -1 ((completing -) 1) ;; =&gt; 1 (transduce completing - 0 [1 2 3 4]) ;; =&gt; -10 ;;   !</code> </pre><br>  In the core of the language, there are special functions for working with <s>transformers</s> with transducers.  It is quite expected that the standard set of these most transducers was also added.  And in order not to produce a lot of new functions (there are so many of them, you will get confused in two accounts), we decided to upgrade the existing <code>map</code> , <code>filter</code> , <code>take</code> , <code>interpose</code> , <code>mapcat</code> and company: <br><br><pre> <code class="plaintext hljs">(map inc [1 2 3]) ;; =&gt; (2 3 4) (map inc) ;; =&gt; #&lt;core$map$fn__4525 clojure.core$map$fn__4525@2d9e9038&gt; ;;  ! ;;    (transduce (map inc) + [1 2 3]) ;; =&gt; 9 (transduce (comp (map inc) (filter even?)) + [1 2 3]) ;; =&gt; 6 ;; ~~ (+ (inc 1) (inc 3)) =&gt; 6</code> </pre><br>  In addition to <code>transduce</code> there are several other functions for working with transducers: <br><br><pre> <code class="plaintext hljs">;;     (sequence (map inc) [1 2 3]) ;; =&gt; (2 3 4) ;;     (transduce (map inc) conj [1 2 3]) ;; =&gt; [2 3 4] ;; ... ;;  `sequence`   ** ! ;;  `transduce`      (take 5 (sequence (map inc) (range))) ;; =&gt; (1 2 3 4 5) ;;   `into`     (into [9] (map inc) [1 2 3]) ;; =&gt; [9 2 3 4]</code> </pre><br>  But the funniest feature is <a href="">eduction</a> .  It returns a proxy object on which you can call <code>seq</code> , <code>reduce</code> or get a java-iterator.  It is expected that this object will simply cause <code>transduce</code> or <code>sequnce</code> .  Trifle, but convenient. <br><br><pre> <code class="plaintext hljs">(def odds (eduction (filter odd?) (range))) (def evens (eduction (remove odd?) (range))) ;;     sequential (take 5 odds) ;; =&gt; (1 3 5 7 9) ;;     sequence   100500  ;;       - sequence  GC (nth odds 100500) ;; =&gt; 2010001 ;;       reduce (  LazyCol) ;; ~= (reduce ((filter even?) ((take 100500) +)) 0 (range)) (transduce (take 100500) + evens) ;; =&gt; 10100149500</code> </pre><br>  Stop, stop, stop.  After all, it is suspiciously reminiscent of <code>clojure.core.reducers/reducer</code> ... He, however, could only be turned off, and then <code>seq</code> allowed to run.  So <code>r/reducer</code> throw in the trash!  But not <code>r/folder</code> , he knows how to multithreading! <br><br><pre> <code class="plaintext hljs">(require '[clojure.core.reducers :as r]) (def v (vec (range 1000000))) (time (transduce (map inc) + v)) ;; "Elapsed time: 120.193971 msecs" ;; =&gt; 500000500000 (time (r/fold + (r/folder v (map inc)))) ;; "Elapsed time: 37.597224 msecs" ;; =&gt; 500000500000 ;;   ! (transduce (take 100500) + v) ;; =&gt; 5050074750 (r/fold + (r/reducer v (take 100500))) ;; =&gt; 5050074750 ;;  ;; reducer  -   eduction (r/fold + (eduction (take 100500) v)) ;; =&gt; 5050074750 (reduce + (r/folder v (take 100500))) ;; =&gt; 5050074750 ;;    (r/fold + (r/folder v (take 100500))) ;; =&gt; 109071345018 ;; ... ;;     (   )</code> </pre><br>  When using transducers, both better performance compared to conventional <code>map</code> / <code>filter</code> / <code>etc</code> (based on lazy sequences) and greater flexibility / abstractness are achieved.  I note that we are talking here about the clojur sequences: in terms of the level of abstraction and speed, transducers are comparable to conventional iterators / enumerators / generators (in different languages, they are called differently). <br><br>  But back to Clojure.  Earlier in <a href="https://github.com/clojure/core.async">core.async there</a> was a whole lot of functions like <code>map&gt;</code> , <code>map&lt;</code> , <code>filter&lt;</code> , <code>filter&gt;</code> , etc.  Today they have been <a href="">removed</a> (well, as they have removed, for now they have only declined).  But allowed to specify the <s>transformer</s> transducer when creating the channel: <br><br><pre> <code class="plaintext hljs">;;      project.clj (require '[clojure.core.async :as a]) ;;     (def xf (filter odd?)) ;;     (def ch (a/chan 10 xf)) ;;      0  9     (a/onto-chan ch (range 10)) ;;     (a/&lt;!! (a/into [] ch)) ;; =&gt; [1 3 5 7 9]</code> </pre><br>  The transducer can only be hung on buffered channels.  And before the element is in the buffer, our transducer processes it.  There are all sorts of <a href="">pipeline</a> 's, they also work with transducers. <br><br><h2>  Summing up </h2><br>  Various reducer / transducer - all the essence of a generalization of the convolution operation.  And therefore, they require a reduct function with 2 arguments to work its useful. <br><br>  In addition to the 2-ary variant, it is better to determine the 0-ary one at the same time - it can be used if the initial state of convolution is not specified.  Or maybe not used: if the source collection is not empty, then <code>reduce</code> will take its first element.  But <code>transduce</code> is not so despicable - either the initial state is passed to it explicitly, or the 0-ary call to the reduct function is used. <br><br>  On the other hand, <code>transduce</code> requires more from the reduct function ‚Äî a 1-ary variant is needed.  Which, in general, most often does nothing at all.  Seriously, usually <code>([x] x)</code> is the most meaningful implementation in this case.  But we are lazy, rewriting old functions (0/2-ary) is too lazy for us, so we use <code>completing</code> wrapper, which adds an empty 1-ary version. <br><br>  Further, reductors are based on transformers.  Transformer = function with type <code>rf -&gt; rf</code> .  In fact, a reducer is a collection to which the transformer is tightly screwed.  And, every time we run <code>reduce</code> on this collection, first the transformer ‚Äúspoils‚Äù our reduct function. <br><br>  The transducer ~ = transformer, only requires support for the 1-ary reduct function.  So we always define this most hapless 1-arnick, and proudly declare to everyone: ‚ÄúWell, of course, I don‚Äôt use outdated transformers, only transducers‚Äù <br><br>  For all this, transducers are not limited to working with collections.  You can fasten them to channels, I / O streams, queues, observators, etc.  In general, everything that fantasy is enough. <br><br>  Total: <br><ul><li>      ,       ; </li><li>     ,  I/O,    ‚Äî  <code>reducers</code> ; </li><li>        <code>reduce</code> ‚Äî    <code>transduce</code> ; </li><li>      ‚Äî     ; </li><li>  ,    ‚Ä¶     ; </li><li>           ‚Äî   <code>map</code> , <code>filter</code>   . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/247889/">https://habr.com/ru/post/247889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247871/index.html">Mobile interface for one hand</a></li>
<li><a href="../247873/index.html">Curve25519, EdDSA, and Poly1305: Three cryptoprimitives neglected</a></li>
<li><a href="../247877/index.html">How I got to the Top AppStore with a simple application of exchange rates</a></li>
<li><a href="../247883/index.html">Design and installation of antenna mast structures of the SV range</a></li>
<li><a href="../247885/index.html">MyBatis as a faster alternative to Hibernate</a></li>
<li><a href="../247891/index.html">Wolves of Wall Street: A story about high-frequency trading from the expert Thomson Reuters</a></li>
<li><a href="../247893/index.html">List of YouTube channels for web development training</a></li>
<li><a href="../247897/index.html">Conditional indexing. Optimizing the full-text search process</a></li>
<li><a href="../247901/index.html">Study under the MASA program in Israel</a></li>
<li><a href="../247903/index.html">Docker: interesting features of basic images</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>