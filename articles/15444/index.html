<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classes, Objects, and JavaScript Inheritance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently in the office of Habr, I wanted to read to my colleagues a small report on object orientation and class inheritance in JavaScript. 

 The fac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classes, Objects, and JavaScript Inheritance</h1><div class="post__text post__text-html js-mediator-article">  Recently in the office of Habr, I wanted to read to my colleagues a small report on object orientation and class inheritance in JavaScript. <br><br>  The fact is that at one time I was delighted, learning how to create my own objects and build inheritance chains, and decided, as they say, to share my findings and observations with others.  (= <br><br>  I confess that in the process of preparing the texts of the seminar I discovered anew for myself again and was surprised again by the possibilities that JavaScript has at its disposal, and which become available to the developer only by scrutinizing and experimenting with the language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Taking advantage of the fact that the seminar was postponed all the time ‚Äúuntil next Friday‚Äù, I decided to publish the seminar texts online so that my enthusiasm could be useful to someone else. <br><br>  The whole text is divided into 5 sections: <br><ol><li>  OOP in Java Script (1/5): Objects </li><li>  OOP in Java Script (2/5): Classes </li><li>  OOP in Java Script (3/5): Properties and Methods of a Class </li><li>  OOP in Java Script (4/5): Class Inheritance </li><li>  OOP in Java Script (5/5): Useful Links </li></ol><br><a name="habracut"></a><br><h2>  OOP in Java Script (1/5): Objects </h2><br>  Everything in javascript is actually an object.  An array is an object.  A function is an object.  The object is also an object.  So what is an object?  An object is a collection of properties.  Each property is a name-value pair.  The property name is a string, and the property value is a string, a number, a boolean value, or an object (including an array and a function). <br><br>  When we define a variable, for example: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>; alert(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> s); <span class="hljs-comment"><span class="hljs-comment">//  string</span></span></code> </pre> <br>  we are, in fact, implicitly setting the property of an object.  In this case, this object will be the global window object: <br><br><pre> <code class="javascript hljs">alert (s == <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.s); <span class="hljs-comment"><span class="hljs-comment">//  true alert (typeof window); //  object</span></span></code> </pre><br>  Moreover, this window.s property is itself an object, since  it has already initially defined its own collection of properties: <br><br><pre> <code class="javascript hljs">alert(s.length); <span class="hljs-comment"><span class="hljs-comment">//  11 (   )</span></span></code> </pre><br>  For all that, it is, at first glance, an ordinary string literal! <br><br>  If the property value is a function, we can call this property an object method.  To call an object's method, it is enough to add two parentheses () after its name.  When an object's method is executed, the this variable inside this function refers to the object itself.  Using the this keyword, the object method accesses all other properties and methods of the object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">'futurico'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    s  window (window.s) var f = function(){ //    f  window (window.f) alert(this == window); //  true alert(this.s); //  'futurico' } f(); //   f  window (window.f()) var o = {}; //    o  window (window.o) os = 'karaboz'; //    s  window.o (window.os) of = function(){ //    f  window.o (window.of) alert(this == o); //  true alert(this.s); //  'karaboz' } of(); //   f  window.o (window.of())</span></span></code> </pre><br>  An object is created using a constructor function that initializes the object and the keyword <code>new</code> .  The constructor function provides the same features as a class in other programming languages: namely, it describes the template by which objects (instances) of the class will be created.  The basis of such a template is the enumeration of properties and methods that an object created on the basis of this class will possess.  For all built-in data types in JavaScript, there are built-in function constructors. <br><br>  For example, when we declare a string variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str=<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>;</code> </pre><br>  we implicitly call the built-in constructor function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>);</code> </pre><br>  and thereby create an object (instance) of class <code>String</code> . <br><br>  The same statement is true for all other JavaScript data types: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var num = 12345.6789; // var num = new Number(12345.6789); //   var bul = true; // var c = new Boolean(true); //  var fun = function(x){var p = x}; // var fun = new Function('x', 'var p = x'); //  var arr = ['a', 'b', 'c']; // var arr = new Array('a', 'b', 'c'); //  var obj = {}; // var obj = new Object();</span></span></code> </pre><br>  All of these objects immediately after creation have all the properties and methods described in their constructor functions (classes): <br><br><pre> <code class="javascript hljs">alert(num.toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  12345.6 alert(arr.length); //  3</span></span></code> </pre><br>  In fact, the JavaScript interpreter is somewhat trickier than it might seem from the previous example.  So, despite the fact that the following code shows the equality of two variables (objects of class <code>String</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>); alert(str1 == str2); <span class="hljs-comment"><span class="hljs-comment">//  true</span></span></code> </pre><br>  when trying to define a new user method for str1, we get an error: <br><br><pre> <code class="javascript hljs">str1.tell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } str1.tell(); <span class="hljs-comment"><span class="hljs-comment">//   'str1.tell is not a function'</span></span></code> </pre><br>  At the same time, for str2 everything will work, as we expect: <br><br><pre> <code class="javascript hljs">str2.tell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } str2.tell(); <span class="hljs-comment"><span class="hljs-comment">//  'karaboz'</span></span></code> </pre><br>  This restriction imposed by JavaScript on variables (objects) created through string, numeric, and Boolean literals, however, does not apply to objects created through function, array, or object literals.  Those.  variables (objects) containing a function, or an array, or an object, you can directly assign custom properties and methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">'futurico'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    s  window (window.s) var f = function(){ //    f  window (window.f) alert(this == window); //  true alert(this.s); //  'futurico' } f(); //   f  window (window.f()) fs = 'karaboz'; //    s  window.f (window.fs) fm = function(){ //    m  window.f (window.fm) alert(this == f); //  true alert(this.s); //  'karaboz' } fm(); //   m  window.f (window.fm())</span></span></code> </pre><br>  Here we clearly see that the function f, created as a method of the global window object, is itself an object that can have its own properties and methods! <br><br><h2>  OOP in Java Script (2/5): Classes </h2><br>  So, a class is a template that describes the properties and methods that any object created on the basis of this class will have.  To create our own class in JavaScript, we need to write a constructor function: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// - -    var Class = function(p){ alert('My name is constructor'); this.p = p; }</span></span></code> </pre><br>  And in order to create an object of this new class, we must call it as a normal function, using the new keyword.  In this case, the this keyword within the constructor function will now point to the newly created object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class(<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>); alert(o); <span class="hljs-comment"><span class="hljs-comment">//  [Object object] alert(op); //  'karaboz' -     o</span></span></code> </pre><br>  If you try to variable o simply assign a call to the function Class () - without the keyword new, then no object will be created: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = Class(<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   window.Class() alert(o); //  undefined,   ,    Class() alert(window.p); //  'karaboz' -      window</span></span></code> </pre><br>  When creating a function, JavaScript automatically creates an empty <code>.prototype</code> property for it.  Any properties and methods recorded in the <code>.prototype</code> function will be available as properties and methods of objects created on the basis of this function.  This is the basis for the description of the template (class), according to which the objects will be created. <br><br><pre> <code class="javascript hljs">Class.prototype.method = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'my name is .method'</span></span>); }</code> </pre><br>  Now we can call this method as the method of the object itself: <br><br><pre> <code class="javascript hljs">o.method(); <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre><br>  When calling an object property, it is searched first in the object itself, and if it is not there, then the interpreter looks at the <code>.prototype</code> function that created the object. <br><br>  So, when creating an object, there already exists a property <code>.constructor</code> , which points to the constructor function that created this object: <br><br><pre> <code class="javascript hljs">alert(o.constructor == Class); <span class="hljs-comment"><span class="hljs-comment">//  true</span></span></code> </pre><br>  Note that we did not define such a property in the object itself.  The interpreter, not finding the <code>.constructor</code> property in the object, takes it from the .prototype of the constructor function that created the object.  Check: <br><br><pre> <code class="javascript hljs">alert(Class.prototype.constructor == Class); <span class="hljs-comment"><span class="hljs-comment">//  true</span></span></code> </pre><br>  It should be noted that <code>.prototype</code> exists only for the constructor function, but not for the object itself created on its basis: <br><br><pre> <code class="javascript hljs">alert(o.prototype); <span class="hljs-comment"><span class="hljs-comment">//  undefined alert(o.constructor.prototype); //  [Object object]</span></span></code> </pre><br>  Access to the <code>.prototype</code> function exists for all objects, including objects embedded in JavaScript, such as strings, numbers, etc.  Moreover, there are already no restrictions in creating own properties and methods (we saw these restrictions when trying to directly assign properties and methods to a string variable - to an object created via a string literal): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>; s.constructor.prototype.tell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } s.tell(); <span class="hljs-comment"><span class="hljs-comment">//     ,   'karaboz'</span></span></code> </pre><br>  You can also set a new property or method for built-in object types directly through the built-in constructor function of these objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.tell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  By the way, we once again confirmed the statement that everything in JavaScript is an object (= <br><br><h2>  OOP in Java Script (3/5): Properties and Methods of a Class </h2><br>  Properties and methods of a class (class members) can be public (public), private (private), privileged (privileged) and static (static). <br><br><h3>  Public (public) members </h3><br>  Open refers to such properties and methods that can be directly read, modified, deleted, or added by any code outside the object itself. <br>  Open properties are set using the <code>.this</code> inside a constructor function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Class = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p = p; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class(<span class="hljs-string"><span class="hljs-string">'karaboz'</span></span>); alert(op); <span class="hljs-comment"><span class="hljs-comment">//  'karaboz' op = 'mertas'; alert(op); //  'mertas'</span></span></code> </pre><br>  Public methods are defined using the <code>.prototype</code> function: <br><br><pre> <code class="javascript hljs">Class.prototype.method = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'my name is .method'</span></span>); } obj.method(); <span class="hljs-comment"><span class="hljs-comment">//  'my name is .method' obj.method = function(){ alert('my name is .method, but I am new one!'); } obj.method(); //  'my name is .method, but I am new one!'</span></span></code> </pre><br>  Assigning the <code>.method</code> method to the <code>obj</code> object, we do not change the method of the same name in the <code>.prototype</code> function, but just close it from the interpreter, creating a new property with the same name in our object.  Those.  all newly created objects will still have the standard method from <code>.prototype</code> . <br><br>  We can allow the object to see again and use the method from <code>.prototype</code> .  To do this, simply delete the <code>.method</code> property of the object itself: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> o.method; o.method(); <span class="hljs-comment"><span class="hljs-comment">//   'my name is .method'</span></span></code> </pre><br>  Properties and methods specified through the <code>.prototype</code> of the constructor function are not copied to newly created objects.  All objects of this class use the reference to the same properties and methods.  At the same time, we can define open members at any point of the program, including even after the creation of an object (instance) of a class. <br><br><h3>  Private Members </h3><br>  Private properties and methods are not directly accessible from outside the object.  They are described directly in the class constructor function and are created when the object is initialized.  Variables that are passed as parameters to a constructor function, variables declared using the var keyword, and functions declared as local within the constructor function have these properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Class = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secret = p; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ count ‚Äì; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre><br>  The <code>secret</code> , <code>count</code> and <code>counter</code> properties are created in the object upon its initialization.  They are called closed because they do not have access to both the code from outside the object and the public methods of the object itself.  To understand how you can use these private properties, you need to refer to the preferred methods. <br><br><h3>  Privileged methods </h3><br>  The privileged method has access to private properties and methods, and is also available to both public methods of the object and from outside it.  It is possible to delete or rewrite the preferred method, but you cannot change it or force it to reveal the secrets it protects. <br><br>  The privileged method is defined in the constructor using the this keyword: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Class = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secret = p; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ count ‚Äì; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tellSecret = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secret; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class(<span class="hljs-string"><span class="hljs-string">'12345'</span></span>); alert(o.tellSecret()); <span class="hljs-comment"><span class="hljs-comment">//  '12345' alert(o.tellSecret()); //  '12345' alert(o.tellSecret()); //  '12345' alert(o.tellSecret()); //  null //      counter, // a   ,       o.counter = function(){ return true; } alert(o.tellSecret()); //    null</span></span></code> </pre><br>  <code>.tellSecret</code> is the preferred method.  It returns the private property <code>secret</code> at the first three calls, and at all subsequent starts to return <code>null</code> .  Each time <code>.tellSecret</code> calls the private method <code>counter</code> , which itself has access to the private properties of the object.  Any code has access to the <code>.tellSecret</code> method, but this does not give direct access to the private members of the object. <br><br>  Unlike the public methods created through <code>.prototype</code> , a copy of the privileged method is created in each object that is created, which naturally entails a greater memory consumption.  Private and privileged members are created only at the time of initialization of the object and later can not be changed. <br><br><h3>  Static members </h3><br>  Static properties and methods are properties and methods that are tied to the constructor function itself (to the class itself).  Therefore, they are also called class properties and methods.  They are available to any code both inside and outside the object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Class = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p = p; } Class.prototype.tell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function">)</span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.p + <span class="hljs-string"><span class="hljs-string">' '</span></span> + word + <span class="hljs-string"><span class="hljs-string">' '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor.p); <span class="hljs-comment"><span class="hljs-comment">// alert(this.p + ' ' + word + ' ' + Class.p); } Class.p = 'futurico'; var o = new Class('karaboz'); o.tell('love'); //  'karaboz loves futurico';</span></span></code> </pre><br><br><h3>  Closure (closure) </h3><br>  Private and privileged methods are possible in JavaScript due to what is called closure.  A closure is a function, plus all the lexical variables from the covering context that it uses.  When we use the <code>function</code> operator, we always create not a function, but a closure.  A closure ‚Äúremembers‚Äù the values ‚Äã‚Äãof all variables that existed in the context creating this closure, even when the function is used already outside the context that created it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closureParam = param; <span class="hljs-comment"><span class="hljs-comment">//  var returnedFunc = function(){alert(closureParam);} return returnedFunc; } var f = createFunc('karaboz');</span></span></code> </pre><br>  Now, if we look at the variable <code>f</code> , we will see that this is a normal function, in the body of which is the <code>closureParam</code> parameter, which is undefined anywhere in the surrounding context and should give an error: <br><br><pre> <code class="javascript hljs">alert(f); <span class="hljs-comment"><span class="hljs-comment">// : function(){alert(closureParam);}</span></span></code> </pre><br>  However, there will be no error; the <code>function(){alert(closureParam);}</code> due to the closure effect, remembers <code>closureParam</code> from the context that generated it: <br><br><pre> <code class="javascript hljs">f(); <span class="hljs-comment"><span class="hljs-comment">//  'karaboz'</span></span></code> </pre><br>  If we recall the privileged <code>.tellSecret</code> method described above, now we can understand how it works.  The method remembers both the private function <code>count()</code> and the private property <code>secret</code> , declared in the context that creates <code>.tellSecret</code> .  At the same time, when <code>count()</code> is called inside <code>.tellSecret</code> , this last function, in turn, remembers the <code>count()</code> <code>.tellSecret</code> used in its body. <br><br><h2>  OOP in Java Script (4/5): Class Inheritance </h2><br>  Basic principles of class inheritance: <br><br><ol><li>  A subclass always inherits all the properties and methods defined in its superclass. </li><li>  A subclass can override inherited properties and methods, as well as create new ones - and this should not affect the properties and methods of the superclass with the same name. </li><li>  A subclass should be able to call the native methods of the superclass even if it overrides them. </li><li>  Subclass objects should be initialized only at the time of their creation. </li></ol><br>  There are no tools in JavaScript to create classic class inheritance.  Instead, there is inheritance based on the object's <code>.prototype</code> property: when the object method is called, the interpreter searches for this method in the properties of the object itself, and if it does not find the method there, it continues searching in the property (object) of the object's <code>.prototype</code> function. <br><br>  Knowing about this JavaScript behavior, let's try to create the inheritance of two classes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Class = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -  this.className = 'Class'; } Class.prototype.method = function(){ //     alert('method of ' + this.className); } var ClassSub = function(){ // -  this.className = 'ClassSub'; } ClassSub.prototype = new Class(); //     .prototype  var objSub = new ClassSub(); //    ClassSub objSub.method(); // !  'method of ClassSub'</span></span></code> </pre><br>  We see that the subclass inherits the method <code>.method</code> its superclass (executes it as its own).  How does this happen?  First, the interpreter searches for the <code>.method</code> method in the <code>objSub</code> object <code>objSub</code> and naturally does not find it there.  Next, the interpreter accesses <code>ClassSub.prototype</code> and searches for <code>.method</code> among the properties of this object.  Again, it doesn‚Äôt find anything: we have never set anything similar to <code>ClassSub.prototype.method = function(){}</code> .  But after all, the <code>ClassSub.prototype</code> object <code>ClassSub.prototype</code> created from the <code>Class()</code> constructor function.  Therefore, not finding the necessary properties in <code>ClassSub.prototype</code> itself, the interpreter refers to the <code>.prototype</code> function of the constructor of this object.  And here already finds the requested method: <code>Class.prototype.method = function(){}</code> . <br><br>  We confirm this long argument with a simple comparison: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .method  objSub   .method  ClassSub.prototype alert(objSub.method == ClassSub.prototype.method); // true //  .method  ClassSub.prototype   .method  Class.prototype alert(ClassSub.prototype.method == Class.prototype.method); // true</span></span></code> </pre><br>  Such a chain of prototypes can be arbitrarily long, but the search for the interpreter in any case ends at the moment when it gets to the object created (explicitly or implicitly) from the built-in class <code>Object</code> .  If in the <code>Object.prototype</code> it still does not find the requested method, it will return an error.  The <code>Object</code> class lies at the very top of any possible hierarchy of classes created in JavaScript. <br><br>  Now let's try to override this inherited method, and at the same time expand the subclass with our own additional method.  At the same time, we check that the methods of the superclass remain the same (remember that you can add public methods and properties even after creating an instance of the class): <br><br><pre> <code class="javascript hljs">ClassSub.prototype.method = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     alert('method of ' + this.className + ' but new one'); } ClassSub.prototype.methodSub = function(){ //     alert('methodSub of ' + this.className); }; //       objSub.method(); //  'method of ClassSub but new one' //       objSub.methodSub(); //  'methodSub of ClassSub' var obj = new Class(); //    Class //       obj.method(); //  'method of Class' //       obj.methodSub(); //   'obj.methodSub is not a function'</span></span></code> </pre><br>  So for now everything is going fine.  We redefined the .method method in a subclass, and an instance of the subclass began to implement it.  Simultaneously, a copy of the superclass retained its same method with the same name.  We have created a new subclass method that works successfully on an instance of the subclass.  At the same time, this new method did not become a superclass method - an instance of the superclass does not see it and gives an error. <br><br>  Everything looks simple until we try to write more realistic code.  As a rule, the constructor function not only defines the properties of an object, but also performs some initialization functions.  For example, create an <code>Animal</code> class in which the name of an individual will be passed as a parameter, and each new instance of which will scream at birth (= <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Animal = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cry(); <span class="hljs-comment"><span class="hljs-comment">//      } Animal.prototype.cry = function(){ alert('whoa!'); } var animal_thing = new Animal('karaboz'); //  'whoa!';</span></span></code> </pre><br><br>  Now create a subclass of Cat, instances of which do not scream, but meow: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cry(); } Cat.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(); <span class="hljs-comment"><span class="hljs-comment">//    Animal Cat.prototype.cry = function(){ //   .cry alert('meow!'); } var cat_thing = new Cat('mertas');</span></span></code> </pre><br>  By running this code, we will hear not two shouts (whoa! Meow!), But three!  (whoa!, whoa !, meow!) And it is clear why.  The second cry occurs at the very moment when we do the inheritance of Cat.prototype = new Animal ().  We unwittingly create an instance of the class Animal (and make it scream at birth).  Those.  we run the designer function of the superclass idle before creating any instance of the subclass! <br><br>  In addition, in the subclass we completely duplicated the constructor function of the superclass!  While we do not even see how otherwise it is possible to force the subclass to assign properties to the object, passed through the parameters of the constructor function, and how to make this constructor do something differently in another way. <br><br><h3>  Solving the problem of idle call of the constructor function of a superclass </h3><br>  Maybe try not to create an instance of the class <code>Animal</code> , but just point out the equality of the prototypes of the two classes?  (after all, it is through their prototypes that they are connected).  Let's try to change this line: <br><br><pre> <code class="javascript hljs">Cat.prototype = Animal.prototype;</code> </pre><br>  Running the code, we hear two expected shouts!  But it only seems that the problem is solved.  Let's try to create another instance of the <code>Animal</code> superclass right after creating an instance of the <code>Cat</code> subclass. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animal_thing_new = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(<span class="hljs-string"><span class="hljs-string">'juks'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'meow!',      Cat!</span></span></code> </pre><br>  This copy is screaming in Cat voice!  It turned out that we overwritten the same-name method of the parent class.  The thing is, when we write <code>Cat.prototype = Animal.prototype</code> , we pass the Animal.prototype object to the Cat.prototype object by reference (as always happens when an object is assigned to a variable).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, any changes of the first reasonably lead to a change in the second. When we wrote </font></font><code>Cat.prototype = new Animal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we created a </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new object. Changing its properties, we did not affect the properties of </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the object's constructor function itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to implement inheritance - without creating an instance of the parent class - a little differently. Let's just try to copy </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all the properties and methods from the </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">superclass to the subclass. Rewrite the problem line as follows:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Animal.prototype){ Cat.prototype[prop] = Animal.prototype[prop]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run the code and see that the third individual is no longer meowing, i.e. The parent class method is still the same! But did we do well? In fact, we did not inherit the properties of the superclass, but simply created another copy of them. If there are many objects of a subclass, then each object will create its own complete copy of all properties of the superclass. Moreover, if you try to change the class methods after creating objects of a subclass, then these changes will not affect the objects of the subclass! This code seems very inflexible and cumbersome. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us resort to the following tricky trick: we will create </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a new object </font><font style="vertical-align: inherit;">in the </font><font style="vertical-align: inherit;">subclass that has a link to the </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">superclass, but does not launch the constructor function of the superclass. Rewrite the complex line again:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Empty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//   - Empty.prototype = Animal.prototype; Cat.prototype = new Empty();</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We created </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an object </font><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">an artificial class </font></font><code>Empty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When creating this object, nothing happens because the constructor function is </font></font><code>Empty()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empty. </font><font style="vertical-align: inherit;">Any assignments in </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will affect only changes in the properties of the object itself </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and will not affect the constructor function of the superclass </font></font><code>Animal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the interpreter does not find the required method either in the class instance </font></font><code>Cat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or in the properties </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it will turn to the object's constructor function </font></font><code>Cat.prototype (== new Empty())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and begin to search in </font></font><code>Empty.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which refers directly to the one we need.</font></font><code>Animal.prototype</code> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solving the problem of duplicating the constructor function of a superclass </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We would like to do something like this: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ Animal.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">during initialization of each new object of the subclass, </font></font><code>Cat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call the constructor function of the superclass </font></font><code>Animal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the context of the object </font></font><code>new Cat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In principle, our code already works well, but I would like to see it more universal - not tied to specific class names. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's make one lyrical digression. As we remember, when creating any object, it forms a property </font></font><code>.constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, taken from </font></font><code>.prototype.constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the constructor function that spawned it. However, when we recorded:, </font></font><code>Cat.prototype = new Empty()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we created a </font></font><code>Cat.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new object. If you now try to turn to </font></font><code>(new Cat()).constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the interpreter will go to look for it in </font></font><code>Cat.prototype.constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which means in </font></font><code>(new Empty().constructor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and will find this property as a result in </font></font><code>Empty.prototype.constructor ( == Animal.prototype.constructor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our property </font></font><code>.constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now points to the constructor function of a superclass, not a subclass! </font><font style="vertical-align: inherit;">We have corrupted this property. </font><font style="vertical-align: inherit;">Knowing all this, right now could be written:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get the desired universality of the code, but rather with this code we will add even more confusion, because </font></font><code>.constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an object must point to a construct function of a subclass, not a superclass. </font><font style="vertical-align: inherit;">Therefore, let's look like this: in the place of the last problem line in which inheritance took place, we write the following:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Empty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//   - Empty.prototype = Animal.prototype; Cat.prototype = new Empty(); Cat.prototype.constructor = Cat; //     - Cat.superClass = Animal; //    -   ,     - : var Cat = function(name){ Cat.superClass.apply(this, arguments); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we now want in the subclass to change our method not entirely, but only expand it, we can easily do it like this: </font></font><br><br><pre> <code class="javascript hljs">Cat.prototype.cry = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ Cat.superClass.prototype.cry.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); alert(<span class="hljs-string"><span class="hljs-string">'one more cat was born'</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will restore order in our code and write a universal inheritance function. </font><font style="vertical-align: inherit;">We write it in the </font></font><code>.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">built-in constructor function </font></font><code>Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thus, we will create a new method for all possible functions, incl. </font><font style="vertical-align: inherit;">and for our custom classes.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Function.prototype.inheritsFrom = function(superClass) { var Inheritance = function(){}; Inheritance.prototype = superClass.prototype; this.prototype = new Inheritance(); this.prototype.constructor = this; this.superClass = superClass; } // -  var Class = function(){} //      Class.prototype.method = function(){}; // -  var ClassSub = function(){ ClassSub.superClass.apply(this, arguments); } //   ClassSub.inheritsFrom(Class); // sic! //      ClassSub.prototype.method = function(){ ClassSub.superClass.prototype.method.apply(this, arguments); }</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OOP in Java Script (5/5): Useful Links </font></font></h2><br><ol><li> <a href="http://javascript.crockford.com/private.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Private Members in JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Douglas Crockford</font></font></li><li> <a href="http://javascript.crockford.com/inheritance.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classical Inheritance in JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Douglas Crockford</font></font></li><li> <a href="http://phrogz.net/JS/Classes/OOPinJS.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP in JS, Part 1: Public / Private Variables and Methods</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Gavin Kistner</font></font></li><li> <a href="http://phrogz.net/JS/Classes/OOPinJS.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP in JS, Part 2: Inheritance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Gavin Kistner</font></font></li><li> <a href="http://kevlindev.com/tutorials/javascript/inheritance/index.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inheritance in JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Kevin Lindsey</font></font></li><li> <a href="http://dklab.ru/chicken/nablas/38.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little tricks of JavaScript, or writing scripts in a new way</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Dmitry Koterov</font></font></li><li> <a href="http://dklab.ru/chicken/nablas/39.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Big tricks of JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Dmitry Koterov</font></font></li><li> <a href="http://dklab.ru/chicken/nablas/40.html">  JavaScript</a> ,   </li></ol></div><p>Source: <a href="https://habr.com/ru/post/15444/">https://habr.com/ru/post/15444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154419/index.html">Code injection into .NET CLR: IL code change during program execution</a></li>
<li><a href="../15442/index.html">Samsung tech pen</a></li>
<li><a href="../154425/index.html">We transfer the entire office to the "cloud": not a byte on local machines</a></li>
<li><a href="../15443/index.html">SanDisk TV Flash Drive</a></li>
<li><a href="../154437/index.html">November 6th is the best day of the calendar! Student Day 3.0 with Steve Ballmer!</a></li>
<li><a href="../154443/index.html">Sony has opened API Floating touch</a></li>
<li><a href="../154445/index.html">SDS-TWR Distance Measurement without Roulette and Sync</a></li>
<li><a href="../154449/index.html">Fluid Data: A ‚Äúsmall‚Äù win in storing ‚Äúbig‚Äù data - part 2</a></li>
<li><a href="../15445/index.html">About the benefits of the console</a></li>
<li><a href="../154451/index.html">Seamless migration of MySQL 5.0 -> Percona Server 5.5 with repartitioning storage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>