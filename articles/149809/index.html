<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Message dispatching on D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many game developers are faced with the problem of describing and implementing the client and server communication protocol, especially if they write ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Message dispatching on D</h1><div class="post__text post__text-html js-mediator-article">  Many game developers are faced with the problem of describing and implementing the client and server communication protocol, especially if they write their bicycles for working with sockets.  Below I will talk about my attempt to solve the problem as elegantly and conveniently as possible for further use and scaling of the application.  There will be a lot of compile-time'a with automatic code generation, gently seasoned with a pinch of run-time'a. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  The client and the server are constantly exchanged messages, but these messages must first be prepared, forwarded and then restored to a readable form.  Brief diagram below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/220/014/ef6/220014ef6bcf438e4f7050548660f1f8.png"><br><br>  The main problem arises between the stage of reading the message and deserialization, a stream of bytes comes to the receiver, and for correct deserialization you need to know the structure of the message, that is, the type.  All operations on types ended in compile-time and we no longer have the help of the compiler.  The very first, most brutal solution that comes to mind is to write a huge switch linking the message id and a specific function to unpack the message.  I think it‚Äôs not necessary to explain why this decision leads to a headache when processing the protocol and a huge number of difficult-to-find errors.  This problem will be solved. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First you need to determine what we want to get: <br><ul><li> Link a message id to a specific message handler class once.  And that's all, never remember further about id.  Something like this: <br> <code>0 AMessage <br> 1 BMessage <br> 2 CMessage <br></code> <br></li><li>  Correctly handle usage errors and stop attempts to spoil the code at the compilation stage.  For example, in C ++ it is almost impossible to get clear error messages when dealing with compile-time structures. <br></li><li>  Simple use, one function call and a stream of bytes turned into a message ready for processing. <br></li></ul><br><br><h4>  Dependencies </h4><br>  Our project uses its own serializer, which also actively uses compile-time (This is a topic for a separate post).  Let us agree that we have a certain black box that can translate classes and their fields into bytes and back again with such calls: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream = serialize!(ByteBackend)(SomeObject, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> object = deserialize!(ByteBackend, SomeClass)(stream, <span class="hljs-string"><span class="hljs-string">"name"</span></span>);</code> </pre><br><br>  Also, for simplicity, we naively assume that the messages are not encrypted and the serializer solves all security problems if the message does not match the stated structure, throws an exception, and we ignore the problematic message. <br><br>  All the code that goes further was tested on dmd 2.060 and probably no longer compiled to 2.059 (a very unpleasant children's disease D2). <br><br><h4>  Messages </h4><br>  Each message is a certain class that has a functional operator overloaded and there is a constructor without parameters (a requirement for deserialization).  The first requirement is easy to formalize; any message must implement this interface: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">interface Message { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Sample message: <br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMsg</span></span></span><span class="hljs-class"> :</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() {} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pa, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pb) { a = pa; b = pb; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ writeln(<span class="hljs-string"><span class="hljs-string">"AMsg call with "</span></span>, a, <span class="hljs-string"><span class="hljs-string">" "</span></span>, b); } }</code> </pre><br></div></div><br><br>  The second constructor is needed to build the message, about this and about checking the presence of the constructor without parameters below. <br><br><h4>  We start to make magic </h4><br>  In C ++, I would use many, many structures with template-specific parameters, but in D there are other ways to execute code in compile-time.  I will use templates and mixins so that as little as possible the compile-time code is settled in the executable file.  In total, all the code will be in the template mixin, it can be easily used again in another application or in another version of the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">mixin </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtocolPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IndexType, SerializerBackend, pairs...)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><br>  <b>IndexType</b> is the type of index we will use.  <b>SerializerBackend</b> is the backend for the serializer, it is possible that another application will use a different serialization mechanism in bytes or even not in bytes, but xml / json. <br><br>  <b>pairs ...</b> - The most interesting parameter, pairs will be recorded here: id and message type.  Example below: <br><br><pre> <code class="cpp hljs"> mixin ProtocolPool!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, BinaryBackend, <span class="hljs-number"><span class="hljs-number">0</span></span>, AMsg, <span class="hljs-number"><span class="hljs-number">1</span></span>, BMsg, <span class="hljs-number"><span class="hljs-number">2</span></span>, CMsg );</code> </pre><br><br><h5>  Error processing </h5><br>  But the user can stuff everything into pairs, break this fragile agreement, and then the problems will not keep themselves waiting.  It is necessary to check the correctness.  Therefore, we will insert into the template one more template that will run through the pairs and stop the compilation with a beautiful and understandable error message. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckPairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tpairs...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tpairs.length &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__traits(compiles, typeof(tpairs) ), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ProtocolPool expected index first, but got some type"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is(typeof(tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]) == IndexType), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ProtocolPool expected index first of type "</span></span></span></span><span class="hljs-function"><span class="hljs-params">~ IndexType.stringof~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" not a "</span></span></span></span><span class="hljs-function"><span class="hljs-params">~typeof(tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]).stringof)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is(tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">] : Message), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ProtocolPool expected class implementing Message"</span></span></span></span><span class="hljs-function"><span class="hljs-params">~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" interface following index not a "</span></span></span></span><span class="hljs-function"><span class="hljs-params">~tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].stringof)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CountValInList!(tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">], pairs) == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ProtocolPool indexes must be unique! One message,"</span></span></span></span><span class="hljs-function"><span class="hljs-params">~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"one index."</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CheckPairs = CheckPairs!(tpairs[<span class="hljs-number"><span class="hljs-number">2.</span></span>.$]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> assert(tpairs.length == <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"ProtocolPool expected even number of parameters. Index and message type."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CheckPairs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br></div></div><br><br>  There may be incomprehensible calls to <b>__traits (compiles, sometext)</b> , this is an explicit request to the compiler to check whether sometext is compiled at all or not.  You can read more about embedded Traits <a href="http://dlang.org/traits.html">here</a> .  And right after the template declaration, we call it through <b>static assert</b> .  It would be possible to simply call this template, but the compiler swears at obviously meaningless expressions, which sometimes hinders a little. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">mixin </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtocolPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IndexType, SerializerBackend, pairs...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckPairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tpairs...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,    } static assert(CheckPairs!pairs == 0, "Parameters check failed! If code works well, you never will see this message!"); }</span></span></code> </pre><br></div></div><br><br>  An attentive reader (if anyone got to this line at all) probably noticed that I did not define the <b>CountValInList</b> pattern, which counts the number of occurrences of the value in the list. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// returns count of val occurenes in list template CountValInList(IndexType val, list...) { static if(list.length &gt; 1) { static if(list[0] == val) enum CountValInList = 1 + CountValInList!(val, list[2..$]); else enum CountValInList = CountValInList!(val, list[2..$]); } else enum CountValInList = 0; }</span></span></code> </pre><br></div></div><br><br><h5>  Code Generation </h5><br>  Great, all improper uses are clipped and processed correctly.  According to such error messages, it is quite possible to find the right way to use the scientific method of typing (this will not save writing the documentation!).  Now you need to think about the task itself.  We need a compromise between usability and speed, stop, we can get this and that at the same time!  We will generate a giant switch automatically without the participation of the programmer: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// generating switch template GenerateSwitch() { template GenerateSwitchBody(tpairs...) { static if(tpairs.length &gt; 0) { enum GenerateSwitchBody = "case("~to!string(tpairs[0])~ "): return cast(Message)(func!(SerializerBackend, "~ tpairs[1].stringof~")(args)); break; \n" ~ GenerateSwitchBody!(tpairs[2..$]); } else enum GenerateSwitchBody = ""; } enum GenerateSwitch = "switch(id)\n{\n"~ GenerateSwitchBody!(pairs) ~ "default: " ~ " break;\n}"; }</span></span></code> </pre><br></div></div><br><br>  This template will generate a string similar to this: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(Message)(func!(SerializerBackend, AMsg)(args)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(Message)(func!(SerializerBackend, BMsg)(args)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(Message)(func!(SerializerBackend, CMsg)(args)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br></div></div><br><br>  It now remains to mix the resulting string into the function for dispatching: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//        ,      nested class   ,      private class dummyClass {} // func -  ,         args    Message dispatchMessage(alias func, T...)(IndexType id, T args) { static assert(__traits(compiles, func!(SerializerBackend, dummyClass)(args)), "ChooseMessage func must be callable with got args " ~T.stringof); //  ,      //pragma(msg, GenerateSwitch!()); mixin(GenerateSwitch!()); throw new Exception( "Cannot find corresponding message for id "~to!string(id)~"!"); }</span></span></code> </pre><br></div></div><br><br>  What the call to this function will look like in code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readMsg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; stream.read(id); writeln(<span class="hljs-string"><span class="hljs-string">"Got message id is "</span></span>,id); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> message = dispatchMessage!(deserialize)(id, stream, <span class="hljs-string"><span class="hljs-string">"MSG"</span></span>); writeln(<span class="hljs-string"><span class="hljs-string">"Calling message"</span></span>); message(); }</code> </pre><br></div></div><br><br>  Actually the most difficult part is written, there were only any goodies for convenient design of the message.  Nobody wants to do it manually ?!  It is much more convenient to do it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream = constructMessage!AMsg(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>);</code> </pre><br><br>  No id, no other extra stuff.  The parameters are immediately passed to the message constructor, and the message is serialized into a stream of bytes.  It remains to write this ... You need to be able to search for the message id by type, for this you need another template: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindMessageId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Msg, tpairs...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tpairs.length &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is(tpairs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">] == Msg))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> FindMessageId </span></span>= tpairs[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FindMessageId = FindMessageId!(Msg, tpairs[<span class="hljs-number"><span class="hljs-number">2.</span></span>.$]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Cannot find id for message "</span></span>~ Msg.stringof~<span class="hljs-string"><span class="hljs-string">". Check protocol list."</span></span>); }</code> </pre><br></div></div><br><br>  At this point, my tiny number of publics should have the thought that I suffer from a mania for functional programming.  I respect all the paradigms, but in the compile-time templates there is no mutable state, so a functional style naturally arises here.  Now it is not difficult to construct a message, knowing only its type: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Msg, T...)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is(Msg : Message), Msg.stringof~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" must implement Message interface!"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__traits(compiles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg(args)), Msg.stringof~ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" should implement constructor with formal parameters "</span></span></span></span><span class="hljs-function"><span class="hljs-params">~ T.stringof)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Msg(args); IndexType sendId = FindMessageId!(Msg, pairs); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream = serialize!SerializerBackend(msg, <span class="hljs-string"><span class="hljs-string">"MSG"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fullStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream; fullStream.write(sendId); fullStream.copyFrom(stream); fullStream.position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fullStream; }</code> </pre><br></div></div><br><br><h4>  Using </h4><br>  Now that we have this clever system, we need to test it in practice.  For this, I wrote unittest: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">version(unittest) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMsg</span></span></span><span class="hljs-class"> :</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() {} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pa, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pb) { a = pa; b = pb; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ writeln(<span class="hljs-string"><span class="hljs-string">"AMsg call with "</span></span>, a, <span class="hljs-string"><span class="hljs-string">" "</span></span>, b); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BMsg</span></span></span><span class="hljs-class"> :</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() {} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pa, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pb) { a = pa; b = pb; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ writeln(<span class="hljs-string"><span class="hljs-string">"BMsg call with "</span></span>, a, <span class="hljs-string"><span class="hljs-string">" "</span></span>, b); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMsg</span></span></span><span class="hljs-class"> :</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() {} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pa, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ps) { a = pa; s = ps; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ writeln(<span class="hljs-string"><span class="hljs-string">"CMsg call "</span></span>, a, <span class="hljs-string"><span class="hljs-string">" "</span></span>, s); } } mixin ProtocolPool!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, GendocArchive, <span class="hljs-number"><span class="hljs-number">0</span></span>, AMsg, <span class="hljs-number"><span class="hljs-number">1</span></span>, BMsg, <span class="hljs-number"><span class="hljs-number">2</span></span>, CMsg ); } unittest { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readMsg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; stream.read(id); writeln(<span class="hljs-string"><span class="hljs-string">"Got message id is "</span></span>,id); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> message = dispatchMessage!(deserialize)(id, stream, <span class="hljs-string"><span class="hljs-string">"MSG"</span></span>); writeln(<span class="hljs-string"><span class="hljs-string">"Calling message"</span></span>); message(); } <span class="hljs-comment"><span class="hljs-comment">// serializing auto stream = constructMessage!BMsg(4.0,8.0); // sending... // got at other side readMsg(stream); stream = constructMessage!AMsg(10, "Hello World!"); readMsg(stream); stream = constructMessage!CMsg(5., "Some usefull string"); readMsg(stream); }</span></span></code> </pre><br></div></div><br><br><h4>  Full source code </h4><br>  For the integrity of the picture below is the full source code under the Boost license.  For normal operation, the module needs a serializer, you can screw your own or use Orange. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright Gushcha Anton 2012. // Distributed under the Boost Software License, Version 1.0. // (See accompanying file LICENSE_1_0.txt or copy at // http://www.boost.org/LICENSE_1_0.txt) module protocol; import std.stdio; import std.conv; import std.stream; //  ,      import util.serialization.serializer; interface Message { void opCall(); } mixin template ProtocolPool(IndexType, SerializerBackend, pairs...) { // returns count of val occurenes in list template CountValInList(IndexType val, list...) { static if(list.length &gt; 1) { static if(list[0] == val) enum CountValInList = 1 + CountValInList!(val, list[2..$]); else enum CountValInList = CountValInList!(val, list[2..$]); } else enum CountValInList = 0; } // check pairs to be correct template CheckPairs(tpairs...) { static if(tpairs.length &gt; 1) { static assert(__traits(compiles, typeof(tpairs) ), "ProtocolPool expected index first, but got some type"); static assert(is(typeof(tpairs[0]) == IndexType), "ProtocolPool expected index first of type "~IndexType.stringof~" not a "~typeof(tpairs[0]).stringof); static assert(is(tpairs[1] : Message), "ProtocolPool expected class implementing Message interface following index not a "~tpairs[1].stringof); static assert(CountValInList!(tpairs[0], pairs) == 1, "ProtocolPool indexes must be unique! One message, one index."); enum CheckPairs = CheckPairs!(tpairs[2..$]); } else { static assert(tpairs.length == 0, "ProtocolPool expected even number of parameters. Index and message type."); enum CheckPairs = 0; } } // generating switch template GenerateSwitch() { template GenerateSwitchBody(tpairs...) { static if(tpairs.length &gt; 0) { enum GenerateSwitchBody = "case("~to!string(tpairs[0])~"): return cast(Message)(func!(SerializerBackend, "~tpairs[1].stringof~")(args)); break; \n" ~ GenerateSwitchBody!(tpairs[2..$]); } else enum GenerateSwitchBody = ""; } enum GenerateSwitch = "switch(id)\n{\n"~GenerateSwitchBody!(pairs) ~ `default: ` ~ " break;\n}"; } template FindMessageId(Msg, tpairs...) { static if(tpairs.length &gt; 0) { static if(is(tpairs[1] == Msg)) enum FindMessageId = tpairs[0]; else enum FindMessageId = FindMessageId!(Msg, tpairs[2..$]); } else static assert(false, "Cannot find id for message "~Msg.stringof~". Check protocol list."); } // actual check static assert(CheckPairs!pairs == 0, "Parameters check failed! If code works well, you never will see this message!"); private class dummyClass {} Message dispatchMessage(alias func, T...)(IndexType id, T args) { static assert(__traits(compiles, func!(SerializerBackend, dummyClass)(args)), "ChooseMessage func must be callable with got args "~T.stringof); //pragma(msg, GenerateSwitch!()); mixin(GenerateSwitch!()); throw new Exception("Cannot find corresponding message for id "~to!string(id)~"!"); } Stream constructMessage(Msg, T...)(T args) { static assert(is(Msg : Message), Msg.stringof~" must implement Message interface!"); static assert(__traits(compiles, new Msg(args)), Msg.stringof~" should implement constructor with formal parameters "~T.stringof); auto msg = new Msg(args); IndexType sendId = FindMessageId!(Msg, pairs); auto stream = serialize!SerializerBackend(msg, "MSG"); auto fullStream = new MemoryStream; fullStream.write(sendId); fullStream.copyFrom(stream); fullStream.position = 0; return fullStream; } } version(unittest) { class AMsg : Message { int a; string b; this() {} this(int pa, string pb) { a = pa; b = pb; } void opCall() { writeln("AMsg call with ", a, " ", b); } } class BMsg : Message { double a; double b; this() {} this(double pa, double pb) { a = pa; b = pb; } void opCall() { writeln("BMsg call with ", a, " ", b); } } class CMsg : Message { double a; string s; this() {} this(double pa, string ps) { a = pa; s = ps; } void opCall() { writeln("CMsg call ", a, " ", s); } } mixin ProtocolPool!(int, BinaryBackend, 0, AMsg, 1, BMsg, 2, CMsg ); } unittest { void readMsg(Stream stream) { int id; stream.read(id); writeln("Got message id is ",id); auto message = dispatchMessage!(deserialize)(id, stream, "MSG"); writeln("Calling message"); message(); } // serializing auto stream = constructMessage!BMsg(4.0,8.0); // sending... // Got at other side readMsg(stream); stream = constructMessage!AMsg(10, "Hello World!"); readMsg(stream); stream = constructMessage!CMsg(5., "Some usefull string"); readMsg(stream); }</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/149809/">https://habr.com/ru/post/149809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149801/index.html">VisualSVN 3.0.2 client for Visual Studio is released and has become more accessible!</a></li>
<li><a href="../149802/index.html">Localization of ASP.NET MVC applications</a></li>
<li><a href="../149803/index.html">Google files a lawsuit against Apple, requires banning imports of iPad, iPhone and Mac in the US</a></li>
<li><a href="../149806/index.html">802.11ac: what we need to know about the new standard Wi-Fi</a></li>
<li><a href="../149808/index.html">Custom firmware with Android 4.0.4 for Desire HD, craftsmen doing work for HTC</a></li>
<li><a href="../149810/index.html">Development of technical specifications (TZ) for a software product from the point of view of the customer</a></li>
<li><a href="../149812/index.html">Play on QuickTiGame2d in Appcelerator Titanium. Part 1</a></li>
<li><a href="../149813/index.html">The Russian neutron detector at Curiosity has begun work. No water detected yet</a></li>
<li><a href="../149814/index.html">Harvard scientists write 643 kilobytes of data into a DNA molecule</a></li>
<li><a href="../149815/index.html">Basic principles of interaction with the user's computer with visual impairment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>