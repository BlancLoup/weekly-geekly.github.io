<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The development of custom data types in programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to stop and look at the development of programming languages ‚Äã‚Äãin terms of the development of user-defined data types (PDD). 
 I want to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The development of custom data types in programming</h1><div class="post__text post__text-html js-mediator-article">  I would like to stop and look at the development of programming languages ‚Äã‚Äãin terms of the development of user-defined data types (PDD). <br>  I want to make a reservation right away, by users, programmers are understood as people who write code in these languages.  Well, those who accompany this code or just read. <br><br>  User data types are data types that can be created by the user based on what is available in the language. <br><img src="https://habrastorage.org/storage2/f7f/aae/2b8/f7faae2b85b54ca93457509e06cc131a.jpg"><br>  <i>Users want to have these types of data.</i> <br><br>  Users wanted to be able to compile data the way they want it.  Wanted, wanted, and surely will want.  More and more, more diverse and stronger. <br>  That is why it is useful to follow the development of user-defined data types in programs and programming languages. <br><a name="habracut"></a><br><h4>  No user data types </h4><br><img src="https://habrastorage.org/storage2/4c2/00f/e1d/4c200fe1dbb3151fab4f67e3eae8bdc0.jpg"><br>  <i>There was once no user data type.</i>  <i>Somehow got out</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the dawn of the computer era, the languages ‚Äã‚Äãwere not so hot - machine: either you obey their dictates (and the dictates are simple: either you use low bit numbers in binary-decimal system of calculation (or, what processor works) and processor commands) or not. <br>  We will not touch those "dark ages". <br>  One thing is to say - there was no user data type there, but programmers somehow survived and somehow wrote programs. <br><br><h4>  Built-in data types </h4><br><img src="https://habrastorage.org/storage2/434/8c9/28f/4348c928f3e0ff8c55b51c3c6759d847.jpg"><br>  <i>Built-in types are so comfortable!</i>  <i>As long as you use them as planned by the developers ...</i> <br><br>  The first more or less normal language was Assembler (in fact, there are many assemblers, we are talking about the backbone of languages, which appeared in the 50s).  In addition to readability, he brought a lot of new things in terms of user data. <br>  The largest and undeniable achievement is the ability to create variables!  Since then, the possibility has been inserted in almost all languages ‚Äã‚Äã- the ability to create variables. <br>  The second no less major achievement of the assembler, made of good intentions, is an attempt to insert into the language all data types (of those that the programmer might need) directly into the language. <br>  Well, the rest of the little things - first of all, the ability to record numbers not only in binary, but also in hexadecimal, octal, binary-decimal systems. <br>  Then it seemed, well, what else can the user need? <br><br>  Years passed, and the need not only for high-level abstractions, but also for user data types grew. <br>  And then struck 1957th year with FORTRAN. <br>  The written code on it looked almost like modern languages, although its version on punch cards may shock people who want to read it. <br>  Fortran gave everything that is needed ... for calculating the flight of ballistic missiles - such data as integers (of type int), with a comma (of type float), and complex. <br>  Strings?  Who needs them on punch cards?  They will appear in FORTRAN later - real lines only after 20 years, and their imitation - in 10 (together with the logical data type). <br>  And Fortran gave an almost-real user data type as an array (although its use is somewhat different from the modern one), we'll talk more about this in the chapter on Group User Data. <br><br>  But users are few - they want more and more user data. <br><br>  And now it appears - Algol, already in 1958, the programs on which are easily read and in our days. <br>  That's just Algol brought the basis of what is now everywhere - Boolean types, string, a variety of integer types and numbers with a comma.  A little later, Fortran will apply it all, but Algol was a pioneer. <br>  It would seem - all appetites are satisfied, what other types are needed by users?  Yes, everything is already implemented - just take it and use it. <br><br>  And then, stepping on the heels of Algola with FORTRAN, in 1958 another language appeared, quite different from the language - Lisp. <br><br><img src="https://habrastorage.org/storage2/4a2/9c5/1ac/4a29c51accdce2f5b31fb469145a1530.jpg"><br>  <i>Lisp can do unimaginable functions.</i>  <i>Just how to live with it?</i> <br><br>  He gave another, completely new data type, real user data types - functions (of the C-expressions type), which had firmly begun to enter all modern languages ‚Äã‚Äãonly from the beginning of the 21st century (first of all, thanks to the multiparadigm languages ‚Äã‚ÄãPython and Ruby).  If we take into account that Lisp allows to operate with macros - something like programming with eval (in 58), it is not surprising that the world was not ready for it. <br>  But is the world ready for Lisp now?  Probably not. <br>  Focus on why.  Lisp, like any other functional programming, works with strongly interconnected objects, somewhat reminiscent of linked gears of a mechanical clock.  Unlike imperative languages, any wedging into a gear will stop the whole mechanism.  Because of this, language requirements, including user data types, are much stricter.  Those problems that arose in Lisp immediately, in imperative languages, they only worsened by the end of the 80s. <br>  Lisp makes it possible to build any C-expression.  But he gives only one toolkit - the standard and simple toolkit for working with C-expressions. <br>  It turns out that there is an opportunity to write any user data, but you can work with them only as with primitives.  The development of Lisp-like languages ‚Äã‚Äãhas shown that so far no good tools have been found for unwritten C-expressions. <br><br>  Not all were satisfied for long.  The development of user data has slowed down for almost a decade. <br>  If they wanted something, then we finished these data types directly into the language.  But in those days, languages ‚Äã‚Äãdid not evolve and were updated as quickly as they are now, so they were mainly engaged in simulating the creation of custom data types. <br><br>  Imitation from the original data types is almost no different in functionality.  Basically in those days imitation was based on emulation by functions (procedural style). <br>  The main difference from the real user types is one thing - if you want to ‚Äúslightly‚Äù change the data type, you have to rewrite all the functionality.  Nobody wanted to do this. <br>  Therefore, to imitate become more flexible. <br>  Now I will say what everyone knows, but what is important here is not the described imitation technique itself, but the angle of view of this technique. <br><br><img src="https://habrastorage.org/storage2/2fe/828/7ae/2fe8287aeb464d2dc4e8d3c58f010619.jpg"><br>  <i>Sometimes you need to work only with the opportunities that are</i> <br><br>  First, a configurable flag-based functionality appeared.  This is not the easiest method, but it very much resembled an assembler, and it was then still known. <br>  The essence of the transfer flags is simple - the transfer of the number as a parameter, the number is represented as a binary number of flags.  Despite the widespread use, still no special data types exist in languages ‚Äã‚Äãlike a series of flags.  Instead, they found a good substitute - named constants and bit operations that look like logical ones. <br>  The simplest method ‚Äî it is still widely used everywhere ‚Äî is parameter configuration: the more you need to configure, the more parameters are passed.  One only has a minus - too easy to get confused in the order of passing parameters.  Therefore, they try to transfer up to 4-5 arguments with such methods. <br>  For more arguments, with the development of real user data, primarily group and composite, it became possible to transmit one complex argument - this is the same configuration not only horizontally, but vertically. <br>  The development of this method can be called the creation of embedded languages ‚Äã‚Äã(DSL) for configuring functions. <br>  The third method of simulator flexibility is the invention of manipulators (handlers), although at that time they were not called that, and often they were substitutes for manipulators - they were numbers and strings, and not references or pointers. <br><br>  The era of built-in data types has ended. <br>  But 1972 came, appeared ... Sy.  And the era of dinosaur domination (embedded data types) continued for another decade, although user data types began to win their place in the sun. <br>  Including in the very Si. <br><br>  But for now let us return to one more built-in data type, which has become one of the reasons for the growing popularity of the language.  C introduced a low-level data type, which was in assembler, and was completely forgotten in the first high-level languages ‚Äã‚Äã- dynamic types.  First of all, these are references (reference) and pointers (pointer).  A null data service type is added to them - null. <br><br><img src="https://habrastorage.org/storage2/32a/edb/adf/32aedbadf97135e8b2e94941acc62adc.jpg"><br>  <i>Dynamic data types like master keys are inconspicuous, but what kind of secret rooms can not be reached with them ?!</i> <br><br>  The link can be viewed as one of the options for implementing this type of user data as a synonym. <br>  The development of synonyms can be found in PCP and its concept of variables, when you can return the value of a variable or function whose name is written in the value of the variable being called. <br>  In C, calling a function can be called with a function call, or you can pass a callback function. <br>  In addition to this, dynamic data types help to speed up the execution of compiled code well. <br>  To these advantages, dynamic data types have another huge plus - with them it is quite simple to implement something that was not laid down in the language itself.  Only one afflicts, written with their use can be accessed only with the help of tools for working with dynamic data.  But the crawling technique for simulating data is known - to close in functions and return a reference / pointer to the created one ‚Äî handlers.  Manipulators are one of those data types, in different languages ‚Äã‚Äãof which it can be called quite differently. <br>  For example, in PCP they are called resources, in Erlang they are called ports and process identifiers.  In Cobol there is such a data type as a file and a picture. <br><br>  However, dynamic data types are not only advantages.  Cons, too, sometimes very large. <br>  The more freedom in using dynamic data types is given by language, the: <br>  1) the possibilities for creating something that was not laid in the language (and not necessarily positive opportunities) are increasing <br>  2) the compiler interferes less and less with the user's actions, and all responsibility for the actions falls on the programmer <br>  2) code insecurity increases dramatically <br>  3) sharply increases the possibility of injections into the namespace <br>  4) the garbage collector intervenes less and less, and all responsibility falls on the user <br>  Further history has shown that the creators of subsequent languages ‚Äã‚Äã(or when added to already existing languages) when adding dynamic data balanced the balance between security and capabilities. <br><br>  The end of the 70s was nearing, and these basic built-in data types began to go off to the periphery, into a routine, giving way to real user data. <br><br>  However, the reality sometimes presents surprising surprises. <br>  Who knows how much more can be found in the old-kind and long-understood data types? <br><br><img src="https://habrastorage.org/storage2/5bd/39e/dd8/5bd39edd86d70a1c3ae0b0ab3898cce6.jpg"><br>  <i>Sometimes you just need to see a new where everything has long been known.</i>  <i>As, for example, this sorting of M &amp; Ms</i> <br><br>  Then, in the late 70s, the AWK scripting language appeared (using the grep utility development), and a decade later based on it, in 1987, a language like Pearl appeared.  And among other things, he had (still has) such an exotic built-in data type as regular expressions. <br>  Perl helped look at such an old data type as strings from a new side.  The toolkit for working with it in early languages ‚Äã‚Äãcould be considered as simplified parsers. <br>  Regular expression languages ‚Äã‚Äãhave proven to be very flexible and super-powerful tools for working with character data types. <br><br><h5>  Group data types </h5><br><img src="https://habrastorage.org/storage2/99c/c11/45a/99cc1145abcb1d0c16603b4450912441.jpg"><br>  <i>Some groups are big.</i>  <i>I want to work with them quickly</i> <br><br>  In fact, group data types are a lot of something that is in a language, as a rule, a monomorphic grouping.  Often, these data types are not user-defined, but built-in; however, they are sometimes so flexible that this is enough. <br>  Already Fortran supported group data types - these are arrays (array), although they looked a bit different than they are now.  Arrays, very similar to the modern ones, were already in Algol.  There were sets in Pascal (set) <br>  In Lisp there were lists (list). <br>  Then came the hash tables, associated arrays, vectors, heaps, queues, stacks, trees ... <br>  Something was embedded, something was simulated or created using custom data types. <br>  Further development of group data types led to 2 different branches of development. <br>  1) the need to use its functionality with each group data type was not the most satisfactory, I wanted to work with them uniformly.  The main tools for this in imperative languages ‚Äã‚Äãare collections and iterators.  Mostly been added in the early 2000s. <br>  2) In the 80s with the development of data growth, the need to expand the tools for working with group data types grew by leaps and bounds.  Databases have appeared, and with them both queries and query languages.  In the mid-80s, the structured query language (SQL) becomes dominant.  Like parsers for strings, the query language made it clear that the toolkit that was used for group data types can be viewed as a primitive query language.  Databases, as a rule, are taken out of the language, and in the language there are only methods of working with them, therefore they cannot be considered as full-fledged user-defined data types.  Although due to their flexibility, this is immaterial. <br><br><h4>  Real user data types </h4><br>  In the era of built-in data types in different languages, you can find support for very exotic built-in data types. <br>  For example, in C, this type of data was enumeration.  He was first introduced to Pascal by Pascal (1970), although he called him a scalar. <br><br><img src="https://habrastorage.org/storage2/ea3/ce3/d90/ea3ce3d909e44aa9d6dd4e704ddc7c01.jpg"><br>  <i>What is an enumeration is easy to explain even to children on the fingers</i> <br><br>  Enumeration is the most authentic user data type!  It would seem, it is necessary to put a monument to C for this.  No, except that the gravestone. <br>  The fact is that users have the opportunity to build any transfers.  Only here to work with them in C there is nothing (there was a basic set in Pascal).  Nothing at all.  You can create transfers, but you cannot work with them. <br>  Since C was in the mainstream, few people wanted to add this data type to other languages.  Only in C ++ 11 there appeared at least some tools for working with enumerations. <br>  This example, like the development of Lisp, showed how important it is to have not only user-defined data types, but also tools for working with them. <br><br><h5>  Composite data types </h5><br><img src="https://habrastorage.org/storage2/cb7/2d4/a6c/cb72d4a6c81121817e5be85e1ae6b377.jpg"><br>  <i>The recordings are so varied.</i>  <i>Still learn how to use them</i> <br><br>  But in C there was another real user data type.  Although it was invented much earlier - back in Cobol, published in the early 60s (the language itself was created in 1959). <br>  This is a record, in C, it is called a structure (struct). <br>  A record is nothing more than a group of heterogeneous data types. <br>  Records toolkit is attached to the records.  For example, C not fully gives the standard minimum of work with records (for example, only one-sided initialization). <br>  With records it is easy not to imitate, but to create real lists and trees. <br>  Really, everything is in the language again? <br>  No and no again. <br>  It is not enough to have just custom data types.  It is not enough to have the tools for working with the PDD as with the PDD.  Another thing comes to the fore. <br>  <b>No one gives any tool for uncreated data types!</b> <br>  Now, languages ‚Äã‚Äãwith records support have fallen into a similar trap like the one Lisp has got into - you can create your own data, and you can only work with them with a basic set. <br>  Only in Lisp the situation is worse: in this language everything is C-expressions, and in C, Cobol, and others, the record is an independent type, besides it has its own, albeit small, toolkit. <br>  Fortunately, the solution to this impasse has long been known - an imitation of working with user-defined data types using functions. <br><br>  It was thanks to the records / structures (including in C) that programmers came to realize the importance of user-defined data types. <br>  At the same time, an acute shortage of tools for working with yet-created data types was clearly indicated. <br><br>  And the answer was.  No matter how surprising it sounds, but he was still a couple of years before the creation of C, he was in Europe, and was called Simula (1967).  And when C began to choke on the lack of tools for user-defined data types, C ++ (in 1983) took over the best from the Simula and applied the C syntax to it. <br><br><h5>  Objects </h5><br><img src="https://habrastorage.org/storage2/1e2/348/82e/1e234882ef1110b6a6af5024de02b7a1.jpg"><br>  <i>Objects can do everything.</i>  <i>Themselves and above themselves</i> <br><br>  Objects are another type of user data.  It has much greater capabilities than the recording. <br>  This gave him the opportunity to win just wild popularity. <br>  Ironically, the same as Simula, which came out a couple of years before C, which had no objects, and a couple of years before C ++, Smalltalk in 1980 declared the paradigm ‚Äúall objects‚Äù. <br>  But Smallt did not win great popularity, he had to wait until C ++ reached the level of stagnation, and only after that, in 1995, Java was again able to raise the ‚Äúall objects‚Äù paradigm proudly overhead. <br>  What is so good objects, because they are not so different from the records.  In essence - the same entries with the addition of methods. <br>  First, the tools for working with the objects themselves are much richer and stronger than the tools for working with the structure. <br>  And secondly, there were no tools for working with objects that have not yet been created ... either. <br>  Stop, one wonders, where is the ‚Äúsecond‚Äù here, if objects have no tools with uncreated data types, and records have no.  And, nevertheless, secondly!  <b>For the records, it was necessary to imitate this toolkit, while for objects you can simply implement this toolkit inside the object itself!</b> <br>  And if suddenly it was necessary to slightly change the user-defined data type, it was convenient to create a descendant using the toolkit of objects - by inheritance, and correct the behavior in it. <br>  The boom and total use of objects has now led to stagnation. <br>  What prevents objects from developing further? <br>  As we remember, the implementation of the toolbox of a new object is entirely the responsibility of the programmer, and not in the language, so the level of code reuse is not as large as it could be. <br>  Equally important and increasing closeness.  The object itself will do everything, although it is almost never necessary to do everything from it.  And vice versa, having the ability to do everything yourself, this object will not do anything to others.  Maybe, but it won't. <br>  Part of the problem helps to solve the introduction of interfaces (interfaces) and primisey (mixins, traits). <br>  Interfaces are introduced for the first time by Delphi (in 1986, even as Object Pascal), later Java and C #.  And this is understandable - they were leaders in object languages. <br>  But what is surprising is that the primitives / traits appeared when trying to attach objects to Lisp (Flavors, CLOS) (CLOS is part of Common Lisp), later added to different languages. <br>  However, even abstract helpers such as interfaces and impurities do not always help, for example, to an old object labeled ‚Äúfinalized‚Äù (final).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partially, one can solve the problem of hybridization based on prototype inheritance (the Self-open language (dialect of that Smalltalka) in the mid-1980s and gained popularity primarily thanks to Java Script a decade later), but this method has its drawbacks regarding class inheritance. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting support for metaclasses (metaclass), which were incorporated in Smalltalk in 1980 and are now supported by some languages, for example, Python. Metaclasses work with classes as objects (such a recursive approach). This greatly improves the tools for working with objects as objects. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nowadays, it is not the creation of a new object that comes to the forefront, but a competent approach to designing a system using design patterns (patterns).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What will happen next? </font><font style="vertical-align: inherit;">The question is rhetorical. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Are there alternatives to such powerful custom data types as objects, structures? </font><font style="vertical-align: inherit;">There are, and even better than objects! </font><font style="vertical-align: inherit;">It is worth looking at them better to understand how objects can develop in the future.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search alternatives </font></font></h5><br><img src="https://habrastorage.org/storage2/612/a9d/a4b/612a9da4b5f2a2c06507b985cdc0b781.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Christ and Krishna together. Imperativeness and Functionality can be together</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where to look for alternatives? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Declarative (like HTML) and logical languages ‚Äã‚Äã(like Prolog) currently do not contain alternatives. They are based on the fact that instead of the programmer, the compiler / interpreter works. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here we must either </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) just quit trying to add user-defined data types and enter a symbiosis with another language (for example, HTML + Java Script) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) connect other programming paradigms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, at the expense of connecting other paradigms, it would seem, how good it is to have multi-paradigm languages? Python (1991) and Ruby (1994) did not think so.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, they were right. Where it is easy to do all Lisp - it is convenient to use the functional programming paradigm, where simplicity is needed - there is a procedural style, for other cases - objects do well. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would seem that no new user data has been added, and the efficiency of writing code has greatly increased. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And when in the yard of 2011, even in C ++, lambda functions from Lisp came. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala has grown from Java since 2003, accepting the premise that objects are also functions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaprogramming is good. </font><font style="vertical-align: inherit;">But, as a rule, it allows either to expand (make it more flexible) the built-in data types, or to generate new code, or simply to create generalizations, it works with the built-in data types. </font><font style="vertical-align: inherit;">So far only with embedded. </font><font style="vertical-align: inherit;">But even without user-defined data types, beyond the metaprogramming, the future (and already in many ways the present) in terms of getting rid of the programming routine.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algebraic Data Types </font></font></h5><br><img src="https://habrastorage.org/storage2/3bb/aaf/d04/3bbaafd04955b28036e1418a9393fb74.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATD are so beautiful that I want to insert into the frame and hang. And sometimes, leave there and no longer touch</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wow, how menacing it sounds! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard ML in 1990 for the first time introduces Algebraic Data Types (ATD). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algebraic data types are one of the most powerful custom data types. They were found by mathematicians Hindley and Milner in lambda calculus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATD is ‚Äúall in one‚Äù - unitary data types (like null), enumeration (like enum, bool), protected basic types (like how resource versus link), switching types (something like in C - union), list-like structures, tree structures, functions, tuples, records, object-like structures (but not objects). And any combination of all this.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is much better than objects! At least from the point of view of creating the various user-defined data types themselves - yes, better, of course. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only from other points of view, this data type, both in the Standard MLS and in the later Okamle, is very, very poor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools for working with ADT as with ADT is not much more than working with records, and significantly less than with objects. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, there are no tools for working with not yet created data types. And, unlike objects, there is no place to hide the samopisny toolkit. Only imitate.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kaml, as a descendant of the Standard ML, without thinking twice, added objects to himself and became the Omemle (by 1996). And in parallel, Okaml began to develop an alternative, more functional solution, where to hide the implementation of the user data toolkit - in parametric modules. And, for 15 years Okaml built a decent functional replacement for objects. There is another interesting approach - as we remember, parametric module-functions were introduced in order to get rid of the problem of lack of tools for unwritten ADT data, only the parametric modules themselves nowadays do not differ much from ADT, which means that now there are no tools for more not written ... modules. Straight recursion!</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And for these 15 years, Okaml finds another solution to the problem of lack of tools for uncreated data types, he called them so - variant (variant). </font><font style="vertical-align: inherit;">This is a different, non-ATD data type, although it looks similar. </font><font style="vertical-align: inherit;">This is a switching data type, at the same time it can be shared in any proportions, including mixing (it is impossible to share ATD data in proportions, as well as to mix). </font><font style="vertical-align: inherit;">It‚Äôs good that it is possible to proportionally share (with objects it can be achieved only with the help of interfaces or traits, and even then not completely), it is often tempting to mix (you cannot create this with objects), it‚Äôs bad that in any proportions. </font><font style="vertical-align: inherit;">There is still something to work on. </font><font style="vertical-align: inherit;">This data type is underdeveloped. </font><font style="vertical-align: inherit;">From the simple ways of development - to add hitherto meager toolkit of work with the options toolkit of sets.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algebraic Data Types paired with Type Classes </font></font></h6><br><img src="https://habrastorage.org/storage2/f64/75f/f09/f6475ff09c380b3f3b4656d873fe22d0.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATD with types of classes look rough, but they are capable of much.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the early 90s, based on the Standard ML, as well as several academic languages, another language was developed, first standardized only in 1998. It was Haskel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He had the same algebraic data types as the Standard ML and OCM. And the same meager set to work with ADT as with ADT. But </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell had (and still has) something that no one type of user data had before. Haskell has a toolkit for the still unwritten custom data types</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - these are the type classes (class). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The types of classes themselves are something like interfaces or impurities most closely to the roles in Perl, only the introduction of classes differs from the introduction of interfaces / traits.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaces for simple classes of types, admixtures for complicated ones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, for complex classes, the analogy with an admixture will no longer be suitable. For complex classes there is no need to connect all the data, just join at the entry points, or at one of several entry points, if allowed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And with the help of the implementation of the class (instance), one can share tools, and not only with the code written after the creation of the class, but also for the data created earlier (as if one could add behavior to the finalized objects). If we take the analogy in object languages, this is achieved, first of all, by not attaching interfaces and impurities to objects, but, on the contrary, objects to impurities and interfaces (in part, roles in Perl already have this).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But Haskell did not stop even on this. </font><font style="vertical-align: inherit;">He implemented automatic deriving of classes for various types of data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is definitely much more on the capabilities of user-defined data types than is incorporated in the objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskel is booming. </font><font style="vertical-align: inherit;">Already, Algebraic Data Types are only a fraction of the larger. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it is quite possible to create data families, Generalized Algebraic Data Types (GADTs), existential, multi-rank. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes of types also do not stand still. </font><font style="vertical-align: inherit;">Already now it is possible to use multiparameter, function-dependent, species-specific classes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The toolkit for working with ADT as with ADT in the context of metaprogramming is expanding.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Much of this new language exists as an extension of the language, and in 2014 it can enter the standard of the language. </font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The story openly showed an urgent need for custom data types. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User data types are needed more and more. More diverse. With deep support for tools that can work with both a generic type of user data, and with what will be created by programmers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as we managed to hide the samopny toolkit in the user data itself, the rapid growth of user data began. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, as history has shown, it is sometimes not enough for a language to own progressive technologies in order to become popular. The invention of objects in Simula before the advent of C (in which there were not even objects) did not make a breakthrough for the Simula itself.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">History has shown that finding what no one sees under their feet is also useful. </font><font style="vertical-align: inherit;">Combining several paradigms and achieving more than individually (Ruby, Python, ..), opening low-level dynamic data types (C), summarizing the work with strings ‚Äî like working with parsers (Pearl) ‚Äîhas greatly helped both these languages ‚Äã‚Äãand programming in general. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Will Lisp-like languages ‚Äã‚Äãfind their own toolkit for the data types that have not yet been created? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Will objects stop developing? </font><font style="vertical-align: inherit;">If not, where will they go - along the path of the Scala language? </font><font style="vertical-align: inherit;">Ruby? </font><font style="vertical-align: inherit;">Pearl? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When is the golden age of algebraic data types? </font><font style="vertical-align: inherit;">Is there any chance of developing a variant data type? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Will the Haskele classes be borrowed in other languages? </font><font style="vertical-align: inherit;">Where will Haskel go? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time will tell and answer questions.</font></font></div><p>Source: <a href="https://habr.com/ru/post/184558/">https://habr.com/ru/post/184558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184548/index.html">SQL Reporting services in the clouds. Part 3: Multi-tenant</a></li>
<li><a href="../184550/index.html">O Backbone.js is very simple and brief for fans of MVC frameworks.</a></li>
<li><a href="../184552/index.html">DXperience 13.1 - New version of .NET components from DevExpress</a></li>
<li><a href="../184554/index.html">Crazy DIY toy: a homemade cell phone with a built-in dosimeter. Part 1</a></li>
<li><a href="../184556/index.html">Iterative search program</a></li>
<li><a href="../184560/index.html">VKontakte iOS SDK</a></li>
<li><a href="../184562/index.html">Thread concurrency C ++ 11, your bike technology (Apple) GCD</a></li>
<li><a href="../184566/index.html">LinkMeUp. Release 4</a></li>
<li><a href="../184570/index.html">Digest of new MSDN materials in Russian for May and June</a></li>
<li><a href="../184572/index.html">Port "Age of Empires" for smartphones will be released before the end of the year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>