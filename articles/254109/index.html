<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to decrypt magnetic track data using DUKPT</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of "Habrakhabr" a translation of the article "How To Decrypt Magnetic Card Data With DUKPT" . 

 Recently, I needed to decipher ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to decrypt magnetic track data using DUKPT</h1><div class="post__text post__text-html js-mediator-article">  I offer the readers of "Habrakhabr" a translation of the article <a href="https://www.parthenonsoftware.com/blog/how-to-decrypt-magnetic-stripe-scanner-data-with-dukpt/">"How To Decrypt Magnetic Card Data With DUKPT"</a> . <br><br>  Recently, I needed to decipher card data from a magnetic track reader.  It would seem simple.  I take the key and perform a specific decryption algorithm.  But it was not there. <br><br>  It turned out that my readers use a scheme known as DUKPT (Derived Unique Key Per Transaction - Definition of Unique Key On Transaction).  The idea of ‚Äã‚Äãthis scheme is that for each transaction (or in our case for each card rental) the data is encrypted using the key calculated for the individual card rental. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, in order to decrypt data that has been encrypted using this scheme, you must be able to calculate the key for a separate card rental.  The process of calculating such a key (session key) is far from simple. <br><a name="habracut"></a><br>  The process is described in ANSI X9.24 part 1. However, the document costs about $ 140.  Free, easy-to-access documentation describing this process is difficult to find.  The best resource I managed to find is <a href="http://www.andyorrock.com/2006/11/creating_an_ipe.html">here</a> ;  There is a pretty good explanation of how IPEK is calculated (Initial Pin Encryption Key - the initial key for calculating keys).  Unfortunately, this is only part of the complete scheme.  In this post I will try to fully explain the DUKPT scheme. <br><br><h4>  Definitions </h4><br>  <b>BDK</b> : This is an abbreviation for Base Derivation Key.  This key is known only to the manufacturer and developer of software that interacts with a magnetic track scanner. <br><br>  <b>IPEK</b> : This is short for Initial Pin Encryption Key.  This key is determined from the BDK.  This key is downloaded to the device by the manufacturer and used to generate future keys.  Compromising IPEK does not compromise BDK. <br><br>  <b>KSN</b> : This is short for Key Serial Number.  KSN is a combination of the serial number of the magnetic track scanner and the card rental quantity counter, which was performed on the device. <br><br><h4>  How does it work </h4><br>  The BDK is used by the manufacturer to generate IPEK, which is downloaded to the device during development.  The device uses IPEK and KSN to calculate the session key that encrypts data readable from the card. <br><br>  BDK is required by software developers to calculate IPEK.  After receiving IPEK, they can request KSN from the device.  IPEK and KSN are used to obtain the key for a separate transaction / rental card.  Having these keys, developers can decipher card data. <br><br><h4>  IPEK calculation </h4><br>  To get the initial key to calculate the keys (IPEK), we need the basic key of the algorithm (BDK) and the serial number of the key (KSN).  IPEK is determined using the TripleDES algorithm.  TripleDES is a simple DES algorithm that runs in three passes. <br><br>  The algorithm uses a key length of 24 bytes.  The DES algorithm is used three times, first with a key of 1-8 bytes, then 9-16 bytes and, finally, 17-24 bytes separately for each pass. <br><br>  TripleDES can use a key length of 16 bytes, this method is called EDE3.  Bytes 1-8 will be used first, then 9-16 and, again, 1-8 emitting a 24-byte key. <br><br>  Some implementations of TripleDES may not automatically use the short key.  Before you understand it, I spent a lot of time trying to figure out what the problem was.  Assuming that this is a special implementation of TripleDES, I used an emitted 24 byte key of 16 bytes. <br><br>  After much anguish, it descended on me to try to take the first 8 bytes and add them to the end of the key before transferring it to the TripleDES algorithm.  This solved the problem. <br><br><h4>  Details </h4><br>  IPEK consists of two 8-byte parts, which are obtained as a result of two separate passes of the TripleDES algorithm.  Both are obtained by encrypting the higher 8 bytes of KSN with a zero counter.  The difference between the left and right sides is that the right side is obtained by encrypting KSN using a slightly modified version of the BDK.  I will describe this process below. <br><br>  Suppose there is a 16-byte BDK represented by the hexadecimal string "0123456789ABCDEFFEDCBA9876543210".  We also have a 10 byte KSN with a counter equal to 8, represented by the hexadecimal string "FFFF9876543210E00008". <br><br>  Get the BDK to encrypt the left side of the IPEK by adding the first 8 bytes to the end of the BDK, this will be the next 24 byte key. <br><br><pre><code class="hljs">0123456789ABCDEFFEDCBA98765432100123456789ABCDEF</code> </pre> <br>  If the length of KSN is not equal to 10 bytes, then we supplement it with 10 bytes of hexadecimal "F" (1111).  It is important to note that IPEK is the very first key on the device.  This means that we calculate it with a counter in KSN equal to 0. To get a KSN with counter 0, we superimpose a mask on it in hexadecimal representation of which is the string "FFFFFFFFFFFFFFE00000". <br><br><pre> <code class="hljs pgsql"> FFFF9876543210E00008 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> FFFFFFFFFFFFFFE00000 = FFFF9876543210E00000</code> </pre><br>  Wonderful.  Now we have zero KSN.  However, we need the upper 8 bytes of KSN.  We get them by moving the KSN to the right by 16 bits. <br><br><pre> <code class="hljs ruby">FFFF9876543210E0000<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">16</span></span> = FFFF9876543210E<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Fine.  The next step is TripleDES encryption of the string ‚ÄúFFFF9876543210E0‚Äù with the BDK key of 24 bytes ‚Äú0123456789ABCDEFFEDCBA98765432100123456789ABCDEF‚Äù.  The result of this encryption will be the left side of the IPEK. <br><br><pre> <code class="hljs">6AC292FAA1315B4D</code> </pre><br>  If you remember, I mentioned that a slightly modified version of the BDK will be used to get the right part.  Thus, to do this, we need to take the original 16 byte BDK "0123456789ABCDEFFEDCBA9876543210" and perform the XOR using the following mask "C0C0C0C000000000C0C0C0C000000000".  It looks like a completely arbitrary mask, but alas, it is necessary to get the right IPEK. <br><br><pre> <code class="hljs perl"> <span class="hljs-number"><span class="hljs-number">01234567</span></span>89ABCDEFFEDCBA987654321<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> C0C0C0C000000000C0C0C0C00000000<span class="hljs-number"><span class="hljs-number">0</span></span> = C1E385A789ABCDEF3E1C7A587654321<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  We will do the same thing that we did with the key for the left side, take the upper 8 bytes and add them to the end, we get the next 24 byte key. <br><br><pre> <code class="hljs">C1E385A789ABCDEF3E1C7A5876543210C1E385A789ABCDEF</code> </pre><br>  Next, take the upper 8 bytes of KSN with a zero counter (which we calculated earlier) and encrypt it with the help of TripleDES with the key that we just calculated.  This will give us the right IPEK register, we get the next 16 byte IPEK (I separated the left and right parts for clarity). <br><br><pre> <code class="hljs">6AC292FAA1315B4D 858AB3A3D7D5933A</code> </pre><br><h4>  Calculation of session keys </h4><br>  We have IPEK.  Next, we need to get from IPEK a unique key for a separate rental card (session key).  To get it, a certain subroutine is used, let's call it a black box, the purpose of which is to return a separate session key.  What is happening in the black box is not our concern yet.  Right now we will look at the input of this subroutine. <br><br>  Our black box has two entrances.  One is the key and the second is the string to encrypt.  The string is a modified KSN. <br><br>  If you remember, the lower 21 bits of KSN contain a count of the number of card rentals on the device.  We will transfer the modified KSN to the subroutine as many times as the units in the binary representation of the counter.  The key that is transmitted with the modified KSN is IPEK at the first iteration, and at the next iterations it will be the key obtained from the black box at the previous iteration. <br><br>  Let's start by changing the KSN.  To begin, we will take the lower 8 bytes of KSN and reset the counter value in KSN.  This can be done by masking the KSN using the following mask. <br><br><pre> <code class="hljs pgsql"> FFFF9876543210E00008 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span>FFFFFFFFFFE00000 = <span class="hljs-number"><span class="hljs-number">00009876543210E00000</span></span></code> </pre><br>  We will use the resulting value to calculate each message sent to the black box.  In our example with a counter equal to 8, we must transfer to the black box the binary representation of the number 8 (1000).  For demonstration, assume that the counter has a more complex value of 10 (1010). <br><br>  We will extract a set of binary numbers from the counter.  In our case, for the number 10 (1010) there will be two binary numbers: 1000 and 0010. Have you caught the scheme?  We get a set of numbers representing each binary unit of the number 10. <br><br>  Next, we take the first number and apply the OR operation with KSN, which has the counter reset to zero, as shown earlier (note that the hexadecimal representation of the first number will be 0008). <br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">9876543210E00000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">0000000000000008</span></span> = <span class="hljs-number"><span class="hljs-number">9876543210E00008</span></span></code> </pre><br>  Now we transfer IPEK as a key and just modified KSN to a black box.  The black box will return the new key.  This is the first session key (presented in hexadecimal): "27f66d5244ff62e1aa6f6120edeb4280". <br><br>  Next, repeat the process with the following binary number, calculated earlier, 2 (0010).  This time, we will use the first session key, which we have just received and we will calculate the new modification of KSN. <br><br>  To calculate the new KSN modification, we will perform the OR operation with the latest modification obtained: 9876543210E00008. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">9876543210E00008</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">0000000000000002</span></span> = <span class="hljs-number"><span class="hljs-number">9876543210E0000</span></span>A</code> </pre><br>  Now we will transfer our new key ‚Äú27f66d5244ff62e1aa6f6120edeb4280‚Äù and the new modification KSN ‚Äú9876543210E0000A‚Äù to the black box and get another future key, ‚Äú6cf2500a22507c7cc776ceadc1e33014‚Äù.  This is the session key for our device with a counter of 10. <br><br>  However, our real counter was 8, and we calculated the real session key ‚Äú27F66D5244FF62E1AA6F6120EDEB4280‚Äù at the first stage. <br><br>  The last operation we have to do with the obtained value is the final transformation of the key, with which we will decrypt the data.  We must perform the XOR key with the mask "00000000000000FF00000000000000FF". <br><br><pre> <code class="hljs vbscript"> <span class="hljs-number"><span class="hljs-number">27</span></span>F66D5244FF62E1AA6F6120EDEB4280 <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span> <span class="hljs-number"><span class="hljs-number">00000000000000</span></span>FF00000000000000FF = <span class="hljs-number"><span class="hljs-number">27</span></span>F66D5244FF621EAA6F6120EDEB427F</code> </pre><br>  This is the key that is required to decrypt the data. <br><br><h4>  Black box </h4><br>  I called the black box an algorithm that calculates session keys.  The black box accepts the current session key, which I denote <i>current_sk</i> , and the KSN modification, denoted <i>ksn_mod</i> . <br><br>  If at the beginning the assumption that IPEK obtained above was transmitted as <i>current_sk</i> , and <i>ksn_mod</i> was equal to the value "9876543210E00008", which we calculated above. <br><br>  First we need to take <b>current_sk</b> , get the upper 8 bytes and move them 64 bits to the right, we get ‚Äú6AC292FAA1315B4D‚Äù.  This can be obtained using a bit mask. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">6</span></span>AC292FAA1315B4D858AB3A3D7D5933A <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> FFFFFFFFFFFFFFFF0000000000000000 = <span class="hljs-number"><span class="hljs-number">6</span></span>AC292FAA1315B4D0000000000000000</code> </pre><br>  Here we need to shift this value 64 bits to the right to get "6AC292FAA1315B4D".  Let's call it <i>left_key</i> (looks like the left side of <i>current_sk</i> ). <br><br>  Next, we get 8 low bytes <i>current_sk</i> , using a mask. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">6</span></span>AC292FAA1315B4D858AB3A3D7D5933A <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>FFFFFFFFFFFFFFFF = <span class="hljs-number"><span class="hljs-number">0000000000000000858</span></span>AB3A3D7D5933A</code> </pre><br>  Let's call this value (you guessed it) <i>right_key</i> .  Next, take the <i>right_key</i> and execute the XOR with <i>ksn_mod</i> "9876543210E00008". <br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">858</span></span>AB3A3D7D5933A <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">9876543210E00008</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>DFCE791C7359332</code> </pre><br>  This value is called message.  Next, take a message and encrypt it using DES (simple DES).  We will transmit the message algorithm to DES as data to be encrypted and <i>left_key</i> , which will encrypt the key.  The result is ‚Äú2FE5D2833A3ED1BA‚Äù.  Now you need to XOR this value and <i>right_key</i> . <br><br><pre> <code class="hljs vbscript"> <span class="hljs-number"><span class="hljs-number">2</span></span>FE5D2833A3ED1BA <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span> <span class="hljs-number"><span class="hljs-number">858</span></span>AB3A3D7D5933A = AA6F6120EDEB4280</code> </pre><br>  This value is the lower 8 bytes of our session key!  Now we need to repeat the operations just described with other inputs.  This time we take <i>current_sk</i> and XOR it with ‚ÄúC0C0C0C000000000C0C0C0C000000000‚Äù.  As far as I can judge this value is arbitrary, but it is part of the ANSI standard, so you just have to believe my words. <br><br><pre> <code class="hljs vbscript"> <span class="hljs-number"><span class="hljs-number">6</span></span>AC292FAA1315B4D858AB3A3D7D5933A <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span> C0C0C0C000000000C0C0C0C000000000 = AA02523AA1315B4D454A7363D7D5933A</code> </pre><br>  If we take the value ‚ÄúAA02523AA1315B4D454A7363D7D5933A‚Äù and substitute it for the <i>current_sk</i> in the operation described above, we get ‚Äú27F66D5244FF62E1‚Äù.  This is the upper 8 bytes of our session key.  Combining them we get "27F66D5244FF62E1AA6F6120EDEB4280". <br><br><h4>  Conclusion </h4><br>  I hope I explained the DUKPT scheme and how it relates to the effectiveness of magnetic track scanners.  Waiting for corrections and questions in the comments section. </div><p>Source: <a href="https://habr.com/ru/post/254109/">https://habr.com/ru/post/254109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254097/index.html">How to avoid null pointer dereferencing, using the example of a single patch in the Linux kernel</a></li>
<li><a href="../254099/index.html">Wristwatches based on Arduino, created on a 3D printer in one Saturday evening</a></li>
<li><a href="../254101/index.html">Nutanix Discovery Kit - "Datacenter in a Box", more accessible than ever</a></li>
<li><a href="../254103/index.html">Webix 2.3. Spring update</a></li>
<li><a href="../254105/index.html">TARS, make the level of frontend-routine 0%</a></li>
<li><a href="../254111/index.html">Winchester speaker</a></li>
<li><a href="../254113/index.html">How to create and earn SaaS | Part 16 | Own mobile network WI-FI</a></li>
<li><a href="../254115/index.html">Binding and xaml markup extensions using localization as an example</a></li>
<li><a href="../254117/index.html">Servers for business: energy efficiency matters</a></li>
<li><a href="../254119/index.html">The warden for the freelancer: choose the system of accounting of working time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>