<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ivan Tulup: asynchronism in JS under the hood</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Are you familiar with Ivan Tulup? Most likely, yes, you just don‚Äôt know what kind of person it is and that you need to take great care of the state of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ivan Tulup: asynchronism in JS under the hood</h1><div class="post__text post__text-html js-mediator-article">  Are you familiar with Ivan Tulup?  Most likely, yes, you just don‚Äôt know what kind of person it is and that you need to take great care of the state of its cardiovascular system. <br><br>  About this and how asynchrony works in JS under the hood, how the Event Loop works in browsers and in Node.js, are there any differences and maybe similar things were told by <strong>Mikhail Bashurov</strong> ( <a href="https://habr.com/users/saitonakamura/" class="user_link">SaitoNakamura</a> ) in his report on RIT ++  We are pleased to share with you the decoding of this informative presentation. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>About Speaker:</strong> Mikhail Bashurov - fullstack web developer at JS and .NET from Luxoft.  He likes beautiful UI, green tests, transpilation, compilation, compiler allowing technique and improved dev experience. <br><br>  <strong>From the editor:</strong> Mikhail's report was accompanied not just by slides, but by a demo project in which you can click on the buttons and see for yourself the execution of the shoes.  The best option would be to open the <a href="https://saitonakamura.github.io/ivan-tooloop/">presentation</a> in the adjacent tab and periodically refer to it, but the text will be given links to specific pages.  And now we pass the word to the speaker, enjoy reading. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Grandpa Ivan Tulup </h2><br>  I had a candidacy for Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  But I decided to go a more conformist way, so meet - grandfather Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  Actually, you only need to know about two things: <br><br><ol><li>  He likes to play cards. </li><li>  He, like all people, has a heart, and it beats. </li></ol><br><h2>  Facts About Heart Attack </h2><br>  You may have heard that cases of heart disease and mortality from them have recently become more frequent.  Probably the most common heart disease is a heart attack, that is, a heart attack. <br><br>  What is interesting about heart attack? <br><br><ul><li>  Most often it occurs on Monday morning. </li><li>  Lonely people have a higher risk of having a heart attack.  Here, perhaps, the matter is solely in correlation, and not in causation.  Unfortunately (or fortunately), however, it is. </li><li>  Ten conductors died of a heart attack while conducting (apparently very nervous work!). </li><li>  A heart attack is a necrosis of the heart muscle caused by a lack of blood flow. </li></ul><br>  We have a coronary artery that supplies blood to the muscle (myocardium).  If the blood starts to get sick of it, the muscle gradually dies off.  Naturally, this has a very negative effect on the heart and on its work. <br><br>  Grandfather Ivan Tulup also has a heart, and it beats.  But our heart pumps blood, and the heart of Ivan Tulup pumps our code and our tasks. <br><br><h2>  Task: a large circle of blood circulation <br></h2><br>  What is task?  What could be the browser in general?  Why are they even needed? <br><br>  For example, we execute code from a script.  This is one heartbeat, and now we have blood flow.  We clicked on the button and subscribed to the event ‚Äî the event handler was spat out ‚Äî the Callback that we sent.  Put setTimeout, Callback worked - one more task.  And so in parts, one heartbeat is one task. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  There are many different sources of taskes, according to the specification of a huge number.  Our heart continues to beat, and while it beats, we are fine. <br><br><h3>  Event Loop in the browser: a simplified version <br></h3><br>  This can be represented in a very simple diagram. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  There is a task, we performed it. </li><li>  Then we perform the browser render. </li></ul><br>  But in fact, this is not necessary, because in some cases the browser may not render the render between two tasks. <br><br>  This can happen, for example, if the browser can decide to group several timeouts or multiple scrolling events.  Or at some point something goes wrong, and the browser decides instead of 60 fps (the usual frame rate so that everything goes cool and smooth) to show 30 fps.  Thus, he will have much more time to execute your code and other useful work, he will be able to perform several tasks. <br><br>  Therefore, the render is actually not necessarily performed after each task. <br><br><h3>  Taski: classification <br></h3><br>  There are two types of potential operations: <br><br><ol><li>  I / O bound; </li><li>  CPU bound. </li></ol><br>  <strong>CPU bound</strong> is our useful work that we do (we consider, display, etc.) <br><br>  <strong>I / O bound</strong> - these are the points at which we can divide our tasks.  It may be: <br><br><ul><li>  Time-out. </li></ul>  We did setTimeout 5000 ms, and we just wait for these 5000 ms, and we can do other useful work.  Only when this time has passed, we will get a Callback, and do some work in it. <br><br><ul><li>  xhr / fetch. </li></ul>  We went to the network.  While we are waiting for a response from the network, we are just waiting, but we can also do something useful. <br><br><ul><li>  Network (Bd). </li></ul>  Or, for example, we go to Network BD.  We are talking about Node.js, among other things, and if we want to go somewhere to the network from Node.js please - this is the same potential I / O bound task (input / output). <br><br><ul><li>  File. </li></ul>  Read the file - potentially it‚Äôs not a CPU bound task at all.  In Node.js, it runs in the thread pool due to the slightly crooked API of Linux, to be honest. <br><br>  Then CPUbound is: <br><br><ul><li>  For example, when we do a for of / for loop (;;) or through an array with some additional methods, we go through: filter, map, etc. </li><li>  JSON.parse or JSON.stringify, that is, serialization / deserialization of messages.  This is all done on the CPU, we can‚Äôt just wait until all of this is done magically somewhere. </li><li>  Counting hashes, that is, for example, mining crypts. </li></ul><br>  Of course, the crypt can be mine on the GPU, but I think - the GPU, the CPU - you understand this analogy. <br><br><h3>  Task: arrhythmia and thrombus </h3><br>  In the end, it turns out that our heart beats: it performs one TASK, the second, the third, until we do something wrong.  For example, we go through an array of 1 million elements and count the sum.  It would seem that it is not so difficult, but it can take considerable time.  If we constantly occupy tangible time without releasing the task, our render cannot be performed.  He hangs in this task, and that's it - the arrhythmia begins. <br><br>  I think everyone understands that arrhythmia is a rather unpleasant heart disease.  But you can still live with him.  What happens if you put a task that just hangs the entire event loop in an endless loop?  You put a thrombus in the coronary or some other artery, and everything will be very sad.  Unfortunately, our grandfather Ivan Tulup will die. <br><br><h3>  That grandfather Ivan died ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  For us, this means that the entire tab will freeze at all - you will not be able to click on anything, and then Chrome will say: ‚ÄúAw, Snap!‚Äù <br><br>  This is even worse than the bugs on the website when something went wrong.  But if everything is hanging at all, moreover, probably, the CPU has loaded and everything has hung up for the user, then he will most likely never go to your site. <br><br>  Therefore, the idea is this: we have a task, and we do not need to hang out for a very long time in this task.  We need to quickly release it so that the browser, if anything, can render (if it wants).  If you do not want - fine, dance! <br><br><h2>  Philip Roberts Demo: Loupe by Philip Roberts <br></h2><br>  Consider <a href="http://latentflip.com/loupe/%3Fcode%3DJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIGNvbnNvbGUubG9nKCdjbGljaycpOyAgICAKfSk7CgpzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXQoKSB7CiAgICBjb25zb2xlLmxvZygidGltZW91dCIpOwp9LCA1MDAwKTsKCmNvbnNvbGUubG9nKCJIZWxsbyB3b3JsZCIpOw%253D%253D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D">an example</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(‚ÄúHello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  The point is this: we have a button, we subscribe to it (addEventListener), we call Timeout for 5 s and write ‚ÄúHello, world!‚Äù To console.log, write Timeout to setTimeout, we write Click on onClick. <br><br>  What will happen if we run it and repeatedly click on the button - when will Timeout actually be executed?  Let's see the demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The code starts to execute, gets on the stack, Timeout goes.  Meanwhile, we clicked on the button.  At the bottom of the queue added a few events.  While the Click is running, Timeout is waiting, although 5 seconds has passed. <br><br>  Here onClick runs quickly, but if you put a longer task, then in general everything will hang, as has been clarified earlier.  This is a very simplified example.  There is one line here, but in browsers this is actually not the case. <br><br>  In what order are the events executed - what does the HTML specification say about this? <br><br>  She says the following: we have 2 concepts: <br><br><ol><li>  task source; </li><li>  task queue. </li></ol><br>  Task source is a kind of task.  This can be a user interaction, that is, onClick, onChange is something the user interacts with;  or timers, that is, setTimeout and setInterval, or PostMessages;  or generally completely wild Canvas Blob Serialization types task source is also a separate type. <br><br>  The specification says that for the same task source, tasks will be guaranteed to be executed in the order of addition.  For everything else, nothing is guaranteed, because the task queue can be an unlimited number.  The browser itself decides how many they will be.  Using the task queue and creating them, the browser can prioritize certain tasks. <br><br><h3>  Browser Priorities and Task Queues <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Imagine that we have 3 queues: <br><br><ol><li>  user interaction; </li><li>  timeouts; </li><li>  post messages. </li></ol><br>  The browser starts to get hacks from these queues: <br><br><ul><li>  First, he takes <strong>onFocus</strong> user interaction - this is very important - one heartbeat from us has gone. <br></li><li>  Then he takes <strong>postMessages</strong> - well, postMessages is pretty high priority, cool! <br></li><li>  The next, <strong>onChange,</strong> is also a priority from user interaction. <br></li><li>  Further <strong>onClick</strong> goes.  The user interaction queue is over, we brought the user all that is needed. <br></li><li>  Then we take <strong>setInterval</strong> , we add postMessages. <br></li><li>  <strong>setTimeout will be executed only the most recent</strong> .  He was somewhere at the end of the lineup. <br></li></ul><br>  This again is also a very simplified example, and, unfortunately, <strong>no one can guarantee how it will work in browsers</strong> , because they themselves decide it all.  You need to test it yourself if you want to find out what it is. <br><br>  For example, postMessages are more priority than setTimeout.  You may have heard about such a thing as setImmediate, which, for example, in IE browsers was only native.  But there are polyfiles that are mostly not based on setTimeout, but on creating a postMessages channel and subscribing to it.  This works generally faster because browsers prioritize this. <br><br>  Well, these tasks are done here.  At what point do we finish performing our task and understand that we can take the next one, or what can we render? <br><br><h3>  Stack </h3><br>  A stack is a simple data structure that works on the principle of "last in - first out", i.e.  ‚ÄúI put the last one - you get it first‚Äù <strong>.</strong>  The closest, probably the real equivalent is a deck of cards.  Therefore, our grandfather Ivan Tulup loves to play cards. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  Above is an example in which there is some code, the same example can be poked into the <a href="https://saitonakamura.github.io/ivan-tooloop/">presentation</a> .  In some place we call handleClick, enter console.log, call showPopup and window.  confirm.  Let's form a stack. <br><br><ul><li>  So, first we take handleClick and put the call to this function on the stack - great! </li><li>  Then we go into his body and execute it. </li><li>  We put console.log on the stack, and execute it right there, because there is everything to execute it. </li><li>  Next, we put showConfirm - this is a function call - great. </li><li>  Put the functions in the stack - put her body, that is, window.confirm. </li></ul><br>  We have nothing more - we do it.  A window will pop up: ‚ÄúAre you sure?‚Äù, Click on ‚ÄúYes‚Äù, and everything will leave the stack.  Now we have finished the showConfirm body and the handleClick body.  Our stack is cleared and you can proceed to the next task.  Question: well, I now know that it is necessary to break it all into small pieces.  How can I, for example, do this in the most elementary case? <br><br><h3>  Splitting an array into chunks and their asynchronous processing </h3><br>  Let's look at the most "in the forehead" example.  Immediately I warn you: please do not try to repeat this at home - it will not compile. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  We have a large, large array, and we want to calculate something on it, for example, parse some binary data.  We can just break it into chunks: process this piece, this and this.  We choose the size of the chunk, say, 10 thousand elements, we consider how many chunks we will have.  We have the parseData function, which is included in the CPU bound and can really do something heavy.  Then we divide the array into chunks, setTimeout (() =&gt; parseData (slice), 0). <br><br>  In this case, the browser will again be able to prioritize User interaction and render the render in between.  So at least you let go of your Event Loop, and it continues to work.  Your heart keeps beating, and that's good. <br><br>  But this is really a very "in the forehead" example.  Now browsers have many APIs that will help to do this in a more specialized way. <br><br>  In addition to setTimeout and setInterval, there are APIs that go beyond the limits of tasks, such as, for example, requestAnimationFrame and requestIdleCallback. <br><br>  Probably many people are familiar with <strong>requestAnimationFrame</strong> , and even use it already.  It is performed before the render.  Its charm is that, firstly, it tries to run every 60 fps (or 30 fps), secondly, this is all done immediately before creating the CSS Object Model, etc. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Therefore, even if you have multiple requestAnimationFrame, they will actually group all the changes, and the frame will be complete.  In the case of setTimeout, of course, you cannot receive such a guarantee and guarantee it.  One setTimeout will change one thing, another another, and between this a render may slip through - you will have jerking of the screen or something else.  RequestAnimationFrame for this fits perfectly. <br><br>  In addition, there is a <strong>requestIdleCallback.</strong>  Maybe you heard that it is used in React v16.0 (Fiber).  RequestIdleCallback works in such a way that if the browser understands that it has time between frames (60 fps) to do something useful, and at the same time they did everything - did the task, did requestAnimationFrame - everything seems to be cool, then can give out small quanta, say, 50 ms for you to do something (IDLE mode). <br><br>  It is not on the diagram above, because it is not in a particular place.  The browser can decide to place it before the frame, after the frame, between the requestAnimationFrame and the render, after the task, before the task.  No one can guarantee this. <br><br>  It‚Äôs guaranteed that if you have work that is not related to changing the DOM (because then requestAnimationFrame is animation and so on), while it‚Äôs not super priority, but tangible, requestIdleCallback is your way out. <br><br>  So, if we have a long CPU bound operation, then we can try to break it apart. <br><br><ul><li>  If this is a DOM change, then use <strong>requestAnimationFrame.</strong> <br></li><li>  If this is a non-priority, short-lived and not hard task that will not burden the CPU too much, then <strong>requestIdleCallback.</strong> <br></li><li>  If we have a big powerful task that needs to be performed constantly, then we go beyond the Event Loop and use WebWorkers.  There is no other way out. <br></li></ul><br>  <strong>Browser Tasking Results:</strong> <br><br><ol><li>  Split everything up into small tasks. </li><li>  There are many types of tasks. </li><li>  Tasks are prioritized for these types through specification queues. </li><li>  Much is solved by browsers, and the only way to understand how it works is just to check, run this or that code. </li><li>  But the specification is not always respected! </li></ol><br>  The problem is that our Ivan Tulup is an old grandfather, because the implementations of the Event Loop in browsers are also very old.  They were created before the specification was written, so the specification, unfortunately, is respected as long as.  Even if you read that the specification should be so, no one guarantees that all browsers have supported it.  So be sure to check in browsers how it actually works. <br><br>  Grandfather Ivan Tulup in browsers is a man of little predictable, with some interesting features, we must remember this. <br><br><h2>  Terminator Santa: Loop Mascot in Node.js <br></h2><br>  Node.js is more like someone like that. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Because on the one hand it is the same grandfather with a beard, but at the same time everything is distributed in phases and clearly spelled out where what is being done. <br><br>  <strong>Phases of the Event Loop in Node.js:</strong> <br><br><ul><li>  timers; <br></li><li>  pending callback; <br></li><li>  idle, prepare; <br></li><li>  poll; <br></li><li>  check; <br></li><li>  close callbacks. <br></li></ul><br>  Everything except the last is not very clear what it means.  The phases have such strange names, because under the hood, as we already know, we have Libuv in order to rule everyone: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> event ports. <br></li></ul><br>  Thousands of them all! <br><br>  In addition, Libuv also provides the same Event Loop.  There are no specifics of Node.js in it, but there are phases, and Node.js simply uses them.  But for some reason she took the names from there. <br><br>  Let's see what each phase actually means. <br><br><h4>  Phase Timers performs: <br></h4><br><ul><li>  Callback ready timers; <br></li><li>  setTimeout and setInterval; <br></li><li>  But <strong>NOT</strong> setImmediate is another phase. <br></li></ul><br><h4>  Phase pending callbacks <br></h4><br>  Prior to this, the documentation phase was called I / O callbacks.  Most recently, this documentation has been corrected, and it has ceased to contradict itself.  Prior to this, in one place it was written that I / O callbacks are executed in this phase, in another - that in the poll phase.  But now everything is written there clearly and well, so read the documentation - something will become much more understandable. <br><br>  In the pending callback phase, callbacks from some system operations (TCP error) are executed.  That is, if in Unix there is an error in the TCP-socket, in this case, he wants not to throw it out right away, but in a callback that will just be executed during this phase.  That's all we need to know about her.  It is practically not interesting to us. <br><br><h4>  Phase Idle, prepare <br></h4><br>  In this phase, we cannot do anything at all, so we forget about it in principle. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Phase poll <br></h4><br>  This is the most interesting phase in Node.js, because it does the main useful work: <br><br><ul><li>  Performs I / O callbacks (not pending callback phase!). </li><li>  Waiting for events from I / O; </li><li>  It's cool to do setImmediate; </li><li>  No timers; </li></ul><br>  Looking ahead, setImmediate will be executed at the next check phase, that is, guaranteed before the timers. <br><br>  Also, the poll phase controls the Event Loop flow.  For example, if we have no timers, no setImmediate, that is, no one did the timer, setImmediate did not call, we just block in this phase and wait for an event from the I / O if something comes to us, if there are any callbacks , if we subscribed to something. <br><br>  How is a non-blocking model implemented?  For example, with the same Epoll, we can subscribe to an event ‚Äî we open the socket and wait for something written in it.  In addition, the second argument is timeout, i.e.  we will wait for Epoll, but if the timeout ends, and the event from the I / O does not come, then it will exit the timeout.  If we receive an event from the network (someone writes in the socket), it will come. <br><br>  Therefore, the poll phase gets from the heap (a heap is a data structure that allows for a well-sorted retrieval and delivery) of the earliest callback, takes its timeout, writes down at this timeout and releases everything.  Thus, even if no one in our socket writes, timeout will work, return to the poll phase and work will continue. <br><br><blockquote>  It is important to note that in the poll phase there is a limit on the number of callbacks at a time. <br></blockquote><br>  Sadly, in other phases it is not.  If you add 10 billion timeout, you add 10 billion timeout.  Therefore, the next phase is the check phase. <br><br><h4>  Phase check </h4><br>  Here setImmediate is executed.  The phase is beautiful because the setImmediate, called in the poll phase, is guaranteed to execute earlier than the timer.  Because the timer will only be on the next tick at the very beginning, and from the poll phase earlier.  Therefore, we can not be afraid of competition with other timers and use this phase for those things that we don‚Äôt want for some reason to perform in a callback. <br><br><h4>  Phase close callbacks </h4><br>  This phase does not perform all of our callback socket closures and other types: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, ‚Ä¶).</code> </pre><br>  She executes them only if this event took off unexpectedly, for example, someone at the other end sent: ‚ÄúEverything ‚Äî close the socket ‚Äî go here, Vasya!‚Äù Then this phase will work, because the event is unexpected.  But we are not particularly affected. <br><br><h3>  Invalid asynchronous processing of chunks in Node.js </h3><br>  What will happen if we have the same pattern that we took in browsers with setTimeout, put it on Node.js - that is, we divide the array into chunks; for each chunk we will make setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Do you think there are any problems with this? <br><br>  I already ran a little ahead when I said that if we add 10 thousand timeout (or 10 billion!), There will be 10 thousand timers in the queue, and he will get them and execute - there is no protection against this: get - execute, get - perform and so on to infinity. <br><br>  Only the poll phase, if we constantly receive an event from I / O, all the time in the socket, someone writes something, so that we at least can set the timers and setImmediate, have protection for the limit, and system-dependent.  That is, it will be different on different operating systems. <br><br>  Unfortunately, other phases, including timers and setImmediate, <strong>do not have such protection.</strong>  Therefore, if you do the same as in the example, everything will hang on you and it won't take very long to reach the poll phase. <br><br>  How do you think something will change if we replace setTimeout (() =&gt; parseData (slice), 0) with setImmediate (() =&gt; parseData (slice))?  - Naturally, no, there is also no protection in the check phase. <br><br>  To solve this problem, you can call <strong>recursive processing</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  The bottom line is that we took the function parseData and wrote its recursive call, but not just ourselves, but through setImmediate.  When you call it in the setImmediate phase, then it hits the next tick, and not the current one.  Therefore, it will release the Event Loop, it will go further in a circle.  That is, we have recursiveAsyncParseData, where we pass a certain index, fetch a chunk on this index, parse it - and then put the setImmediate in the queue with the next index.  He will get us to the next tick, and we can thus recursively handle the whole thing. <br><br>  True, the problem is that it is still some kind of CPU bound task.  Perhaps she will still somehow weigh and take time in the Event Loop.  Most likely, you want your Node.js to have a pure I / O bound. <br>  Therefore, it is better to use some other things for this, for example, <strong>process fork / thread pool.</strong> <br><br>  Now we know about Node.js that: <br><br><ul><li>  everything is distributed in phases - well, we clearly know it; <br></li><li>  there is protection from too long poll-phase, but not the rest; <br></li><li>  recursive processing patterns can be applied in order not to block the Event Loop; </li><li>  But it is better to use process fork, thread pool, child process </li></ul><br>  You should also be careful with thread pool, because Node.js and so many things run there, in particular, DNS resolving, because for some reason, the DNS function DNS is not asynchronous.  Therefore, it is necessary to execute it in ThreadPool.  On Windows, fortunately, not the case.  But there and files can be read asynchronously.  In Linux, unfortunately, is impossible. <br><br>  In my opinion, the standard limit is 4 processes in a ThreadPool.  Therefore, if you actively do something there, it will compete with everyone else - with fs and others.  You can consider increasing the ThreadPool, but also very carefully.  Therefore, read something on this topic. <br><br><h2>  Microtasks: a small circle of blood circulation </h2><br>  We have Tasks in Node.js and Tasks in browsers.  You may have already heard about microtasks.  Let's see what it is and how they work, and start with browsers. <br><br><h3>  Microtasks in browsers <br></h3><br>  To understand how microtasks work, let's turn to the whatWg standard Event Loop algorithm, that is, let's go into the specification and see how it all looks. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Translating into human language, it looks like this: <br><br><ul><li>  We take free tuska from our turn, </li><li>  We carry it out </li><li>  We execute microtask checkpoint - OK, we still do not know what it is, but remember. </li><li>  Update the rendering (if necessary), and go back to square one. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  They are performed in the place indicated in the diagram, and in several other places that we will soon find out.  That is, the task is over, microtasks are executed. <br><br><h3>  Sources microtasks </h3><br><ul><li>  <strong>Promise.then.</strong> </li></ul><br>  The important thing is not Promise itself, but Promise.then.  That callback that was placed in the then is a microtask.  If you called 10 then - you have 10 micro-strokes, 10 thousand then - 10 thousand micro-strokes. <br><br><ul><li>  <strong>Mutation observer.</strong> <br></li><li>  <strong>Object.observe</strong> , which is deprecated and not needed by anyone. <br></li></ul><br>  How many people use the mutation observer? <br><br>  I think that few use the Mutation observer.  Most likely, Promise.then is used more, therefore we will consider it in the example. <br><br>  <strong>Features of microtask checkpoint:</strong> <br><br><ul><li>  <strong>We carry out everything</strong> - this means that we carry out all the microtasks that we have in line to the end.  We do not let go - just everything that we have, we take and we do - they must be micro, right? </li><li>  You can still generate new microtasks in the process, and they will be executed at the same microtask checkpoint. </li><li>  What else is important - they are executed not only after the execution of the task, but also after clearing the stack. </li></ul><br>  This is an interesting point.  It turns out that you can generate new microtasks and we will execute them all to the end.  What can it lead us to? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  We have two hearts.  The first heart I animated JS animation, and the second - CSS-animation.  There is another great feature called starveMicrotasks.  We call Promise.resolve, and then we put the same function in then. <br>  Look in the <a href="https://saitonakamura.github.io/ivan-tooloop/">presentation for</a> what happens if you call this function. <br><br>  Yes, the heart of JS will stop, because we add a micro-drag, and then we add a micro-drag in it, and then we add a micro-drag in it ... And so endlessly. <br><br>  That is, a recursive call microtasks hang everything.  But, it would seem, I have everything asynchronous!  Should be let go, I called setTimeout there.  Not!  Unfortunately, you need to be careful with microtasks, so if you somehow use a recursive call, be careful - you can block everything. <br><br>  In addition, as we remember, microtasks are executed at the end of stack cleaning.  We remember what a stack is.  It turns out that as soon as we got out of our code, the setTimeout callback was executed ‚Äî that's all ‚Äî the microtasks went right away.  This can lead to interesting side effects. <br><br>  Consider <a href="https://saitonakamura.github.io/ivan-tooloop/">an example</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  There is a button and a gray container in which it lies.  We subscribe to click and buttons, and container.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Events, as we know, float, that is, they will appear here and there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In handlers, we do 2 things:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .then in which we enter console.log ('RO') </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the handler itself, we then enter "FUS", and in the handler on the container - "DAH!" (When we have an event pops up). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you think that we will appear in the console? </font><font style="vertical-align: inherit;">In these messages there is a small hint, and oddly enough, it will be displayed ‚ÄúFUS RO DAH!‚Äù Excellent! </font><font style="vertical-align: inherit;">Everything works as we expected. </font></font><br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's consider exactly the same example, but earlier we clicked on the button and the browser called the handler for us, but now we will programmatically call this click. </font><font style="vertical-align: inherit;">It would seem - what's the difference. </font><font style="vertical-align: inherit;">Do you think something will change or not? </font></font><br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course change! </font><font style="vertical-align: inherit;">Because otherwise I would not ask this question.</font></font><br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  Let's see why this happens. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have our first code, which has a queue of microtasks, and we have a stack. </font><font style="vertical-align: inherit;">You can see how this is all done </font></font><a href="https://saitonakamura.github.io/ivan-tooloop/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the first case</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first time we first go into our handler - buttonHandleClick, put it on the stack. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we add Promise.resolve. </font><font style="vertical-align: inherit;">He, too, falls on the stack. </font><font style="vertical-align: inherit;">We executed it, and he added the microretk console.log ('RO') to the queue. </font><font style="vertical-align: inherit;">We did it.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we enter and process console.log ('FUS'). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the buttonHandleClick almost ended and the stack was cleared. </font><font style="vertical-align: inherit;">We can get our microdog and execute it.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the event pops up, we go to the second handler (divHandleClick) and execute its code, display ‚ÄúDAH!‚Äù. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HandleClick is over. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would seem that everything is cool and everything is logical. </font><font style="vertical-align: inherit;">Why is the next example wrong with us? </font><font style="vertical-align: inherit;">Let's follow the execution flow </font></font><a href="https://saitonakamura.github.io/ivan-tooloop/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the second case</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running button.click (). </font><font style="vertical-align: inherit;">We put it on the stack.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go to button HandleClick. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run Promise.resolve with then. </font><font style="vertical-align: inherit;">He adds a microtask to the queue, Promise.resolve is executed.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, go to console.log and enter "FUS". </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We have finished the buttonHandleClick body and exit it, remove it from the stack. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But our synchronous method (click) is not over, because there are still other handlers there, and the stack is not cleared. Therefore, we go to divHandleClick and, of course, execute console.log ('DAH!') Executed. And only after that we have cleared the stack, and we can execute our microduck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is very unpleasant, for example, when we call button.click in all sorts of tests. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this, it is easy to shoot yourself in the foot. Event popup is used, for example, in modal windows. It often happens that a modal window is closed if you click it outside.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is usually implemented as follows: we subscribe to the document (click) and the modal window container itself (also to click). If we clicked somewhere and it reached the modal window, we stopPropagation. If not, then it comes to the document, a click pops up, we understand that we have clicked somewhere outside, close the window. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if some evil genius (or junior programmer) tries to build an interesting logic - like we click on the ‚ÄúConfirm‚Äù button, we have a promise that resolves, and then in then we decide whether to close something or not . In this case, it turns out that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there will be one behavior in the interface, and another in the tests</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: either the test will fall, and the interface will not fall, or vice versa. </font><font style="vertical-align: inherit;">It will be very unpleasant. </font><font style="vertical-align: inherit;">Therefore, it is better not to be tied to this behavior at all, not to try to invent something on top of this and make it as simple as possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now most browsers (I tested 4) work well with microtasks, and this is all done correctly in the right order. </font><font style="vertical-align: inherit;">But before that it was not, and no one, unfortunately, can guarantee that there will be no bugs and any additional tricky cases. </font><font style="vertical-align: inherit;">So it is better to do simply and not be tied to this implementation. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On microtasks in browsers, we learned that:</font></font></strong> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With their help, you can block the Event Loop. </font></font> It is unpleasant. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> They are executed every time after the task and every time the stack is empty. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, in fact, in the middle of the task, they can also be executed, because the stack has cleared. </font><font style="vertical-align: inherit;">A click is one task, but the stack is cleared in the middle of it, the microtasks come out.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Microtasks in Node.js </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The microtasks in Node.js are Promise.then and process.nextTick. </font><font style="vertical-align: inherit;">And they are also executed every time the stack is empty - not at the end of the phase. </font><font style="vertical-align: inherit;">Just every time the phase ends, strangely enough, the stack is empty.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> process.nextTick </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good, but why do we need process.nextTick if there is setImmediate? </font><font style="vertical-align: inherit;">Why do we need microtasks in Node.js in general? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at an example. </font><font style="vertical-align: inherit;">We have a createServer function, it creates an EventEmitter, then returns us an object that has a listen method (subscribe to the port), and this method emit our event.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we call the function, create the server, listen to port 8080, subscribe to the listening event, and write something elementary in console.log. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's think about how this code is actually executed, and if there is any problem with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We execute the createServer function, and it returns an object. At this object we call the listen method, in which we already emit an event, but we have not yet had time to subscribe to it. We still have the last line is not even fulfilled. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we subscribed to the event, but did not receive it.</font></font> What can be done?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use process.nextTick: replace evEmitter.emit ('listening', port) with process.nextTick (() =&gt; evEmitter.emit ('listening', port)). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bottom line is that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process.nextTick should be used to call the callbacks that were transferred to you</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . From the point of view of EventEmitter, this is also essentially a callback. So, they passed you a callback, but they expect an asynchronous API from you, because this callback will not be executed synchronously. Therefore, we use process.nextTick, and this emit will occur immediately after the userland code has run out. That is, we declared the createServer function, executed it, listened, subscribed to the listening event. Our stack has cleared - at this point in the process. NextTick - boom! Emit event, we have already subscribed to it, everything is cool.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This polling case process.nextTick basically. </font><font style="vertical-align: inherit;">That is, everything for callback, including errors, is the same story. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it should be understood that process.nextTick has the same behavior as Promise.then in browsers. </font><font style="vertical-align: inherit;">If you call process.nextTick recursively, no one will help you - everything will hang on you, both the Event Loop and Node.js will hang. </font><font style="vertical-align: inherit;">Therefore, please do not do so. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use process.nextTick only in exceptional cases</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , otherwise it is better to use ghbvtybnm setImmediate with recursive patterns, or give it to a module in C ++, etc. at all. </font><font style="vertical-align: inherit;">And process.nextTick can be used just to call callbacks.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Async / await </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also have such an API - async / await, some kind of generators. </font><font style="vertical-align: inherit;">They work very simply. </font><font style="vertical-align: inherit;">As we all know, async / await is based on Promise, so from the point of view of the Event Loop, it works exactly the same. </font><font style="vertical-align: inherit;">There are some differences in implementation, but from our point of view it is all the same.</font></font><br><br><h2>  useful links </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once again, the </font></font><a href="https://saitonakamura.github.io/ivan-tooloop/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link to the slides</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><a href="https://github.com/saitonakamura/ivan-tooloop"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li> <a href="https://www.youtube.com/watch%3Fv%3D8aGhZQkoFbQ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philip Roberts. </font><font style="vertical-align: inherit;">What the heck is the event loop anyway?</font></font></a> <br></li><li> <a href="https://youtu.be/PNa9OMajw9w"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bert Belder. </font><font style="vertical-align: inherit;">Everything you need to know about the Node.js event loop.</font></font></a> <br></li><li> <a href="https://www.youtube.com/watch%3Fv%3DcCOL7MC4Pl0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jake Archibald. </font><font style="vertical-align: inherit;">In the Loop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li> <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Node.js Event Loop, Timers, and process.nextTick ()</font></font></a> <br></li><li> <a href="https://html.spec.whatwg.org/multipage/webappapis.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHATWG Specification event loop processing model</font></font></a> <br></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please do not let Ivan Tulup die!</font></font></strong> <br><br><blockquote>   <a href="http://frontendconf.ru/moscow/2018">Frontend Conf</a>     ‚Äî 4  5   ,  .    ,        : <br><br><ul><li> <a href="http://frontendconf.ru/moscow/2018/abstracts/3329">Grid Layout    </a> /   ( .) <br></li><li> <a href="http://frontendconf.ru/moscow/2018/abstracts/3931">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="http://frontendconf.ru/moscow/2018/abstracts/3513"> </a> /   () <br></li><li> <a href="http://frontendconf.ru/moscow/2018/abstracts/3829">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Come, it will be interesting! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/417461/">https://habr.com/ru/post/417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417449/index.html">Jurassic World: Can we really resurrect dinosaurs?</a></li>
<li><a href="../417451/index.html">Five common mistakes novice managers</a></li>
<li><a href="../417453/index.html">Organization of internships for students: rakes and tricks</a></li>
<li><a href="../417457/index.html">Frontend Conf Moscow - client-side and deep and wide</a></li>
<li><a href="../417459/index.html">Know your JIT: closer to the car</a></li>
<li><a href="../417463/index.html">Unexpected meeting. Chapter 17</a></li>
<li><a href="../417465/index.html">Overview of text entry binding methods</a></li>
<li><a href="../417469/index.html">Five selfish reasons to work reproducibly</a></li>
<li><a href="../417471/index.html">Simple Solder MK936 SMD. DIY soldering station on SMD components</a></li>
<li><a href="../417473/index.html">Secure storage with DRBD9 and Proxmox (Part 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>