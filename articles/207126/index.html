<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Zoo of Algebraic Data Types</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will try to consider the whole variety of Algebraic Data Types. 

 It must be said, the task is rather unaffordable, and it is not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Zoo of Algebraic Data Types</h1><div class="post__text post__text-html js-mediator-article">  In this article we will try to consider the whole variety of Algebraic Data Types. <br><img src="https://habrastorage.org/getpro/habr/post_images/814/15f/cbd/81415fcbd34d4b31a157924f359bc7ac.jpg"><br>  It must be said, the task is rather unaffordable, and it is not very easy to understand a person if he has not dealt with Algebraic Types before - <br>  ATD was first used in the Hope language, but they gained their main popularity thanks to ML languages, such as Standart ML, OCaml, F #, and Haskell. <br>  Nowadays, ATD are to some extent supported in much more languages: Scala, Rust, Nemerle, Racket, ... <br>  ADT is a universal data type.  With it, you can present most of the data types. <br>  ATD are called algebraic, because they can be represented as a certain algebraic composition of the types of its components.  This knowledge gives its advantage: understanding the properties of an algebraic composition, it is possible to calculate what type is necessary for the construction of certain data. <br>  We will consider types based on the Haskell language, but this with light modifications can be achieved in other languages ‚Äã‚Äãwith ADT support. <br><a name="habracut"></a><br>  It should be noted that the theory of types developed in the 20th century by Russell, Church, Martin-L√∂f became so popular that now (already in the 21st century) a theory of the Homotopic Theory of Types has appeared that has set about to explain the foundation of mathematics. <br><div class="spoiler">  <b class="spoiler_title">Hott</b> <div class="spoiler_text">  If anyone is interested in the theory, you can read free fresh work in English. <a href="http://homotopytypetheory.org/book/">Homotopy Type Theory: Univalent Foundations of Mathematics</a> </div></div><br>  Our task is to look at Algebraic Data Types.  Often these ATD is called boxed or wrapped.  They are so named because they look like data packed in a box.  The most interesting thing is that even an implementation means not storing data, but pointers.  In addition to the ease of implementation, it gives effective mechanisms of laziness, which Haskel has. <br>  In fairness, I note that Haskell allows you to create non-lazy, including unwrapped data, which helps in processing high-loaded data volumes. <br>  In Haskell, there are 2 ways to create an ADT using the <code>data</code> or <code>newtype</code> declaration.  The difference between them is that the <code>newtype</code> de facto not wrapped, which means cheaper (in terms of machine resources), and therefore more profitable, but with the help of it you can write only a narrow circle of ADT, so it is not suitable in general. <br><br><h4>  Types of data implemented through primitives </h4><br>  In Haskell there are not many of them, first of all these are data types such as <br>  <code>Int</code> , <code>Integer,</code> <code>Float</code> , <code>Double</code> , <code>Char</code> , ... <br>  The point is not that it is impossible to make these types truly (through ADT), just the computer already knows how to work with numbers, and it's a sin not to use it. <br>  I want to note that all types are written with a capital letter, this is due to the fact that all type and data constructors in Haskell are written exclusively with a capital letter. <br><br><h4>  Zero data types </h4><br>  Most imperative languages ‚Äã‚Äãare built in such a way that it is convenient to create programs from the bottom up through hierarchical complexity. <br>  In Haskell, it's very easy to write code from top to bottom.  In this connection, it became necessary to have empty data types (without implementations), since it is known that this data type will do, but it has not yet been decided how to fill it.  There is an extension that allows you to do this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      These are not real, pseudo-zero, empty data types. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class"> ab</span></span></code> </pre><br>  The syntax, as we see it is simple to ugliness. <br>  Here we created 3 types of data, the second of which is parametric.  We see that <code>a</code> is written with a lowercase letter, which means it cannot be a constructor.  The output is a parameter in which you can substitute any type, that is, you can have the following types: <code>T Int,</code> <code>T Char</code> , <code>TS</code> , <code>T (T Double)</code> and even <code>T (T ( T String))</code> . <br>  We also see that the constructor stands at the beginning of the type, and then the data is packed in a box. <br>  You ask why they are needed? <br>  For example, we can write the following valid function code: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doubleT</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> a -&gt; (<span class="hljs-type"><span class="hljs-type">T</span></span> a, <span class="hljs-type"><span class="hljs-type">T</span></span> a) doubleT t = (t, t)</code> </pre><br>  Of course, in most cases, you cannot write all the functions without internal knowledge about the data, but you can leave some of the functions for later, doing other tasks, such as this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">S</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> a foo = undefined nextT :: <span class="hljs-type"><span class="hljs-type">S</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> a) nextT si = (i+<span class="hljs-number"><span class="hljs-number">1</span></span>, foo s (i+<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre><br>  This program will be compiled and checked for errors, despite the fact that neither the data nor the part of the functions are defined. <br><br>  This zero data type looks unusual enough for an untrained eye, but we can understand it. <br>  It was found relatively recently, is still not in the Platform (so that it can be used out of the box), and still little used. <br><div class="spoiler">  <b class="spoiler_title">Void</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Void</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Void</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Void</span></span></span></span></code> </pre><br>  Here we see the recursive type (we'll talk about this later), first comes the type name - <code>Void</code> , then <code>=</code> , then the constructor of this type is <code>Void</code> and the parameter, which is the <code>Void</code> type. <br>  If we rename, it will not change anything except our understanding: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VoidData</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Void</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VoidData</span></span></span></span></code> </pre><br>  This data type is infinitely self-centered. </div></div><br><br><h4>  Single data types </h4><br>  Single data types provide nothing but the knowledge that it is. <br>  Of the common data types used <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> () = () </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--X</span></span></span></span></code> </pre><br>  <i>hereafter comment</i> <pre> <i><code class="haskell hljs"> <span class="hljs-comment"><span class="hljs-comment">-- X</span></span></code></i> </pre>  <i>data will be shown so defined, but they can not be determined by the very fact that invalid characters are used.</i> <br>  In almost all programs, a signature is used: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br>  because the program must return something.  Therefore <code>()</code> is the most popular type when you need to return anything. <br>  Or, here's another well-known single type: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span></span></code> </pre><br>  the same, only ordinary constructors are used. <br>  I must say that in these types there is no recursion, that is, we can write: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UnitData</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span></span></code> </pre><br>  The fact is that the type namespace does not overlap with the type constructor space, so the compiler perfectly understands where recursion is and where it is not. <br><br><h4>  Types of works </h4><br>  Types of works are named so that they can be represented as a product of several types that make it up. <br>  Very popular data types are used everywhere. <br>  The most famous ones are tuples or tuples.  Haskell uses special syntactic sugar for this: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> (,) ab = (,) ab </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--X (a, b) data (,,) abc = (,,) abc --X (a, b, c) data (,,,,) abcd = (,,,,) abcd --X (a, b, c, d)</span></span></span></span></code> </pre><br>  We can write the same thing with ordinary constructors: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> ab </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Triple</span></span></span><span class="hljs-class"> abc = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Triple</span></span></span><span class="hljs-class"> abc</span></span></code> </pre><br>  Everywhere where you need to store more than one given in the data - this is the type of works. <br><br><h4>  Summary Data Types </h4><br>  Summary data types are named because they summarize the data types that compose them. <br>  For example, if you add single data types, you get an enumeration. <br>  I present one of the most famous listings: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span></span></code> </pre><br>  Also known is the <code>Ordering</code> type, which is used in comparisons. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ordering</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LT</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQ</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GT</span></span></span></span></code> </pre><br>  If we move on to more complex ADDs, we need to recall the null-abel type: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br>  Data that has a field for the result when it is not there, so to say <code>null</code> from many programming languages. <br><pre> <code class="haskell hljs">(&lt;/&gt;) :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> _ &lt;/&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> a &lt;/&gt; b = <span class="hljs-type"><span class="hljs-type">Just</span></span> (a `div` b)</code> </pre><br>  If you need to learn more about the error, use an even more complex data type: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> b</span></span></code> </pre><br>  data type, where there is either a ‚Äúleft‚Äù result (description of the error or the error itself) or ‚Äúcorrect‚Äù result. <br>  This type of data is also used for binary selection. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdPerson</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ErrorMsg</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> personChecker :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ErrorMsg</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdPerson</span></span></span><span class="hljs-class"> personChecker p = if age p &lt; 0 then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> "this guy is not born yet!" else if null $ first_name p then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> "this guy is unnamed!" else </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> $ registeredId p</span></span></code> </pre><br>  You can make more exotic data types, for example: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Both</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">None</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">First</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Second</span></span></span><span class="hljs-class"> b | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Both</span></span></span><span class="hljs-class"> ab</span></span></code> </pre><br>  here we either have no result, or 1 result, or 2nd, or 1st and 2nd. <br><br><h4>  Recursive data types </h4><br>  In Haskell, you can easily create recursive data types. <br>  The most well-known, using the syntactic sugar type are lists: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> [] a = [] | a : [a] </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--X</span></span></span></span></code> </pre><br>  However, it can be easily rewritten with the words: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  I want to note that special characters can be used as constructors, where the first character is necessarily a colon <code>(:)</code> , then they use infix notation. <br>  Want to build a tree?  No problem. <br>  For example, a simple binary tree: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Leaf</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Branch</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Branch2</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Or here's another, natural numbers: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Zero</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Succ</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span></span></code> </pre><br>  If you have not yet opened a spoiler of the zero data type (or opened, but did not understand) - it's time to open and read and understand that the <code>Void</code> elementary infinitely recursive data type. <br><br><h4>  Power data types </h4><br>  Do not think that only data can be recorded in ADT.  Functions can also be easily written to ATD: power types (the general type has the power of raising one type of data to the power of another): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fun</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fun</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContT</span></span></span><span class="hljs-class"> rma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Writer</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mr</span></span></span><span class="hljs-class">) -&gt; mr)</span></span></code> </pre><br>  If we use ADT works, where the data will be interspersed with functions - this is nothing but records, and very similar structures to objects. <br><br><h4>  Phantom data types </h4><br>  Sometimes you have to create a rather unusual behavior, and you have to invent types that do nothing but pretend they do.  Phantom types are used for this in particular.  One of the most famous types is: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Proxy</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Proxy</span></span></span></span></code> </pre><br>  As you can see, the type header says that the type is parametric, but in reality it is a dummy. <br>  These data types are often used as universal plugs, since they are easily converted from one data type to another. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">proxy</span></span>onverter :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Proxy</span></span> b proxyonverter <span class="hljs-type"><span class="hljs-type">Proxy</span></span> = <span class="hljs-type"><span class="hljs-type">Proxy</span></span></code> </pre><br><br><h4>  Records </h4><br>  The type of works is so often used that there is a special syntactic sugar, which makes it easier and more convenient to work with it (with built-in getters and setters).  Such types are called records. <br>  Let we have a type <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sex</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Female</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Male</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sex</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  much more convenient to rewrite to: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sex</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Female</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Male</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lastName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firstName</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">age</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">socialId</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sex</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sex</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greeting</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br><br><h5>  Inserts or Wrappers </h5><br>  Inserts are used where it is necessary either to hide the implementation of the type, to protect from outside interference, or to impart other properties than the maternal type. <br>  It is written in a similar way (with the syntax of records): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Wrapper</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Wrapper</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwrapper</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dollar</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dollar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span></span></code> </pre><br><br><h4>  Existential Data Types </h4><br>  Existential data types are named like this because of the existence quantifier ‚àÉ. <br>  The paradox is that there is no such quantifier in Haskele. <br>  But there is a quantifier of universality ‚àÄ.  But these quantifiers can easily be transformed into each other. <br>  If to be completely accurate, then each existentially-quantified type of rank <code>n+1</code> can be transformed into a universally-quantified type of rank <code>n</code> . <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class"> = forall a. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class"> a heteroList :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class">] heteroList = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class"> 3.7, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class"> "message", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HeteroData</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">]</span></span></code> </pre><br>  As you can see, they were able to create a heterogeneous list, despite the fact that it is homogeneous. <br>  But something looks like an object: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Counter</span></span></span><span class="hljs-class"> a = forall self. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewCounter</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_this</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_inc</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_display</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> () , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tag</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  We cannot work directly with functions written with an underscore. <br>  The truth is to work with similar objects does not seem to work with the PLO: <br><div class="spoiler">  <b class="spoiler_title">Record with existential variable</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">inc</span></span> :: <span class="hljs-type"><span class="hljs-type">Counter</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Counter</span></span> a inc (<span class="hljs-type"><span class="hljs-type">NewCounter</span></span> xidt) = <span class="hljs-type"><span class="hljs-type">NewCounter</span></span> { _this = ix, _inc = i, _display = d, tag = t } display :: <span class="hljs-type"><span class="hljs-type">Counter</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () display <span class="hljs-type"><span class="hljs-type">NewCounter</span></span>{ _this = x, _display = d } = dx counterA :: <span class="hljs-type"><span class="hljs-type">Counter</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> counterA = <span class="hljs-type"><span class="hljs-type">NewCounter</span></span> { _this = <span class="hljs-number"><span class="hljs-number">0</span></span>, _inc = (<span class="hljs-number"><span class="hljs-number">1</span></span>+), _display = print, tag = <span class="hljs-string"><span class="hljs-string">"A"</span></span> } counterB :: <span class="hljs-type"><span class="hljs-type">Counter</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> counterB = <span class="hljs-type"><span class="hljs-type">NewCounter</span></span> { _this = <span class="hljs-string"><span class="hljs-string">""</span></span>, _inc = ('#':), _display = putStrLn, tag = <span class="hljs-string"><span class="hljs-string">"B"</span></span> } main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> display (inc counterA) <span class="hljs-comment"><span class="hljs-comment">-- prints "1" display (inc (inc counterB)) -- prints "##"</span></span></code> </pre><br></div></div><br><br><h4>  Generalized Algebraic Data Types (GADTs) </h4><br>  Generalized ADT differ from the usual ones in that they cut and specialize the resulting type. <br>  Haskell uses a ‚Äúfunctional‚Äù record of this data.  Let's rewrite the simple data type in a new syntax: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> :: a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- -------------------- data List a = Nil | Cons a (List a) data List a where Nil :: List a Cons :: a -&gt; List a -&gt; List a</span></span></span></span></code> </pre><br>  We see that the final data type for all is the same: <code>Maybe a</code> (or <code>List a</code> ).  OATD allow you to have different total data types. <br>  If we have an abstract tree: <br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> a where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Lit</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Succ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsZero</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">If</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> b -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Term</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  it is easy to build a function for computing a similar tree: <br><pre> <code class="haskell hljs"> eval :: <span class="hljs-type"><span class="hljs-type">Term</span></span> a -&gt; a eval (<span class="hljs-type"><span class="hljs-type">Lit</span></span> i) = i eval (<span class="hljs-type"><span class="hljs-type">Succ</span></span> t) = <span class="hljs-number"><span class="hljs-number">1</span></span> + eval t eval (<span class="hljs-type"><span class="hljs-type">IsZero</span></span> t) = eval t == <span class="hljs-number"><span class="hljs-number">0</span></span> eval (<span class="hljs-type"><span class="hljs-type">If</span></span> b e1 e2) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> eval b <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> eval e1 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eval e2 eval (<span class="hljs-type"><span class="hljs-type">Pair</span></span> e1 e2) = (eval e1, eval e2)</code> </pre><br><br><h4>  Parametric data types with limited parameters </h4><br>  Sometimes it really hurts to restrict parametric data types.  They are cut off by a restriction <i>of the</i> (kind) type. <br>  The view is essentially a type type, for example <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> :: (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> :: *)</code> </pre><br>  Here is the data with a parameter limit: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: * -&gt; *) where ...</span></span></code> </pre><br>  Basically, these types are required for very high levels of abstraction. <br><div class="spoiler">  <b class="spoiler_title">Vector type</b> <div class="spoiler_text">  Vector with natural numbers as length <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ze</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Su</span></span></span><span class="hljs-class"> n </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> :: * -&gt; * -&gt; * where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ze</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> :: a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> an -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Su</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">)</span></span></code> </pre></div></div><br><br><h4>  Conclusion </h4><br>  Algebraic Data Types is a very simple, versatile, elegant, easily extensible and powerful tool for creating custom data types to meet the many needs of programmers. <br><img src="http://habrastorage.org/storage3/c19/11e/213/c1911e21328968e3b374cba671f11be1.jpg"></div><p>Source: <a href="https://habr.com/ru/post/207126/">https://habr.com/ru/post/207126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207116/index.html">Autodesk Simulation CFD 2014 Quick Start Guide</a></li>
<li><a href="../207118/index.html">iTunes - the payment system of the future?</a></li>
<li><a href="../207120/index.html">New trends in cryptocurrencies: 100% proof-of-stake and Nxt</a></li>
<li><a href="../207122/index.html">A kosher way to modify write-protected areas of the Linux kernel</a></li>
<li><a href="../207124/index.html">Yandex.Disk congratulates the new year</a></li>
<li><a href="../207130/index.html">LEDs in the snow</a></li>
<li><a href="../207132/index.html">10 new commercials from Trailer Studio</a></li>
<li><a href="../207134/index.html">Who, when and how is going to fly to Mars</a></li>
<li><a href="../207136/index.html">Holiday geeky: with ARM and TFT LCD</a></li>
<li><a href="../207138/index.html">School bell on Raspberry Pi with remote control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>