<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Another treatise</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you probably guessed, this article is devoted to lock-free queues. 

 Queues are different. They can differ in the number of writers (producer) and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Another treatise</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/80a/ba4/d90/80aba4d9012b64b9d8786ca727761f58.jpg" align="right"><br>  As you probably guessed, this article is devoted to lock-free queues. <br><br>  Queues are different.  They can differ in the number of writers (producer) and readers (consumer) - single / multi producer - single / multi consumer, 4 options - they can be limited (bounded, based on a predistributed buffer) and unlimited, based on a list (unbounded) , with or without priority support, lock-free, wait-free or lock-based, with strict adherence to FIFO (fair) and not very (unfair), etc.  The types of queues are described in detail in <a href="http://www.1024cores.net/home/lock-free-algorithms/queues">this</a> and <a href="http://www.1024cores.net/home/in-russian/ottenki-fifo">this</a> article by Dmitry Vyukov.  The more specialized the requirements for the queue, the more efficient its algorithm, as a rule.  In this article, I will look at the most common variant of queues ‚Äî a multi-producer / multi-consumer unbounded concurrent queue without priority support. <br><a name="habracut"></a><br>  The queue is perhaps the favorite data structure for researchers.  On the one hand, it is simple <s>as a log</s> , on the other hand, it is not as simple as a stack - it still has two ends, and not one;  since it has two ends, interesting problems arise, how to manage them in a multithreaded environment.  The number of publications with different variations of the queue algorithm rolls over, it is not possible to cover them all.  I‚Äôll dwell on the recognized ones and start with the classic lineup. <br><br><h1>  Classic lineup </h1><br>  A classic queue is a list (it doesn't matter if it is simply connected or biconnected) with two ends - Head and tail Tail.  From the head we read, we write to the tail. <br><div class="spoiler">  <b class="spoiler_title">Naive standard queue</b> <div class="spoiler_text">  Copy-paste from the <a href="http://habrahabr.ru/company/ifree/blog/195770/">first</a> article of the cycle <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> Node * m_pNext ; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">queue</span></span></span><span class="hljs-class"> {</span></span> Node * m_pHead ; Node * m_pTail ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>(): m_pHead( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ), m_pTail( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Node * p )</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;m_pNext = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_pTail ) m_pTail-&gt;m_pNext = p; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_pHead = p ; m_pTail = p ; } <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !m_pHead ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ; Node * p = m_pHead ; m_pHead = p-&gt;m_pNext ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !m_pHead ) m_pTail = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p ; } };</code> </pre> <br>  Do not look, there is no competition here - it‚Äôs just an illustration of how simple the subject for conversation is.  In the article we will see what happens with simple algorithms, if they begin to adapt to a competitive environment. <br>  UPD: thank you <a href="https://habrahabr.ru/users/xnike/" class="user_link">xnike</a> , who first found a mistake here! <br></div></div><br>  The classic (1996) lock-free queue algorithm is considered to be the <a href="http://www.research.ibm.com/people/m/michael/podc-1996.pdf">Michael &amp; Scott</a> algorithm. <br>  As always, the <s>sheet</s> code is provided from the <a href="http://sourceforge.net/projects/libcds/">libcds</a> library, if it contains an implementation of the algorithm in question, in an abbreviated (adapted) form.  For the full code, see the class <code>cds::intrusive::MSQueue</code> .  Comments are inserted by code, trying to make them not too boring. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( value_type&amp; val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Implementation detail:    node_type  value_type -                 ,  node_traits::to_node_ptr -   static_cast&lt;node_type *&gt;( &amp;val ) */</span></span> node_type * pNew = node_traits::to_node_ptr( val ) ; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> gc::Guard guard; <span class="hljs-comment"><span class="hljs-comment">// , , Hazard Pointer // Back-off  (template- ) back_off bkoff; node_type * t; //    lock-free, ,     ... while ( true ) { /*  m_pTail,                  (delete)  */ t = guard.protect( m_pTail, node_to_value() ); node_type * pNext = t-&gt;m_pNext.load( memory_model::memory_order_acquire); /*  :  ,  m_pTail     ,  ,      .     */ if ( pNext != nullptr ) { // !    //(  )    m_pTail.compare_exchange_weak( t, pNext, std::memory_order_release, std::memory_order_relaxed); /*    ,   CAS   CAS  ‚Äî , m_pTail -    ,    . */ continue ; } node_type * tmp = nullptr; if ( t-&gt;m_pNext.compare_exchange_strong( tmp, pNew, std::memory_order_release, std::memory_order_relaxed )) { //      . break ; } /*      ‚Äî CAS  .  ,  -    .   ‚Äî    ,       ‚Äî   back_off */ bkoff(); } /* ,   ‚Äî   ...  ,    -   ‚Äî   ,     .         ,         */ ++m_ItemCounter ; /* ,     m_pTail.    ,     , ‚Äî  ,   , . '!'   ,  dequeue */ m_pTail.compare_exchange_strong( t, pNew, std::memory_order_acq_rel, std::memory_order_relaxed ); /*     true. , , bounded queue,    false,   .    enqueue     */ return true; } value_type * dequeue() { node_type * pNext; back_off bkoff; //  dequeue   2 Hazard Pointer' typename gc::template GuardArray&lt;2&gt; guards; node_type * h; // ,    ... while ( true ) { //     m_pHead h = guards.protect( 0, m_pHead, node_to_value() ); //      pNext = guards.protect( 1, h-&gt;m_pNext, node_to_value() ); // : ,     , //  ?.. if ( m_pHead.load(std::memory_order_relaxed) != h ) { // , - -    ... //   continue; } /*   . ,            */ if ( pNext == nullptr ) return nullptr; //   /*    ,    Hazard Pointer'   ‚Äî    ,     ( ) */ node_type * t = m_pTail.load(std::memory_order_acquire); if ( h == t ) { /* !    :  ,     ,     .    ... */ m_pTail.compare_exchange_strong( t, pNext, std::memory_order_release, std::memory_order_relaxed); //       - //      CAS continue; } //    ‚Äî    //       if ( m_pHead.compare_exchange_strong( h, pNext, std::memory_order_release, std::memory_order_relaxed )) { //  ‚Äî     break; } /*  ... , -  .    ,    */ bkoff() ; } //   -    , // .   enqueue --m_ItemCounter; //    '  h' dispose_node( h ); /* !!!     !   ,   []  ,  pNext     ‚Äî    ! */ return pNext; }</span></span></code> </pre><br>  As you can see, the queue is represented by a simply linked list from head to tail. <br>  What is the important point in this algorithm?  The important point is to contrive to control two pointers - on the tail and on the head - using the usual (not double!) CAS.  This is achieved due to, firstly, the fact that the queue is never empty - look carefully at the code, is there somewhere head / tail <code>nullptr</code> for <code>nullptr</code> ? .. You will not find.  To ensure physical (but not logical) non-emptiness in the queue's constructor, one false (dummy) element is added to it, which is the head and tail.  And the consequence of this is this: during the extraction ( <code>dequeue</code> ), an element is returned, which becomes the new dummy-element (new head), and the former dummy-element (former head) is deleted: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ba3/6c2/952/ba36c295213f301121d678de152d5ae0.png"><br>  This moment should be taken into account when constructing an intrusive queue ‚Äî the returned pointer is still part of the queue and can only be deleted with the <i>next</i> <code>dequeue</code> . <br>  Secondly, the algorithm explicitly assumes that the tail may not point to the last element.  For every reading of the tail, we check whether it has the next element <code>m_pNext</code> .  If this pointer is not <code>nullptr</code> - the tail is not in place, you need to move it.  There is another underwater stone here: it may happen that the tail points to the element <i>in front of the</i> head (the intersection of the head and tail).  To avoid this, we implicitly check <code>m_pTail-&gt;m_pNext</code> : we read the head following the head element <code>m_pHead-&gt;m_pNext</code> , made sure that <code>pNext != nullptr</code> , and then we see that the head is equal to the tail.  Consequently, there is something behind the tail, since there is a <code>pNext</code> , and the tail must be pushed forward.  A typical example of mutual help (helping) flows, which is very common in lock-free programming. <br><div class="spoiler">  <b class="spoiler_title">Memory ordering</b> <div class="spoiler_text">  I‚Äôm ashamed to hide such a confession behind the spoiler: the above code is not a model for the arrangement of memory ordering of atomic operations.  The fact is that I did not see the detailed analysis of algorithms from the point of view of C ++ 11 memory ordering more complicated than the Treiber stack.  Therefore, in this code, the memory ordering is placed rather by intuition, with a <s>slight</s> addition of the brain.  Intuition is supported by a long-term run of tests, and not only on x86.  I fully admit (and even suspect) that there are weaker barriers to this code, I remain open to discussion. <br></div></div><br><br>  In 2000, <a href="http://pdf.aminer.org/000/213/075/formal_verification_of_a_practical_lock_free_queue_algorithm.pdf">a</a> small optimization of this algorithm <a href="http://pdf.aminer.org/000/213/075/formal_verification_of_a_practical_lock_free_queue_algorithm.pdf">was proposed</a> .  It was noted that the <code>MSQueue</code> algorithm in the <code>MSQueue</code> method <i>at each</i> iteration of the loop reads the tail, which is redundant: the tail needs to be read (to check that it is really a tail and points to the last element) only when the head has been successfully updated.  Thus, we can expect a decrease in pressure on <code>m_pTail</code> under certain types of load.  This optimization is represented in libcds by the class <code>cds::intrusive::MoirQueue</code> . <br><br><h2>  Baskets queue </h2><br>  An interesting variation of <code>MSQueue</code> <a href="http://people.csail.mit.edu/shanir/publications/Baskets%2520Queue.pdf">was introduced</a> in 2007.  A rather well-known in lock-free circles researcher Nir Shavit and his comrades approached the optimization of the classic lock-free queue of Michael and Scott on the other hand. <br>  He presented the queue as a set of logical baskets (basket), each of which is available for adding a new element for some short period of time.  The interval has passed - a new basket is being created. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81c/65c/4bf/81c65c4bf94011a7414e7ad2bdc36bcf.png"><br><br>  Each basket is an unordered collection of items.  It would seem that this definition violates the main property of the queue - FIFO, that is, the queue becomes not quite a queue (unfair).  FIFO holds for baskets, but not for items in baskets.  If the basket availability interval for adding is sufficiently small, we can neglect the disorder of the elements in it. <br>  How to determine the duration of this interval?  And it is not necessary to define it, the authors say Baskets Queue.  Consider the <code>MSQueue</code> .  In the <code>enqueue</code> operation under high <code>enqueue</code> , when the CAS tail changes did not work, that is, where the back-off is called in <code>MSQueue</code> , we cannot determine in which order the elements will be added to the queue, as they are added <i>simultaneously</i> .  This is the logical basket.  In essence, it turns out that the abstraction of logical baskets is a kind of back-off strategy. <br>  I am not a fan of reading code kilometers in review articles, so I‚Äôll not give the code.  Using the example of <code>MSQueue</code> we have already seen that the lock-free code is very verbose.  Those wishing to see the implementation refer to the class <code>cds::intrusive::BasketQueue</code> library, file <code>cds/intrusive/basket_queue.h</code> .  For the explanation of the algorithm, I will borrow another picture from the work of Nir Shavit &amp; Co: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f99/128/7ad/f991287ad9fccc975e7e8d186c1cafb0.png"><br><br>  1. Threads A, B, C want to add items to the queue.  They see that the tail is in its <code>MSQueue</code> place (and we remember that in <code>MSQueue</code> tail may not indicate the last element in the queue at all) and try <i>to</i> change it <i>at the same time</i> . <br>  2. Stream A came out the winner - added a new element.  Flows B and C losers - their CAS with a tail is unsuccessful, so they both start adding their items <i>to the basket</i> using the previously read <i>old</i> tail value. <br>  3. Thread B was the first to add.  At the same time, thread D also calls <code>enqueue</code> and successfully adds its element, changing the tail. <br>  4. Thread C also successfully completes the addition.  We look where he added - in the middle of the queue!  When added, he uses the old pointer to the tail, which he read on entering the operation before performing his unsuccessful CAS. <br><br>  It should be noted that with this addition it may well happen that the element will be inserted <i>in front of the</i> queue head.  For example, the element in front of C in Figure 4 is above: while thread C is <code>enqueue</code> on <code>enqueue</code> , another thread may already delete the element in front of C. To prevent such a situation, it is proposed to apply a <i>logical deletion</i> , that is, you must first mark the deleted elements with the special flag <code>deleted</code> .  Since it is required that the flag and the pointer to the element itself can be read atomically, we will store this flag in the <code>pNext</code> bit of the <code>pNext</code> pointer of the element.  This is permissible, since in modern systems memory is allocated evened out at least 4 bytes, so that the lower 2 bits of the pointer will always be zeros.  Thus, we have invented <i>marked pointers</i> , which is widely used in lock-free data structures.  This reception we will meet more than once in the future.  By applying a logical deletion, that is, setting the low-order bit of <code>pNext</code> to 1 using CAS, we will exclude the possibility to insert an element in front of the head ‚Äî the insertion is also performed by CAS, and the deleted element contains 1 in the low-order bit of the pointer, so the CAS will fail (of course when inserting, we take not all of the marked pointer, but only its high bits, which contain the actual address, the lower bit is set to zero). <br>  And the final improvement introduced by <code>BasketQueue</code> concerns the physical removal of elements.  It was noticed that changing the head with each successful call to <code>dequeue</code> can be costly - CAS is also called there, which, as you know, is rather heavy.  Therefore, we will change the head only when <i>several</i> logically deleted elements have accumulated (in the default implementation of <code>libcds</code> three).  Or when the queue becomes empty.  It can be said that the head in <code>BasketQueue</code> changes by leaps (hops). <br><br>  All these optimizations are designed to improve the performance of the classic lock-free queue in a situation of high competition. <br><br><h2>  Optimistic approach </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/417/0b3/e09/4170b3e09099eb1c0c06423badd51d27.png" align="right"><br>  In 2004, Nir Shavit and Edya Ladan Mozes <a href="http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-journal.pdf">proposed</a> another approach to optimizing <code>MSQueue</code> , which they called <i>optimistic</i> . <br><div class="spoiler">  <b class="spoiler_title">Warning</b> <div class="spoiler_text">  If anyone is interested in the original article - be careful!  There are two articles of the same name ‚Äî 2004 and 2008. The 2004 article gives some kind of furious (and seemingly inoperable) pseudo-queue code. <br>  In the 2008 article, the pseudocode is different ‚Äî pleasant for the eyes and working. <br></div></div><br>  They noticed that in the Michael and Scott algorithm, the <code>dequeue</code> operation requires only one CAS, whereas the <code>enqueue</code> two (see the figure to the right). <br><br>  This second CAS in enqueue can significantly affect performance even at low load, - CAS in modern processors is quite a hard operation.  Is there any way to get rid of him? .. <br>  Consider where in the <code>MSQueue::enqueue</code> two <code>MSQueue::enqueue</code> came from.  The first CAS associates a new element with a tail ‚Äî changes <code>pTail-&gt;pNext</code> .  The second - promotes the tail itself.  Can the <code>pNext</code> field <code>pNext</code> changed with a regular atomic notation, and not with a CAS?  Yes, if the direction of our simply linked list would be different - not from head to tail, but on the contrary, we could use an atomic store ( <code>pNew-&gt;pNext = pTail</code> ) to set <code>pNew-&gt;pNext</code> and then change <code>pTail</code> .  But if we change direction, then how do <code>dequeue</code> do <code>dequeue</code> ?  There will be no <code>pHead-&gt;pNext</code> , the direction of the list has changed. <br>  The authors of the optimistic lineup suggested using a <i>doubly linked</i> list. <br><img src="https://habrastorage.org/getpro/habr/post_images/ca8/10f/d6c/ca810fd6c9e0383abcee031493ffb856.png" align="right"><br>  There is one problem here: the effective algorithm for a doubly connected lock-free list on CAS is not yet known.  Algorithms for DCAS (CAS over <i>two different</i> memory cells) are known, but there is no DCAS implementation in hardware.  The MCAS emulation algorithm (CAS over M unrelated memory cells) is known on CAS, but it is inefficient (requires 2M + 1 CAS) and is more likely of theoretical interest. <br>  The authors proposed this solution: the link in the list from tail to head (next, the link that is <i>not needed</i> for the queue, but the introduction of this link allows you to get rid of the first CAS in the <code>enqueue</code> ) will always be consistent.  But the feedback - from head to tail, the most important, prev - may be not quite consistent, that is, its violation is permissible.  If we find such a violation, we can always restore the correct list by following the next links.  How to detect such a violation?  Very simple: <code>pHead-&gt;prev-&gt;next != pHead</code> .  If this inequality is detected in the <code>dequeue</code> , the auxiliary <code>fix_list</code> procedure is <code>fix_list</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fix_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( node_type * pTail, node_type * pHead )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pTail  pHead   Hazard Pointer' node_type * pCurNode; node_type * pCurNodeNext; typename gc::template GuardArray&lt;2&gt; guards; pCurNode = pTail; while ( pCurNode != pHead ) { //     pCurNodeNext = guards.protect(0, pCurNode-&gt;m_pNext, node_to_value() ); if ( pHead != m_pHead.load(std::memory_order_relaxed) ) break; pCurNodeNext-&gt;m_pPrev.store( pCurNode, std::memory_order_release ); guards.assign( 1, node_traits::to_value_ptr( pCurNode = pCurNodeNext )); } }</span></span></code> </pre><br>  [Taken from the <code>cds::intrusive::OptimisticQueue</code> class of the <code>cds::intrusive::OptimisticQueue</code> Library] <br>  <code>fix_list</code> runs through the entire queue from tail to head via the obviously <i>correct</i> <code>pNext</code> links and adjusts <code>pPrev</code> . <br>  Breaking the head-to-tail list (prev pointers) as soon as possible because of delays, and not because of a heavy load.  Delays are a thread preemption by an operating system or an interrupt.  Consider the code <code>OptimisticQueue::enqueue</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( value_type&amp; val )</span></span></span><span class="hljs-function"> </span></span>{ node_type * pNew = node_traits::to_node_ptr( val ); <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> gc::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> GuardArray&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; guards; back_off bkoff; guards.assign( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;val ); node_type * pTail = guards.protect( <span class="hljs-number"><span class="hljs-number">0</span></span>, m_pTail, node_to_value()); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//    ‚Äî     pNew-&gt;m_pNext.store( pTail, std::memory_order_release ); //    if ( m_pTail.compare_exchange_strong( pTail, pNew, std::memory_order_release, std::memory_order_relaxed )) { /*    ‚Äî    .      ().   pTail     (dequeue)   (    ,   pTail    Hazard Pointer' , , ) */ pTail-&gt;m_pPrev.store( pNew, std::memory_order_release ); break ; // Enqueue done! } /* CAS  ‚Äî pTail  (   CAS  C++11:     !)   pTail Hazard Pointer' */ guards.assign( 0, node_traits::to_value_ptr( pTail )); // High contention -  bkoff(); } return true; }</span></span></code> </pre><br>  It turns out that we are optimists: we build the <code>pPrev</code> list (the most important for us), counting on success.  And if then we find the forward and reverse list mismatches - well, we will have to spend time on reconciliation (launch <code>fix_list</code> ). <br>  So what's the bottom line?  Both <code>enqueue</code> and <code>dequeue</code> we now have exactly one CAS.  Price - run <code>fix_list</code> when a list violation is detected.  Big is the price or small - the experiment will say. <br>  The working code can be found in the <code>cds/intrusive.optimistic_queue.h</code> , the <code>cds::intrusive::OptimisticQueue</code> class of the <code>cds::intrusive::OptimisticQueue</code> library. <br><br><h2>  Wait-free queue </h2><br>  To end the conversation on the classic queue, it is worth mentioning the <a href="http://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdf">wait-free queue</a> algorithm. <br>  Wait-free is the most stringent requirement among others.  It says that the execution time of the algorithm should be finite and predictable.  In practice, wait-free algorithms are often noticeably (surprise!) <i>Inferior</i> in performance to their less strict counterparts ‚Äî lock-free and obstruction-free ‚Äî outperforming them in the number and complexity of the code. <br>  The structure of many wait-free algorithms is rather standard: instead of performing an operation (in our case <code>enqueue</code> / <code>dequeue</code> ), they first <i>declare</i> it, save the operation descriptor together with the arguments in some shared shared storage, and then begin to help competing threads: browse descriptors in the repository and try to accomplish what is written in them (descriptors).  As a result, with a large load, several threads perform the same work, and only one of them will be the winner. <br>  The complexity of implementing such algorithms in C ++ is mainly how to implement this storage and how to get rid of memory allocation under descriptors. <br>  The <code>libcds</code> library <code>libcds</code> not have a wait-free queue implementation.  For the authors themselves cite disappointing data on its performance in their research. <br><br><h1>  Test results </h1><br>  In this article, I decided to change my dislike for comparative tests and present the results of testing the above algorithms. <br>  Tests - synthetic, test machine - dual-processor Debian Linux, Intel Dual Xeon X5670 2.93 GHz, 6 cores per processor + hyperthreading, a total of 24 logical processors.  At the time of the tests, the car was almost free - idle at 90%. <br>  Compiler - GCC 4.8.2, optimization <code>-O3 -march=native -mtune=native</code> . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The queues to be tested are from the namespace </font></font><code>cds::container</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, not intrusive. </font><font style="vertical-align: inherit;">This means that memory is allocated for each element. </font><font style="vertical-align: inherit;">We will compare with standard implementations </font></font><code>std::queue&lt;T, std::deque&lt;T&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>std::queue&lt;T, std::list&lt;T&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with synchronization mutex. </font><font style="vertical-align: inherit;">Type </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a structure of two integers. </font><font style="vertical-align: inherit;">All lock-free queues are based on Hazard Pointer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endurance test </font></font></h2><br>   .  10  <code>enqueue</code> / <code>dequeue</code>  .      10  <code>enqueue</code> ,   75%  ‚Äî  <code>enqueue</code> , 25% ‚Äî <code>dequeue</code> (     10  <code>enqueue</code>  2.5  ‚Äî <code>dequeue</code> ).   ‚Äî  <code>dequeue</code> 7.5  ,     . <br>       :    , , ,    . <br>   ‚Äî   : <br><img src="https://habrastorage.org/getpro/habr/post_images/02d/0e1/8dd/02d0e18dd82246089ab4e59b6d007cda.png"><br>  What can I say? ,     ‚Äî    <i></i> <code>std::queue&lt;T, std::deque&lt;T&gt;&gt;</code> .  Why? ,      : <code>std::deque</code>     N ,     .    ,        ,       ,    ,  ,    [].  ,  <code>libcds</code>     ,       ,     . <br>    lock-free , ,    ,      <code>MSQueue</code> ,   ,      . <br><br><h2> Prodcer/consumer test </h2><br>    .  N   N  .   10   , ,  10   .     ‚Äî       . <br>   ‚Äî   : <br><img src="https://habrastorage.org/getpro/habr/post_images/53e/fcc/220/53efcc220ce61d2fbce1be193079bcca.png"><br>  lock-free     .   <code>OpimisticQueue</code> , ‚Äî ,   ,      ,  . <br>      , ‚Äî       ,        (  ).  ,  , ‚Äî ,   ,      ,     ,     ‚Äî     . <br><br><div class="spoiler"> <b class="spoiler_title"> ‚Äî    </b> <div class="spoiler_text">      ‚Ä¶ <br>      <a href="http://habrahabr.ru/company/ifree/blog/216013/"></a>   lock-free     <code>libcds</code> elimination back-off   Treiber'.  , ,    /     C++    (,  ,    , ‚Äî        ).      ,     elimination back-off,      ‚Äî  .      <a href="http://sourceforge.net/p/libcds/code/HEAD/tree/"> libcds</a> . <br>    <s></s>    .   ‚Äî   . <br>  ‚Äî producer/consumer:      ( <code>push</code> ),  ‚Äî  ( <code>pop</code> ).    ‚Äî  ,    ‚Äî   .    ‚Äî 10  (  10  <code>push</code>  10  <code>pop</code> ).      . <br>    : <br><img src="https://habrastorage.org/getpro/habr/post_images/5f4/7e1/913/5f47e19135293897b9324aaefc03d9e8.png"><br> ,     . <br> ,         elimination back-off?  ,   ,  <code>push</code> / <code>pop</code>    .        (    <code>libcds</code>    ,   ),  ,   10  <code>push/pop</code>   10 ‚Äì 15  (   64 ),    0.1%,     (     elimination back-off)  35 ! ,    elimination back-off  ,            (       elimination back-off  5 ),        . <br></div></div><br><br><h1>  findings </h1><br> ,    lock-free ,    .        ‚Äî   .       ,     . ,            . <br><br>      , ,    lock-free,  CAS   -    . ,   -  ,      (  ), -     . <br>       ¬´ ¬ª. <br><br>  To be continued‚Ä¶ <br><div class="spoiler"> <b class="spoiler_title">Lock-free  </b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/195948/">   </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/196548/">    </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/197520/"> </a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/202190/">  </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/216013/"> </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/219201/"> </a> </li><li> <a href="http://habrahabr.ru/post/230349/"> </a> </li><li> <a href="http://habrahabr.ru/post/250383/">Concurrent maps: </a> </li><li> <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li> <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li> <a href="https://habrahabr.ru/post/251267/">Concurent maps: </a> </li><li> <a href="https://habrahabr.ru/post/314948/">: multi-level array</a> </li><li> <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/196834/">  libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/219201/">https://habr.com/ru/post/219201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219187/index.html">Methods of formation of cost in the procurement unit ERP-systems</a></li>
<li><a href="../219189/index.html">How dies technology? Elements of Reliability Theory</a></li>
<li><a href="../219191/index.html">Raspberry Pi integration with NetBeans 8.0</a></li>
<li><a href="../219193/index.html">Unity3d Lessons from Unity 3D Student (B17-B20)</a></li>
<li><a href="../219199/index.html">Startup or how not to give up</a></li>
<li><a href="../219209/index.html">John Resig: Write the code every day</a></li>
<li><a href="../219211/index.html">This is Science: Silicon electronics: bend me completely</a></li>
<li><a href="../219213/index.html">Build 2014. Announced changes in Windows and Windows Phone app stores</a></li>
<li><a href="../219217/index.html">The digest of interesting news and materials from the world of PHP No. 39 (March 24 - April 14, 2014)</a></li>
<li><a href="../219219/index.html">Github cheat sheet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>