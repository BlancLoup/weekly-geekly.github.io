<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ChatScript Intelligent Chat Bots: The Basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chat bots that communicate with a person in a natural language are very popular and in demand. Today we want to share with you the first part of the t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ChatScript Intelligent Chat Bots: The Basics</h1><div class="post__text post__text-html js-mediator-article">  Chat bots that communicate with a person in a natural language are very popular and in demand.  Today we want to share with you the first part of the translation of the material on the development of chat bots using ChatScript (CS), written by a <a href="https://webbylab.com/">WebbyLab</a> employee based on the experience he gained while working on one of the company's recent projects.  Here, in particular, we will focus on the basics of working with CS, considered from the point of view of a programmer-practice.  ChatScript is good because it is relatively easy to develop large-scale systems with artificial intelligence capabilities, and because it is easy to integrate it into projects written in JavaScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/560/614/811/56061481168624996ee26ffd6f2e1148.jpg"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Formulation of the problem</font> </h2><br>  One day, a company where I work, WebbyLab, was faced with the task of developing an intelligent chat bot for an insurance company from the United States.  At the time of the start of work, the client already had a user interface for chatting on Facebook.  We needed to make sure that the bot that ‚Äúsits‚Äù behind this interface would understand the users' messages and intelligently respond to them, analyzing the phrases and extracting the necessary information from the entered data.  We decided to separate the statements of users according to their possible intentions and implement a mechanism for recognizing these intentions based on a set of phrases.  In addition, it was necessary to take into account the fact that intentions may contain various parameters (for example, the area of ‚Äã‚Äãa house, date, car model) that the chat bot also needed to be recognized.  ChatScript was chosen as the platform for the project. <br><br><h2>  <font color="#3AC1EF">ChatScript</font> </h2><br>  To get started, take a closer look at ChatScript.  This is the chat bots engine, the programs created on which received the L√∂bner Prize four times.  It was developed by Sue and Bruce Wilcox.  CS is based on rules and working with it can resemble a declarative programming approach, similar to writing a configuration file or grammar for an interpreter.  However, working with CS is closer to imperative programming, because here, in addition, you have to use commands in order to inform the engine about how to respond to a particular message.  CS is written in C ++, the engine has binary builds for Windows, Linux and MacOS platforms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#3AC1EF">Development of a simple bot</font> </h2><br>  The best way to master a software tool is to try it out in practice, to create something simple and easy to understand with it.  This is the project we are going to do now.  In addition, I advise you to look at this <a href="https://medium.freecodecamp.com/chatscript-for-beginners-chatbots-developers-c58bb591da8">article</a> about and go through the official ChatScript tutorial. <br><br>  First of all, it is worth preparing a comfortable workplace.  To do this, I advise you to install development tools that support syntax highlighting CS.  Here are the plugins for <a href="https://packagecontrol.io/packages/ChatScript%2520Syntax">Sublime Text 3</a> , <a href="https://marketplace.visualstudio.com/items%3FitemName%3Dkuzyn.chatscript-language">Visual Studio Code</a> and <a href="https://atom.io/packages/language-chatscript">Atom</a> .  I used Sublime, because sometimes you had to open huge files, and this editor quickly copes with this task, but you can choose the editor that you like. <br><br>  In order to clarify the basic things, I will consider a step-by-step example of developing a valid chat bot.  My example uses Ubuntu 16.04 and CS 7.4., But you can use any other supported platform. <br><br>  <b>1.</b> Clone the CS repository with GitHub: <br><br><pre><code class="hljs php">git <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//github.com/bwilcox-1234/ChatScript.git</span></span></code> </pre> <br>  <b>2.</b> <code>ChatScript</code> directory and create a folder for the chat bot with the file for the main topics (what we have, we‚Äôll discuss below), and the files <code>filesfood.txt</code> file that contains the list of topics included in the application: <br><br><pre> <code class="hljs dos">bash <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ChatScript/RAWDATA <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> FOOD touch FOOD/food.top touch filesfood.txt</code> </pre> <br>  <b>3.</b> <code>implecontrol.top</code> s <code>implecontrol.top</code> file from <code>RAWDATA/HARRY</code> to the <code>FOOD</code> folder.  This is the script required to interact with the bot.  Here, although it is not necessary, you can change the value of the <code>$botprompt</code> variable in the 9th line of the s <code>implecontrol.top</code> file with the line that will be inserted before each bot message.  However, you can leave everything as it is (the default is <code>HARRY</code> ), since it does not affect the behavior of the bot.  In my example, I use the following setting for this variable: <code>$botprompt = ^"fastfood&gt;</code> . <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">bash</span></span> cp HARRY/simplecontrol.top FOOD/simplecontrol.top</code> </pre> <br>  <b>4.</b> Add the following code to the <code>food.top</code> file: <br><br><pre> <code class="hljs axapta">topic: ~fastfood keep repeat [] t: Hello in our online fastfood. Please make your <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>. u: BURGER (I [want need take] _[burger potato ice-cream]) $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> = _0 Okay, you want $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> . Something <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>?</code> </pre> <br>  <b>5.</b> Add to the <code>filesfood.txt</code> file a list of files that will be used when building the bot: <br><br><pre> <code class="hljs">RAWDATA/FOOD/simplecontrol.top RAWDATA/FOOD/food.top</code> </pre> <br>  <b>6.</b> And finally, collect and run the bot.  To do this, run the following command from the ChatScript directory: <br><br><pre> <code class="hljs pgsql">./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span></code> </pre> <br>  <b>7.</b> At this stage, you can choose any username.  Next, in the CS console, you need to execute two commands (the first collects the basic level of the chat bot, the second sets it up for a specific topic): <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:build</span></span> 0 <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:build</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">food</span></span></code> </pre> <br>  After completing all these steps, we will have a working chat bot.  At the moment, he understands only a few phrases (like ‚ÄúI need a burger‚Äù and ‚ÄúI want ice-cream‚Äù), but it can be expanded by adding new rules and topics.  After any changes to the <code>food.top</code> file, run the command again <code>:build food</code> .  Below we will talk more about the syntax and constructs used in this example. <br><br><h2>  <font color="#3AC1EF">Basic ChatScript Constructs</font> </h2><br>  Now you can get down to work with ChatScript.  But for starters, I advise you to learn a little more about the <a href="">basic constructs of CS</a> by reading the official documentation.  Here I will talk about the basic mechanisms of CS, relying on my own experience with this medium for developing chatbots. <br><br><h3>  <font color="#3AC1EF">Topiki</font> </h3><br>  A topic (topic) is a set of rules to be shared.  If we suggest the system to use a specific topic, then as long as they work with it, only the rules from this topic will act.  Topics are declared using a keyword ( <code>topic:</code> , followed by a name beginning with a ‚Äú <code>~</code> ‚Äù sign ( <code>~fastfood</code> ) and a list of functions ( <code>keep repeat</code> ) that should be used for all the rules inside the topic (the <code>keep</code> and <code>repeat</code> functions are needed to return to this topic after calling each rule inside it).  At the end of the announcement are square brackets - <code>[]</code> : <br><br><pre> <code class="hljs swift">topic: ~fastfood keep <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> []</code> </pre> <br>  Each topic usually includes a set of related rules.  Switching between topics, or in other words, calling one topic from another, is done using the <code>^respond</code> method, which we will discuss below. <br><br><h3>  <font color="#3AC1EF">‚ñçRules</font> </h3><br>  A <code>rule</code> is a call to an action when a pattern within it matches the data sent to the chat bot.  Rules must be posted after the announcement of topics. <br><br><pre> <code class="hljs pgsql">u: BURGER (I want ari-burger) Okay, your <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> hamburger</code> </pre> <br>  Rule descriptions typically include a type ( <code>u:</code> , a label (for example, <code>BURGER</code> ; this is optional, but useful for debugging and self-documenting code), a template (everything that is in brackets).  The description of the rule, in addition, can be divided into several lines in order to improve the readability of the code.  CS does not pay attention to line breaks, a sign of the end of the rule is the declaration of a new rule or topic.  In the rule, you can use the command to go to another topic - the <code>^respond</code> function: <br><br><pre> <code class="hljs">u: BURGER (I want ari-burger)  ^respond(~answers)</code> </pre> <br>  In this case, the input data will be processed by the rules from the topic passed to the <code>^respond</code> function.  This approach can give us the opportunity to divide CS-scripts into parts, or, for example, place the formatting of answers for phrases in separate topics. <br><br><h3>  <font color="#3AC1EF">‚ñçVariables and working with memory</font> </h3><br>  Variables in CS are a mechanism for storing user input.  There are variables for short-term information storage ‚Äî their values ‚Äã‚Äãare cleared after exiting the templates, and user variables, long-term data stores, which store values ‚Äã‚Äãuntil they are cleared.  Here is an example of a rule code that uses short-term variables: <br><br><pre> <code class="hljs axapta">u: ORDER (I want _)  $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> = _0  Okay, your <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> is $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span></code> </pre> <br>  The underscore indicates a short-term variable (you can specify how many words you need to remember in such a variable, using, for example, the <code>_*</code> construct, which corresponds to all words, or <code>_*2</code> , which corresponds to two words, and so on).  As a result, if the above code works, the word from the entered data that comes after ‚ÄúI want‚Äù will be stored in short-term memory.  In order to access it, the second line uses the construction <code>_0</code> .  A template can include as many of these variables as needed (usually no more than 20, but this is usually enough), while the values ‚Äã‚Äãare obtained from them using names consisting of an underscore and a sequence number of a match inside pattern.  In this example, <code>$order ‚Äî</code> a user variable in which what is stored in <code>_0</code> written. <br><br><h3>  <font color="#3AC1EF">‚ñçTemplates</font> </h3><br>  A pattern is used to describe the order and set of words, the appearance of which is expected in what the user will enter when communicating with the bot.  In my opinion, a very remarkable possibility of CS templates is that when describing them, you do not need to add all forms of each word.  The system has built-in support for the mechanism, during which in the pattern, which includes only one form of the word, all forms of this word can be found. <br><br>  For example, take the verb ‚Äúbe‚Äù.  Adding it to the template also includes this verb in it in all its forms: am, is, are, was, were, were.  However, to process data containing auxiliary verbs (will, have, do), they must be added in an explicit form - CS can automatically process different forms only for individual words.  For this purpose, I advise you to use another possibility of templates - an optional word in curly braces: <br><br><pre> <code class="hljs delphi">u: BURGER (I <span class="hljs-comment"><span class="hljs-comment">{will}</span></span> take _burger)</code> </pre> <br>  The same applies to nouns and pronouns - it is enough to add a word in the nominative singular, after which CS will look for matches for all variants of the word, using its internal mechanisms.  In templates, you can also expand variants of phrases that correspond to a certain statement, using sets of words in certain positions of the template.  Expanding our example, we can add the following to it: <br><br><pre> <code class="hljs axapta">u: BURGER (I {will} [want need take] [_burger hamburger potato ice-cream])  $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> = _0  Okay, your <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> is $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span></code> </pre> <br>  This rule will correspond to all sentences entered by the user with combinations of the specified words (for example, ‚ÄúI want a hamburger‚Äù, ‚ÄúI will take a potato‚Äù, ‚ÄúI need ice-cream‚Äù).  Another important feature of memoization, which I did not find descriptions in the official CS documentation, is how short-term variables work in sets (if you find this topic in the documentation - let me know please).  In fact, in a similar situation in a short-term memory, in the variable <code>_0</code> , any matched word from the set will be saved.  The custom variable <code>$order</code> , in any case, when a match is found, will get some value. <br><br>  In addition, you can control the beginning and end of user-entered phrases using <code>&lt;</code> and <code>&gt;</code> signs: <br><br><pre> <code class="hljs xml">u: BURGER (<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">I</span></span></span><span class="hljs-tag"> {</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">will</span></span></span><span class="hljs-tag">} [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">want</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">need</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">take</span></span></span><span class="hljs-tag">] [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">_burger</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hamburger</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">potato</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ice-cream</span></span></span><span class="hljs-tag">] &gt;</span></span>)</code> </pre> <br>  Inside the templates, in fact, you can still do a lot of interesting things.  For example - to check values ‚Äã‚Äãfor compliance with some criteria.  For example, this is what can be done if, within a certain range, we are only interested in numbers: <br><br><pre> <code class="hljs kotlin">u: OLD_ENOUGH (I be _~number _0&gt;<span class="hljs-number"><span class="hljs-number">21</span></span> _0&lt;<span class="hljs-number"><span class="hljs-number">120</span></span>)  You are old enough <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>. u: TOO_YOUNG (I be _~number _0&lt;<span class="hljs-number"><span class="hljs-number">21</span></span>)  $missed_age = <span class="hljs-number"><span class="hljs-number">21</span></span> - _0  You are too young <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, come after $missed_age years.</code> </pre> <br><h3>  <font color="#3AC1EF">Concepts</font> </h3><br>  A concept is a collection of words or combinations of words associated with a single keyword (concept name).  A concept ad is similar to a topic ad.  The list of words related to the concept is given in square brackets: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">food_type</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[burger potato salad ice-cream]</span></span></code> </pre> <br>  After declaring a concept, you can use it as an alias in rules like this (now our template will find matches only for words defined in the <code>~food_type</code> concept): <br><br><pre> <code class="hljs axapta">u: BURGER (I want _~food_type) $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> = _0 Okay, your <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> is $<span class="hljs-keyword"><span class="hljs-keyword">order</span></span></code> </pre> <br>  Moreover, some concepts can be nested in others, creating an additional level of abstraction, grouping different sets of words in one parent concept: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">dessert</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ice-cream sweets cookie]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">burger</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[burger hamburger cheeseburger vegeterainburger]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">food_type</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[~burger ~dessert potato salad]</span></span></code> </pre> <br>  If you need to find out to which particular concept the word with which a match is found belongs, you can use the <code>pattern</code> keyword.  In the following example, the value stored in the <code>$drink</code> variable is checked for its belonging to the concept <code>~alcohol</code> .  For this purpose we use the keyword <code>pattern</code> and the sign <code>?</code>  in the <code>if</code> expression, dividing them with what we check and the target value of the concept (CS supports <code>if-else</code> ): <br><br><pre> <code class="hljs perl">concept: ~drink_type [~alcohol ~non_alcohol] concept: ~alcohol [rum gean wiskey vodka] concept: ~non_alcohol [cola juice milk water] u: DRINK (^want(<span class="hljs-number"><span class="hljs-number">_</span></span>~drink_type))  $drink = _<span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern $drink?~alcohol) {      ^respond(~age_checker)  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      Ok, take <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> drink your $drink .  }</code> </pre> <br>  If you need to find matches not only with individual words of user input, but also with combinations of words, you can also add them to the concept, enclose in quotes, or using underscores between the words in one phrase (this approach is also used when you need to find matches with punctuation marks): <br><br><pre> <code class="hljs scala">concept: ~vegburger [<span class="hljs-string"><span class="hljs-string">"vegeterian burger"</span></span> <span class="hljs-string"><span class="hljs-string">"vegeterian's burger"</span></span> vegan_burger vegan_<span class="hljs-symbol"><span class="hljs-symbol">'s_burger</span></span>]</code> </pre> <br>  These approaches are similar, but I prefer to use quotes, as they make it easier to read the code. <br><br>  Another interesting feature of CS is the availability of standard concepts defined at the engine level.  They allow you to use already prepared sets for the most frequently used in natural language phrases and single words with the same or similar meaning.  Among them are the concepts <code>~yes</code> and <code>~no</code> , which include phrases that can be interpreted in natural language as positive and negative.  For example, the concept <code>~yes</code> contains words and phrases such as yes, yeah, ok, okay, sure, of_course, alright, and many others (183 total).  There are 138 corresponding words and phrases in the <code>~no</code> concept.  Here are some other concepts that were useful to us when working on the project: <br><br><ul><li>  <code>~number</code> - helps to find matches with numbers. <br></li><li>  <code>~yearnumber</code> - is a subset of <code>~number</code> that contains only values ‚Äã‚Äãfrom 999 to 10000. <br></li><li>  <code>~dateinfo</code> - helps to find dates in the text, using the format of the record with a slash.  For example, mm_dd_yy or mm_dd_yyyy will be recognized as the strings ‚Äúmm / dd / yy‚Äù or ‚Äúmm / dd / yyyy‚Äù. <br></li><li>  <code>~timeword</code> - when using this concept, for example, for ‚Äú1 July 2017‚Äù and for ‚ÄúJuly 1 2017‚Äù, ‚ÄúJuly 1 2017‚Äù will be returned.  In addition, this concept includes a huge set of words related to time, like second, yesterday, already, and so on). <br></li></ul><br>  Here is <a href="">the</a> CS <a href="">documentation section</a> where you can find information about all embedded concepts. <br><br>  If, for some reason, you need to extend the existing standard concepts, you can add entries to the file <code>LIVEDATA_ENGLISH_SUBSTITUTES/interjections.txt</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">roger_that</span></span></span><span class="hljs-tag">&gt;</span></span> ~yes</code> </pre> <br>  After that, just restart the ChatScript engine and the phrase ‚Äúroger that‚Äù will be added to the <code>~yes</code> concept.  The angle brackets at the beginning and at the end of a phrase mean that only these two words will be considered a match, and nothing more. <br><br>  In addition, existing concepts can be expanded in a different way - new values ‚Äã‚Äãcan be added to them using the keyword <code>MORE</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">food</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[burger potato]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">food</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MORE</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ice-cream]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF"> Macros</font> </h3><br>  In order to ensure code reuse, CS contains macros ‚Äî functions that a programmer develops that are called to generate output data or to use them in templates.  JSON is used in our project, as a result, the output must be properly formatted so that they can be transferred to the JS wrapper class.  For this purpose, I decided to prepare a string that can be easily parsed in JavaScript.  Every time the system generates some output, I convert it to a JSON string.  However, in CS there are methods for working with JSON.  If we use all this with the use of <code>outputmacro</code> , we will get a simple and convenient way to format the output for the application backend API: <br><br><pre> <code class="hljs perl">outputmacro: ^formated_in_json(^param_from_rule) {  $_result = ^jsoncreate(object)  $_result.first_level_param = ^param_from_rule  $_result.nested_object = ^jsoncreate(object)  ^jsonwrite($_result) }</code> </pre> <br>  Using macros in the rules looks exactly the same as using the above described standard function <code>^respond</code> : <br><br><pre> <code class="hljs">u: FOOD (I want _~food_type)  ^formated_in_json(_0)</code> </pre> <br>  Since macros can be written for different output formatting depending on parameters, it is possible to create them for templates with similar constructions for a set of rules using <code>patternmacro</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">patternmacro</span></span>: ^<span class="hljs-selector-tag"><span class="hljs-selector-tag">want</span></span>(^<span class="hljs-selector-tag"><span class="hljs-selector-tag">appendix</span></span>)  <span class="hljs-selector-attr"><span class="hljs-selector-attr">[i we]</span></span> * <span class="hljs-selector-attr"><span class="hljs-selector-attr">[want need take]</span></span> ^<span class="hljs-selector-tag"><span class="hljs-selector-tag">appendi</span></span></code> </pre> <br>  Part of the template returned by the macro can be reused in a variety of other templates, which allows to simplify the script: <br><br><pre> <code class="hljs pgsql">u: FOOD (^want(_~food_type))  <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> you want _0, you should <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> \_0 . u: DRINK (^want(_~drink_type))  Ok, take <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> drink your _0 .</code> </pre> <br><h2>  <font color="#3AC1EF">Chat bot scheme</font> </h2><br>  The following diagram shows the location of each of the CS constructs that we talked about in a chat bot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/7a6/a1f/cf87a6a1f12a4a84a19257e3c65af59c.png"></div><br>  <i><font color="#999999">Chat bot scheme</font></i> <br><br>  As you can see, topics, concepts and macros must be declared in the outer layer of the bot.  The rules are nested in topics.  Each rule, as an input point, has a pattern, and something like a responder, or a rule body, which is executed only if the current pattern is called.  Concepts and template macros declared outside the topic are then used internally with variables for short-term data storage containing the values ‚Äã‚Äãnecessary to form a response.  At the same time, a macro can be called in the responder to process the output values.  Variables for long-term data storage are used to transfer data from short-term variables to other topics if the responder calls a command like <code>^respond(~another_topic)</code> .  This means that the processing of data, which will then be displayed to the user, will be taken up by the rules in another topic. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today you learned about the basics of ChatScript, which means that if you want to use this engine to develop your own bot, you can start planning the project.  From the next part of this material, you will learn about the CS environment, about debugging CS projects, about integrating CS and JavaScript, and how to deal with the problems that can arise when developing ChatScript chatbots. <br><br>  <b>Dear readers!</b>  Do you create chat bots?  If so, please tell us about the tools you use. </div><p>Source: <a href="https://habr.com/ru/post/344604/">https://habr.com/ru/post/344604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344594/index.html">Update Veeam Availability Suite 9.5: what you need to know</a></li>
<li><a href="../344596/index.html">Hadoop 3.0: a brief overview of new features</a></li>
<li><a href="../344598/index.html">The ill traveler and the yellow October</a></li>
<li><a href="../344600/index.html">Tutorial on the Unreal Engine. Part 4: UI</a></li>
<li><a href="../344602/index.html">Blockchain 101: Books, Research, and Related Articles</a></li>
<li><a href="../344606/index.html">Dependencies of our dependencies or a few words about the vulnerability of our projects</a></li>
<li><a href="../344608/index.html">Italian robot strike</a></li>
<li><a href="../344610/index.html">Innopolis eyes of a resident of Moscow</a></li>
<li><a href="../344614/index.html">Adding special offers to customers in emails using Zentyal + Postfix + alterMIME</a></li>
<li><a href="../344616/index.html">Criticism 1C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>