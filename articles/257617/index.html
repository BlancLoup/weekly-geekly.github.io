<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three features of JavaScript, which is useful to know every Java / C developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes JavaScript can mislead a developer, and sometimes lead to white heat because of its incomplete consistency. There are some things in JavaScr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three features of JavaScript, which is useful to know every Java / C developer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b5b/d91/ecf/b5bd91ecffe945a084958735182e11f9.jpg"><br><br>  Sometimes JavaScript can mislead a developer, and sometimes lead to white heat because of its incomplete consistency.  There are some things in JavaScript that just confuse and confuse.  The most famous of these are <a href="http://www.2ality.com/2011/06/with-statement.html">the with statement</a> , <a href="http://yuiblog.com/blog/2006/06/01/global-domination/">implicit global variables,</a> and <a href="http://dorey.github.io/JavaScript-Equality-Table/">strange behavior during a comparison operation</a> . <br><br>  Perhaps, the most controversy in the history of programming has flared up around JavaScript.  In addition to its shortcomings (partly discussed in the new ECMAScript specifications), most programmers are unhappy with the following points: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  DOM, which many mistakenly consider the equivalent of the JavaScript language itself, has a very unsuccessful API. </li><li>  When you switch to JavaScript from C and Java languages, you fall into the trap of syntax, which is not like in imperative languages.  This very often leads to bugs and is very annoying. </li></ul><br>  As a result, JavaScript has gained a rather bad reputation, which, in general, it does not deserve.  And most often this is due to the fact that many developers transfer their experience in Java or C / C ++ to JavaScript.  Here are three of the most difficult cases, demonstrating the difference in approaches between Java and JavaScript. <br><a name="habracut"></a><br><h2>  Area of ‚Äã‚Äãvisibility </h2><br>  Most developers switch to javascript due to the need.  And almost everyone repeats one mistake - they start writing code without first learning the features of the language.  Many people at least once have difficulty with areas of visibility. <br><br>  The syntax of JavaScript is very similar to that used in the C family, with its curly braces separating the constructs of functions, <code>if</code> and <code>for</code> .  Therefore, many developers assume that the scope at the block level is arranged along similar principles.  Unfortunately, this is not the case. <br><br>  First, the scope of variables is determined by functions, not parentheses.  That is, <code>if</code> and <code>for</code> do not create a new scope, and the variable declared in their constructions, in fact, "rises".  That is, it is created at the beginning of the very first function in which it is declared, in other words, in the global scope. <br><br>  Secondly, the presence of a <code>with</code> statement makes the JavaScript scope dynamic, it cannot be determined before the program starts.  It is better to avoid using <code>with</code> at all; without it, JavaScript becomes a language that uses lexical scopes.  That is, it will be enough to read the code in order to understand all the scopes. <br><br>  Formally, in JavaScript there are four ways to include an identifier in scope: <br><br><ul><li>  <b>According to the language standard</b> : by default, all fields contain the identifiers this and arguments. </li><li>  <b>Based on formal parameters</b> : the scope of any formal parameter of a function is limited to the function body. </li><li>  <b>Using the function declaration</b> . </li><li>  <b>Using variable declarations.</b> </li></ul><br>  But one thing to keep in mind: declaring (implicit) variables without using <code>var</code> leads to an implicit definition of the global scope.  The same applies to the <code>this</code> pointer when the function is called without explicit binding. <br><br>  Before going into details, it is recommended to use strict mode ( <code>'use strict';</code> ) and place all declarations of variables and functions at the beginning of each function.  Avoid declaring variables and functions inside <code>for</code> and <code>if</code> blocks. <br><br><h4>  Uplifting </h4><br>  This term is used to simplify the description of how an ad is actually performed.  Raised variables are declared at the very beginning of the functions containing them, and then initialized as <code>undefined</code> .  Assignment is carried out directly in the line where the declaration occurs. <br><br>  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }</code> </pre><br>  What do you think will be displayed on the screen? <br><br><pre> <code class="javascript hljs"><span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  The <code>var</code> statement does not declare a local copy of the variable <code>i</code> inside an <code>if</code> block.  Instead, it overwrites the previously declared.  Notice that the first <code>console.log</code> statement displays the actual value of the variable <code>i</code> , initialized as undefined.  And if you go into strict mode?  In <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">strict mode,</a> variables <b>must be</b> declared before they are used, but the JavaScript engine does not require it.  By the way, keep in mind that <code>var</code> . Will not be required from you.  If you need to catch such bugs, then use tools like <a href="http://www.jshint.com/">JSHint</a> or <a href="http://www.jslint.com/">JSLint</a> . <br><br>  Let's look at an example that demonstrates another way of declaring variables that can lead to errors: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notNull = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notNull) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Null-ish, so far"</span></span>, notNull); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notNull = <span class="hljs-number"><span class="hljs-number">10</span></span>; notNull &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; notNull++){ <span class="hljs-comment"><span class="hljs-comment">//.. } console.log("Now it's not null", notNull); } console.log(notNull); }</span></span></code> </pre><br>  In this example, the <code>if</code> block is executed because the local copy of the <code>notNull</code> variable <code>notNull</code> declared inside the <code>test()</code> function and <b>raised</b> .  The casting operation plays its role here. <br><br><h4>  Functional expressions and function declarations </h4><br>  Raising can be applied not only to variables, but also to functional expressions, which are actually variables, and to function declarations.  This feature is only briefly mentioned here.  In short, function declarations generally behave as functional expressions, except that their declarations are placed at the beginning of their scope. <br><br>  Here is an example function declaration: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// A function declaration function bar() { return 3; } return bar(); // This function declaration will be hoisted and overwrite the previous one function bar() { return 8; } }</span></span></code> </pre> <br>  Now compare with the example of a functional expression: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// A function expression var bar = function() { return 3; }; return bar(); // The variable bar already exists, and this code will never be reached var bar = function() { return 8; }; }</span></span></code> </pre><br>  For a deeper understanding of the issue is to refer to the publications listed at the end of the post. <br><br><h4>  With </h4><br>  This example reflects the situation when the scope can only be determined at run time: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } }</code> </pre><br>  If <code>y</code> has a field <code>x</code> , then the function <code>foo()</code> returns <code>yx</code> , otherwise - <code>123</code> .  This practice can lead to errors at the execution stage, so it is recommended to avoid using the <code>with</code> statement. <br><br><h4>  Looking to the future: ECMAScript 6 </h4><br>  <a href="http://www.sitepoint.com/preparing-ecmascript-6-let-const/">ECMAScript 6</a> specifications will allow the implementation of a fifth way to define a block-level scope: the <code>let</code> statement. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }</code> </pre><br>  In ECMAScript 6, an <code>i</code> declaration inside an <code>if</code> using let will create a new local variable in an <code>if</code> block.  As a non-standard alternative, you can declare <code>let</code> blocks: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Other code here */</span></span> } <span class="hljs-comment"><span class="hljs-comment">// prints 6 console.log(i);</span></span></code> </pre><br>  In this example, the variables <code>i</code> and <code>j</code> will exist only inside the block.  At the time of writing this post, only Chrome is <a href="http://kangax.github.io/compat-table/es6/">supported</a> using <code>let</code> . <br><br><h4>  In other languages </h4><br>  Below is a comparative table of the features of the implementation of scopes in different languages: <br><table><tbody><tr><th>  Property </th><th>  Java </th><th>  Python </th><th>  Javascript </th><th>  Note </th></tr><tr><th>  Area of ‚Äã‚Äãvisibility </th><td>  Lexical (blocks) </td><td>  Lexical (functions, classes or modules) </td><td>  Yes </td><td>  It does not work at all like in Java or C. </td></tr><tr><th>  Block scope </th><td>  Yes </td><td>  Not </td><td>  In conjunction with <code>let</code> (ES6) </td><td>  It does not work at all like in Java. </td></tr><tr><th>  Raising </th><td>  Not </td><td>  Not </td><td>  Yes </td><td>  For the declaration of variables, functions and functional expressions. </td></tr></tbody></table><br><h2>  Functions </h2><br>  Functions are often another stumbling block in JavaScript.  The reason is that imperative languages ‚Äã‚Äãlike Java use a completely different concept.  JavaScript refers to functional programming languages.  True, it is not purely functional, yet it clearly shows the imperative style and encourages mutability.  But be that as it may, JavaScript can only be used as a functional language, without any external influence on function calls. <br><br>  In JavaScript, functions can be accessed like any other data type, for example, <code>String</code> or <code>Number</code> .  They can be stored in variables and arrays, passed as arguments to other functions, and returned by other functions.  They can have properties, they can be dynamically changed, and all this thanks to objects. <br><br>  For many newbies to JavaScript, the fact that the functions here are objects is amazing.  The <code>Function</code> constructor creates a <code>Function</code> object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>([<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>], <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  This is almost the same: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre><br>  Almost - because using a constructor is less efficient.  It generates an anonymous function and does not create a closure for its context.  <code>Function</code> objects are always created in the global scope. <br><br>  <code>Function</code> , as a type of function, is based on <code>Object</code> .  This can be clearly seen if you disassemble any function we declare: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// prints "object" console.log(typeof test.prototype); // prints function Function() { [native code] } console.log(test.constructor);</span></span></code> </pre><br>  This means that the function has properties.  Some of them are assigned at creation.  For example, <code>name</code> or <code>length</code> , returning, respectively, the name and number of arguments in the function definition. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// prints "func" console.log(func.name); // prints 3 console.log(func.length);</span></span></code> </pre><br>  Any function can be set and other properties, at its discretion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(test.custom); } test.custom = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-comment"><span class="hljs-comment">// prints 123 test();</span></span></code> </pre><br><h4>  In other languages </h4><br>  Comparative table of implementations of functions in different languages: <br><table><tbody><tr><th>  Property </th><th>  Java </th><th>  Python </th><th>  Javascript </th><th>  Note </th></tr><tr><th>  Functions as built-in types </th><td>  Lambda java 8 </td><td>  Yes </td><td>  Yes </td><td></td></tr><tr><th>  Callback / Team Template </th><td>  Objects (or lambdas for Java 8) </td><td>  Yes </td><td>  Yes </td><td>  Functions (callbacks) </td></tr><tr><th>  Dynamic creation </th><td>  Not </td><td>  Not </td><td>  <code>eval</code> ( <code>Function</code> object) </td><td>  <code>eval</code> raises questions from a security point of view; <code>Function</code> objects can work unpredictably. </td></tr><tr><th>  Properties </th><td>  Not </td><td>  Not </td><td>  May have properties </td><td>  Access to function properties can be restricted. </td></tr></tbody></table><br><h2>  Closures </h2><br>  JavaScript was the first major programming language in which closures appeared.  As you probably know, in Java and Python for a long time there were simplified versions of closures, when you could only read some values ‚Äã‚Äãfrom the enclosing scopes.  For example, in Java, an anonymous nested class provides functionality similar to closures (with some limitations).  For example, in their scopes only final local variables can be used.  More precisely, their values ‚Äã‚Äãcan be read. <br><br>  JavaScript has full access to external variables and functions of the external scope.  They can be read, written down and, if necessary, even hidden with the help of local definitions.  Examples of this were repeatedly presented in the first chapter. <br><br>  Even more interesting is that the function created in the closure "remembers" the environment in which it was created.  By combining closures and nesting of functions, you can make it so that external functions return internal ones without their execution.  Moreover, the local variables of external functions can be stored in the closure of the internal function for a long time after the execution of the one where they were declared last time.  This is quite a powerful tool, but it has one drawback: a common problem with memory leaks in JavaScript applications. <br><br>  For a better understanding of the foregoing, let's look at a few examples. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayCounter</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-comment"><span class="hljs-comment">// prints 1 counter(); // prints 2 counter();</span></span></code> </pre><br>  The function <code>makeCounter()</code> creates and returns another function that maintains its connection with its parent environment.  Although the execution of <code>makeCounter()</code> ended with the assignment of the counter variable, the local variable i is stored in the closure of the <code>displayCounter</code> , inside of which you can access it. <br><br>  If you run <code>makeCounter()</code> again, it will create a new closure with a different initial value <code>i</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counterBis = makeCounter(); <span class="hljs-comment"><span class="hljs-comment">// prints 1 counterBis(); // prints 3 counter(); // prints 2 counterBis();</span></span></code> </pre><br>  You can also make so that <code>makeCounter()</code> takes an argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayCounter</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(++i); }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// prints 11 counter(); // prints 12 counter();</span></span></code> </pre><br>  Arguments of external functions are also stored in the closure, so we do not need to declare a local variable.  With each call to <code>makeCounter()</code> initial value we set will be remembered, from which the count will be taken. <br><br>  Closures are crucial for many fundamental things in JavaScript: namespaces, modules, private variables, memoizations, and so on.  For example, this is how you can simulate a private variable for an object: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">setName</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> newName === <span class="hljs-string"><span class="hljs-string">'string'</span></span> &amp;&amp; newName.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = newName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">"Not a valid name"</span></span>); } }, <span class="hljs-attr"><span class="hljs-attr">getName</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = Person(<span class="hljs-string"><span class="hljs-string">"Marcello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// prints "Marcello" a.getName(); // Uncaught TypeError: Not a valid name a.setName(); // Uncaught TypeError: Not a valid name a.setName(2); a.setName("2"); // prints "2" a.getName();</span></span></code> </pre><br>  This way, you can create a wrapper for the property name with our own setter and getter.  In ES 5, this has become much easier to do, since you can create objects with setters / getters for their properties and fine-tune access to these properties. <br><br><h4>  In other languages </h4><br>  Comparative table of closure implementations in different languages: <br><br><table><tbody><tr><th>  Property </th><th>  Java </th><th>  Python </th><th>  Javascript </th><th>  Note </th></tr><tr><th>  Short circuit </th><td>  Disabled, read only, in anonymous nested classes </td><td>  Handicapped, read only, in nested definitions </td><td>  Yes </td><td>  Memory leaks </td></tr><tr><th>  Memoization template </th><td>  Shared objects must be used. </td><td>  Perhaps using lists or dictionaries </td><td>  Yes </td><td>  It is better to use deferred calculations. </td></tr><tr><th>  Namespace / module pattern </th><td>  Not necessary </td><td>  Not necessary </td><td>  Yes </td><td></td></tr><tr><th>  Private Attributes Template </th><td>  Not necessary </td><td>  Is impossible </td><td>  Yes </td><td>  May be misleading </td></tr></tbody></table><br><h2>  Conclusion </h2><br>  So, this article describes three features of JavaScript, which most often confuse developers who have previously worked in other programming languages, especially Java and C. If you want to further study the topics touched, you can read these resources: <br><br>  ‚Ä¢ <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">Scoping in JavaScript</a> <br>  ‚Ä¢ <a href="http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/">Function Declarations vs Function Expressions</a> <br>  ‚Ä¢ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">Let statement and let blocks</a> </div><p>Source: <a href="https://habr.com/ru/post/257617/">https://habr.com/ru/post/257617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257607/index.html">Layered menu for Arduino and not only</a></li>
<li><a href="../257609/index.html">How to translate an entire site to permanent HTTPS for all</a></li>
<li><a href="../257611/index.html">Unknown Smalltalk</a></li>
<li><a href="../257613/index.html">Test data for HL7 messages</a></li>
<li><a href="../257615/index.html">The best reports. NEXT 2014 Moscow (video inside). Part 1: Places 6 to 10</a></li>
<li><a href="../257619/index.html">We write bot for browser game agar.io</a></li>
<li><a href="../257621/index.html">Intel Edison. Work with Intel IoT Analytics cloud: register and send data</a></li>
<li><a href="../257625/index.html">Easy debugging with PHPixie Debug</a></li>
<li><a href="../257627/index.html">Restoring damaged Innodb tables</a></li>
<li><a href="../257629/index.html">A series of freelance texts written by industry professionals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>