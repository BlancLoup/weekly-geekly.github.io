<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[F #] pattern matching</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As in many other functional programming languages, pattern matching (pattern matching) is supported in F #. Those who are not familiar with the OP can...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[F #] pattern matching</h1><div class="post__text post__text-html js-mediator-article">  As in many other functional programming languages, pattern matching (pattern matching) is supported in F #.  Those who are not familiar with the OP can imagine it as a <b>much</b> improved switch. <br><br><a name="habracut"></a><br>  Go to the code. <br><br>  <font color="Blue">let</font> <font color="Blue">rec</font> factorial n = <br>  <font color="Blue">match</font> n <font color="Blue">with</font> <br>  <font color="Blue">|</font>  <font color="Maroon">0</font> <font color="Blue">|</font>  <font color="Maroon">1</font> <font color="Blue">-&gt;</font> <font color="Maroon">1</font> <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> n * factorial <font color="Blue">(</font> n - <font color="Maroon">1</font> <font color="Blue">)</font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This code defines a recursive factorial function.  As you can see, it is very similar to switch. <br><br><h4>  Couples, threes, etc. </h4><br>  <font color="Blue">let</font> <font color="Blue">(</font> + <font color="Blue">)</font> vec multiplier = <br>  <font color="Blue">match</font> vec <font color="Blue">with</font> x, y <font color="Blue">-&gt;</font> <br>  x * multiplier, y * multiplier <br><br>  Here the element is matched with a pair of values ‚Äã‚Äã(touple).  Accordingly, x takes the value of the first element of the pair, y - the second.  Note that x and y are new value descriptors.  If earlier in the program another value was described with the name x, then it will be hidden again by the end of the branch.  In order not to introduce a new description, you must use the underscore character, as was done in the first code example.  It can occur in a sample as many times as desired and is essentially a placeholder. <br><br><h4>  Lists </h4><br><br>  <font color="Blue">let rec</font> sum = <font color="Blue">function</font> <br>  <font color="Blue">|</font>  <font color="Blue">[</font> <font color="Blue">]</font> <font color="Blue">-&gt;</font> <font color="Maroon">0</font> <br>  <font color="Blue">|</font>  head <font color="Blue">::</font> tail <font color="Blue">-&gt;</font> <br>  head + sum tail <br><br>  This abbreviated entry is equivalent to <br><br>  <font color="Blue">let rec</font> sum value = <br>  <font color="Blue">match</font> value <font color="Blue">with</font> <br>  <font color="Blue">|</font>  <font color="Blue">[</font> <font color="Blue">]</font> <font color="Blue">-&gt;</font> <font color="Maroon">0</font> <br>  <font color="Blue">|</font>  head <font color="Blue">::</font> tail <font color="Blue">-&gt;</font> <br>  head + sum tail <br><br>  The only difference is that a descriptor with the name value is not entered. <br><br>  The first pattern, [], corresponds to an empty list.  The second sample describes the list as two parts, the head (the first element) and the tail (a list of all the other elements).  Names in place of head and tail can be arbitrarily chosen.  Their field of view is to the end of the branch. <br><br>  You can separate multiple items from the beginning of the list.  el1 :: _ :: el3 :: tail <br><br><h4>  Several meanings </h4><br>  When comparing samples, one can not only break a pair into its components, but also work with a pair of values. <br><br>  <font color="Blue">match</font> host port <font color="Blue">with</font> <br>  <font color="Blue">|</font>  <font color="Maroon">‚ÄúMicrosoft.com‚Äù</font> , <font color="Maroon">80</font> <font color="Blue">-&gt;</font> Allow <br>  <font color="Blue">|</font>  <font color="Maroon">‚ÄúWarezzz.ws‚Äù</font> , <font color="Maroon">80</font> <font color="Blue">-&gt;</font> Deny <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> Forward <br><br>  Pattern matching can be used to determine types (dynamic). <br><br>  <font color="Blue">match</font> obj <font color="Blue">with</font> <br>  <font color="Blue">|</font>  <font color="Blue">:</font> ?  String <font color="Blue">as</font> str <font color="Blue">-&gt;</font> <font color="Maroon">"String!"</font> <br>  <font color="Blue">|</font>  <font color="Blue">:</font> ?  Int32 <font color="Blue">as</font> integer <font color="Blue">-&gt;</font> <font color="Maroon">"Int!"</font> <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> <font color="Maroon">"What is it?"</font> <br><br><h4>  Additional terms </h4><br>  <font color="Blue">let</font> <font color="Blue">rec</font> hasNegative = <font color="Blue">function</font> <br>  <font color="Blue">|</font>  <font color="Blue">[</font> <font color="Blue">]</font> <font color="Blue">-&gt;</font> <font color="Blue">false</font> <br>  <font color="Blue">|</font>  head <font color="Blue">::</font> tail <font color="Blue">when</font> head &lt; <font color="Maroon">0</font> <font color="Blue">-&gt;</font> <font color="Blue">true</font> <br>  <font color="Blue">|</font>  _ <font color="Blue">::</font> tail <font color="Blue">-&gt;</font> hasNegative tail <br><br>  I want to note that the comparison of samples occurs consistently and therefore if one of the samples came up, then the subsequent ones are no longer compared.  Due to this, it is not necessary to write when head&gt; = 0 in the last branch. <br><br><h4>  Active Patterns </h4><br>  This feature is probably unique to F #.  We are given the opportunity to define our own matching methods.  Consider a simple example. <br><br>  <font color="Blue">let</font> <font color="Blue">(</font> <font color="Blue">|</font> Odd <font color="Blue">|</font> Even <font color="Blue">|</font> <font color="Blue">)</font> = <font color="Blue">function</font> <br>  <font color="Blue">|</font>  x <font color="Blue">when</font> x% <font color="Maroon">2</font> = <font color="Maroon">0</font> <font color="Blue">-&gt;</font> Even <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> Odd <br><br>  <font color="Blue">match</font> <font color="Maroon">10</font> <font color="Blue">with</font> <br>  <font color="Blue">|</font>  Odd <font color="Blue">-&gt;</font> <font color="Maroon">"oO"</font> <br>  <font color="Blue">|</font>  Even <font color="Blue">-&gt;</font> <font color="Maroon">":)"</font> <br><br>  The matching method is essentially a special defined function.  She does not have a name, but a pair of samples is determined at once - Odd and Even. <br><br>  In addition to the simple choice, you can organize arbitrary.  Partial matching methods are used for this. <br><br>  <font color="Blue">let</font> <font color="Blue">(</font> <font color="Blue">|</font> Prime <font color="Blue">|</font> _ <font color="Blue">|</font> <font color="Blue">)</font> value = <br>  <font color="Blue">let</font> composite = List <font color="Blue">.</font>  exists <font color="Blue">(</font> <font color="Blue">fun</font> n <font color="Blue">-&gt;</font> value% n = <font color="Maroon">0</font> <font color="Blue">)</font> <font color="Blue">[</font> <font color="Maroon">2</font> <font color="Blue">.</font>  <font color="Blue">.</font>  <font color="Blue">int</font> <font color="Blue">(</font> Math <font color="Blue">.</font> Sqrt <font color="Blue">(</font> value <font color="Blue">)</font> <font color="Blue">)</font> <font color="Blue">]</font> <br>  Some <font color="Blue">(</font> value <font color="Blue">)</font> <br>  <font color="Blue">else</font> None <br><br>  <font color="Blue">match</font> n <font color="Blue">with</font> <br>  <font color="Blue">|</font>  Prime x <font color="Blue">-&gt;</font> sprintf <font color="Maroon">"input% d is prime!"</font> X <br>  <font color="Blue">|</font>  x <font color="Blue">-&gt;</font> sprintf <font color="Maroon">"this value is not special"</font> <br><br>  This was a fairly simple example.  Let's look more complicated. <br><br>  <font color="Blue">type</font> StackItem = <br>  <font color="Blue">|</font>  Int <font color="Blue">of</font> int32 <br>  <font color="Blue">|</font>  String <font color="Blue">of</font> string <br><br>  <font color="Blue">let</font> <font color="Blue">(</font> <font color="Blue">|</font> Add <font color="Blue">|</font> _ <font color="Blue">|</font> <font color="Blue">)</font> = <font color="Blue">function</font> <br>  <font color="Blue">|</font>  OpCode <font color="Blue">.</font>  Add, Int <font color="Blue">(</font> a <font color="Blue">)</font> <font color="Blue">::</font> Int <font color="Blue">(</font> b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">-&gt;</font> <br>  Some <font color="Blue">(</font> Int <font color="Blue">(</font> a + b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">)</font> <br>  <font color="Blue">|</font>  OpCode <font color="Blue">.</font>  Add, String <font color="Blue">(</font> a <font color="Blue">)</font> <font color="Blue">::</font> String <font color="Blue">(</font> b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">-&gt;</font> <br>  Some <font color="Blue">(</font> String <font color="Blue">(</font> a + b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">)</font> <br>  <font color="Blue">|</font>  OpCode <font color="Blue">.</font>  Add, _ <font color="Blue">-&gt;</font> <br>  InvalidProgramException <font color="Blue">(</font> <font color="Maroon">"invalid add args"</font> <font color="Blue">)</font> <font color="Blue">|</font>  &gt; raise <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> None <br><br>  <font color="Blue">let</font> <font color="Blue">(</font> <font color="Blue">|</font> Sub <font color="Blue">|</font> _ <font color="Blue">|</font> <font color="Blue">)</font> = <font color="Blue">function</font> <br>  <font color="Blue">|</font>  OpCode <font color="Blue">.</font>  Add, Int <font color="Blue">(</font> a <font color="Blue">)</font> <font color="Blue">::</font> Int <font color="Blue">(</font> b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">-&gt;</font> <br>  Some <font color="Blue">(</font> Int <font color="Blue">(</font> a - b <font color="Blue">)</font> <font color="Blue">::</font> stackRest <font color="Blue">)</font> <br>  <font color="Blue">|</font>  OpCode <font color="Blue">.</font>  Add, _ <font color="Blue">-&gt;</font> <br>  InvalidProgramException <font color="Blue">(</font> <font color="Maroon">"invalid sub args"</font> <font color="Blue">)</font> <font color="Blue">|</font>  &gt; raise <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> None <br><br>  <font color="Blue">let</font> compute opcode currentStack = <br>  <font color="Blue">match</font> opcode, currentStack <font color="Blue">with</font> <br>  <font color="Blue">|</font>  Add <font color="Blue">(</font> newStack <font color="Blue">)</font> <font color="Blue">|</font>  Sub <font color="Blue">(</font> newStack <font color="Blue">)</font> <font color="Blue">-&gt;</font> newStack <br>  <font color="Blue">|</font>  _ <font color="Blue">-&gt;</font> InvalidProgramException <font color="Blue">(</font> sprintf <font color="Maroon">"invalid opcode% A"</font> opcode <font color="Blue">)</font> <br><br><br>  In the partial matching method, a special type of option (analogue of Nullable) is used, described in the following way: <br>  <font color="Blue">type</font> Option 'a = <br>  <font color="Blue">|</font>  None <br>  <font color="Blue">|</font>  Some <font color="Blue">of</font> 'a <br><br>  Accordingly, to indicate that the object does not match the pattern, None is returned.  In this case, we also return the result of applying the pattern as a parameter Some and then use it (newStack). <br><br><h4>  Results </h4><br>  As you can see, the comparison of samples is quite a useful thing.  They are almost the only reason why I choose F # instead of C # (it is very convenient to use them during translation, see the example code with the stack machine).  Many use cases, compact code, extensibility due to its matching methods - all this makes pattern matching in F # very, very attractive. <br><br>  PS I apologize for the fact that not all examples of the code are the correct quotes.  This is a malicious joke played either habraparser, or a means of highlighting the code. <br></div><p>Source: <a href="https://habr.com/ru/post/89912/">https://habr.com/ru/post/89912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../89902/index.html">Unpack the iPad</a></li>
<li><a href="../89903/index.html">World passport</a></li>
<li><a href="../89905/index.html">Flash XML parsing: win vs mac</a></li>
<li><a href="../89906/index.html">Happy webmasters</a></li>
<li><a href="../89910/index.html">Business Card Thrower and Samsung H205 Camcorder</a></li>
<li><a href="../89913/index.html">Who buys paid content on the Internet? Part 1</a></li>
<li><a href="../89914/index.html">Adding commands to the Computer context menu and the Recycle Bin (continued)</a></li>
<li><a href="../89916/index.html">sudo and alias in .bashrc</a></li>
<li><a href="../89917/index.html">The only true indicator of code quality</a></li>
<li><a href="../89918/index.html">5 Tips for a good code review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>