<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We prove the correctness of the search for the diameter of the tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once in the standings, I got the next task. Come up with an algorithm that finds two vertices of the tree with the maximum distance from each other, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We prove the correctness of the search for the diameter of the tree</h1><div class="post__text post__text-html js-mediator-article">  Once in the standings, I got the next task.  Come up with an algorithm that finds two vertices of the tree with the maximum distance from each other, and prove its correctness.  At that moment, I basically did not know that trees have a diameter, a radius, and many other things.  After the test, a friend enlightened me, telling me what the algorithm was, but without proof.  It was with the question of evidence that my head was clogged for a long time.  After reading a few articles, it became clear that the material does not settle down until I myself can explain everything on my fingers (maybe the reader will like it).  Let's move from demagogy to the point. <br><br>  The diameter of the tree is the maximum distance between two vertices in the tree.  The search algorithm consists of two launches of BFS.  The first goes from an arbitrary top of the tree; during the traversal, the distances from the current top to all others are recorded.  Then the most distant is selected from them.  From it, the second launch of BFS is done.  There are new distances.  The maximum among them will be the diameter. <br><br>  Why does this seemingly simple algorithm work correctly? <br><a name="habracut"></a><br>  To avoid the pitfalls in the proof, we will immediately discuss the case of a tree from one vertex and two vertices.  If there is one vertex, then we have no edges, the first BFS will inform that the starting vertex has the maximum depth, the second - also.  In fact, this is the case, the algorithm will work correctly.  If there are two vertices, then the first traversal will come to the second vertex, and the second - to the starting one, which is correct for this case. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, we understand that the desired distance is the distance between two sheets.  In fact, let the vertex at the end of the found maximal path not be a leaf.  At the same time, we cannot increase the desired distance by assumption.  However, this means that BFS did not visit the vertices ‚Äúlocated behind‚Äù the current one, which contradicts the correctness of BFS.  It turns out that both the vertices found are leaves.  Perfectly. <br><br>  We hang our tree by the vertex <i>v</i> , from which we launch the first traversal. <br><br>  Consider a separate case where the vertex v is itself a leaf.  If it is the first end of the diameter, then it is obvious that the first BFS will find the second end, and the second will return to the starting vertex.  Otherwise, the diameter will not pass through <i>v</i> and will also bend over, since it cannot contain more than two leaves. <br><br>  Suppose we found a diameter and two vertices corresponding to it.  Find the LCA of these vertices <i>a</i> and <i>b</i> , let's call this vertex <i>c</i> .  It is obvious that <i>D = d [a, c] + d [c, b]</i> .  In fact, the diameter is the sum of the two deepest subtrees of a certain vertex, if it belongs to the longest path.  The diameter of a tree is the maximum diameter among all subtrees.  The first detour in width will give us the maximum peak in depth (as we hung on the starting peak).  Denote the vertex at the end of the found path <i>w</i> .  Let us prove that <i>w</i> will belong to the desired longest path.  Let the diameter ‚Äúbends‚Äù at the vertex <i>c</i> (it will ‚Äúbend‚Äù because it connects two leaves, and the tree is suspended by the vertex <i>v</i> , which is not a leaf).  Let the vertex <i>w</i> belong to one of the subtrees of the vertex <i>c</i> .  Then simply replace some part of the path <i>(c, x)</i> , where <i>x</i> is one of the ends, with <i>(c, w).</i>  <i>d [c, x] &lt;d [c, w].</i>  We have improved the answer.  Hence, the original path was not a diameter.  If <i>w</i> is an ancestor of <i>c</i> , then <i>w is</i> not a leaf, so this case does not exist.  If <i>w</i> is somewhere in another subtree, then let <i>e</i> = LCA <i>(c, w)</i> .  <i>d [w, e]</i> - the maximum depth of the subtree <i>e</i> .  Then, since <i>e</i> is the ancestor of <i>c</i> , then <i>d [x, e]&gt; d [x, c]</i> .  <i>d [w, e]&gt; d [y, e]&gt; d [y, c]</i> .  Therefore, <i>D0 = d [x, c] + d [y, c] &lt;d [x, e] + d [w, e] = D.</i>  Hence, the original diameter was found incorrectly and the vertex <i>w</i> belongs to the diameter. <br><br>  <u>Note:</u> <br>  In this part of the proof, we used the property that the leaf <i>w</i> has the greatest depth in any subtree of this tree to which <i>w</i> belongs.  We prove by induction.  Base - one sheet <i>w</i> .  Obviously, the statement is true.  Suppose that for some subtree this is also true, then let us go up a level.  Suppose there is a vertex whose depth in the current subtree is greater than that of <i>w</i> .  We call the current vertex <i>a</i> , the vertex with the assumed greater depth <i>x</i> , the root of the tree <i>v</i> . <br>  <i>d [v, x] = d [v, a] + d [a, x];</i> <i><br></i>  <i>d [v, w] = d [v, a] + d [a, w];</i> <br>  <i>d [v, x] &lt;d [v, w]</i> due to the correctness of the BFS operation; <br>  <i>d [a, x]&gt; d [a, w]</i> by assumption; <br>  As a result, we obtain a contradiction.  Therefore, the vertex <i>w</i> has the greatest depth in any subtree. <br><br>  We obtain that the vertex <i>w</i> belongs to the diameter and is also one of its ends.  Then it is obvious that it remains only to find the vertex most distant from <i>w</i> , which is what the second BFS does. <br><br>  When writing the article materials were used: <br>  <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585">neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_ % D0% BD% D0% B0_% D0% B4% D0% B5% D1% 80% D0% B5% D0% B2% D1% 8C% D1% 8F% D1% 85</a> </div><p>Source: <a href="https://habr.com/ru/post/305912/">https://habr.com/ru/post/305912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305900/index.html">ES6 humanly</a></li>
<li><a href="../305904/index.html">Haordic Organization Visa (Part 4)</a></li>
<li><a href="../305906/index.html">Increment in php</a></li>
<li><a href="../305908/index.html">"Closer to the people": Does the manager need to understand programming</a></li>
<li><a href="../305910/index.html">The evolution of mobile payments</a></li>
<li><a href="../305916/index.html">Android and Data Binding: action handling</a></li>
<li><a href="../305918/index.html">Postfix Answering Machine</a></li>
<li><a href="../305920/index.html">Do IT marketing: why you need to visit hackathons</a></li>
<li><a href="../305922/index.html">The next requirement for the use of domestic encryption</a></li>
<li><a href="../305924/index.html">Creating your own graph processing application in Giraph</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>