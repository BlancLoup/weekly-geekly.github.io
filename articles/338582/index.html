<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We work with long API in ASP.NET Core correctly or the subtleties of moving to a new platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microsoft did a great job creating a new web development platform. The new ASP.NET Core is similar to the old ASP.NET MVC, only perhaps by the MVC arc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We work with long API in ASP.NET Core correctly or the subtleties of moving to a new platform</h1><div class="post__text post__text-html js-mediator-article">  Microsoft did a great job creating a new web development platform.  The new ASP.NET Core is similar to the old ASP.NET MVC, only perhaps by the MVC architecture itself.  The difficulties and familiar things from the old platform are gone, embedded DI and lightweight view components appeared, HTTP modules and handlers gave way to middleware, etc.  Coupled with cross-platform and good performance, all this makes the platform very attractive for choice.  In this article I will tell you how I managed to solve the specific task of logging lengthy requests to third-party APIs to improve the convenience of analyzing incidents. <br><a name="habracut"></a><br><h2>  Instead of intro ... </h2><br>  In diplomas and theses somewhere in the beginning, a problem should usually be stated.  But what I describe below is probably not even a problem, but the desire to make the application more usable and the world around it a little bit more beautiful.  This is one of those moments in my life where I ask myself, can I do better?  And after that I try to find ways to do it.  Sometimes I do it, sometimes I understand that it is either impossible to do better, or it is worth it to spend so much effort that it will eventually lose all meaning.  In the end, it <s>will not turn the world around and solve the problem of poverty on the planet is</s> not something that is worth spending their time and energy.  But anyway, I get some experience from this that cannot but come in handy in the future.  In this article I will describe what seems to me that I managed to do better. <br><br><h2>  Task statement </h2><br>  To begin with, the company where I work is developing high-load websites.  The applications I have been able to work on at the moment, for the most part, are a kind of hidden authorization of the access interface to the customer‚Äôs internal APIs.  There is little logic there and it is distributed in approximately equal proportions between the frontend and backend.  Most of the key business logic lies precisely in these APIs, and sites that are visible to the end customer are their conciergers. <br><br>  Sometimes it turns out that third-party APIs in relation to the site respond to user requests for a very long time.  Sometimes this is a temporary effect, sometimes permanent.  Since applications are by nature highly loaded, we should not allow user requests to be in a hung state for a long time, otherwise it could threaten us with an ever increasing number of open sockets, a rapidly replenishing queue of unanswered requests on the server, and also a large number of clients worrying and worrying why their favorite site opens so long.  With the API, we can not do anything.  And in connection with this, since very old times, we have imposed a limit on the balancer for the duration of the query execution, equal to 5 seconds.  This primarily imposes restrictions on the architecture of the application, as it implies even more asynchronous interaction, and as a result solves the above problem.  The site itself opens quickly, and the download indicators are spinning on the open page, which will eventually yield some result to the user.  It will be what the user expects to see, or the error no longer plays a big role, and this will be a completely different story ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Completely different story</b> <div class="spoiler_text"> <a href="https://imgbb.com/"><img src="https://habrastorage.org/getpro/habr/post_images/904/3a3/12b/9043a312beacbb0300f4fd0923fd736d.jpg" alt="hqdefault"></a> <br></div></div><br>  The attentive reader will note: but if the restriction is on all requests, then it also applies to AJAX requests, too.  All right  I don‚Äôt know at all how to distinguish an AJAX request from the usual transition to a page that is 100% working in all cases.  Therefore, long AJAX requests are implemented according to the following principle: from the client we make a request to the server, the server creates a Task and associates with it a specific GUID, then returns this GUID to the client, and the client receives the result on this GUID when it comes to the server from the API.  At this stage, we almost got to the essence of my <s>contrived problem</s> problem. <br><br>  All requests and responses to these APIs should be logged and stored for debriefing, and from logs we should receive maximum useful information: called action / controller, IP, URI, user login, etc.  etc.  When I first used NLog to log my request / response in my ASP.NET Core application, in principle, I was not surprised to see something like ElasticSearch: <br><br> <code>2017-09-23 23:15:53.4287|0|AspNetCoreApp.Services.LongRespondingService|TRACE|/| DoJob method is starting (AspNetCoreApp.Services.LongRespondingService.DoJob:0)| url:http:///</code> <br> <br>  At the same time, in the NLog configuration, everything looked quite correct and the following was set as the layout: <br><br> <code>${longdate}|${event-properties:item=EventId.Id}|${logger}|${uppercase:${level}}|${aspnet-mvc-controller}/${aspnet-mvc-action}| ${message} (${callsite}:${callsite-linenumber})| url:${aspnet-request-url}</code> <br> <br>  The problem here is that the response from the API comes after the client completes the request (it returns only the GUID).  It was here that I began to think about possible ways to solve this problem ... <br><br><h2>  Possible solutions to the problem </h2><br>  Of course, any problem can be fixed in several ways.  And to score on it is also one of the techniques that sometimes should not be neglected.  But let's talk about real solutions and their consequences. <br><br><h3>  Pass the task ID to the API call method. </h3><br>  Perhaps this is the first thing that can come to mind.  We generate the GUID, log this GUID before exiting the action and transfer it to the API service. <br><br>  The problems of this approach are obvious.  We must pass this ID to absolutely all methods of accessing third-party APIs.  In this case, if we want to reuse this piece somewhere else, where such functionality is not required, then we will be very much disturbed. <br><br>  The situation is aggravated if, before giving the data to the client, we want to somehow process, simplify or aggregate it.  This refers to the business logic and it should be taken out in a separate piece.  It turns out that this piece, which should remain as independent as possible, will also work with this identifier!  So things are not done, so consider other ways. <br><br><h3>  Save task ID in CallContext </h3><br>  If we think about what tools the framework provides for this purpose, then first of all we will recall CallContext with its LogicalSetData / LogicalGetData.  Using these methods, you can save the task ID in CallContext, and .NET (better to say, .NET 4.5) will make sure that the new threads automatically access the same data.  Inside the framework, this is implemented using a pattern somewhat similar to Memento, which should be used by all methods of starting a new thread / task: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     snapshot   var ec = ExecutionContext.Capture(); ... //   snapshot    ExecutionContext.Run(ec, obj =&gt; { // snapshot     ,       }, state);</span></span></code> </pre><br>  Now that we know how to save the ID, and then get it in our task, we can include this identifier in each of our logged messages.  You can do this directly when calling the logging method.  Or, in order not to clog the data access layer, you can use the capabilities of your logger.  In NLog, for example, there are <a href="https://github.com/nlog/nlog/wiki/Layout-Renderers">Layout Renderers</a> . <br><br>  Also, in extreme cases, you can write your logger.  In ASP.NET Core, all logging is done using special interfaces located in the Microsoft.Extensions.Logging namespace, which are introduced into the class via DI.  Therefore, we only need to implement two interfaces: ILogger and ILoggerProvider.  I think this option may be useful if your logger does not support extensions. <br><br>  And so that everything <a href="https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html">worked</a> out as it should, I recommend reading the <a href="https://blog.stephencleary.com/2013/04/implicit-async-context-asynclocal.html">article of Stephen Cleary</a> .  It does not have a binding to the .NET Core (in 2013, it simply was not there yet), but something useful for yourself can be definitely emphasized there. <br><br>  The disadvantage of this approach is that messages with an identifier will get into the log and in order to get the full picture you will need to search for an HTTP request with the same ID.  I won't say anything about performance, because even if there is some kind of drawdown, then compared to other things it will seem to be incommensurably small value. <br><br><h3>  And what if you think why it does not work? </h3><br>  As I said before, messages like this appear in our log file: <br><br> <code>2017-09-23 23:15:53.4287|0|AspNetCoreApp.Services.LongRespondingService|TRACE|/| DoJob method is starting (AspNetCoreApp.Services.LongRespondingService.DoJob:0)| url:http:///</code> <br> <br>  Those.  everything related to IHttpContext is simply null.  It seems to be understandable: the execution of the request is over, so NLog cannot receive data, i.e.  HttpContext is simply no longer a reference. <br><br>  Finally, I decided to look, and how the actual NLog gets a link to the HttpContext outside the controller.  Since SynchronizationContext and HttpContext.Current in .NET Core <a href="https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html">were finished</a> (yes, this is again Stephen Cleary), then there must be some other way to do it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c80/363/eb3/c80363eb3a2c7f0ce050e339a988e1ac.png" alt="image"><br><br>  Having picked the source code for NLog, I found a certain <a href="https://docs.microsoft.com/ru-ru/dotnet/api/Microsoft.AspNetCore.Http.IHttpContextAccessor%3Fview%3Daspnetcore-2.0">IHttpContextAccessor</a> .  The thirst to understand what is happening here all the same made me climb into GitHub again and see what this magic thing with one property is.  It turned out that this is just an <a href="">abstraction over AsyncLocal</a> , which is essentially a new version of LogicalCallContext (the very same LogicalSetData / LogicalGetData methods).  By the way, for the .NET Framework, this was <a href="">not always the case</a> . <br><br>  After that, I asked myself the question: why, then, actually it does not work?  We run Task in the standard way, there is no unmanaged code here ... Running the debugger to see what is happening with HttpContext at the time of calling the logging method, I saw that HttpContext is there, but the properties in it are all set to zero except for Request.Scheme, which at the time call equals "http".  So it turns out that in my log instead of URL - a strange " <code>http:///</code> ". <br><br>  So, it turns out that in order to improve the performance of ASP.NET Core, somewhere inside of itself, HttpContexts are reset to zero and reuse them.  Apparently, such subtleties together allow to achieve significant advantages in comparison with the old ASP.NET MVC. <br><br>  What could I do about it?  Yes, just save the current state of HttpContext'a!  I wrote a simple service with a single CloneCurrentContext method that I registered in the DI container. <br><br><div class="spoiler">  <b class="spoiler_title">HttpContextPreserver</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HttpContextPreserver</span></span> : <span class="hljs-title"><span class="hljs-title">IHttpContextPreserver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IHttpContextAccessor _httpContextAccessor; ILogger _logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpContextPreserver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IHttpContextAccessor httpContextAccessor, ILogger&lt;HttpContextPreserver&gt; logger</span></span></span><span class="hljs-function">)</span></span> { _httpContextAccessor = httpContextAccessor; _logger = logger; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloneCurrentContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpContext = _httpContextAccessor.HttpContext; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> feature = httpContext.Features.Get&lt;IHttpRequestFeature&gt;(); feature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequestFeature() { Scheme = feature.Scheme, Body = feature.Body, Headers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HeaderDictionary(feature.Headers.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value)), Method = feature.Method, Path = feature.Path, PathBase = feature.PathBase, Protocol = feature.Protocol, QueryString = feature.QueryString, RawTarget = feature.RawTarget }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemsFeature = httpContext.Features.Get&lt;IItemsFeature&gt;(); itemsFeature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemsFeature() { Items = itemsFeature?.Items.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value) }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> routingFeature = httpContext.Features.Get&lt;IRoutingFeature&gt;(); routingFeature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoutingFeature() { RouteData = routingFeature.RouteData }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionFeature = httpContext.Features.Get&lt;IHttpConnectionFeature&gt;(); connectionFeature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpConnectionFeature() { ConnectionId = connectionFeature?.ConnectionId, LocalIpAddress = connectionFeature?.LocalIpAddress, RemoteIpAddress = connectionFeature?.RemoteIpAddress, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeatureCollection(); collection.Set(feature); collection.Set(itemsFeature); collection.Set(connectionFeature); collection.Set(routingFeature); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHttpContext(collection); _httpContextAccessor.HttpContext = newContext; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IHttpContextPreserver</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloneCurrentContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br></div></div><br>  I did not use deep cloner, as this would add a heavy reflection to the project.  And I need it all in one place.  Therefore, I simply create a new HttpContext based on the existing one and copy into it only what would be useful to see in the log when analyzing incidents (action | controller, url, ip, etc.).  <u><b>Not all information is copied</b></u> . <br><br>  Now running the application, I saw about the following happy lines: <br><br><pre> <code class="xml hljs">2017-10-08 20:29:25.3015|0|AspNetCoreApp.Services.LongRespondingService|TRACE|Home/Test| DoJob method is starting (AspNetCoreApp.Services.LongRespondingService.DoJob:0)| url:http://localhost/Test/1 2017-10-08 20:29:34.3322|0|AspNetCoreApp.Services.LongRespondingService|TRACE|Home/Test| DoJob method is ending (AspNetCoreApp.Services.LongRespondingService+<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DoJob</span></span></span><span class="hljs-tag">&gt;</span></span>d__3.MoveNext:0)| url:http://localhost/Test/1</code> </pre><br>  And this meant a small victory for me, which I share here with you.  Who thinks about this? <br><br>  To make sure that I didn‚Äôt think up anything wrong with a false one, I wrote a small functional load test that can be found in my repository on github along with the service.  When you run 5000 simultaneous tasks, the test was successful. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/33e/f1e/f6f33ef1e013d8d322339500fe098184.png" alt="image"><br><br>  By the way, thanks to the ASP.NET Core architecture, such tests can be written easily and naturally.  You just need to run a full-fledged server inside the test and access it through a real socket: <br><br><div class="spoiler">  <b class="spoiler_title">Server initialization by URL</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFixture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fixHttpContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> solutionRelativeTargetProjectParentDir</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startupAssembly = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TStartup).Assembly; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentRoot = GetProjectPath(solutionRelativeTargetProjectParentDir, startupAssembly); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Content root: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{contentRoot}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebHostBuilder() .UseKestrel() .UseContentRoot(contentRoot) .ConfigureServices(InitializeServices) .UseEnvironment(fixHttpContext ? <span class="hljs-string"><span class="hljs-string">"Good"</span></span> : <span class="hljs-string"><span class="hljs-string">"Bad"</span></span>) .UseStartup(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TStartup)) .UseUrls(BaseAddress); _host = builder.Build(); _host.Start(); }</code> </pre> <br></div></div><br>  Another reason for using ASP.NET Core in their projects. <br><br><h2>  Results </h2><br>  I really liked ASP.NET Core in all aspects of its implementation.  It has great flexibility and at the same time the lightness of the entire platform.  Due to abstractions for absolutely all the functionality, you can do any things and customize the entire platform for yourself, your team and your development methods.  Cross-platform is not yet perfected, but Microsoft is committed to this, and someday (albeit maybe not soon) they should get it. <br><br>  <a href="https://github.com/Dobby007/aspnetcore-longtask/">Github link</a> </div><p>Source: <a href="https://habr.com/ru/post/338582/">https://habr.com/ru/post/338582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338568/index.html">Creating the Google Maps API Maps Component with VueJs2</a></li>
<li><a href="../338572/index.html">Eggs Datacenter: how Emercoin allowed to implement the idea of ‚Äã‚Äãa distributed data center on the blockchain</a></li>
<li><a href="../338576/index.html">Facebook Messenger bug or feature - Poll</a></li>
<li><a href="../338578/index.html">Networks for the harshest. Part thirteen. MPLS Traffic Engineering</a></li>
<li><a href="../338580/index.html">How on animeshniki cryptocurrency mined</a></li>
<li><a href="../338584/index.html">The implementation of "Tetris" in the game "Life"</a></li>
<li><a href="../338590/index.html">ViewModel and LiveData: patterns and antipatterns</a></li>
<li><a href="../338592/index.html">The digest of interesting materials for the mobile developer # 222 (September 18 - 24)</a></li>
<li><a href="../338594/index.html">Another aspect of JavaScript, which everyone knows about, but not everyone thinks</a></li>
<li><a href="../338596/index.html">Development of profitable Android games by two students</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>