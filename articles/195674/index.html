<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Subtleties of successful git-merge</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="opening speech 
 It is believed that the "killer feature" SLE Git is a lightweight branching. I felt this advantage in full, because I switched to Git...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Subtleties of successful git-merge</h1><div class="post__text post__text-html js-mediator-article"><h4>  opening speech </h4><br>  It is believed that the "killer feature" SLE Git is a lightweight branching.  I felt this advantage in full, because I switched to Git from SVN, where branching was quite an expensive process: to create a branch, you had to copy the entire working directory.  In Git, everything is simpler: creating a branch only means creating a new pointer to a specific commit in the <code>.git/refs/heads</code> folder, which is a file with 40 bytes of text, a commit hash. <br><br>  The main user-level commands for branching in Git are git-branch, git-checkout, git-rebase, git-log and, of course, git-merge.  For myself, I consider the git-merge zone of greatest responsibility, a point of tremendous magical energy and great opportunities.  But this is a fairly complex team, and even a fairly long experience with Git is sometimes not enough to master all its subtleties and the ability to apply it most effectively in a non-standard situation. <br><br>  Let's try to understand the subtleties of git-merge and tame this great magic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here I want to consider only the case of a <i>successful merger,</i> by which I mean a <i>merger without conflicts.</i>  Handling and conflict resolution is a separate interesting topic worthy of a separate article.  I highly recommend also reading the <a href="http://habrahabr.ru/company/badoo/blog/163853/">Git Internal</a> article <a href="http://habrahabr.ru/company/badoo/blog/163853/">: data storage and merge</a> , which contains a lot of important information that I rely on. <br><a name="habracut"></a><br><h4>  Team anatomy </h4><br>  If you believe the <a href="http://git-scm.com/docs/git-merge">manual</a> , the command has the following syntax: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">git merge [-n] [--stat] [--no-commit] [--squash] [- [no-] edit]</font> <font color="#286294">
</font>  <font color="#286294">[-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;]</font> <font color="#286294">
</font>  <font color="#286294">[- [no-] rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt; ...]</font> <font color="#286294">
</font>  <font color="#286294">git merge &lt;msg&gt; HEAD &lt;commit&gt; ...</font> <font color="#286294">
</font>  <font color="#286294">git merge --abort</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  By and large, there are two types of merge in Git: fast-forward merge (fast-forward merge) and true merge (true merge).  Consider a few examples of both cases. <br><br><h4>  ‚ÄúTrue‚Äù merge (true merge) </h4><br>  We deviate from the master branch in order to introduce several <s>bug fixes</s> .  We have the following history of commits: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - D</font> <font color="#d32831">
                 </font>  <font color="#d32831">\</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  Run on the master <code>git merge feature</code> branch: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - D - (M)</font> <font color="#d32831">
                 </font>  <font color="#d32831">\ /</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  This is the most common merge pattern.  In this case, a new commit is created in the master branch (M), which will refer to two parents: commit D and commit Y;  and the master pointer is set to commit (M).  Thus, Git will understand which changes correspond to commit (M) and which commit is the last one in the master branch.  Usually a merge commit is done with a message like ‚ÄúMerge branch 'feature'‚Äù, but you can define your own commit message with the <code>-m</code> . <br><br>  Let's look at the history of commits in the test repository, which I created specifically for this case: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ git log --oneline</font> <font color="#286294">
</font>  <font color="#286294">92384bd (M)</font> <font color="#286294">
</font>  <font color="#286294">bceb5a4 D</font> <font color="#286294">
</font>  <font color="#286294">5dce5b1 Y</font> <font color="#286294">
</font>  <font color="#286294">76f13e7 X</font> <font color="#286294">
</font>  <font color="#286294">d1920dc C</font> <font color="#286294">
</font>  <font color="#286294">3a5c217 B</font> <font color="#286294">
</font>  <font color="#286294">844af94 A</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  And now let's look at the information about commit (M): <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ git cat-file -p 92384bd</font> <font color="#286294">
</font>  <font color="#286294">tree 2b5c78f9086384bd86a2ab9d00c7e41a56f01d04</font> <font color="#286294">
</font>  <font color="#286294">parent bceb5a4ad88e80467404473b94c3e0758dd8e0be</font> <font color="#286294">
</font>  <font color="#286294">parent 5dce5b1edef64bd0d4e1039061a77be4d7182678</font> <font color="#286294">
</font>  <font color="#286294">author Andre &lt;andrey.prokopyuk@gmail.com&gt; 1380475972 +0400</font> <font color="#286294">
</font>  <font color="#286294">committer Andre &lt;andrey.prokopyuk@gmail.com&gt; 1380475972 +0400</font> <font color="#286294"><font></font>
<font></font>
</font>  <font color="#286294">(M)</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  We see two parents, a tree object corresponding to a given state of the repository files, as well as information about who is responsible for the commit. <br><br>  Let's see where the master pointer refers to: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ cat .git / refs / heads / master</font> <font color="#286294">
</font>  <font color="#286294">92384bd77304c09b81dcc4485da165923b96ed5f</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  Indeed, he is now moved to a commit (M). <br><br><h4>  Squash and no commit </h4><br>  But what if the content of the feature branch can beat you?  For example, the improvement was small, and it could fit in one logical commit, but it turned out that in the middle of work you had to run off by train and continue at home?  In this case, there are two ways out: exporting the repository and then importing it on another machine, or (especially when it‚Äôs 10 minutes to the train, and about a kilometer to the train station) - to do a <code>push origin feature</code> . <br><br>  Pouring incomplete commits into the main branch is bad, and something needs to be done about it.  One of the ways, and perhaps the easiest, is the <code>--squash</code> option. <br><br>  <code>git merge feature --squash</code> changes of all commits of the feature branch, transfers them to the master branch and adds them to the index.  When this <i>commit merge will not be created,</i> you will need to make it manually. <br><br>  You can achieve the same behavior without the squash parameter by passing the <code>--no-commit</code> parameter when merging. <br><br>  In the case of such a merge, the commits of the feature branch will not be included in our history, but the Sq commit will contain all their changes: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - D - Sq</font> <font color="#d32831">
                 </font>  <font color="#d32831">\</font> <font color="#d32831"> 
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br><br>  Later, if you run the ‚Äúclassic‚Äù <code>git merge feature</code> you can fix it.  Then the story will take the following form: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - D - Sq - (M)</font> <font color="#d32831">
                 </font>  <font color="#d32831">\ /</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br><br>  If you did a merge without a commit, and then realized that you made a fatal error, you can cancel everything with a simple command: <code>git merge --abort</code> .  The same command can be applied if conflicts occurred during the merge, but you do not want to resolve them at the moment. <br><br><h4>  Rewind (fast-forward merge) </h4><br>  Consider another case of commit history: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C</font> <font color="#d32831">
                 </font>  <font color="#d32831">\</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  Everything is the same as last time, but now there are no commits after the branch in the master branch.  In this case, fast-forward merge (rewind) occurs.  In this case, there is no merge commit, the master pointer (branch) is simply set to commit Y, and the feature branch also points there: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master, feature: A - B - C - X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  To prevent rewinding, you can use the <code>--no-ff</code> option. <br>  In case we execute the <code>git merge feature --no-ff -m '(M)'</code> , we will get the following picture: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - (M)</font> <font color="#d32831">
                 </font>  <font color="#d32831">\ /</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  If for us the only acceptable behavior is fast-forward, we can specify the option <code>--ff-only</code> .  In this case, if the rewind is not applicable to the merge, a message will be displayed that it is impossible to merge.  This would be the case if we added the <code>--ff-only</code> option in the very first example, where after tapping the feature in the master branch, a commit C was made. <br><br>  It can be added that when <code>git pull origin branch_name</code> , the <code>git pull origin branch_name</code> is used as something like <code>--ff-only</code> .  That is, if during the merge with the origin / branch_name branch, rewinding is not acceptable, the operation is canceled and a message about the impossibility of execution is displayed. <br><br><h4>  Merge strategies </h4><br>  The git-merge command has an interesting parameter, <code>--strategy</code> strategy, strategy.  Git supports the following merge strategies: <br><ul><li>  resolve </li><li>  recursive </li><li>  ours </li><li>  octopus </li><li>  subtree </li></ul><br><br><h5>  Resolve strategy </h5><br>  The resolve strategy is a classic three-way merge (three-way merge).  The standard three-way merge algorithm is used for two files with a common ancestor.  Conventionally, this algorithm can be represented in the form of the following steps: <br><ol><li>  search for a common ancestor </li><li>  search for blocks that have changed in both versions relative to a common ancestor, </li><li>  unchanged blocks are written, </li><li>  blocks that have changed only in one of the descendants are written as changed, </li><li>  blocks that have changed in both versions are recorded only if the changes are identical, otherwise a conflict is declared, the resolution of which is granted to the user. </li></ol><br>  This strategy has one drawback: the earliest common commit is always selected as the common ancestor of the two branches.  For the case of our first example, this is not terrible, you can safely use the <code>git merge feature -s resolve</code> , and the result will be expected: <br><br><pre> <font color="#d32831">
</font>  <font color="#d32831">master: A - B - C - D - (M)</font> <font color="#d32831">
                 </font>  <font color="#d32831">\ /</font> <font color="#d32831">
</font>  <font color="#d32831">feature: X - Y</font> <font color="#d32831">
</font> </pre> <font color="#d32831"><br></font> <br>  Here C is a common commit of two branches, the file tree corresponding to this commit is taken as a common ancestor.  The changes made in the master and feature branches since the time of this commit are analyzed, after which a new version of the file tree is created for commit (M) in accordance with clauses 4 and 5 of our conditional algorithm. <br><br>  In which case is the lack of the strategy resolve?  It manifests itself if we had to resolve conflicts for commit (M), after which we continued to develop and once again want to perform the <code>git merge feature -s resolve</code> .  In this case, commit C will be used again as a common ancestor, and conflicts will occur again and will need our intervention. <br><br><h5>  Recursive strategy </h5><br>  This strategy solves the problems of the resolve strategy.  It also implements a three-way merger, but the real ‚Äúvirtual‚Äù ancestor is used as an ancestor, which is constructed according to the following conventional algorithm: <br><ol><li>  A search for all candidates for a common ancestor, </li><li>  a chain of candidates is merged, resulting in a new ‚Äúvirtual‚Äù ancestor, with more recent commits having a higher priority, thus avoiding the re-emergence of conflicts. </li></ol><br>  The result of this action is taken as a common ancestor and is carried out a trilateral merger. <br><br>  To illustrate this strategy, let's take an example from the article <a href="http://codicesoftware.blogspot.com/2011/09/merge-recursive-strategy.html">Merge recursive strategy</a> from the blog ‚ÄúThe plasticscm blog‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/141/6f7/fc8/1416f7fc87b985febe5cb513b927562b.png" alt="Merge recursive"><br><br>  So, we have two branches: main and task001.  And so it turned out that our developers know a lot about perversions: they merged commit 15 from the main branch with commit 12 from the task001 branch, as well as commit 16 with commit 11. When we needed to merge the branches, it turned out that finding a real ancestor is ungrateful , but the recursive strategy with its construction of a ‚Äúvirtual‚Äù ancestor will help us.  As a result, we get the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ec/91d/fb8/7ec91dfb88714e106fae26303087789b.png" alt="Merge recursive"><br><br>  The recursive strategy has many options that are passed to the <code>git-merge</code> command with the <code>-X</code> option: <br><ul><li>  <b>ours and theirs</b> <br>  Used to automatically resolve conflicts.  Ours - to prefer "our" version, the version of "dst", theirs - to prefer "their" version. <br></li><li>  <b>renormalize (no-renormalize)</b> <br>  Prevents false conflicts when merging options with different types of line breaks. <br></li><li>  <b>diff-algorithm = [patience | minimal | histogram | myers]</b> , as well as the <b>patience</b> option <br>  The choice of file differentiation algorithm. <br>  More information about these options can be found in the <a href="http://git-scm.com/docs/git-diff">git-diff documentation</a> .  In short, the properties of these algorithms are as follows: <br>  <i>default, myers</i> is a standard, greedy algorithm.  It is used by default. <br>  <i>minimal</i> - it searches for the smallest changes, which takes extra time. <br>  <i>patience</i> - use the patience diff algorithm.  You can read about it <a href="http://git.661346.n2.nabble.com/Bram-Cohen-speaks-up-about-patience-diff-td2277041.html">from the author of the algorithm</a> , or in an abbreviated version <a href="http://stackoverflow.com/a/4045087/1377912">on SO</a> . <br>  <i>histogram</i> - extends the patience algorithm with the goal described as "support low-occurrence common elements".  To be honest, I could not find a sufficiently clear answer to the question of what specific cases are implied and I would be very happy if someone helps me find this answer. <br></li><li>  <b>ignore-space-change, ignore-all-space, ignore-space-at-eol</b> <br>  The roots of these options are, again, in git-diff and relate to the differentiation of files when merging. <br>  <i>ignore-space-change</i> - ignores differences in the number of spaces in a row, as well as spaces at the end of the line, <br>  <i>ignore-all-space</i> - spaces are absolutely ignored when comparing, <br>  <i>ignore-space-at-eol</i> - ignores differences in spaces at the end of the line. <br></li><li>  <b>rename-threshold = &lt;n&gt;</b> <br>  This option sets a threshold upon reaching which a file can be considered not a new, but a renamed file, of which the git-diff was not counted.  For example, <code>-Xrename-threshold=90%</code> implies that a file that contains 90% of the content of some deleted file is considered renamed. <br></li><li>  <b>subtree [= &lt;path&gt;]</b> <br>  Performing a recursive merge with this option will be a more advanced version of the subtree strategy, where the algorithm is based on the assumption of how the trees should fit together in the merge.  Instead, a specific option is indicated in this case. <br></li></ul><br><br><h5>  Octopus strategy </h5><br>  This strategy is used to merge more than two branches.  The resulting commit will have, respectively, more than two parents. <br><br>  This strategy involves more caution about potential conflicts.  In this regard, sometimes you can get a refusal to merge when applying the strategy of octopus. <br><br><h5>  Strategy ours </h5><br>  Do not confuse ours strategy with ours strategy option recursive. <br><br>  When performing <code>git merge -s ours obsolete</code> , you kind of say: I want to merge the stories of the branches, but ignore all the changes that have occurred in the obsolete branch.  Sometimes it is recommended to use the following option instead of ours strategy: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ git checkout obsolete</font> <font color="#286294">
</font>  <font color="#286294">$ git merge -s recursive -Xtheirs master</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  Ours strategy is a more radical means. <br><br><h5>  Subtree strategy </h5><br>  To illustrate this strategy, let's take an example from the chapter <a href="http://git-scm.com/book/ru/%25D0%2598%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B-Git-%25D0%25A1%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D0%25B5%25D0%25B2">Merging the subtrees</a> of the Pro Git book. <br><br>  Add a new remote repository to our project, rack: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ git remote add rack_remote git@github.com: schacon / rack.git</font> <font color="#286294">
</font>  <font color="#286294">$ git fetch rack_remote</font> <font color="#286294">
</font>  <font color="#286294">warning: no common commits</font> <font color="#286294">
</font>  <font color="#286294">remote: Counting objects: 3184, done.</font> <font color="#286294">
</font>  <font color="#286294">remote: Compressing objects: 100% (1465/1465), done.</font> <font color="#286294">
</font>  <font color="#286294">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</font> <font color="#286294">
</font>  <font color="#286294">Receiving objects: 100% (3184/3184), 677.42 KiB |</font>  <font color="#286294">4 KiB / s, done.</font> <font color="#286294">
</font>  <font color="#286294">Resolving deltas: 100% (1952/1952), done.</font> <font color="#286294">
</font>  <font color="#286294">From git@github.com: schacon / rack</font> <font color="#286294">
 </font>  <font color="#286294">* [new branch] build -&gt; rack_remote / build</font> <font color="#286294">
 </font>  <font color="#286294">* [new branch] master -&gt; rack_remote / master</font> <font color="#286294">
 </font>  <font color="#286294">* [new branch] rack-0.4 -&gt; rack_remote / rack-0.4</font> <font color="#286294">
 </font>  <font color="#286294">* [new branch] rack-0.9 -&gt; rack_remote / rack-0.9</font> <font color="#286294">
</font>  <font color="#286294">$ git checkout -b rack_branch rack_remote / master</font> <font color="#286294">
</font>  <font color="#286294">Branch ref_branch set up to track remote branch refs / remotes / rack_remote / master.</font> <font color="#286294">
</font>  <font color="#286294">Switched to a new branch "rack_branch"</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br><br>  It is clear that the master and rack_branch branches have completely different working directories.  Add files from rack_branch to master using squash in order to avoid clogging the history with unnecessary facts: <br><br><pre> <font color="#286294">
</font>  <font color="#286294">$ git checkout master</font> <font color="#286294">
</font>  <font color="#286294">$ git merge --squash -s subtree --no-commit rack_branch</font> <font color="#286294">
</font>  <font color="#286294">Squash commit - not updating HEAD</font> <font color="#286294">
</font>  <font color="#286294">Automatic merge went well;</font>  <font color="#286294">stopped before committing as requested</font> <font color="#286294">
</font> </pre> <font color="#286294"><br></font> <br>  Now the files of the project rack are in our working directory. <br><br><h4>  Final word </h4><br>  So, I have gathered together all the knowledge that I gained while working with Git regarding the successful git-merge.  I will be happy if it helps someone, but I will also be happy if someone helps me to supplement the material or correct inaccuracies and errors, if suddenly I made such. </div><p>Source: <a href="https://habr.com/ru/post/195674/">https://habr.com/ru/post/195674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195656/index.html">Nokia, life goes on</a></li>
<li><a href="../195664/index.html">Tutorial Derby.js</a></li>
<li><a href="../195668/index.html">Farewell Steve Ballmer with Microsoft employees</a></li>
<li><a href="../195670/index.html">Google introduced the new search algorithm Hummingbird</a></li>
<li><a href="../195672/index.html">The digest of news from the world of mobile development in the last week ‚Ññ26 (September 23‚Äî29, 2013)</a></li>
<li><a href="../195676/index.html">Need For Speed ‚Äã‚Äã3 + Cryengine 3 = Cry For Speed</a></li>
<li><a href="../195678/index.html">WordPress 3.7 will be updated automatically.</a></li>
<li><a href="../195682/index.html">Smoothieboard - 32-bit CNC controller for 3D printers, laser cutters and milling machines</a></li>
<li><a href="../195684/index.html">Do you have a backup plan?</a></li>
<li><a href="../195686/index.html">We load Node to the eyeballs (2nd of 12 articles about Node.js from the Mozilla Identity team)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>