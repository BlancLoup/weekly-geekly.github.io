<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We learn PHP from the inside. Zval</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is based on the chapter Zvals of the book PHP Internals Book , which I am currently translating into Russian [ 1 ]. The book is primarily...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We learn PHP from the inside. Zval</h1><div class="post__text post__text-html js-mediator-article">  This article is based on the chapter Zvals of the book <a href="http://www.phpinternalsbook.com/">PHP Internals Book</a> , which I am currently translating into Russian [ <sup>1</sup> ].  The book is primarily aimed at C-programmers who want to write their own extensions for PHP, but I am sure that it will also be useful for PHP developers, since it describes the internal logic of the interpreter.  In the article, I left only the basic theory, which should be clear to all developers (not even familiar with PHP or C).  For a more complete presentation of the material refer to the book. <br><br>  Task to attract attention.  What will be the result of the following code? <br><pre><code class="php hljs">$obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StdClass(); $obj2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StdClass(); $obj1-&gt;value = <span class="hljs-number"><span class="hljs-number">1</span></span>; $obj2-&gt;value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($o)</span></span></span><span class="hljs-function"> </span></span>{ $o = <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($o)</span></span></span><span class="hljs-function"> </span></span>{ $o-&gt;value = <span class="hljs-number"><span class="hljs-number">100</span></span>; } f1($obj1); f2($obj2); var_dump($obj1); var_dump($obj2);</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  object (stdClass) # 1 (1) {["value"] =&gt; int (1)} <br>  object (stdClass) # 2 (1) {["value"] =&gt; int (100)} <br></div></div><br>  If you have precisely defined the answer and can explain why it will be like this, then you probably will not learn anything new from this article, otherwise you definitely should read this article to deepen your knowledge. <br><a name="habracut"></a><br><h5>  Basic structure </h5><br>  The basic data structure in PHP is zval (short for ‚ÄúZend value‚Äù).  Each zval stores several fields, two of which are the value and the type of this value.  This is necessary because PHP is a language with dynamic typing and therefore the type of variables is known only at runtime and not at compile time.  In addition, the type of a variable can be changed during the life of a zval, that is, a zval previously stored as an integer can later contain a string. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The type of the variable is stored as an integer label (type tag, unsigned char).  A label can take one of 8 values, which corresponds to 8 types of data available in PHP.  These values ‚Äã‚Äãshould be assigned using constants of the form <code>IS_TYPE</code> .  For example, <code>IS_NULL</code> corresponds to the data type null, and <code>IS_STRING</code> to the string. <br><br><h6>  zvalue_value </h6><br>  The actual value of the variable is stored in the data type union ("union", in the future I will use the terms union or union), which is defined as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zvalue_value { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> lval; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dval; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *val; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; } str; HashTable *ht; zend_object_value obj; } zvalue_value;</code> </pre><br>  A small explanation for those who are not familiar with the concept of union.  Union defines several data members of different types, but at any given time only one value can be used from those defined in the union.  For example, if the <code>value.lval</code> data member <code>value.lval</code> been assigned a value, then you can use only <code>value.lval</code> to access the data, access to other data members is invalid and can lead to unpredictable program behavior.  The reason for this is that the unions store the data of all their members in the same memory area and interpret the value differently based on the name you are referring to.  The size of the memory allocated for the union corresponds to the size of its largest data member. <br><br>  When working with zval-s, a special tag (type tag) is used, which allows you to determine what type of data is stored in the union at the moment.  Before accessing the API, let's look at what data types are supported in PHP and how they are stored. <br><br>  The simplest data type is <code>IS_NULL</code> : it should not store any value, since it is just null. <br><br>  For storing numbers, PHP represents 2 types: <code>IS_LONG</code> and <code>IS_DOUBLE</code> , which use the members <code>long lval</code> and <code>double dval</code> respectively.  The first is used to store integers, the second - for floating point numbers. <br><br>  There are a few things you should know about the long data type.  First, it is a signed integer, that is, it can contain positive and negative values, but this data type is not suitable for bitwise operations.  Secondly, long has different sizes on different platforms: on 32-bit systems it is 32 bits or 4 bytes in size, but on 64-bit systems it can be either 4 or 8 bytes in size.  On Unix systems, it is usually 8 bytes in size, while on 64-bit versions of Windows it uses only 4 bytes. <br><br>  For this reason, you should not rely on a specific value of type long.  The minimum and maximum values ‚Äã‚Äãthat can be stored in the long data type are available in the <code>LONG_MIN</code> and <code>LONG_MAX</code> and the size of this type can be determined using the <code>SIZEOF_LONG</code> macro (unlike the <code>sizeof(long)</code> this macro can be used in <code>#if</code> directives). <br><br>  The <code>double</code> data type is intended for storing floating point numbers and, usually, following the IEEE-754 specification, it is 8 bytes in size.  Details of this format will not be discussed here, but you should at least be aware that this type has limited accuracy and often stores not exactly the value you are counting on. <br><br>  Boolean variables use the <code>IS_BOOL</code> flag and are stored in the <code>long val</code> field as <code>0</code> (false) and <code>1</code> (true).  Since this type uses only 2 values, then, theoretically, it was enough to use a smaller type (for example, zend_bool), but since zvalue_value is a union and under it the memory size corresponding to the largest data member is allocated, the use of a more compact variable for boolean values ‚Äã‚Äãwill not save memory.  Therefore, lval is reused in this case. <br><br>  Strings ( <code>IS_STRING</code> ) are stored in a <code>struct {char *val; int len; } str;</code> <code>struct {char *val; int len; } str;</code>  that is, the string is stored as a pointer to the <code>char *</code> string and the integer length of the <code>int</code> string.  Strings in PHP must explicitly store their length in order to be able to contain NUL bytes (\ 0) and be binary safe (binary safe).  But despite this, the lines used in PHP still end with a null byte (NUL-terminated) to ensure compatibility with library functions that do not accept an argument with a string length, but expect to find a zero byte at the end of the string.  Of course, in such cases the strings can no longer be binary safe and will be truncated to the first occurrence of the zero byte.  For example, many of the functions associated with the file system and most of the string functions from libc behave in this way. <br><br>  The string length is measured in bytes (not the number of Unicode characters) and should not include a zero byte, that is, the length of the string <code>foo</code> is 3, despite the fact that 4 bytes are used to store it.  If you define the length of a string using <code>sizeof</code> you need to subtract the unit: <code>strlen("foo") == sizeof("foo") - 1</code> . <br><br>  It is very important to understand: the length of the string is stored in the int type, and not in a long or some other similar type.  This is a historical artifact that limits the length of a string to 2,147,483,647 bytes (2 gigabytes).  Larger lines will cause overflow (which will make their length negative). <br><br>  The remaining three types will be mentioned only superficially. <br><br>  Arrays use the <code>IS_ARRAY</code> label and are stored in the data member <code>HashTable *ht</code> .  How the HashTable data structure works is covered in another article. <br><br>  The objects ( <code>IS_OBJECT</code> ) use the data member <code>zend_object_value obj</code> , which consists of an ‚Äúobject handle‚Äù (an integer ID used to search for real data) and a set of ‚Äúobject handlers‚Äù that determine the behavior of the object.  The system of classes and objects in PHP will be described in the ‚ÄúClasses and Objects‚Äù chapter. <br><br>  Resources ( <code>IS_RESOURCE</code> ) are similar to objects, since they also store a unique ID used to look up the value.  This ID is stored in the long lval member.  Resources will be described in the relevant chapter, which has not yet been written. <br><br>  Let's summarize the intermediate result, below is a table listing all the available type labels and the corresponding value store: <br><table><tbody><tr><td>  Type tag </td><td>  Storage location </td></tr><tr><td> <code>IS_NULL</code> </td> <td> <code>none</code> </td> </tr><tr><td> <code>IS_BOOL</code> </td> <td> <code>long lval</code> </td> </tr><tr><td> <code>IS_LONG</code> </td> <td> <code>long lval</code> </td> </tr><tr><td> <code>IS_DOUBLE</code> </td> <td> <code>double dval</code> </td> </tr><tr><td> <code>IS_STRING</code> </td> <td> <code>struct { char *val; int len; } str</code> </td> </tr><tr><td> <code>IS_ARRAY</code> </td> <td> <code>HashTable *ht</code> </td> </tr><tr><td> <code>IS_OBJECT</code> </td> <td> <code>zend_object_value obj</code> </td> </tr><tr><td> <code>IS_RESOURCE</code> </td> <td> <code>long lval</code> </td> </tr></tbody></table><br><h6>  zval </h6><br>  Let's now see what the zval data structure looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_struct</span></span></span><span class="hljs-class"> {</span></span> zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; } zval;</code> </pre><br>  As already mentioned, zval contains terms for hreneniya values ‚Äã‚Äãand its type.  The value is stored in the zvalue_value union, which is described above.  The type is stored in the <code>zend_uchar type</code> .  In addition, this structure contains 2 additional properties whose names end with <code>__gc</code> , which are used by the garbage collection mechanism.  These properties are discussed in more detail in the next section. <br><br><h5>  Memory management </h5><br>  The zval data structure plays 2 roles.  First, as described in the previous section, it stores data and its type.  Secondly (this will be discussed in the current section) is used to effectively manage the values ‚Äã‚Äãin memory. <br><br>  In this section, we look at the concepts of reference counting and copy-on-write (copy-on-write). <br><br><h6>  Semantics of knowledge and references </h6><br>  In PHP, all values ‚Äã‚Äãalways have value-semantics semantics only if you have not explicitly requested the use of links.  This means that when passing a value to a function, and when performing an assignment operation, you will work with 2 different copies of the value.  A couple of examples will help make sure of this: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; $b = $a; $a++; <span class="hljs-comment"><span class="hljs-comment">//  $a    1, $b   : var_dump($a, $b); // int(2), int(1) function inc($n) { $n++; } $c = 1; inc($c); //   $c     $n   ‚Äî    var_dump($c); // int(1)</span></span></code> </pre><br>  The example above is very simple and obvious, but it is important to understand that this is the basic rule that applies everywhere.  It also applies to objects: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $obj = (object) [<span class="hljs-string"><span class="hljs-string">'value'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fnByVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,     object  integer $val = 100; } function fnByRef(&amp;$ref) { $ref = 100; } // ,    ,   $obj,       ‚Äî : fnByVal($obj); var_dump($obj); // stdClass(value =&gt; 1),  fnByVal     fnByRef($obj); var_dump($obj); // int(100)</span></span></code> </pre><br>  You can often hear that in PHP 5 objects are automatically passed by reference, but the example above shows that this is not the case.  The function to which the value is transferred cannot change the value of the passed variable, only the function to which the link is passed can do it. <br><br>  This is true, although the objects actually behave as if they were passed by reference.  You cannot assign a different value to a variable, but you can change the properties of an object.  This is possible because the value of the object is the ID that is used to search for the ‚Äúreal data‚Äù of the object.  Transfer semantics by value will not allow you to change this ID to another one or change the type of a variable, but it will not prevent you from changing the ‚Äúreal data‚Äù of the object. <br><br>  Let's slightly change the example above: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $obj = (object) [<span class="hljs-string"><span class="hljs-string">'value'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fnByVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,       $val-&gt;value = 100; } var_dump($obj); // stdClass(value =&gt; 1) fnByVal($obj); var_dump($obj); // stdClass(value =&gt; 100),  fnByVal     </span></span></code> </pre><br>  The same can be said about the resources, as they also store only the ID, which can be used to search for data.  So again, the semantics of the transfer by value does not allow you to change the ID or the type of zval, but does not prevent you from changing the resource data (for example, shifting the position in the file). <br><br><h6>  Link counting and copy-on-writing </h6><br>  If you think a little about what was written above, then you will come to the conclusion that PHP must perform a huge number of copy operations.  Each time passing a variable to a function, its value must be copied.  This may not be a problem for data of type integer or double, but imagine that you are passing an array of ten million values ‚Äã‚Äãto a function.  Copying millions of values ‚Äã‚Äãeach time a function is called is unacceptably slow. <br><br>  To avoid this, PHP uses the copy-on-write paradigm.  Zval can be shared by many variables / functions / etc, but only as long as the data zval is used for reading.  As soon as someone wants to change the zval data, it will be copied before the changes are applied. <br><br>  Since one zval can be used in several places, PHP should be able to determine the moment, the zval code is no longer used by anyone and remove it (free up the memory it occupies).  PHP does this by simply counting the links.  Note that ‚Äúlink‚Äù here is not a link in terms of PHP (the one that is specified with <code>&amp;</code> ), but simply an indicator saying that someone (variable, function, etc.) uses this zval.  The number of such links is called <code>refcount</code> and it is stored in the data member <code>refcount__gc</code> zval. <br><br>  To understand how this works, let's take an example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(value=1, refcount=1) $b = $a; // $a = $b = zval_1(value=1, refcount=2) $c = $b; // $a = $b = $c = zval_1(value=1, refcount=3) $a++; // $b = $c = zval_1(value=1, refcount=2) // $a = zval_2(value=2, refcount=1) unset($b); // $c = zval_1(value=1, refcount=1) // $a = zval_2(value=2, refcount=1) unset($c); // zval_1 ,   refcount=0 // $a = zval_2(value=2, refcount=1)</span></span></code> </pre><br>  The logic here is simple: when a link is added, the value of <code>refcount</code> incremented by one, when the link is deleted - the <code>refcount</code> decreases.  When the value of <code>refcount</code> reaches 0 - zval is deleted. <br><br>  However, this method will not work in the case of circular references: <br><br><pre> <code class="cpp hljs">&lt;?php $a = []; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(value=[], refcount=1) $b = []; // $b = zval_2(value=[], refcount=1) $a[0] = $b; // $a = zval_1(value=[0 =&gt; zval_2], refcount=1) // $b = zval_2(value=[], refcount=2) // refcount zval_2    //     zval_1 $b[0] = $a; // $a = zval_1(value=[0 =&gt; zval_2], refcount=2) // $b = zval_2(value=[0 =&gt; zval_1], refcount=2) // refcount zval_1    //     zval_2 unset($a); // zval_1(value=[0 =&gt; zval_2], refcount=1) // $b = zval_2(value=[0 =&gt; zval_1], refcount=2) // refcount zval_1 ,  zval //          zval_2 unset($b); // zval_1(value=[0 =&gt; zval_2], refcount=1) // zval_2(value=[0 =&gt; zval_1], refcount=1) // refcount zval_2 ,  //          zval_1</span></span></code> </pre><br>  After the code above is run, we get a situation in which we will have two zvals that are not accessible through any variable, but still exist in memory, as they refer to each other.  This is a classic example of a reference counting problem. <br><br>  To solve this problem in PHP, another garbage collection mechanism is implemented - the circular garbage collector.  We can ignore it now because the circular collector (unlike the reference counting mechanism) is transparent to developers of PHP extensions.  If you are interested in this topic, then refer to the PHP documentation, which describes this algorithm. <br><br>  There is another feature of PHP links (those defined as <code>&amp;$var</code> , and not those that were discussed above) that needs to be considered.  To indicate that zval is used as a PHP reference, the <code>is_ref__gc</code> flag is <code>is_ref__gc</code> in the zval structure. <br><br>  If <code>is_ref=1</code> this is a signal that zval should not be copied before the modification, instead, the value of zval should be changed: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(value=1, refcount=1, is_ref=0) $b =&amp; $a; // $a = $b = zval_1(value=1, refcount=2, is_ref=1) $b++; // $a = $b = zval_1(value=2, refcount=2, is_ref=1) //   is_ref=1 PHP   zval //      </span></span></code> </pre><br>  In the example above, the zval variable <code>$a</code> has a <code>refcount=1</code> before creating the link.  Now consider a similar example with the number of links greater than 1: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(value=1, refcount=1, is_ref=0) $b = $a; // $a = $b = zval_1(value=1, refcount=2, is_ref=0) $c = $b // $a = $b = $c = zval_1(value=1, refcount=3, is_ref=0) $d =&amp; $c; // $a = $b = zval_1(value=1, refcount=2, is_ref=0) // $c = $d = zval_2(value=1, refcount=2, is_ref=1) // $d   $c,  **  $a and $b,  // zval    .     //  zval  is_ref=0   is_ref=1. $d++; // $a = $b = zval_1(value=1, refcount=2, is_ref=0) // $c = $d = zval_2(value=2, refcount=2, is_ref=1) //       2  zvals $d++  //  $a  $b (  ).</span></span></code> </pre><br>  As you can see, when creating a link to zval c <code>is_ref=0</code> and <code>refcount&gt;1</code> requires creating a copy.  Similarly, when using zval with <code>is_ref=1</code> and <code>refcount&gt;1</code> in context with passing by value, a copy operation is required.  For this reason, using PHP links usually slows down the code.  Almost all functions in PHP use the transfer semantics by value, so they create a copy when they receive a zval with the value <code>is_ref=1</code> . <br><br><h5>  Conclusion </h5><br>  In this article, I gave the squeeze of the Zvals chapter of the PHP Internals Book.  I tried to keep only the material that would be useful for PHP-developers and cut out a lot of text related to the development of extensions (otherwise the article would have grown 3 times).  If you are interested in learning more about the issue of developing extensions for PHP, you can refer to the <a href="http://www.phpinternalsbook.com/">book</a> or <a href="http://romka.gitbooks.io/php-internals-book-ru">my translation</a> .  At the moment, only the head of Zvals is translated, but I continue to work.  In the near future, I will take on the most interesting chapters about hash tables and classes. <br><br><hr><br>  [ <sup>1</sup> ] The translation of the book is done with the permission of the authors, but it is unofficial.  You can <a href="http://romka.gitbooks.io/php-internals-book-ru">read</a> my translation here: <a href="http://romka.gitbooks.io/php-internals-book-ru">romka.gitbooks.io/php-internals-book-ru</a> , help translate here: <a href="https://github.com/romka/phpinternalsbook-ru">github.com/romka/phpinternalsbook-ru</a> </div><p>Source: <a href="https://habr.com/ru/post/226707/">https://habr.com/ru/post/226707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226693/index.html">Skype 4.3 for Linux released</a></li>
<li><a href="../226695/index.html">Introduction to XWT</a></li>
<li><a href="../226697/index.html">Digest photo news # 5: the best materials of the beginning of June</a></li>
<li><a href="../226699/index.html">Cisco re-enters the personal computers protection segment.</a></li>
<li><a href="../226701/index.html">MeetUp Autodesk. Let's discuss modern technologies of visualization of 3D-models in WEB</a></li>
<li><a href="../226711/index.html">The company Ilona Mask SolarCity intends to become the largest manufacturer of solar panels in the world</a></li>
<li><a href="../226713/index.html">Summer Mini-Conference on Robotics in Yekaterinburg</a></li>
<li><a href="../226715/index.html">Video recordings of DesignLab conference reports</a></li>
<li><a href="../226723/index.html">The most complete collection of video games in the world sold for 750 thousand dollars</a></li>
<li><a href="../226725/index.html">How we increased JSON generation speed by 6000 times</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>