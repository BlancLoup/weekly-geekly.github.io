<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>jl-sql: SQL queries by JSON logs on the command line</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nobody is interested in the introduction, so I'll start right away with examples of using 



% cat log.json  


 {"type": "hit", "client": {"ip": "12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>jl-sql: SQL queries by JSON logs on the command line</h1><div class="post__text post__text-html js-mediator-article"><p>  Nobody is interested in the introduction, so I'll start right away with examples of using </p><br><img src="https://habrastorage.org/files/6fb/fc4/506/6fbfc450605a4350bfce24d2ddb54b42.png" alt="json-pipe-sql" align="right"><br><pre><code class="bash hljs">% cat log.json</code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hit"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hit"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.2.3.4"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hit"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.3.4.5"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hit"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.3.4.5"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hit"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-string"><span class="hljs-string">"client"</span></span>: {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.2.3.4"</span></span>}}</code> </pre> <br><p>  Execute the query: </p><br><pre> <code class="bash hljs">% cat log.json | jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT client.ip, COUNT(*) AS count WHERE type = "hit" GROUP BY client.ip'</span></span></code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>},<span class="hljs-string"><span class="hljs-string">"count"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>} {<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.2.3.4"</span></span>},<span class="hljs-string"><span class="hljs-string">"count"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.3.4.5"</span></span>},<span class="hljs-string"><span class="hljs-string">"count"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>}</code> </pre> <a name="habracut"></a><br><hr><br><h1 id="kratkoe-opisanie">  Short description </h1><br><p>  As you can see, to execute the query, the <a href="https://github.com/avz/jl-sql">jl-sql</a> utility is used, which accepts a stream of JSON objects separated by a newline character ( <code>"\n"</code> ) as input. </p><br><p>  It is worth noting here that the utility is based on the <a href="https://github.com/avz/node-jl-sql-api">jl-sql-api</a> library, on the basis of which you can quite simply implement data processing in an arbitrary format, not limited only to JSON. </p><br><p>  The SQL engine supports <code>WHERE</code> , <code>GROUP BY</code> , <code>HAVING</code> , <code>ORDER BY</code> and <code>{LEFT|INNER} JOIN</code> .  As for <code>JOIN</code> , there is a restriction on the expression in <code>ON</code> : support for joins is implemented only by the exact correspondence of two fields, the so-called <a href="https://en.wikipedia.org/wiki/Join_(SQL)">Equi Join</a> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, @town.name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> townName <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">`towns.json`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> @towns.id = townId</code> </pre> <br><hr><br><h1 id="primery">  Examples </h1><br><h2 id="opredelenie-unikalnyh-ip-adresov">  Definition of unique ip-addresses </h2><br><pre> <code class="bash hljs">% cat log.json | jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT DISTINCT client.ip AS ip'</span></span></code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>} {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.2.3.4"</span></span>} {<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.3.4.5"</span></span>}</code> </pre> <br><h2 id="podschyot-kolichestva-unikalnyh-adresov-dlya-kazhdoy-gruppy">  Counting the number of unique addresses for each group </h2><br><pre> <code class="bash hljs">% cat log.json | jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT type, COUNT(DISTINCT client.ip) AS ipCount GROUP BY type'</span></span></code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"click"</span></span>,<span class="hljs-string"><span class="hljs-string">"ipCount"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"hit"</span></span>,<span class="hljs-string"><span class="hljs-string">"ipCount"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <br><h2 id="perestroyka-obektov">  Rebuilding facilities </h2><br><p>  With the help of alias ( <code>AS</code> ), you can not only assign aliases to the fields, but also create complex structures within the object: </p><br><pre> <code class="bash hljs">% <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'{"a": 1, "b": 2}'</span></span> | jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT a AS sub.bar.first, b AS sub.foo.second'</span></span></code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"sub"</span></span>:{<span class="hljs-string"><span class="hljs-string">"bar"</span></span>:{<span class="hljs-string"><span class="hljs-string">"first"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-string"><span class="hljs-string">"foo"</span></span>:{<span class="hljs-string"><span class="hljs-string">"second"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>}}}</code> </pre> <br><h2 id="udalenie-i-izmenenie">  Delete and modify </h2><br><p>  In addition to <code>SELECT</code> , <code>DELETE</code> and <code>UPDATE</code> are also supported. </p><br><pre> <code class="bash hljs">% cat log.json | jl-sql -b :ip=127.1.2.3 <span class="hljs-string"><span class="hljs-string">'DELETE WHERE client.ip = :ip'</span></span></code> </pre> <br><pre> <code class="bash hljs">% cat log.json | jl-sql -b :ip=127.1.2.3 <span class="hljs-string"><span class="hljs-string">'UPDATE SET banned = true WHERE client.ip = :ip'</span></span></code> </pre> <br><p>  These examples also show the use of bindings (the <code>-b</code> / <code>--bind</code> option), more in detail about them is described in the <a href="https://habr.com/ru/post/319722/">corresponding section</a> . </p><br><h2 id="rabota-s-datami">  Work with dates </h2><br><pre> <code class="bash hljs">% <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'{"ts": "2017-01-18 00:00:00"}'</span></span> | jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT ts - INTERVAL 2 MONTH 3 DAY 4 HOUR 5 MINUTE 6 SECOND AS past'</span></span></code> </pre> <br><p>  The keyword <code>INTERVAL</code> allows you to "add" and "take away" periods of time from a certain date.  All this is similar to using <code>INTERVAL</code> in MySQL. </p><br><p>  Since JSON does not provide a separate data type for dates, strings are used to save them.  The utility understands formats from <a href="https://tools.ietf.org/html/rfc2822">RFC2822</a> or <a href="https://ru.wikipedia.org/wiki/ISO_8601">ISO 8601</a> .  Others may be used, but the results will be unpredictable. </p><br><p>  It should be noted that the system time zone is used for parsing and date manipulation.  If this does not suit you, then you can set the <code>TZ</code> environment variable with the desired time zone before running <code>jl-sql</code> . </p><br><p>  A more detailed description of working with dates can be found in the <a href="https://github.com/avz/node-jl-sql-api">documentation on GitHub</a> . </p><br><h2 id="obedineniya-join">  <code>JOIN</code> </h2><br><p>  For <code>JOIN</code> , at least one more data source is required, in terms of SQL, this is called a ‚Äútable‚Äù, as such sources are regular files: </p><br><pre> <code class="bash hljs">% cat banned.json</code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}</code> </pre> <br><pre> <code class="bash hljs">% cat log.json | jl-sql -b :banned=banned.json <span class="hljs-string"><span class="hljs-string">'SELECT * INNER JOIN {:banned} ON @banned.ip = client.ip'</span></span></code> </pre> <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"hit"</span></span>,<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"hit"</span></span>,<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}} {<span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"click"</span></span>,<span class="hljs-string"><span class="hljs-string">"client"</span></span>:{<span class="hljs-string"><span class="hljs-string">"ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"127.1.2.3"</span></span>}}</code> </pre> <br><p>  In this example, a new concept was introduced - the data source ( <code>@banned</code> ), more details about this and JOIN in general can be found in the <a href="https://habr.com/ru/post/319722/">corresponding section</a> . </p><br><hr><br><h1 id="proizvoditelnost-i-potreblyaemye-resursy">  Productivity and consumed resources </h1><br><p>  The utility is designed for processing large logs.  Depending on the type, the request can be executed either in <em>streaming mode</em> or in the <em>mode of using temporary storage</em> .  A huge advantage of <em>streaming mode</em> is the ability to perform <a href="https://github.com/avz/jl-sql">jl-sql</a> in conjunction, for example, with <code>tail -f</code> for filtering and reformatting logs in real time. </p><br><ul><li>  <em>streaming mode</em> - a mode in which the request processes incoming data immediately, without waiting for the end of the incoming stream.  The computational complexity of such processing is <code>O(n)</code> by CPU and <code>O(1)</code> by memory.  In this mode, only the simplest queries that do not require sorting can be executed: <code>SELECT &lt;fields...&gt;</code> , <code>SELECT ... WHERE expression</code> . </li><li>  <em>the mode of using temporary storage</em> - to fulfill the request, the incoming stream must be sorted.  This means that you may need temporary storage in the FS.  This category includes queries with <code>GROUP BY</code> , <code>ORDER BY</code> and <code>JOIN</code> .  The sizes of the internal buffers are given by the <code>-B</code> and <code>-S</code> options (see the <a href="https://habr.com/ru/post/319722/">description of the options</a> ). </li></ul><br><p>  For sorting large volumes of <a href="https://github.com/avz/jl-sql">jl-sql</a> uses the system utility <code>sort</code> , which allows the use of more productive native sorting. </p><br><hr><br><h1 id="ustanovka">  Installation </h1><br><p><img src="https://habrastorage.org/files/cd4/4a4/d08/cd44a4d08162464b9f46d11ab417a035.png" align="right">  The code is written in JavaScript under Node.js, so the easiest way to install the package is through <code>npm</code> : </p><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># npm install -g jl-sql</span></span></code> </pre> <br><p>  <strong>Attention:</strong> Node.js version is required not less than 6.0.0 </p><br><hr><br><h1 id="gryaznye-podrobnosti">  Dirty details </h1><br><h2 id="sortirovka">  Sorting </h2><br><p>  Sorting can be set by the standard <code>ORDER BY expression [{DESC|ASC}]</code> , the sorting is supported by several fields at once, including multidirectional ones. </p><br><p>  The unstructured data at the input introduces its own corrections: the field by which sorting is performed may be absent in some objects or may have different types of data in different objects.  Therefore, it is advisable to always explicitly specify the data type with the <code>STRING()</code> and <code>NUMBER()</code> functions: </p><br><p>  Sort by rows </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> STRING(field)</code> </pre> <br><p>  Sort by numbers </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> NUMBER(field)</code> </pre> <br><p>  If you do not explicitly specify the type of sorting, the utility will try to determine the type according to the rules described <a href="https://github.com/avz/node-jl-sql-api">here</a> .  If the type could not be determined, then the sorting will occur in rows. </p><br><p>  Values ‚Äã‚Äãare converted to a string according to the following rules: </p><br><table><thead><tr><th>  Data type </th><th>  String representation </th></tr></thead><tbody><tr><td>  line </td><td>  source line </td></tr><tr><td>  number </td><td>  decimal string </td></tr><tr><td>  boolean </td><td>  <code>"true"</code> / <code>"false"</code> </td></tr><tr><td>  null </td><td> <code>"null"</code> </td> </tr><tr><td>  missing field </td><td>  <code>""</code> (empty string) </td></tr><tr><td>  an object </td><td>  N / A <sup>*</sup> </td></tr><tr><td>  array </td><td>  N / A <sup>*</sup> </td></tr></tbody></table><br><p>  <sup>*</sup> - conversion of strings and arrays to a string is not specified, so relying on the order of these values ‚Äã‚Äãin the total set should not be. </p><br><p>  <em>I recommend always explicitly setting the data type.</em>  <em>current default behavior can be changed or completely removed as potentially dangerous.</em> </p><br><hr><br><h2 id="bindingi">  Binding </h2><br><p>  In order to solve the problem of data screening on the command line, the utility allows you to use binders (substitutions): </p><br><pre> <code class="bash hljs">jl-sql -b :<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=hit jl-sql <span class="hljs-string"><span class="hljs-string">'SELECT client.ip, COUNT(*) AS count WHERE type = :type GROUP BY client.ip'</span></span></code> </pre> <br><p>  Here the option <code>-b :type=hit</code> specifies a substitution with the name <code>:type</code> and the value <code>"hit"</code> .  This makes it possible to use conventional shell-level screening for SQL queries. </p><br><p>  Similarly, you can use substitutions for the file names used in the <code>JOIN</code> : </p><br><pre> <code class="bash hljs">jl-sql -b :towns=towns.json <span class="hljs-string"><span class="hljs-string">'SELECT id, @town.name AS townName JOIN {:towns} ON @towns.id = townId'</span></span></code> </pre> <br><p>  This will allow the use of autocomplete file names in your favorite shell. </p><br><p>  More specifically about <code>JOIN</code> can be read in the appropriate section <a href="https://habr.com/ru/post/319722/">JOIN</a> . </p><br><hr><br><h1 id="join"> <code>JOIN</code> </h1> <br><p>  <code>JOIN</code> support required an introduction to the syntax of a new entity - the name of the data source (you can call it a "table").  The problem here is that in "classic" SQL you can always determine where in the <code>ident1.ident2</code> identifier <code>ident1.ident2</code> name of the table, and where is the name of the field.  With JSON, everything is more complicated: objects can have different nesting, so without special syntax it is impossible to say exactly what the user had in mind when he entered <code>ident1.ident2</code> because  <code>ident1</code> can be either a field name or a "table" name. </p><br><p>  To resolve this ambiguity, the <code>@ident</code> syntax was <code>@ident</code> , where <code>@</code> is the prefix indicating that the identifier next to it is the name of the "table". </p><br><p>  Let's return to the example from the beginning of the article and analyze it in more detail: </p><br><pre> <code class="bash hljs">% cat log.json | jl-sql -b :banned=banned.json <span class="hljs-string"><span class="hljs-string">'SELECT * INNER JOIN {:banned} ON @banned.ip = client.ip'</span></span></code> </pre> <br><p>  So let's start from the beginning: </p><br><p>  <strong><code>-b :banned=banned.json</code></strong> - create a binding with the name of the source file, this is not an obligatory step, but it allows your shell to auto-complete petey, and also eliminates the need to escape special characters in the path </p><br><p>  <strong><code>INNER JOIN {:banned}</code></strong> - here <code>{:banned}</code> is a special syntax for substitution of binding in <code>JOIN</code> .  Without the use of binders, this line would look like <strong><code>INNER JOIN `banned.json`</code></strong> .  The use of back quotes is mandatory here.  otherwise, the dot ( <code>.</code> ) will be interpreted in a special way. </p><br><p>  <strong><code>@banned.ip</code></strong> - here <code>@banned</code> is the name of the table.  In this case, the name was derived automatically from the name of the binding, but you can explicitly set it via alias: <strong><code>INNER JOIN {:banned} AS @someName</code></strong> , then the call to this table will occur as <code>@someName.ip</code> </p><br><p>  <em>I recommend to always use binders, both for files and for regular data.</em>  <em>This eliminates many problems.</em> </p><br><p>  Currently only two types of JOIN are <code>INNER JOIN</code> : <code>INNER JOIN</code> and <code>LEFT JOIN</code> .  If you do not specify a JOIN type in the query, then the <code>INNER JOIN</code> will be used. </p><br><p>  Kau has already been said earlier, the expression in <code>ON</code> must have the form <code>ON @table.primary = foreign</code> , that is, the exact correspondence of the field <code>@table.primary</code> (the table to be connected) to the <code>foreign</code> field (the main table). </p><br><hr><br><h1 id="operatory-sravneniya">  Comparison operators </h1><br><p>  For convenience, the operator <code>=</code> (and its alias <code>==</code> ) does not take into account the type of the value and tries to compare the values ‚Äã‚Äãas liberal as possible, therefore the value of the expression <code>1 = "1"</code> will be <code>true</code> .  In contrast, the <code>===</code> operator also takes into account the type when comparing, so the expression <code>1 === "1"</code> will already be <code>false</code> .  Comparison rules are similar to those used in JavaScript, more details can be found <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25D1%2581%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">here</a> . </p><br><h2 id="sravnenie-obektov-i-massivov">  Comparing Objects and Arrays </h2><br><p>  The behavior of the operators <code>=</code> and <code>===</code> not defined for arrays and objects, so this comparison should be avoided at the moment.  In the future, the comparison of objects and arrays will be implemented. </p><br><hr><br><h1 id="opcii-komandnoy-stroki">  Command line options </h1><br><pre> <code class="bash hljs">% jl-sql -h</code> </pre> <br><pre> <code class="hljs mel">Usage: jl-sql [OPTIONS] SQL OPTIONS: -h, --<span class="hljs-keyword"><span class="hljs-keyword">help</span></span> show this <span class="hljs-keyword"><span class="hljs-keyword">help</span></span> -I, --ignore-json-<span class="hljs-keyword"><span class="hljs-keyword">error</span></span> ignore broken JSON -v, --verbose display additional information -B, --<span class="hljs-keyword"><span class="hljs-keyword">sort</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>-buffer-length=ROWS save up to ROWS rows <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">memory</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort</span></span> -S, --<span class="hljs-keyword"><span class="hljs-keyword">sort</span></span>-external-buffer-<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>=SIZE use SIZE bytes <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">`sort`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span> buffer -T, --temporary-directory=DIR use DIR <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> temporaries, not $TMPDIR or /tmp -b, --bind=BIND=VALUE+ bind valiable See full documentation at https:<span class="hljs-comment"><span class="hljs-comment">//github.com/avz/jl-sql</span></span></code> </pre> <br><p>  More detail on interesting options </p><br><ul><li>  <code>-I</code> : ignore errors in JSON.  By default, <code>jl-sql</code> fails (non-zero return codes) after detecting the first error in JSON.  This option allows you to override this behavior and simply ignore such errors.  The warning output in stderr remains </li><li>  <code>-B</code> : set a limit on the number of lines / objects that will be sorted in RAM without using external sorting through the system utility <code>sort</code> </li><li>  <code>-S</code> : set a limit on the amount of RAM used by the <code>sort</code> utility as a buffer (see the description of the <code>-S</code> option in <code>man sort</code> ) </li><li>  <code>-T</code> : directory to place temporary sorting files </li></ul><br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://github.com/avz/jl-sql">https://github.com/avz/jl-sql</a> - the main repository of the utility </li><li>  <a href="https://github.com/avz/node-jl-sql-api">https://github.com/avz/node-jl-sql-api</a> - SQL engine repository </li></ul><br><p>  Thanks for attention. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/319722/">https://habr.com/ru/post/319722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319710/index.html">8 network resources to remove malicious code and eliminate the consequences of hacking the site</a></li>
<li><a href="../319712/index.html">Crysis at the maximum speed, or why the server needs a video card</a></li>
<li><a href="../319714/index.html">Flash to the head: IBM announced a line of storage arrays for the cloud</a></li>
<li><a href="../319716/index.html">Server abroad</a></li>
<li><a href="../319718/index.html">IT-meetup Superjob ‚ÄúiOS - architecture of design, code, deployment‚Äù</a></li>
<li><a href="../319724/index.html">How npm became the most popular package manager in the world</a></li>
<li><a href="../319726/index.html">Not OK, Google! Or, how to talk with Google AdWords support</a></li>
<li><a href="../319728/index.html">MIT launched Moral Machine: an experiment to study how unmanned vehicles should be delivered</a></li>
<li><a href="../319730/index.html">Verification of the finite state machine</a></li>
<li><a href="../319732/index.html">Playing Encrypted On-the-Fly Encrypted Files on iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>