<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional testing of modern web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern web applications often contain many moving parts and third-party dependencies. In the process of refactoring and adding / changing functionalit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional testing of modern web applications</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/db9/80c/76c/db980c76cc584bb68c981d73fb2ff792.jpg"></div><br>  Modern web applications often contain many moving parts and third-party dependencies.  In the process of refactoring and adding / changing functionality in such an application, the breakdown of existing use-case scripts and unstable work in certain browsers can occur. <p></p><br><p>  For the timely detection of such situations and the implementation of continuous integration, functional testing of the web application is necessary.  The article will discuss two free open-source solutions: </p><br><ul><li>  <a href="https://devexpress.github.io/testcafe/">https://devexpress.github.io/testcafe/</a> </li><li>  <a href="http://nightwatchjs.org/">http://nightwatchjs.org/</a> <br><a name="habracut"></a></li></ul><br><p>  These solutions provide a similar, at first glance, a number of possibilities. </p><br><ul><li>  Automated functional testing with sequential and parallel test execution and grouping, integration with Gulp and Mocha. </li><li>  Support for most desktop and mobile browsers;  interaction with the real DOM API (the web application opens in a non-hidden browser window in the usual tab - the test is as close to life as possible). </li><li>  Extensive support for page element selectors: document.querySelector, CSS selectors, and even XPath;  The combination of these options allows you to maintain the functionality of the functional test when making changes to the markup. </li><li>  Automatic waiting for the browser's DOM-model to be ready, synchronous delivery of visual interaction commands (clicks on buttons, input into text fields);  convenient tools to wait for client JS-code and network AJAX activity. </li><li>  Support iframe-s - by selecting the current context DOMWindow - window for the test and the execution of commands within it with the ability to switch at any time. </li><li>  Opportunities for expansion - both solutions provide opportunities for adding support for custom browsers and expanding your own functionality, including adding new commands. </li></ul><br><h2>  Function Test Example </h2><br><p>  An example for testing would be a TodoMVC-type web application, with a server on node.js and a client SPA page on React + Redux.  To bring the testing conditions closer to real ones, random delays were added to all redux action actions that emulate network interaction with the backend (this is based on). </p><br><p>  In the future, it will be assumed that the test web application is launched at <a href="http://localhost:4000/">http: // localhost: 4000 /</a> .  The functional test will be simple and include adding a todo-element, editing its contents, marking the completed / failed task and deleting it. </p><br><p>  The language for writing tests in both frameworks is JS (ES2016 and ES5, respectively, for TestCafe and Nightwatch), but this is perfect for web applications written in any language.  If you haven‚Äôt been developing on JS for a long time, then you need to take into account that modern editions are very far from the old ES3, and include convenient tools for writing code, object-oriented and functional programming, and much more. </p><br><p> TestCafe is installed with just one <code>npm install -g testcafe</code> .  After completing the download and installation of the necessary dependencies, the test is executed by the <code>testcafe &lt;browser-name&gt; &lt;tests-directory&gt;/</code> command in the appropriate directory. </p><br><p>  The source code of the functional test checking the above use-case script may be as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { expect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'chai'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Selector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'testcafe'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_TIME_AJAX_WAIT = <span class="hljs-number"><span class="hljs-number">2500</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 2.5 seconds by default const querySelector = Selector((val) =&gt; document.querySelector(val), { timeout: MAX_TIME_AJAX_WAIT }); const querySelectorCondition = Selector((val, checkFunc) =&gt; { const foundElems = document.querySelectorAll(val); if(!foundElems) return null; for(let i=0; i &lt; foundElems.length; i++) { if(checkFunc(foundElems[i])) return foundElems[i]; } return null; }, { timeout: MAX_TIME_AJAX_WAIT }); fixture `Example page` .page `http://localhost:4000/`; test('Emulate user actions and perform a verification', async t =&gt; { await t.setNativeDialogHandler(() =&gt; true); const inputNewTodo = await querySelector('header.header input.new-todo'); await t.typeText(inputNewTodo, 'New TODO element\r\n'); const addedTodoElement = await querySelectorCondition( 'section.main label', (elm) =&gt; (elm.innerText === 'New TODO element') ); await t.doubleClick(addedTodoElement); const addedTodoEditInput = await querySelectorCondition( 'section.main input[type=text]', (elm) =&gt; (elm.value === 'New TODO element') ); await t.typeText(addedTodoEditInput, ' changed\r\n'); const addedTodoCheckboxAC = await querySelectorCondition( 'section.main input[type=checkbox]:not([checked])', (elm) =&gt; (elm.nextSibling.innerText === 'New TODO element changed') ); await t.click(addedTodoCheckboxAC); const addedTodoCheckboxBC = await querySelectorCondition( 'section.main input[type=checkbox]', (elm) =&gt; (elm.nextSibling.innerText === 'New TODO element changed') ); await t.click(addedTodoCheckboxBC); const addedTodoDelBtn = await querySelectorCondition( 'button.destroy', (elm) =&gt; (elm.previousSibling.innerText === 'New TODO element changed') ); await t.click(addedTodoDelBtn); });</span></span></code> </pre> <br><p>  The address of the tested web page is determined in the fixture-part, followed by functional tests, upon completion of each of which the web-page is automatically restored to its original state.  To search for DOM elements on the page, testcafe-specific Selectors are used, which are used as a wrapper for the function that will perform the query to the DOM model, possibly using arguments. </p><br><p>  In this example, the first selector represents a wrapper over document.querySelector, and the second - above document.querySelectorAll with a callback function that helps select the desired item from the list.  The Selector wrapper accepts options; in particular, the maximum time is set here during which testcafe will wait for an element with specified characteristics to appear in the DOM model. </p><br><p>  The function test itself is a set of asynchronous calls to the Selectors, between which actions are performed by means of a test controller, instantiated by the variable t.  The purpose of most of its methods is obvious from the names (click, typeText, etc.), and <code>t.setNativeDialogHandler</code> used to prevent the generation of alert-like windows that can ‚Äúhang‚Äù the test ‚Äî which is very convenient. </p><br><p>  The installation of Nightwatch also starts with a simple <code>npm install -g nightwatch</code> , however, to run functional tests, you also need Selenuim-server (you can download it <a href="">here</a> , Java SE runtime must be installed on your computer) and webdrivers for each of the browsers that will be launched test. </p><br><p>  To run the tests, you first need to create the nightwatch.json configuration file that describes the location of the tests, the paths and settings for the selenium-server and webdrivers, and then use the simple <code>nightwatch</code> command in the current directory. <br>  If you use Microsoft Web Driver (Edge), then nightwatch.json might look something like this: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"src_folders"</span></span> : [<span class="hljs-string"><span class="hljs-string">"nightwatch-tests"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"output_folder"</span></span> : <span class="hljs-string"><span class="hljs-string">"reports"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"custom_commands_path"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"custom_assertions_path"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"page_objects_path"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"globals_path"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"selenium"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"start_process"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"server_path"</span></span> : <span class="hljs-string"><span class="hljs-string">"nightwatch-bin/selenium-server-standalone-3.0.1.jar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"log_path"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span> : <span class="hljs-number"><span class="hljs-number">4444</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cli_args"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"webdriver.edge.driver"</span></span> : <span class="hljs-string"><span class="hljs-string">"nightwatch-bin/MicrosoftWebDriver.exe"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"test_settings"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"default"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"selenium_port"</span></span> : <span class="hljs-number"><span class="hljs-number">4444</span></span>, <span class="hljs-attr"><span class="hljs-attr">"selenium_host"</span></span> : <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"desiredCapabilities"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"browserName"</span></span>: <span class="hljs-string"><span class="hljs-string">"MicrosoftEdge"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"acceptSslCerts"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre> <br><p>  The source code of the function test, which checks the use-case script similar to the one discussed above, may look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-string"><span class="hljs-string">'Demo test'</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">client</span></span></span><span class="hljs-function">) </span></span>{ client.url(<span class="hljs-string"><span class="hljs-string">'http://localhost:4000/'</span></span>) .waitForElementVisible(<span class="hljs-string"><span class="hljs-string">'body'</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// May use CSS selectors for element search .waitForElementVisible('header.header input.new-todo', 1000) .setValue('header.header input.new-todo', ['New TODO element', client.Keys.ENTER]) // Or use Xpath - it's more powerful tool .useXpath() .waitForElementVisible('//section[@class=\'main\']//label[text()=\'New TODO element\']', 2000) .execute(function() { // For dispatch double click - Nightwatch doesn't support it by default var evt = new MouseEvent('dblclick', {'view': window, 'bubbles': true,'cancelable': true}); var foundElems = document.querySelectorAll('section.main label'); if(!foundElems) return; var elm = null; for(var i=0; i &lt; foundElems.length; i++) { if(foundElems[i].innerText === 'New TODO element') { elm = foundElems[i]; break; } } elm.dispatchEvent(evt); }) .waitForElementVisible('//section[@class=\'main\']//input[@type=\'text\']', 2000) .clearValue('//section[@class=\'main\']//input[@type=\'text\']') .setValue('//section[@class=\'main\']//input[@type=\'text\']', ['New TODO element changed', client.Keys.ENTER] ) .waitForElementVisible( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/preceding-sibling::input[@type=\'checkbox\' and not(@checked)]', 2000 ) .click( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/preceding-sibling::input[@type=\'checkbox\' and not(@checked)]' ) .waitForElementVisible( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/preceding-sibling::input[@type=\'checkbox\']', 2000 ) .click( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/preceding-sibling::input[@type=\'checkbox\']' ) .waitForElementVisible( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/following-sibling::button[@class=\'destroy\']', 2000 ) .click( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']' + '/following-sibling::button[@class=\'destroy\']' ) .waitForElementNotPresent( '//section[@class=\'main\']//label[text()=\'New TODO element changed\']', 2000 ) .pause(2000) .end(); } }</span></span></code> </pre> <br><p>  Among the features of the code, it is easy to see that Nightwatch does not support the double-click emulation of an element ‚Äî instead, you have to implement a workaround with an inject-function on the client that performs dispatchEvent on the target control. </p><br><p>  A convenient feature of Nightwatch is support for XPath, which provides much wider possibilities for selecting elements of the DOM model, compared to CSS selectors ‚Äî to take at least an element extraction by its textual content, which is quite often found in the functional test. </p><br><h2>  TestCafe versus Nightwatch functionality </h2><br><p>  <strong>Installation</strong> : <br>  <strong>[T] estCafe</strong> : One <code>npm install -g testcafe</code> , and you can immediately start writing and running tests in the current web project directory <br>  <strong>[N] ightwatch</strong> : Although the installation of the npm module is done simply - <code>npm install -g nightwatch</code> , manual loading of the selenium-standalone-server, webdrivers for all browsers of interest, manual creation of the configuration file will be required (Or maybe even downloading Java, if it is not installed) </p><br><p>  <strong>Selection of DOM elements</strong> : <br>  <strong>T</strong> : The Selectors mechanism is used - wrappers over client JS functions that select one or multiple DOM nodes;  this provides almost unlimited possibilities for selection, from simple wrappers over <code>document.querySelector</code> or <code>document.getElementById</code> to arbitrary logic for traversing DOM elements.  At the same time, TestCafe independently provides for checking the presence / absence of elements according to a given Selector during the specified time. <br>  <strong>N</strong> : There is a choice of CSS selectors or XPath - in principle, the second option is enough to solve most of the tasks for selecting elements on the page, although this certainly doesn‚Äôt compare with the ability to specify complex arbitrary search logic. </p><br><p>  <strong>Test writing language</strong> : <br>  <strong>T</strong> : From the box, it is possible to write tests directly in the ES2016 language, which allows you to write simple and readable test code in the same language as the web application itself. This is also convenient in cases when you need to import a specific module from the project under test. <br>  <strong>N</strong> : Outdated ES5 syntax and exports-constructs in the source code of the functional test (You can still screw ES6, but on crutches) </p><br><p>  <strong>Asynchronous operation support</strong> : <br>  <strong>T</strong> : All API functions are based on Promise, which allows you to describe arbitrary asynchronous logic of the test, and at the same time integrate your own functions from the node.js side.  With support for ES2016, this code can be written using async and await constructs in a consistent style. <br>  <strong>N</strong> : In the test, you can implement a sequence of commands for analyzing and managing the contents of a web page, but they are added to the internal event queue, and integrating your own asynchronous functions with them is problematic. </p><br><p>  <strong>Insert client code on the fly</strong> : <br>  <strong>T</strong> : Easily performed using the appropriate API, supports the creation and subsequent execution of client functions, a single execution of an injected code, the replacement of existing functions in the source web page, as well as the execution of client functions in the callback node.js functions the controller. <br>  <strong>N</strong> : There is functionality for executing JS code on the client side, or even inserting a whole script block, but no means of integration with the test controller is provided.  Suitable for simple synchronous integrable JS code, but more generally integration is problematic. </p><br><p>  <strong>Descriptions of statements and expectations</strong> : <br>  <strong>T</strong> : By default, the usual assertion language is chai / expect, and you can use any other compatible assertion library. <br>  <strong>N</strong> : The advanced <code>assert</code> and <code>expect</code> language, which includes tools for describing the state of a page, including the presence of an element and focus on it, belonging to a CSS class, and so on.  It looks convenient, but primarily due to the lack of full support for asynchronous operations in the test, if necessary, the presence of statements and expectations. </p><br><p>  <strong>Managing the tested web page</strong> : <br>  <strong>T</strong> : Assumes the possibility of mock-a for the functions blocking the execution of scripts <code>alert</code> , <code>confirm</code> and so on, with the ability to set the return value.  Complex manipulations with the DOM model, emulation of user interaction with controls, and even the ability to suspend the JS script due to wrapping client JS functions are supported. <br>  <strong>N</strong> : Commands for direct control of the browser window displayed and the underlying DOM model are supported, integration with the client JS script is difficult </p><br><p>  <strong>Working with the mouse cursor</strong> : <br>  <strong>T</strong> : A virtual cursor is provided, through which hover, click and drag events are performed for the target visual elements of the page.  During the test, you can observe the movement of the cursor and the actions performed. <br>  <strong>N</strong> : Means for working with a cursor are in general - these are functions from webdriver api, but working with actions is more difficult than a single left click, rather problematic - to take at least a double click. </p><br><h2>  Implement browser interaction in TestCafe and NightWatch </h2><br><p>  The NightWatch framework is based on the well-known, to some extent already traditional, Selenium webdriver library, the benefits of which include an established API, a high degree of documentation and extensive Q &amp; A on the Internet, as well as universal and fairly low-level access to the browser ... Interaction with browsers is organized through webdrivers, one for each browser. <br>  The main disadvantage is that webdrivers do not exist for all browsers, and also require a separate update when changing the version of the browser itself, but also requires external dependency on Java.  Read more about webdriver technology at <a href="http://www.w3.org/TR/webdriver/">http://www.w3.org/TR/webdriver/</a> </p><br><p>  The TestCafe framework is based on an approach in which interaction with the browser application is minimized - only the functions of opening the window / tab, resizing the window, navigating to the URL address, and some others are used. <br>  The web page interacts with the testcafe-hammerhead web-proxy server, which loads the remote web page and modifies the source JS code so that it performs the functional test steps, through integration with the DOM model, searching and managing visual elements, performing arbitrary js code and so on.  ( <a href="https://github.com/DevExpress/testcafe-hammerhead/">https://github.com/DevExpress/testcafe-hammerhead/</a> ) </p><br><p>  The TestCafe method is more versatile, as it can potentially work with any browser that supports HTML5 and ES 5+, while NightWatch requires an appropriate webdriver.  In addition, it allows you to run tests not only on the local browser, but on any browser on the network, including any mobile - without installing any software on the phone. </p><br><p>  An example of testing the above web application in the Android browser is shown in the following video: <a href="https://youtu.be/2na5jkqvUx0">https://youtu.be/2na5jkqvUx0</a> </p><br><p>  However, testcafe-hammerhead has potential drawbacks: the overhead of analyzing and modifying the source JS code of the test page, produced in turn by the Testcafe core JS code, as well as theoretically incorrect work of the test web page or test integration, if the source code was proxied wrong.  (For example, replacing an alert window in testcafe can be circumvented by such an example <a href="http://pastebin.com/p6gLWA75">http://pastebin.com/p6gLWA75</a> - and, unfetteredly or specifically, ‚Äúsuspend‚Äù its execution) </p><br><h2>  findings </h2><br><p>  Of course, the selenium-webdriver, on which Nightwatch is based, is a popular and widely known solution that has a standard API interface, which is undoubtedly its advantage.  In addition, in related task areas, for example, automating the target web resource in a given browser ‚Äî actually writing a bot for a remote web site ‚Äî selenium-webdriver is better suited. </p><br><p>  However, for functional testing of a TestCafe web application being developed or supported is undoubtedly ahead for a wide range of reasons: </p><br><p>  1) Running tests in any browser, including mobile phones and tablets, and this can be done in a batch manner for all browsers of interest and does not require installation of any additional software. <br>  2) Convenience of writing a test on ES2016, including async / await constructs for sequential writing code, importing program elements from the project itself, transferring functions to the client and back, and so on - ample opportunities for integration and management of the client web application. <br>  3) Broad support for selectors for visual elements, easy interaction with the DOM model, virtual mouse cursor, emulation of various and complex user interactions with the page. </p><br><p>  Thus, among the existing open-source solutions for functional testing of web applications, TestCafe looks like a very attractive option, moreover, with the combination of lightness and functionality. </p><br><p>  ¬ª <a href="https://github.com/IhostVlad/react-todomvc-with-functional-tests">Source codes of the application and functional tests</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/315526/">https://habr.com/ru/post/315526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315510/index.html">5 books that will help you to think outside the box and why it is important right now</a></li>
<li><a href="../315514/index.html">Speak about the ‚Äúeasy‚Äù process: the development process in the Larian Studios toolkit department</a></li>
<li><a href="../315516/index.html">Around Citrix NetScaler ADC. Part 1</a></li>
<li><a href="../315518/index.html">ReactOS 0.4.3 released under the code name "Haters gonna hate"</a></li>
<li><a href="../315524/index.html">SDN: concept changes over 5 years</a></li>
<li><a href="../315530/index.html">Etiquette and ethics of using OpenSource</a></li>
<li><a href="../315532/index.html">‚ÄúI will know when I see‚Äù - we study the accuracy of Google Cloud Vision using Tumblr and NSFW content</a></li>
<li><a href="../315534/index.html">Opanki, I broke your life</a></li>
<li><a href="../315536/index.html">Reverse tunnel for RDP access using putty and icinga2</a></li>
<li><a href="../315538/index.html">What is Bitrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>