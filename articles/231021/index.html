<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Variadic Templates, Low Coupling and a bit of thinking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each programmer must have come across a situation where the application has a set of classes (possibly service ones) that are used in many parts of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Variadic Templates, Low Coupling and a bit of thinking</h1><div class="post__text post__text-html js-mediator-article">  Each programmer must have come across a situation where the application has a set of classes (possibly service ones) that are used in many parts of the program.  And everything seems to be nothing, but as soon as it became necessary to change these classes, it could negatively influence the calling code.  Yes, as indicated in the title, the article will discuss the very pattern of ‚ÄúLow Coupling‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cf/d1d/212/8cfd1d2124c1ce933e1044d4f1f382e7.jpg"><br><br>  The problem is not new and has long been known.  There may be several ways to solve it, it all depends on the subject area.  I offer the reader a possible solution, which I found while working on an applied task.  As an idealist, the solution I found was not completely satisfactory.  Also, it was designed to a large extent from the desire to take advantage of new features of the standard C ++ 11.  Naturally, everything written is subject to discussion, and perhaps someone will suggest a more slender version. <br><a name="habracut"></a><br><h3>  Task statement </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/ac9/a57/a6d/ac9a57a6db5c03bc895c117b00c38e16.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are various devices in the system.  For example, temperature sensors, speed sensors, alarms, traffic lights and others.  As the reader assumes, all these devices in the program are represented by the heirs from the base class.  Of course, each heir has its own specific member functions. <br><blockquote>  <i>-Everything is as usual.</i>  <i>What is the problem?</i> </blockquote><br>  The problem is that there are several systems.  In each such system, the devices may differ both in composition and in functionality (expand or vice versa, narrow).  For example, in one system there is no traffic light, and in the other, everything is the same as in the first one, but the alarm has several operation modes.  I gave a possible case in the diagram. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8c/8a7/de5/d8c8a7de58783103ba7a4cd00a91c052.png"><br><br>  It can be seen that the specific implementation of <code>SyncBoard</code> for the first system only overrides the speed request method, while new methods are added for the second system.  Thus, the caller needs knowledge of the specific type of each device with which he works.  But the caller does not change from system to system.  Its basic logic is unchanged, only ways of interacting with devices change. <br><blockquote>  <i>- Of course, if the caller needs to use the new functionality of the device, then he simply must know its specific type.</i> </blockquote><br>  But let's look at it from the other side.  There is a certain module / class, which in one system uses the type <code>SyncBoard_System1</code> , and in the second, respectively, <code>SyncBoard_System2</code> .  As I said above, this module / class does not change its logic in these two systems.  Changing only the interaction with the device.  What are the options? <br>  1) Copy this module and use the new way of interaction.  In different systems use different copies of the modules. <br><blockquote>  <i>-Thank you, laughed.</i> </blockquote><br>  2) To make interaction with the device in a separate virtual function.  In successors to redefine interaction with the device. <br><blockquote>  <i>- Already better.</i>  <i>Only you on each device with which the class interacts will be done by a virtual function?</i>  <i>With new devices, new virtual functions will have to appear in interested classes.</i> </blockquote><br>  3) Encapsulate interaction with the device in a separate class and use it as a strategy. <br><blockquote>  <i>-Sounds like in smart books.</i>  <i>But for the new functionality of the device, the strategy must also implement it.</i>  <i>That is, the strategy interface will change, and then you still need to know the specific implementation (type) of the strategy.</i> </blockquote><br>  Concrete is not gone, but the number of links is reduced.  Instead of each caller being tied to a specific device implementation (of which there are many), you can define (strategy) that will delegate the calls to these devices. <br><blockquote>  <i>- Very similar to Mediator or Facade.</i> </blockquote><br>  Only externally.  The common feature of these patterns and my task is that instead of a multitude of links, one single link is created with "".  For now, we‚Äôll dwell on the decision that a class is needed that hides in itself all concrete device implementations and provides an interface to clients for interacting with them. <br><br><h3>  Search for implementation options </h3><br><h4>  <u>Option 1 - in the forehead.</u> </h4><br>  The manager stores a list of all devices and provides the appropriate interface. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7b/f4e/374/b7bf4e3749efb12491fa7d2345d1afe8.png"><br><br><blockquote>  <i>-And if you have more than one temperature sensor in your system?</i>  <i>Function <code>getTemperature()</code> what will return?</i> </blockquote><br>  Fair remark.  It turns out that it is necessary to add a parameter to each such function - a device identifier.  Let's fix it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f92/3cb/aaa/f923cbaaaa787e16814527d08fd30e6d.png"><br><br>  This variant immediately came to my mind, since  simplest.  And this is probably his last plus.  Let's imagine what awaits us when adding a new device.  In addition to creating the class of the new device itself, we will need to display all its functions in the manager (and delegate them, of course).  And if this device is suddenly added to all systems at once, then it will also add all these functions to all specific implementations of the managers of all systems.  "Copy-paste" in its purest form. <br><blockquote>  <i>-Not beautiful, but not deadly.</i> </blockquote><br>  Another scenario.  The two systems are exactly the same.  Differ only in the absence of a single device.  In this case, we can no longer use the written manager class, since  it contains functions that are not needed.  Well, we can be more exact, but there is an opinion that this is wrong.  It remains to either inherit and replace these methods with an empty implementation, or copy the class and delete the unnecessary.  Neither one nor the other did not suit me. <br><br><h4>  <u>Option 2 - a bunch of cases.</u> </h4><br>  But what if we make the manager a single virtual method within which delegation will take place? <br><blockquote>  <i>- You have not forgotten about the different parameters of the functions and different return values?</i> </blockquote><br>  To do this, we will create a base data class through which the calling code will send and receive parameters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2e/f19/c96/c2ef19c96ee6b1b6bf559a6165290afe.png"><br><br><div class="spoiler">  <b class="spoiler_title">Implementation example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDevData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IDevData(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDevData(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DevManager_v2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeviceManager { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    } //   virtual void callMethod(int dev_id, IDevData&amp; data) { switch (data.getID()) { case DATA_SYNC_BOARD_GET_STATE: //      dev_id  getState(); //     IDevData break; case DATA_SYNC_BOARD_GET_VELOCITY: // ... break; // ... etc } } };</span></span></code> </pre><br></div></div><br>  What have we achieved?  We now have only one virtual method.  All changes occur only in it, when adding / removing devices from the system to the system, unnecessary functions disappear automatically.  The calling classes do not need to know the specific implementations of the manager at all!  They only need to know the <code>callMethod</code> method and ... <br><blockquote>  <i>-Yes Yes!</i>  <i>And the specific type of <code>IDevData</code> for each call.</i>  <i>If you ran earlier from binding to specific implementations of devices, then you came to linking to specific implementations of <code>IDevData</code> wrappers.</i>  <i>Funny.</i> </blockquote><br>  Some kind of vicious circle.  We came to the same with which we started.  Before calling a single method on a manager, the caller will need to know exactly what type of <code>IDevData</code> create.  And how does this differ from the situation where the caller knew a particular type of device?  Yes, nothing! <br><br><h4>  <u>Option 3 - C ++ 11</u> </h4><br>  I liked the idea of ‚Äã‚Äãthe only function <code>callMethod()</code> .  But the problem with the transfer and return of parameters reduced all efforts to nothing.  It would be great if we could pass any parameters in any quantity to this single function and could get any type of return value from it ... <br><blockquote>  <i>Yes, everyone already understood what you are talking about templates and C ++ 11.</i>  <i>Come on, tell me how the spaceships plow ... ¬©</i> </blockquote><br>  The new standard just provides such opportunities.  It became clear that the <code>callMethod</code> function should be template and have the following prototype: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-function"><span class="hljs-function">ResType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dev_id, Args&amp;&amp; ... args)</span></span></span></span>;</code> </pre><br>  The caller now needs to know nothing, except for the manager, the types of parameters and the returned values ‚Äã‚Äã(which is already taken for granted)! <br><blockquote>  <i>- And how will you solve the situation when in the same class there are two functions identical in signature?</i>  <i>Judging by your thinking, you want to go somewhere (where?) To <code>dev_id</code> (which means a particular class) and just pass all the parameters of <code>Args&amp;&amp;‚Ä¶</code> someone (to whom?).</i> </blockquote><br>  Indeed, this creates a problem.  There are two options to solve it.  Add another parameter - <code>int method_id</code> , which I don‚Äôt like at all, or give a different meaning to the parameter - <code>int dev_id</code> .  Let's call it, say, <code>command_id</code> , and now it will mean a specific method of a particular class.  That is, a certain pair identifier Class-&gt; method.  Thus, the values ‚Äã‚Äãof these <code>command_id</code> will be exactly the same as the methods of all classes of devices.  For good, of course, this should be turned into an enumeration, but we will not dwell on this.  Now, about "where to go with <code>command_id</code> " and "who to send to <code>Args&amp;&amp;</code> ".  The <code>command_id</code> parameter gives us a hint.  A certain collection of methods is supposed, which is accessed by <code>command_id</code> .  In other words, the following scheme is needed: <br>  1) Create a repository for any functions with any signature. <br>  2) In the <code>callMethod</code> remove the required object from the storage using the <code>command_id</code> key and transfer all parameters <br>  3) Profit! <br><blockquote>  <i>-Thanks, Cap.</i> </blockquote><br>  Point 1 has already been resolved before me.  In particular, on Habr√© there was also an article about <a href="http://habrahabr.ru/post/207294/">type erasure</a> .  I read and slightly modified to fit my needs.  Thanks <a href="https://habrahabr.ru/users/rpz/" class="user_link">rpz</a> and <a href="http://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">other sources</a> . <br><br>  For those who are too lazy or have no time to re-read, I will briefly tell you how it works.  First of all, we need a base class with one useful virtual function for type checking. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">type_info </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><br>  Further, we create the successor - a sample class.  Any function can be passed to it.  In order not to create different templates for different functions (a class method, or a simple function), I decided to use the already prepared <code>std::function</code> .  All that is required of this class is to overload the <code>operator()</code> , into which the parameters for the delegation of the call are passed. <br><div class="spoiler">  <b class="spoiler_title">Template type_impl</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> base_impl { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;ResType(Args ...)&gt; _Fn; _Fn _func; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: type_impl(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;ResType(Args ...)&gt; func) : _func(func) {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">type_info </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(_Fn); } <span class="hljs-function"><span class="hljs-function">ResType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); } };</code> </pre><br></div></div><br>  At the moment, there is already a scheme that allows you to add any function to the container through a pointer to the <code>base_impl</code> class.  But how to get to the <code>operator()</code> call through this pointer?  A type conversion is required.  For this we have a method <code>getTypeInfo()</code> .  To hide this underling, as well as the need to manually write each time, when adding a function to a container, the <code>type_impl</code> template, create the last class with one little trick - the template designer. <br><div class="spoiler">  <b class="spoiler_title">FuncWrapper</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base_impl&gt; holder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Params&gt; FuncWrapper(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;ResType(Params ...)&gt; func) : holder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> type_impl&lt;ResType, Params ...&gt;(func)) {} ~FuncWrapper() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-function"><span class="hljs-function">ResType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;ResType(Args ...)&gt; _Fn; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder-&gt;getTypeInfo() != <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(_Fn)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"Bad type cast"</span></span>); type_impl&lt;ResType, Args ...&gt;* f = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;type_impl&lt;ResType, Args ...&gt;*&gt;(holder); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*f)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); } } };</code> </pre><br></div></div><br>  We add to it the sample <code>call()</code> method and in it we delegate the call to the saved <code>type_impl</code> . <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      callable object. //    ,       class base_impl { public: virtual std::type_info const&amp; getTypeInfo() const = 0; }; //      . //    -   base_impl. //       type_impl,   //     base_impl //      - ResType //    - Args... template &lt;typename ResType, typename ... Args&gt; class type_impl : public base_impl { typedef std::function&lt;ResType(Args ...)&gt; _Fn; _Fn _func; //       ! public: //    ,       std::function //     std::function ? type_impl(std::function&lt;ResType(Args ...)&gt; func) : _func(func) {} //    ,    . //   ,     . //   exception. std::type_info const&amp; getTypeInfo() const { return typeid(_Fn); } //   , ,     . ResType operator()(Args&amp;&amp; ... args) { return _func(std::forward&lt;Args&gt;(args)...); } }; std::unique_ptr&lt;base_impl&gt; holder; public: //  ,      std::function //  ,        template &lt;typename ResType, typename ... Params&gt; FuncWrapper(std::function&lt;ResType(Params ...)&gt; func) : holder(new type_impl&lt;ResType, Params ...&gt;(func)) {} ~FuncWrapper() {} //  ,        template &lt;typename ResType, typename ... Args&gt; ResType call(Args&amp;&amp; ... args) { typedef std::function&lt;ResType(Args ...)&gt; _Fn; if (holder-&gt;getTypeInfo() != typeid(_Fn)) throw std::exception("Bad type cast"); //   ,    type_impl&lt;ResType, Args ...&gt;* f = static_cast&lt;type_impl&lt;ResType, Args ...&gt;*&gt;(holder.get()); return (*f)(std::forward&lt;Args&gt;(args)...); } }; // ,   test, -  class test { public: test() {} int fn1(int a) { cout &lt;&lt; "test::fn1!!! " &lt;&lt; a &lt;&lt; endl; return ++a; } int fn2(int a, int b) { cout &lt;&lt; "test::fn2!!! " &lt;&lt; a &lt;&lt; endl; return a + 2; } int fn3(int a, int b) { cout &lt;&lt; "test::fn3!!! " &lt;&lt; a &lt;&lt; endl; return a + 3; } }; class IDeviceManager { protected: std::map&lt;int, FuncWrapper*&gt; m_funcs; public: virtual ~IDeviceManager() {}; virtual void initialize() = 0; template &lt;typename ResType, typename ... Args&gt; ResType callMethod(int command_id, Args&amp;&amp; ... args) { //     ‚Äì    . return m_funcs[command_id]-&gt;call&lt;ResType&gt;(std::forward&lt;Args&gt;(args)...); } }; const int FN1_ID = 0; const int FN2_ID = 1; const int FN3_ID = 2; class DevManager_v3 : public IDeviceManager { std::unique_ptr&lt;test&gt; m_test_ptr; public: void initialize() { //    m_test_ptr.reset(new test); std::function&lt;int(int)&gt; _func1 = std::bind(&amp;test::fn1, m_test_ptr.get(), std::placeholders::_1); std::function&lt;int(int, int)&gt; _func2 = std::bind(&amp;test::fn2, m_test_ptr.get(), std::placeholders::_1, std::placeholders::_2); std::function&lt;int(int, int)&gt; _func3 = std::bind(&amp;test::fn3, m_test_ptr.get(), std::placeholders::_1, std::placeholders::_2); //      m_funcs[FN1_ID] = new FuncWrapper(_func1); m_funcs[FN2_ID] = new FuncWrapper(_func2); m_funcs[FN3_ID] = new FuncWrapper(_func3); } ~DevManager_v3() { //    } }; int _tmain(int argc, _TCHAR* argv[]) { DevManager_v3 dev_manager; dev_manager.initialize(); // -!        . dev_manager.callMethod&lt;int&gt;(FN1_ID, 1); dev_manager.callMethod&lt;int&gt;(FN2_ID, 2, 3); dev_manager.callMethod&lt;int&gt;(FN3_ID, 4, 5); getchar(); }</span></span></code> </pre><br></div></div><br>  Wow!  We now have one single virtual method, <code>initialize()</code> , which creates all the necessary devices for this system and places their methods in the collection.  The caller does not even need to know the specific type of manager.  The <code>callMethod()</code> method <code>callMethod()</code> does everything for us.  For each specific system, the desired <code>IDevManager</code> instance is <code>IDevManager</code> using, say, <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">&lt;factory&gt;</a> .  The caller needs only an ancestor <code>IDevManager</code> . <br><blockquote>  <i>- It seems you have achieved your goal.</i> </blockquote><br>  Yes, but there are new flaws and they, perhaps, have more significant negative consequences in comparison with the first options.  The code is not safe! <br>  First, look carefully at <code>callMethod()</code> .  If we pass a key that is not in the collection, we get an exception.  Of course, you must first check whether the key is in the collection.  But what to do when it turned out that the key does not exist (a method that does not exist is requested)?  Generate an exception?  And most importantly, at the compilation stage, we will not be able to catch this.  This can happen when a device is missing in some system, or part of its methods. <br>  Secondly, the code editor will not tell you what parameters are expected at the input of <code>callMethod()</code> - it will not highlight the name / type / number of parameters.  If we pass the wrong type of parameter, or the wrong number of parameters, an exception is waiting for us again, but in the <code>call()</code> method of the <code>test_impl</code> class.  And again, we can't catch it at compile time.  This can easily happen because of a programmer‚Äôs inattention. <br><br>  With regard to the task, it did not suit me, for the following reasons: <br>  - At the compilation stage, the exact number of classes (respectively methods) to which access is always known. <br>  - These classes change only when designing different systems. <br>  So I had to start from scratch. <br><blockquote>  <i>- ‚ÄúSho, again ?!‚Äù ¬©</i> </blockquote><br><br><h4>  <u>Option 4 - the final?</u> </h4><br>  I came to him after seeing a very unpretentious construction: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dissembler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T ... { };</code> </pre><br>  What's going on here?  Only multiple inheritance.  But it seems that this is what I need.  If I inherit from all my device classes, I automatically have all their methods in this class.  The disadvantages of the third option disappear. <br><blockquote>  <i>- Holy simplicity.</i>  <i>It will work for you until you have to inherit from two identical classes.</i>  <i>Or in two classes there will be identical functions (diamond-shaped inheritance).</i> </blockquote><br>  So you need to somehow make the methods unique, even if they have the same signature.  And I knew where the clue was.  Thank you, <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25BA%25D1%2583,_%25D0%2590%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B5%25D0%25B9">Andrew</a> ! <br><div class="spoiler">  <b class="spoiler_title">It's simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, T t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueToType</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassifiedWrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, C c, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassifiedWrapper</span></span></span><span class="hljs-class">&lt;ValueToType&lt;C, c&gt;, T&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ClassifiedWrapper(T&amp;&amp; fn) : T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(fn)) {}; ClassifiedWrapper() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ClassifiedWrapper() {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::result_of&lt;T(Args...)&gt;::<span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueToType&lt;C, c&gt;&amp;&amp;, Args&amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args) ...); }; };</code> </pre><br></div></div><br>  The <code>ValueToType</code> class serves one purpose - to set the type depending on the value of the template parameter.  The <code>ClassifiedWrapper</code> class is another wrapper over a ‚Äúcallable object‚Äù.  Its goal is to inherit from an object that has the operator <code>operator()</code> defined, and delegate the call, but with an additional parameter that introduces ‚Äúuniqueness‚Äù.  I.e: <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: test() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"test::fn1!!! "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"test::fn2!!! "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"test::fn3!!! "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">3</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _tmain(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, _TCHAR* argv[]) { test t; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _func2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;test::fn2, &amp;t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_2); ClassifiedWrapper&lt;ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(_func2)&gt; cw1(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(_func2)); ClassifiedWrapper&lt;ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(_func2)&gt; cw2(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(_func2)); cw1(ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  cw2(ValueToType&lt;int, 1&gt;(), 3, 4); //  cw1(ValueToType&lt;int, 0&gt;(), 1); //   cw2(ValueToType&lt;short, 1&gt;(), 3, 4); //   }</span></span></code> </pre><br></div></div><br>  The function used is the same, but we made two of its wrappers different with an additional parameter. <br><blockquote>  <i>- And what to do with this good?</i> </blockquote><br>  As a result, we have a class that allows you to wrap any function and make it unique.  Remember the original problem, how did this option start?  Now you can apply the same focus with multiple inheritance, but inherit from <code>CalssifiedWrapper</code> . <br><div class="spoiler">  <b class="spoiler_title">We first declare the stock:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dissembler</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Next, we will make a partial specialization, which simultaneously starts the recursion of the expansion of the parameter package.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, C c, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dissembler</span></span></span><span class="hljs-class">&lt;ValueToType&lt;C, c&gt;, Func, T ...&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ClassifiedWrapper&lt;ValueToType&lt;C, c&gt;, Func&gt;, <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Dissembler&lt;T ...&gt; <span class="hljs-comment"><span class="hljs-comment">//   ,  Dissembler&lt;T ...&gt;     ValueToType&lt;C, c&gt;  Func   T ...,     .   ,    () { protected: using ClassifiedWrapper&lt;ValueToType&lt;C, c&gt;, Func&gt;::operator(); using Dissembler&lt;T ...&gt;::operator(); public: Dissembler(ValueToType&lt;C, c&gt;&amp;&amp; vt, Func&amp;&amp; func, T&amp;&amp; ... t) : ClassifiedWrapper&lt;ValueToType&lt;C, c&gt;, Func&gt;(std::forward&lt;Func&gt;(func)), Dissembler&lt;T ...&gt;(std::forward&lt;T&gt;(t) ...) {}; //       Dissembler() = delete; virtual ~Dissembler() {}; //  ,      . template &lt;typename Cmd, Cmd cmd, typename ... Args&gt; std::result_of&lt;Func(Args...)&gt;::type call(Args&amp;&amp; ... args) { //      ,   ClassifiedWrapper'. //   ,        return this-&gt;operator()(ValueToType&lt;Cmd, cmd&gt;(), std::forward&lt;Args&gt;(args)...); }; };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Well, it remains only to make the recursion stop</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, C c, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dissembler</span></span></span><span class="hljs-class">&lt;ValueToType&lt;C, c&gt;, Func&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ClassifiedWrapper&lt;ValueToType&lt;C, c&gt;, Func&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Dissembler(ValueToType&lt;C, c&gt;&amp;&amp;, Func&amp;&amp; func) : ClassifiedWrapper&lt;ValueToType&lt;C, c&gt;, Func&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Func&gt;(func)) {}; Dissembler() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Dissembler() {}; };</code> </pre><br></div></div><br><blockquote>  <i>- You'll break your eyes.</i>  <i>And on the fingers and clear understand you can?</i> </blockquote><br>  The idea at the core is simple - multiple inheritance.  But as soon as we encounter the previously mentioned problems (two identical classes in the chain of inheritance or rhomboid inheritance), then everything stops working.  To do this, we start a class ( <code>ClassifiedWrapper</code> ), which can, as it were, ‚Äúattribute a unique label‚Äù (in fact, it does not attribute anything, I put it so beautifully) to any function.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, he himself </font></font><code>ClassifiedWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is naturally unique (again, it is clear that with different template parameters). </font><font style="vertical-align: inherit;">Next, we simply create a ‚Äústatic list‚Äù of such unique functions wrapped in </font></font><code>ClassifiedWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and inherit from all of them. </font><font style="vertical-align: inherit;">Fuh, easier, probably can not explain. </font><font style="vertical-align: inherit;">In general, the focus I applied with the Variadic Template, many of which are described. </font><font style="vertical-align: inherit;">In particular on </font></font><a href="http://habrahabr.ru/post/101430/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-And why is there no method in the closure of recursion </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because it makes no sense to make a garden around one single function. </font><font style="vertical-align: inherit;">That is, if someone wants to use </font></font><code>Dissembler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not for a variety of functions, but for one, then this idea does not make sense. </font><font style="vertical-align: inherit;">Here's how to use all this household:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _tmain(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, _TCHAR* argv[]) { test t; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _func2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;test::fn2, &amp;t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_2); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _func3 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;test::fn3, &amp;t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_2); Dissembler&lt; ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(_func2), ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(_func3) &gt; dis( ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(_func2), ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(_func3) ); dis.call&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); dis.call&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); getchar(); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I deliberately pointed out two different types of "identifier" of functions for the demonstration - </font></font><code>ValueToType&lt;int, 0&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ValueToType&lt;char, 'a'&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the real problem, instead of the ‚Äúincomprehensible‚Äù int and method numbers, it is much clearer to use enumerations with intelligible names of elements. Everything works quite clearly - we specify the </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type of the identifier and its value by the </font><font style="vertical-align: inherit;">parameters of the template function </font><font style="vertical-align: inherit;">, and we pass the parameters. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In comparison with the previous version, it was possible to ensure that an error in the number of parameters or in the key value leads to compile-time errors. So, for the ultimate goal, when the number of classes is known in advance and does not change during program execution, the problem is solved.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the inexperienced eye, as well as the person who dislikes the templates, will be shocked to see the generated compilation error (in case of incorrectly specified parameters). </font><font style="vertical-align: inherit;">But this ensures that the error will attract attention and it will not happen at run-time, and this, I think, is worth the work done.</font></font><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-And how will yours look like in the end </font></font><code>IDevManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Almost the same as in option 3, but with small differences. </font></font><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Dissembler&lt; ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;, ValueToType&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; &gt; SuperWrapper; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDeviceManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;SuperWrapper&gt; m_wrapperPtr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDeviceManager() {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> command_id, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-function"><span class="hljs-function">ResType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_wrapperPtr-&gt;call&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, command_id&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DevManager_v4</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeviceManager { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;test&gt; m_test_ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    m_test_ptr.reset(new test); std::function&lt;int(int, int)&gt; _func2 = std::bind(&amp;test::fn2, m_test_ptr.get(), std::placeholders::_1, std::placeholders::_2); std::function&lt;int(int, int)&gt; _func3 = std::bind(&amp;test::fn3, m_test_ptr.get(), std::placeholders::_1, std::placeholders::_2); m_wrapperPtr.reset(new SuperWrapper( ValueToType&lt;int, 0&gt;(), std::move(_func2), ValueToType&lt;int, 1&gt;(), std::move(_func3) )); } }; int _tmain(int argc, _TCHAR* argv[]) { DevManager_v4 v4; v4.initialize(); v4.callMethod&lt;1, int&gt;(0, 1); v4.callMethod&lt;0, int&gt;(10, 31); getchar(); }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitions </font></font><code>SuperWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for each system its own), you have to put in a separate header file. </font><font style="vertical-align: inherit;">And to separate each definition </font></font><code>#ifdef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"s, so that the" correct "is connected in the necessary project </font></font><code>SuperWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is for this reason that I put a question mark when writing option 4. Final?</font></font></div><p>Source: <a href="https://habr.com/ru/post/231021/">https://habr.com/ru/post/231021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231011/index.html">Remote control and power device</a></li>
<li><a href="../231013/index.html">Summary of the preparation of pitch-performance</a></li>
<li><a href="../231015/index.html">Popularization of information security through cartoons</a></li>
<li><a href="../231017/index.html">We study the algorithm of regular expressions in Ruby</a></li>
<li><a href="../231019/index.html">IM + team released protected messenger</a></li>
<li><a href="../231023/index.html">Modernization of mirrors in the hallway</a></li>
<li><a href="../231025/index.html">Camera Review Samsung Galaxy K Zoom</a></li>
<li><a href="../231027/index.html">Robots are engaged in car parking at Dusseldorf Airport</a></li>
<li><a href="../231029/index.html">The Ministry of Finance decided not to lower postal limits to 150 euros</a></li>
<li><a href="../231033/index.html">PostgreSQL 9.4 beta2 released. All active branches have been updated.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>