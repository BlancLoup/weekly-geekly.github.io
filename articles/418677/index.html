<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 6. Other RTOS services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we discussed the functionality of the kernel in terms of tasks performed and the interactions between them. In this article we w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 6. Other RTOS services</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  In <a href="https://habr.com/post/415429/">previous articles,</a> we discussed the functionality of the kernel in terms of tasks performed and the interactions between them.  In this article we will look at what else the kernel can do, which is largely manifested in a number of other available API calls.  We will also answer the question, what turns the kernel into an operating system? <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Task Management </h2><br>  In addition to task scheduling and interaction between them, the RTOS will include functionality (API calls) for managing tasks in various ways.  Consider some of the features. <br><br>  <b>Creating and deleting tasks</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In a ‚Äúdynamic‚Äù RTOS, there are function calls that allow you to create tasks (and other RTOS objects) when they are required.  Such calls include a wide range of parameters that define a task, such as an entry point, stack size, and priority.  The corresponding API delete task call allows you to release resources after the task is completed. <br><br>  In the ‚Äústatic‚Äù RTOS, the task defining parameters are configured in a kind of configuration file during the build. <br><br>  <b>Suspending and Resuming a Task</b> <br><br>  As we have seen, most RTOSs have the concept of a ‚Äúsuspended‚Äù task state.  This can be achieved in various ways.  One of them is an explicit call to the Suspend Task API function.  It can be caused by itself or another task.  The corresponding ‚ÄúResume Task‚Äù call allows the task to be queued for planning again. <br><br>  <b>Sleep status</b> <br><br>  For a real-time system, time control is an important requirement and can take various forms.  A simple view is the ability of the task to ‚Äúfall asleep‚Äù, that is, the task is suspended for a certain period of time.  When time runs out, the task ‚Äúwakes up‚Äù and is again queued for planning.  An API call will usually be available for this purpose.  Of course, this functionality depends on the availability of the timer. <br><br>  <b>Release</b> <br><br>  When using the Round Robin scheduler (task), the task may refuse to control the processor for the next task in the chain.  For this, the task release API function will be available.  The task is not suspended, it will be available for planning when it is its turn.  When using the Time slice scheduler, a situation is possible when a task can release part of its time interval if it does not have important work to be performed immediately.  The release of the task has no logical significance when running the schedulers Run to completion ("completion to completion") or Priority ("priority planning"). <br><br>  <b>Completing the task</b> <br><br>  In the previous article, we found out that in addition to the states ‚ÄúReady‚Äù (‚ÄúReady to continue‚Äù) or ‚ÄúSuspended‚Äù (RTOS), the RTOS can also support other task states.  The task can be ‚ÄúFinished‚Äù, which means that its main function just came out: no special API call is required.  The task may be ‚ÄúTerminated‚Äù, which means that it is not available for planning and must be reset in order to become available for launch again, see ‚ÄúResetting the Task‚Äù below.  This requires a special API call.  The availability of these additional task states, the terminology used, and their precise definitions will differ depending on the RTOS. <br><br>  <b>Task reset</b> <br><br>  Many RTOSs offer a call to the Task Reset API function, which allows you to return the task to its original state.  It may be in a suspended state and require the ‚ÄúResume Task‚Äù function to be queued for scheduling. <br><br>  <b>Priority tasks, etc.</b> <br><br>  In a ‚Äúdynamic‚Äù RTOS, API calls can be accessed to configure several task parameters at run time.  Examples include the priority and duration of the time interval. <br><br><h2>  System Information </h2><br>  The RTOS will have a series of API calls to provide the system information to the task, including: <br>  <b>Information about the tasks</b> .  How many tasks in the system, their configurations and current statuses. <br>  <b>Information about other kernel objects.</b>  How many objects of each type are in the system, their configurations and information about the current state.  For example: <br><br><ul><li>  What is the current capacity of the queue? Can I add more messages? </li><li>  How many tasks are suspended on a specific mailbox? </li></ul>  <b>Version Information RTOS</b> .  An API call can provide similar data. <br><br><h2>  Memory allocation </h2><br>  In many applications, it is important that the program can dynamically capture some memory when it is required, and free it when it is no longer needed.  The same happens in the embedded software.  However, conventional approaches are prone to problems that are unlikely or inconvenient in desktop applications, but for an embedded system they can be catastrophic.  However, there are ways to embed such services, even in a static RTOS. <br><br><h2>  Problems with malloc () and free () functions </h2><br>  In a C desktop program, a function can call <b>malloc ()</b> , indicating how much memory is required, and get a pointer back to the storage area.  Using memory, it can be freed by calling <b>free ()</b> .  Memory is allocated from an area called "heap."  The problem with this approach is that with an uncoordinated sequence of calls to these functions, the ‚Äúheap‚Äù area can easily become fragmented, and then the memory allocation will fail even if enough memory is available, because  adjacent areas are not large enough.  Some systems (for example, Java and Visual Basic) use complex ‚Äúgarbage collection‚Äù schemes to implement defragmentation.  The problem is that these schemes can lead to significant unpredictable delays in execution time and the need to use indirect pointers (which does not work in C). <br><br>  If <b>malloc ()</b> and <b>free ()</b> were implemented in a reentrant manner (usually not) and used by RTOS tasks, fragmentation will occur very quickly, and a system failure will be almost inevitable.  In C ++, there are <b>new</b> and <b>delete</b> operators that generally perform the same functions as malloc () and free ().  They are subject to the same limitations and problems. <br><br><h2>  Memory sections </h2><br>  To provide a real-time system with dynamically available memory, you can use a block approach to memory management.  Such blocks are usually called ‚Äúpartitions‚Äù (partitions);  partitions can be allocated from the "partition pool". <br><br>  A partition pool contains a certain number of blocks, each of which has the same size.  The number and size of blocks in a partition are determined when creating a pool of partitions.  This may be dynamic if the system itself allows it, or statically during assembly.  As a rule, an application can include several pools of sections offering blocks of different sizes. <br><br>  If the task needs memory, it calls the API, requesting a block from a specific pool.  If this call is successful, the task will receive a pointer to the selected block.  If the call fails, because  there are no partitions in the specified pool; the task may receive an error response.  Alternatively, a task can be blocked (suspended) until another task releases a block in a section. <br><br>  Usually, a task simply transfers a pointer to a block of memory to any code that the block uses.  This causes a problem when the block is no longer needed.  If the code has only a pointer to the block, how can it tell the RTOS via an API call, from which partition pool does it want to free the memory?  The answer is that most RTOSs support additional data in a dedicated block (usually a negative offset from the pointer), which provide the required information.  Thus, to call an API to release a block, only its address is required. <br><br>  The next article will have more information about the sections of memory. <br><br><h2>  Time </h2><br>  The functionality associated with the use and control of time is likely to be available in a real-time OS.  Opportunities will vary depending on the RTOS, but we will look publicly available.  In any case, a real-time timer is an essential element for the operation of any of these services. <br><br>  <b>System time</b> <br><br>  Simple system time, or ‚Äúclock timer,‚Äù is almost always available.  It is simply a counter (typically 32 bits), which is incremented using a real-time interrupt service routine and can be set and read through API calls. <br><br>  <b>Service call timeouts</b> <br><br>  Usually, the RTOS allows blocking API calls, that is, the calling task pauses (blocks) until the requested service is provided.  Normally, this blocking is uncertain, but some RTOS offer a timeout during which the call returns when the waiting time expires if the service continues to be unavailable.  API call timeouts are not supported by all RTOS. <br><br>  <b>Sleep status</b> <br><br>  Usually, tasks have the ability to suspend themselves for a fixed period of time.  This was discussed earlier in the ‚ÄúTask Management‚Äù section. <br><br>  <b>Software timers</b> <br><br>  In order for software tasks to perform timing functions, most RTOS offer timer objects.  These are independent timers updated by the real-time timer interrupt handler that can be controlled by API calls.  Such calls set up, monitor and track the timer.  As a rule, they can be set for one-time operation or automatic restart.  An expiration routine is also usually supported, a function that is executed every time the timer ends a cycle.  The next article will contain more information about software timers and a description of their implementation. <br><br><h2>  Interrupts, drivers and I / O </h2><br>  The extent to which RTOS is associated with interrupts and I / O is very different.  Similarly, some RTOSs have a very clear structure for device drivers, which can add problems when choosing a particular product. <br><br>  <b>Interruptions</b> <br><br>  Interrupts are a problem for RTOS for two reasons. <br><br><ul><li>  Without any precautions, the interrupt handler (ISR) will ‚Äústeal‚Äù processor time, thereby disrupting real-time RTOS behavior. </li><li>  If an ISR makes API calls that affect task scheduling, this should be monitored, and the RTOS should be able to run its scheduling algorithm. </li></ul> An example of such an API call is a task wake up procedure with a higher priority than the one that was started when the interrupt occurred. <br><br>  Some RTOSs fully control all interrupts.  A series of API calls are available, allowing you to ‚Äúregister‚Äù ISR programs.  This approach allows the scheduler to determine exactly when interrupts are enabled, and facilitates the use of most API calls from an ISR. <br><br>  For example, Nucleus RTOS implements the concept of ‚Äúlow priority‚Äù and ‚Äúhigh priority‚Äù interrupt handlers, which provides reliable interrupt handling without unnecessary overhead (i.e., increasing the interrupt latency). <br><br>  Other RTOSs can use an automatic ‚Äúhands off‚Äù mode for interrupts, which gives developers more options to ensure that interrupt handlers work correctly.  As a rule, additional prefix (prologue) and suffix (epilogue) ISR are provided to protect the API calls made in it. <br>  Nucleus SE uses lightweight interrupt handling tools, which will be described in the next article. <br><br>  <b>Drivers</b> <br><br>  Most RTOSs determine the structure of a device driver.  Details may differ depending on the RTOS, but the driver usually consists of two interacting components: embedded code (API calls) and ISR.  Normally, other API calls will be available for managing and registering drivers. <br><br>  <b>Input Output</b> <br><br>  Currently, most RTOSs on the market do not care about higher level I / O, but some of them define I / O flow, which basically establishes the connection between the corresponding device drivers and standard C language functions, such as printf (). <br>  Historically, RTOSs often supported a ‚Äúconsole‚Äù, a user interface to the RTOS, via a serial channel.  It was mainly used for diagnostics and debugging.  The use of modern debuggers that support debugging of applications with RTOS eliminates the need for such objects. <br><br><h2>  Diagnostics </h2><br>  Usually, an RTOS requires maximum performance with a minimum amount of memory.  Therefore, integrity checking is not a top priority.  With the help of modern debugging technologies that take into account the characteristics of the RTOS, most of the checks can be performed outside the RTOS itself. <br><br><h2>  Check API Call Parameters </h2><br>  API calls can have many complex parameters.  This can lead to errors.  Many RTOSs provide verification of runtime parameters with the return of an error code in case of an incorrect parameter.  Since this requires additional code, and the checks themselves have a negative impact on performance, it is better to perform parameter checks during assembly or configuration. <br><br><h2>  Stack check </h2><br>  For most types of scheduler (except Run to Completion), each task has its own stack, the size of which is determined individually.  In some RTOSs, the core has a separate stack; in others, the task stack is ‚Äúborrowed‚Äù during an API call.  Obviously, the integrity of the stack is important to the overall reliability of the system.  Therefore, RTOSs often offer tools to check the integrity of stacks at run time.  There are several options: <br><br><ul><li>  An API call that returns the amount of free stack space for the current or specified task. </li><li>  Limiting stack options.  They are assigned a unique (usually odd and non-zero) value, which is periodically checked for rewriting. </li></ul><br><br><h2>  Application Diagnostics </h2><br>  Despite the fact that this function is not directly supported in the RTOS, the application task can be allocated for checking the integrity of the entire system.  Such a task may be responsible for resetting the watchdog timer.  A task can take periodic input data (for example, signal parameters) from each critical task.  The watchdog timer reset (which will not allow the system to reboot) will be performed only after the data from all tasks arrive. <br><br><h2>  Non-core services </h2><br>  RTOS is more than just the core we have focused on so far.  By this, the desktop operating system is significantly different from the embedded RTOS.  Typically, in a desktop OS, all additional components are bundled or can be installed (all desktops have a graphical user interface, and only a few of them do not have access to the network).  The desktop PC has no real resource limitations: there is always free memory, hard disk space, and unused CPU resources.  In the world of embedded systems with limited resources, additional components such as video cards, network components and file systems may be necessary, but they must be switchable and scalable to minimize the memory footprint. <br><br>  <b>Networking opportunities</b> <br><br>  Most embedded systems somehow relate to networks.  Thus, it is expected that there is a significant interest in networking solutions for embedded systems, thanks to which there are a large number of products on the market. <br><br>  <b>TCP / IP</b> is a standard protocol, widely used, and an obvious choice for many applications.  Typically, TCP / IP is used for Ethernet (IEEE802.3), which on average provides a speed of 10 MB / s.  Today, 100 MB / s are quite common, and on the approach of 1 Gb / s.  In addition, TCP / IP can be used for other protocols.  For example, PPP (Point-to-Point Protocol) is a TCP / IP implementation for serial data transmission that has been adapted for broadband Internet connections. <br><br>  Until recently, the v4 version of the IP protocol (IPv4) was used.  However, it becomes obsolete, as free addresses end.  The solution is IPv6, which significantly increases the number of possible addresses and provides more efficient maintenance and security tools.  IPv6 is widely available and used in the equipment of many countries, as well as military systems all over the world. <br>  An alternative is the User Datagram Protocol (User Datagram Protocol, UDP).  This protocol is used for maximum performance.  UDP does not provide the same reliability and consistency as TCP, but is lightweight and highly efficient. <br><br>  <b>USB</b> is the Universal Serial Bus, widely used in devices for connecting to desktop computers.  It provides a very easy-to-use interface like ‚Äúplug &amp; play‚Äù, which hides behind itself rather complicated software.  An embedded device that must be connected to a PC must be implemented as a USB function, which requires a specific set of software components.  If a device needs to control other devices connected via USB (like a normal PC), it needs a set of host-type software. <br><br>  <b>IEEE1394</b> , another serial interface standard that is used to quickly transfer large amounts of data between devices (for example, to transmit video data), is also known as FireWire and i.Link. <br><br>  Wireless protocols - The convenience and prevalence of various wireless technologies among consumers has led to a high demand for wireless capabilities in embedded devices.  Wi-Fi (a set of IEEE802.11 standards) provides a complete set of network capabilities, allowing you to implement both peer-to-peer and infrastructure topologies at a sufficient distance.  Interest in data security in such networks is growing, which means that this should affect the software.  Other radio technologies, such as Bluetooth and ZigBee, provide short-range point-to-point wireless. <br><br>  <b>Protocols check</b> <br><br>  Since networking capabilities are in high demand, there are many vendors offering their solutions.  Customers face the challenge of checking the quality of available products.  Unlike the RTOS core, full verification of the functionality and performance of the protocol stack is not an easy task.  Fortunately, toolkits are available for checking protocols (albeit at a considerable price), and a potential buyer can find out from the supplier what kit they used when checking. <br><br>  <b>Graphics</b> <br><br>  Graphical user interface is becoming increasingly common among embedded devices.  It can be a very simple, small monochromatic LCD (as on older phones, MP3 players, alarms, etc.).  On the other hand, a digital television receiver may have its own high-resolution HDTV screen.  Such a screen requires software support, which is fully integrated into the core RTOS. <br>  Since the screen usually has some kind of input device, support for such devices is often included in the graphics package.  Such a package can support pointing devices (for example, a mouse), touchscreens, keypads, and full-fledged keyboards. <br>  Graphics can be used in various ways.  It can simply provide information output (for example, as an electronic scoreboard).  Or, the display may be part of a graphical user interface along with menus, windows, icons, and similar elements.  In any case, a fairly specific set of software is required, and the graphics package that comes with the RTOS should provide the necessary flexibility without significantly increasing the memory footprint. <br><br>  <b>File systems</b> <br><br>  When an embedded application has to store and process significant amounts of data, it is obvious that it makes sense to organize this data into some kind of file system.  The data can be in RAM, in the built-in flash memory, on a flash drive, a regular hard disk or on an optical disk (CD-ROM or DVD-ROM).  Again, this capability should have fully integrated software support in the RTOS.  The file system must be carefully designed to meet the reentrancy requirements of the multitasking system. <br><br>  Compliance with standards is especially important for file systems.  For example, using an MS-DOS compatible disk format allows developers to use a well-proven architecture and offers full data exchange with desktop systems. </div><p>Source: <a href="https://habr.com/ru/post/418677/">https://habr.com/ru/post/418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418665/index.html">Adaptation of the project MR under HoloLens</a></li>
<li><a href="../418667/index.html">Benchmarking HDFS 3 with HDFS 2</a></li>
<li><a href="../418669/index.html">Security Week 28: NetSpectre, attack on third-party channels through a network</a></li>
<li><a href="../418673/index.html">Why the ERP market is growing: statistics and trends</a></li>
<li><a href="../418675/index.html">How I went to Droidcon Berlin</a></li>
<li><a href="../418679/index.html">Writing a component with ‚Äúmaterial‚Äù buttons for Svelte</a></li>
<li><a href="../418681/index.html">On Friendship Day - 50% discount on all IDE JetBrains for our friends</a></li>
<li><a href="../418683/index.html">Creating an emulator arcade machine. Part 2</a></li>
<li><a href="../418685/index.html">Procedural level generation</a></li>
<li><a href="../418687/index.html">The 3.5 "revolution: details of a small diskette boom with wavepave music</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>