<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dependent Types - The Future of Programming Languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Despite the outlandishness and some distraction of the topic under consideration today - we hope that she will be able to diversify your wee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dependent Types - The Future of Programming Languages</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Despite the outlandishness and some distraction of the topic under consideration today - we hope that she will be able to diversify your weekend.  At the end of the post we put three links from the author, allowing you to get acquainted with dependent typing in Idris, F * and JavaScript <br><a name="habracut"></a><br>  Sometimes it seems as if programming languages ‚Äã‚Äãhave hardly changed since the 60s.  When they talk to me about it, I often remember how many cool tools and opportunities we now have, and how they simplify life.  Offhand: it‚Äôs integrated debuggers, unit tests, static analyzers, cool IDEs, typed arrays and much more.  The development of languages ‚Äã‚Äãis a long and progressive process, and there are no such ‚Äúsilver bullets‚Äù with the appearance of which the development of languages ‚Äã‚Äãwould change once and for all. <br><br>  Today I want to tell you about one of the final stages in this ongoing process.  The technology, which will be discussed, is being actively explored, but everything indicates that it will soon take root in mainstream languages.  And our story begins with one of the most fundamental concepts in computer science: with <b>types</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  World of types </h2><br>  Typification is one of those things that are so inseparable from our thinking that we hardly even think about the concept of types as such?  Why is 1 - this is <code>int</code> , but if you only put this value in quotes - and it turns into a <code>string</code> ?  What is ‚Äútype‚Äù, in essence?  As is often the case in programming, the answer depends on the wording of the question. <br><br>  Types are diverse.  In some type systems, there are very clear boundaries between types and values.  So, 3, 2 and 1 are values ‚Äã‚Äãof type <code>integer</code> , but <code>integer</code> is not a value.  This construct is ‚Äúembedded‚Äù in the language and is fundamentally different from the meaning.  But, in fact, such a distinction is not necessary and can only limit us. <br><br>  If you release the types and turn them into another category of values, a number of amazing possibilities open up.  Values ‚Äã‚Äãcan be stored, converted and passed to functions.  Thus, it would be possible to make a function that takes a type as a parameter, creating generic functions: those that can work with many types without overloads.  You can have an array of values ‚Äã‚Äãof a given type, rather than doing strange pointer arithmetic and type casting, as you have to do in C. You can also collect new types as the program runs and provide features such as, for example, JSON automatic deserialization.  But, even if you interpret types as values, all the same with types you will not do all that you can do with values.  So, using user instances, you can, for example, compare their names, check their age or identifier, etc. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  However, if you tried to do the same with the <code>User</code> type, you could only compare type names and, possibly, property names.  Since this is a type, not an instance, you cannot check the values ‚Äã‚Äãof its properties. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  How cool would it be if we had a function that could only get a non-empty list of users?  Or a function that would accept an email address only if it was recorded in the correct format?  For these purposes, you would need the types of "non-empty array" or "email address".  In this case we are talking about a type that depends on the value, i.e.  about <b>dependent type</b> .  In mainstream languages, this is not possible. <br><br>  For the types to be used, the compiler must check them.  If you claim that the variable contains an integer, then it would be better if it did not have a <code>string</code> , otherwise the compiler will swear.  In principle, this is good, because it does not allow us to sabotage.  It is very simple to check types: if the function returns an <code>integer</code> , and we are trying to return <code>"Marin"</code> in it, then this is an error. <br><br>  However, with dependent types everything is more complicated.  The problem is when exactly the compiler checks the types.  How can he make sure that there are three values ‚Äã‚Äãin the array, if the program is not even running yet?  How to make sure that an integer is greater than 3 if it is not even assigned yet?  To do this, there is <i>magic</i> ... or, in other words, <i>mathematics</i> .  If you can mathematically prove that the set of numbers is always greater than 3, then the compiler can verify this. <br><br><h2>  Math in the studio! </h2><br>  <b>Mathematical induction</b> is used to formulate evidence.  Induction allows one to unconditionally confirm the truth of some statement.  For example, we want to prove that the following mathematical formula holds for any positive number: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  There are an infinite number of possible x, so it would take us a very long time to check all the numbers manually.  Fortunately, this is not necessary.  We just need to prove two things: <br><br><ol><li>  This statement is respected for the first number.  (Usually it is 0 or 1) </li><li>  If this statement is true for the number <code>n</code> , then it will be observed for the next number <code>n + 1</code> </li></ol><br>  Since the statement is observed for both the first number and all the following numbers, we know that it is true for all possible numbers. <br><br>  Proving this is not difficult: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Now we also have to prove that the statement holds for all other numbers.  To do this, we assume that it works for some number n, and then we make sure that it also works for n + 1. <br><br>  Assuming the following expression is true: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  Check it for <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Thus, it is possible to replace <code>"(1 + 2 + 3 + ... + n)"</code> above equation: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  and simplify to <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Since both parts of the expression are equal, we are convinced that this statement is true.  This is one of the ways in which you can check the truth of statements without manually calculating each case, and dependent types work on the basis of this principle.  You write a mathematical statement to make sure that the thesis about the type is correct. <br><br>  The beauty of this approach lies in the fact that any mathematical proof can be made in the form of a computer program - and this is exactly what we need! <br><br><h2>  Back to programming </h2><br>  So, we have established that some things can be proved first, and then proceed to specific values.  To do this in a programming language, you need a way to express these statements in code that will be written to the type system itself, that is, the type system needs to be improved. <br><br>  Consider an example.  Here we have the append function that takes two arrays and combines them.  Typically, the signature of such a function would look something like this: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  However, just by looking at the signature, we cannot be sure of the correct implementation.  The fact that the function returns an array does not mean that it has done something.  One way to check the result is to make sure that the length of the resulting array is equal to the sum of the lengths of the parameter arrays. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  But why check it at runtime if you can create a constraint that will be checked at program compilation time: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  We declare that <code>append</code> is a function that takes two <code>Array</code> arguments and returns a new <code>Array</code> argument, which we called <code>newArray</code> .  Only this time we add a clause that the length of the new array should be equal to the sum of the lengths of all the arguments of the function.  The statement we had above at runtime is converted to a type at compile time. <br><br>  The above code refers to the world of types, not values, that is, the <code>==</code> sign indicates a comparison of the return type of <code>length</code> rather than its value.  For this mechanism to work, the return type length must give us any information about the actual number. <br><br>  To ensure the operation of such a mechanism, you need to make sure that each number is of a separate type.  Type One can contain only one value: 1. The same applies to Two, Three, and all other numbers.  Naturally, such work is very tiring, but it is for this kind of work that we have programming.  You can write a compiler that will do it for us. <br><br>  By doing this, you can create separate types for arrays containing 1, 2, 3, and a different number of elements.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> , etc. <br><br>  Thus, you can define the length function, which will accept one of the above types of arrays and have a dependent return type of <code>One</code> for <code>ArrayOfOne</code> , <code>Two</code> for <code>ArrayOfTwo</code> , etc.  for every number. <br><br>  Now that we have a separate type for any particular array length, we can be sure (at compile time) that both arrays are of equal length.  To do this, compare their types.  And since types are the same values ‚Äã‚Äãas any others, you can assign operations to them.  You can define the addition of two specific types by specifying that the sum of <code>ArrayOfOne</code> and <code>ArrayOfTwo</code> is equal to <code>ArrayOfThree</code> . <br><br>  That's all the information the compiler needs to make sure that the code you write is correct. <br><br>  Suppose we want to create a variable of type <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  The compiler can determine that [1] has only one value, so you can assign the type <code>ArrayOfOne</code> .  It can also assign <code>ArrayOfTwo</code> to [2, 3]. <br><br>  The compiler knows that the result type must be equal to the sum of the types of the first and second argument.  He also knows that ArrayOfOne + ArrayOfTwo is equal to ArrayOfThree, that is, he knows that the entire expression on the right side of the identity is of type ArrayOfThree.  It coincides with the expression on the left side, and the compiler is satisfied. <br><br>  If we wrote the following: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  then the compiler would be completely unhappy because it would know that the type is incorrect. <br><br><h2>  Dependent typing is very cool. </h2><br>  In this case, a huge number of bugs is simply impossible to prevent.  With dependent typing, you can avoid errors by one, calls to nonexistent array indexes, null pointer exceptions, infinite loops, and invalid code. <br><br>  With the help of dependent types, you can express almost anything.  The factorial function will accept only natural numbers, the <code>login</code> function will not accept empty strings, the <code>removeLast</code> function will only accept non-empty arrays.  Moreover, all this is checked before you run the program. <br><br>  The problem with runtime checks is that they fail if the program is already running.  This is normal if the program is run only by you, but not by the user.  Dependent types allow you to bring such checks to the level of types, so this type of failure during the execution of the program becomes impossible. <br><br>  I think dependent typing is the future of mainstream programming languages, and I can't wait to wait for it! <br><br>  ‚Üí <a href="https://www.idris-lang.org/">Idris</a> <br><br>  ‚Üí <a href="https://www.fstar-lang.org/tutorial/">F *</a> <br><br>  ‚Üí <a href="http://goto.ucsd.edu/~ravi/research/oopsla12-djs.pdf">Adding dependent types to javascript</a> </div><p>Source: <a href="https://habr.com/ru/post/432416/">https://habr.com/ru/post/432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432406/index.html">DEV Labs 2018. Online MAP for C ++ developers. December 15</a></li>
<li><a href="../432408/index.html">Fintech-digest: preparation of switching off small banks from Visa and Mastercard, a pension calculator and not only</a></li>
<li><a href="../432410/index.html">DDD-style Entities with Entity Framework Core</a></li>
<li><a href="../432412/index.html">Highload ++: How to help the ERP system cope with 500,000 requests per second</a></li>
<li><a href="../432414/index.html">Old secrets of quick debugging: source code animation</a></li>
<li><a href="../432418/index.html">Parse lambda expressions in java</a></li>
<li><a href="../432420/index.html">Introducing Git Merge and Git Rebase: Why and When to Use Them</a></li>
<li><a href="../432422/index.html">Offline mode on iOS and features of its implementation on Realm</a></li>
<li><a href="../432424/index.html">HyperFlex Certified Infrastructure for SAP HANA</a></li>
<li><a href="../432426/index.html">Debugging a bug that does not play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>