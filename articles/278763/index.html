<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KTV. New JSON</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my development I had to run through several stages in several directions: Java ‚Üí Objective C ‚Üí Swift, Web ‚Üí Enterprise ‚Üí Mobile, XML ‚Üí JSON. I walk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KTV. New JSON</h1><div class="post__text post__text-html js-mediator-article">  In my development I had to run through several stages in several directions: Java ‚Üí Objective C ‚Üí Swift, Web ‚Üí Enterprise ‚Üí Mobile, XML ‚Üí JSON.  I walked this way for more than 15 years, long and attentively lingering at each stage.  Need to go further.  For mobile applications, you can think of something (probably, so far you don‚Äôt want to), languages ‚Äã‚Äãare generally a dime a dozen, nothing more interesting than JSON has been invented.  Why change it? <br><br>  Then I will tell you why I do not really like JSON for some applications and how, in my opinion, it can be improved to make it a little more convenient. <br><br>  I should immediately note that I do not consider KTV as a replacement for JSON.  And in no case do I consider it for use in JavaScript.  It will be uncomfortable and wrong.  On the other hand, the situation when the system of describing objects of JavaScript is used in other languages ‚Äã‚Äãfor working with typed data is also strange, and I want to correct it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are wondering what was the original reason for creating such a format - you can read <a href="https://habrahabr.ru/post/278787/">about S2</a> and the <a href="https://habrahabr.ru/post/278793/">reasons for creating the KTV format</a> <br><a name="habracut"></a><br><h2>  Pros and cons of JSON </h2><br>  JSON itself is good. <br><br><ul><li>  Plain.  Special thanks for the lack of comments.  If they were left, there would start to push the meta-information (because JSON is very poor) and the notation would quickly turn into a trash. </li><li>  Expressive.  Not like XML, but enough for a wide range of tasks. </li><li>  Much shorter in writing than XML. </li></ul><br>  JSON's diseases grow from the history of creation.  It was necessary for <code>eval(-)</code> in JavaScript to produce an object with which it is convenient to work.  Unfortunately, evals in other languages ‚Äã‚Äãusually work differently (if they are present at all), and the languages ‚Äã‚Äãthemselves are different.  Using this format with non-javascript, its flaws are visible. <br><br><ul><li>  Quotes.  According to the standard (as a standard I take the text from here: <a href="http://www.json.org/">http://www.json.org</a> ) all names should be in quotes.  If we use JSON, for example, to transfer data over the network, then this is overkill. </li><li>  Lack of typing.  More precisely, there are types, but only the string / number / true / false / null.  And objects with arrays.  Everything.  There are no dates, no whole / fractional numbers.  There is no possibility to mark objects with types in order to make the model easier to understand. </li><li>  Lack of standards for recording objects.  This, for example, can lead to arrays with mixed objects inside.  When you have this parsit - it hurts. </li><li>  Missing links.  If you record the hierarchical structure of objects in JSON, then there are regular references to the same object from different places.  JSON does not allow to refer to the first use.  It is necessary either to invent something, or to repeat objects as a whole, which has a bad effect on the size of the structure and on the complexity of parsing. </li></ul><br>  I tried to find a format that would work as JSON (ideally - would be its superset), but at the same time I was able to solve some or all of the problems listed above in a standard way.  Found YAML. <br><br><h2>  Yaml </h2><br>  Yaml is good.  It is almost a superset of JSON, well defined ( <a href="http://www.yaml.org/spec/1.2/spec.html">http://www.yaml.org/spec/1.2/spec.html</a> ), easy to read.  But at the same time: <br><br><ul><li>  nesting of structures is determined by indents.  In the case of the transfer of information, it would be convenient to remove them.  Tab lovers are also not respected, indents are made only with spaces. </li><li>  YAML is overly complex.  A large number of special characters, agreements on the structure make support for YAML'a difficult, parsers - complex (YAML 1.2 has appeared for 7 years already, but, according to news from the site, parsers still support mostly previous versions). </li></ul><br>  In general, YAML "did not go."  In addition to his popular formats, I do not know.  If suddenly you know - write, I will look with pleasure. <br><br>  It's time to introduce what I got. <br><br><h2>  KTV </h2><br>  Key-Type-Value.  I call this format. <br><br>  Let's write a simple object in JSON: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"coolness"</span></span>: <span class="hljs-number"><span class="hljs-number">3.1415</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAProgrammer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  If you rewrite the same on KTV, you get: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">name</span></span>: Alex coolness: <span class="hljs-number"><span class="hljs-number">3.1415</span></span> isAProgrammer: true }</code> </pre> <br>  It would seem that nothing has changed.  But let's take a look: <br><br><ul><li>  quotes cleaned up.  They are now required only if there is a non-trivial string in the key or value.  Normal situations do not require quotes. </li><li>  commas were removed at the end of lines.  They (or semicolons) can be put if we write several definitions in one line.  But in the traditional record they can be omitted. </li></ul><br>  Both the first and second examples are both correct KTV files.  This is very important, since it allows you to stuff standard JSON into the KTV parser, and it will eat it with pleasure.  And you can take advantage of amenities, types for example. <br><br>  Where are the types?  In the above case, types are inferred from values.  ‚ÄúAlex‚Äù is a lowercase literal, so the name type is ‚Äústring‚Äù, the coolness is ‚Äúdouble‚Äù, and isAProgrammer is ‚Äúbool‚Äù.  In addition to these types, there is also ‚Äúnull‚Äù (aka ‚Äúnil‚Äù, hello to colleagues), ‚Äúint‚Äù and ‚Äúcolor‚Äù.  Let's write the same example, but completely indicating the types: <br><br><pre> <code class="hljs cs">{ name(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): <span class="hljs-function"><span class="hljs-function">Alex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coolness</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span></span><span class="hljs-function">): 3.1415 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAProgrammer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span></span><span class="hljs-function">): </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">true</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br>  Nowhere and nested objects / arrays.  With additions: <br><br><ul><li>  Both objects and arrays can have types.  For an array, type is the generic type of each object in the array.  You cannot put two different types (string / number, or different objects) into an array. </li><li>  The type of an array or object may also indicate the class to which this object or array must be cast during parsing.  For example: <br> <code>property(font): {name:..., size:...}</code> <br>  may denote a font object, and <br> <code>property(point): [2, 3]</code> <br>  can be converted to a point object when recognized.  In principle, a point can also be made an object (with x, y perperty), but why?  After all, we already know where there is. </li></ul><br>  There are links, the ability to refer to any other proppeyu.  Something like this: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">property</span></span>: value another: @property }</code> </pre> <br>  This allows you to reduce the recording of some branched objects, or simply set constants, referring to them in other parts of the file.  The first feature is useful in REST if the structure of objects is nontrivial.  The second is in the configuration files. <br><br>  The idea of ‚Äã‚Äãmixins is also borrowed from other languages.  They allow one object (or objects) to be attached to another object.  You can imagine it as inheritance, but inheritance is from the PLO, where behavior is inherited, there are only properties.  So it is better to mix. <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">object</span></span>: { a: ..., b: ...} <span class="hljs-selector-tag"><span class="hljs-selector-tag">object2</span></span>(+<span class="hljs-selector-tag"><span class="hljs-selector-tag">object</span></span>): { <span class="hljs-attribute"><span class="hljs-attribute">c</span></span>: ..., d: ... } }</code> </pre> <br>  In this example, after parsing, object2 will contain both its own properties and the properties of the object.  That is, a, b, c, and d. <br><br><h2>  Comments </h2><br>  I could not resist and organized comments.  They can be set either using // or #.  Both types of comments are lowercase, no block comments. <br><br><blockquote>  With the second type (which is octotorp) there is a slight problem.  The fact is that the color literal is supposed to be set in the standard CSS form, that is, #rrggbbaa, which conflicts with the current version of writing comments.  So, perhaps, in the future, only the C-variant (//) will remain. </blockquote><br><h2>  Work with format </h2><br>  For me, this format, and the parser of this format is needed in two places: <br><br><ul><li>  to store style information in S2 (development of the <a href="http://www.lonelybytes.com/blog-ru/2014/4/15/-">√Öngstr√∂m Style System</a> ) </li><li>  so that you can improve communication between your own Swift servers and applications on it. </li></ul><br>  Therefore, I consider working with the format for Swift.  In principle, the format is quite simple and it should not be difficult to organize its parser in any language. <br><br>  Swift problems now do not allow you to really properly load / serialize objects from / to KTV.  Therefore, the process of working with the format assumes the following: <br><br><ul><li>  Model classes are created.  Like regular classes (including annotated <code>@objc</code> ) or structures.  Each class must implement the <code>KTVGenerated</code> protocol. </li><li>  With the help of the generator, extensions are created to these classes that can load and serialize objects. </li><li>  We use the generated to convert KTV into objects and back (or to / from JSON). </li></ul><br>  A model structure might look like this: <br><br><pre> <code class="hljs cmake">public struct RootObject: KTVGenerated { var <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">String</span></span> //   var stringOrNil:<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>? // optional var int:Int //  var stringArray:[<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>] //  var stringDictionary:[<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>:Int] //   var object:ChildObject? //      private var _privateString:<span class="hljs-keyword"><span class="hljs-keyword">String</span></span> //      private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var _privateSetString:<span class="hljs-keyword"><span class="hljs-keyword">String</span></span> //  ‚Äî  let _constantString:<span class="hljs-keyword"><span class="hljs-keyword">String</span></span> //      }</code> </pre> <br>  It is seen that all the main features are supported: <br><br><ul><li>  Types (they must be written explicitly so that the generator can correctly create class extensions. </li><li>  Collections (arrays and associative arrays). </li><li>  Object hierarchies (links to other model classes) </li><li>  Property that does not participate in serialization (these are constants, private properties and properties with private setters) </li></ul><br>  The history of creating such a parser is a topic for a separate article.  Tasks of simultaneously maintaining structures and classes, ways of specifying attributes without the presence of attributes themselves, using SourceKit instead of reflection for analyzing files, the need for custom mappers (for example, for parsing non-standard dates).  The parser itself is now in the process of active development, and is constantly changing.  But, if there is enough interest - lay out a working draft, discuss options. <br><br><h2>  Benefit from the next data format </h2><br><img src="https://imgs.xkcd.com/comics/standards.png" alt="image"><br>  <a href="https://xkcd.com/927/">https://xkcd.com/927/</a> <br>  JSON is a so-so format for transferring data between applications.  This is the format for describing objects in JavaScript.  And we constantly use it for completely different purposes, cramming both in and out of business. <br><br>  It seems to me that it is time to move on to something more adapted to the tasks performed.  To the new Swift with its strict typing, to the complex data structures that often have to be transferred to the mobile clients from the server.  We need a format whose syntax can be checked in the IDE, during the compilation process and during the parsing.  And, it seems to me that KTV, without changing cardinally the structure, practically without complicating the already known format, adds a few handy little things. <br><br>  I spread the experimental source code with a small description.  There are more interesting techniques for parsing the format on Swift, rather than the parser.  But suddenly it will be interesting to anyone to see: <a href="http://github.com/bealex/KTV">http://github.com/bealex/KTV</a> <br><br>  Most likely, I missed a lot or not.  Maybe someone has a similar experience?  Write in the comments, or e-mail: alex@jdnevnik.com, discuss! <br></div><p>Source: <a href="https://habr.com/ru/post/278763/">https://habr.com/ru/post/278763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278749/index.html">Extortionist KeRanger for OS X: our analysis</a></li>
<li><a href="../278751/index.html">Work with private repositories and other updates of the FlyElephant platform</a></li>
<li><a href="../278755/index.html">Asynchronous parallel execution in PHP</a></li>
<li><a href="../278757/index.html">Windows-way synchronization settings between systems</a></li>
<li><a href="../278759/index.html">The idea of ‚Äã‚Äãan educational game for schoolchildren</a></li>
<li><a href="../278765/index.html">AutoCAD & RTree</a></li>
<li><a href="../278767/index.html">Microsoft announced Linux version of SQL Server</a></li>
<li><a href="../278769/index.html">Extensible Android application code with MVP</a></li>
<li><a href="../278771/index.html">Import substitution successes or entertaining statistics based on the Register of Federal State Information Systems</a></li>
<li><a href="../278773/index.html">Grid implementation for working with large tables. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>