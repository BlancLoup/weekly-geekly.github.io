<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Driver anatomy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Again, back to the traditional area of ‚Äã‚Äãoperating system development (and applications for microcontrollers) - writing drivers. 

 I will try to high...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Driver anatomy</h1><div class="post__text post__text-html js-mediator-article">  Again, back to the traditional area of ‚Äã‚Äãoperating system development (and applications for microcontrollers) - writing drivers. <br><br>  I will try to highlight some general rules and canons in this area.  As always - on the example of the Phantom. <br><br>  A driver is a functional component of an OS that is responsible for relations with a certain subset of computer hardware. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With a light hand of the same Unix, drivers are divided into block and byte-oriented.  In the old days, the classic examples were a disk driver (operations ‚Äî write and read a sector of a disk) and display driver (read and write a character). <br><br>  In modern reality, of course, everything is more complicated.  A driver is a typical instantiated object of a class, and these classes to the fig and more.  In principle, the interface drivers are trying to somehow squeeze in the Procrustean bed model read / write, but this is self-deception.  The network card driver has a method ‚Äúread the MAC address of the card‚Äù (which, of course, can be implemented through <a href="https://habrahabr.ru/post/282415/">properties</a> ), and the USB driver has a whole bundle of USB-specific operations.  Even more fun with graphics drivers is that some bitblt (startx, starty, destx, xsize, ysize, operation) is common. <br><br>  The life cycle of the driver, in general, can be described as: <br><br><ul><li>  Initialization: the driver receives resources (but not access to its hardware) </li><li>  Hardware search: the driver receives from the kernel or finds its own hardware resources </li><li>  Activation - the driver starts working </li><li>  The appearance / disappearance of devices, if appropriate.  See the same USB. </li><li>  Sleeping / waking up the equipment, if appropriate.  In controllers, often unused hardware is turned off to save. </li><li>  Driver deactivation - queuing stops </li><li>  Driver unloading - all kernel resources are released, the driver does not exist. </li></ul><br><br>  (Actually, I wrote a draft open driver interface specification last year ‚Äî see the <a href="https://github.com/dzavalishin/openpod">repository</a> and the <a href="https://github.com/dzavalishin/openpod/blob/master/dox/OpenPOD_0_1.pdf">document</a> .) <br><br>  I know of three models for building a driver: <br><br><ul><li>  Polling </li><li>  Interruptions </li><li>  Threads </li></ul><br><a name="habracut"></a><br><h4>  Driver based on polling (cyclic polling) device </h4><br>  Such drivers are used only with great grief or for great need.  Or if it is a simple built-in microcontroller system, in which there are only two drivers.  For example, the serial port &lt;-&gt; TCP interface converter, in which the network operates on interrupts, can, in principle, work with the serial port with polling.  If you do not mind the excess heat and energy costs. <br><br>  There is one more reason: such drivers are practically indestructible.  Therefore, for example, in Phantom OS, debugging the output of the kernel to the serial port is done this way. <br><br>  In the loop, we check the readiness of the port to receive bytes, transfer the bytes, and finish the exercise. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT 0x3F8 int dbg_baud_rate = 115200; void debug_console_putc(int c) { while(! (inb(PORT+5) &amp; 0x20) ) ; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">( c == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta"> ) outb(PORT, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta"> ); outb(PORT, c); } void arch_debug_console_init(void) { short divisor = 115200 / dbg_baud_rate; outb( PORT+3, 0x80 ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* set up to load divisor latch */</span></span></span><span class="hljs-meta"> outb( PORT, divisor &amp; 0xf ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LSB */</span></span></span><span class="hljs-meta"> outb( PORT+1, divisor &gt;&gt; 8 ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* MSB */</span></span></span><span class="hljs-meta"> outb( PORT+3, 3 ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* 8N1 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><br>  Such a driver, as it is easy to see, devours the processor in anticipation of the readiness of the device.  This can be repaired if the speed of the driver itself is noncritical: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(! (inb(PORT+<span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x20</span></span>) ) yield(); <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre><br><br>  But, of course, in general, this is not suitable anywhere (except for the above case :) model. <br><br><h4>  Interrupt Based Driver </h4><br>  The general structure of such a driver looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device_state</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> dev_write( buf ) { dev.buf = buf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !dev.started ) dev_start(); cond_wait( &amp;dev.ready ); } dev_interrupt() { dev_output(); } dev_start() { dev.started = <span class="hljs-number"><span class="hljs-number">1</span></span>; dev_enable_interrups( &amp;dev_interrupt ); dev_output(); } dev_output() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( buffer_empty() || (!dev.started) ) { dev.started = <span class="hljs-number"><span class="hljs-number">0</span></span>; dev_disable_interrupts(); cond_signal( &amp;dev.ready ); <span class="hljs-comment"><span class="hljs-comment">// done return; } // send to device next byte from buffer out( DEV_REGISTER, *dev.buf++ ); }</span></span></code> </pre><br><br>  In fact, such a driver generates a pseudo-thread for itself: a control flow that lives only on receipt of interrupts from the device. <br><br>  As soon as the driver receives the next write request, it enables interrupts and ‚Äúmanually‚Äù initiates sending the first byte of data to the device.  After which the incoming thread falls asleep, waiting for the end of the transfer.  And maybe come back if you need asynchronous work.  Now the driver will wait for an interrupt from the device.  When the device ‚Äúburns through‚Äù the received byte, it will generate an interrupt, during which the driver will either send the next byte (and wait for the next interrupt), or finish its work, turn off the interrupts and ‚Äúrelease‚Äù the thread waiting for dev_write (). <br><br><h4>  What is forgotten </h4><br>  Before we get to the latest driver model, we will list the things that I (intentionally) missed in the previous narration. <br><br><h5>  Error processing </h5><br>  In our pseudo-code, I / O success is not checked.  A real device may refuse or report a media failure.  They took out the cable from the LAN port, there was a bad block on the disk.  The driver must detect and process. <br><br><h5>  Timeouts </h5><br>  The device may break and simply not interrupt the request, or never set the ready bit.  The driver should request a timer event that would lead him out of the ‚Äústupor‚Äù to such an event. <br><br><h5>  Death request </h5><br>  If the OS around us allows this, then we must be prepared for the fact that the thread that entered the driver, within which the I / O request "came", may simply be killed.  This should not lead to fatal consequences for the driver. <br><br><h5>  Synchronization </h5><br>  For simplicity, I specify cond as the synchronization primitive.  In a real driver, this is not possible - cond requires an enclosing mutex at the synchronization point, and in the interruption, what kind of mutex is impossible!  Here in the latest model, a driver with its own thread, you can use cond as a means of synchronizing user threads and driver threads.  But synchronization with interruption is only a spinlock and a semaphore, and the semaphore implementation must be ready for the opportunity to activate (open) the semaphore from the interrupt.  (In the Phantom it is) <br><br><h4>  Thread Based Driver </h4><br>  It differs from the previous one in that it has its own thread that performs I / O. <br><br><pre> <code class="cpp hljs">dev_thread() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dev.active) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!dev_buffer_empty()) cond_wait(&amp;dev.have_data); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* device busy */</span></span> ) cond_wait(&amp;dev.interrupt); dev_enable_interrupts(); <span class="hljs-comment"><span class="hljs-comment">// send to device next byte from buffer out( DEV_REGISTER, *dev.buf++ ); } } dev_interrupt() { dev_disable_interrupts(); cond_signal(&amp;dev.interrupt); }</span></span></code> </pre><br><br>  The advantage of such a driver is that you can afford much more from a thread than from an interrupt handler ‚Äî you can allocate memory, manage page tables, and generally call any kernel function.  From the interruption one cannot afford long and, especially, blocking operations. <br><br>  Note that there is a third, intermediate model in which the driver does not have its own thread, but does the same from the I / O request thread.  But, first, see the point that they can kill her, secondly, this is a redneck :), and in the third - not always she (the thread) wants this.  Others would like asynchronous service. <br><br><h4>  Block I / O, sorting and fences </h4><br>  Disk drivers usually have a request queue as input - the OS generates I / O requests in batches, and all requests at the driver level are asynchronous.  At the same time, a good driver has its own query service strategy, and service is not in the order of receipt. <br><br>  Indeed, if on a regular disk device to perform requests in the order in which they arrived, the drive head will have to make random movements on the disk, slowing down the input-output. <br><br>  Usually, the driver simply sorts the request queue by block number and services them so that the disk head consistently moves from the outer track to the inner track, or vice versa.  It helps a lot. <br><br>  But not every couple of requests can be swapped.  If the file system (or its equivalent) decided that it needed to guarantee the integrity of the data on the disk, she would really like to make sure that a certain group of requests was completed.  To do this, a special I / O request is inserted into the request queue, which prohibits mixing requests to itself with requests after itself. <br><br>  In addition, it‚Äôs a bad idea to interchange the request for writing a N block and a read request for the same block.  However, this is a matter of agreement. </div><p>Source: <a href="https://habr.com/ru/post/282564/">https://habr.com/ru/post/282564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282550/index.html">About coordination of changes in time zones</a></li>
<li><a href="../282552/index.html">Apache Parquet performance</a></li>
<li><a href="../282556/index.html">Cocos creator</a></li>
<li><a href="../282558/index.html">We invite you to the conference on artificial intelligence and big data AI & BigData Lab June 4</a></li>
<li><a href="../282560/index.html">Big Data: Silver Bullet or another tool</a></li>
<li><a href="../282566/index.html">Who is faster: "clouds" vs "IT market"?</a></li>
<li><a href="../282568/index.html">Scenarios of application of free tools Veeam for development and testing in Microsoft Azure</a></li>
<li><a href="../282570/index.html">Intel Xeon processors equip FPGA Altera</a></li>
<li><a href="../282572/index.html">Cryptodisk synchronization between PC and Android</a></li>
<li><a href="../282574/index.html">Paul Graham: The Other Road Ahead, Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>