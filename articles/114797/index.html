<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Story of one optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 The article reveals the features of high-level optimization of computational algorithms in Java on the example of the cubic matrix multip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Story of one optimization</h1><div class="post__text post__text-html js-mediator-article"><img src="http://upload.wikimedia.org/wikipedia/en/thumb/e/eb/Matrix_multiplication_diagram_2.svg/313px-Matrix_multiplication_diagram_2.svg.png" align="right"><br><br><h4>  annotation </h4><br>  The article reveals the features of high-level optimization of computational algorithms in Java on the example of the cubic matrix multiplication algorithm. <br><br><h4>  Step 0. Set a reference point! </h4><br>  Decide on the environment: <br><ul><li>  Hardware: 1-socket / 2-cores Intel Core 2 Duo T7300 2GHz, 2Gb ram; </li><li>  Java: HotSpot (TM) Client VM (build 17.0-b17, mixed mode, sharing); </li></ul><br><a name="habracut"></a><br>  Consider the simplest cubic matrix multiplication algorithm.  Perhaps, any student or even a schoolboy knows him.  In addition, the principle of the algorithm is perfectly illustrated by a picture from Wikipedia at the beginning of the article, so we will not dwell on its features. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; A.rows(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; A.columns(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> summand = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; B.columns(); k++) { summand += A[i][k] * B[k][j]; } C[i][j] = summand; } }</code> </pre> <br><br>  As workload, we take two dense square double precision N x N matrices (double precision), where N = 1000. <br><br>  In this case, the operating time of a simple cubic algorithm: <b>18.921 s</b> .  We will consider this number as a point of reference (baseline) for subsequent optimizations. <br><br><h4>  Step 1. Know the rule 20/80! </h4><br>  It is known that 80% of the time works 20% of the code.  The task of the developer is to calculate these same 20% of the total code.  In our case, everything is obvious - the required 20% are concentrated in the internal computing cycle.  From the point of view of the JVM, this code is the most likely candidate for a just-in-time compilation.  You can check whether the bytecode is compiled into native by using the options <b>- XX: + PrintCompilation -XX: + CITime</b> . <br><br><pre> <code class="bash hljs">$ java -XX:+PrintCompilation la4j.Demo 1 java.lang.String::hashCode (64 bytes) 2 java.lang.String::charAt (33 bytes) 3 java.lang.String::indexOf (151 bytes) 4 java.lang.String::indexOf (166 bytes) 5 java.util.Random::next (47 bytes) 6 java.util.concurrent.atomic.AtomicLong::get (5 bytes) 7 java.util.concurrent.atomic.AtomicLong::compareAndSet (13 bytes) 8 java.util.Random::nextDouble (24 bytes) 9 la4j.matrix.DenseMatrix::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (10 bytes) 1% la4j.matrix.MatrixFactory::createRandomDenseMatrix @ 30 (68 bytes) 10 la4j.matrix.MatrixFactory::createRandomDenseMatrix (68 bytes) 2% la4j.matrix.DenseMatrix::multiply @ 81 (152 bytes)</code> </pre><br><br>  It can be seen from the listing that the matrix multiplication method (la4j.matrix.DenseMatrix :: multiply) was successfully compiled.  This gives us a certain amount of room for further action.  First, let's take advantage of the final variables.  It is known that when compiled into native code, they are translated directly into values.  Theoretically, replacing matrix boundaries with final values ‚Äã‚Äãwould reduce memory access by 1000x1000x1000 times.  Instead, the values ‚Äã‚Äãwill be substituted directly.  Let's check the theory. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aColumns = A.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aRows = A.rows(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bColumns = B.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bRows = B.rows(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; aRows; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; aColumns; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> summand = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; bColumns; k++) { summand += A[i][k] * B[k][j]; } C[i][j] = summand; } }</code> </pre><br>  The running time of the algorithm: <b>16.996 s</b> ; <br>  Performance boost: <b>~ 11%</b> ; <br><br><h4>  Step 2. Remember Kesh! </h4><br>  In fact, such an implementation will always work slowly.  Iteration over ‚Äúk‚Äù refers to the elements of matrix B in columns.  Such reading is very expensive, because the processor has to prefetch the data from the memory each time, instead of taking it ready from the cache. <br><br>  It is noteworthy that Fortran does not have such a problem.  Multidimensional arrays are stored in it in columns.  Therefore, the cache will be operated as it should and the regular implementation of the cubic algorithm will work many times faster. <br><br>  On the platform in question, the first-level cache line size (L1) - 64 bytes - this is the cheapest memory for the processor.  In our case, 64 bytes of almost free memory give the potential to receive as many as 8 cells of the matrix (sizeof (double) = 8) in the place of one more followed by the overhead from prefetching. <br><br>  The problem of the algorithm is that it practically does not use this feature.  At the same time, random access to memory (by columns) resets the cache line and initializes the update procedure for the cache line on each access. <br><br>  Let's try to fix this and implement sequential access to the elements of the matrices in order to get the maximum benefit from the cache.  To do this, simply transpose the matrix B and we will refer to its elements in rows. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aColumns = A.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aRows = A.rows(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bColumns = B.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bRows = B.rows(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> BT[][] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[bColumns][bRows]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bRows; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bColumns; j++) { BT[j][i] = B[i][j]; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; aRows; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; aColumns; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> summand = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; bColumns; k++) { summand += A[i][k] * BT[j][k]; } C[i][j] = summand; } }</code> </pre><br>  The running time of the algorithm: <b>7.334 s</b> ; <br>  Performance boost: <b>~ 232%</b> ; <br><br><h4>  Step 3. Think! </h4><br>  The code has become more, however, the operation time has been reduced by almost 2.5 times.  Not bad.  However, when viewing the code, there are obvious shortcomings.  The main one is a lot of cycles.  Let's try to reduce the amount of code and make it more elegant by combining the operations of transposition and multiplication into one computational cycle.  At the same time, the transposition will be carried out not for the whole matrix but by columns, as they are needed. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aColumns = A.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aRows = A.rows(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bColumns = B.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bRows = B.rows(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> thatColumn[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[bRows]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bColumns; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; aColumns; k++) { thatColumn[k] = B[k][j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; aRows; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> thisRow[] = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> summand = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; aColumns; k++) { summand += thisRow[k] * thatColumn[k]; } C[i][j] = summand; } }</code> </pre><br>  The running time of the algorithm: <b>3.976 s</b> ; <br>  Performance boost: <b>~ 190%</b> ; <br><br><h4>  Step 4. Throw away! </h4><br>  Let's take advantage of one more Java - exceptions.  We will try to replace the check for exceeding the bounds of the matrix by a try {} catch {} block.  This will reduce the number of comparisons by 1000 in our case.  Indeed, why compare 1000 times what will always return false and return true for 1001 times. <br><br>  On the one hand, we reduce the number of comparisons, on the other hand, additional overhead costs for handling exceptions appear.  Anyway, this approach gives some gain. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aColumns = A.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> aRows = A.rows(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bColumns = B.columns(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bRows = B.rows(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> thatColumn[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[bRows]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; ; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; aColumns; k++) { thatColumn[k] = B[k][j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; aRows; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> thisRow[] = A[i]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> summand = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; aColumns; k++) { summand += thisRow[k] * thatColumn[k]; } C[i][j] = summand; } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IndexOutOfBoundsException ignored) { }</code> </pre><br>  The running time of the algorithm: <b>3.594 s</b> ; <br>  Productivity gain: <b>~ 10%</b> ; <br><br><h4>  Step 5. Do not stop! </h4><br>  At this stage, I have so far stopped, because I have achieved the desired goal.  My goal was to overtake the most popular library for working with matrices - JAMA (the first line in Google on the query ‚Äújava matrix‚Äù).  Now my implementation works about 30% faster than JAMA.  In addition, relatively small optimizations resulted in an increase of almost <b>600%</b> , relative to the initial version. <br><br><h4>  Instead of a conclusion (this is not an advertisement) </h4><br>  The code considered is part of the open-source <a href="http://la4j.googlecode.com/">laj4</a> project.  This is a library for solving problems of linear algebra in Java.  I started working on the project in the fourth course in the process of studying a course in computational mathematics.  Now la4j shows excellent performance and works several times faster than analogs on many tasks. <br><br>  If someone is interested and wants to spend the evening in a similar way - write in a personal :) </div><p>Source: <a href="https://habr.com/ru/post/114797/">https://habr.com/ru/post/114797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114792/index.html">Geek has adapted Kinect for playing Tetris</a></li>
<li><a href="../114793/index.html">Content farms suffer losses due to a change in the Google search algorithm</a></li>
<li><a href="../114794/index.html">Ideal life</a></li>
<li><a href="../114795/index.html">Broadcast Presentation iPad 2</a></li>
<li><a href="../114796/index.html">Apple introduced iPad 2</a></li>
<li><a href="../114800/index.html">Will you buy an iPad 2?</a></li>
<li><a href="../114801/index.html">Is cacheAsBitmap good?</a></li>
<li><a href="../114803/index.html">ICANN approved the domain "Ukrainian" for Ukraine</a></li>
<li><a href="../114804/index.html">hGate - the gateway to Mercurial repository management</a></li>
<li><a href="../114805/index.html">Google has updated its user interface.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>