<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding the right way to split site content with a Webpack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Finding the best way to organize web project materials can be a daunting task. There are many different scenarios for user experience with projects, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding the right way to split site content with a Webpack</h1><div class="post__text post__text-html js-mediator-article">  Finding the best way to organize web project materials can be a daunting task.  There are many different scenarios for user experience with projects, many technologies and other factors that need to be taken into account. <br><br>  The author of the material, the translation of which we are publishing today, says that he wants to tell here everything that he needs to know in order to competently prepare materials for web projects for work.  Firstly, the discussion will focus on how to select a site file sharing strategy that is best suited for a particular project and its users.  Secondly, the means of implementing the chosen strategy will be considered. <br><br> <a href="https://habr.com/company/ruvds/blog/423483/"><img src="https://habrastorage.org/getpro/habr/post_images/7fe/270/c2c/7fe270c2cd5aad585ca616a6f3704704.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">General information</font> </h2><br>  According to the <a href="https://webpack.js.org/glossary/">Webpack glossary</a> , there are two file sharing strategies.  This is bundle splitting and code splitting.  These terms may seem interchangeable, but they are not. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Bundle splitting is a technique for splitting large bundles into several parts, which are smaller files.  Such files, in any case, as when working with a single bundle, will be downloaded by all users of the site.  The strength of this technique is to improve the use of browser caching mechanisms. </li><li>  Code separation is an approach that implies dynamic code loading as the need arises.  This leads to the fact that the user downloads only the code that is necessary for him to work with some part of the site at a certain point in time. </li></ul><br>  Separating code seems to be much more interesting than splitting a bundle.  And, in fact, there is a feeling that many articles on our topic focus on the separation of code, this technique is considered as the only worthwhile way to optimize site materials. <br><br>  However, I would like to say that for many sites the first strategy turns out to be much more valuable - the separation of bundles.  And, perhaps, literally all web projects can benefit from its implementation. <br><br>  Let's talk about this in more detail. <br><br><h2>  <font color="#3AC1EF">Splitting bundles</font> </h2><br>  A very simple idea is at the core of the bundle separation technique.  If you have one huge file and you change one single line of code in it, the regular user will have to download the entire file at the next visit to the site.  However, if you divide this file into two files, then the same user will need to download only the one that has been modified, and the second file will be taken from the browser cache. <br><br>  It is worth noting that since the optimization of site materials by splitting bundles is tied to caching, users visiting the site for the first time, in any case, will have to download all the materials, so there is no difference for them whether these materials are presented as a single file or as several . <br><br>  It seems to me that too much talk about the performance of web projects is devoted to users who visit the site for the first time.  Perhaps this is so, in part, because of the importance of the first impression that the project will have on the user, and also on the fact that the amount of data transmitted to users when you first visit the site is easy and convenient to measure. <br><br>  When it comes to regular visitors, it can be difficult to measure the impact of applied optimization techniques on them.  But we just have to know about the consequences of such optimizations. <br><br>  To analyze such things you need something like a spreadsheet.  You will also need to create a strict list of conditions in which we can test each of the caching strategies under investigation. <br><br>  Here is a script suitable for the general description given in the previous paragraph: <br><br><ul><li>  Alice visits our site once a week for 10 weeks. </li><li>  We update the site once a week. </li><li>  We are updating the product list page every week. </li><li>  In addition, we have a page with product details, but we are not working on it yet. </li><li>  On the fifth week, we add a new npm package to the project materials. </li><li>  On the eighth week, we are updating one of the npm packages already used in the project. </li></ul><br>  There are people (like me) who will try to make such a scenario as realistic as possible.  But you do not need to do that.  The real scenario here does not really matter.  Why this is so - we will soon find out. <br><br><h3>  <font color="#3AC1EF">‚ñçThe conditions</font> </h3><br>  Suppose the total size of our javascript package is quite 400 kb, and we, in the current environment, transfer all this to the user as one <code>main.js</code> file.  We have a Webpack configuration, which, in general, is similar to the one below (that which doesn‚Äôt apply to our conversation, I removed it from there): <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, };</code> </pre> <br>  Webpack calls the resulting <code>main.js</code> file when there is only one entry in the configuration. <br><br>  If you are not very good at working with the cache, keep in mind that every time I write <code>main.js</code> here, I actually mean something like <code>main.xMePWxHo.js</code> .  An insane sequence of characters is a hash of the contents of the file, something that is called <code>contenthash</code> in the configuration.  Using this approach leads to the fact that, when the code changes, the file names also change, which forces the browser to download new files. <br><br>  In accordance with the above scenario, when we make some changes to the site code every week, the <code>contenthash</code> line of the package changes.  As a result, visiting our website weekly, Alice is forced to upload a new file of 400 KB in size. <br><br>  If you make a nice sign (with a useless row of totals) containing data on the weekly amount of data loading that falls on this file, then we will have the following. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/fa6/424/3b6fa6424d43c147b40c5347e4dfa104.png"></div><br>  <i><font color="#999999">The amount of data uploaded by the user</font></i> <br><br>  As a result, it turns out that the user, in 10 weeks, uploaded 4.12 MB of code.  This indicator can be improved. <br><br><h3>  <font color="#3AC1EF">‚ñçDivision of third-party packages from the main code</font> </h3><br>  We divide the large package into two parts.  Our own code will be in the <code>main.js</code> file, and third-party code in the <code>vendor.js</code> file.  It's easy to do this; the following Webpack configuration will help us: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, optimization: {   splitChunks: {     chunks: <span class="hljs-string"><span class="hljs-string">'all'</span></span>,   }, }, };</code> </pre> <br>  Webpack 4 tries to make the developer's life as easy as possible, so he does everything he can and does not require him to be told exactly how to break the bundles into parts. <br><br>  Such an automatic behavior of the program leads to a few delights, like: ‚ÄúWell, what a beauty this Webpack is‚Äù, and to many questions in the spirit: ‚ÄúAnd what is this doing here with my bundles?‚Äù. <br><br>  In any case, adding to the configuration configuration <code>optimization.splitChunks.chunks = 'all'</code> tells Webpack that we need it to take everything from the <code>node_modules</code> and put it in the <code>vendors~main.js</code> . <br><br>  After we have done this basic division of the bundle, Alice, who regularly visits our site weekly, will upload a 200 KB <code>main.js</code> file at each visit.  But the <code>vendor.js</code> file it will load only three times.  It will happen during the visits in the first, fifth and eighth weeks.  Here is the corresponding table, in which, by the will of fate, the sizes of the files <code>main.js</code> and <code>vendor.js</code> in the first four weeks coincide and are equal to 200 Kb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f52/61f/49f/f5261f49f5f3dba9c34fec5f83a142b2.png"></div><br>  <i><font color="#999999">The amount of data uploaded by the user</font></i> <br><br>  The result is that the amount of data uploaded by the user in 10 weeks was 2.64 MB.  That is, in comparison with what happened before the bundle split, the volume decreased by 36%.  Not so bad result achieved by adding a few lines to the configuration file.  By the way, before you read further - do the same in your project.  And if you need to upgrade from Webpack 3 to 4 - do it and do not worry, since the process is quite simple and still free. <br><br>  It seems to me that the improvement considered here looks somewhat abstract, since it is stretched for 10 weeks.  However, if we count the volume of data sent to a loyal user, then this is an honest reduction of this volume by 36%.  This is a very good result, but it can be improved. <br><br><h3>  <font color="#3AC1EF">‚ñçPackaging packages into separate files</font> </h3><br>  The <code>vendor.js</code> file suffers from the same problem as the original <code>main.js</code>  It lies in the fact that changing any package that is included in this file leads to the need for the regular user to reload this entire file. <br><br>  Why don't we create separate files for each npm-package?  It‚Äôs really easy to do, so let's <code>react</code> our <code>react</code> , <code>lodash</code> , <code>redux</code> , <code>moment</code> , and so on, into separate files.  The following Webpack configuration will help us with this: <br><br><pre> <code class="hljs markdown">const path = require('path'); const webpack = require('webpack'); module.exports = { entry: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'), plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], output: {   path: path.resolve(__</span></span>dirname, 'dist'),   filename: '[<span class="hljs-string"><span class="hljs-string">name</span></span>].[<span class="hljs-string"><span class="hljs-string">contenthash</span></span>].js', }, optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules[\\/]/,         name(module) {           //  ,   node_</span></span>modules/packageName/not/this/part.js           //  node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName           const packageName = module.context.match(/[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  In the <a href="https://webpack.js.org/guides/caching/">documentation</a> you can find an excellent explanation of the constructions used here, but I, nevertheless, devote a little time to the story about some things, since it took a lot of time to use them correctly. <br><br><ul><li>  Webpack has quite reasonable standard settings, which, in fact, turn out to be not so reasonable.  For example, the maximum number of output files is set to 3, the minimum file size is 30 KB (that is, smaller files will be merged).  I redefined it. </li><li>  <code>cacheGroups</code> is where we set the rules for how Webpack should group data in output files.  I have one group here, <code>vendor</code> , that will be used for any module loaded from <code>node_modules</code> .  Usually the name for the output file is set as a string.  But I set the <code>name</code> in the form of a function that will be called for each processed file.  Then I take the package name from the module path.  As a result, we get one file for each package.  For example, <code>npm.react-dom.899sadfhj4.js</code> . </li><li>  Package names, in order for them to be published to npm, must be suitable for use in <a href="">URLs</a> , so we do not need to perform an <code>encodeURI</code> operation for <code>packageName</code> names.  However, I ran into a problem, which is that the .NET server refuses to work with files that have an <code>@</code> symbol in their names (such names are used for packages with a given scope of the so-called scoped packages), so I‚Äôve code fragment, get rid of these characters. </li></ul><br>  The above Webpack configuration is good because you can configure it once and then forget about it.  It does not require reference to specific packages by name, therefore, after its creation, it, even with changes in the composition of packages, remains relevant. <br><br>  Alice, our regular visitor, still <code>main.js</code> 200-kilobyte <code>main.js</code> every week, and when she first visits the site, she has to download 200 KB of npm-packages, but she will not have to download the same packages twice. <br><br>  Below is a new version of the table with information about the volume of weekly data downloads.  By a strange coincidence, the size of each file with npm packages is 20 Kb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/787/006/f98787006dc9320ca37b680b23534e71.png"></div><br>  <i><font color="#999999">The amount of data uploaded by the user</font></i> <br><br>  Now the amount of data downloaded in 10 weeks is 2.24 MB.  This means that we have improved the base rate by 44%.  The result is already quite decent, but then the question arises whether it is possible to do so in order to achieve a result that exceeds 50%.  If this happens, it will be just great. <br><br><h3>  <font color="#3AC1EF">‚ñçDisposing the application code into fragments</font> </h3><br>  Let's <code>main.js</code> back to the <code>main.js</code> file, which unfortunate Alice has to load constantly. <br><br>  Above, I said that our site has two separate sections.  The first is a list of products, the second is a page with detailed information about the product.  The size of the code, unique for each of them, is 25 Kb (and 150 Kb of code is used both there and there). <br><br>  Product details page is not subject to change, as we have already brought it to perfection.  Therefore, if we separate its code into a separate file, this file, most of the time it takes to work with the site, will be loaded into the browser from the cache. <br><br>  In addition, as it turned out, we have a huge embedded SVG file used for rendering icons, which weighs as much as 25 Kb and rarely changes. <br><br>  With this we need to do something. <br><br>  We manually created several entry points, telling Webpack that he needed to create a separate file for each of these entities. <br><br><pre> <code class="hljs markdown">module.exports = { entry: {   main: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'),   ProductList: path.resolve(__</span></span>dirname, 'src/ProductList/ProductList.js'),   ProductPage: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/ProductPage/ProductPage.js'),   Icon: path.resolve(__</span></span>dirname, 'src/Icon/Icon.js'), }, output: {   path: path.resolve(<span class="hljs-emphasis"><span class="hljs-emphasis">__dirname, 'dist'),   filename: '[name].[contenthash:8].js', }, plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]/,         name(module) {           //  ,   node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName/not/this/part.js           //  node_</span></span>modules/packageName           const packageName = module.context.match(/[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node_modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  A hard-working Webpack will also create files for what is common, for example, for <code>ProductList</code> and <code>ProductPage</code> , that is, there will be no duplicate code here. <br><br>  What we have just done will allow Alice to save 50 Kb of traffic almost every week.  Please note that the icon description file was edited in the sixth week.  Here is our traditional table. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/b9e/8ed/62fb9e8ed563fd4aa7a61fdcec61fc2d.png"></div><br>  <i><font color="#999999">The amount of data uploaded by the user</font></i> <br><br>  Now for ten weeks loaded only 1.815 MB of data.  This means that the traffic saving was an impressive 56%.  In accordance with our theoretical scenario, the regular user will always work with this level of savings. <br><br>  All this is done due to changes made to the Webpack configuration.  We did not change the application code to achieve such results. <br><br>  Above, I said that the specific scenario in which such a test is conducted does not really play a special role.  This is said because, regardless of the script used, the conclusion of everything we talked about is the same: splitting the application into small files that make sense when applied to its architecture reduces the amount of site data uploaded by its regular users. <br><br>  Very soon we will start talking about code sharing, but first I would like to answer three questions that you are probably thinking about now. <br><br><h3>  <font color="#3AC1EF">‚ñç Question number 1.</font>  <font color="#3AC1EF">Doesn‚Äôt the necessity of fulfilling a multitude of requests harm the speed of loading a site?</font> </h3><br>  This question can be given a simple short answer: "No, it does not harm."  A similar situation resulted in a problem in the old days, when the HTTP / 1.1 protocol was used, and when using HTTP / 2 this is irrelevant. <br><br>  Although, it should be noted that <a href="http-2-437c37efe3ff">this</a> article, published in 2016, and <a href="http2.htm">this</a> 2015 Khan Academy article concludes that even when using HTTP / 2, the use of too many files slows down the download.  But in both of these materials, ‚Äútoo much‚Äù means ‚Äúseveral hundred.‚Äù  Therefore, it is worth remembering that if you have to work with hundreds of files, restrictions on parallel data processing may affect the speed of their loading. <br><br>  If you are interested, HTTP / 2 support is available in IE 11 in Windows 10. In addition, I did extensive research among those using older systems.  They unanimously stated that their website loading speed is not particularly a concern. <br><br><h3>  <font color="#3AC1EF">‚ñç Question number 2.</font>  <font color="#3AC1EF">In Webpack-bandla there is an auxiliary code.</font>  <font color="#3AC1EF">Does it create additional load on the system?</font> </h3><br>  Yes it is. <br><br><h3>  <font color="#3AC1EF">‚ñç Question number 3.</font>  <font color="#3AC1EF">When working with many small files, their compression level worsens, doesn‚Äôt it?</font> </h3><br>  Yes it is, too.  In fact, I would like to say this: <br><br><ul><li>  More files means more auxiliary Webpack code. </li><li>  More files means less compression. </li></ul><br>  Let's deal with this in order to understand how bad it is. <br><br>  I just did a test, during which the code from a file of 190 KB in size was broken into 19 parts.  This added about 2% to the amount of data sent to the browser. <br><br>  The result is that when you first visit the site, the user will download 2% more data, and the next - 60% less, and it will continue for a very, very long time. <br>  So is it worth worrying about it?  No, not worth it. <br><br>  When I compared the system using 1 file and the system with 19 files, I tested it using various protocols, including HTTP / 1.1.  The table below strongly supports the idea that more files are better. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/2fa/47c/a852fa47c36befc2234794c9cae1b9c1.png"></div><br>  <i><font color="#999999">Data on working with 2 versions of a site hosted on a static Firebase hosting, the code of which has a size of 190 Kb, but, in the first case, is packaged in 1 file, and in the second - broken into 19</font></i> <br><br>  When working in 3G and 4G networks, downloading a site variant with 19 files took 30% less time than downloading a site with one file. <br><br>  In the data presented in the table, a lot of noise.  For example, one download session on 4G (Run 2 in the table) took 646 ms, another (Run 4) - 1116 ms, which is 73% longer.  Therefore, there is a feeling that saying that HTTP / 2 "is 30% faster" is somewhat unfair. <br><br>  I created this table to see what HTTP / 2 uses.  But, in fact, the only thing that can be said here is that the use of HTTP / 2 probably does not significantly affect the page load. <br><br>  The last two lines in this table were a real surprise.  Here are the results for not the newest version of Windows with IE11 and HTTP / 1.1.  If I tried to predict the results of the test in advance, I would definitely say that such a configuration would load materials much more slowly than others.  True, a very fast network connection was used here, and for such tests I probably should use something slower. <br><br>  And now I will tell you a story.  I, in order to investigate my site on an absolutely ancient system, downloaded the Windows 7 virtual machine from <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">the</a> Microsoft <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">site</a> .  IE8 was installed there, which I decided to upgrade to IE9.  To do this, I went to the Microsoft page, designed to download IE 9. But I did not succeed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/ee6/529/a3bee65295b45bf2467da37252674cf0.png"></div><br>  <i><font color="#999999">That is bad luck ...</font></i> <br><br>  By the way, if we talk about HTTP / 2, I would like to note that this protocol is integrated into Node.js.  If you want to experiment - you can use the small <a href="https://gist.github.com/davidgilbertson/e5690c04e06c4882cf5761f8acff36ec">HTTP / 2 server</a> I wrote with support for the answer cache, gzip and brotli. <br><br>  Perhaps, I said everything I wanted about the method of splitting bundles.  I think that the only drawback of such an approach, when using which users have to upload a lot of files, in fact, is not such a ‚Äúminus‚Äù. <br><br>  Now let's talk about code sharing. <br><br><h2>  <font color="#3AC1EF">Code separation</font> </h2><br>  The main idea of ‚Äã‚Äãthe code separation technique is: ‚ÄúDo not download unnecessary code‚Äù.  I was told that using this approach only makes sense for some sites. <br><br>  I prefer, when it comes to code sharing, to use the 20/20 rule that I just formulated.  If there is any part of the site that only 20% of users visit, and its functionality provides more than 20% of the site's JavaScript code, then this code should be downloaded only on request. <br><br>  These are, of course, not absolute numbers, they can be tailored to a specific situation, and in reality there are much more complex scenarios than the one described above.  The most important thing here is balance, and it‚Äôs completely normal not to use code separation at all if it makes no sense for your site. <br><br><h3>  <font color="#3AC1EF">‚ñçDivide or not?</font> </h3><br>  How to find the answer to the question of whether you need code separation or not?  Suppose you have an online store and you are thinking about whether the code that is used to receive payment from customers should be separated from the rest of the code, since only 30% of the visitors buy something from you. <br><br>  What is there to say?  First of all, you would have to work on filling the store and selling something that will be interesting to more visitors.  Secondly - you need to understand how much code is completely unique for the section of the site where payment is accepted.  Since you should always do a ‚Äúbundle separation‚Äù before ‚Äúcode separation‚Äù, and you hope so, you probably already know what size the code of interest is. <br><br>  Perhaps this code may turn out to be less than you think, therefore, before you rejoice at the new opportunity to optimize the site, it is worthwhile to calmly count everything.  If you have, for example, a React site, then the storage, reducer, routing system, actions will be shared by all parts of the site.  The code that is unique for different parts of the site will be mainly represented by components and auxiliary functions for them. <br><br>  So, you found out that a completely unique code of the section of the site used to pay for purchases takes 7 Kb.  The size of the rest of the site code is 300 Kb.  In a situation like this, I wouldn‚Äôt deal with code separation for several reasons: <br><br><ul><li>  If you download these 7 KB in advance, the site is not slow.  Remember that the files are downloaded in parallel and try to measure the difference needed to download 300 KB and 307 KB of code. </li><li>  If you download this code later, then the user will have to wait after clicking on the "Pay" button.  And this is the very moment when you need everything to go as smoothly as possible. </li><li>  Separating the code requires changes to the application.  In the code, in those places where before everything was done synchronously, asynchronous logic appears.  Of course, there are no cosmic difficulties in such code transformations, but this is still an additional amount of work, which, I think, should be done for a tangible improvement in the user experience of working with the site. </li></ul><br>  , ,        ,  . <br><br>        . <br><br><h3> <font color="#3AC1EF">‚ñç</font> </h3><br>      ,   ,    ,       . <br><br>           .     ,     .      : <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'whatwg-fetch'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'intl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url-polyfill'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/web/dom-collections'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/string'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/array'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/object'</span></span>);</code> </pre> <br>         <code>index.js</code> ,      : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> render = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root')); } render(); // ,     </span></span></code> </pre> <br>    Webpack   ,        ,        npm-.     25 , 90%    ,      . <br><br>   Webpack 4    <code>import()</code> (      <code>import</code> ),      : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; const render = () =&gt; { ReactDOM.render(&lt;App /&gt;, document.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-string"><span class="hljs-string">'fetch'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Intl'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'URL'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Map'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'forEach'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> NodeList.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'startsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'endsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'assign'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'entries'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'keys'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> ) { render(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(render); }</code> </pre> <br>  ,  ,   ,  ‚Äî     .   ‚Äî        <code>render()</code> .      ,  Webpack     npm-,       ,    <code>render()</code>   . <br><br>  ,   <code>import()</code>    Babel <a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/">dynamic-import</a> .  ,      Webpack,  <a href="https://webpack.js.org/guides/code-splitting/">import()</a>  ,           . <br><br>    ,   .    . <br><br><h3> <font color="#3AC1EF">‚ñç    React,   </font> </h3><br>     . ,          ,      ,    . <br><br>       ,     npm-    .        ,   ,      100 . <br><br>       , ,    URL <code>/admin</code> ,  <code>&lt;AdminPage&gt;</code> . Webpack    ,      <code>import AdminPage from './AdminPage.js'</code>       . <br><br>     .           ,   ,  <code>import('./AdminPage.js')</code> ,   Webpack    ,      . <br><br> ,      . <br><br> ,  ,    <code>AdminPage</code> ,     ,        URL <code>/admin</code> . ,    : <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdminPageLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ constructor(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {     <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,   } } componentDidMount() {   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>('./<span class="hljs-type"><span class="hljs-type">AdminPage</span></span>').then(module =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: module.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> });   }); } render() {   const { <span class="hljs-type"><span class="hljs-type">AdminPage</span></span> } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>     ? &lt;<span class="hljs-type"><span class="hljs-type">AdminPage</span></span> {...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props} /&gt;     : &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Loading</span></span>...&lt;/div&gt;; } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-type"><span class="hljs-type">AdminPageLoader</span></span>;</code> </pre> <br>        .     (,     URL <code>/admin</code> ),    <code>./AdminPage.js</code> ,          . <br><br>   <code>render()</code>   ,   <code>&lt;AdminPage&gt;</code> ,  <code>&lt;div&gt;Loading...&lt;/div&gt;</code> ,   <code>&lt;AdminPage&gt;</code>  ,         . <br><br>        ,       <code>react-loadable</code> ,    <a href="https://reactjs.org/docs/code-splitting.html"></a> React   . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br> ,   ,   (,  ,      CSS).   : <br><br><ul><li>          ‚Äî      . </li><li>       ,      ‚Äî    . </li></ul><br>  <b>Dear readers!</b>           ? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/423483/">https://habr.com/ru/post/423483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423469/index.html">The fastest floating point numbers in the wild west</a></li>
<li><a href="../423475/index.html">Breaking the code of aging: the new science of aging and what it means to stay young</a></li>
<li><a href="../423477/index.html">Be a security ninja: start your way to the top of IB</a></li>
<li><a href="../423479/index.html">"First": whether to fly to Mars</a></li>
<li><a href="../423481/index.html">I need to raise the Kubernetes cluster, but I'm just a code programmer. There is an exit</a></li>
<li><a href="../423485/index.html">Lazy loading images using IntersectionObserver</a></li>
<li><a href="../423487/index.html">Node.js without node_modules</a></li>
<li><a href="../423489/index.html">I'm an emergency doctor, and I want to talk about the new Apple Watch electrocardiogram</a></li>
<li><a href="../423491/index.html">PHP Digest number 139 (September 3 - 17, 2018)</a></li>
<li><a href="../423493/index.html">Android Go is the next billion devices and 50 MB limit. Yandex lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>