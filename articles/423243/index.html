<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vector averaging method for measuring wind direction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A year ago, I described a weather station with a wind speed and direction meter. According to the experience of two seasons of operation, some changes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vector averaging method for measuring wind direction</h1><div class="post__text post__text-html js-mediator-article">  A year ago, I <a href="https://habr.com/post/404385/">described a</a> weather station with a wind speed and direction meter.  According to the experience of two seasons of operation, some changes and improvements were made to it, which are partially described there in the supplements to the main text. <br><br>  One of these changes concerns the calculation of the average value of the wind speed direction.  To my amazement, I didn‚Äôt find anything sensible on the web, only on one of the forums the people themselves almost thought of the vector averaging method (but only almost, they didn‚Äôt solve the problem in general).  Therefore, I considered it useful to bring this topic into a separate publication - suddenly someone else will come in handy.  The method can be used for averaging any vector quantities, not just wind or current. <br><a name="habracut"></a><br>  Note that the canonical method of conducting meteorological measurements of wind is as follows: to average the vector (that is, the speed and direction) for 10 minutes (in Russia and most countries of the world, this is usually the case, they say, in the USA and some other countries differently).  In this case, measurements are carried out at a height of 10 m from the surface of the Earth.  It is rather difficult to provide all this in knee-down conditions: you cannot reach 10 m in open space (you should not build a special tower, and far from houses and trees distorting the wind flow), and the temperature with humidity should be measured in the shade and near from the surface.  From a compact device, the remote sensor transforms into a whole measuring system (see photo of the territory of the weather station in the city of Kirov). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/704/b2b/b03704b2bd492c4455aae265a659d489.jpg" alt="Weather station in Kirov">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the result obtained - an average of 10 minutes - will be of little informative.  Near the surface, the wind is much more gusty than at a height, in 10 minutes it can change the speed and direction twenty times, and the information about these gusts for the average person is much more informative than the average value.  Let me remind you that the speed sensor we have demonstrates the maximum value of four measurements per cycle of 8 s, and this turned out to be the right choice (in fact, instead of the average speed sensor, we received a pulsation sensor). <br><br>  But the weather vane turned out to be more capricious than the speed sensor.  According to the initial algorithm of my meteorological station (which was chosen on the basis of the maximum possible energy saving), the direction was measured once per cycle, that is, even the pulsations did not work: there were random samples from the continuous process of wind vane rolling back and forth with a frequency much higher than every 8 and more than 16 seconds. <br><br>  Therefore, it was decided to average the direction of the velocity vector per cycle, taking measurements every two seconds and calculating the average.  But this is not the case in such a way that the half-ping is solved - the direction values ‚Äã‚Äãdo not form a uniform array of numbers that can be directly folded and divided (one word is a vector, and not bullshit).  An example is usually given with values ‚Äã‚Äãof 1 degree and 359 degrees: it is easy to figure out that on average it will be exactly 360 (or 0, no difference), but ordinary arithmetic will produce a number of 180 degrees. <br><br>  There is no need to invent anything - everything has already been invented before you.  The problem is solved by the vector averaging method, well known to those who dealt with measurements of winds or currents.  The method is essentially very simple: if we cannot directly average the angles, then let's average the projections of the vector on the coordinate axes, which, by definition, are scalar, that is, amenable to ordinary arithmetic without questions. <br><br>  The projections of the current wind vector W '(the apostrophe here plays the role of a superscript line) on the X and Y axes are wx = Wa ‚Ä¢ cos (Œ±) and wy = Wa ‚Ä¢ sin (Œ±), where Wa is the vector modulus (velocity value), and Œ± - the value of the angle between the vector and the zero axis of coordinates.  If we average these values ‚Äã‚Äãof the projections, and then convert the averages back into a vector, we get the true value of the average speed and direction of the wind. <br><br><div class="spoiler">  <b class="spoiler_title">Note for especially corrosive</b> <div class="spoiler_text">  For a fully correct averaging in this way, it is necessary that the value of Wa (velocity value) be measured strictly simultaneously with the magnitude of the angle.  In practice, this should be monitored only if the periods of significant amplitude flow pulsations are shorter or comparable to the measurement time.  For the wind (and for almost all cases of the natural flow of water), it is usually not necessary to monitor, since the measurement time is at most a fraction of a second, and significant wind pulsations, of course, last longer.  We may neglect the high-frequency flow irregularities, because they do not affect anything: the inertia of real physical bodies (including sensors) is much larger than these discontinuities, and we simply will not feel them - a piece of paper will tremble, but no more.  In the extreme case, they will come out as a small random noise that does not significantly affect the quality of measurements. <br></div></div><br>  This remarkable method (let's call it complete vector averaging) has one fundamental drawback from a practical point of view: in the absence of a measurement object (that is, when there is complete calm, which is quite a household case), it produces a mathematically incorrect result: since the wind speed is zero, and both projections are equal to zero, which cannot be (since sin and cos are complementary functions).  More precisely, it can be, but it is fundamentally impossible to extract information from such a situation.  And what would you order to show on the display?  To be honest, I still do not know the correct way to get around this situation (in the flow meters that I once designed, the averaging cycles made up the clock, and it was believed that during this time at least some movement would occur). <br><br>  But in our case, the task, fortunately, is easier - we don‚Äôt need to average the speed, and we can do with single projections of the vector, without taking into account the magnitude of its module.  In other words, it is possible to operate with pure sines and cosines, which never take the zero value both at once: even when there is no wind, a weather vane frozen in real estate shows a certain direction.  Let's call such a method a simplified vectorial averaging of direction (maybe it has some kind of official name, but I am not up to date). <br><br>  The difficulty now remains only one: turn the calculated average values ‚Äã‚Äãof the projections back into the angle value.  For this, the function Œ± = arctan (sin (Œ±) / cos (Œ±)) is usually used, but if we calculate it through inverse trigonometric functions, then it is easier to take simply arcos (cos (Œ±)) (or arcsin (sin (Œ±)), all the same), and to supplement this result to get a full circle (ie, from 0 to 359 degrees), analyzing the signs of the projections, you still have to in any case: all inverse functions produce a result within a semicircle (from 0 to 180 or from -90 to +90).  (See about this UPD at the end of the article). <br><br>  We formalize everything said in the real algorithm (with reference to Arduino).  To begin with, we will read the direction indications not every cycle, but every measurement (after the value of the anemometer frequency).  The result obtained in the Gray code (we denoted it as wind_Gray of the byte type, see <a href="https://habr.com/post/404385/">that publication</a> ) we convert to ordinary binary code, and, like the frequency of the anemometer, we place it in the global array, which we declare as wDirAvr [4], where 4 is the number of measurements in the cycle.  We will not paint the conversion of the four-digit Gray code to binary code - this can be done in several ways at the discretion of the programmer and is described in any reference book. <br><br>  This binary code will take values ‚Äã‚Äãfrom 0 to 15, and we will agree that we will count the angles, not as shifted geographers / topographers / navigators, but as normal people who have studied trigonometry in school - counterclockwise.  That is, if the zero value corresponds to the north, then 90 degrees is not east, as in ‚Äúshifted‚Äù ones, but west.  Since we have 16 gradations of direction, the code value must be multiplied by 22.5 (360/16) in order to get the direction in usual degrees of arc. <br><br>  Now the algorithm itself of the simplified vectorial averaging of direction from 4 code values: <br><br><pre><code class="plaintext hljs">. . . . . float wSin=0; // sin float wCos=0; // cos float wind_Rad; //   for (byte i=0; i&lt;4; i++){ wind_Rad= ((float(wDirAvr[i])*22.5)*M_PI/180); //   wSin=wSin+sin(wind_Rad);//    sin wCos=wCos+cos(wind_Rad);//    cos } // wSin=wSin/4;// sin ‚Äì    ,   wCos=wCos/4; // cos wind_Rad = acos(wCos); //     arccos if (wSin&lt;0) wind_Rad=2*M_PI-wind_Rad; //   sin int wind_G = round ((wind_Rad*180/M_PI)/22.5); //    0-15 . . . . .</code> </pre> <br>  In the last line, we convert the average, expressed in radians, into the average, expressed in our code from 0 to 15. You can then convert back to Gray code, then you don't even have to change the program in the main module to display the direction. <br><br>  That's the whole algorithm.  I was afraid that the calculation of cosine-arccosinuses would be slowed down by the weak (in the current 32-bit time) Arduino controller, but nothing happened: he swallowed the code without even blinking ... with a LED, I guess. <br><br>  <b>UPD</b> : The algorithm of the author works in this form for several months without failures.  However, commentators put me on a possible, though extremely unlikely error in practice: if the data contain two groups of measurements that are approximately 180 degrees apart from each other (ie, about 90 and 270 degrees), then the algorithm will produce an erroneous value.  To avoid it, instead of acos (), you should use the atan2 (wSin, wCos) function, which immediately gives the correct result, taking into account the sine and cosine signs (thanks to <a href="https://habr.com/post/423243/">aamonster</a> for the hint).  The line where the mean value of wSin is calculated, should be uncommented, and the line adjusted for the wSin sign is not needed.  Instead, you need to insert a cast to positive values ‚Äã‚Äãof the angle (since atan2 gives values ‚Äã‚Äãfrom pi to -pi): <br><pre> <code class="plaintext hljs">if (wind_Rad&lt;0) wind_Rad=2*M_PI+wind_Rad;</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/423243/">https://habr.com/ru/post/423243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423233/index.html">Artificial Intelligence in the real world</a></li>
<li><a href="../423235/index.html">From Dribbble to Android Motion</a></li>
<li><a href="../423237/index.html">Simple but smart robotic arm</a></li>
<li><a href="../423239/index.html">Creating packages for Kubernetes with Helm: chart structure and templating</a></li>
<li><a href="../423241/index.html">Digium A20 and A25 SIP Phone Review</a></li>
<li><a href="../423247/index.html">What is intelligence?</a></li>
<li><a href="../423249/index.html">Release Rust 1.29</a></li>
<li><a href="../423251/index.html">Personal account from Megafail</a></li>
<li><a href="../423253/index.html">Domestic CAD-platform nanoCAD Plus 10: a universal complex for those who design</a></li>
<li><a href="../423257/index.html">Arguments of functions as bit constants in PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>