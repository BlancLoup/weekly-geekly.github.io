<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HL 2018. Abstract of the report ‚ÄúMake passwords great again! How to defeat brute force and leave hackers with nothing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Ahmadeev Rinat, I Sr. PHP developer. 


 I present to you the summary of the report Make passwords great again! How to defeat bru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HL 2018. Abstract of the report ‚ÄúMake passwords great again! How to defeat brute force and leave hackers with nothing</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt="Passwords are like underwear"></p><br><p>  Hi, Habr!  My name is Ahmadeev Rinat, I Sr.  PHP developer. </p><br><p>  I present to you the summary of the report <a href="https://www.highload.ru/moscow/2018/abstracts/3865">Make passwords great again!</a>  <a href="https://www.highload.ru/moscow/2018/abstracts/3865">How to defeat brute force and leave hackers with nothing</a> from Alexei Yarmishkin from Virgil Security with <a href="https://www.highload.ru/moscow/2018">HighLoad ++ 2018</a> . </p><br><p>  When I went to the report, I was pessimistic.  But since  this is Virgil Security, then I decided to go.  At the beginning, the report seemed to be really captain, and I even began to lose interest, but then, as it turned out, I even learned several new approaches to protecting passwords that are different from regular hashing with salt. </p><br><p>  The report discusses ways to protect passwords ranging from hashes to more modern approaches, such as Facebook's password Onion, Sphinx and Pythia.  At the very end is a new Simple Password-Hardened Encryption Services (PHE). </p><br><p>  I liked the report so much that I prepared a summary.  I recommend everyone to read. </p><a name="habracut"></a><br><p>  Alexey Ermishkin shared <a href="https://www.dropbox.com/s/a4fctwy8nzlasao/Make.Passwords.Great.Again.Ermishkin.v3.pdf%3Fdl%3D0">slides</a> and video of the report in the comments: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y1MQyl13ssc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="konspekt">  Abstract </h2><br><h3 id="vstuplenie">  Introduction </h3><br><p><img src="https://habrastorage.org/webt/wd/sg/tu/wdsgtu8tz1yjoswesm2sjy7gs0k.png" alt="Slide 0. Make passwords great again"></p><br><p>  Hello everyone, good morning everyone!  I am glad to see you all at the Highload conference.  My name is Alexey Ermishkin, I work for Virgil Security. </p><br><p><img src="https://habrastorage.org/webt/p_/dm/2o/p_dm2o99hyouir1mw0qn1nq_k0s.png" alt="VirgilSecurity"></p><br><p>  We develop various cryptographic products for both individual developers and businesses.  Focusing on end-to-end solutions, this is when you do not need to trust the service in order to perform some actions like data transfer, authentication, etc.  Our SDKs are open and available for everyone to use. </p><br><p><img src="https://habrastorage.org/webt/mt/_q/ey/mt_qeyv-o-f8tcltewqjz5bdxze.png" alt="Slide 7. Performance, convenience, security"></p><br><p>  Long since passwords were used as a means of authentication, as a way to get somewhere.  It was a long time before computers appeared.  But with the advent of computers, with the advent of IT-systems, people did not abandon the habit of using passwords.  This has become a very big problem for developers, because they are faced with the problem of how to make systems both comfortable and fast and protected.  Very often, when some two of these aspects are trying to do well, the third is not very good.  If you make the system productive and protected, then it can be inconvenient, etc. </p><br><p><img src="https://habrastorage.org/webt/yf/vy/8n/yfvy8nslfegffzdm8ldboycqpvc.png" alt="Slide 8. What are we protecting ourselves from?"></p><br><p>  So, what are we going to talk about today? </p><br><p>  I will talk about protection from offline attacks.  When passwords get into your databases, after that the user does not control them.  If your database is hacked, it will leak somewhere, then hackers can do anything with it.  Even if you somehow protected the passwords, they can start sorting through them and they don‚Äôt need to interact with anyone, they already have everything for that.  Also, users do not stop using weak passwords.  Password policies are certainly a useful thing, but also not always convenient, i.e.  when even people enter it seems a strong password, the policy still says you need to add a letter or number, then for them it is not convenient.  It is also obvious that the problem is the need to compare what the user entered with what you have in the database.  How to do it in a safe manner?  Well, let's not forget that inside the company there are also people who are not entirely benevolent and would like to protect themselves from them as well. </p><br><h3 id="heshi">  Hashes </h3><br><p><img src="https://habrastorage.org/webt/-w/aj/lj/-wajlj6zqzv9v52a1tm-jyykii0.png" alt="Slide 9. What is wrong with passwords?"></p><br><p> Basically, why passwords are such a sore subject, why is it worth working with them more carefully?  The problem is that the password has a small <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%258D%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BF%25D0%25B8%25D1%258F">entropy</a> .  What is entropy?  This is the amount of information contained in the data, i.e.  for example, in the word Highload 8 letters - 8 bytes, but if we count the entropy, it will not be 64 bits like the entire word, but less than 30 bits.  When they talk about password cracking today, they say that it is possible to crack passwords with entropy no more there or no less many bits in such and such a time.  Those.  even the number of passwords is not counted. </p><br><p><img src="https://habrastorage.org/webt/2u/ry/lh/2urylhxlc1vap1pdvcq8wqubgai.png" alt="Slide 10.1.  Hashes"></p><br><p>  How did people start working with password security?  The first thing that came to mind is to use unidirectional <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">cryptographic hashes</a> . </p><br><p><img src="https://habrastorage.org/webt/ny/ng/3e/nyng3eb-ukqoj_siqeyekl-m6ys.png" alt="Slide 10.2.  Hashes"></p><br><p>  Their remarkable feature is that they cannot be turned back.  Those.  If you transferred some information to this hash, received a value at the output, you cannot get this information back from this value.  But, unfortunately, they are very quickly calculated.  For example, a modern cluster of 4 NVidia cards can iterate over several billion passwords per second.  Those.  if the entropy of your password is less than 40 bits, then a cluster of 4 video cards will pick it up there in a minute, or even less. </p><br><h3 id="raduzhnye-tablicy">  Rainbow tables </h3><br><p><img src="https://habrastorage.org/webt/rw/bd/ku/rwbdku7uc7nlyovcvlp7fh19zbk.png" alt="Slide 11.1.  Rainbow tables"></p><br><p>  In addition, for every tricky hash there is a <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B4%25D1%2583%25D0%25B6%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">rainbow table</a> .  What is this table and how are they made? </p><br><p><img src="https://habrastorage.org/webt/m_/sj/yy/m_sjyylroq0g4wcqjj8stum8yq4.png" alt="Slide 11.2.  Rainbow tables"></p><br><p>  Those.  they take the most popular passwords and combinations of characters that can fit on a hard disk, count hashes for them and put them on some more storage of several terabytes.  When a hash is encountered, it can be not calculated, but it can be found very quickly using these tables and compared with a password that was previously calculated.  Those.  The advantages of tables are that they work very quickly, but you need a lot of space to store them.  Nevertheless, there are tables for the most popular hashes on the Internet, you can download them, or even buy them. </p><br><p>  <em>Note by the author of the abstract: <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B4%25D1%2583%25D0%25B6%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">Wikipedia</a> with the speaker does not agree: "The rainbow table is a special variant of the lookup tables for inverting cryptographic hash functions, using a reasonable compromise mechanism between the table search time and the memory occupied."</em>  <em>Those.</em>  <em>not the hashes of the most popular passwords that fit on the disk are stored there, but simply the hashes of some passwords, the rest are calculated based on those that exist - there are several passwords per record in the table.</em> </p><br><h3 id="sol">  Salt </h3><br><p><img src="https://habrastorage.org/webt/nx/cx/l3/nxcxl3ijlwytnvaumlbt9zlnjdo.png" alt="Slide 12.1.  Salt"></p><br><p>  But again, there is a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BB%25D1%258C_(%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F)">salt</a> on every rainbow table.  What is salt?  This is a random set of bytes, which is added to the password.  It is stored in a table somewhere near the hash and protects against rainbow tables. </p><br><p><img src="https://habrastorage.org/webt/xl/z1/_j/xlz1_j7oasnp6wpvijtlbmpw5n8.png" alt="Slide 12.2.  Salt"></p><br><p>  Those.  people who have got a base with salted hashes in their hands will still have to calculate these hashes.  But the problem is that these hashes are calculated very quickly and the salt does not help much here. </p><br><h3 id="kak-zamedlit-perebor">  How to slow brute force? </h3><br><p><img src="https://habrastorage.org/webt/tb/vh/of/tbvhoftqtm7hlvgibwwvafv9cl4.png" alt="Slide 13.1.  How to slow brute force?"></p><br><p>  The natural way out of this is to slow down the hashes in some way.  How can I do that? </p><br><p><img src="https://habrastorage.org/webt/6j/9c/x0/6j9cx0nof6w-dzgbc3b6nx5qw-8.png" alt="Slide 13.2.  How to slow brute force?"></p><br><p>  The most naive approach is that we take some kind of hashing function, for example, <a href="https://ru.wikipedia.org/wiki/SHA-2">sha256</a> and calculate it iteratively, i.e.  calculate the hash, from this hash again the hash, etc.  You can do this many thousands and even millions of times.  The problem is that if you write such an implementation yourself, then it will most likely be slower than the implementation of people who are professionally engaged in brute force passwords. </p><br><p><img src="https://habrastorage.org/webt/nj/f3/hr/njf3hrodtzqbbu5w3purv-vsm6u.png" alt="Slide 14. Password hashing functions"><br>  <a href="https://ru.wikipedia.org/wiki/Scrypt">SCrypt</a> , <a href="https://ru.wikipedia.org/wiki/Scrypt">Bcrypt</a> , <a href="https://ru.wikipedia.org/wiki/Argon2">Argon2</a> </p><br><p>  And so the cryptographers have come up with several functions that are specifically designed to slow down the search for passwords - they use a large amount of memory and all possible modern instructions of the processor.  If a password protected by such a function falls into the hands of intruders, then they will have to use very powerful hardware. </p><br><p><img src="https://habrastorage.org/webt/-e/ed/gw/-eedgw4f2c-6q3khy9pywdotzwa.png" alt="Slide 15. Argon2"></p><br><p>  For example, the most advanced function of <a href="https://ru.wikipedia.org/wiki/Argon2">Argon2</a> works as follows: in the diagram you can see that there are so many different memory blocks that the hash goes through.  He does this in various ways back and forth, memory is used very intensively, memory is used all.  Optimizing such a function (search speed) is quite difficult. </p><br><p><img src="https://habrastorage.org/webt/eu/gn/u2/eugnu2x_t3tsbyfzqmyesuwlmse.png" alt="Slide 16. Password hashing functions"></p><br><p>  But these approaches also have their disadvantages.  These functions are made specially slow, but they are specially slow, not only for intruders, they will be especially slow for you.  They will load your iron.  These functions are customizable, i.e.  You can choose how much memory will be used to calculate the hash of a single password, up to several gigabytes, how many passes through this memory.  If you screw these parameters very seriously, then your own hardware will suffer and if you have a lot of people log in, then you just have to allocate quite substantial resources for password protection and also simple passwords, well, very simple passwords can still be picked up . </p><br><h3 id="facebooks-password-onion">  Facebook's password Onion </h3><br><p><img src="https://habrastorage.org/webt/jg/ij/6k/jgij6ksfudwqixuwbidyqos8g_y.png" alt="Slide 17. Can you not load the backend?"></p><br><p>  People thought about it and asked whether it was possible to achieve the same properties without loading the backend, without loading their own servers? </p><br><p><img src="https://habrastorage.org/webt/3t/bt/i5/3tbti5mfy7-5smkvkfpkzyw8cq0.png" alt="Slide 18. Facebook's password Onion"></p><br><p>  One of the pioneers in this <a href="https://www.youtube.com/watch%3Fv%3D7dPRFoKteIU">was Facebook</a> .  These lines, which you see, are the historical stages of Facebook, how they protected passwords, at first they were just passwords, then they took the old function <a href="https://ru.wikipedia.org/wiki/MD5">md5</a> , which was cracked a long time ago, then they added salt to it and took the <a href="https://ru.wikipedia.org/wiki/SHA-1">sha1</a> hash, and then interesting thing, they carried the calculation of the function <a href="https://ru.wikipedia.org/wiki/HMAC">hmac</a> (this is a hash with the key) to the remote service. </p><br><p><img src="https://habrastorage.org/webt/at/hg/59/athg59eofneynp9pmmn1ffzdbg8.png" alt="Slide 19. Facebook"></p><br><p>  How it works?  There is a backend, there is a remote service.  There is a secret key on this service.  A person enters the backend, enters his password.  This password is mixed with salt, which lies in the database, is run through the hash and sent to the service.  The service takes its secret key, calculates the hmac function and sends it all back.  On the backend it is put into the base. </p><br><p><img src="https://habrastorage.org/webt/nj/hw/ac/njhwackeuo-kschvhkkvaxstmky.png" alt="Slide 20. Facebook"></p><br><p>  What does this give?  If Facebook has a user base, then there is no sense in sorting passwords in it, because they do not have a remote secret key.  But the problem with the Facebook approach is that if something happens to their remote secret key, they will be in big trouble.  They can't do anything about it, because they use hashes, they use hmac.  They have no way to somehow sort out this situation so that the users would not notice anything and by doing so drive themselves into a corner. </p><br><h3 id="sphinx">  Sphinx </h3><br><p><img src="https://habrastorage.org/webt/_t/kq/nd/_tkqnduhchzryj-sgjt-kqytyo0.png" alt="Slide 21. And can you do better?"></p><br><p>  Cryptographers looked at the whole thing.  They liked the idea of ‚Äã‚Äãusing remote services and they decided to think: is it possible to do even better?  Can you make a similar system, but without the drawbacks that Facebook has endowed it with? </p><br><p><img src="https://habrastorage.org/webt/hh/04/o5/hh04o5poadnr-d4diswhuaferuq.png" alt="Slide 22. Password - number?"></p><br><p> And we decided to approach this problem in the following way: what if the password or the password hash is presented as a number?  If we have the word <code>passw0rd</code> , it consists of 8 bytes.  In almost all programming languages ‚Äã‚Äãthere are eight-byte integer types, i.e.  In principle, this is the same thing.  Those.  8 bytes, the word <code>passw0rd</code> and we can represent it as a normal decimal number.  What does this give us?  This gives us a completely different freedom of action.  We can add passwords or hashes from them, multiply them, turn them into some other numbers.  We can do real serious math operations with them. </p><br><p><img src="https://habrastorage.org/webt/6h/3d/wm/6h3dwmeitk9jftagy1hszcqbmgo.png" alt="Slide 23.1. Sphinx - password manager"></p><br><p>  One of the first systems that used this technology is <a href="http://spies.cs.uab.edu/sphinx-a-password-store-that-perfectly-hides-passwords-from-itself/">Sphinx</a> .  She appeared a couple of years ago.  This is a deterministic password manager.  There are many different programs like <a href="https://ru.wikipedia.org/wiki/KeePass">keepass</a> , where you have a master password and for each site it generates a random one.  But there are also deterministic such things, where you enter your master password, the site you want to visit and it calculates something there and gives a unique password for each site.  But of course, if this master password goes somewhere, then all passwords from your sites will be forever compromised. </p><br><p><img src="https://habrastorage.org/webt/qs/9j/0z/qs9j0z8enfk9_j_p53msuqcxufu.png" alt="Slide 23.2. Sphinx - password manager"></p><br><p>  How did Sphinx approach this problem?  He takes the master password, he takes the domain to which you want to go, runs the whole thing through the hash and turns it into a number.  But in fact, elliptic cryptography is used there, for simplicity, I will explain all this on ordinary numbers with ordinary mathematics.  He turns it into a number (let's call it <code>a</code> ) and what does he do next? </p><br><p><img src="https://habrastorage.org/webt/wx/ba/hk/wxbahkcpmzzmwsaxj1_abbdwrpq.png" alt="Slide 24. Sphinx - password manager, disguise!"></p><br><p>  Absolutely wonderful thing, we can generate a large random number <code>r</code> each time.  If we raise the number <code>a</code> to the power of <code>r</code> , and sometime later we raise this number to the power of the inverse of the number <code>r</code> , then we get back the same number <code>a</code> , right?  Those.  we can disguise something from the beginning, and then unmask it. </p><br><p><img src="https://habrastorage.org/webt/pu/yp/5t/puyp5t7x6yprlu_xyybj4z8llna.png" alt="Slide 25.1. Sphinx - password manager"></p><br><p>  And what does the sphinx do?  Again, there is a user, there is a remote service.  A masked number is sent to this remote service.  There is a private key on the remote service <code>b</code> .  What is he doing?  He sent the number <code>a^r</code> multiplies to his secret key <code>b</code> and sends it back.  ( <em>Note by the author of the abstract: on the slide, the number sent is not multiplied by the private key, but raised to the power of the private key, but the main point here is</em> ).  Since the number <code>r</code> different each time, the remote service cannot say anything about which password and domain were masked, i.e.  every time he sees some different random numbers.  And it multiplies simply to its private key <code>b</code> and sends it back. </p><br><p><img src="https://habrastorage.org/webt/gs/nm/bx/gsnmbxvngd2m2ziqnuqo-mdtney.png" alt="Slide 25.2. Sphinx - password manager"></p><br><p>  The user unmasks what the server sent him and he gets a number - his master password with the domain multiplied by the server's secret key <code>a^b</code> .  It turns out the secret key of the server he does not know, the server does not know what the user sent him, but in the end he also gets some kind of deterministic number.  Each time performing this protocol, the disguise will be different, but the result will always be the same and this result can then be turned back into some kind of password and used to log in to different sites. </p><br><p><img src="https://habrastorage.org/webt/7v/zd/hv/7vzdhvrksyvyg_awii2rkvphdgy.png" alt="Slide 26. Sphinx - password manager"></p><br><p>  Truly wonderful technology.  First, you can generate large passwords, i.e.  It protects against busting.  Secondly, if a hacker gets access to several passwords, he will not be able to say anything about the rest, since  they are generated independently of each other.  Thirdly, if a user saves his master password somewhere, this will not give anything either, because hackers will not have a secret key.  In the fourth, it works very quickly, because  no iterative large hashes are needed here, i.e.  literally 2-3 multiplications are performed and everything works instantly. </p><br><p>  But this system has its drawbacks.  The server with which the user communicates, knows nothing about him.  He just gets some random numbers as input, multiplies them and sends them back.  The client also does not know anything about the server, he sends something somewhere, gets the result, works well.  But if something happens to the service, the user will not be able to say anything about it, he does not have information for this.  The secret key also cannot be changed, nothing can be done with it. </p><br><h3 id="pythia">  Pythia </h3><br><p><img src="https://habrastorage.org/webt/cp/kt/3z/cpkt3zvvpwx7svjbydprtntli5i.png" alt="Slide 27. Is there any better?"></p><br><p>  Can you do better? </p><br><p><img src="https://habrastorage.org/webt/ot/jg/ms/otjgmsc63aic6zb8mpod01tn9jy.png" alt="Slide 28. END-TO-END!"></p><br><p>  Cryptographers looked at this system and thought, is it possible to further improve the system and supplement it with properties that would allow us to say that it corresponds to the principles of end-to-end?  Those.  the client can communicate with the server, but at the same time he can also authenticate him and can trust him to some extent. </p><br><p><img src="https://habrastorage.org/webt/gv/2o/p8/gv2op8fshghvw1rvt0dnqnqwxnw.png" alt="Slide 29.1. Pythia"></p><br><p>  And they came up with a protocol called <a href="http://pages.cs.wisc.edu/~ace/papers/pythia-full.pdf">Pythia</a> . </p><br><p><img src="https://habrastorage.org/webt/kq/wd/in/kqwdin-__0xxfcerqmva6s2vewo.png" alt="Slide 29.2. Pythia"></p><br><p>  He was made a wonderful man <a href="http://pages.cs.wisc.edu/~ace/">Adam Everspaugh</a> with his colleagues.  What makes it unique?  First, the service knows who enters the password, i.e.  The user ID is transmitted to the server by the password.  It can be some random id-box that lies next to it, or just a user name.  No matter.  But the service knows about it.  But it‚Äôs not enough that the server does not just know, it can strictly mathematically prove that it is he. </p><br><p><img src="https://habrastorage.org/webt/pf/lo/zf/pflozf9qji8nzq_nhpswlqd-3xa.png" alt="Slide 30.1. Pythia"></p><br><p>  How it works?  There is a backend (some kind of web service, site) and there is a Pythia service.  What does the backend do and what does the service do?  There is a private key <code>k</code> on the service, but it also transmits its public key to the backend.  The backend to the service sends not only the masked number <code>a^r</code> , as in the Sphinx protocol, but also sends some kind of user ID ( <code>UserID</code> ).  The service multiplies the user ID and password to its secret key and the result <code>(UserID, a)^(r*k)</code> sends the backend.  He also sends back a certain <code>Proof</code> , which can be used by the backend to check the server, that it was not hacked, that it responds as it should. </p><br><p><img src="https://habrastorage.org/webt/re/qr/x2/reqrx276lka5gxfal99x0_l9esy.png" alt="Slide 30.2. Pythia"></p><br><p>  Then there is a unmasking and the number <code>y</code> which turns out as a result is put in a DB.  In the database, we have not just some kind of hash, but a number, a point of an elliptic curve. </p><br><p><img src="https://habrastorage.org/webt/xx/qc/jt/xxqcjtbljojosjg0ssvhptf3oj0.png" alt="Slide 31. Pythia"></p><br><p>  Here are some interesting points: </p><br><ul><li>  The ability for the server to combine a user ID and password into one number.  This is called bilinear operation or bilinear pairing.  This is a relatively new mathematics, which not so long ago began to use.  She has all the properties of a new mathematician in that not even 30 years have passed in order for everyone to be convinced that everything is fine with this. </li><li>  But the <code>Proof</code> that sends the service is a rather old technology.  This is called <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2585%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25A8%25D0%25BD%25D0%25BE%25D1%2580%25D1%2580%25D0%25B0">the Schnorr protocol</a> .  The generation of a public key is the multiplication of the base point by some kind of secret key.  The Schnorr protocol proves that the secret key that was used to generate the public key was used to multiply the user's password by the same number too.  This protocol has long been there, it is used in many places and it allows us to prove it.  This is called a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D1%2581_%25D0%25BD%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D1%258B%25D0%25BC_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B3%25D0%25BB%25D0%25B0%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">zero-disclosure proof</a> - the server does not show its public key, but at the same time it says that the operation that I performed, it was performed with the private key that we initially agreed on. </li></ul><br><p><img src="https://habrastorage.org/webt/jz/pg/lo/jzpglodcswcwxprayrpud8semws.png" alt="Slide 32.1. Pros of Pythia"></p><br><p>  What are the advantages of this system? </p><br><p><img src="https://habrastorage.org/webt/xn/dg/zg/xndgzgr-to_dgnypnwarbyxengg.png" alt="Slide 32.2. Pros of Pythia"></p><br><p>  And she has not a lot of them. </p><br><ul><li>  The system does not load the backend.  Because the backend is all that does - it turns the password into a number, masks it, sends it, and then unmasks the same result. </li><li>  If a base with such numbers is stolen from you, then there is no sense in sorting passwords without a private key either. </li><li>  The Pythia service can block brute force attempts, which means the backend does not have to do this in principle.  If he sees that under the same user ID they are trying to perform this transformation operation several times, he can simply cut and block everything according to the rate limit. </li><li>  Thanks to the disguise, the service knows nothing about the password.  Every time a new random number is sent to him.  The constant is only the user ID. </li><li>  Thanks to ZKP (Zero-knowledge proof), the backend always knows that it was the very service that he had originally addressed to him answered. </li><li>  If you have a base with hashes and salt for example, then you can migrate to this solution seamlessly for users.  They may even not notice.  Instead of the user's password, you take his hash, drive it into Pythia and then simply use this protocol, get the number <code>y</code> , put it again in your database.  The hash can then be deleted.  Each time a user logs on to your system, this protocol will be executed, a number will be the result that you compare with what is in the database.  The authentication system itself will remain unchanged, since  users will log in as well as log in, with the same passwords, even weak ones.  In this case, the system will be much more secure. </li></ul><br><p><img src="https://habrastorage.org/webt/2i/63/ja/2i63jae0xiucsx-dqailxoaqiuw.png" alt="Slide 33.1. That's not all"></p><br><p>  But this is not all buns. </p><br><p><img src="https://habrastorage.org/webt/oa/dy/h9/oadyh9nurjtlv5qdbgo8f2xfcui.png" alt="Slide 33.2. That's not all"></p><br><p>  One of the main features is that even if the Pythia service itself is hacked, you can generate a new private key.  We also have a number in the database, not a hash.  If we represent the old key as the number <code>k</code> , and the new one as the number <code>k'</code> , then we can calculate the number, which is called the Update token.  To do this, we multiply the new number by the number opposite to the old one.  And with this update token you can go through the database for each user and multiply this number <code>y</code> by the update token.  After you have done this, your system continues to work with the new private key on the remote service.  This all happens instantly.  If trouble happened, your password database was stolen from you, you click on your finger to release the update token, and what hackers stole from you becomes instantly useless.  You just quietly go through your background in all the records, update them and they work with the new secret key for you.  Users generally do not even notice.  Those.  seamless update and instant password base invalidation; this is one of the key innovative features of this system. </p><br><p><img src="https://habrastorage.org/webt/uu/cb/_z/uucb_z0ikld1bufittz0asq5m84.png" alt="Slide 34.1. Bonus"></p><br><p>  But that's not all. </p><br><p><img src="https://habrastorage.org/webt/vr/jo/3k/vrjo3kpwbw1xuzdr6wklxmwkrgw.png" alt="Slide 34.2. Bonus"></p><br><p>  The number that lies in the database is large <code>y</code> , it is in principle large and looks rather pseudo-random, i.e.  it's not easy to pick it up.  If we transfer the functionality that we have on the backend, for example, to client devices, to phones, then we can use this one to generate keys.  We called this thing BrainKey.  This means that the user enters a password somewhere on the phone, also masks it, sends it to a remote service.  The service returns some number <code>y</code> and then this <code>y</code> can be used to generate already some asymmetric keys.  Thus, a user can get a key pair from his password.  It is used in every <a href="https://en.bitcoin.it/wiki/Brainwallet">BrainWallet</a> .  This is when you enter a password and get a bitcoin wallet generated for it.  But not only cryptocurrency is limited to this application, it is a digital signature, and some backups, and account recovery, i.e.  wherever asymmetric cryptography is used, where asymmetric keys are needed.  All this can be used, but at the same time a key pair, and, depending on the need, you can generate as many as you like.  So they will all depend on the user's password, and it is very convenient. </p><br><p><img src="https://habrastorage.org/webt/sy/cw/nl/sycwnl1rpbmtpsc_0ddxi3fjlx0.png" alt="Slide 35.1. Minuses?"></p><br><p>  In a barrel of honey, as it were, not without a spoon of tar. </p><br><p><img src="https://habrastorage.org/webt/wx/jw/an/wxjwanacuusmfnb_ptce1peh_cg.png" alt="Slide 35.2. Minuses?"></p><br><p>  And the features of this technology is that it is very new.  It uses an elliptic curve, which is for bilinear operations ( <a href="https://z.cash/blog/new-snark-curve/">BLS12-381</a> ).  Mathematics itself already exists for some time, but this particular curve, which is used in particular in our implementation, is used except for us only in <nobr>ZCash</nobr> .  Accordingly, the libraries that use this new math can be counted on the fingers of one hand.  To bring this into production, you need to spend a certain amount of time and effort.  Nevertheless, the industry does not stand still and all these disadvantages are temporary.  As a consequence of the first two properties, the speed of these bilinear operations is not very consistent with the modern mathematics, elliptical in particular, which we now all use when we use the TLS protocol, when we use some sites.  This is somewhere several hundred operations on the service per core.  In fact, this did not stop us and we spring up this protocol, released it in <a href="https://pythia.virgilsecurity.com/">production</a> and translated all our records, protected them using this protocol.  In principle, we are satisfied with the performance for our current tasks, if necessary, we will raise another node with the Pythia service and, in principle, we can play with all this. </p><br><h3 id="phe">  PHE </h3><br><p><img src="https://habrastorage.org/webt/hv/1e/1l/hv1e1lslzyk31hgsw2fu5sffk_o.png" alt="Slide 36. Is it even better?"></p><br><p>  But we are thinking about whether it can be done even better?  Is it possible to achieve the properties that Pythia provides, using mathematics like yesterday?  Not tomorrow, not today, but even yesterday, which has been used for many years. </p><br><p><img src="https://habrastorage.org/webt/6r/rn/0x/6rrn0xaorj5qjkyuk2hhamqaqyk.png" alt="Slide 37.1. Simple Password-Hardened Encryption Services (PHE)"></p><br><p>  And literally in July of this year, scientists released a new protocol called <a href="https://virgilsecurity.com/wp-content/uploads/2018/11/PHE-Whitepaper-2018.pdf">Simple Password-Hardened Encryption Services</a> or abbreviated PHE. </p><br><p><img src="https://habrastorage.org/webt/hx/o5/zv/hxo5zveu2y75lmqm-t3pqknaq0e.png" alt="Slide 37.2. Simple Password-Hardened Encryption Services (PHE)"></p><br><p>  This is <a href="https://dl.acm.org/author_page.cfm%3Fid%3D99659285884%26coll%3DDL%26dl%3DACM%26trk%3D0">Russell Lai</a> , a scientist from Europe. </p><br><p>  What is the advantage of this service?  First, it uses the standard <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F">P-256</a> curve, which is used everywhere, in all browsers, products, everywhere by default, which has been around for many years.  Secondly, this thing works about 10 times faster than Pythia and uses standard primitives.  It seems to be difficult, but it can be implemented with my own hands, without using any incomprehensible libraries.  You can use <a href="https://ru.wikipedia.org/wiki/OpenSSL">OpenSSL</a> , or <a href="https://ru.wikipedia.org/wiki/Bouncy_Castle">Bouncy Castle</a> , whatever. </p><br><p><img src="https://habrastorage.org/webt/el/f0/ho/elf0hoawmvsekav9jgvkqxp0_ju.png" alt="Slide 38. Simple Password-Hardened Encryption Services (PHE)"></p><br><p>  But it works a little differently.  Again, there is a backend, there is a PHE service.  On the back end there is a public key, on the service there is a private key <code>y</code> .  Unlike Pythia, the registration process and password verification process takes place a little differently.  When a new user comes to the service and wants to register, what does the backend do?  From the beginning, he asks the PHE service, please give me some data that I can use for registration, some Enrollment record.  The service says OK and answers the backend with the following things.  It generates some random 32-byte salt ( <code>sNonce</code> ).  Based on this salt and its private key y, it generates two numbers, let's call them <code>C0</code> and <code>C1</code> .  It also generates evidence ( <code>Proof</code> ) that these two numbers or there 2 points were generated using his private key <code>y</code> , using the Schnorr protocol (as in previous protocols).  Backend <code>Proof</code> checks.  There is no password yet.  What does the backend do?  He, for his part, also has his own personal client private key <code>x</code> and, having received the password from the user, does approximately the same thing that the service did, only adds another password there.  He takes a random <code>cNonce</code> (random client salt) password and again generates 2 numbers <code>HC0</code> and <code>HC1</code> .  Why 2?  Because the first <code>HC0</code> used for authentication, and in the second number <code>HC1</code> , we also mix in some random number <code>M</code> multiplied by the private key <code>x</code> ( <code>MC</code> ).  The <code>M</code> number is also 32 bytes in size and can later be used to encrypt user data (we have the same Encryption Services) ( <em>note by the author of the abstract: the encryption key in this case will be <code>MC</code></em> ).  The <code>MC</code> number will be available as a key only after the user has entered the correct password.  It turns out at the registration stage, you can generate not only an entry for authorization, but also an encryption key, unique for each user, which can encrypt his profile, some data, something else.  Then the backend simply adds what the service sent and what he did ‚Äî adds these points and gets <code>T0</code> and <code>T1</code> .  In the first case, it adds two ( <code>C0 + HC0</code> ), and in the second three ( <code>C1 + HC1 + MC</code> ).  And puts in the base 2 salts ( <code>sNonce</code> , <code>cNonce</code> ), with the help of which these numbers and 2 numbers ( <code>T0</code> and <code>T1</code> ) were obtained, which resulted in the sum. </p><br><p><img src="https://habrastorage.org/webt/ly/9d/fj/ly9dfjao1laxszgo9okoovsvzjy.png" alt="Slide 39. PHE Login"></p><br><p>  Accordingly, the user authentication process occurs in reverse order.  The user enters his password on the backend.  The backend calculates the <code>HC0</code> and from what it has in the database, subtracts the <code>HC0</code> from <code>T0</code> and sends the resulting <code>C0</code> to the service along with the server salt.  The service, knowing the server salt, calculates the same point and looks at it, it coincides with the fact that it sent a backend or not, if it matches, then the password is correct and you can answer it with the second number <code>C1</code> , which it will subtract with <code>HC1</code> from <code>T1</code> and get the encryption key.  Thus, the password for the PHE service does not even go away.  He doesn't even leave the backend.  It is in the form of some points multiplied by the private key of the backend.  It doesn‚Äôt even exist as such, but the remote service can make a strict conclusion about whether this password is correct or not and further prove that he performed all calculations using his private key <code>y</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/7-/op/bi7-opjxk_7cwvgb4lm4wkwgtbi.png" alt="Slide 40.1. PHE Features"></p><br><p>  What features does this system have? </p><br><p><img src="https://habrastorage.org/webt/2t/ar/rm/2tarrmmsr5j4sgk5zlrtcsu1eyc.png" alt="Slide 40.2. PHE Features"></p><br><p>  Password as I said does not leave the backend.  But unlike Pythia, you need a private key on the backend.  Well, need and need, save somewhere.  PHE has all the basic functions of Pythia: </p><br><ul><li>  You can also issue update token if you have something wrong with the private key; </li><li>  You can also go through the entire database, update and everything will be as it was; </li><li>  brute force protection; </li><li>  the service knows nothing about the password; </li><li>   (Pythia , ,  ,    ,  PHE ); </li><li>     . </li></ul><br><p><img src="https://habrastorage.org/webt/vq/_m/yr/vq_myrj2venkvtkjqaij3ujapd4.png" alt=" 41. ..."></p><br><p>      ... </p><br><p><img src="https://habrastorage.org/webt/hp/s9/_t/hps9_tr6ha4ysxt6szxsdhseuoe.png" alt=" 42. passw0rd.io"></p><br><p> ‚Ä¶      .      .   <a href="http://passw0rd.io/">passw0rd.io</a>  .    password  ,    18-        ,    ,    zero trust, ..    .     , , ..  <a href="https://ru.wikipedia.org/wiki/Let%25E2%2580%2599s_Encrypt">Let's encrypt</a> .  ,   .    CLI     ,   .       <a href="https://github.com/passw0rd">2 SDK</a> ,  GO  .Net,     . </p><br><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt=" 43. Passwords are like underwear"></p><br><p>           : </p><br><ol><li>    . </li><li>      . </li><li>     . </li></ol><br><p><img src="https://habrastorage.org/webt/d4/nh/d4/d4nhd4nzbnhgfq21j-8yqs1ps0m.png" alt=" 44. "></p><br><ul><li> <a href="https://virgilsecurity.com/">VirgilSecurity.com</a> </li><li> <a href="https://twitter.com/virgilsecurity">@VirgilSecurity</a> </li><li> <a href="https://github.com/VirgilSecurity">GitHub.com/VirgilSecurity</a> </li><li> <a href="https://noisesocket.org/">NoiseSocket.com</a> </li><li> <a href="https://passw0rd.io/">passw0rd.io</a> </li></ul><br><p>     ,             . </p><br><h3 id="voprosy"> ? </h3><br><p> <strong> 37. ?</strong> </p><br><p><img src="https://habrastorage.org/webt/z_/t0/05/z_t005mcdxnznvcinnqsg-z750a.png" alt=" 45. ?"></p><br><p>     . </p><br><p> Q: ,    !   .     ,      Pythia       update token,        ?        private key  .         update token?  Or not? <br> A: , update token-     . <br> Q:    .      -        update token-,       Private key         ? <br> A: ,    update token-,     ,  - ,   ,  ,    update token.     , ..   . <br> Q: , ,    ,   . <br> A: ..     . </p><br><p> Q: ,   ,     ,     -   Pythia  -    ,       ,     ,   ? <br> A:  . <br> Q:      ? <br> A: ,      Pythia   .  Those.     ,        . <br> Q: ( )  bcrypt      ? <br> A: ,      ,   ,      . </p><br><p> Q:  ,    .      ?  , ‚Ä¶ <br> A: password   <br> Q: password  ?  The fire!  At all. <br> A: 123456   ,        12345, 123456. <br> Q: .    Pythia  ,  PHE   . <br> A:    ,           . <br> Q: .   .         ?  production   ? <br> A:  .  BUT!   Pythia. <br> Q:   Pythia,    , ? <br> A:  . <br> Q:   ,  ? <br> A:   . <br> Q: , , ! <br> A:     SDK,     . </p><br><p> Q: ,  ,  ,     , ..   -  ,     ?    ?    ? <br> A: ,    ,    , ..       PHE,    ,    5   2 ,   2   5  .    ,     .    PHE ( ,    ),    ,     10 ,    . <br> Q: ..      - ,      -  ?   ? <br> A:   .     rate limiting,   ,                . <br> Q: ..             , ? <br> A: . </p><br><p> Q: . , ..       Pythia      (),          , ? ? <br> A: ,    ,     . <br> Q:  ,   update   ? <br> A: ,    Pythia  ,         ,  -     -  ,   ,        ,     ) </p><br><p> A: ?  Thank you all so much!   .     , ,   PHE,   , . </p><br><h2 id="vyvody">  findings </h2><br><p>      PHE (    )          + ‚Äî    (  ,   ,  )      (     ).   PHE      ,                   . </p><br><p>         : </p><br><ul><li>       ( <strong></strong> )   ; </li><li>              (      ). </li></ul><br><p>  ,         . </p><br><p>    <a href="https://habr.com/users/scratch/" class="user_link">Scratch</a>   Virgil Security  ,    ,      ! </p><br><p>      (  )? </p><br><p> <strong>UPD</strong> :   <a href="https://habr.com/users/scratch/" class="user_link">Scratch</a> .          .     ,     .    . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/434708/">https://habr.com/ru/post/434708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434698/index.html">Pessimism about multithreading</a></li>
<li><a href="../434700/index.html">Benefits of following styleguides when developing Angular applications</a></li>
<li><a href="../434702/index.html">Why do I get nervous about the failures of modern SSD</a></li>
<li><a href="../434704/index.html">The reasons for the decline in the cost of mobile traffic in Russia and the forecast for 2019</a></li>
<li><a href="../434706/index.html">UDB. What is it? Part 3. Datapath FIFO</a></li>
<li><a href="../434710/index.html">Blog RUVDS on Habr√©: three years</a></li>
<li><a href="../434712/index.html">Third Turing Test in Russian</a></li>
<li><a href="../434716/index.html">Moving to the data center: Preparation</a></li>
<li><a href="../434718/index.html">Two years later, I still miss the headphone jack</a></li>
<li><a href="../434720/index.html">The reverse side of zero knowledge: backdoor in zk-SNARK, which can not be detected</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>