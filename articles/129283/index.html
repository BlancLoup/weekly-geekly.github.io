<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dispose pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúYou shouldn‚Äôt follow some idiom just because everything is done this way or so it‚Äôs written somewhere‚Äù 

 Thoughts of the author of the article while...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dispose pattern</h1><div class="post__text post__text-html js-mediator-article">  <i>‚ÄúYou shouldn‚Äôt follow some idiom just because everything is done this way or so it‚Äôs written somewhere‚Äù</i> <i><br><br></i>  <i>Thoughts of the author of the article while reading and refactoring someone else's code</i> <br><br>  It will not be a secret to anyone that the .NET platform supports automatic memory management.  This means that if you create an object using the <b>new</b> keyword, then you will not have to take care of it yourself.  The garbage collector will determine the ‚Äúreachability‚Äù of the object, and if there are no root links to the object, it will be released.  However, as soon as it comes to resources, such as a socket, an unmanaged memory buffer, an operating system descriptor, etc., the garbage collector, by and large, washes his hands and the entire headache of working with such resources falls on the developer‚Äôs shoulders. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what about the finalizers?  - you ask.  Well, yes, there is such a thing, finalizers are really meant for freeing resources, but the problem is that the time of their call is not deterministic, which means that no one knows when they will be called and whether they will be called at all.  And the order of calling finalizers is not defined, so when you call the finalizer, some ‚Äúparts‚Äù of your object can already be ‚Äúdestroyed‚Äù, since their finalizers have already been called.  In general, finalizers - they exist, but this is more like a "safety cable", rather than a normal resource management tool. <br><a name="habracut"></a><br><br><h4>  Idiom raii </h4><br><br>  In C ++, in which there are no built-in tools for automatic memory management in addition to smart pointers, the pattern (or idiom) has long been actively used for the timely release of resources (*).  This idiom is called Resource Acquisition Is Initialization (RAII - Resource Acquisition Is Initialization) and is as follows.  The resource is captured in the constructor and released in the destructor, and since destructors are called automatically, no additional effort is needed to manage the resources. <br><br>  Not surprisingly, the same idea of ‚Äã‚Äãdeterministic resource management pumped into other more "smart" and "managed" environments, such as .NET or Java (**) as an <b>IDisposable</b> interface (in C #) and a <b>dispose</b> method (in Java) .  But since these environments are smarter compared to the old C ++, and the main problems associated with memory management are solved in them, this idiom moved not too well.  No, do not misunderstand me, it moved quite successfully, but for this you need to use the <b>using</b> block (for C #) or <b>try</b> <b>-</b> <b>with</b> <b>-</b> <b>resources</b> <b>statement</b> (in Java 7), if you ‚Äúforget‚Äù to use them, then from your deterministic release of resources will not remain a trace. <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     using</font> <br> <font color="#0000ff">using</font> ( <font color="#2B91AF">FileStream</font> file = <font color="#2B91AF">File</font> .OpenRead( <font color="#A31515">"foo.txt"</font> )) <br> { <br> <font color="#008000">//       </font> <br> <font color="#0000ff">if</font> (someCondition) <font color="#0000ff">return</font> ; <br> <font color="#008000">//         using</font> <br> } <br> <font color="#008000">//  ,  -     using?</font> <br> <font color="#2B91AF">FileStream</font> file2 = <font color="#2B91AF">File</font> .OpenRead( <font color="#A31515">"foo.txt"</font> ); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  However, this is not the only difficulty that arises when working with resources in .NET.  As we will see shortly, using the usual method to free up resources has some other problems.  Since the <b>Dispose</b> method frees resources, the finalizer call is no longer needed and it needs to be canceled; in addition, the <b>Dispose</b> method destroys the class invariant, which allows the user to obtain a destroyed or partially destroyed object.  And this requires additional checks both in the <b>Dispose</b> method and in all public methods of the class. <br><br>  All this led to the fact that the relatively simple idiom RAII resulted in a .NET platform in a pattern that is called the ‚ÄúDispose pattern‚Äù.  However, before proceeding to its consideration, let's consider two types of resources that exist on the .NET platform: managed and unmanaged resources. <br><br><h4>  Managed and Unmanaged Resources </h4><br><br>  There are two types of resources in .NET: managed and unmanaged.  Moreover, it is quite simple to distinguish them: only ‚Äúraw‚Äù resources, such as <b>IntPtr</b> , raw socket descriptors or something like that, belong to unmanaged resources;  if, using the RAII idiom, this resource was packed into an object that captures it in the constructor and releases it in the <b>Dispose</b> method, then such a resource is already managed.  In essence, managed resources are ‚Äúsmart shells‚Äù for unmanaged resources, to free them you don‚Äôt need to call some ingenious functions, but simply call <b>Dispose on</b> the <b>IDisposable</b> interface. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> NativeResourceWrapper : IDisposable <br> { <br> <font color="#008000">// IntPtr ‚Äì   </font> <br> <font color="#0000ff">private</font> <font color="#2B91AF">IntPtr</font> nativeResourceHandle; <br> <font color="#0000ff">public</font> NativeResourceWrapper() <br> { <br> <font color="#008000">// ¬´¬ª      </font> <br> nativeResourceHandle = AcquireNativeResource(); <br> } <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() <br> { <br> <font color="#008000">//   ,  ,   -</font> <br> <font color="#008000">//  </font> <br> ReleaseNativeResource(nativeResourceHandle); <br> } <br> <font color="#008000">//    ,      </font> <br> ~NativeResourceWrapper() {...} <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Thus, any object can own two types of resources: it can directly contain an unmanaged resource (for example <b>,</b> <b>IntPtr</b> ) or it can contain a link to a managed resource (for example, <b>NativeResourceWrapper</b> ), and in both cases an object containing one of these resources, itself becomes a managed resource.  This may not seem very important, but it is very important to understand the difference between the two types of resources, since it is necessary to work with them in different ways. <br><br><h4>  Dispose pattern </h4><br><br>  So, we know that an object can own two types of resources: <b>managed</b> and <b>unmanaged</b> ;  as well as the fact that we have two ways to free resources: <b>deterministic</b> , using the <b>Dispose</b> method and <b>non-deterministic</b> , using the finalizer (***).  And now let's see how to live with all this good and, most importantly, how to release this good. <br><br>  The idea behind the Dispose pattern is as follows: let's put the entire logic of resource release into a separate method, and we will call it from the <b>Dispose</b> method and from the finalizer, while adding a checkbox to tell us who caused this method.  Since this simple idea contains a fairly large number of details, let's describe the Dispose pattern by items. <br><br>  1. The class containing managed or unmanaged resources implements the <b>IDisposable</b> interface <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> Boo : IDisposable { ... }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  2. The class contains the <b>Dispose</b> method <b>(</b> <b>bool</b> <b>disposing</b> <b>)</b> , which does all the work of freeing resources;  The <b>disposing</b> parameter indicates whether this method is called from the <b>Dispose</b> method or from the finalizer.  This method must be <b>protected</b> <b>virtual</b> for non-sealed classes and <b>private</b> for sealed classes. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//  -sealed </font> <br> <font color="#0000ff">protected</font> <font color="#0000ff">virtual</font> <font color="#0000ff">void</font> Dispose( <font color="#0000ff">bool</font> disposing) {} <br> <br> <font color="#008000">//  sealed </font> <br> <font color="#0000ff">private</font> <font color="#0000ff">void</font> Dispose( <font color="#0000ff">bool</font> disposing) {} <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  3. The Dispose method is always implemented as follows: <b>Dispose</b> <b>(</b> <b>true</b> <b>)</b> is called first, and then the <b>GC</b> method call can follow <b>.</b>  <b>SuppressFinalize</b> <b>()</b> , which prevents the finalizer from being called. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() <br> { <br> Dispose( <font color="#0000ff">true</font> <font color="#008000">/*called by user directly*/</font> ); <br> GC.SuppressFinalize( <font color="#0000ff">this</font> ); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  <b>GC</b> method <b>.</b>  <b>SuppressFinalize</b> <b>()</b> , first, should be called after calling <b>Dispose</b> <b>(</b> <b>true</b> <b>)</b> , and not before it, because if <b>Dispose</b> <b>(</b> <b>true</b> <b>)</b> ‚Äúfalls‚Äù with an exception, then the finalizer will not be canceled.  Secondly, <b>GC</b> <b>.</b>  <b>SuppressFinalize</b> <b>()</b> must be called even for classes that do not contain finalizers, since a finalizer may appear to its successor (that is, we must call the <b>GC</b> method <b>.</b> <b>SuppressFinalize</b> <b>()</b> in all non-sealed classes). <br><br>  4. The <b>Dispose</b> method <b>(</b> <b>bool</b> <b>disposing</b> <b>)</b> contains two parts: (1) if this method is called from <b>Dispose</b> (i.e. the <b>disposing</b> parameter is <b>true</b> ), then we release the managed and unmanaged resources and (2) if the method is called from the finalizer garbage collection time ( <b>disposing</b> parameter is <b>false</b> ), then we release only unmanaged resources. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> Dispose( <font color="#0000ff">bool</font> disposing) <br> { <br> <font color="#0000ff">if</font> (disposing) <br> { <br> <font color="#008000">//    </font> <br> } <br> <br> <font color="#008000">//   </font> <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  5. (OPTIONAL) A class may contain a finalizer and call <b>Dispose</b> <b>(</b> <b>bool</b> <b>disposing</b> <b>)</b> from it, passing <b>false</b> as a parameter. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">~Boo() <br> { <br> Dispose( <font color="#0000ff">false</font> <font color="#008000">/*not called by user directly*/</font> ); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Do not forget that the finalizer can be called even for partially constructed objects if the constructor of this class throws an exception.  So the cleanup code of unmanaged resources must take into account that resources have not yet been captured (****). <br><br>  6. (OPTIONAL) The class may contain the <b>bool</b> <b>_</b> <b>disposed field</b> , which indicates that object resources have already been released.  Disposable classes should quietly allow a re-call of the <b>Dispose</b> method, and also generate an exception when accessing any other public methods or properties (since the object invariant has already been destroyed). <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> Dispose( <font color="#0000ff">bool</font> disposing) <br> { <br> <font color="#0000ff">if</font> (disposed) <br> <font color="#0000ff">return</font> ; <font color="#008000">//   </font> <br> <font color="#008000">//  </font> <br> disposed = <font color="#0000ff">true</font> ; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> SomeMethod() <br> { <br> <font color="#0000ff">if</font> (disposed) <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ObjectDisposedException(); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  7. (OPTIONAL) A class can inherit from <b>CriticalFinalizerObject</b> , if the previous six points are few and you want more exotic.  Inheritance from this class gives you additional guarantees: <br><br><ol><li>  The finalizer of such classes is compiled by the JIT compiler immediately when constructing an instance, and not postponed as necessary.  This makes it possible for the finalizer to succeed even in the case of an acute lack of memory. <br></li><li>  As we have said, the CLR does not guarantee the order of calling finalizers, which makes it impossible to access other objects containing unmanaged resources inside the finalizer.  However, the CLR guarantees that the finalizers of ‚Äúmere mortal‚Äù objects will be called <b>before the</b> heirs of the <b>CriticalFinalizerObject</b> .  This makes it possible, in particular, from the finalizers of your classes (if they do not inherit from <b>CriticalFinalizerObject</b> ) to access the <b>SafeHandle</b> field, which will definitely be released later. <br></li><li>  Finalizers of such classes will be called even in case of an emergency unloading of the application domain. <br></li></ol><br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//   ,    ?</font> <br> <font color="#0000ff">class</font> Foo : CriticalFinalizerObject {} <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Pragmatic look at the Dispose pattern </h4><br><br>  If it seemed to you that working with resources in .NET is unjustifiably complex, then I have two news on this: one is good and the other is not very good.  The ‚Äúnot so good‚Äù news is that working with resources is even more difficult than described here (*****), but the good thing is that in most cases all this complexity will hardly touch us. <br><br>  All the complexities of implementing a Dispose pattern are associated with the assumption that the same class (or class hierarchy) can simultaneously contain both managed and unmanaged resources.  But let's think about it, why should we even need to store unmanaged resources directly in business logic classes?  But what about the notorious Single Responsibility Principle (SRP) and <b>Common Sense</b> ?  The RAII idiom, described earlier, has been used successfully for decades and is intended just for such cases: <b>if you have an unmanaged resource, then instead of working with it directly, wrap it in a managed shell and work with it</b> . <br><br>  If you look at the .NET Framework, you can see that it uses exactly this approach: a shell is created for all resources that hides all the complexity of working with resources inside, leaving the user to simply call the <b>Dispose</b> method to explicitly clean up the resources (well, the finalizer, just in case).  In addition, for the majority of unmanaged operating system resources, such shells have already been made, and there is no need to reinvent the wheel. <br><br>  All this I lead to the fact that you <b>do not need to mix in your code business logic and logic for working with unmanaged resources</b> .  Both that, and another is rather difficult in itself and deserves a separate class.  It turns out that this pattern is ‚Äúoptimized‚Äù for a very rare case (that a class can contain both managed and unmanaged resources), while making the most common case where a class contains only managed resources, very inconvenient in implementation and maintenance. <br><br><h4>  Simplified version of the Dispose pattern </h4><br><br>  If you and I know that no one is going to mix managed and unmanaged resources in one place, so why not implement this in code explicitly?  We can leave the <b>Dispose</b> method and instead of the additional Dispose method with a completely vague boolean parameter, add a virtual method <b>DisposeManagedResources</b> , whose name will clearly state that we have to release the managed resources.  The access modifier of this method should be similar to our <b>Dispose (</b> <b>bool)</b> method, i.e.  <b>protected</b> <b>virtual</b> for non-sealed classes or <b>private</b> for sealed classes. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> SomethingWithManagedResources : IDisposable <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() <br> { <br> <font color="#008000">//  Dispose(true)    GC.SuppressFinalize()</font> <br> DisposeManagedResources(); <br> } <br> <br> <font color="#008000">//  ,       </font> <br> <font color="#0000ff">protected</font> <font color="#0000ff">virtual</font> <font color="#0000ff">void</font> DisposeManagedResources() {} <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  At first glance, such an approach may seem too pragmatic, but judge for yourself: in the <a href="http://sergeyteplyakov.blogspot.com/2009/06/framework-design-guidelines-2nd-edition.html">Framework Design Guidelines</a> book, two dozen pages are devoted to the Dispose of the pattern, while its authors recommend adding finalizers only when absolutely necessary.  At the same time, we all know that mixing two types of resources in one class is bad, but still we follow a pattern that encourages it and does not prohibit it. <br><br><h4>  <b>Conclusion</b> </h4><br><br>  When developing library classes or business classes that will be used in a dozen other projects, it is quite reasonable to follow all the principles described above.  Other requirements are imposed on reusable code, and when designing them, other principles must be followed: ease of use and extensibility of such classes are much more important than maintenance costs. <br><br>  If you are designing business logic classes or simple libraries with a limited number of users, then you can not fool your head with ‚Äúcanons‚Äù, but use a simplified version of this pattern that works only with managed resources. <br><br>  ------------------------------ <br><br>  (*) In C ++, unlike C #, memory is also a resource.  Therefore, the RAII idiom in C ++ is used both for freeing dynamically allocated memory and for freeing any other resources, such as OS descriptors or sockets. <br><br>  (**) In Java 7, a construction similar to that <b>using</b> the C # language has finally appeared: try-with-resource statement <br><br>  (***) Unfortunately, the same syntax (tilde followed by the name of the class) is used for finalizers in C #, which is used for destructors in C ++.  But the semantics of the destructor and the finalizer are very different, because the destructor implies the deterministic release of resources, but the finalizer is not. <br><br>  (***) Yes, this is another difference in the behavior of .NET and the C ++ language.  In the latter, the destructor is called only for a fully constructed object, and destructors are called for all of its fully constructed fields. <br><br>  (****) Here, for example, I did not talk about how to get a ‚Äúresource leak‚Äù when exceptions occur or about problems with changeable types that implement the <b>IDisposable</b> interface.  I already wrote about this earlier in the notes ‚Äú <a href="http://sergeyteplyakov.blogspot.com/2011/08/blog-post_15.html">Guarantees of security of exceptions</a> ‚Äù and ‚Äú <a href="http://sergeyteplyakov.blogspot.com/2011/07/blog-post.html">On the harm of changeable significant types</a> ‚Äù, respectively. </div><p>Source: <a href="https://habr.com/ru/post/129283/">https://habr.com/ru/post/129283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129276/index.html">Electric and two cars</a></li>
<li><a href="../129277/index.html">Use of controllers to keep ErlyBank afloat</a></li>
<li><a href="../129279/index.html">The prototype of the national OS will be developed for 5 million rubles and 16 days</a></li>
<li><a href="../129280/index.html">The Big Kinescope Theory</a></li>
<li><a href="../129282/index.html">Motorola Droid 3 - review of the thinnest dual-core qwerty slider</a></li>
<li><a href="../129284/index.html">Notes on Whale Rider</a></li>
<li><a href="../129285/index.html">Solving encoding problems in GSP pages (without Grails)</a></li>
<li><a href="../129287/index.html">"What? Where? When? "On IT topics</a></li>
<li><a href="../129288/index.html">Big cotton</a></li>
<li><a href="../129289/index.html">Android client for myshows.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>