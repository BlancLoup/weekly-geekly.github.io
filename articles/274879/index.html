<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering laser distance sensor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, the Keyence LK-G407 non-operational laser distance sensor came to me. Not only was it non-working, it also could not be used without a specia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering laser distance sensor</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/688/cc5/fb6/688cc5fb671d4b5fa1e262ff0f263410.png" alt="image" align="right"><br>  One day, the <a href="http://www.keyence.com/products/measure/laser-1d/lk-g3000/models/lk-g407/index.jsp">Keyence LK-G407</a> non-operational laser distance sensor came to me.  Not only was it non-working, it also could not be used without a special control unit.  But the sensor has such interesting characteristics: distance measurement with an accuracy of micron units, and a work speed of 50 kilo-measurements / s.  So, in order to run it, you will have to notice a lot in the sensor itself, and at the same time get valuable experience. <br><a name="habracut"></a><br><h4>  What is inside the sensor? </h4><br>  The optical part of the sensor is shown in the photo below: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/59f/63c/689/59f63c6893d62f9f06c8221909e693bd.jpg"></a> <br>  On the left in the photo is the laser module, behind it is a photosensitive ruler, on the right is a lens and a mirror. <br>  From the design it becomes clear that this sensor can be attributed to the class of laser range finders with a triangulation method of measuring distance.  The principle of operation of such rangefinders is well described <a href="https://sites.google.com/site/todddanko/home/webcam_laser_ranger">here</a> .  In principle, it is quite simple - when the distance to the object to which the laser shines changes, the angle between the rangefinder lens and the laser spot changes.  If in the focal plane of the lens to install a photosensitive ruler or matrix, then you can determine this angle by the position of the maximum output signal.  Knowing the angle and distance between the laser and the lens, you can determine the distance to the object. <br>  The advantages of this method are very high accuracy at small distances - under certain conditions it can be better than 0.1 microns! <br>  It is also not a problem to measure the distance at high speed - you only need to use a high-speed photosensitive ruler. <br>  The circuitry of such a rangefinder is also quite simple - due to the fact that there are no high frequencies in the device, and the primary signal amplification goes in the ruler itself. <br>  But there is a drawback - the accuracy of the method drops sharply with increasing distance. <br>  This sensor uses a long-focus lens (focal length of about 150 mm), therefore, to reduce the size of the sensor it includes a mirror. <br><br>  And now it is worth going to the sensor electronics. <br>  Here is the second part of the sensor: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1fb/d01/eb8/1fbd01eb82bc82adef843ef5daea925d.jpg"></a> <br>  And the board itself: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fb7/58d/f10/fb758df1078a09a017cc5006f477d179.jpg"></a> <br>  And on the other hand: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f1e/3ff/4ef/f1e3ff4efad8d9a8b678f624ce83da10.jpg"></a> <br>  The printed circuit board seems to be four-layered - most of the signal conductors are on the outer layers, the power lines are on the inner ones. <br>  As I already mentioned, there was no control unit to the sensor, and without it it did not start working.  It is clear that there were no circuits on the sensor either, the pinout of the cable and the sensor supply voltage were not even known.  Conclusion - you need to do reverse-engineering schemes. <br>  The result is such a scheme: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f25/011/b8e/f25011b8e8c525b156afb3575ef1ff6b.png"></a> <br>  Of course, I did not begin to draw the entire sensor circuit, and figured out only the part related to FPGA.  The numbers of the elements in the diagram do not correspond to the numbers on the board. <br>  Thus, the block diagram of the sensor: <br><img src="https://habrastorage.org/getpro/habr/post_images/f98/ce5/ee5/f98ce5ee5d30e292c38040b8297c6e17.png" alt="image"><br>  From it it is clear that the work of the entire sensor is controlled by two chips - FPGA Xilinx Spartan-3A and some custom chip.  However, I was very lucky - from the diagram it is clear that the custom chip is connected only with FPGA.  Thus, the FPGA itself is able to control all the signals in the sensor. <br><br>  The key element of the whole structure is the photosensitive ruler.  This line - obviously custom.  Under the microscope on one of its edges is visible the inscription: <br>  25-512 <br>  LI004-02 <br>  I assumed that 512 is the number of pixels in the ruler, and 25 is the width of the pixel in microns.  As it turned out, I was right. <br>  Behind the line is soldered a small board: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cac/0f2/307/cac0f230763cc1aaf78ebb691f0c592b.jpg"></a> <br>  It contains an operational amplifier that increases the signal from the line 2 times and several resistors and capacitors.  This board connects to P1.  As can be seen from the diagram, only 3 signal lines go to the line.  One of them is clearly an analog signal from its output (it is transmitted over a separate coaxial wire).  The remaining two lines are digital, and are used to control the ruler.  When analyzing the circuit, I was lucky again - when voltage is applied to the circuit on one of these lines (4), a frequency of 10 MHz appears.  It immediately became clear that this line is responsible for the clocking of the ruler.  Obviously, all ruler control is on the remaining line (3).  I connected the line to the STM32F4 microcontroller, and started to send different signals to the (3) and (4) lines.  As it turned out, the ruler works quite simply - as long as there is a high level on the line (3), there is an exposure - the ruler receives light.  After installing the low level on the line (3), you need to apply 14 clock pulses to the ruler, after which it will output an analog signal to the next 512 clock pulses.  The line operates on 5V voltage, and the FPGA - from 3.3V, and therefore the DD2 chip is used for level matching. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The analog signal from the ruler is transmitted via the low-pass filter to the repeater assembled on the DA1 chip.  The signal is then fed to a P83-amplifier with a programmable gain <a href="http://www.gaw.ru/html.cgi/txt/ic/Analog_Devices/amplifiers/ad8369.htm">AD8369</a> .  The maximum gain of this microcircuit is 40 dB, and it can be adjusted programmatically by setting the necessary code at its inputs BIT0-3.  This chip is designed to amplify the differential signal, and its output is also differential, so that then both of its outputs are connected to an operational amplifier DA4, amplifying the signal 2 times, and forming a single signal. <br>  Next, the analog signal is fed to the input of a 10-bit <a href="http://www.gaw.ru/html.cgi/txt/ic/Analog_Devices/adc/ot_1/10bit/ad9200.htm">AD9200</a> ADC.  This chip was already familiar to me from the <a href="http://habrahabr.ru/post/204310/">SDR receiver</a> .  In this case, it is connected in such a way that the voltage range digitized by it is (0.5-2.5) V. The digitized signal from the ADC output is transmitted to the FPGA. <br>  It is worth paying attention to the CLAMP input of this ADC.  This input is also controlled by FPGA.  It is designed to bring the constant component of the input signal to a certain level. <br>  Here is the scheme of the input stage of the ADC from the datasheet: <br><img src="https://habrastorage.org/files/6c8/c2e/f56/6c8c2ef569c34a709c0f91a9203fd556.png"><br>  When a high level is applied to the CLAMP input, a voltage equal to the ‚ÄúCLAMP IN‚Äù input voltage appears at the amplifier output and at the AIN. <br>  In this case, the capacitor CIN will be charged until the voltage on it becomes equal (Uin - Uclamp_in).  After that, the input CLAMP set a low level, and the amplifier ceases to influence the operation of the ADC.  In this sensor, the input "CLAMP IN" is connected to the lower reference voltage of the ADC + 0.5V.  Thus, if there is some constant component at the output of DA4, then by using the CLAMP function, you can eliminate its influence on the result of the ADC operation. <br>  After the first test configurations for the FPGA were written, it turned out that you really need to control the CLAMP signal, otherwise the signal from the ADC has a very large DC component.  In my implementation, I simply applied 1 to it at that time, until the data is captured using the ADC. <br><br>  From the diagram it can be seen that it uses a large number of supply voltages.  I did not begin to draw diagrams of various power sources included in the sensor and various smoothing capacitors.  As it turned out, the power pins (they are connected to a separate 2-pin connector) are connected to the TPS62050 DC-DC converter.  The maximum voltage for it is 10V, the electronics have not yet started up from 6V, so I decided that the operating voltage of the sensor is 8V. <br><br>  The laser diode used in this module is controlled by electronics mounted on a separate shawl: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a4d/08f/7cf/a4d08f7cf192fd4e49ed375b50437543.jpg"></a> <br>  I did not draw the circuit of this board.  It connects to the main board via the P3 connector.  As you can see, the control of the laser goes on two lines.  One of them (3) is connected to the FPGA via an inverter, and is responsible for turning on the laser ‚Äî it is turned on at a low level at the FPGA output.  Another line (4) is needed to control the laser power.  This is an analog line, and in order to change the voltage on it, the DAC, assembled on DA5-7 microcircuits, is included in the circuit (I did not understand why the developers built up such an intricate circuit, and did not take the finished DAC chip). <br><br>  As it is known, most FPGAs do not contain non-volatile memory, respectively, the FPGA configuration should be stored in an external chip.  In this case, this is the DD3 XCF01 - a specialized flash memory chip.  When enabled, the FPGA automatically reads the configuration from it into its memory.  The FPGA and XCF01 are connected to the JTAG circuit, which is connected to the P2 connector.  As a result, you can program the XCF01 in-situ via this connector, configure the FPGA and debug it. <br><br>  So I figured out how the sensor electronics work, and I got a part of its circuit.  Now you can start the experiments, i.e.  FPGA programming.  It is worth noting that before that I had not dealt with the FPGA manufactured by Xilinx.  I also didn‚Äôt have the necessary programmer, so I had to <a href="http://we.easyelectronics.ru/plis/programmator-dlya-plis-xilinx-na-at90usb162.html">make it myself</a> by combining several OpenSource projects. <br>  The programmer worked fine, and I managed to launch simple projects on the FPGA ‚Äî simple switching of the FPGA outputs.  However, in the future I needed a connection with a computer.  I didn‚Äôt want to communicate with the LVDS interface (at the port where the LVDS power supply line is 2.5V), so I just cut the two tracks connecting the FPGA and ASIC.  There was a connector on the board, apparently intended for setting up or testing ASIC, I could not use it, so I also cut two tracks going to it, and connected the connector pins to the FPGA.  Now you can connect a USB-UART adapter to this connector. <br>  Type of board after revision: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc5/c03/8ab/bc5c038ab626cc3185b176be5c124324.jpg"></a> <br><br>  After that, I wrote a simple program to test the operation of the UART.  It worked - the computer correctly received single bytes transmitted over the UART with the FPGA.  The next step is to transfer data from the photosensitive line to the computer.  I used this block diagram of the FPGA program: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e8a/2b9/bf5/e8a2b9bf594aa17187c83889a79200a6.png"></a> <br>  View of the scheme in ISE: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d82/8aa/d0d/d828aad0df003a3f89cbbce582e9aa4e.png"></a> <br>  The top-level project is drawn in the schematic editor, and all modules included in it are written in Veriolg.  The principle of the project is quite simple - the data from the ruler, digitized by the ADC, are captured by the FPGA and stored in the RAM.  After all 512 elements of the signal are captured, they are transmitted via the UART to the computer.  After all the data has been transmitted, the cycle repeats.  The sensor_reader module in this project controls the ruler, the laser, and the CLAMP signal.  The control is implemented in the simplest way - a clock counter controls all signals.  The tx_controller module includes a UART transmitter module.  It is designed to transfer data that the module receives from external memory. <br>  During operation, the level of the useful signal on the ruler can vary greatly - due to a change in the distance to the object and a change in its reflectance.  If the signal is too small, measurements become impossible, and if the signal is too large, the measurement accuracy drops dramatically.  Because of this, the gain of the analog signal needs to be adjusted.  Initially, the project included a UART receiver module that allowed you to manually change the gain, later I removed it and made an automatic gain control - AGC. <br>  It includes the maximum signal search module (‚Äúmax_finder‚Äù) and the AGC module itself (‚Äúagc_module‚Äù).  This module is also quite simple - if the signal level is less than 170, then the gain increases, if more than 250, it decreases. <br>  All modules, line and ADC are clocked from 10 MHz frequency.  I made the exposure time equal to 5 ¬µs.  Thus, the entire process of exposure and signal capture in the FPGA takes (5 + 51) Œºs.  Data transmission time is much longer - at a clock frequency of 500,000 bps, transmission of 512 bytes takes 10 ms, which gives 100 measurements per second. <br><br>  To view the transmitted data in real time, a simple C # program was written: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d38/949/c1a/d38949c1a32815e49df2b30dd94373d2.png"></a> <br>  When moving an object along a laser beam, the position of the peak peak changes.  A simple calculation of the position of the maximum gives a low measurement accuracy, since the ruler contains only 512 pixels.  Therefore, to more accurately measure the position of the maximum of the signal, it is necessary to use center of gravity search algorithms, which make it possible to determine the coordinates of the maximum of the signal with sub-pixel accuracy. <br>  I used this formula to find the peak center of gravity: <br><img src="https://habrastorage.org/files/6cf/4bd/ef8/6cf4bdef8af34c5b866f6c27563ddd8b.png"><br>  where n is the total number of pixels, Int [i] is the intensity i of a pixel. <br>  In order for the various noise present in the signal to not degrade the accuracy of operation, it is useful to process only samples that exceed a certain threshold and are close to the peak maximum.  This is especially important in the case when the gain is not enough, and the useful signal does not exceed half of the ADC scale.  Moreover, with increasing gain, the noise level increases, which worsens the situation.  In the above program, this is taken into account. <br>  In the picture above, MAX POS is the value calculated by this formula, MAX POS F is the average value of the last 50 measurements. <br>  As I have already said, the resulting measurement frequency is 100 Hz, and it is limited by the speed of data transmission over the UART.  However, it is not necessary to process the signal on the computer, it can be done on the FPGA, due to which you can multiply the speed of measurements. <br><br>  As a result, a program was developed for the FPGA with the following structural scheme: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9db/317/183/9db31718377ba2980840535065ff08ea.png"></a> <br>  View of the scheme in ISE: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/63c/c06/b13/63cc06b1336777cc3438735fd0100587.png"></a> <br>  As you can see, some of the modules are taken from the previous project. <br>  In this case, the centroid_finder module is engaged in calculating the position of the center of gravity (centroid) of the signal.  In order to limit the data analysis area, the coarse value of the position of the maximum and its amplitude are transferred to the module. <br>  Since these values ‚Äã‚Äãcan be calculated only by analyzing the entire signal (that is, they appear with a delay of 512 clock pulses), it turns out that the digitized data must be fed to the input ‚Äúcentroid_finder‚Äù with the same delay.  In order to hold the data for 512 clocks, the FIFO buffer is used.  For the initial filling of the FIFO, the ‚Äúfifo_logic‚Äù module is used - it prohibits reading from the FIFO if it is not filled. <br>  The ‚Äútx_controller_3bytes‚Äù module sequentially transmits 3 bytes, the first of them is zero, the remaining two contain the calculated position of the center of gravity.  At a speed of 50000 bit / s, the transmission of 3 bytes takes 60 ¬µs - almost the same as the capture of a signal.  Zero byte is used to synchronize data - after it always goes high byte. <br>  Data transmission over the UART and data capture are triggered simultaneously by the start_capture signal.  This signal is generated if the previous transmission is over at the same time and a new position of the center of gravity is calculated.  As a result, the distance measurement and data transmission time is close to 60 Œºs, which gives the coordinate measurement speed - 16.6 KSPS.  This is less than stated by the sensor manufacturer.  It indicates the minimum measurement time - 20 ¬µs (this corresponds to 50 KSPS), although it is not clear how this time is obtained, because even at the maximum speed of the AD9200 - 20 MSPS, the signal capture time from 512 pixels will be - 25.6 ¬µs.  And this is without taking into account the time of exposure. <br><br>  As I said earlier, this sensor did not work.  As far as I know, the problem was that it was installed on a highly vibrating industrial installation, and because of the vibration, the laser of the sensor failed (the sensor stopped responding to dark surfaces). <br>  Unfortunately, there was no marking on the native diode.  I tried to replace the laser diode in the laser module with a purchased 5 mW laser diode, but after a while its intensity dropped.  Most likely, the electronics of the laser module was designed for a more powerful diode (although operating in a pulsed mode, due to which the average radiation level is quite low). <br>  In order to at least somehow start the sensor, I made my laser diode driver working in the constant-radiation mode: <br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/c6f/7c7/f2bc6f7c76e7db4db331c5f8563d9953.jpg" alt="image"><br>  The native laser diode of the sensor was rolled into the metal case of the laser module, so the new laser diode just had to be glued to the module.  At the same time, the overall dimensions of the diode used were somewhat different from the dimensions of the native diode, which is why I never managed to focus the laser module qualitatively. <br>  This is the assembled sensor: <br><img src="https://habrastorage.org/files/6ba/d6c/250/6bad6c250dd946d3a1d55e26297ef39e.jpg"><br>  In order to use the sensor to measure the distance, it is necessary to calibrate it, i.e.  determine the law relating the result returned by the sensor and the actual distance.  The calibration process itself is a series of measurements, as a result of which a set of distances from the sensor to an object and the corresponding results are formed. <br>  The distance between the sensor and the object must be measured very accurately.  For calibration, I made a stand that includes a <a href="http://we.easyelectronics.ru/citizen/podklyuchenie-lineynogo-enkodera-k-stm32.html">linear encoder</a> and the laser sensor itself: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c8c/01a/072/c8c01a0728a680ad5ddb464ff738f1eb.jpg"></a> <br><br>  The distance is measured to the plate attached to the end of the encoder. <br>  After all the data is collected, you can conduct a regression analysis in Mathcad. <br>  As a result, I got this expression: <br>  value_mm = 70.0 / Tan (-0.000277757 * max_pos + 0.28355) - 366.23554 <br>  Obviously, the values ‚Äã‚Äãof the constants in terms of the position of the details of the sensor.  The slightest shift in details will cause the calculated distance value to be incorrect.  Therefore, all parts must be very firmly fixed. <br><br>  The video below shows how you can process data from the sensor: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/xuD4vOZ_E2s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The first part of the video shows what the signal from the photosensitive ruler looks like.  It is clearly seen that if the object is dark, the amplitude does not change (due to the operation of the AGC), but the noise level greatly increases. <br>  In the second part of the video, the program takes from the sensor the position of the center of gravity, and recounts it into the distance.  The value of the distance to the object received from the encoder is also transferred to the program.  Under the distance of the encoder, the difference between these distances is displayed.  It can be seen that when moving, the difference becomes greater than 1 mm (this is due to delays during transmission of distances and their display), but during the stops at any distance the difference does not exceed 0.03 mm. <br><br>  In order to make the data from the sensor easier to analyze, I wrote a program that stores the data received from the sensor in wav format.  Such files can be opened in sound editors, and various filters can be applied to them. <br>  Here, for example, looks like a signal from a sensor that was directed to the wall of a transformer power supply: <br><img src="https://habrastorage.org/files/d9c/477/6a5/d9c4776a55a147238feff6579249b4b8.png"><br>  It can be seen as when turning on the power supply began to vibrate. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to direct the sensor to the speaker cone on which the music is played - and after processing it was really audible in the audio editor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taim way, I managed to give a non-working sensor a new life (I may need it in future projects), and at the same time get experience with Xilinx FPGA. </font></font><br><br> <a href="https://github.com/iliasam/keyence_LK_G407_reverce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projects for FPGA</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/274879/">https://habr.com/ru/post/274879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274867/index.html">As I wrote the web app angular + material and REST on Yii2 + webserver nginx</a></li>
<li><a href="../274871/index.html">Linus Torvalds announced the release of the Linux 4.4 LTS kernel (Long-Term Support)</a></li>
<li><a href="../274873/index.html">Static, Aggregate and Generate routes at JunOS</a></li>
<li><a href="../274875/index.html">Debugging Groovy scripts with Grape based on maven aether</a></li>
<li><a href="../274877/index.html">Mercurial: changing history</a></li>
<li><a href="../274881/index.html">A Minute of Theory: Understanding RESTful Applications</a></li>
<li><a href="../274883/index.html">New tools (Octave and Scilab) in FlyElephant and the announcement of webinars</a></li>
<li><a href="../274885/index.html">As I rewrote Dcoin on Go for 8 months ... about Katya, in general</a></li>
<li><a href="../274887/index.html">Create a RESTful API with Dart in minutes</a></li>
<li><a href="../274889/index.html">Calculating the binomial coefficients ... manually</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>