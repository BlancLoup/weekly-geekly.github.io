<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL indexes - 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 This series of articles discusses PostgreSQL indexes. 

 Any question can be viewed from different points of view. We will talk about what ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL indexes - 1</h1><div class="post__text post__text-html js-mediator-article"><h1>  Foreword </h1><br>  This series of articles discusses PostgreSQL indexes. <br><br>  Any question can be viewed from different points of view.  We will talk about what should be of interest to an application developer using a DBMS: which indexes exist, why there are so many different PostgreSQL, and how to use them to speed up queries.  Perhaps the topic could have been revealed with a smaller number of words, but we secretly hope for an inquisitive developer who is also interested in the details of the internal structure, especially since understanding such details allows not only to listen to other people's opinions, but also to draw our own conclusions. <br><br>  Beyond the discussion brackets will be the issues of developing new types of indices.  This requires knowledge of the C language and is more likely the responsibility of the system programmer, rather than the application developer.  For the same reason, we practically will not consider software interfaces, but will only focus on what matters to the use of ready-to-use indexes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this part we will talk about the division of responsibilities between the general <b>indexing mechanism</b> related to the database engine and the individual index access methods that can be added as extensions to PostgreSQL.  In the next section, we will look at the <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">interface of the access method</a> and such important concepts as classes and operator families.  After such a long but necessary introduction, we consider in detail the design and application of various types of indices: <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">Hash</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-tree</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">SP-GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">GIN</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/343488/">RUM</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/346460/">BRIN</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/349224/">Bloom</a> . <br><br><h1>  Indices </h1><br>  PostgreSQL indices are special database objects designed primarily to speed up data access.  These are auxiliary structures: any index can be deleted and restored again according to the information in the table.  Sometimes you hear that a DBMS can work without indices, just slowly.  However, this is not the case, since the indices also serve to support some integrity constraints. <br><a name="habracut"></a><br>  Currently, six different kinds of indexes are built into PostgreSQL 9.6, and another one is available as an extension ‚Äî this was possible due to important changes in version 9.6.  So in the near future we should expect the appearance of other types of indices. <br><br>  Despite all the differences between the types of indexes (also called <em>access methods</em> ), in the end, any of them establishes a correspondence between the key (for example, the value of the indexed column) and the rows of the table in which this key occurs.  Strings are identified by a TID (tuple id), which consists of the file block number and the position of the string inside the block.  Then, knowing the key or some information about it, you can quickly read those lines that may contain information of interest to us, without looking at the entire table. <br><br>  It is important to understand that the index, speeding up access to data, in return requires a certain amount of maintenance costs.  For any operation on indexed data - whether it is inserting, deleting or updating table rows, the indices created for this table must be rebuilt, moreover, within the framework of the same transaction.  Note that updating the table fields for which no indexes were created does not lead to the rebuilding of the indexes;  This mechanism is called HOT (Heap-Only Tuples). <br><br>  Extensibility has some implications.  To make the new access method easy to integrate into the system, PostgreSQL has a general indexing mechanism.  Its main task is to obtain the TID from the access method and work with them: <br><br><ul><li>  reading data from the corresponding versions of rows of the table; </li><li>  sample by individual TID, or immediately by a set of TID (with the construction of a bitmap); </li><li>  checking the visibility of row versions for the current transaction, taking into account the isolation level. </li></ul><br>  The indexing mechanism is involved in the execution of queries;  It is called according to a plan built during the optimization phase.  The optimizer, sorting through and evaluating various ways of executing a query, must understand the capabilities of all the access methods that can potentially be applied.  Will the access method be able to give the data immediately in the right order, or should a separate sort be provided?  Is it possible to use an access method to find null?  - such questions are constantly solved by the optimizer. <br><br>  Information about the access method is needed not only by the optimizer.  When creating an index, the system needs to decide: is it possible to build an index over several columns?  Can this index provide uniqueness? <br><br>  So, each access method must provide all the necessary information about itself.  Prior to version 9.6, the pg_am table was used for this, and starting from 9.6, the data migrated deeper, inside special functions.  We will get acquainted with this interface a bit later. <br><br>  The tasks of the access method itself include everything else: <br><br><ul><li>  implementation of the algorithm for constructing the index and splitting data into pages (so that any index is processed in the same way by the buffer cache manager); </li><li>  information search in the index by the expression " <em>indexed-field operator expression</em> "; </li><li>  evaluation of the cost of using the index; </li><li>  work with locks required for correct parallel execution of processes; </li><li>  formation of the log proactive record (WAL). </li></ul><br>  First, we look at the capabilities of the general indexing mechanism, and then proceed to consider the various access methods. <br><br><h1>  Indexing mechanism </h1><br>  The indexing mechanism allows PostgreSQL to work equally with a variety of access methods, given their capabilities. <br><br><h2>  Basic scan methods </h2><br><h3>  Index scan </h3><br>  You can work differently with the TID supplied by the index.  Consider an example: <br><br> <code>postgres=# create table t(a integer, b text, c boolean); <br> CREATE TABLE <br> postgres=# insert into t(a,b,c) <br> select s.id, chr((32+random()*94)::integer), random() &lt; 0.01 <br> from generate_series(1,100000) as s(id) <br> order by random(); <br> INSERT 0 100000 <br> postgres=# create index on t(a); <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br></code> <br>  We created a table with three fields.  The first field contains numbers from 1 to 100,000, and an index has been created for it (for now it does not matter which one).  The second field contains various ASCII characters besides non-printable characters.  Finally, the third field contains a logical value, true for approximately 1% of the lines, and false for the rest.  Rows inserted into the table in random order. <br><br>  Let's try to choose a value by the condition "a = 1".  Note that the condition has the form " <em>indexed-field operator expression</em> ", where the <em>operator</em> is "equal", and the <em>expression</em> (search key) is "1".  In most cases, the condition must have exactly such a form that the index can be used. <br><br> <code>postgres=# explain (costs off) select * from t where a = 1; <br> QUERY PLAN <br> ------------------------------- <br> Index Scan using t_a_idx on t <br> Index Cond: (a = 1) <br> (2 rows) <br></code> <br>  In this case, the optimizer decided to use an <em>index scan</em> (Index Scan).  In the index view, the access method returns the TID values ‚Äã‚Äãone by one, until the matching rows run out.  The indexing mechanism, in turn, accesses the pages of the table indicated by the TID, gets the row version, checks its visibility according to the multiversion rules, and returns the received data. <br><br><h3>  Bitmap scanning </h3><br>  Index scanning works well when it comes to just a few values.  However, increasing the sample increases the chances of having to go back to the same tabular page several times.  Therefore, in this case, the optimizer switches to a bitmap scan: <br><br> <code>postgres=# explain (costs off) select * from t where a &lt;= 100; <br> QUERY PLAN <br> ------------------------------------ <br> Bitmap Heap Scan on t <br> Recheck Cond: (a &lt;= 100) <br> -&gt;  Bitmap Index Scan on t_a_idx <br> Index Cond: (a &lt;= 100) <br> (4 rows) <br></code> <br>  First, the access method returns all TIDs that match the condition (Bitmap Index Scan node), and the bitmap of string versions is constructed from them.  Then the versions of the rows are read from the table (Bitmap Heap Scan) - each page will be read only once. <br><br>  Note that in the second step the condition can be rechecked (Recheck Cond).  The sample may be too large for the string version version bitmap to fit entirely into RAM (limited by the work_mem parameter).  In this case, only the bitmap of the <em>pages</em> containing at least one suitable version of the string is constructed.  Such a ‚Äúrough‚Äù card takes up less space, but when reading a page you have to re-check the conditions for each line stored there.  Note that even in the case of a small sample (as in our example), the ‚ÄúRecheck Cond‚Äù step is still displayed in the plan, although it is not actually implemented. <br><br>  If conditions are imposed on several table fields, and these fields are indexed, scanning the bitmap allows (if the optimizer finds it advantageous) to use several indexes at the same time.  For each index, bitmap versions of strings are built, which are then logically multiplied bit-wise (if expressions are joined by AND condition) or logically added (if expressions are joined by OR condition).  For example: <br><br> <code>postgres=# create index on t(b); <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br> postgres=# explain (costs off) select * from t where a &lt;= 100 and b = 'a'; <br> QUERY PLAN <br> -------------------------------------------------- <br> Bitmap Heap Scan on t <br> Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) <br> -&gt;  BitmapAnd <br> -&gt;  Bitmap Index Scan on t_a_idx <br> Index Cond: (a &lt;= 100) <br> -&gt;  Bitmap Index Scan on t_b_idx <br> Index Cond: (b = 'a'::text) <br> (7 rows) <br></code> <br>  Here, the BitmapAnd node combines two bitmaps using the ‚Äúand‚Äù bitwise operation. <br><br>  Bitmap scanning avoids repeated access to the same data page.  But what if the data in the table pages is physically ordered just like the index entries?  Of course, you cannot completely rely on the physical order of the data in the pages - if you need sorted data, you must explicitly specify the ORDER BY clause in the query.  But it is quite possible that in fact ‚Äúalmost all‚Äù data is ordered: for example, if the rows are added in the correct order and do not change after that, or after executing the CLUSTER command.  Then the construction of the bitmap is an extra step, the usual index scan will be no worse (if you do not take into account the possibility of combining several indices).  Therefore, when choosing an access method, the scheduler looks in special statistics that show the degree of ordering of the data: <br><br> <code>postgres=# select attname, correlation from pg_stats where tablename = 't'; <br> attname | correlation <br> ---------+------------- <br> b      |    0.533512 <br> c      |    0.942365 <br> a      | -0.00768816 <br> (3 rows) <br></code> <br>  Values ‚Äã‚Äãclose in magnitude to unity indicate a high degree of ordering (as for column c), while those close to zero indicate, on the contrary, a chaotic distribution (column a). <br><br><h3>  Sequential scan </h3><br>  For completeness, it should be said that under a non-selective condition, the optimizer will prefer to use the index to <em>sequentially scan</em> the entire table: <br><br> <code>postgres=# explain (costs off) select * from t where a &lt;= 40000; <br> QUERY PLAN <br> ------------------------ <br> Seq Scan on t <br> Filter: (a &lt;= 40000) <br> (2 rows) <br></code> <br>  And he will be right.  The fact is that the indices work the better, the higher the selectivity of the condition, that is, the fewer rows it satisfies.  As the sample increases, so does the overhead of reading index pages. <br><br>  The situation is aggravated by the fact that sequential reading is performed faster than reading pages "one to one".  This is especially true for hard drives, where the mechanical operation of leading the head to the track takes significantly more time than reading the data itself;  in the case of SSDs, this effect is less pronounced.  To take into account the difference in the cost of access, there are two parameters seq_page_cost and random_page_cost, which can be set not only globally, but also at the level of table spaces, taking into account the characteristics of different disk subsystems. <br><br><h2>  Covering indexes </h2><br>  As a rule, the main task of the access method is to return the identifiers of the matching rows of the table so that the indexing engine can read the necessary data from them.  But what if the index already contains all the necessary data for the query?  Such an index is called <em>covering</em> (covering), in which case the optimizer can apply <em>only</em> Index <em>Scan</em> (Scan Only): <br><br> <code>postgres=# vacuum t; <br> VACUUM <br> postgres=# explain (costs off) select a from t where a &lt; 100; <br> QUERY PLAN <br> ------------------------------------ <br> Index Only Scan using t_a_idx on t <br> Index Cond: (a &lt; 100) <br> (2 rows) <br></code> <br>  The name may suggest that the indexing mechanism does not refer to the table at all, receiving all the necessary information solely from the access method.  But this is not entirely true, because PostgreSQL indexes do not contain information that allows you to judge the visibility of rows.  Therefore, the access method returns all versions of the rows that match the search condition, regardless of whether they are visible in the current transaction or not. <br><br>  However, if the indexing mechanism had to look at the table every time to determine visibility, this scanning method would be no different from a regular index scan. <br><br>  The problem is solved by the fact that PostgreSQL supports for tables a so-called <em>visibility map,</em> in which the cleaning process (vacuum) marks the pages where the data did not change long enough for all transactions to see, regardless of the start time and isolation level.  If the identifier of the row returned by the index refers to such a page, then visibility can be not checked. <br><br>  Therefore, regular cleaning performance increases the effectiveness of covering indexes.  Moreover, the optimizer takes into account the number of unclean rows and can abandon the use of an index scan only if it predicts a large overhead of visibility checks. <br><br>  The number of forced table accesses can be found using the explain analyze command: <br><br> <code>postgres=# explain (analyze, costs off) select a from t where a &lt; 100; <br> QUERY PLAN <br> ------------------------------------------------------------------------------- <br> Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) <br> Index Cond: (a &lt; 100) <br> Heap Fetches: 0 <br> Planning time: 0.092 ms <br> Execution time: 0.059 ms <br> (5 rows) <br></code> <br>  In this case, it was not necessary to refer to the table (Heap Fetches: 0), since it had just been cleared.  In general, the closer this number is to zero, the better. <br><br>  Not all indexes store indexed values ‚Äã‚Äãalong with row IDs.  If the access method cannot return data, it cannot be used exclusively for an index scan. <br><br><h2>  Null </h2><br>  Indefinite values ‚Äã‚Äãplay an important role in relational databases as a convenient way of representing the fact that a value does not exist or is not known. <br><br>  But special importance requires special treatment.  Normal Boolean logic turns into a three-digit;  it is not clear whether the undefined value should be less than usual values ‚Äã‚Äãor greater (hence the special constructions for sorting NULLS FIRST and NULLS LAST);  It is not obvious whether uncertain values ‚Äã‚Äãshould be taken into account in aggregate functions or not;  Special statistics are required for the scheduler ... <br><br>  From the point of view of index support with uncertain values, there is also a lack of clarity: should these values ‚Äã‚Äãbe indexed or not?  If you do not index null, then the index can be smaller.  But if we index, then it becomes possible to use an index for the ‚Äú <em>indexed-field</em> IS [NOT] NULL‚Äù type of conditions, and also as a covering index with no conditions on the table (since in this case the index should return the data of all rows of the table, including number and with uncertain values). <br><br>  For each access method, its developers make their decision whether to index indefinite values ‚Äã‚Äãor not.  But, as a rule, they are still indexed. <br><br><h2>  Multiple field indices </h2><br>  Conditions for several fields can be supported using <em>multi-column indices</em> .  For example, we could create an index for two fields of our table: <br><br> <code>postgres=# create index on t(a,b); <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br></code> <br>  The optimizer is likely to prefer such an index to combining bitmaps, because here we immediately get the necessary TIDs without any additional actions: <br><br> <code>postgres=# explain (costs off) select * from t where a &lt;= 100 and b = 'a'; <br> QUERY PLAN <br> ------------------------------------------------ <br> Index Scan using t_a_b_idx on t <br> Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) <br> (2 rows) <br></code> <br>  A multi-column index can also be used to speed up sampling by condition on a part of the fields - starting with the first: <br><br> <code>postgres=# explain (costs off) select * from t where a &lt;= 100; <br> QUERY PLAN <br> -------------------------------------- <br> Bitmap Heap Scan on t <br> Recheck Cond: (a &lt;= 100) <br> -&gt;  Bitmap Index Scan on t_a_b_idx <br> Index Cond: (a &lt;= 100) <br> (4 rows) <br></code> <br>  As a rule, if no condition is imposed on the first field, the index will not be used.  But in some cases, the optimizer may find that it is still more profitable than sequential scans.  We will touch on this topic in more detail when considering btree indexes. <br><br>  Not all access methods support the creation of indexes across multiple columns. <br><br><h2>  Expression indexes </h2><br>  We talked about the fact that the search condition should have the form " <em>indexed-field operator expression</em> ".  In the example below, the index will not be used, since instead of the field name itself, an expression is used with it: <br><br> <code>postgres=# explain (costs off) select * from t where lower(b) = 'a'; <br> QUERY PLAN <br> ------------------------------------------ <br> Seq Scan on t <br> Filter: (lower((b)::text) = 'a'::text) <br> (2 rows) <br></code> <br>  This particular query is not difficult to rewrite so that only the field name is to the left of the operator.  But if this is not possible, <em>expressions</em> (functional indexes) come to the rescue: <br><br> <code>postgres=# create index on t(lower(b)); <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br> postgres=# explain (costs off) select * from t where lower(b) = 'a'; <br> QUERY PLAN <br> ---------------------------------------------------- <br> Bitmap Heap Scan on t <br> Recheck Cond: (lower((b)::text) = 'a'::text) <br> -&gt;  Bitmap Index Scan on t_lower_idx <br> Index Cond: (lower((b)::text) = 'a'::text) <br> (4 rows) <br></code> <br>  A functional index is created not by a table field, but by an arbitrary expression;  the optimizer will take into account such an index for the conditions of the form ‚Äú <em>indexed-expression statement expression</em> ‚Äù.  If the calculation of the indexed expression is a costly operation, then updating the index will require significant computational resources. <br><br>  It should also be borne in mind that the indexed expression is going to separate statistics.  It can be seen in the pg_stats view by the index name: <br><br> <code>postgres=# \dt <br> Table "public.t" <br> Column |  Type  | Modifiers <br> --------+---------+----------- <br> a      | integer | <br> b      | text    | <br> c      | boolean | <br> Indexes: <br> "t_a_b_idx" btree (a, b) <br> "t_a_idx" btree (a) <br> "t_b_idx" btree (b) <br> "t_lower_idx" btree (lower(b)) <br> <br> postgres=# select * from pg_stats where tablename = 't_lower_idx'; <br> ... <br></code> <br>  If necessary, you can control the number of histogram baskets in the same way as for ordinary table fields (bearing in mind that the column name may be different depending on the indexed expression): <br><br> <code>postgres=# \d t_lower_idx <br> Index "public.t_lower_idx" <br> Column | Type | Definition <br> --------+------+------------ <br> lower  | text | lower(b) <br> btree, for table "public.t" <br> <br> postgres=# alter index t_lower_idx alter column "lower" set statistics 69; <br> ALTER INDEX <br></code> <br><h2>  Partial indexes </h2><br>  Sometimes it becomes necessary to index only a portion of the rows in a table.  This is usually associated with a strong uneven distribution: it makes sense to search for a rare value by index, but it is often easier to find it by full scanning the table. <br><br>  Of course, you can build a regular index on the column "c", and it will work as we expect: <br><br> <code>postgres=# create index on t(c); <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br> postgres=# explain (costs off) select * from t where c; <br> QUERY PLAN <br> ------------------------------- <br> Index Scan using t_c_idx on t <br> Index Cond: (c = true) <br> Filter: c <br> (3 rows) <br> <br> postgres=# explain (costs off) select * from t where not c; <br> QUERY PLAN <br> ------------------- <br> Seq Scan on t <br> Filter: (NOT c) <br> (2 rows) <br></code> <br>  In this case, the index takes 276 pages: <br><br> <code>postgres=# select relpages from pg_class where relname='t_c_idx'; <br> relpages <br> ---------- <br> 276 <br> (1 row) <br></code> <br>  But, since the ‚Äúc‚Äù column is true for only one percent of the rows, 99% of the index is simply never used.  In this case, you can build a partial index: <br><br> <code>postgres=# create index on t(c) where c; <br> CREATE INDEX <br> postgres=# analyze t; <br> ANALYZE <br></code> <br>  The size of this index has decreased to 5 pages: <br><br> <code>postgres=# select relpages from pg_class where relname='t_c_idx1'; <br> relpages <br> ---------- <br> 5 <br> (1 row) <br></code> <br>  In some cases, the difference in volume and performance can be quite substantial. <br><br><h2>  Sorting </h2><br>  If the access method returns string identifiers in the sort order, this gives the optimizer additional options for executing the query. <br><br>  You can scan the table and then sort the data: <br><br> <code>postgres=# set enable_indexscan=off; <br> SET <br> postgres=# explain (costs off) select * from t order by a; <br> QUERY PLAN <br> --------------------- <br> Sort <br> Sort Key: a <br> -&gt;  Seq Scan on t <br> (3 rows) <br></code> <br>  And you can read the data using the index immediately in the sort order: <br><br> <code>postgres=# set enable_indexscan=on; <br> SET <br> postgres=# explain (costs off) select * from t order by a; <br> QUERY PLAN <br> ------------------------------- <br> Index Scan using t_a_idx on t <br> (1 row) <br></code> <br>  Of all the access methods, only btree can return data in a sorted form, so postpone a more detailed conversation until we consider this type of index. <br><br><h2>  Parallel construction </h2><br>  Typically, building an index requires setting a SHARE lock on the table.  Such a lock allows you to read data from a table, but prohibits any changes while the index is being built. <br><br>  You can make sure of this if at the moment of creating the index, say on table t, in another session, perform the query: <br><br> <code>postgres=# select mode, granted from pg_locks where relation = 't'::regclass; <br> mode    | granted <br> -----------+--------- <br> ShareLock | t <br> (1 row) <br></code> <br>  If the table is large enough and is actively used in insert, update, or delete mode, this may be invalid - changing sessions will wait for the lock to be released for a long time. <br><br>  In this case, you can use parallel index creation: <br><br> <code>postgres=# create index concurrently on t(a); <br> CREATE INDEX <br></code> <br>  Such a command establishes a SHARE UPDATE EXCLUSIVE lock, which allows both reading and changing data (only changing the structure of the table is prohibited, as well as simultaneous cleaning, analyzing, or building another index on the same table). <br><br>  However, there is a downside.  First, the index will be built more slowly than usual, because instead of one pass through the table, two runs, and it is still necessary to wait for the completion of parallel transactions that modify the data. <br><br>  Secondly, with the parallel construction of the index, a deadlock or violation of the uniqueness constraint may occur.  The index is nevertheless created, but in a ‚Äúnon-working‚Äù state;  in this case, it must be deleted and recreated again.  Non-working indices are marked with the word INVALID in the output of the psql \ d command, and the full list can be obtained with the query: <br><br> <code>postgres=# select indexrelid::regclass index_name, indrelid::regclass table_name from pg_index where not indisvalid; <br> index_name | table_name <br> ------------+------------ <br> t_a_idx    | t <br> (1 row) <br></code> <br>  <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/326096/">https://habr.com/ru/post/326096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326084/index.html">Audit of current vulnerabilities without registration and SMS</a></li>
<li><a href="../326086/index.html">Cisco CSR 1000v: Features Overview. Part 1</a></li>
<li><a href="../326088/index.html">Message based integration. Advantages and differences from other approaches</a></li>
<li><a href="../326090/index.html">Creating npm package of React components based on create-react-app</a></li>
<li><a href="../326094/index.html">Introduction to the Storage Performance Development Kit (SPDK)</a></li>
<li><a href="../326098/index.html">A step-by-step guide to the CSS Grid auto-placement algorithm</a></li>
<li><a href="../326102/index.html">Online cash vs blockchain: you did not know this, but thought about it?</a></li>
<li><a href="../326104/index.html">Not soon the fence is built, especially a beautiful data center. How we build the data center "Avantage". Part 1</a></li>
<li><a href="../326106/index.html">PostgreSQL indexes - 2</a></li>
<li><a href="../326108/index.html">A little about the lines in C, or several options to optimize non-optimizable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>