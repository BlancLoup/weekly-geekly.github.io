<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Not ORM single</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not ORM single 


 Hello! I manage the Partners Development department in the hotel reservation service Ostrovok.ru . In this article I would like to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Not ORM single</h1><div class="post__text post__text-html js-mediator-article"><h1 id="ne-ormom-edinym">  Not ORM single </h1><br><p>  Hello!  I manage the Partners Development department in the hotel reservation service <a href="https://www.ostrovok.ru/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Delfimov_apr19">Ostrovok.ru</a> .  In this article I would like to tell you about how we used <a href="https://docs.djangoproject.com/en/2.1/topics/db/">Django ORM</a> on one project. </p><br><p>  In fact, I was a slave, the name was supposed to be " <del>  Not </del>  ORM uniform. "If you are wondering why I wrote this, and also if: </p><br><ul><li> You have Django on the stack, and you want to squeeze out the maximum of ORM capabilities, not just <code>Model.objects.all()</code> , </li><li>  You want to transfer part of business logic to the database level </li><li>  Or do you want to find out why the most frequent excuse for developers in B2B.Ostrovok.ru <em>"has historically been this way"</em> , </li></ul><br><p>  ... welcome under cat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="cdpv"></p><a name="habracut"></a><br><p>  In 2014, we launched B2B.Ostrovok.ru, an online booking service for hotels, transfers, cars and other travel services for professionals of the tourism market (travel agents, operators and corporate clients). </p><br><p>  In B2B, we have designed and quite successfully use an abstract order model based on <a href="https://docs.djangoproject.com/en/2.1/ref/contrib/contenttypes/"><code>GenericForeignKey</code></a> ‚Äî meta-order ‚Äî <code>MetaOrder</code> . </p><br><p>  A meta-order is an abstract entity that can be used regardless of which type of order it belongs to: hotel ( <code>Hotel</code> ), additional service ( <code>Upsell</code> ) or car ( <code>Car</code> ).  In the future we may have other types. </p><br><p>  This was not always the case.  When the B2B service was launched, only hotels could be booked through it, and all business logic was oriented towards them.  Many fields have been created, for example, to display the exchange rates of the sale amount and the refund amount of the reservation.  Over time, we realized how best to store and reuse this data, given the meta-orders.  But the whole code could not be rewritten, and part of this heritage came into the new architecture.  Actually, this led to difficulties in calculations, which use several types of orders.  What to do - so <em>historically</em> ... </p><br><p>  My goal is to show on our example the power of Django ORM. </p><br><h2 id="predystoriya">  Prehistory </h2><br><p>  Our B2B clients for planning their expenses didn‚Äôt have enough information about how much they need to pay now / tomorrow / later, whether they have debts on orders and what is its size, as well as how much more they can spend within their limits.  We decided to show this information in the form of a dashboard - such a simple socket with a clear diagram. </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="dash1"><br>  <em>(all values ‚Äã‚Äãare test and do not apply to a specific partner)</em> </p><br><p>  At first glance, everything is quite simple - we filter all the orders of a partner, summarize and show. </p><br><h2 id="varianty-resheniya">  Solution options </h2><br><p>  A little explanation of how we make the calculations.  We are an international company, our partners from different countries conduct transactions - they buy and resell reservations - in different currencies.  At the same time, they should receive financial statements in their chosen currency (usually local).  It would be foolish and impractical to store all possible data on the rates of all currencies, so you need to select a reference currency, for example, the ruble.  Thus, it is possible to store the rates of all currencies only to the ruble  Accordingly, when a partner wants to receive a summary, we convert the amount at the rate set at the time of sale. </p><br><h3 id="v-lob">  "Head-on" </h3><br><p>  In fact, this is <code>Model.objects.all()</code> and a loop with conditions: </p><br><div class="spoiler">  <b class="spoiler_title">Model.objects.all () with conditions</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p>  This request will return a generator, which potentially contains several hundred bookings.  Each of these bookings will be requested in the database, and therefore the cycle will work for a very long time. </p><br><p>  You can speed things up a bit by adding the <a href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/"><code>prefetch_related</code></a> method: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p>  Then there will be slightly fewer requests to the database (referrals by <code>GenericForeignKey</code> ), but all the same, in the end, we will rest on their number, because the query to the database will still be made for each iteration of the cycle. </p><br><p>  The <code>output</code> method can (and should) be cached, but still the first call runs on the order of a minute, which is completely unacceptable. </p><br><p>  Here are the results of this approach: </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="timing_before"></p><br><p>  The average response time is 4 seconds, and there are peaks reaching 21 seconds.  Pretty long. </p><br><p>  We didn‚Äôt roll out dashboards for all partners, and therefore we didn‚Äôt have so many requests to him, but still enough to understand that this approach is not effective. </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>The numbers on the bottom right are the number of requests: minimum, maximum, average, total.</em> </p><br><h3 id="s-umom">  Wisely </h3><br><p>  The head-on prototype was good for understanding the complexity of the task, but is not optimal for use.  We decided that it would be much quicker and less resource-intensive to make several complex queries to the database than many simple ones. </p><br><h4 id="plan-zaprosa">  Query plan </h4><br><p>  With broad strokes, the query plan can be described like this: </p><br><ul><li>  collect orders for initial conditions, </li><li>  prepare the fields for calculation through <code>annotate</code> , </li><li>  calculate field values </li><li>  make <code>aggregate</code> by amount and quantity, </li></ul><br><h4 id="nachalnye-usloviya">  Initial conditions </h4><br><p>  Partners who enter the site can only see information on their contract. </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p>  In the case when we do not want to show new types of orders / reservations, you need to filter only supported ones: </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p>  Order status is important (more about <a href="https://docs.djangoproject.com/en/2.1/topics/db/queries/"><code>Q</code></a> ): </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p>  We also often use pre-prepared requests, for example, to exclude all orders that cannot be paid.  There are quite a lot of business logic there, which is not very interesting to us in this article, but in fact it‚Äôs just additional filters.  A method that returns a prepared query might look like this: </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p>  As you can see, this is a class method that also returns a <code>QuerySet</code> . </p><br><p>  We will also prepare a couple of variables for conditional constructions and for storing the results of calculations: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate">  Field preparation ( <a href="https://docs.djangoproject.com/en/2.1/ref/models/querysets/"><code>annotate</code></a> ) </h4><br><p>  Due to the fact that we have to refer to the fields depending on the type of order, we will apply <a href="https://docs.djangoproject.com/en/2.1/ref/models/database-functions/"><code>Coalesce</code></a> .  Thus, we will be able to abstract any number of new types of orders in a single field. </p><br><p>  Here is the first part of the <code>annotate</code> block: </p><br><div class="spoiler">  <b class="spoiler_title">First annotate</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code> works here with a bang, because hotel orders have several special properties, and in all other cases (additional services and cars) these properties are not important to us.  So appear <code>Value(ZERO)</code> for the sums and <code>Value(ONE)</code> for exchange rates.  <code>ZERO</code> and <code>ONE</code> are <code>Decimal('0')</code> and <code>Decimal(1)</code> , only in the form of constants.  The approach is an amateur, but in our project it is so accepted. </p><br><p>  You might ask, why not put some fields one level higher in a meta-order?  For example, <code>payment_pending</code> , which is everywhere.  Indeed, over time, we transfer such fields into a meta-order, but now the code works well, so such tasks are not our priority. </p><br><h4 id="esche-odna-podgotovka-i-raschety">  Another preparation and calculations </h4><br><p>  Now we need to make some calculations with the sums that we received in the past <code>annotate</code> block.  Notice, here you no longer need to be tied to the type of order (except for one exception). </p><br><div class="spoiler">  <b class="spoiler_title">Second annotate</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p>  The most interesting part of this block is the <code>_reporting_currency_rate</code> field, or the exchange rate to the reference currency at the time of sale.  Data on the rates of all currencies to the reference currency for a hotel order are stored in <code>currency_data</code> .  This is just JSON.  Why do we keep it like this?  <em>So historically</em> . </p><br><p>  And here, it would seem, why not use <a href="https://docs.djangoproject.com/en/2.1/ref/models/expressions/"><code>F</code></a> and not substitute the value of the currency of the contract?  That is, it would be cool if you could do this: </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p>  But <code>f-strings</code> not supported in <code>F</code>  Although the fact that Django ORM already has the ability to refer to nested json-fields is very pleasing - <code>F('currency_data__USD')</code> . </p><br><p>  And the last <code>annotate</code> block is the calculation <code>_payable_in_cur</code> , which will be summed up for all orders.  This value must be in the currency of the contract. </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  The peculiarity of the <code>annotate</code> method is that it generates a lot of <code>SELECT something AS something_else</code> constructions that are not directly involved in the query.  This can be seen by unloading the SQL query - <code>query.__str__()</code> . </p><br><p>  <a href="https://gist.github.com/biozz/0de1f7af557a9360a096fd9a2f0bf110">This is the</a> SQL generated by the Django ORM for <code>base_query_annotated</code> .  It is quite often necessary to read it to understand where it is possible to optimize request. </p><br><h4 id="zaklyuchitelnye-podschety">  Final calculations </h4><br><p>  There will be a small <code>aggregate</code> wrapper so that in the future, if a partner needs some other metric, it can be easily added. </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p>  And one more thing - this is the last filtering by business condition, for example, we need all the orders that need to be paid soon. </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="dash4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka">  Debugging and checking </h4><br><p>  A very convenient way to verify the correctness of a created request is to verify it with a more readable version of calculations. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p>  Do you know the method "in the forehead"? </p><br><h3 id="finalnyy-kod">  Final code </h3><br><p>  As a result, we got something like the following: </p><br><div class="spoiler">  <b class="spoiler_title">Final code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p>  This is how it works now: </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="timing_after"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody">  findings </h2><br><p>  By rewriting and optimizing the logic, we managed to make a fairly fast handle for partner metrics and greatly reduce the number of queries to the database.  The solution was good and we will reuse this logic in other parts of the project.  ORM is our everything. </p><br><p>  Write comments, ask questions - we will try to answer!  Thank! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447706/">https://habr.com/ru/post/447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447696/index.html">Why cities resist Amazon Go, first cashless stores</a></li>
<li><a href="../447698/index.html">Red Hogwarts: Academician without a diploma</a></li>
<li><a href="../447700/index.html">Emotional flexibility is the key to personal growth.</a></li>
<li><a href="../447702/index.html">There is no perfect mathematical circle.</a></li>
<li><a href="../447704/index.html">Climbing Elbrus - Reconnaissance. Technical Part 1. Registers, stacks and other technical details</a></li>
<li><a href="../447708/index.html">Yandex presented the first Ilya Segalovich awards to young scientists and supervisors</a></li>
<li><a href="../447712/index.html">Hi, SaaS | Russian SaaS 2018 - results</a></li>
<li><a href="../447714/index.html">On the application of the theory of ARMA-processes in engineering practice</a></li>
<li><a href="../447716/index.html">Unity: draw a lot of health bars in one drawcall</a></li>
<li><a href="../447718/index.html">Everything will go according to plan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>