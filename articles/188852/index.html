<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiquay generator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, the month of Quinys, so I want to share my development, which I did four years ago. 

 A good multiquine is a piece of engineering, but ... ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiquay generator</h1><div class="post__text post__text-html js-mediator-article">  On Habr√©, the month of Quinys, so I want to share my development, which I did four years ago. <br><br>  A good multiquine is a piece of engineering, but ... <br>  When you look at the next batch of ‚Äúinterference on the telegraph line,‚Äù an ordinary programmer has only the amazement: ‚Äúhow is this even possible‚Äù, and ‚Äúwho was that gloomy Teutonic genius.‚Äù <br>  I want to break the covers and show how easy it is to write a multiquine of any degree of complexity in any set of programming languages, including whitespace and brainfack. <br><br>  Since we are dealing with the texts of programs and the results of their execution, it would be natural to look at this business as functions on strings. <br><a name="habracut"></a><br><h4>  Functions </h4><br>  What features do we have? <br>  First, it is an <b>interpreter</b> : it takes the program text, compiles it, runs it, and returns the text from the standard output. <br>  Let's call this function simply: <b>RUN</b> . <br>  Since we will not be limited to one language, then, in fact, we have a whole family: RUNpython, RUNc, RUNbrainfuck ... <br>  It is clear that these functions are implemented in different ways, but how exactly - it should not worry us.  After all, we do not write our own interpreter of the language, and even more so, in the same language. <br>  In general, the main implementation will now be in our head, because we will solve the string equations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Secondly, an important family of functions are <b>decorators</b> and <b>writers</b> .  The decorator takes an arbitrary string and replaces special characters in it, and then the writer frames the string with quotes. <br>  L x = qopen + D x + qclose <br>  An important property of decorators is the additivity of the addition (concatenation) of rows: E (x + y) = Ex + Ey. <br><br>  By the way, we will immediately agree: for compact recording, the functions will be large letters, the lines are small, Fx - applying the function F to x, FGx - applying F to Gx, or, equivalently, applying the composition FG to x. <br><br><h4>  Quineas </h4><br>  If you look at the smallest quine on C, <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*f=<span class="hljs-string"><span class="hljs-string">"char*f=%c%s%c;main(){printf(f,34,f,34,10);}%c"</span></span>;main(){<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(f,<span class="hljs-number"><span class="hljs-number">34</span></span>,f,<span class="hljs-number"><span class="hljs-number">34</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>);}</code> </pre> <br>  then we will see a characteristic pattern.  Here, two program fragments are repeated two times - once as the text of the top level, another time as the string literal. <br><br>  So we write: <code>quine = a + b + Ea + c + Ee + d + e</code> <br><br>  Exactly in the same way, we can make quine on python: <br><pre> <code class="python hljs">s1,s2 = <span class="hljs-string"><span class="hljs-string">'s1,s2 = '</span></span>, <span class="hljs-string"><span class="hljs-string">"\nprint s1+repr(s1)+', '+repr(s2)+s2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> s1+repr(s1)+<span class="hljs-string"><span class="hljs-string">', '</span></span>+repr(s2)+s2</code> </pre><br>  Or, a little more clearly and verbally: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># this is quine s1 = '# this is quine' s2 = 'print s1\nprint "s1="+repr(s1)\nprint "s2="+repr(s2)\nprint s2' print s1 print "s1="+repr(s1) print "s2="+repr(s2) print s2</span></span></code> </pre><br>  Substrings a and e are informative, large texts that cannot be programmatically generated;  substrings b, c, d - glue, usually consisting of quotation marks, carriage transfers, etc. <br><br>  Speaking of clarity.  It is convenient to consider the program text not as a monolithic string, but as a list of strings.  In another article, I will definitely return to this, and show a couple of ways how to work with lists. <br>  In the meantime, back to Quine. <br>  The RUN function is defined for the quine: <code>RUN quine = quine</code> . <br>  That is, a quine is a fixed point of the RUN function. <br>  Let's summarize a little quine.  What if we learn to output arbitrary strings in arbitrary ways? <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Q</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,f,g,h,i,j) = a + b + <span class="hljs-type"><span class="hljs-type">Ef</span></span> + c + <span class="hljs-type"><span class="hljs-type">Ej</span></span> + d + e <span class="hljs-comment"><span class="hljs-comment">--  a,b,c,d,e -  () F  g,h,i. RUN Q(F,f,g,h,i,j) = f + g + Ff + h + Fj + i + j</span></span></code> </pre><br>  On the same python: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># this is Q def F(s) : '''     F   ''' s1 = 'Ef' s2 = 'Ej' print s1 + 'Eg' + F(s1) + 'Eh' + F(s2) + 'Ei' + s2 #  Ef, Eg, Eh, Ei, Ej ‚Äî  -</span></span></code> </pre><br>  Quine is a solution to the permutation equation: <code>RUN Q(F,f,g,h,i,j) = Q(F,f,g,h,i,j)</code> <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">RUN</span></span> <span class="hljs-type"><span class="hljs-type">Q</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,f,g,h,i,j) = f + b + <span class="hljs-type"><span class="hljs-type">Ff</span></span> + c + <span class="hljs-type"><span class="hljs-type">Fj</span></span> + d + e <span class="hljs-type"><span class="hljs-type">Q</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,f,g,h,i,j) = a + b + <span class="hljs-type"><span class="hljs-type">Ff</span></span> + c + <span class="hljs-type"><span class="hljs-type">Ej</span></span> + d + e</code> </pre><br>  From where F = E, i.e. the program method of decoration coincides with the decoration according to the rules of the language;  fragments of the text - it is clear that with what is the same. <br><br>  Another digression: even within one language, decorators can be very, very different.  We can represent strings as an array of numbers, for example. <br>  Then the output of the ‚Äústring‚Äù 104, 97, 98, 114 is the print '' .join (map (chr), xs), and the output in the decorated form is the print ','. Join (map (str), xs). <br><br>  Note: RUN and Q functions are defined above strings (Q is generally a higher order function defined above strings and a function), but their implementation lies outside the target programming language in which we write quine.  Whereas function E must be implemented as text in the target language! <br><br><h4>  Printers </h4><br>  And now let's look at another, very simple program.  This program prints the specified text. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">printer</span></span> = p + <span class="hljs-type"><span class="hljs-type">Sq</span></span> + r <span class="hljs-type"><span class="hljs-type">RUN</span></span> printer = q</code> </pre><br>  where S is some way of decorated text storage. <br><br>  Since we can write a <b>printer</b> for completely arbitrary text, we will make a function: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">P</span></span>(q) = p + <span class="hljs-type"><span class="hljs-type">Sq</span></span> + r</code> </pre><br>  Of course, the invariant: <code>RUN P(q) = q</code> <br>  That is, the printer is a function inverse to the interpreter! <br><br>  In C: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { printf("%s", "hello\nhabr"); return 0; }</span></span></span></span></code> </pre><br>  On python: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">""" hello RSDN """</span></span></code> </pre><br>  That is, the function S here coincides with the good old E. (On the python - even simpler, you don‚Äôt have to escape the line feed). <br>  And here - does not match: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { putchar(114);putchar(115);putchar(100);putchar(110); return 0; }</span></span></span></span></code> </pre><br>  The printer P favorably differs from the Q Qine in that its elements ‚Äî p and r ‚Äî do not depend on the parameters of the function. <br><br>  It's easy to make a <b>meta-</b> printer out of a printer: a program that prints a program that prints text. <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Pmeta</span></span> (q) = <span class="hljs-type"><span class="hljs-type">PPq</span></span> = <span class="hljs-type"><span class="hljs-type">P</span></span>(p + <span class="hljs-type"><span class="hljs-type">Sq</span></span> + r) = p + <span class="hljs-type"><span class="hljs-type">S</span></span>(p + <span class="hljs-type"><span class="hljs-type">Sq</span></span> + r) + r = p + <span class="hljs-type"><span class="hljs-type">Sp</span></span> + <span class="hljs-type"><span class="hljs-type">SSq</span></span> + <span class="hljs-type"><span class="hljs-type">Sr</span></span> + r pmeta = p + <span class="hljs-type"><span class="hljs-type">Sp</span></span> <span class="hljs-type"><span class="hljs-type">Smeta</span></span> = <span class="hljs-type"><span class="hljs-type">SS</span></span> rmeta = <span class="hljs-type"><span class="hljs-type">Sr</span></span> + r <span class="hljs-type"><span class="hljs-type">RUN</span></span> (<span class="hljs-type"><span class="hljs-type">RUN</span></span>( <span class="hljs-type"><span class="hljs-type">Pmeta</span></span>(q) )) = q</code> </pre><br><br>  No one bothers us to make a multilingual printer: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Pbilingua</span></span>(q) = <span class="hljs-type"><span class="hljs-type">P'P</span></span><span class="hljs-string"><span class="hljs-string">"q = P'(p"</span></span> + <span class="hljs-type"><span class="hljs-type">S</span></span><span class="hljs-string"><span class="hljs-string">"q + r"</span></span>) = p' + <span class="hljs-type"><span class="hljs-type">S'p</span></span><span class="hljs-string"><span class="hljs-string">" + S'S"</span></span>q + <span class="hljs-type"><span class="hljs-type">S'r</span></span><span class="hljs-string"><span class="hljs-string">" + r' RUN"</span></span>(<span class="hljs-type"><span class="hljs-type">RUN'</span></span>(<span class="hljs-type"><span class="hljs-type">Pbilingua</span></span>(q))) = <span class="hljs-type"><span class="hljs-type">RUN</span></span><span class="hljs-string"><span class="hljs-string">"(RUN'(P'P"</span></span>(q))) = <span class="hljs-type"><span class="hljs-type">RUN</span></span><span class="hljs-string"><span class="hljs-string">"(P"</span></span>(q)) = q</code> </pre><br><br>  And in general, you can use as many languages ‚Äã‚Äãas you like ( <b>multi-printer</b> ): <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Pmulti</span></span>(q) = pmulti + <span class="hljs-type"><span class="hljs-type">Smultiq</span></span> + rmulti pmulti = p1 + <span class="hljs-type"><span class="hljs-type">S1p2</span></span> + <span class="hljs-type"><span class="hljs-type">S1S2p3</span></span> + <span class="hljs-type"><span class="hljs-type">S1S2S3p4</span></span> <span class="hljs-type"><span class="hljs-type">Smulti</span></span> = <span class="hljs-type"><span class="hljs-type">S1S2S3S4</span></span> rmulti = <span class="hljs-type"><span class="hljs-type">S1S2S3r4</span></span> + <span class="hljs-type"><span class="hljs-type">S1S2r3</span></span> + <span class="hljs-type"><span class="hljs-type">S1r2</span></span> + r1</code> </pre><br><br>  All we need is to learn how to make the composition of the functions of the decorators.  (About this - below). <br><br>  And one more printer, for completeness: this is a <b>null printer</b> P0 (text) = text <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p0</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> r0 = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-type"><span class="hljs-type">S0</span></span> = id</code> </pre><br><br><h4>  Ping pong </h4><br>  Well, now let's cross the printer (or multi-printer) and quine. <br>  This is where a solution to the equation is needed <br>  Let's call these programs ping and pong: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">RUN</span></span> ping = pong <span class="hljs-type"><span class="hljs-type">RUN</span></span> pong = ping</code> </pre><br><br>  And let ping is a P (pong) printer, and pong is something more intricate.  If this were P (ping), then an infinitely expanding string would result, and we want a final solution. <br>  So let pong = Q (F, f, g, h, i, j). <br>  Substitute: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ping</span></span> = <span class="hljs-type"><span class="hljs-type">P</span></span> pong = p + <span class="hljs-type"><span class="hljs-type">S</span></span> pong + r = p + <span class="hljs-type"><span class="hljs-type">S</span></span>(a + b + <span class="hljs-type"><span class="hljs-type">Ef</span></span> + c + <span class="hljs-type"><span class="hljs-type">Ej</span></span> + d + e) + r = p + <span class="hljs-type"><span class="hljs-type">Sa</span></span> + <span class="hljs-type"><span class="hljs-type">Sb</span></span> + <span class="hljs-type"><span class="hljs-type">SEf</span></span> + <span class="hljs-type"><span class="hljs-type">Sc</span></span> + <span class="hljs-type"><span class="hljs-type">SEj</span></span> + <span class="hljs-type"><span class="hljs-type">Sd</span></span> + <span class="hljs-type"><span class="hljs-type">Se</span></span> + r = (p + <span class="hljs-type"><span class="hljs-type">Sa</span></span> + <span class="hljs-type"><span class="hljs-type">Sb</span></span>) + <span class="hljs-type"><span class="hljs-type">SEf</span></span> + <span class="hljs-type"><span class="hljs-type">Sc</span></span> + <span class="hljs-type"><span class="hljs-type">SEj</span></span> + (<span class="hljs-type"><span class="hljs-type">Sd</span></span> + <span class="hljs-type"><span class="hljs-type">Se</span></span> + r) ping = <span class="hljs-type"><span class="hljs-type">RUN</span></span> pong = f + g + <span class="hljs-type"><span class="hljs-type">Ff</span></span> + h + <span class="hljs-type"><span class="hljs-type">Fj</span></span> + i + j</code> </pre><br>  Why so, <code>f = p+Sa+Sb</code> , and not <code>g=Sa+Sb</code> , for example? <br>  The fact is that f and j are specifically designed for recursion: we can easily mention in them fragments of the pong source code (substrings a, b, d, e), while recursion in g, h, i is undesirable. <br><br>  So we got <br> <code>pong = a+b + E(p+Sa+Sb) + c + E(Sd+Se+r) + d+e</code> <br> <br>  and somewhere in the depths of a or e, the function F = SE and the string ESc are hidden. <br>  Note: if e contains ESc, recursion does not occur, because c does not depend on e. <br><br>  Let us now get rid of these "in the depths of hiding."  Take another function. <br>  Let be <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pong</span></span> = <span class="hljs-type"><span class="hljs-type">R</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,x,y,z) = a + <span class="hljs-type"><span class="hljs-type">Ex</span></span> + b + <span class="hljs-type"><span class="hljs-type">Ez</span></span> + c + <span class="hljs-type"><span class="hljs-type">Ey</span></span> + d <span class="hljs-type"><span class="hljs-type">RUN</span></span> <span class="hljs-type"><span class="hljs-type">R</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,x,y,z) = x + <span class="hljs-type"><span class="hljs-type">Fx</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fz</span></span> + z <span class="hljs-type"><span class="hljs-type">P</span></span> pong = p+<span class="hljs-type"><span class="hljs-type">Sa</span></span> + <span class="hljs-type"><span class="hljs-type">SEx</span></span> + <span class="hljs-type"><span class="hljs-type">Sb</span></span> + <span class="hljs-type"><span class="hljs-type">SEz</span></span> + <span class="hljs-type"><span class="hljs-type">Sc</span></span>+<span class="hljs-type"><span class="hljs-type">SEy</span></span>+<span class="hljs-type"><span class="hljs-type">Sd</span></span>+r <span class="hljs-type"><span class="hljs-type">RUN</span></span> pong = x + <span class="hljs-type"><span class="hljs-type">Fx</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fz</span></span> + z</code> </pre><br><br>  So we got: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">F</span></span> = <span class="hljs-type"><span class="hljs-type">SE</span></span> x = p+<span class="hljs-type"><span class="hljs-type">Sa</span></span> y = <span class="hljs-type"><span class="hljs-type">Sb</span></span> z = <span class="hljs-type"><span class="hljs-type">Sc</span></span>+<span class="hljs-type"><span class="hljs-type">SEy</span></span>+<span class="hljs-type"><span class="hljs-type">Sd</span></span>+r = <span class="hljs-type"><span class="hljs-type">Sc</span></span> + <span class="hljs-type"><span class="hljs-type">SESb</span></span> + <span class="hljs-type"><span class="hljs-type">Sd</span></span> + r</code> </pre><br><br>  If you define pong a little differently, <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pong</span></span> = <span class="hljs-type"><span class="hljs-type">R</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,x,y,z) = a + <span class="hljs-type"><span class="hljs-type">Ex</span></span> + b + <span class="hljs-type"><span class="hljs-type">Ey</span></span> + b + <span class="hljs-type"><span class="hljs-type">Ez</span></span> + c <span class="hljs-type"><span class="hljs-type">RUN</span></span> <span class="hljs-type"><span class="hljs-type">R</span></span>(<span class="hljs-type"><span class="hljs-type">F</span></span>,x,y,z) = x + <span class="hljs-type"><span class="hljs-type">Fx</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fy</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fz</span></span> + z</code> </pre><br>  that is, if we get the hang of having a list of string constants, then we'll get rid of the double decoration: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">P</span></span> pong = p+<span class="hljs-type"><span class="hljs-type">Sa</span></span> + <span class="hljs-type"><span class="hljs-type">SEx</span></span> + <span class="hljs-type"><span class="hljs-type">Sb</span></span> + <span class="hljs-type"><span class="hljs-type">SEy</span></span> + <span class="hljs-type"><span class="hljs-type">Sb</span></span> + <span class="hljs-type"><span class="hljs-type">SEz</span></span> + <span class="hljs-type"><span class="hljs-type">Sc</span></span>+r <span class="hljs-type"><span class="hljs-type">RUN</span></span> pong = x + <span class="hljs-type"><span class="hljs-type">Fx</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fy</span></span> + y + <span class="hljs-type"><span class="hljs-type">Fz</span></span> + z</code> </pre><br><br>  Thus, if we have blanks for <code>P = {S, p,r}</code> and for <code>R = {E,a,b,c}</code> , then we will immediately turn them into ping-pong.  And do not forget that P can be a multi-printer.  Then the ping-pong will oscillate with a period of n + 1, where n is the multiplicity of the multiprinter.  And if P is a null printer, then ping-pong oscillates with a period of 1 and (who would have thought?) Becomes quine. <br><br>  The last thing left for us is to make the composition SE. <br>  Formally, the task sounds like this. <br>  Given: pong programming language;  decorators E and S, and E is native to this language, and S is any. <br>  Find: the text of the subroutine in pong language that implements the decorator SE. <br>  And at the same time, implement decorators E and SE in the language of the development environment.  After all, we want to automate the generation of multikvaynov? <br><br>  To do this, let's look at how the decorators are arranged. <br>  The decorator is distributive in addition: F (a + b) = Fa + Fb. <br>  If we break a string into elementary parts - single-character strings, we get <br> <code>F(abcd‚Ä¶) = Fa + Fb + Fc + Fd + ‚Ä¶</code> <br>  Decorators are associative: <br> <code>FG(abcd‚Ä¶) = FGa + FGb + FGc + FGd + ‚Ä¶</code> <br> <br>  Therefore, we can present the decorator as a coding table of each character, and recalculate the composition into a table with the same number of keys, but with longer values. <br><br>  Thus, the work plan is the following: <br>  Given: <br><ul><li>  Printers <code>{Sk,pk,rk}</code> in which languages ‚Äã‚Äãare unknown (all we need are only table implementations of Sk functions); </li><li>  pong pattern <code>{E,a(F),b,c(F)}</code> , where a or d reserve space for an arbitrary codebook F (therefore, a and c are not strings or functions above strings, but functions of higher order). </li></ul><br>  We act: <br><ol><li>  We find the multiprinter <code>{S,p,r}</code> , calculating <code>S1S2...</code> according to the tables. </li><li>  Find the table <code>F = SE</code> . </li><li>  If desired, we find the minimum alphabet - the set of symbols that make up p, r, Sa, Sb, Sc, Sd.  This is in order not to pile up the coding table of the entire ASCII or, God forbid, unicode. </li><li>  Spread the table in a or c. </li><li>  We find <code>x=(p+Sa), y=(Sb), z=(Sc+r)</code> . </li><li>  Form a pong: <code>a+Ex+b+Ey+b+Ey+c</code> . </li></ol><br>  Everything! <br><br>  And since all these steps are too laborious to do manually, then let's write a quine generator. <br>  Here, for a seed, the code on python, which (at the moment) makes multiquains from python and si. <br>  To supplement it with any other languages ‚Äã‚Äãis a matter of ten minutes. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#-*- coding: utf-8 -*- #  - ,     def I(c) : ''' id-,    ''' return c def C(c) : '''      ''' if c=='"' or c=='\\' or ord(c)&lt;32 or ord(c)&gt;126 : return '\\%03o' % ord(c) # ,  ,      #           , #     : \x24bad -    chr(0x24BAD),    $bad else : return c def decor(F,s) : '''     ''' return ''.join(map(F,s)) #       def compose(F,G) : '''   ''' return lambda c : decor(F,G(c)) #  -  (S,p,r) def make_printer(S, tpl, tag = '&lt;-T-&gt;') : '''      ( &lt;-T-&gt; ,   ) ''' p,r = tpl.split(tag) return S,p,r nul_printer = (I,'','') def show_printer(prn, t) : '''       t ''' S,p,r = prn return p + decor(S,t) + r def meta_printer(prn1, prn2) : '''   ''' S1,p1,r1 = prn1 S2,p2,r2 = prn2 S = compose(S1,S2) p = p1 + decor(S1,p2) r = decor(S1,r2) + r1 return S,p,r #  - ,      -  (E, am, b, cm) #  am  cm -  decorator -&gt; string def make_quiner(E, M, tpl, tagX = '&lt;-X-&gt;', tagF = '&lt;-F-&gt;') : '''       &lt;-X-&gt;       x,y,z,  &lt;-F-&gt; ,     F  E -  ,  M      ''' a,b,b_,c = tpl.split(tagX) assert b==b_ am = lambda F : a.replace(tagF, M(F)) if tagF in a else a cm = lambda F : c.replace(tagF, M(F)) if tagF in c else c return E,am,b,cm def show_quiner(qnr, F,x,y,z) : '''         a,Ex,b,Ey,b,Ez,c --  x,Fx,y,Fy,y,Fz,z -- ,     (RUN) ''' E,am,b,cm = qnr a,c = am(F), cm(F) ex,ey,ez = decor(E,x), decor(E,y), decor(E,z) return a + ex + b + ey + b + ez + c def show_quiner_printer(qnr,prn) : '''      p+Sa,SEx,Sb,SEy,Sb,SEz,Sc+r --   x , Fx, y , Fy, y , Fz, z --    ''' E,am,b,cm = qnr S,p,r = prn F = compose(S,E) a,c = am(F), cm(F) x = p + decor(S,a) y = decor(S,b) z = decor(S,c) + r ex,ey,ez = decor(E,x), decor(E,y), decor(E,z) return a + ex + b + ey + b + ez + c ############################################################# #     : c_quine_tpl = '''/* C quine */ #include &lt;stdio.h&gt; const char* f[128] = {&lt;-F-&gt;}; const char* xyz[3] = {"&lt;-X-&gt;", "&lt;-X-&gt;", "&lt;-X-&gt;"}; void ps(const char* s) { while(*s) putchar(*s++); } void pm(const char* s) { while(*s) ps(f[*s++]); } int main() { ps(xyz[0]); /* x */ pm(xyz[0]); /* Fx */ ps(xyz[1]); /* y */ pm(xyz[1]); /* Fy */ ps(xyz[1]); /* y */ pm(xyz[2]); /* Fz */ ps(xyz[2]); /* z */ return 0; } ''' def c_quine_M(F) : '''   -     ''' codes = [ '"%s"' % decor(C,decor(F,chr(i))) for i in xrange(128) ] return ', '.join(codes) c_quiner = make_quiner(C, c_quine_M, c_quine_tpl) #    ,           py_quine_tpl = '''#!/usr/bin/python import sys m = [ &lt;-F-&gt; ] xyz = [ "&lt;-X-&gt;", "&lt;-X-&gt;", "&lt;-X-&gt;" ] def ps(s) : sys.stdout.write(s) def pm(s) : for c in s : ps(m[ord(c)]) ps(xyz[0]) pm(xyz[0]) ps(xyz[1]) pm(xyz[1]) ps(xyz[1]) pm(xyz[2]) ps(xyz[2]) ''' py_quiner = make_quiner(C, c_quine_M, py_quine_tpl) #     ################### #     : c_printer_tpl = '''#include &lt;stdio.h&gt; int main() { printf("%s", "&lt;-T-&gt;"); return 0; } ''' c_printer = make_printer(C, c_printer_tpl) py_printer_tpl = '''import sys sys.stdout.write("&lt;-T-&gt;") ''' py_printer = make_printer(C, py_printer_tpl) #################### # !    c_c_printer = meta_printer(c_printer, c_printer) py_py_printer = meta_printer(py_printer, py_printer) #  1  c_quine = show_quiner_printer(c_quiner, nul_printer) py_quine = show_quiner_printer(py_quiner, nul_printer) #  2  c_c_quine = show_quiner_printer(c_quiner, c_printer) py_py_quine = show_quiner_printer(py_quiner, py_printer) #  2  -  c_py_quine = show_quiner_printer(c_quiner, py_printer) py_c_quine = show_quiner_printer(py_quiner, c_printer) #  3  - -   c_c_c_quine = show_quiner_printer(c_quiner, c_c_printer) py_py_py_quine = show_quiner_printer(py_quiner, py_py_printer) c_py_py_quine = show_quiner_printer(c_quiner, py_py_printer) py_c_c_quine = show_quiner_printer(py_quiner, c_c_printer) sys.stdout.write(py_py_py_quine) # ,  , - ...</span></span></code> </pre><br>  The source code and its fruits can be found on the bucket: <a href="https://bitbucket.org/nickolaym/quines">bitbucket.org/nickolaym/quines</a> <br><br>  Of course, the machine-generated multiquine is not very elegant.  Its size is 5438 bytes, most of which is occupied by the codepage. <br><br>  How to make it more compact (while preserving the universality of the approach and the possibility for machine generation) - I propose to solve this problem on your own. <br><br>  If you like, I'll write more on this topic: <br><ul><li>  programs as list functions </li><li>  features of stupid languages ‚Äã‚Äãlike brainfack </li></ul><br><br>  Also see my stream of consciousness on the RSDN, 4 years ago.  <a href="http://rsdn.ru/forum/etude/3604693">http://rsdn.ru/forum/etude/3604693</a> . </div><p>Source: <a href="https://habr.com/ru/post/188852/">https://habr.com/ru/post/188852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188832/index.html">New Google service will help you find the missing phone.</a></li>
<li><a href="../188842/index.html">Again about ORM performance, or a new promising project - Pony ORM</a></li>
<li><a href="../188846/index.html">Experts call to prepare for cryptoapocalypse</a></li>
<li><a href="../188848/index.html">Install, configure OpenDNSSEC 1.3.x and 1.4.1, NSD, FreeBSD 9.2</a></li>
<li><a href="../188850/index.html">Love and hate java 8</a></li>
<li><a href="../188854/index.html">North Korean Android based tablet</a></li>
<li><a href="../188858/index.html">Metric # 17 - Podcast on technologies and design of interfaces and services</a></li>
<li><a href="../188860/index.html">A simple example of using the Volley library</a></li>
<li><a href="../188862/index.html">Remake of Paperboy with Oculus Rift and Kinect</a></li>
<li><a href="../188866/index.html">Petitions demanding to ban the game "Company of Heroes-2" in the CIS, scored about 15 thousand signatures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>