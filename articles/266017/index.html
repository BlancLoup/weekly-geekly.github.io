<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Centrifuge + Go = Centrifugo - harder, better, faster, stronger</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last September, the last article on Centrifuge, an open source server for real-time messaging, was published . Now Go is on the list of hubs to which ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Centrifuge + Go = Centrifugo - harder, better, faster, stronger</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/878/4ab/ca7/8784abca7cfa4aae80c81eda487beb66.png"><br><br>  Last September, the last article on Centrifuge, an open source server for real-time messaging, was <a href="http://habrahabr.ru/company/mailru/blog/237257/">published</a> .  Now Go is on the list of hubs to which this post is published.  And for good reason, as you can already understand from the title, the centrifuge was ported from Python to Go - this is how <a href="https://github.com/centrifugal/centrifugo">Centrifugo</a> appeared.  About the reasons for migration, about the pros and cons of Go, as well as how the project has evolved since the previous publication - read under the cut. <br><a name="habracut"></a><br>  In the post (and, apparently, later in life) I will call the server in general Centrifuge, and if you want to emphasize the difference between implementations in different languages, I will use the English name - Centrifuge for the Python version, Centrifugo - for the Go version. <br><br>  Very briefly about what a centrifuge is.  This is the server that runs next to the backend of your application.  Application users connect to Centrifuge using the Websocket protocol or the SockJS polyfill library.  Having connected and authorized, they subscribe to the channels of interest to them.  As soon as the application backend learns about a new event, it sends it to the desired channel in Centrifuge (using a queue in Redis or HTTP API), which, in turn, sends a message to all connected interested users. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/d89/316/1a8/d893161a87ff47f58978a4d914c50dcd.png"><br><br>  Thus, Centrifuge solves the problems of a number of modern common frameworks (such as Django, Ruby on Rails, Laravel, etc.), with which the backend of many web applications is written.  When the backend is not able to work asynchronously, and the pool of workers that process requests is limited, then processing of persistent connections from clients instantly leads to the exhaustion of this pool.  Of course, nothing prevents you from using Centrifuge and paired with your asynchronous backend, just to reduce the amount of work that needs to be done for development. <br><br>  There are a lot of solutions like Centrifuge, and I mentioned some of them in previous articles.  The main features are several things: <br><br><ul><li>  independence of the language in which the application backend is written; </li><li>  using SockJS: allows all users whose browsers for one reason or another cannot establish a Websocket connection, receive new messages via fallback transport (eventsource, xhr-streaming, xhr-polling, etc.); </li><li>  user authorization based on the use of a signed token (HMAC SHA-256); </li><li>  the ability to run several processes associated with radishes; </li><li>  information about current users in the channel, history of messages in the channels, messages about subscription to the channel by the user or unsubscribing from the channel;  Most PUB / SUB solutions can only send new messages; </li><li>  full deployment readiness: rpm, Dockerfile, Nginx config;  and now releases in the form of a binary file for all platforms. </li></ul><br>  Previously, I focused on the fact that the main purpose of a centrifuge is instant messages in web applications.  Perhaps the ‚Äúweb‚Äù prefix slightly hides the potential of the project: you can also connect to the Centrifuge from mobile applications using the Websocket-protocol.  This has been confirmed by some users in the opensource community.  But unfortunately, there are no clients for mobile devices, that is, in Java or Objective-C / Swift.  Migrating to Go is another small step towards adapting a server for use from different environments.  But first things first.  So why go?  There were several reasons for this. <br><br><img src="https://habrastorage.org/files/9f9/3ac/8cf/9f93ac8cf57e4b3cab32eed2ed779899.png"><br><br><h1>  Pros of migrating to Go </h1><br><h4>  Performance </h4><br>  It's no secret that Go is much faster than CPython.  And the centrifuge on Go has become much faster.  I will give examples.  The centrifuge allows you to send multiple commands in a single HTTP request to the API.  I sent a request containing 1000 new messages to be posted to the channel.  Let's look at the results. <br><br><pre><code class="bash hljs">Centrifuge: 2.0    ,      Centrifuge: 17.2 ,    100  Centrifugo: 30 ,    (x15) Centrifugo: 350 ,    100  (x49)</code> </pre> <br>  Still, 1000 messages are a non-standard situation, here are the results of sending one new message to the channel, in which there are 1000 active clients: <br><br><pre> <code class="bash hljs">Centrifuge: 3 ,  0    Centrifuge: 160   1000    Centrifugo: 200 ,  0    (x15) Centrifugo: 2.0   1000    (x80)</code> </pre><br>  The figures were obtained on Macbook Air 2011. It is also worth noting that client connections were artificially created from the same machine, and the completed answer does not mean that the messages have already arrived to customers.  By the way, here is the code that was used to post messages: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cent.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generate_api_sign <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json command = { <span class="hljs-string"><span class="hljs-string">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"publish"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: {<span class="hljs-string"><span class="hljs-string">"channel"</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span>: {<span class="hljs-string"><span class="hljs-string">"json"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>}} } n = <span class="hljs-number"><span class="hljs-number">1000</span></span> url = <span class="hljs-string"><span class="hljs-string">"http://localhost:8000/api/development"</span></span> commands = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): commands.append(command) encoded_data = json.dumps(commands) sign = generate_api_sign(<span class="hljs-string"><span class="hljs-string">"secret"</span></span>, <span class="hljs-string"><span class="hljs-string">"development"</span></span>, encoded_data) r = requests.post(url, data={<span class="hljs-string"><span class="hljs-string">"sign"</span></span>: sign, <span class="hljs-string"><span class="hljs-string">"data"</span></span>: encoded_data})</code> </pre><br>  Of course, this performance increase is not observed in all components of the server, but absolutely everything has become faster.  The Centrifuge repository also has a benchmark script that creates a large number of connections subscribed to one channel.  After the subscription, a message is sent to the channel and the time is calculated until all customers receive the message.  If we take the upper limit of such time for 200 ms, then the number of simultaneous connections that a server can normally serve with this distribution of channels / clients has increased by ~ 4 times (on my laptop from 4000 to 14000).  Again, since all clients are created within the same script from the same machine, there is the possibility of this evaluation being biased. <br><br><h4>  Multicore </h4><br>  Go allows you to run a single process that will use multiple cores at the same time.  In the case of Tornado, we had to start several Centrifuge processes and use Nginx as a balancer in front of them.  It works, but Go makes it much easier to do this: write a program that takes care of how to utilize the available power of the machine.  But there is no magic, the program code must be such that the Go runtime can distribute the work between the processor cores ( <a href="https://golang.org/doc/faq">https://golang.org/doc/faq#Why_GOMAXPROCS</a> ). <br><br><h4>  Spread </h4><br>  An application on Go is easier to distribute, since at the output Go allows you to get one statically linked executable file for a program.  Downloaded, launched - works!  Without any dependencies and dragging the Pythonic virtualenv on the combat machine.  In Mail.Ru Group we, of course, don‚Äôt just copy files to battle, but create rpm for each of our applications.  But creating rpm is also much more transparent, easier and faster.  In addition to the above, Go allows cross-compiling code for different platforms - this is an amazing and convenient feature.  All that is needed in most cases is to specify for which platform and architecture you need a binary file. <br><br><h4>  Built-in language concurrency-model </h4><br>  The default built-in language Go concurrency allows you to write non-blocking code using all available libraries and language tools, there is no need to search for non-blocking libraries, as is the case with Tornado.  One of the headaches, for example, was an asynchronous client for Radish.  About the official redis-py you can immediately forget.  Of the more or less alive and adapted for Tornado there were two: <a href="https://github.com/leporo/tornado-redis">tornado-redis</a> and <a href="https://github.com/mrjoes/toredis">toredis</a> .  Initially, I planned to use tornado-redis, but it turned out that it was completely inappropriate for me because of the <a href="https://github.com/leporo/tornado-redis/issues/79">bug</a> .  As a result, toredis is used in the Python version.  He is very good, but the path to it was thorny. <br><br>  In Go, asynchronous work with network and system calls is the basis of the language.  The runtime scheduler switches the context between the gorutines on blocking calls or after a certain maximum time allowed for the gorutina to work.  In general, all this seems to work for Gevent, and Tornado to some extent, but to have it out of the box is a great happiness. <br><br><h4>  Static typing </h4><br>  Please note that in this paragraph I do not claim that static typing is better than dynamic typing.  But!  Due to static typing, it is much easier to make changes to the code.  For me, it must be admitted, this was one of the most striking discoveries after Python - refactoring is greatly simplified.  There is an additional assurance that if the code is compiled after making the changes, it will work correctly. <br><br>  It seems to me that these points are enough to make sure that the migration is reasonable.  There were other advantages found in the process.  Go-code is easy to test, version 1.5 opens the way to creating a shared library for use from Java or Objective-C, built-in utilities allow you to track leaks of gorutin. <br><br><img src="https://habrastorage.org/files/703/79d/b5f/70379db5ffdc4ba299cd80757e1a43de.png"><br><br><h1>  Migrations to Go </h1><br>  It was necessary, of course, to evaluate the disadvantages of such a migration.  For example, what to do with the Python version: write a fully compatible Go version and replace the code in the repository or make it a separate project?  It was tempting to substitute, after all the links on the Internet to the project and the name meant quite a lot.  Common sense prompted what to do separately.  As a result, now there are Centrifuge and Centrifugo.  And I would not say that it is very good, it causes confusion. <br><br>  The second point: it is much easier to find developers of users of an opensource-solution, if they themselves use the same programming language in which it is written this opensource-application.  Still, whatever one may say, but the Python community is bigger than the Go community.  I had to sacrifice it. <br><br>  Further, the language for me is new, so there was a chance (and even still is) to step on the old rake again or find new ones.  But has it ever stopped programmers?  On the contrary! <br><br>  There are downsides to the Go language itself.  Let's go through the main ones that usually complain about: <br><br><ul><li>  Lack of generics.  Yes, they are not.  As a result, I have 2 data structures in the repository, which theoretically, if Go support for generics, I could reuse in other projects (and maybe even take already prepared from another repository).  This is an <a href="">in-memory fifo queue</a> and <a href="">priority heap queue</a> , able to work only with strings.  Perhaps there would be generics - it would be better.  But at the same time, I would not say that it confuses me very much.  As I understand it, the authors of the Go language <a href="https://golang.org/doc/faq">consider</a> this question open.  Perhaps in the future they will be able to find the right way to add generics to the language. </li><li>  Error processing.  There are no exceptions in Go, and it is customary to explicitly return an error from functions / methods.  In my opinion, this is a very subjective minus.  For example, I like it.  For some personal reasons, I did it in Tornado as well, as a result of doing coruntine instead of causing an exception.  It's convenient for me!  But if in Python it seems unnatural in relation to the practices of the language, then there simply cannot be done without it. </li></ul><br><h1>  Migration </h1><br>  Python centrifuge is based on several main libraries: <a href="https://github.com/tornadoweb/tornado">Tornado</a> , <a href="https://github.com/mrjoes/toredis">Toredis</a> , <a href="https://github.com/mrjoes/sockjs-tornado">Sockjs-Tornado</a> .  Accordingly, it was necessary to find analogues in Go.  Instead of Tornado, the language itself appears directly, <a href="https://github.com/garyburd/redigo">Redigo is</a> used to work with Redis, and a wonderful <a href="https://github.com/igm/sockjs-go">implementation of the SockJS server was found</a> .  In general, the decision to migrate from Python to Go was made, and rewriting the main code base took about 3 months of work in the evenings after work.  It just so happened that the migration process coincided with my desire to get rid of the backend storage of project settings and namespaces.  If you read the previous articles about the project, then you probably know: previously, these settings were stored for selection in a JSON file, SQLite, MongoDB or PostgreSQL with the ability to write and use your backend.  SQLite was the default choice.  This, perhaps, was a mistake.  Settings change so rarely that keeping a database for them is, well, completely pointless.  As a result, I reworked everything to use only the configuration file, getting rid of all sorts of backends. <br><br>  The configuration file can now be created in JSON, YAML or TOML formats - thanks to the wonderful Go <a href="https://github.com/spf13/viper">Viper</a> library.  In general, Viper is good not only for supporting several formats, its main task is to collect configuration options from different places with the correct priority: <br><br><ul><li>  default values; </li><li>  values ‚Äã‚Äãfrom the configuration file; </li><li>  from environment variables; </li><li>  from remote configuration sources (Etcd, Consul); </li><li>  from command line arguments; </li><li>  set explicitly in the process of the application itself. </li></ul><br>  Thus, the library allows very flexible configuration of the application. <br><br>  Among the difficulties of migration that have arisen, I would note the following: <br><br><ol><li>  Frequent use of interface {} and map [string] interface {}, which I applied here and there.  Not immediately, but gradually, we managed to get rid of this, using strictly typed structures instead.  By the way, it helped to bring the internal protocol of communication between the nodes and the protocol of communication with the client in order.  It is clear what type will come or should be sent. </li><li>  Possible race conditions when accessing data from different gorutin.  Most of them were found using the Go race-detector, which prints to the console all the observed cases of unprotected by any means of synchronizing access to data from various Gorutin.  Channels are available from the synchronization tools in Go, as well as primitives from the sync and atomic packages. </li></ol><br><br>  <a href="https://github.com/klauspost">Mr Klaus Post</a> , who found several race conditions, pointed out some style flaws in the code, and also made some extremely useful pull requests. <br><br>  There is another interesting opportunity Go, which has already opened in the course of rewriting.  This is the support for creating a shared library in Go 1.5 version for working with a public library API from Java and Objective-C.  Perhaps this is the road to creating clients for iOS and Android?  During the migration process, the <a href="http://fzambia.gitbooks.io/centrifugal/content/">documentation</a> was completely rewritten.  She now embraces and binds together all projects related to Centrifugo.  This is the server itself, a javascript client, HTTP API clients, a web interface.  By the way, the web interface, previously written on Tornado and located directly in the repository along with the server code, is now separated and is a one-page application on ReactJS ( <a href="https://github.com/centrifugal/web">https://github.com/centrifugal/web</a> ).  Attention gif: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0c/ca1/dc2/a0cca1dc2bc7fb5015ac55bcf9d27cc1.gif" alt="image"><br><br>  The Python version of the Centrifuge is currently almost completely compatible with the Go version.  The differences are insignificant, but in the future the discrepancy will be stronger, I do not plan to add new features in Centrifuge, only fixes for found bugs. <br><br>  For almost 2 months we have been using Centrifugo on the Mail.Ru Group intranet, and there have been no problems so far.  We have a small load: 550 simultaneously connected users on average per day, about 50 active channels on average, and about 30 messages per minute.  To launch and try Centrifugo, you can download a binary release for your system ( <a href="https://github.com/centrifugal/centrifugo/releases">https://github.com/centrifugal/centrifugo/releases</a> ), there is a spec for RPM and Docker image. <br><br>  I am often asked two questions.  First, why should I use a Centrifuge if I have Radishes?  Second, how many users can a single centrifuge instance withstand?  The first question is strange, and the answer to it: of course, you can not use a centrifuge, but then from scratch you have to realize a lot of things that are out of the box are available in the project.  At first glance, this may seem simple, but the devil is in the details.  And these little things decently, starting with the code of the browser client and ending with deployment.  In Centrifuge, many problems of real use are already solved.  It has already been successfully tested in battle.  For example, it allowed us at Mail.Ru Group to conduct an interactive game for employees: about 50 participants came with their mobile devices - laptops, tablets and phones.  Absolutely everyone was able to connect to the game and in real time received questions on the screens, the results of the round and game statistics.  At the same time, the presenter saw who was really online, which helped to organize people at the beginning of the game.  The answer to the second question: I do not know.  I do not know, because you can connect tens of thousands of simultaneous connections, and everything will work fine.  But at the same time, a lot of factors influence the overall performance and throughput: iron, number of connections, number of channels, number of messages in channels.  The answer to this question can only give a sound assessment and monitoring. <br><br>  Further goals are: <br><br><ol><li>  Clients for use on Android and iOS - by and large hope here on opensource-community or on shared library on Go as I don‚Äôt know either Objective-C / Swift or Java. </li><li>  Metrics. </li><li>  Sharding?  Redis Cluster?  Tarantool? </li></ol><br>  And a few links in conclusion: <br><br><ul><li>  demo instance with web interface to Heroku (password demo) <a href="http://centrifugo.herokuapp.com/">centrifugo.herokuapp.com</a> </li><li>  repository with examples <a href="https://github.com/centrifugal/examples">github.com/centrifugal/examples</a> </li><li>  documentation <a href="http://fzambia.gitbooks.io/centrifugal/content/">fzambia.gitbooks.io/centrifugal/content</a> </li></ul><br>  PS Pictures from the gophers in the article from the repository on Github: <a href="https://github.com/hackraft/gophericons">github.com/hackraft/gophericons</a> <br><br>  PSS I would also like to thank habrap <a href="https://habrahabr.ru/users/merc/" class="user_link">merchants</a> and <a href="https://habrahabr.ru/users/sl4mmer/" class="user_link">sl4mmer</a> , which made a significant contribution to the development of the project. </div><p>Source: <a href="https://habr.com/ru/post/266017/">https://habr.com/ru/post/266017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266007/index.html">Industrial control system: how we created a system for the exact calculation of the machine tool life of a large plant</a></li>
<li><a href="../266009/index.html">Apache Spark or the return of the prodigal user</a></li>
<li><a href="../266011/index.html">Takari: Maven on steroids</a></li>
<li><a href="../266013/index.html">Digest of grocery design, August 2015</a></li>
<li><a href="../266015/index.html">IBM Watson cognitive system: principles of working with natural language</a></li>
<li><a href="../266019/index.html">The first book of the young programmer. Learning to write programs on Scratch</a></li>
<li><a href="../266021/index.html">Publish DITA to PDF using the DITA Open Toolkit</a></li>
<li><a href="../266023/index.html">Error compensation for floating-point operations</a></li>
<li><a href="../266025/index.html">Working with text data in scikit-learn (translation of documentation) - part 2</a></li>
<li><a href="../266027/index.html">#NoHacked: eliminating the effects of hacking with loading URLs containing meaningless text</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>