<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do not be afraid of bicycles. Or another Grand Central Dispatch (GCD) in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IMHO (I Have Opinion Horseradish Dispute) 
 From my point of view, the most useful thing a programmer can do to improve his professional level is writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do not be afraid of bicycles. Or another Grand Central Dispatch (GCD) in C ++ 11</h1><div class="post__text post__text-html js-mediator-article"><h4>  IMHO (I Have Opinion Horseradish Dispute) </h4><br>  From my point of view, the most useful thing a programmer can do to improve his professional level is writing bicycles.  Cycling is a very exciting process.  Sometimes he carries away more than the task for which the bicycle itself was started.  When writing a bicycle (by bicycle, I understand the implementation of an existing one) a deeper understanding of existing solutions and techniques occurs. <br><img src="https://habrastorage.org/storage2/15a/1bf/b69/15a1bfb6986f94d613aeaab475a50e86.jpg"><br><a name="habracut"></a><br><h4>  Motivation </h4><br>  For more than three years, my main working language has been objective-c, and when I first started writing on it I was pleasantly surprised by a thoughtful high-level API for working with multithreading <a href="http://developer.apple.com/library/mac/">NSOperationQueue</a> , and later - <a href="http://ru.wikipedia.org/wiki/Grand_Central_Dispatch">GCD</a> , which in my opinion is the quintessence of conciseness and clarity for Thread concurrency.  And here recent articles on Habr√©: <a href="http://habrahabr.ru/post/185706/">Technique of writing of await / async analog from C # for C ++</a> and <a href="http://habrahabr.ru/post/184562/">Thread concurrency C ++ 11</a> .  They are forced to look at those new buns that C ++ provides for working with multithreading.  And most of them (the same std :: future) look like this to me: <br><img src="https://habrastorage.org/storage2/6f3/1a3/100/6f31a31005c7e24ac4396e0660e00cc3.jpg"><br><br><h4>  Speculation and Wishlist </h4><br>  Here is a typical scenario in which I use multithreading in my applications: <br><ul><li>  asynchronously get some data (files / network); </li><li>  parse / prepare the data; </li><li>  return data to the called stream (for example, to the main stream and update the UI). </li></ul><br>  It is convenient that each of these operations had its own line. <br>  And even more convenient when all this is collected in one place, and not scattered across the five source files.  Something like: <br><pre><code class="cpp hljs">file_io_queue.async([=]{ file_data = get_data_from_file( file_name ); parser_queue.async([=]{ parsed_data = parse( file_data ); main_queue.async([=]{ update_ui_with_new_data( parsed_data ) ; }); }); });</code> </pre>  This code is read as an absolutely linear, synchronous code.  It describes the logic of how data changes will occur.  For me, by and large, no matter in which stream the file will be read, in which - its parsing.  The main thing is the sequence of these operations.  I can call the previous code 100500 times for 100500 files. <br><br>  The obvious solution is to implement a pool of threads template.  But almost all implementations that I have seen on the Internet, suggest using one std :: thread for one queue.  From my point of view, this is not good.  For example, you need to store the instance of the queue itself as long as the asynchronous operations are performed.  Creating a std :: thread ist is an order of magnitude more expensive operation than capturing / releasing a mutex.  When should we destroy the queue?  Yes, and idle a large number of threads at a time when the queue is not in use - not ice. <br>  We will do differently.  We will have the Nth number of threads (std :: thread) and a list of lightweight queues with priorities.  When we add a task to the queue, we notify the thread that a new task has appeared.  The thread takes the highest priority task and performs it.  If a task with such a priority is already being performed, then it takes a lower priority task.  If there are none, wait. <br><img src="https://habrastorage.org/storage2/ac7/95c/b93/ac795cb93a894b15a2642302d277dbef.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Code </h4><br>  Let's start: <div class="spoiler">  <b class="spoiler_title">Turn</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> dispatch{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ()&gt; function; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">queue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> priority; <span class="hljs-comment"><span class="hljs-comment">//  .      const queue::priority queue_priority; static std::shared_ptr&lt;queue&gt; main_queue() ; //    virtual void async(function) const; //        queue(queue::priority priority) : queue_priority(priority) {}; }; }</span></span></code> </pre> </div></div><br>  Implementation of the async method <div class="spoiler">  <b class="spoiler_title">just redirects the call to the thread pool:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::async(dispatch::function task) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { thread_pool::shared_pool()-&gt;push_task_with_priority(task, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;queue_priority); };</code> </pre> </div></div><br>  All work will be done in our <div class="spoiler">  <b class="spoiler_title">Thread pool:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">queue_impl</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::priority priority; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;function&gt; tasks; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_running; queue_impl(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::priority priority): priority(priority){}; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_pool</span></span></span><span class="hljs-class">{</span></span> thread_pool(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;thread_pool&gt;&amp; shared_pool(); <span class="hljs-comment"><span class="hljs-comment">// thread_pool virtual ~thread_pool(); bool stop; typedef std::shared_ptr&lt;queue_impl&gt; queue_ptr; void push_task_with_priority(const function&amp;, queue::priority);//       bool get_free_queue(queue_ptr*) const; //  ,        void start_task_in_queue(const queue_ptr&amp;); //     void stop_task_in_queue(const queue_ptr&amp;); //   std::mutex mutex; //     std::map&lt;queue::priority, queue_ptr&gt; queues; //      std::mutex main_thread_mutex; std::queue&lt;dispatch::function&gt; main_queue; std::condition_variable condition; std::vector&lt;std::thread&gt; threads; //   ,      dispatch::function main_loop_need_update; void add_worker(); //     };</span></span></code> </pre> </div></div><br>  Consider the methods in order.  We need to find a free queue with maximum priority: <div class="spoiler">  <b class="spoiler_title">find free queue with maximum priority:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> thread_pool::get_free_queue(queue_ptr* out_queue) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//           auto finded = std::find_if(queues.rbegin(), queues.rend(), [](const std::pair&lt;queue::priority, queue_ptr&gt;&amp; iter){ return ! iter.second-&gt;is_running; //      }); bool is_free_queue_exist = (finded != queues.rend()); if (is_free_queue_exist) *out_queue = finded-&gt;second; return is_free_queue_exist; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Add a task to the queue</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_pool::push_task_with_priority(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function&amp; task, <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::priority priority){ { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); <span class="hljs-comment"><span class="hljs-comment">//   //    .    -   auto queue = queues[priority]; if (!queue){ queue = std::make_shared&lt;dispatch::queue_impl&gt;(priority); queues[priority] = queue; } queue-&gt;tasks.push(task); //  ,    unsigned max_number_of_threads = std::max&lt;unsigned&gt;(std::thread::hardware_concurrency(), 2); unsigned number_of_threads_required = round(log(queues.size()) + 1); while (threads.size() &lt; std::min&lt;unsigned&gt;(max_number_of_threads, number_of_threads_required)){ add_worker(); } } condition.notify_one(); //  ,       }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Mark the task as completed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_pool::stop_task_in_queue(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> queue_ptr&amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>){ { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); <span class="hljs-comment"><span class="hljs-comment">//    .    -      queue-&gt;is_running = false; if ( queue-&gt;tasks.size() ==0 ){ queues.erase(queues.find(queue-&gt;queue_priority)); } } condition.notify_one(); //  ,      }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">And, actually, the flow itself:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_pool::add_worker(){ threads.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread([=]{ dispatch::function task; thread_pool::queue_ptr <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mutex); <span class="hljs-comment"><span class="hljs-comment">//    while(!stop &amp;&amp; !get_free_queue(&amp;queue)) //     condition.wait(lock); //    if(stop) //     ,   return; task = queue-&gt;tasks.front(); //     queue-&gt;tasks.pop(); start_task_in_queue(queue); //     } task(); //   stop_task_in_queue(queue); //     } })); }</span></span></code> </pre> </div></div><br><br><h4>  Main Thread and Run Loop </h4><br><img src="https://habrastorage.org/storage2/18b/9d2/32a/18b9d232af48e845ccdc68606c692b6f.jpg"><br><br>  In C ++, there is no such thing as a main thread.  But almost all UI applications are built on this concept.  We can only change the UI from the main thread.  So, we need to either organize the Run Loop ourselves, or wedge in the existing one. <br><br>  To begin, create a separate queue for the ‚Äúmain thread‚Äù: <div class="spoiler">  <b class="spoiler_title">Main queue</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main_queue</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatch::function task)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; main_queue(): <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::main_queue(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::static_pointer_cast&lt;dispatch::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;dispatch::main_queue&gt;()); }</code> </pre> </div></div><br>  And in the async method we will add tasks to <div class="spoiler">  <b class="spoiler_title">separate queue</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main_queue::async(dispatch::function task) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pool = thread_pool::shared_pool(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(pool-&gt;main_thread_mutex); pool-&gt;main_queue.push(task); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pool-&gt;main_loop_need_update != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) pool-&gt;main_loop_need_update(); }</code> </pre> </div></div><br>  Well, we need a function that will be called from the main thread: <div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pool = thread_pool::shared_pool(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(pool-&gt;main_thread_mutex); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!pool-&gt;main_queue.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> task = pool-&gt;main_queue.front(); pool-&gt;main_queue.pop(); task(); } }</code> </pre> </div></div><br><img src="https://habrastorage.org/storage2/e8d/eef/ad3/e8deefad3a0c113968d1e4812aead585.jpg"><br><br><h4>  Now only two questions: ‚ÄúHow?‚Äù And ‚ÄúWhy?‚Äù </h4><br>  First ‚ÄúWhy?‚Äù: C ++ is often used to write cross-platform software.  For the sake of portability, many convenient things must be discarded.  GCD is a very convenient library, providing a simple, intuitive and convenient way to manage asynchronous queues. <br>  There is no definite answer to the question "How?"  Ruckup can be wedged in different ways.  Many systems provide APIs for this.  For example, in iOS there is ‚ÄúperformSelectorOnMainThread:‚Äù.  We just need to set the callback via dispatch :: set_main_loop_process_callback: <br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dispatchMainThread{ dispatch::process_main_loop(); } - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)launchOptions{ dispatch::set_main_loop_process_callback([=]{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> performSelectorOnMainThread:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(dispatchMainThread) withObject:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> waitUntilDone:<span class="hljs-literal"><span class="hljs-literal">NO</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; }</code> </pre> <br>  If we ourselves organize our own business, then we can do something like this: <pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatch::function main_loop_function)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatch::function main_loop_function)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> main_queue = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::main_queue(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!thread_pool::shared_pool()-&gt;stop) { main_queue-&gt;async(main_loop_function); process_main_loop(); } }</code> </pre> <br><img src="https://habrastorage.org/storage2/14a/97f/130/14a97f13021826707f3d38d78d1571d1.jpg"><br><br><h4>  And now actually for the sake of what it was started: </h4><br>  Create 6 queues and shove 6 tasks each: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> main_thread_id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> task = <span class="hljs-number"><span class="hljs-number">0</span></span>; task &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; ++task) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> priority = <span class="hljs-number"><span class="hljs-number">0</span></span>; priority &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; ++priority){ dispatch::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>(priority).async([=]{ assert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id() != main_thread_id); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> task_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(task); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> palceholder(<span class="hljs-number"><span class="hljs-number">1</span></span>+priority*<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); dispatch::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::main_queue()-&gt;async([=]{ assert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id() == main_thread_id); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; palceholder &lt;&lt; task_string &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }); }); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">We get about this picture</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  A ‚Äúpillar‚Äù is a queue.  The more to the right, the higher priority at the queue.  The line is callbacks to the ‚Äúmain stream‚Äù. </div></div><br>  Well, the code for iOS: <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; ++i){ dispatch::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>(dispatch::QUEUE_PRIORITY::DEFAULT).async([=]{ NSAssert(![NSThread isMainThread], nil); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> first_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(i); dispatch::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>::main_queue()-&gt;async([=]{ NSAssert([NSThread isMainThread], nil); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> second_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(i+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; first_string &lt;&lt; <span class="hljs-string"><span class="hljs-string">" -&gt; "</span></span> &lt;&lt; second_string &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [self.tableView reloadData]; <span class="hljs-comment"><span class="hljs-comment">//  -  UI. ,        }); }); }</span></span></code> </pre> <br><br><h4>  Conclusion </h4><br>  Conclusion will not be.  This bike was written solely for the purpose of feeling multi-threading in C ++ 11.  The code is a little more than 200 lines of not very good C ++ code <a href="https://github.com/nut-code-monkey/dispatch">presented on the github</a> .  It was checked on clang ++ 3.3, g ++ - 4.7 / g ++ - 4.8 and by the compiler 2012 Visual Studio.  That is, the main compilers already sufficiently support C ++ 11. <br><br>  Py.Sy.  Calling to write my bikes, I do not call them to use on combat projects.  Although, on the other hand, how else can a bike turn into something serious? <br><br><div class="spoiler">  <b class="spoiler_title">Well, a couple of bicycles that I did not think of where to cram in the article</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/7b8/b92/d2e/7b8b92d2ea0fbfcc3f59a13d0d88961a.jpg"><br><img src="http://habrastorage.org/storage2/e0d/a9e/1fa/e0da9e1fa8900088bbf4eaa30bad52e8.jpg"><br><img src="http://habrastorage.org/storage2/07e/ad7/536/07ead7536c6d4f44b3cb352e06dc8be5.jpg"></div></div></div><p>Source: <a href="https://habr.com/ru/post/186200/">https://habr.com/ru/post/186200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186190/index.html">Hyundai T10 - tablet 10.1 "on Exynos 4412 with 3G and GPS</a></li>
<li><a href="../186192/index.html">Corning develops anti-bacterial and anti-glare screen</a></li>
<li><a href="../186194/index.html">EllisLab is looking for a new owner for CodeIgniter</a></li>
<li><a href="../186196/index.html">Dynamic Impurities in PHP</a></li>
<li><a href="../186198/index.html">9 signs that you should not hire this Web developer</a></li>
<li><a href="../186202/index.html">Data compression during transfer from browser to server</a></li>
<li><a href="../186204/index.html">Co-founder of The Pirate Bay calls to close the tracker</a></li>
<li><a href="../186206/index.html">Encode content in Dolby Digital Plus with a certified codec in the cloud on request</a></li>
<li><a href="../186208/index.html">We study Storm Framework. Part I</a></li>
<li><a href="../186210/index.html">Ctrl + Z for Ctrl + D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>