<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RenderDoc - a graphical debugger for DirectX11 from Crytek</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you may know in the Windows world, DirectX is often used for drawing graphics. In recent versions (10, 11.x), the library has seriously stepped for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RenderDoc - a graphical debugger for DirectX11 from Crytek</h1><div class="post__text post__text-html js-mediator-article">  As you may know in the Windows world, DirectX is often used for drawing graphics.  In recent versions (10, 11.x), the library has seriously stepped forward and it is on them that the engines of many modern games are built.  In addition, DirectX is used not only in games - the Windows OS interface itself also doesn‚Äôt remember which version (Vista?) Is drawn through it, and it would seem that the programs that are not strongly connected with graphics, wanting to increase the performance and smoothness of the zoom / scrolling, are latest version of directx.  So some time ago, the Google Chrome render went to DirectX11 (seemingly from version 36). <br><br>  Sometime during the days of Windows 95 and Pentium II there was such a joke that the slower a computer is - the better you can understand the operation of the operating system - you can see with the naked eye the order in which the window elements are drawn, events are processed.  Today, for such purposes, there are separate tools for DirectX - graphical debuggers that allow you to understand exactly how each pixel of each frame is drawn, what operations the DirectX engine performs, what resources it uses, how quickly and correctly everything works.  One of these tools - <a href="http://cryengine.com/renderdoc">RenderDoc</a> from the company Crytek today we will consider.  And as an example, let's analyze the already mentioned above new render of Google Chrome. <br><br><img src="https://habrastorage.org/files/e84/e0e/872/e84e0e872fd84356a4c34fd09bc4683d.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  First of all - why am I talking about RenderDoc?  There are many similar tools: <br><ul><li>  <a href="http://en.wikipedia.org/wiki/PIX_(Microsoft)">Pix</a> </li><li>  <a href="https://software.intel.com/en-us/vcsource/tools/intel-gpa">Intel Graphics Performance Analyzers</a> </li><li>  <a href="http://developer.amd.com/tools-and-sdks/graphics-development/gpu-perfstudio-2/">AMD GPU PerfStudio 2</a> </li><li>  <a href="https://developer.nvidia.com/nsight-visual-studio-edition-features">NVIDIA Nsight Development Platform</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/hh873207(v%3Dvs.110).aspx">Visual Studio Graphics Diagnostics tools</a> </li></ul><br><br>  All of them are very good.  But: <br><ul><li>  PIX - is already outdated, does not develop and does not work on the latest OS </li><li>  Intel \ AMD \ Nvidia tools - made in the spirit of "with these utilities you can see how DirectX works with awesome cool and fast work on our video cards", while some applied, routine debugging tasks are not very convenient to do in them </li><li>  Visual Studio - sharpened specifically for the development of its software, and not the analysis of someone else's </li></ul><br><br>  As for RenderDoc, this is: <br><ul><li>  <a href="https://github.com/baldurk/renderdoc">opensource</a> , actively developing </li><li>  sharpened on the latest versions of Windows and DirectX11 </li><li>  product from 3D development professionals - the company that created the CryEngine engine with all the associated strapping </li><li>  imbued with a practical approach to development and debugging - I don‚Äôt know how to explain it better, but for example, when you just think about the fact that ‚Äúhm, it would be nice to see this information in this form here‚Äù, that RenderDoc shows exactly this information, precisely in this call and in the right form.  It can be seen that the tool lives and polishes in the hands of Crytek. </li><li>  In general, the only product that I understand from me is that I want to debug drawing graphics in a Chrome child process running from the parent, in which there is no graphics at all.  It would seem that the launcher is the simplest thing, used in many games, but RenderDoc only came to the need to support it in the debugger. </li></ul><br><br>  So, <a href="">download RenderDoc</a> , install.  Run, see the main window.  Open the Tools-&gt; Options menu and specify the folder into which the temporary files (dumps) will be added. <br><br><img src="https://habrastorage.org/files/a92/9c9/c5a/a929c9c5a14d4926920c9b01c66044c7.png"><br><br>  Now we need to launch the application we want to debug under the RenderDoc debugger.  To do this, on the tab " <b>Capture Executable</b> " enter the path to Chrome, its working folder.  Here are some interesting points.  Graphics in Chrome is drawn in a separate child process, it can be determined by running Process Hacker and finding the one among all the running processes chrome.exe that has the <b>--type = gpu-process</b> flag among the command line parameters. <br><br><img src="https://habrastorage.org/files/d10/854/036/d108540360df477fb7dcefc2d05f713a.png"><br><br>  We cannot start this process directly, so we have to start the main Chrome process, indicating in RenderDoc that we want to track calls to DirectX functions, including among the child processes ( <b>Hook Into Children</b> checkbox) <br><br>  By default, Chrome child processes ‚Äúlive‚Äù in the sandbox ‚Äî they have a low Integrity Level, which prevents them from interacting with the file system, other processes, and common OS resources.  Thus, if we just run Chrome, then RenderDoc will not be able to interact with the process in which the graphics are drawn.  To do this, there is a hack - Chrome needs to be run with a special flag <b>--no-sandbox</b> , which disables the Chrome sandbox. <br><br>  Since we are interested in everything that happens in the course of drawing graphics, we include more useful checkboxes.  We can also immediately indicate which frame we want to capture (for this there is a <b>Queue Capture Of Frame #</b> checkbox), or we can press the PrintScreen button in the application to create a dump for the current frame <br><br>  As a result, the Capture Executable tab will look like this: <br><img src="https://habrastorage.org/files/fd8/462/755/fd84627558ea48d1a130eb33638324d3.png"><br><br>  We press the Capture button, Chrome starts. <br><img src="https://habrastorage.org/files/436/ac4/786/436ac4786fbb42c3aa1736ab7883547b.png"><br><br>  At the top of the window, we see some kind of debugging information that tells us at least a few things: <br><ul><li>  Chrome actually uses DirectX11 to draw its own window (and the whole window: title, toolbars, and page content) </li><li>  RenderDoc successfully "hooked" to Chrome </li></ul><br><br>  Now you can open something in Chrome and click PrintScreen.  At the top of the Chrome window will appear on the created screenshot.  Everything, Chrome can be closed, and in the folder that you specified in the settings there should be a file with the rdc extension.  This is our dump.  Open it through " <b>File-&gt; Open Log</b> " and see something like this: <br><img src="https://habrastorage.org/files/aab/e69/d69/aabe69d69a9f4cab9468544666465f2e.png"><br><br>  In the upper part of the window there is a ‚Äútimeline‚Äù - a time line on which the stages of drawing this frame are marked.  There may be up to several dozen (if you don‚Äôt see them, click on the plus sign in the upper left corner of the Timeline window).  The same steps are marked in the " <b>Event Browser</b> " on the left side of the window.  By clicking on the timeline or on the events in the "Event Browser" we can go to different points in the course of drawing the frame. <br><br>  The root node of the event tree is called " <b>Frame #N</b> " and shows which frame it is from when DirectX was initialized in the application.  Next comes the meta-node " <b>Frame start</b> " indicating the start of drawing this frame (no real calls to DirectX methods are attached to it).  Next we see three nodes: " <b>Color Pass # 1 (1 Targets)</b> ", " <b>Draw (4)</b> " and " <b>Present ()</b> ".  From this we can understand that all the drawing of the chrome window content goes through several stages: <br><ul><li>  First, everything is drawn into some kind of intermediate texture (stage " <b>Color Pass # 1 (1 Targets)</b> ") </li><li>  Then the call to the " <b>Draw (4)</b> " method transfers the contents of this texture to the Swap Chain Backbuffer </li><li>  Finally, the <b>Present</b> method causes the backbuffer to be displayed on the screen. </li></ul><br><br>  As you can see, the drawing stage in the intermediate texture in the tree can be expanded and we will see the moments of drawing individual elements of the Chrome window. <br><img src="https://habrastorage.org/files/de5/137/99d/de513799d12a4f679cd0dee55276124f.png"><br><br>  First, the texture is cleared (call <b>ClearRenderTargetView</b> ).  Then there are many stages called " <b>DrawIndexed (6)</b> ".  6 is the number of points bounding the area drawn at this stage.  The fact that there are 6 of them suggests the idea that these are 2 triangles that make up a rectangle.  Let's select one of the stages " <b>DrawIndexed (6)</b> " (not the first, but not the last) and consider it more closely. <br><br>  Let's start with the tab " <b>Pipeline State</b> " <br><img src="https://habrastorage.org/files/cf1/c48/c5d/cf1c48c5d6f24e2fa7b447a4defaada1.png"><br><br>  As you may know, the concept of " <b>Pipeline</b> " is used in DirectX11 - it is a set of several sequential operations designed to form the final frame.  The pipeline starts with the <b>Input Assembler</b> stage - here we provide all the necessary input data for vertex, index and constant buffers, which may later be needed to calculate what and where to draw.  Next are the stages of processing input data by different types of shaders and the last phase, <b>Output Merger</b> , in which the graphics are assembled and output to where they should be output. <br><br>  In the <b>Pipeline State</b> window, we can click on any stage of the pipeline and see: <br><ul><li>  What came to the input stage (buffer, shader, texture), general information about this object </li><li>  Clicking on the green arrow to the right of the input parameter, we can open a window with more complete information.  For a buffer, this is its full content, for a texture, its picture, for a shader, its compiled bytecode. </li><li>  For the <b>Input Assembler</b> stage, we can also click on the large " <b>Mesh</b> " button and see the coordinates of the points forming the region drawn at this stage.  Here again, you can make sure that we draw exactly a rectangle. </li></ul><br><br>  Turning to the texture window, we can see the textures used when drawing this frame: <br><img src="https://habrastorage.org/files/13c/2b7/aa1/13c2b7aa1b2d4344808e101573d86ec8.png"><br><br>  In the " <b>PS Resources</b> " toolbar, we see the texture (s) that will be drawn at this stage, and in the " <b>OM Targets</b> " toolbar, the texture where the drawing will take place.  Staying in the texture window, you can click on the drawing stages from the top or from the left - and we will see that Chrome draws its window with textures of 256x256 pixels.  It starts from the bottom of the window, then draws the side edges and then the window title with toolbars.  After that, Chrome proceeds to draw the content of the tab (again, slices of 256x256 pixels).  Then objects lying ‚Äúon top of‚Äù the content are drawn - video, flash banners, tooltips.  In the last stages, the scrollbar and its slider are drawn.  Now the texture is ready for drawing into the back buffer. <br><br><h4>  What else interesting can RenderDoc </h4><br>  <b>Show API called DirectX-methods for each stage of drawing</b> <br><img src="https://habrastorage.org/files/183/157/6ed/1831576ed2814b36b8fad6d05468e393.png"><br>  Incredibly useful thing.  And given that not only the names of the methods are visible, but also their parameters - this is generally beauty. <br><br>  <b>Show the stick (from which one or another DirectX method was called in the code)</b> <br>  However, for this you need to slip the program pdb-file (which you only have if you yourself are the author of the code being debugged).  Very useful for debugging their programs, completely useless for analyzing others. <br><br>  <b>Debuff shaders</b> <br>  For vertex shaders, debugging begins in the <b>Mesh Output</b> window with a right-click on the vertex of interest. <br><img src="https://habrastorage.org/files/5a7/84a/e64/5a784ae64f74455c94c7ac2dd50b1871.png"><br><br>  For pixels - in the texture window, where on the pixel of interest you need to click the right mouse button and click in the " <b>Pixel Content</b> " toolbar the " <b>Debug this Pixel</b> " button <br><img src="https://habrastorage.org/files/bbe/3c7/d23/bbe3c7d2362b4c2b9a3d87ea944f108d.png"><br><br>  Here is such a useful tool RenderDoc. <br>  Good luck debugging graphics. </div><p>Source: <a href="https://habr.com/ru/post/234619/">https://habr.com/ru/post/234619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234607/index.html">How to enter the US magistracy?</a></li>
<li><a href="../234609/index.html">Mini airship control system</a></li>
<li><a href="../234611/index.html">Setting up a time tracking system: try it out for yourself</a></li>
<li><a href="../234613/index.html">Flask Mega-Tutorial, Part 10: Full-Text Search</a></li>
<li><a href="../234615/index.html">The search engine in the NSA contains more than 850 billion records</a></li>
<li><a href="../234621/index.html">How we made the educational platform: the first application</a></li>
<li><a href="../234623/index.html">Message Passing Concept. Agents and actors</a></li>
<li><a href="../234627/index.html">ZSlice landscape editor</a></li>
<li><a href="../234629/index.html">Logeek Night Luxoft</a></li>
<li><a href="../234633/index.html">Implementation of TestLink - basic steps from the idea of ‚Äã‚Äãimplementation to your logo in the reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>