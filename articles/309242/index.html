<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write an elegant parser on Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 17 (no, no, Python will be soon, you entered correctly!) A new syntax for the if appears, allowing you to declare variables right in the block...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write an elegant parser on Python</h1><div class="post__text post__text-html js-mediator-article"> In C ++ 17 (no, no, Python will be soon, you entered correctly!) A new syntax for the <code>if</code> appears, allowing you to declare variables right in the block header.  This is quite convenient because the constructions of the form <br><br><pre> <code class="cpp hljs">Foo foo = make_foo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foo.is_nice()) { <span class="hljs-comment"><span class="hljs-comment">// do work with foo } // never use foo again // foo gets deleted</span></span></code> </pre><br>  pretty common.  The code above with a slight movement of the programmer‚Äôs hand (and the heavy movement of the standardization committee‚Äôs hand) turns into: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Foo foo = make_foo(); foo.is_nice()) { <span class="hljs-comment"><span class="hljs-comment">// do work with foo } // foo gets deleted // never use foo again (well, you can't anyway)</span></span></code> </pre> <br>  It has become a little better, although it still does not look perfect.  There is no such thing in Python, but if you hate <code>if</code> in Python code as much as I do and want to learn how to quickly write simple parsers, then welcome to cat.  In this article we will try to write a short and elegant parser for JSON in Python 2 (without any additional modules, of course). <br><a name="habracut"></a><br><h1>  What is parsing and what it eats </h1><br>  <em>Parsing</em> (in Russian, ‚Äúsyntactic analysis‚Äù) is the immortal task of disassembling and transforming into meaningful units something written in a fixed language, be it a programming language, a markup language, a structured query language, or the main language of life, the Universe, and all that.  A typical sequence of problem solving steps looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <strong>Describe the language</strong> .  Of course, you first need to decide which task we are solving.  Usually, a language description is another variation <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0_%25D0%2591%25D1%258D%25D0%25BA%25D1%2583%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259D%25D0%25B0%25D1%2583%25D1%2580%25D0%25B0">of the Backus-Naur form</a> .  ( <a href="https://github.com/python/cpython/blob/master/Grammar/Grammar">Here</a> , for example, the description of the Python grammar, which is used when building its parser.) At the same time, both the rules of "constructing sentences" in the language and the rules for defining valid words are established. <br><br></li><li>  <strong>Split the input into tokens</strong> .  A <em>lexical analyzer is</em> written (popularly a tokenizer) that breaks the input string or file into a sequence of <em>tokens</em> , that is, valid words of our language (or whines, that this cannot be done). <br><br></li><li>  <strong>Check syntax and build syntax tree</strong> .  We check if the sequence of tokens matches the description of our language.  Here, algorithms like <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0">the recursive descent method</a> are used.  Each valid sentence of a language includes a finite number of valid words or other valid sentences;  if the tokens were able to form a coherent picture, then at the output we automatically get a tree, which is called an <em>abstract syntax tree</em> . <br><br></li><li>  <strong>Make it finally work</strong> .  You have a syntax tree and you can finally do what you wanted: calculate the value of the arithmetic expression, organize the query in the database, compile the program, display the web page, and so on. </li></ol><br>  In general, this area has been studied along and across and is full of remarkable results, and hundreds (possibly good) books have been written on it.  However, the theoretical solvability of the problem and writing code is not the same thing. <br><br><h2>  Model problem </h2><br>  We will illustrate parser writing in a simple, but not completely trivial example - parsing JSON.  The grammar looks like this: <br><br><pre> <code class="cpp hljs">root ::= value value ::= <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> | number | object | <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> | <span class="hljs-string"><span class="hljs-string">'true'</span></span> | <span class="hljs-string"><span class="hljs-string">'false'</span></span> | <span class="hljs-string"><span class="hljs-string">'null'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> ::= <span class="hljs-string"><span class="hljs-string">'['</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span> | <span class="hljs-string"><span class="hljs-string">'['</span></span> comma-separated-values <span class="hljs-string"><span class="hljs-string">']'</span></span> comma-separated-values ::= value | value <span class="hljs-string"><span class="hljs-string">','</span></span> comma-separated-values object ::= <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span> | <span class="hljs-string"><span class="hljs-string">'{'</span></span> comma-separated-keyvalues <span class="hljs-string"><span class="hljs-string">'}'</span></span> comma-separated-keyvalues ::= keyvalue | keyvalue <span class="hljs-string"><span class="hljs-string">','</span></span> comma-separated-keyvalues keyvalue ::= <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-string"><span class="hljs-string">':'</span></span> value</code> </pre> <br>  There are no rules for <code>string</code> and <code>number</code> - they, along with all the strings in quotes, will be our tokens. <br><br><h1>  Parsim json </h1><br>  We will not write a full tokenizer (this is boring and not quite the topic of the article) - we will work with the whole line and beat it with tokens as necessary.  We write the first two functions: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-comment"><span class="hljs-comment">#  re.DOTALL        number_regex = re.compile(r"(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)\s*(.*)", re.DOTALL) def parse_number(src): match = number_regex.match(src) if match is not None: number, src = match.groups() return eval(number), src #  eval -   ,    string_regex = re.compile(r"('(?:[^\\']|\\['\\/bfnrt]|\\u[0-9a-fA-F]{4})*?')\s*(.*)", re.DOTALL) def parse_string(src): match = string_regex.match(src) if match is not None: string, src = match.groups() return eval(string), src #     JSON' #    ,   </span></span></code> </pre><br>  (I promised without if'ov, but this is the last, honestly!) <br><br>  For everything else, we will write one function that generates simple parser functions: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, value=None)</span></span></span><span class="hljs-function">:</span></span> l = len(word) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#      .lower()  case-insensitive ! if src.startswith(word): #  if!   ! return value, src[l:].lstrip() # lstrip    , .  result.__name__ = "parse_%s" % word #   return result parse_true = parse_word("true", True) parse_false = parse_word("false", False) parse_null = parse_word("null", None)</span></span></code> </pre><br>  Total, on what basis we build our functions: <br><br><ol><li>  They take the string to parse. </li><li>  They return a pair (the result, the remaining_string) for success (that is, when the required construction was found at the beginning of the line) and <code>None</code> for failure. </li><li>  They send into oblivion all the whitespace between the tokens.  (Do not do this if you are writing the Python parser!) </li></ol><br>  Actually, on these three functions, problems with tokens are solved, and we can move on to the interesting part. <br><br><h3>  Parsim rule with branching </h3><br>  What should the <code>parse_value</code> function look like for the grammar above?  Usually something like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     match = parse_string(src) if match is not None: # ! return match #  ;      match = parse_number(src) if match is not None: return match #    .    ... # ...</span></span></code> </pre><br>  Well, no, these <code>if</code> got me! <br><br>  Let's change the three functions above in a most unexpected way: replace <code>return</code> with <code>yield</code> !  Now they return the <a href="https://wiki.python.org/moin/Generators">generators</a> ‚Äî empty if the parsing failed, and with exactly one element if successful.  Yes, we are expanding our principle number 2 by 90 degrees: we will now write all our functions in this style: <br><br><pre> <code class="python hljs">number_regex = re.compile(<span class="hljs-string"><span class="hljs-string">r"(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)\s*(.*)"</span></span>, re.DOTALL) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> match = number_regex.match(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: number, src = match.groups() <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> eval(number), src <span class="hljs-comment"><span class="hljs-comment">#       yield,    . #   ,    . string_regex = re.compile(r"('(?:[^\\']|\\['\\/bfnrt]|\\u[0-9a-fA-F]{4})*?')\s*(.*)", re.DOTALL) def parse_string(src): match = string_regex.match(src) if match is not None: string, src = match.groups() yield eval(string), src def parse_word(word, value=None): l = len(word) def result(src): if src.startswith(word): yield value, src[l:].rstrip() result.__name__ = "parse_%s" % word return result #   -,  yield' parse_true = parse_word("true", True) parse_false = parse_word("false", False) parse_null = parse_word("null", None)</span></span></code> </pre><br>  What will our <code>parse_value</code> turn <code>parse_value</code> ?  At first glance, in something like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_string(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_number(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br>  But at a second glance, we will see that each option can take only one line! <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   itertools.chain     #  ,       from itertools import chain def parse_value(src): for match in chain( parse_string(src), parse_number(src), parse_array(src), parse_object(src), parse_true(src), parse_false(src), parse_null(src), ): #   ,     yield match return</span></span></code> </pre><br>  At the same time, the efficiency remains at the same level - each function will start to be executed (and therefore, to do work, checking regular expressions) only when the previous one fails.  <code>return</code> ensures that the extra work will not be performed if somewhere in the middle of the list the parsing is successful. <br><br><h3>  Parsim construction sequences </h3><br>  Let's move on to the next number of our program - the <code>parse_array</code> function.  It should look something like this: <br><br><pre> <code class="python hljs">parse_left_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"["</span></span>) parse_right_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"]"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     tsrc,     #        "" for _, tsrc in parse_left_square_bracket(src): for _, tsrc in parse_right_square_bracket(tsrc): #   ,      '['  ']' yield [], tsrc return #   src    --        for _, src in parse_left_square_bracket(src): for items, src in parse_comma_separated_values(src): for _, src in parse_right_square_bracket(src): yield items, src #      yield,     </span></span></code> </pre><br>  Not a single <code>if</code> , as promised, but something is still wrong ... Let's write a small helper function that will help us connect the parser functions in sequence, just like the <code>chain</code> helped connect them in the "or" mode.  This function will have to carefully take all the results and return all the first elements of the results (analysis results) and the last second element (the remaining unanalyzed part of the line).  My version looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*funcs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(funcs) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  ,      if' def result(src): yield (), src return result def result(src): for arg1, src in funcs[0](src): for others, src in sequence(*funcs[1:])(src): yield (arg1,) + others, src #    return result</span></span></code> </pre><br>  With this powerful (albeit scary) tool, our function will be rewritten as: <br><br><pre> <code class="python hljs">parse_left_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"["</span></span>) parse_right_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"]"</span></span>) parse_empty_array = sequence(parse_left_square_bracket, parse_right_square_bracket) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_empty_array(src): <span class="hljs-comment"><span class="hljs-comment"># ,    ,   [] yield [], src return #  return ,      #     {} {"a": 1} for (_, items, _), src in sequence( parse_left_square_bracket, parse_comma_separated_values, parse_right_square_bracket, )(src): yield items, src #      yield,     </span></span></code> </pre><br>  Well, add the function <code>parse_comma_separated_values</code> - just spit: <br><br><pre> <code class="python hljs">parse_comma = parse_word(<span class="hljs-string"><span class="hljs-string">","</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_comma_separated_values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (value, _, values), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_value, parse_comma, parse_comma_separated_values <span class="hljs-comment"><span class="hljs-comment">#  ,       if?   )(src): yield [value] + values, src return for value, src in parse_value(src): yield [value], src</span></span></code> </pre><br>  Will such a decision lead to infinite recursion?  Not!  Once the function <code>parse_comma</code> does not find another comma, and the subsequent <code>parse_comma_separated_values</code> will not <code>parse_comma_separated_values</code> executed anymore. <br><br>  Go ahead!  An object: <br><br><pre> <code class="python hljs">parse_left_curly_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"{"</span></span>) parse_right_curly_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"}"</span></span>) parse_empty_object = sequence(parse_left_curly_bracket, parse_right_curly_bracket) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_empty_object(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> {}, src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_, items, _), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_left_curly_bracket, parse_comma_separated_keyvalues, parse_right_curly_bracket, )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> items, src parse_colon = parse_word(<span class="hljs-string"><span class="hljs-string">":"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keyvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, _, value), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_string, parse_colon, parse_value )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> {key: value}, src <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_comma_separated_keyvalues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (keyvalue, _, keyvalues), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_keyvalue, parse_comma, parse_comma_separated_keyvalues, <span class="hljs-comment"><span class="hljs-comment">#   ,   )(src): keyvalue.update(keyvalues) yield keyvalue, src return for keyvalue, src in parse_keyvalue(src): #  ,         yield keyvalue, src</span></span></code> </pre><br><h3>  Well, what's next? </h3><br>  Actually, everything!  It remains to add a simple interface function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> s = s.strip() <span class="hljs-comment"><span class="hljs-comment">#      ,     match = list(parse_value(s)) if len(match) != 1: # - -   .       :) raise ValueError("not a valid JSON string") result, src = match[0] if src.strip(): #  ,     - .  . raise ValueError("not a valid JSON string") return result</span></span></code> </pre><br>  Voila! <br><br><div class="spoiler">  <b class="spoiler_title">All code together</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chain <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*funcs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(funcs) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (), src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> arg1, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> funcs[<span class="hljs-number"><span class="hljs-number">0</span></span>](src): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> others, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence(*funcs[<span class="hljs-number"><span class="hljs-number">1</span></span>:])(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (arg1,) + others, src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result number_regex = re.compile(<span class="hljs-string"><span class="hljs-string">r"(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)\s*(.*)"</span></span>, re.DOTALL) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> match = number_regex.match(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: number, src = match.groups() <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> eval(number), src string_regex = re.compile(<span class="hljs-string"><span class="hljs-string">r"('(?:[^\\']|\\['\\/bfnrt]|\\u[0-9a-fA-F]{4})*?')\s*(.*)"</span></span>, re.DOTALL) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> match = string_regex.match(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: string, src = match.groups() <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> eval(string), src <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, value=None)</span></span></span><span class="hljs-function">:</span></span> l = len(word) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> src.startswith(word): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> value, src[l:].lstrip() result.__name__ = <span class="hljs-string"><span class="hljs-string">"parse_%s"</span></span> % word <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result parse_true = parse_word(<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) parse_false = parse_word(<span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) parse_null = parse_word(<span class="hljs-string"><span class="hljs-string">"null"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chain( parse_string(src), parse_number(src), parse_array(src), parse_object(src), parse_true(src), parse_false(src), parse_null(src), ): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parse_left_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"["</span></span>) parse_right_square_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"]"</span></span>) parse_empty_array = sequence(parse_left_square_bracket, parse_right_square_bracket) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_empty_array(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [], src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_, items, _), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_left_square_bracket, parse_comma_separated_values, parse_right_square_bracket, )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> items, src parse_comma = parse_word(<span class="hljs-string"><span class="hljs-string">","</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_comma_separated_values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (value, _, values), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_value, parse_comma, parse_comma_separated_values )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [value] + values, src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_value(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [value], src parse_left_curly_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"{"</span></span>) parse_right_curly_bracket = parse_word(<span class="hljs-string"><span class="hljs-string">"}"</span></span>) parse_empty_object = sequence(parse_left_curly_bracket, parse_right_curly_bracket) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_empty_object(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> {}, src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_, items, _), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_left_curly_bracket, parse_comma_separated_keyvalues, parse_right_curly_bracket, )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> items, src parse_colon = parse_word(<span class="hljs-string"><span class="hljs-string">":"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keyvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, _, value), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_string, parse_colon, parse_value )(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> {key: value}, src <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_comma_separated_keyvalues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (keyvalue, _, keyvalues), src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence( parse_keyvalue, parse_comma, parse_comma_separated_keyvalues, )(src): keyvalue.update(keyvalues) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> keyvalue, src <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> keyvalue, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_keyvalue(src): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> keyvalue, src <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> s = s.strip() match = list(parse_value(s)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(match) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"not a valid JSON string"</span></span>) result, src = match[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> src.strip(): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"not a valid JSON string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br></div></div><br>  130 lines.  Let's try to run: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> my_json &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"null"</span></span>) &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"false"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"0.31415926E1"</span></span>) <span class="hljs-number"><span class="hljs-number">3.1415926</span></span> &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"[1, true, '1']"</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>] &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>) {} &gt;&gt;&gt; my_json.parse(<span class="hljs-string"><span class="hljs-string">"{'a': 1, 'b': null}"</span></span>) {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>}</code> </pre> <br>  Success! <br><br><h3>  Conclusion </h3><br>  Of course, I have considered far from all the situations that may arise when writing parsers.  Sometimes a programmer may need to manually control execution, rather than launching a sequence of <code>chain</code> ov and <code>sequence</code> ov.  Fortunately, this is not so inconvenient in the considered approach, as it may seem.  So, if you need to try to parse an optional construction and make an action depending on its presence, you can write: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> stuff, src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_optional_stuff(src): <span class="hljs-comment"><span class="hljs-comment">#     --  break #   else else: #    --  pass</span></span></code> </pre><br>  Here we use the unpopular Python chip - the <code>else</code> block of cycles, which is executed if the cycle has reached the end without a <code>break</code> .  It doesn‚Äôt look as attractive as our code in the article, but it‚Äôs definitely not worse than those <code>if</code> we‚Äôve got rid of so gracefully. <br><br>  Despite the incompleteness and lack of academic presentation, I hope that this article will be useful for beginner programmers, and maybe even surprised by the new approach of advanced programmers.  At the same time, I am well aware that this is just a new form for the good old recursive descent;  but if programming is an art, isn't the form important in it, if not on a par, then at least to a degree close to the content? .. <br><br>  As usual, without delay, write to the PM about any inaccuracies found, spelling, grammatical and factual errors - otherwise I will burn with shame! </div><p>Source: <a href="https://habr.com/ru/post/309242/">https://habr.com/ru/post/309242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309232/index.html">In memory of Solomon Golomb (1932-2016): the author of the shift register with linear feedback of maximum length and polynomial</a></li>
<li><a href="../309234/index.html">Top10 Virtualization Software Companies</a></li>
<li><a href="../309236/index.html">How to make them not go away</a></li>
<li><a href="../309238/index.html">Cloud and Consulting: Case for Private Cloud Migration</a></li>
<li><a href="../309240/index.html">We test Web UI on F # and canopy</a></li>
<li><a href="../309244/index.html">Data Science Week 2016</a></li>
<li><a href="../309246/index.html">Data Science Tools as an Alternative to Classic IT Systems Integration</a></li>
<li><a href="../309248/index.html">ACIT will assume the role of an ‚Äúarbitrator‚Äù in conflicts between online sellers and consumers</a></li>
<li><a href="../309252/index.html">Voronoi diagram and its applications</a></li>
<li><a href="../309254/index.html">Apple vs cryptocurrency Dash: privacy is at stake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>