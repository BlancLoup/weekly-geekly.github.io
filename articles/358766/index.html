<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I started to love Vue</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 





 This post is a logical continuation of my post / article - How I stopped loving Angular / How I stopped loving Angular . 
 It is r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I started to love Vue</h1><div class="post__text post__text-html js-mediator-article"><h1 id="vstuplenie">  Introduction </h1><br><p><img src="https://habrastorage.org/webt/uh/9a/xp/uh9axpymsnxldnhxpw6s0muhqvo.png"></p><br><p>  This post is a logical continuation of my post / article - <a href="https://habr.com/post/337578/">How I stopped loving Angular</a> / <a href="https://medium.com/%40igogrek/how-i-stopped-loving-angular-c2935f7378c4">How I stopped loving Angular</a> . <br>  It is recommended to read before reading. </p><br><p>  For about a year now in all projects in which I participate, I use Vue instead of Angular. <br>  In this post I will share the main impressions and differences after Angular, as well as tell some things from the actual experience of using Vue on combat projects. </p><a name="habracut"></a><br><h2 id="kratkiy-rekap-predyduschego-posta">  Short recap of the previous post: </h2><br><p>  Here is a brief list of the main problems that bothered me in Angular at the time of writing the previous article: </p><br><ol><li>  Horrible router </li><li>  Heavy and practical useless Dependency Injection (see below) </li><li>  Extremely controversial system of modules (not used in any other framework) </li><li>  Many superfluous and few useful abstractions, strange API-design </li><li>  Observable as part of the framework <br>  ... </li></ol><br><h3 id="di">  DI </h3><br><p>  You should immediately make a reservation about Dependency Injection: after switching to Vue, it‚Äôs still worth noting that in Angular it‚Äôs more convenient to mock external dependencies in unit tests. </p><br><p>  This depends entirely on the code base and internal best-practices, but often in Vue it is more difficult to mock something in tests than in Angular (the example will be lower). </p><br><p>  However, I do not consider this to be a serious reason for the use of a pattern so alien to JavaScript on the front end. </p><br><h2 id="pochemu-ne-pro-reakt">  Why not about the reactor </h2><br><p>  And one more small reservation regarding why Vue was chosen, and not React. <br>  Disclaimer: all points below are <strong>VERY</strong> subjective (therefore, they should not be taken as criticism, but only as a personal view): </p><br><ol><li>  Reactive in Vue just works, and immediately and asynchronously: there is no need to bother with immunity and clean functions <br>  (Immunity concept is very cool, but often extremely verbose - it is almost always long and expensive) </li><li>  JSX is bad for several reasons: <br><ul><li>  Slow migration of HTML markup to application code - especially designers who suffer here sometimes have to involve a developer for rather trivial things. </li><li>  Constantly, even without special need, it is necessary to split everything into small components, which takes time VS standardization in Angular / Vue - components are removed as necessary at any moment </li><li>  In my memory, memories of <a href="https://stackoverflow.com/questions/22538638/how-to-have-conditional-elements-and-keep-dry-with-facebook-reacts-jsx/38231866">air condition = pain</a> are still fresh </li></ul></li><li>  Hellish forms - about it later </li><li> <code>reate-react-app</code> in my opinion, today, is the least functional CLI of all the most popular frameworks, so for React it is worth creating a much more powerful tool for a long time </li><li>  Our team had quite a lot of experience with Angular - for a number of similar factors it was much easier for them to enter Vue </li></ol><br><h1 id="otlichiya-i-vpechatleniya-posle-angular">  Differences and impressions after Angular </h1><br><p>  A little about the main differences and impressions that I noted for myself when switching to Vue. </p><br><h2 id="dokumentaciya">  Documentation </h2><br><p>  The first thing you come up with when choosing a UI framework is, of course, the documentation. </p><br><p>  I will not re-parse the Angular documentation with its </p><br><blockquote>  Banana in a box </blockquote><p>  I can only say that in Vue it is much simpler and more intelligible. </p><br><p>  I will not give examples, because  all of them may seem subjective to you, while starting to read the docks, you immediately feel that they were written for people. </p><br><p>  It is also worth noting that the docks are written in 6 languages, although English would be enough (I think that now any developer should know English at least at the reading level). </p><br><h2 id="cli">  CLI </h2><br><p>  From my previous article, you could understand that I had previously thought that the Angular CLI <em>is the best</em> , but as it turned out: </p><br><ol><li>  It is sometimes <a href="https://github.com/angular/angular-cli/wiki/1-x-stories-universal-rendering">extremely difficult to customize.</a> </li><li>  Angular and CLI is broken into many <code>@angular</code> and CLI packages with different versions, which, in turn, leads to a tremendous problem when upgrading the CLI / angular version. <br>  What is already done <a href="https://github.com/angular/angular-cli/wiki/1-x-stories-1.0-update">is not very simple</a> </li></ol><br><p><img src="https://habrastorage.org/webt/fe/qm/cx/feqmcx__di02szm-oqefsyammbu.png"></p><br><p>  On the other hand, Vue CLI 3 is the coolest CLI for today. </p><br><ol><li>  Customization is extremely convenient, any package can be added at any time, thanks to <a href="">the plugin system</a> </li><li>  Simplicity and flexibility through the use of a webpack </li></ol><br><p><img src="https://habrastorage.org/webt/y0/aa/oj/y0aaojafjz2cvtcngqsh3cp8os4.png"></p><br><h2 id="zonejs-vs-vue-reactivity">  Zone.js vs Vue Reactivity </h2><br><p>  Angular uses Zone.js to track changes, which monkey patches for this standard API, like <code>setTimeout</code> . </p><br><p>  This leads to certain problems: </p><br><ol><li>  <a href="">Difficulties with non-standard API</a> , sometimes quite difficult solvable </li><li>  <a href="https://codeburst.io/how-i-stopped-loving-angular-c2935f7378c4">Horrible spectra</a> </li><li>  Generally speaking IMHO, this is a hack, and far from being the most elegant </li></ol><br><p>  Vue does not need Zone.js, tracking works by turning all data / state into Observer. </p><br><p>  At one time, when I saw sortsy, I was even somewhat upset that there was no magic. </p><br><p>  At the top level, everything is trivial: Vue goes through all the objects through Object.defineProperty (for this reason, IE8 and below are not supported) and thus adds a getter and a setter. </p><br><p>  Even nothing special to add ... </p><br><p>  However, this approach has pitfalls, but they are <a href="https://vuejs.org/v2/guide/reactivity.html">extremely simple to describe</a> and easy to understand. <br>  And the understanding is not so much Vue, as the JS itself is at its core. </p><br><blockquote>  In Vue, you cannot dynamically add new root reactive properties to an existing instance.  However, you can add a reactive property to nested objects using the Vue.set method (object, key, value): </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }) <span class="hljs-comment"><span class="hljs-comment">//  vm.a ‚Äî   vm.b = 2 // vm.b   Vue.set(vm.someObject, 'b', 2)</span></span></code> </pre> <br><p>  It should also be noted that since version 2.6, Vue will not have these problems either, since  there will be a transition to the Proxy, and it will be possible to also track the addition / removal of prop. </p><br><h2 id="rx-i-state-management">  Rx and State Management </h2><br><p>  In Angular, from the box, the core of the framework was RxJS, everything is Observable. <br>  Despite my love for Rx, many people and I had questions about whether it was needed inside Angular? </p><br><p>  Especially at first, many people simply turned Observable into promises through <code>.toPromise()</code> . </p><br><p>  And in general, the idea of ‚Äã‚Äãa shared data bus is not the easiest to understand, in addition to the complexity of Angular itself. </p><br><p>  At the same time, being such a massive framework, Angular out of the box does not provide implementation of the most popular data management pattern for today - State Management. </p><br><p>  <a href="https://github.com/ngrx/store">There is NgRx</a> , but it became fully usable not so long ago - as a result, we even have an old project with a custom implementation of a Redux-like stor. </p><br><p>  And now about Vue. </p><br><p>  Not only can any RxJS fan be able to easily connect it at any time by simply adding a new package. </p><br><p>  Already there is even <a href="https://github.com/vuejs/vue-rx">Vue-Rx</a> , allowing the use of RxJS Observabl'y along with data. </p><br><p>  If we talk about State Management, that is a great official Vuex. <br>  At one time, with great surprise, I discovered that besides him there are also a <a href="https://github.com/vuejs/awesome-vue">huge number of alternatives</a> . </p><br><p><img src="https://habrastorage.org/webt/xi/dh/aq/xidhaqnhnn_879w5yhmkhgg5jfe.png"></p><br><h2 id="drop-in">  Drop in </h2><br><p>  Actually, this is where the main advantage manifests itself (although it may seem like a disadvantage to someone) Vue - everything can be connected as needed. </p><br><p>  Just add: </p><br><ol><li><del>  Water </del></li><li>  Rxjs </li><li>  Vuex </li><li>  TypeScript </li><li>  SCSS <br>  ... </li></ol><br><p>  What would you lack, it always integrates simply and quickly. </p><br><h2 id="router">  Router </h2><br><p>  The reason for one of the most severe psychological injuries I received from Angular is a router. <br>  Despite the fact that he has already corresponded three times, he is still <strong>terrible</strong> (yes, I repeat). </p><br><p>  I will not describe all his problems in detail, but since the topic is sore, briefly: </p><br><ol><li>  There are no named routes (!) - one of the strangest decisions that could be made is <strong>to remove</strong> named routes, thereby reducing the ease of supporting complex applications at times </li><li>  A strange system of events, which need to be checked by type, </li><li>  Transformation of the parameters of the route into Observable - sometimes it is extremely inconvenient to work with them if you need them only once at the start of the component </li><li>  <em>Commands</em> were created for navigation, a very strange and not very useful solution, no longer used in any router </li><li>  Lazy Loading via the string name of the modules, in the application entirely in TypeScript ... without comments <br>  ‚Ä¶ etc. </li></ol><br><p>  If you look at the sources, you can understand that many of these problems are related to the complexity and functionality of the router. </p><br><p>  That is, do not even be in it strange solutions like teams, the number of features still makes it difficult and difficult. </p><br><p>  In Vue, the router is extremely simple and working. </p><br><p>  Speaking of simple, it should be mentioned that at one time I did not find the usual Angular parameter <code>abstract: true</code> . </p><br><p>  Out of the box it is impossible to make a route without a template, but this is solved in one line of code - by creating a component like: </p><br><pre> <code class="html hljs xml">// AbstractRoute.vue <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">router-view</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Is it bad that there is no such functionality out of the box? </p><br><p>  And yes and no, because on the one hand it is important how easy the problem is solved, and on the other - the complexity and speed of the router itself (as opposed to tricky Angular). </p><br><p>  By the way, here's the cool thing: </p><br><pre> <code class="javascript hljs"> path: <span class="hljs-string"><span class="hljs-string">`url/sub-url/:id', component: MyComponent, props: true</span></span></code> </pre> <br><p>  Now the component <code>MyComponent</code> will have a <code>props</code> <code>id</code> , which will be a parameter from the URL. <br>  This is an elegant solution, because  <code>id</code> will immediately be reactive and it's very convenient to use it in the component (again, it <em>just works</em> ). </p><br><h2 id="rasshirenie-i-pereispolzovanie">  Expansion and Reuse </h2><br><p>  On the one hand, all components in Angular are TypeScript classes. <br>  Despite this, the use of many TypeScript <em>chips is</em> often either inconvenient or impossible. </p><br><p>  This applies primarily to OOP - inheritance, abstract classes, scopes. <br>  The main problems arise with Dependency Injection and AOT compiler (God forbid you run <a href="https://github.com/angular/angular/issues%3Fq%3Dis%253Aissue%2Bis%253Aopen%2BAOT%2Bsort%253Areactions-%252B1-desc">into them</a> ). </p><br><p>  In Vue, the instance configuration is an object ‚Äî it‚Äôs easy to work with and expand, refactor. <br>  To reuse the code there are powerful things - Mixins and Plugines (see below for details). </p><br><h2 id="ui-komponenty">  UI components </h2><br><p>  In the Enterprise segment, components usually have a finished design, mock-ups, and so on.  Most often, they are written from scratch, immediately sharpened for a specific task / product / project. <br>  But not always developers have the opportunity to create everything from scratch, especially with pet projects and prototyping. </p><br><p>  Here libraries ready UI components come to the rescue, and for Vue there is already a great many of them: Element, Vuetify, Quasar, Vue-Material, Muse, iView, and so on. </p><br><p><img src="https://habrastorage.org/webt/lm/xn/8k/lmxn8klxzseee7wcoflxza7uxy0.png"></p><br><p>  Especially I would point out Element and Vuetify, the impressions are strictly positive: beautiful and stable components for any needs, good docks. </p><br><p>  We also like the set of <a href="https://buefy.github.io/">Buefy</a> components based on the <a href="https://buefy.github.io/">cool</a> Bulma CSS framework, it is especially convenient to use it in Bulma applications, where third-party components are connected as needed. </p><br><p>  In the case of Angular - Enterprise-level component libraries of just a couple of pieces, this is primarily Angular Material (Google) and Clarity (VMWare). </p><br><p>  Unfortunately, the rate of development of Clarity has recently declined, which is even more frustrating in terms of Angular's prospects in this matter. </p><br><p><img src="https://habrastorage.org/webt/fj/ng/s4/fjngs4lgh9wtutqgb201n1a0dvi.png"><br><img src="https://habrastorage.org/webt/zo/pc/r8/zopcr8xl7gz2dedzv9eu59vtt2g.png"></p><br><h1 id="realnyy-opyt-i-problemy">  Real experience and problems </h1><br><p>  And now the main problems from the real experience of using Vue in combat projects. </p><br><h2 id="slishkom-mnogo-svobody">  Too much freedom </h2><br><p>  The main problem Vue for serious projects, today, I would call too much freedom of choice. </p><br><p>  On the one hand, the fact that the same thing can be done in many different ways is very cool. </p><br><p>  But, in reality, this leads to the fact that the code base becomes rather inconsistent. </p><br><p>  <strong>An exaggerated</strong> example: custom logic on a page can be made by declaring a certain component, and it can be as local </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = { created() { <span class="hljs-comment"><span class="hljs-comment">// logic ... }} new Vue({ components: [Component],</span></span></code> </pre> <br><p>  and global (accessible from everywhere). </p><br><pre> <code class="javascript hljs">Vue.component(<span class="hljs-string"><span class="hljs-string">'Global'</span></span>, { created() { <span class="hljs-comment"><span class="hljs-comment">// logic ... }})</span></span></code> </pre> <br><p>  You can make a local Mixin which will implement this functionality. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mixin = { created() { <span class="hljs-comment"><span class="hljs-comment">// logic ... }} new Vue({ mixins: [mixin],</span></span></code> </pre> <br><p>  and it (admixture? is it? ..) again can be global. </p><br><pre> <code class="javascript hljs">Vue.mixin({ created() {<span class="hljs-comment"><span class="hljs-comment">// logic ... }})</span></span></code> </pre> <br><p>  In the end, there are plugins that do almost the same thing as global mixins. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyPlugin = { install(Vue, options) { Vue.mixin({ created() { <span class="hljs-comment"><span class="hljs-comment">// logic ... }}) }</span></span></code> </pre> <br><p>  Of course, all these features are actually needed for specific tasks and are very useful. <br>  But which option to choose is not always obvious to the developer, especially for a beginner. </p><br><h3 id="kod-revyu-neobhodim">  Review code is required </h3><br><p>  Despite the fact that we use Vuex, I noted for myself that sometimes people find it hard enough not to use data () to be used instead of state. </p><br><p>  This is a question of speed rather - it is clear that adding something to data faster, but almost always it turns out that later it will have to be taken out in the state and spend extra time on it. </p><br><p>  Perhaps, the situation in projects where there is no review code and there are a large number of juniors without much experience with Vue will be especially sad. </p><br><p>  I can assume that working with this code in a few months will be completely unpleasant. </p><br><h3 id="yunit-testy">  Unit tests </h3><br><p>  Also, after Angular, it was not very convenient and obviously mocking some things in Jest. <br>  A specific example is local storage.  Someone decided to goadling <a href="https://github.com/facebook/jest/issues/2098">this issue on a githaba</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, <span class="hljs-string"><span class="hljs-string">'localStorage'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: localStorageMock, })</code> </pre> <br><p>  I did not find the solution beautiful, but as it turned out, there is a <a href="https://stackoverflow.com/a/41434763">more elegant one.</a> </p><br><pre> <code class="javascript hljs">global.localStorage = localStorageMock;</code> </pre> <br><p>  Yes, this is not a Vue problem, but an ecosystem problem in comparison with Angular. </p><br><p>  In my opinion, precisely such real examples should be described in the documentation. </p><br><h3 id="cookbook">  Cookbook </h3><br><p>  In general, the guys from Vue know about this problem and solve it by writing a <a href="https://vuejs.org/v2/cookbook/">cookbook with recipes</a> . <br>  In fact, this is a set of ready-made solutions for popular tasks. <br>  For example: <a href="https://vuejs.org/v2/cookbook/unit-testing-vue-components.html">unit tests</a> , <br>  <a href="https://vuejs.org/v2/cookbook/form-validation.html">validation</a> and <a href="https://vuejs.org/v2/cookbook/using-axios-to-consume-apis.html">work with HTTP</a> . </p><br><p>  However, the recipes are still quite basic and are not enough for serious tasks. <br>  Tests are described and for a general understanding of this is sufficient, but the mocking mentioned above will have to be searched for yourself. </p><br><p>  I‚Äôll talk about validation later, but the work with HTTP is not precisely described in depth. </p><br><p>  I would say that Angular taught me to work with the backend API through services, I consider this a good pattern that greatly facilitates support and reuse of the code. </p><br><p>  But since we don‚Äôt have the notorious DI, and it‚Äôs not very convenient to create service instances, I would like to have a similar pattern in the Cookbook. </p><br><p>  For the most part, we have solved this problem by developing local code conventions and best practices.  <strong>Links at the end of the article</strong> </p><br><h1 id="typescript">  TypeScript </h1><br><p>  I have already said and written many times about how cool and useful TypeScript is, but the fact is that you need to know how to cook it. </p><br><p>  In Angular, everything is tied up with experimental features (decorators), inner classes and hundreds (thousands?) Of unnecessary abstractions. </p><br><p><img src="https://habrastorage.org/webt/uh/kl/az/uhklazikkxkqywsxubo7qass_ia.png"></p><br><p>  In Vue, the possible use of TypeScript is much more logical - it only allows you to expand the capabilities of the developer, without having to be tied to certain features of the language. </p><br><h2 id="problemy-s-typescript-v-vue">  Problems with TypeScript in Vue </h2><br><p>  However, to date, using TypeScript with Vue is not always that easy, here are a number of problems we have encountered. </p><br><p>  First, they <a href="https://github.com/vuejs-templates/webpack/pull/797">never took my pull request</a> because of their broken tests = ((( </p><br><p>  <em>The joke, of course, is just my personal pain.</em> </p><br><h3 id="dva-podhoda">  Two approaches </h3><br><p>  The main problem of TypeScript in Vue I would call the fact that there are <a href="https://ru.vuejs.org/v2/guide/typescript.html">two different official approaches to its use</a> . </p><br><p>  This is Vue.extend (taipings that come bundled with Vue out of the box and supported along with the main library) </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = Vue.extend({ ... })</code> </pre> <br><p>  and very similar to the Angular decorator <a href="https://github.com/vuejs/vue-class-component">vue-class-component</a> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Component <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue-class-component'</span></span> @Component({ <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;button @click="onClick"&gt;Click!&lt;/button&gt;'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vue</span></span></span><span class="hljs-class"> </span></span>{ message: string = <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> onClick (): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message) } }</code> </pre> <br><p>  Personally, I don‚Äôt like the class-component, and for several reasons we use Vue.extend: </p><br><ol><li>  The class-component has <a href="https://github.com/vuejs/vue-class-component">its own tricks</a> </li><li>  I want as little as possible to get away from the default ES6 Vue components <br><ul><li>  And use the code directly from the documentation, without the need to edit for TS </li></ul></li><li>  It is necessary for the team to understand how Vue works without TypeScript. <br><ul><li>  Especially since most have an angular background. </li></ul></li></ol><br><h3 id="drugie-problemy">  Other problems </h3><br><p>  Here are some other problems with TypeScript, of varying degrees of sadness: </p><br><ol><li>  TSlint out of the box does not work with Vue - <a href="https://github.com/palantir/tslint/issues/2099">still cannot be run for .vue files</a> .  In general, there are solutions through fork-ts-checker, but they are all ugly </li><li>  ESlint for TypeScript to <em>put it mildly is</em> not super.  Both plugin and parser are still under development. <br>  Many core and vue rules break, but the main problem is that extremely incomprehensible errors occur. <br>  However, despite this, we use it exactly by disabling broken rules and twisting the necessary ones. <br>  <a href="">Link to our ESlint config</a> . </li><li>  Vuex store is not typed outside, respectively, calls <code>this.$store</code> from the component are possible with virtually any payload </li></ol><br><p>  But Vue.extend (), in turn, has some drawbacks: </p><br><ol><li>  You can not use as a class (your captain), respectively, no private, static methods, and so on. </li><li>  Pain with mappers from Vuex ... mapGetters (), ... mapState () and so on.  <a href="https://github.com/vuejs/vuex/issues/1220">When using these mappers, typing is lost and strange errors appear</a> .  We are waiting for the <a href="https://github.com/vuejs/vuex/pull/1121">decision to be</a> flooded. </li><li>  Typing data () is uncomfortable, because  this is a function - every time you have to create an interface describing its return value </li><li>  Honest typing of props is practically impossible at all, since  It is necessary to declare a native JS type, and usually a TypeScript interface is expected, but there is an ugly solution with casting </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      myObjectProps interface MyType = {...} //   data interface MyComponentData = { someBooleanProp: boolean; } export default Vue.extend({ data(): MyComponentData { //    data  return { someBooleanProp: false }; }, props: { myObjectProps: Object as MyType //   TS  },</span></span></code> </pre> <br><h2 id="formy-s-vuex">  Forms with Vuex </h2><br><p>  In general, forms are a problem not only for Vuex, but for almost any State Management pattern. <br>  Still, it involves a one-way data stream, and the forms imply a two-way building. </p><br><p>  Vuex offers <a href="https://vuex.vuejs.org/en/forms.html">two solutions</a> . </p><br><p>  Through binding the <code>value</code> to the state value, and for updating the input event with sending the commit: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"updateMessage"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... computed: { ...mapState({ message: state =&gt; state.obj.message }) }, methods: { updateMessage (e) { this.$store.commit('updateMessage', e.target.value) } }</span></span></code> </pre> <br><p>  Or nevertheless use two-sided biding and <code>v-model</code> and the receiving and commit should be performed via a getter and setter: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... computed: { message: { get () { return this.$store.state.obj.message }, set (value) { this.$store.commit('updateMessage', value) } } }</span></span></code> </pre> <br><p>  We think the second option is more convenient and concise, but still very verbose. <br>  Present to describe in a similar way a form with 20 fields or more? <br>  It turns out a huge amount of code for such a seemingly primitive task. </p><br><p>  The problem is a little less relevant if you use mappers, namely <code>mapGetters()</code> and <code>mapMutations()</code> , <br>  but, as I wrote above, they are currently working poorly with TypeScript and had to find another solution. </p><br><p>  We wrote a primitive mapper, which adds a getter (getter from state) and a setter (commit mutation): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> mapTwoWay&lt;T&gt;(getter: string, <span class="hljs-attr"><span class="hljs-attr">mutation</span></span>: string) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>: Vue): T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.getters[getter]; }, set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>: Vue, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(mutation, value); } }; }</code> </pre> <br><p>  It allows you to reduce the amount of code and describe the fields in a similar way: </p><br><pre> <code class="javascript hljs">stringTags: Util.mapTwoWay&lt;IDatasetExtra[]&gt;(STRING_TAGS, UPDATE_STRING_TAGS)</code> </pre> <br><p>  And, accordingly, use the <code>v-model</code> : </p><br><pre> <code class="html hljs xml">v-model="stringTags"</code> </pre> <br><h2 id="validaciya-form">  Validation of forms </h2><br><p>  What was somewhat surprising after Angular is that there is no form validation out of the box in Vue.  Although it would seem, the feature is very popular. </p><br><p>  However, it does not matter, there are two most popular solutions for this task. </p><br><h3 id="vee-validate">  vee-validate </h3><br><p>  The first is a very similar mechanism with template-driven forms in Angular - <a href="https://github.com/baianat/vee-validate">vee-validate</a> . </p><br><p>  In fact, you describe all the validation logic in HTML. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-validate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'required|email'"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  I would say that this approach is suitable only for relatively small / simple forms. <br>  In reality, validation is often very sophisticated, and it becomes inconvenient to describe everything in HTML. </p><br><p>  Plus it doesn't work very well with Vuex. </p><br><h3 id="vuelidate">  vuelidate </h3><br><p>  The second solution is Vuelidate.  An incredibly elegant way of validating almost any component ‚Äî the model itself is validated, not one or the other input. </p><br><p>  The funny thing is that before discovering this wonderful package we ourselves had already started writing something similar. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$v.name.$touch()"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { required, email } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuelidate/lib/validators'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { data () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">validations</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { required, email } } }</code> </pre> <br><p>  I highly recommend, if necessary, the validation of forms immediately consider Vuelidate - it works fine (including Vuex), it is easy to connect and customize. </p><br><h2 id="osnovnaya-fishkaproblema-vue">  The main feature / problem Vue </h2><br><p>  Actually, this is the main <em>problem</em> (?). Vue is only a library, not a heaped all-in-one framework. </p><br><p>  Out of the box: </p><br><ul><li>  HTTP </li><li>  Validations </li><li>  i18n </li><li>  ‚Ä¶ etc? </li></ul><br><p>  Yes, there are officially supported: </p><br><ul><li>  Router </li><li>  State <br>  But, still these are separate packages, not the kernel. </li></ul><br><p>  However, with all this, in Vue out of the box there is such a cool built-in stuff like Animation ??? </p><br><p>  At one time, stumbled upon was somewhat surprised by the rich possibilities for the animation of just about anything. </p><br><p>  This is perhaps a much more convenient and powerful toolset than in the same Angular. </p><br><p>  <a href="https://vuejs.org/v2/guide/transitioning-state.html">A cool example from the documentation</a> : </p><br><p><img src="https://habrastorage.org/webt/db/ez/fx/dbezfx_wagyubbmwbf1cxvqgfwc.gif"></p><br><h2 id="nightwatch-i-e2e">  Nightwatch and e2e </h2><br><p>  A minor problem, again not directly related to Vue, but which we encountered on a real project. </p><br><p>  Out of the box, when generating a project for e2e testing, there is a choice between <a href="http://nightwatchjs.org/">Nightwatch</a> and <a href="https://www.cypress.io/">Cypress</a> . </p><br><p>  Despite the fact that I personally see Cypress as the coolest e2e testing tool for today, there is still <a href="https://github.com/cypress-io/cypress/issues/310">no</a> support for browsers other than Chrome. </p><br><p>  Therefore, we could not choose it for the combat project - the real customers still use other browsers. </p><br><p>  Once our tests began to crash on Linux CI for a completely inexplicable reason (everything was OK on Windows), and the errors were not informative. <br>  Later we managed to find out that the problem is related to <a href="https://github.com/nightwatchjs/nightwatch/issues/1724">hashes (#) in URLs</a> . <br>    URL'       <code>vue-router</code> . </p><br><p>  ,       <code>ChromeDriver</code> ,   Nightwatch (      Cypress  TestCafe),       "" url   : </p><br><pre> <code class="javascript hljs">.url(<span class="hljs-string"><span class="hljs-string">'data:,'</span></span>) .url(client.globals.devServerURL + <span class="hljs-string"><span class="hljs-string">`/#/my-hashed-url`</span></span>)</code> </pre> <br><h1 id="chto-my-otmetili">    </h1><br><h2 id="skorost-razrabotki">   </h2><br><p>  Angular    boilerplate ,     ,   Vue     . </p><br><p>       ,     ,      Developer Experience.  ,       . </p><br><p>        ,          . </p><br><h2 id="chego-net">   </h2><br><p>      Vue ‚Äî   React Native. <br>            . </p><br><p> ,  Vue  NativeScript Vue,  ,  ,   . <br>   Weex,           ,         . </p><br><h2 id="proizvoditelnost">  Performance </h2><br><p>           .      . </p><br><p><img src="https://habrastorage.org/webt/ch/t6/yc/cht6ycs4lisxa0vf6yra3lf_p40.png"><br><img src="https://habrastorage.org/webt/wo/nf/wu/wonfwuplztleazr2vxunjesjmkw.png"></p><br><p>       : <a href="http://www.stefankrause.net/js-frameworks-benchmark7/table.html">http://www.stefankrause.net/js-frameworks-benchmark7/table.html</a> <br> ( " "         ). </p><br><p>         : <a href="https://about.gitlab.com/2016/10/20/why-we-chose-vue/">GitLab</a> , <br> <a href="https://blog.codeship.com/consider-vuejs-next-web-project/">CodeShip</a> , <a href="https://www.netguru.co/blog/13-top-companies-that-have-trusted-vue.js-examples-of-applications">Alibaba, Xiaomi</a> . </p><br><h1 id="vyvod">  Conclusion </h1><br><p>        . </p><br><p>    ‚Äî  TypeScript  Vue     ,     ,   . </p><br><p>       ,        production. <br>  ,        ,     TS       Vue,     JavaScript. </p><br><p>   ,  ,     ,  TypeScript . </p><br><p>   Vue     ,           ,            . </p><br><p>  , "   ",      <del>  Tide </del> Vue    . </p><br><h2 id="nashi-code-conventions">  code conventions </h2><br><p>       ,         ,    . <br>    ,     . </p><br><p> <a href="https://gist.github.com/Igogrek/40ee29219de1151b0c13c86071246988">    </a> </p><br><p> <a href="https://gist.github.com/Igogrek/8d056526930cc44187d46c39791ac9e2">  cookbook</a> ‚Äî     ,    (    ). </p><br><p> <a href="https://github.com/T-Systems-RUS/vue-seed">  Vue seed</a> (TS,   Jest, ESlint  ..),   ,     Vue CLI 3, <br>             . <br>       Vue CLI 3  . </p><br><blockquote>   ?? <br><br>  Yes.  Thanks for attention. </blockquote><p> PS: <em>   ,   Vue     ‚Äî       ,      </em> </p><br><p> PPS: <em>      </em>  <em>,        ()    ‚Äî    </em> =( </p><br><p> <strong> :</strong> <a href="https://medium.com/%40igogrek/how-i-started-loving-vue-d41c1c8e77e1">https://medium.com/@igogrek/how-i-started-loving-vue-d41c1c8e77e1</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358766/">https://habr.com/ru/post/358766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358754/index.html">Logging hits (payload) Google Analytics to Google Sheets via Google Tag Manager</a></li>
<li><a href="../358758/index.html">Need more gold. How is marketing in GameDev-company?</a></li>
<li><a href="../358760/index.html">Sales using voice assistant Yandex: create skills for Alice</a></li>
<li><a href="../358762/index.html">Development of Clickhouse API for Rambler / Top-100</a></li>
<li><a href="../358764/index.html">Fintech-digest: blockchain-smartphone from HTC, determination of solvency by phone brand and regulation of ICO in Russia</a></li>
<li><a href="../358768/index.html">Month after blocking Telegram: what has changed?</a></li>
<li><a href="../358770/index.html">How to pack three large banks in one site</a></li>
<li><a href="../358772/index.html">As we played the game ‚ÄúStone - scissors - paper‚Äù on the Ethereum blockchain. Part 2 Technical</a></li>
<li><a href="../358774/index.html">Docker under Windows for development, analysis of reefs</a></li>
<li><a href="../358776/index.html">Move to the cloud: how LDAP helps implement virtual PBX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>