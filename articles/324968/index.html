<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.8 - Coordinate Systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous lesson we learned about the benefits that can be obtained from the transformation of vertices by transformation matrices. OpenGL assum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.8 - Coordinate Systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/220/f71/c36/220f71c361864aa4b470499186994907.png" alt="image" align="left" width="300">  In the previous lesson we learned about the benefits that can be obtained from the transformation of vertices by transformation matrices.  OpenGL assumes that all the vertices that we want to see will be in normalized device coordinates after starting the shader (NDC).  This means that the x, y, and z coordinates of each vertex must be between -1.0 and 1.0;  coordinates outside this range will not be visible.  Usually we specify the coordinates in the range that we set up on our own, and in the vertex shader we translate these coordinates into NDC.  Then, these NDCs are transferred to the rasterizer to convert them to two-dimensional coordinates / pixels of your screen. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Menu</b> <div class="spoiler_text"><p>  Part 1 </p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <b>Coordinate systems</b> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2 </p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Lighting maps</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple lighting</a> </li></ol><br><p>  Part 3 </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp and Mesh class</a> </li></ol><br></div></div><br><p>  The transformation of coordinates into normalized, and then into screen coordinates is usually carried out step by step, and, before the final transformation into screen coordinates, we translate the object vertices into several coordinate systems.  The advantage of converting coordinates through several <i>intermediate</i> coordinate systems is that some operations / calculations are easier to perform in certain systems, and this will soon become obvious.  In total there are 5 different coordinate systems that are important to us: </p><br><p></p><ol><li>  Local space (or Object space) </li><li>  World space </li><li>  View space (or Observer) </li><li>  Clipping space </li><li>  Screen space </li></ol><br><p>  Our vertices will be transformed into all these different states before they become fragments. </p><br><p>  Probably now you are completely confused by the fact that each space or coordinate system is of itself, so we will look at them in a more understandable form, showing the overall picture and what each of the spaces really does. </p><br><a name="01_global_picture"></a><h2>  General scheme </h2><br><p>  To convert coordinates from one space to another, we will use several transformation matrices, among which, the most important are the matrices of <b>Model</b> , <b>View</b> and <b>Projection</b> .  The coordinates of our vertices begin in <b>local space</b> as <b>local coordinates</b> , and are subsequently transformed into <b>world coordinates</b> , then <b>coordinates of the form</b> , <b>clipping</b> , and finally, everything ends with <b>screen coordinates</b> .  The following image shows this sequence, and what each transformation does: <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ce9/dfc/577/ce9dfc577b9f4472beb14991182d6e1a.png" alt="image"></div><br><p></p><ol><li>  Local coordinates are the coordinates of your object measured relative to the reference point located where the object itself begins. </li><li>  In the next step, the local coordinates are converted to the coordinates of the world space, which by their meaning are the coordinates of a larger world.  These coordinates are measured relative to the global reference point, the same for all other objects located in world space. </li><li>  Then we transform the world coordinates into the coordinates of the space of the View in such a way that each vertex becomes visible as if it was viewed from the camera or from the point of view of the observer. </li><li>  After the coordinates have been converted to the view space, we want to project them into the clipping coordinates.  The clipping coordinates are valid in the range of -1.0 to 1.0 and determine which vertices appear on the screen. </li><li>  And finally, in the transformation process, which we call the <b>transformation of the viewport</b> , <br>  we convert the clipping coordinates from -1.0 to 1.0 into the screen coordinates area specified by the <b>glViewport</b> function. </li></ol><br><p>  After all this, the resulting coordinates are sent to the rasterizer for turning them into fragments. </p><br><p>  Probably you have already understood a little what each coordinate space is used for.  The reason why we transform our vertices into these different coordinate spaces is that some operations become clearer or simpler in certain coordinate systems. <br><br>  For example, the modification of your object is most reasonable to perform in local space, and the calculation of operations taking into account the location of other objects is better done in world coordinates, etc.  If desired, we could define one transformation matrix that transformed the coordinates from the local space into the cut-off space in one step, but this would deprive us of flexibility. </p><br><p>  Below we discuss each coordinate system in more detail. </p><br><a name="02_local_space"></a><h2>  Local space </h2><br><p>  Local space is a coordinate system that is local to an object, i.e.  starts at the same point as the object itself.  Imagine you created a cube in a simulation software package (similar to Blender).  The starting point of your cube is probably located at (0,0,0), even though the cube may be located elsewhere in the application coordinates.  It is possible that all the models you create have a starting point (0,0,0).  Therefore, all the vertices of your model are in <i>local</i> space: all their coordinates are local to your object. </p><br><p>  The vertices of the container we used were defined with coordinates between -0.5 and 0.5, with a starting point of 0.0.  These are local coordinates. </p><br><a name="03_world_space"></a><h2>  World space </h2><br><p>  If we directly import all our objects into the application, they will probably be piled on top of each other near the world reference point (0.0.0), and this is not what we want.  We need to determine the position of each object to place them in a wider space.  Coordinates in world space, this is exactly what their name says: coordinates of all your peaks relative to the (game) world.  This is the coordinate space in which you would like to see your objects transformed in such a way that they would be distributed in space (and preferably realistic).  The coordinates of your object are converted from local to world space;  This is done through the <b>model</b> matrix. </p><br><p>  The model matrix is ‚Äã‚Äãa matrix that moves, scales and / or rotates your object for its location in world space in the position / orientation in which the object should be.  Imagine this as a transformation of a building that was scaled (it was too large in the local space), moved to the suburbs, and slightly turned to the left along the Y axis in such a way that it exactly approached the neighboring houses.  You can perceive the matrix from the previous lesson, in which we moved the container around the scene, as a kind of model matrix;  with its help, we recalculated the local coordinates of the container to place it in different places of the scene / world. </p><br><a name="04_view_space"></a><h2>  View Space </h2><br><p>  View Space is what people commonly call <b>an</b> OpenGL <b>camera</b> (sometimes also called <b>a camera space</b> or an <b>observer</b> <b>space</b> ).  The view space is the result of transforming world coordinates into coordinates that look as if the user is looking at them from the front.  Thus, the view space is the space visible through the camera's viewfinder.  This is usually achieved by a combination of such shifts and scene rotations that some objects are located in front of the camera.  These combined transformations are typically stored in <b>a view matrix</b> , which transforms the world coordinates into a view space.  In the next lesson we will widely discuss how to create such a view matrix to simulate a camera. <br></p><br><a name="05_clip_space"></a><h2>  Clipping space </h2><br><p>  After completion of the vertex shaders, OpenGL expects that all coordinates will be in a certain range, and everything that goes beyond its boundaries will be <b>clipped</b> .  Trimmed coordinates are discarded, and the rest become fragments visible on the screen.  This is where <b>the clipping space</b> got its name. </p><br><p>  Setting all visible coordinates to values ‚Äã‚Äãfrom the range [-1.0, 1.0] is in fact intuitively incomprehensible, so for work we define our own set of coordinates and then convert them back to NDC, as expected by OpenGL. </p><br><p>  To convert the coordinates from the view space to the clipping space, we define a so-called <b>projection matrix</b> , which defines a range of coordinates, for example, from -1000 to 1000 on each axis.  The projection matrix transforms the coordinates of this range into the normalized coordinates of the device (-1.0, 1.0).  All coordinates outside the specified interval will not fall into the area [-1.0, 1.0], and, therefore, will be cut off.  In the range that we specified by the projection matrix, the coordinate (1250, 500, 750) will not be visible, since its X component goes beyond the boundary, therefore it will be converted to a value greater than 1.0 in NDC, and therefore, the vertex will be clipped . </p><blockquote>  Please note that if outside of the cutoff volume there is not a whole primitive, for example, a triangle, but only a part of it, then OpenGL will rearrange this triangle in the form of one or several triangles that will be completely in the cutoff range. </blockquote><p> This <i>viewing volume</i> , defined by the projection matrix, is called a <b>truncated pyramid</b> (frustum) and each coordinate that falls into this pyramid will be on the user's screen.  The whole process of converting coordinates of a specific range into normalized device coordinates (NDC), which can easily be mapped to two-dimensional coordinates of the view space, is called <b>projection</b> , since the projection matrix <b>projects the</b> 3D coordinates onto simple-to-transform-in-2D normalized coordinates of the device. </p><br><p>  As soon as the coordinates of all the vertices are transferred to the clipping space, the final operation, called <b>perspective division</b> , is performed.  In it, we divide the x, y, and z components of the vertex position vector by the homogeneous component of the vector w.  Perspective division converts the 4D coordinates of the clipping space into three-dimensional normalized coordinates of the device.  This step is performed automatically after the completion of each vertex shader. </p><br><p>  It is after this stage that the coordinates obtained (using the <b>glViewport settings</b> ) are mapped to the coordinates of the screen and turned into fragments. <br></p><br><p>  The projection matrix that converts the view coordinates to cut-off coordinates can take two different forms, and each form defines its own particular truncated pyramid.  We can create an <b>orthographic</b> projection or <b>perspective</b> matrix. <br></p><br><a name="06_orthographic_projection"></a><h2>  Orthographic projection </h2><br><p>  The orthographic projection matrix defines a truncated pyramid in the form of a parallelogram, which is a clipping space, where all vertices outside its volume are clipped.  When creating an orthographic projection matrix, we specify the width, height, and length of the visible clipping pyramid.  All coordinates that after their transformation by the projection matrix into the cut-off space fall into the volume bounded by the pyramid will not be clipped.  The truncated pyramid looks a bit like a container: </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/375/d5d/e36/375d5de3682d466c9f115ebf5c5ec8ac.png" alt="Truncated pyramid of orthographic projection"></div><br><p>  The truncated pyramid defines the region of visible coordinates and is defined by the width, height, <b>near</b> and <b>far</b> planes.  Any coordinate located in front of the near plane is clipped, just as it does with the coordinates behind the rear plane.  The orthographic truncated pyramid directly translates the coordinates falling into it into the normalized coordinates of the device, and the w-components of the vectors are not used;  if the w-component is 1.0, then the perspective division will not change the coordinate values. </p><br><p>  To create an orthographic projection matrix, we use the built-in function of the GLM library, called <b>glm :: ortho</b> : </p><br><pre><code class="cpp hljs">glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">100.0f</span></span> );</code> </pre> <br><p>  The first two parameters define the left and right coordinates of the truncated pyramid, and the third and fourth parameters define the lower and upper boundaries of the pyramid.  These four points set the dimensions of the near and far planes, and the 5th and 6th parameters indicate the distance between them.  This special projection matrix converts all coordinates that fall within the ranges of x, y and z values ‚Äã‚Äãinto normalized coordinates of the device. </p><br><p>  The orthographic projection matrix maps the coordinates directly onto a two-dimensional plane, which is your display, but in reality, direct projection gives unrealistic results because it does not take <b>perspective</b> into account.  This corrects the <b>perspective projection</b> matrix. </p><br><a name="07_perspective_projection"></a><h2>  Perspective Projection </h2><br><p>  If you have ever watched the <i>real world</i> , you probably noticed that objects further away look much smaller.  This strange effect we call <b>perspective</b> .  The perspective is especially noticeable when you look at the end of an endless highway or railway, as seen in the following image: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/963/b26/a93/963b26a937304bcd9ca9d50bc1c9c121.png" alt="Perspective"></div><br><p>  As you can see, because of the perspective it seems that the lines converge the more, the further they are.  This is exactly the effect that the perspective projection tries to imitate, and it is achieved through <b>the perspective projection matrix</b> .  The projection matrix displays the specified range of the truncated pyramid into the clipping space, and at the same time manipulates the w-component of each vertex in such a way that the farther the vertex is from the observer, the more this w-value becomes.  After converting the coordinates to the clipping space, they all fall in the range from -w to w (vertices that are outside this range are truncated).  OpenGL requires the final output of the vertex shader to be between -1.0 and 1.0.  Thus, when the coordinates are in the cut-off space, the perspective division is applied to them: </p><br><p><img src="https://habrastorage.org/files/874/2e4/c86/8742e4c8676b4e96bde7005fc6049918.png" alt="Formula for perspective division"></p><br><p>  Each component of the vertex coordinate is divided into its w-component, which reduces the coordinate values ‚Äã‚Äãin proportion to the distance from the viewer.  This is another reason why the w-component is important because it helps us with a perspective projection.  The coordinates obtained after this are in the normalized device space.  If you are interested in understanding how orthogonal and perspective projection matrices are calculated (and you are not too afraid of mathematics), then I can recommend <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">this excellent</a> Songho <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">article</a> . <br></p><br><p>  You can create a perspective projection matrix in the GLM library as follows: </p><br><pre> <code class="cpp hljs">glm::mat4 proj = glm::perspective( <span class="hljs-number"><span class="hljs-number">45.0f</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">100.0f</span></span>);</code> </pre> <br><p>  <b>glm :: perspective</b> creates a <i>truncated pyramid</i> that defines the visible space, and anything that is outside of it and will not fall into the amount of clipping space will be clipped.  The perspective truncated pyramid can be represented as a trapezoidal box, each coordinate inside of which will be mapped to a point in the clipping space.  An image of a perspective truncated pyramid is shown below: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/744/5fc/9ed/7445fc9ed75b4fbe9167792d0780914a.png" alt="Perspective truncated pyramid"></div><br><p>  The first parameter sets the value of <b>fov</b> (field of view), which means " <b>field of view</b> ", and determines how large the visible area is.  For a realistic view, this parameter is usually set to 45.0f, but to get a similarity to the doom-style, you can set large values.  The second parameter sets the aspect ratio, which is calculated by dividing the width of the viewing area by its height.  The third and fourth parameters define the near and far plane of the truncated pyramid.  Usually we set the nearest distance to 0.1f, and the farthest 100.0f.  All vertices located between the near and far plane and falling into the volume of the truncated pyramid will be visualized. </p><br><blockquote>  If in the projection matrix the distance to the <i>near</i> plane is set too large (for example, 10.0f), then OpenGL cuts off all coordinates located near the camera (between 0.0 and 10.0f), which gives a visual effect familiar to video games when you can see through some objects if you get too close to them. </blockquote><br><p>  When using an orthogonal projection, each coordinate of the vertex is directly mapped to the clipping space without any imaginary perspective division (perspective division is performed, but the w-component does not affect the result (it remains equal to 1) and, therefore, has no effect).  Since the orthographic projection does not take into account the perspective, the objects located further do not seem smaller, which creates a strange visual impression.  For this reason, orthographic projection is mainly used for 2D rendering and various architectural or engineering applications, where we would prefer no distortion due to perspective.  In applications like Blender for 3D modeling, orthographic projection is sometimes used during modeling, because it more accurately reflects the dimensions and proportions of each object.  The following is a comparison of both projection methods in Blender: <br></p><br><p><img src="https://habrastorage.org/files/260/2dc/f7f/2602dcf7f3fb4fcdb9fceb0b809f0582.png" alt="Comparison of projections"></p><br><p>  You can see that with the perspective projection, the remote vertices are much farther away, while in the orthographic projection the vertex removal rate is the same and does not depend on the distance to the observer. </p><br><a name="08_putting_together"></a><h2>  Putting it all together </h2><br><p>  Create a transformation matrix for each of the above steps: model, view and projection matrix.  The vertex coordinate is converted to the coordinates of the clipping space as follows: </p><br><p><img src="https://habrastorage.org/files/ee2/6e6/3b2/ee26e63b29ae4f198215f6bdc51b3cd3.png" alt="Cut-off formula"></p><br><p>  Note that the matrix multiplication order is inverse (remember that matrix multiplication should be read from right to left).  The resulting coordinate of the vertex must be assigned in the vertex shader of the built-in variable <b>gl_Position</b> , after which OpenGL automatically performs the promising division and clipping. </p><br><blockquote>  <b>What then?</b> <br>  The coordinates of the vertex shader output must be in the clipping space, which we have just achieved using transformation matrices.  OpenGL performs a perspective division of the coordinates of the clipping space to convert them into normalized device coordinates. <br>  OpenGL then uses the parameters from <b>glViewPort</b> to map the normalized coordinates of the device to screen coordinates, in which each coordinate corresponds to a point on your screen (in our case, the area is 800x600).  This process is called <i>viewport conversion</i> . </blockquote><br><p>  This topic is difficult to understand, so if you are still not quite sure about what each space is used for, then you need not worry. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Below you will see how we can effectively apply these coordinate spaces, and there will be enough examples in the following lessons. </p><br><a name="09_going_3d"></a><h2>  Go to 3D </h2><br><p>  Now that we know how to transform the 3D coordinates into 2D coordinates, we can begin to display our objects as real 3D objects, and not as damaging 2D planes that we have shown so far. </p><br><p>  To start drawing in 3D, we first create a matrix model.  The matrix of the model consists of shifts, scaling and / or turns, which we would like to apply to <i>transform</i> all the vertices of the object into the global world space.  Let's change our plane a bit, turning it along the X axis so that it looks like it is lying on the floor.  The matrix of the model will look as follows: </p><br><pre> <code class="cpp hljs">glm::mat4 model; model = glm::rotate(model, <span class="hljs-number"><span class="hljs-number">-55.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>);</code> </pre> <br><p>  Multiplying the coordinates of the vertices by this matrix of the model, we transform them into world coordinates.  Our plane lying on the floor is thus a plane in world space. </p><br><p>  Then we need to create a view matrix.  In order for the object to become visible, we need to move a little back in the scene (because the observer's point of view in world space is at the origin (0,0,0)).  To move around the scene, think about the following: </p><br>  Moving the camera back is the same as moving the whole scene forward. <br><br><p>  This is exactly what the view matrix does: we move the entire scene to the opposite side of the one into which we would like to move the camera.  Since we need to move backwards, and since OpenGL uses the right coordinate system, we must move in the positive z direction.  We do this by shifting the entire scene to the negative side of the z axis.  This gives the impression that we are moving backwards. </p><br><blockquote>  <b>Right Coordinate System</b> <br><br><p>  By convention, OpenGL is the right coordinate system.  This basically means that the positive X axis is pointing to the right from you, the positive Y axis is up, and the positive Z axis is on you (that is, back).  Imagine that your screen is the center of three axes, and the positive Z axis passes through the screen towards you.  Axes are depicted as follows: </p><br><p><img src="https://habrastorage.org/files/dad/8d1/106/dad8d1106e6e45c298d299fe10942c96.png" alt="Axis of the right coordinate system"></p><br>  To understand why this system is called right, do the following: <br><br><ul><li>  Stretch your right hand up along the positive Y axis. </li><li>  Let your thumb point to the right. </li><li>  Let the index finger point upwards. </li><li>  Now bend your middle finger 90 degrees. </li></ul><br><p>  If you did everything correctly, your thumb should indicate the direction of the positive X axis, the index finger the positive Y axis, and the middle finger on the positive z axis.  If you do the same with your left hand, you will see that the Z axis changes direction.  This coordinate system is known as the left and is commonly used in DirectX.  Note that in the normalized coordinates of the device, OpenGL actually uses the left system (the projection matrix switches directions). </p></blockquote><br><p>  We will discuss moving around the scene in more detail in the next lesson.  At the moment, the view matrix looks like this: </p><br><pre> <code class="cpp hljs">glm::mat4 view; <span class="hljs-comment"><span class="hljs-comment">//  ,        ,      view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));</span></span></code> </pre> <br><p>  The last thing we need to determine is the projection matrix.  For our scene we will use a perspective projection, so we will declare the matrix as follows: </p><br><pre> <code class="cpp hljs">glm::mat4 projection; projection = glm::perspective(<span class="hljs-number"><span class="hljs-number">45.0f</span></span>, screenWidth / screenHeight, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">100.0f</span></span>);</code> </pre> <br><blockquote>  Be careful when specifying degrees in GLM.  Here we set the fov parameter to 45 degrees, but some GLM implementations accept fov in radians, in which case you need to set it as glm :: radians (45.0). </blockquote><br><p>  Now that we have created the transformation matrices, we must transfer them to our shaders.  First, let's declare the uniform matrix in the vertex shader of the transformation matrix and multiply them by the vertex coordinates: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; ... <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 model; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 view; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 projection; void main() { <span class="hljs-comment"><span class="hljs-comment">// ,       gl_Position = projection * view * model * vec4(position, 1.0f); ... }</span></span></code> </pre> <br><p>  We also need to send the matrices to the shader (this is usually done for each iteration, since the transformation matrices tend to change often): </p><br><pre> <code class="cpp hljs">GLint modelLoc = glGetUniformLocation(ourShader.Program, <span class="hljs-string"><span class="hljs-string">"model"</span></span>); glUniformMatrix4fv(modelLoc, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FALSE, glm::value_ptr(model)); ... <span class="hljs-comment"><span class="hljs-comment">//       </span></span></code> </pre> <br><p>  Now that our vertex coordinates are transformed by the matrices of the model, the view and the projection matrix, the final object should: </p><br><ul><li>  Rejected back to the floor. </li><li>  A little removed from us. </li><li>  To be displayed taking into account the perspective (its dimensions should become smaller with increasing distance to the viewer). </li></ul><br><p>  Let's check if the result really meets these requirements: <br></p><br><p><img src="https://habrastorage.org/files/90f/d04/ae7/90fd04ae7d0248e7924a96f2f089feb2.png" alt="View of the object in perspective"></p><br><p>  It really looks like a 3D plane that rests on some imaginary floor.  If you didn‚Äôt get the same result, check out the full <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems">source code</a> , the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transform%26type%3Dvertex">vertex shader,</a> and the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/transform%26type%3Dfragment">fragment shader</a> . <br></p><br><a name="09_more_3d"></a><h2>  More 3D </h2><br><p>  So far we have been working with the 2D plane, but in 3D space, so let's take a little adventure and expand our 2D plane to a 3D cube. <br><br>  To display the cube, we need a total of 36 vertices (6 sides * 2 triangles * 3 vertices each).  To score 36 vertices is quite a lot, so you can take them <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/cube_vertices">here</a> .  Please note that to get the resulting color of the fragments, we will use only the texture, so we skip the color values ‚Äã‚Äãof the vertices. </p><br><blockquote><p>  Removing color attributes from a vertex array changes the size of the ‚Äústep‚Äù between the vertices, so you need to correct this parameter in the calls to the glVertexAttribPointer function: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid*)0); ... // TexCoord attribute glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));</span></span></code> </pre> </blockquote><p>  For a change, let's set the cube rotation: </p><br><pre> <code class="cpp hljs">model = glm::rotate(model, (GLfloat)glfwGetTime() * <span class="hljs-number"><span class="hljs-number">50.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre> <br><p>  And now draw a cube using glDrawArrays, but this time with the number of 36 vertices. </p><br><pre> <code class="cpp hljs">glDrawArrays(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>);</code> </pre> <br><p>  You should get something like this: </p><br><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/coordinate_system_no_depth.mp4" type="video/mp4"></video></div></div></div><br><p>  The object is a bit like a cube, but something is wrong with it.  Some sides of the cube are drawn on top of its other sides.  This is because when OpenGL renders your cube triangle-behind-triangle, it overwrites the pixels in the frame buffer, despite its contents and what has already been drawn in it before.  Because of this, some triangles are drawn one on top of the other, although they should not overlap each other. </p><br><p>  Fortunately, OpenGL stores depth information in a buffer called <b>Z-Buffer</b> , which allows OpenGL to decide when to draw on top of a pixel and when not.  With the Z-buffer, we can configure OpenGL to do a pixel depth check. </p><br><a name="10_z_buffer"></a><h2>  Z-buffer </h2><br><p>  OpenGL stores all depth information in a Z-buffer, also known as <b>a depth buffer</b> .  GLFW creates this buffer automatically (it also has a frame buffer that stores the colors of the output image).  The depth is stored for each fragment (as a z-value) and whenever the fragment displays its color, OpenGL compares its depth value with the values ‚Äã‚Äãfrom the Z-buffer, and if the current fragment is behind the other fragment, it is discarded, otherwise it is overwritten. .  This process is called <b>depth checking</b> and is performed automatically by OpenGL. </p><br><p>  However, if we want to be sure that OpenGL does perform depth checking, we first need to turn it on, because it is turned off by default.  Depth checking is <b>enabled</b> using the <b>glEnable</b> function.  The <b>glEnable</b> and <b>glDisable</b> functions allow you to enable / disable certain OpenGL features.  OpenGL options are enabled / disabled until another function call is made to disable / enable them.  At this point, we want to enable depth checking, including the <b>GL_DEPTH_TEST</b> parameter: </p><br><pre> <code class="cpp hljs">glEnable(GL_DEPTH_TEST);</code> </pre> <br><p>  Since we use the depth buffer, we need to clear it before each iteration of the visualization (otherwise the buffer will contain information about the depth of previous frames).  We can clear the depth buffer in the same way as the color buffer, by specifying the <b>GL_DEPTH_BUFFER_BIT</b> bit in the <b>glClear</b> function: </p><br><pre> <code class="cpp hljs">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> </pre> <br><p>  Let's rerun our program and see if OpenGL now performs a depth check: </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/coordinate_system_depth.mp4" type="video/mp4"></video></div></div></div><br><p>  That's all!  Our cube is fully textured, with the correct depth checking, and also rotates.  <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems_with_depth">Here is the</a> source code for verification. <br></p><br><a name="11_more_cubes"></a><h2>  More cubes! </h2><br><p>  Suppose we would like to display 10 of our cubes on the screen.  All cubes look the same, but will differ in location in world space and angle of rotation.  The graphical representation of the cube is already defined, and in order to draw a few more objects, we no longer need to change the buffers or attribute arrays.  The only thing we need to fix for each object is its model matrix, thanks to which we transform the local coordinates of the cube into world ones. </p><br><p>  First, let's define for each cube a displacement vector that will set the position of an object in world space.  We write 10 positions of cubes in the array glm :: vec3: </p><br><pre> <code class="cpp hljs">glm::vec3 cubePositions[] = { glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-15.0f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">-1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.2f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.5f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">-3.8f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-12.3f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">2.4f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">-3.5f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">-1.7f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-7.5f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">1.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.5f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.5f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.5f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">-1.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.5f</span></span>) };</code> </pre> <br><p>  Now, within the game cycle, we are going to call the function glDrawArrays 10 times, but at the same time, before each visualization, we will transfer different matrixes of the model to the vertex shader.  We will create another small loop inside the game loop, which will draw our object 10 times with different values ‚Äã‚Äãof the model matrix.  Note that for each container we also added a slight rotation. </p><br><pre> <code class="cpp hljs">glBindVertexArray(VAO); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(GLuint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { glm::mat4 model; model = glm::translate(model, cubePositions[i]); GLfloat angle = <span class="hljs-number"><span class="hljs-number">20.0f</span></span> * i; model = glm::rotate(model, angle, glm::vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>)); glUniformMatrix4fv(modelLoc, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FALSE, glm::value_ptr(model)); glDrawArrays(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>); } glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  This code fragment will update the model matrix with each image of a new cube, and will do it all in all 10 times.  Now we need to see the world filled with ten arbitrarily turned cubes: </p><br><p><img src="https://habrastorage.org/files/6f5/b73/37d/6f5b7337d7104918bca20920721c486f.png" alt="Many textured cubes"></p><br><p>  Fine!  Looks like our container found some friends like it.  If you are stuck, before continuing to look at what could be the problem and compare your code with the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems_multiple_objects">source code</a> , <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems%26type%3Dvertex">vertex</a> and <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems%26type%3Dfragment">fragment</a> shader. </p><br><a name="12_exercises"></a><h2>  Exercises </h2><br><p></p><ul><li>  When creating a projection matrix, try experimenting in the GLM <b>projection</b> function with <i>FOV</i> parameters and an <i>aspect ratio</i> . <br>  See if you can figure out how these parameters affect the perspective truncated pyramid. </li><li>  Play around with the view matrix, shifting the coordinates in different directions and see how the scene changes.  Think of the view matrix as a camera. </li><li>  Try to rotate every third container (including 1), and leave the rest stationary, using only the model matrix: <br>  <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems-exercise3">the decision</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/324968/">https://habr.com/ru/post/324968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324958/index.html">Instructions for publishing iOS applications on the App Store</a></li>
<li><a href="../324960/index.html">In-depth training on the features of the title and content of the article to overcome clickbate</a></li>
<li><a href="../324962/index.html">Dumbbell as an instrument of the mind</a></li>
<li><a href="../324964/index.html">Are there stacking in Cisco Nexus switches?</a></li>
<li><a href="../324966/index.html">SAP Business One ERP Solution Features on SAP HANA Platform</a></li>
<li><a href="../324970/index.html">Adaptive Email Guide</a></li>
<li><a href="../324974/index.html">Open lecture by Sergei Zykov on April Fools ‚Äôactions in games</a></li>
<li><a href="../324978/index.html">Cones stuffed with 15 years of using actors in C ++. Part II</a></li>
<li><a href="../324980/index.html">Webinar "Testing applications for vulnerabilities. The practice of building SDLC</a></li>
<li><a href="../324982/index.html">First experience with Google API (for example, ContactsAPI) and OAuth2.0 on pure HTTP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>