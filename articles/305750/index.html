<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>F library for functional programming in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! 


 I will tell about the library for Python with the laconic name f . This is a small package with functions and classes for solvin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>F library for functional programming in Python</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello colleagues! </p><br><p> I will tell about the <a href="https://github.com/igrishaev/f">library for Python</a> with the laconic name <code>f</code> .  This is a small package with functions and classes for solving problems in a functional style. </p><br><p>  <em>- What, another functional lib for Python?</em>  <em>Author, are you aware that there is <a href="https://github.com/kachayev/fn.py">fn.py</a> and in general these functional crafts a million?</em> </p><br><p>  - Yes, in the know. </p><br><h3>  The reasons for the appearance of the library </h3><a name="habracut"></a><br><p>  I have been doing Python for a long time, but a couple of years ago I seriously got carried away with functional programming and Klozhey in particular.  Some of the approaches taken in the OP made me such a strong impression that I wanted to transfer them to everyday development. </p><br><p>  I emphasize that I do not accept the approach when the patterns of one language are roughly introduced into another without taking into account its principles and coding agreements.  No matter how much I love AF, the piling up of the MAP and Lambda in an attempt to impersonate it as a functional style annoys me. </p><br><p>  Therefore, I tried to arrange my functions so as not to meet the resistance of colleagues.  For example, use standard cycles with conditions instead of maps and reducts inside to make it easier for those who are not familiar with AF to understand. </p><br><p>  As a result, some of the parts of the library were in combat projects and, possibly, still in service.  First, I copied them from project to project, then I started a file-dump of functions and snippets, and finally I designed everything with a library, a package in Pypi and documentation. </p><br><h3>  General information </h3><br><p>  The library is written on pure Python and works on any OS, incl.  on windose.  Both branches of Python are supported.  Specifically, I checked on versions 2.6, 2.7 and 3.5.  If there are difficulties with other versions, let me know.  The only dependency is the <code>six</code> pack for agile development under both branches at once. </p><br><p>  The library is installed in the standard way via pip: </p><br><pre> <code class="python hljs">pip install f</code> </pre> <br><p>  All functions and classes are available in the head module.  It means no need to memorize <br>  paths to entities: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> f f.pcall(...) f.maybe(...) f.io_wraps(...) fL[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><p>  The package carries on board the following subsystems: </p><br><ul><li>  a set of various functions for convenient work with data </li><li>  predicate module to quickly check for any conditions </li><li>  improved versions of collections ‚Äî list, tuple, dictionary, and set </li><li>  generic sales </li><li>  monads Maybe, Either, IO, Error </li></ul><br><p>  In the sections below, I will provide code examples with comments. </p><br><h3>  Functions </h3><br><p>  The first function I transferred to Python from another ecosystem was <code>pcall</code> from Lua.  I programmed it several years ago, and although the language is not functional, I was delighted with it. </p><br><p>  The <em>pcall</em> function <em>(protected call, protected call)</em> takes another function and returns a pair <code>(err, result)</code> , where either <code>err</code> is an error and <code>result</code> empty, or vice versa.  This approach is familiar to us from other languages, such as Javascript or Go. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> f f.pcall(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, b: a / b, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) f.pcall(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, b: a / b, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;&gt;&gt; (ZeroDivisionError(<span class="hljs-string"><span class="hljs-string">'integer division or modulo by zero'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  The function is convenient to use as a decorator for already written functions that throw exceptions: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@f.pcall_wraps def func(a, b): return a / b func(4, 2) &gt;&gt;&gt; (None, 2) func(4, 0) &gt;&gt;&gt; (ZeroDivisionError('integer division or modulo by zero'), None)</span></span></code> </pre> <br><p>  Using the destructive syntax, you can unpack the result at the signature level: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(err, result)</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err: logger.exception(err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">42</span></span> process(func(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><p>  Unfortunately, the destructive syntax was cut in the third Python.  It is necessary to unpack manually. </p><br><p>  It is interesting that the use of the pair <code>(err, result)</code> is nothing else but the <code>Either</code> monad, which we will talk about later. </p><br><p>  Here is a more realistic <code>pcall</code> example.  Often it is necessary to do HTTP requests and retrieve data structures from Jason.  A lot of errors may occur during the request: </p><br><ul><li>  host curves, resolving error </li><li>  connection timeout </li><li>  server returned 500 </li><li>  server returned 200, but parsing Jason fell </li><li>  the server returned 200, but the error is in the response </li></ul><br><p>  Wrapping a call in try with catching four exceptions means making the code completely unreadable.  Sooner or later you will forget to intercept something, and the program will fall.  Here is an example of almost real code.  It retrieves the user from the local rest-service.  The result will always be a pair: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@f.pcall_wraps def get_user(use_id): resp = requests.get("http://local.auth.server", params={"id": user_id}, timeout=3) if not resp.ok: raise IOError("&lt;log HTTP code and body here&gt;") data = resp.json() if "error" in data: raise BusinesException("&lt;log here data&gt;") return data</span></span></code> </pre> <br><p>  Consider other library functions.  I would like to highlight <code>f.achain</code> and <code>f.ichain</code> .  Both are designed to safely retrieve data from objects in a chain. </p><br><p>  Suppose you have Django with the following models: </p><br><pre> <code class="python hljs">Order =&gt; Office =&gt; Department =&gt; Chief</code> </pre> <br><p>  In this case, all the fields are <code>not null</code> and you without fear go through the adjacent fields: </p><br><pre> <code class="python hljs">order = Order.objects.get(id=<span class="hljs-number"><span class="hljs-number">42</span></span>) boss_name = order.office.department.chief.name</code> </pre> <br><p>  Yes, I know about <code>select_related</code> , but it does not matter.  The situation is valid not only for ORM, but also for any other class structure. </p><br><p>  So it was in our project, until one customer asked for some links to be empty, because these are the features of his business.  We made the fields in the <code>nullable</code> base and were glad that we got off easy.  Of course, because of the rush, we did not write unit tests for models with empty links, and in the old tests the models were filled in correctly.  The client started working with updated models and received errors. </p><br><p>  The <code>f.achain</code> function safely traverses the attribute chain: </p><br><pre> <code class="python hljs">f.achain(model, <span class="hljs-string"><span class="hljs-string">'office'</span></span>, <span class="hljs-string"><span class="hljs-string">'department'</span></span>, <span class="hljs-string"><span class="hljs-string">'chief'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>) &gt;&gt;&gt; John</code> </pre> <br><p>  If the chain is broken (the field is None, does not exist), the result will be None. </p><br><p>  The analog function <code>f.ichain</code> runs through the chain of indices.  She works with dictionaries, lists and tuples.  The function is convenient for working with data obtained from Jason: </p><br><pre> <code class="python hljs">data = json.loads(<span class="hljs-string"><span class="hljs-string">'''{"result": [{"kids": [{"age": 7, "name": "Leo"}, {"age": 1, "name": "Ann"}], "name": "Ivan"}, {"kids": null, "name": "Juan"}]}'''</span></span>) f.ichain(data, <span class="hljs-string"><span class="hljs-string">'result'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'kids'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'age'</span></span>) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">7</span></span> f.ichain(data, <span class="hljs-string"><span class="hljs-string">'result'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'kids'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">'dunno'</span></span>) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  I took both of the functions from Klozha, where their ancestor is called <code>get-in</code> .  Convenience is that in microserver architecture, the structure of the response is constantly changing and may not correspond to common sense. </p><br><p>  For example, in the answer there is a field-object "user" with nested fields.  However, if there is no user for some reason, the field will not be an empty object, but None.  In the code, ugly constructions like: </p><br><pre> <code class="python hljs">data.get(<span class="hljs-string"><span class="hljs-string">'user'</span></span>, {]}).get(<span class="hljs-string"><span class="hljs-string">'address'</span></span>, {}).get(<span class="hljs-string"><span class="hljs-string">'street'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;unknown&gt;'</span></span>)</code> </pre> <br><p>  Our version is easier to read: </p><br><pre> <code class="python hljs">f.ichain(data, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'address'</span></span>, <span class="hljs-string"><span class="hljs-string">'street'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;unknown&gt;'</span></span></code> </pre> <br><p>  From Thread in the library <code>f</code> , two threading macros passed: <code>-&gt;</code> and <code>-&gt;&gt;</code> .  In the library, they are called <code>f.arr1</code> and <code>f.arr2</code> .  Both pass the original value through the <em>functional forms</em> .  This term in Lisp means an expression that is evaluated later. </p><br><p>  In other words, a <em>form</em> is either a <code>func</code> function, or a tuple of the form <code>(func, arg1, arg2, ...)</code> .  You can pass such a form somewhere as a frozen expression and calculate it later with the changes.  It turns out something like macros in Lisp, only very poor. </p><br><p>  <code>f.arr1</code> substitutes the value (and further result) as the first <br>  form argument: </p><br><pre> <code class="python hljs">f.arr1( <span class="hljs-number"><span class="hljs-number">-42</span></span>, <span class="hljs-comment"><span class="hljs-comment">#   (lambda a, b: a + b, 2), #  abs, #  str, #  ) &gt;&gt;&gt; "40"</span></span></code> </pre> <br><p>  <code>f.arr2</code> does the same thing, but puts the value at the end of the form: </p><br><pre> <code class="python hljs">f.arr2( <span class="hljs-number"><span class="hljs-number">-2</span></span>, abs, (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, b: a + b, <span class="hljs-number"><span class="hljs-number">2</span></span>), str, (<span class="hljs-string"><span class="hljs-string">"000"</span></span>.replace, <span class="hljs-string"><span class="hljs-string">"0"</span></span>) ) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"444"</span></span></code> </pre> <br><p>  Next, the <code>f.comp</code> function returns a composition of functions: </p><br><pre> <code class="python hljs">comp = f.comp(abs, (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * <span class="hljs-number"><span class="hljs-number">2</span></span>), str) comp(<span class="hljs-number"><span class="hljs-number">-42</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"84"</span></span></code> </pre> <br><p>  <code>f.every_pred</code> builds a super predicate.  This is a predicate that is true only if all internal predicates are true. </p><br><pre> <code class="python hljs">pred1 = f.p_gt(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   pred2 = f.p_even #  pred3 = f.p_not_eq(666) #   666 every = f.every_pred(pred1, pred2, pred3) result = filter(every, (-1, 1, -2, 2, 3, 4, 666, -3, 1, 2)) tuple(result) &gt;&gt;&gt; (2, 4, 2)</span></span></code> </pre> <br><p>  The super predicate is lazy: it breaks the chain of calculations at the first false value.  In the example above, predicates from the <code>predicate.py</code> module are used, which we will talk about later. </p><br><p>  The <code>f.transduce</code> function is a naive attempt to implement the <em>transducer</em> pattern <em>(transducer)</em> from Klozi.  In short, <code>transducer</code> is a combination of the <code>map</code> and <code>reduce</code> functions.  Their superposition yields a conversion "from anything to anything without intermediate data": </p><br><pre> <code class="python hljs">f.transduce( (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x + <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> res, item: res + str(item)), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">""</span></span> ) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"234"</span></span></code> </pre> <br><p>  The module of functions f.nth and its synonyms: <code>f.first</code> , <code>f.second</code> and <code>f.third</code> for safe access to the elements of the collections: </p><br><pre> <code class="python hljs">f.first((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> f.second((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> f.third((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> f.nth(<span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> f.nth(<span class="hljs-number"><span class="hljs-number">9</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><h3>  Predicates </h3><br><p>  <code></code> is an expression that returns true or false.  Predicates are used in mathematics, logic, and functional programming.  Often, a predicate is passed as a variable in a higher order function. </p><br><p>  I added some of the most useful predicates to the library.  Predicates can be <em>unary</em> (without parameters) and <em>binary</em> (or parametric), when the behavior of the predicate depends on the first argument. </p><br><p>  Consider examples with unary predicates: </p><br><pre> <code class="python hljs">f.p_str(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> f.p_str(<span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> f.p_str(<span class="hljs-string"><span class="hljs-string">u"test"</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,    int  float  f.p_num(1), f.p_num(1.0) &gt;&gt;&gt; True, True f.p_list([]) &gt;&gt;&gt; True f.p_truth(1) &gt;&gt;&gt; True f.p_truth(None) &gt;&gt;&gt; False f.p_none(None) &gt;&gt;&gt; True</span></span></code> </pre> <br><p>  Now binary.  Create a new predicate that claims something greater than zero.  What exactly?  While unknown, this is an abstraction. </p><br><pre> <code class="python hljs">p = f.p_gt(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Now, having a predicate, check any value: </p><br><pre> <code class="python hljs">p(<span class="hljs-number"><span class="hljs-number">1</span></span>), p(<span class="hljs-number"><span class="hljs-number">100</span></span>), p(<span class="hljs-number"><span class="hljs-number">0</span></span>), p(<span class="hljs-number"><span class="hljs-number">-1</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Similarly: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -    : p = f.p_gte(0) p(0), p(1), p(-1) &gt;&gt;&gt; True, True, False #    : p = f.p_eq(42) p(42), p(False) &gt;&gt;&gt; True, False #    : ob1 = object() p = f.p_is(ob1) p(object()) &gt;&gt;&gt; False p(ob1) &gt;&gt;&gt; True #      : p = f.p_in((1, 2, 3)) p(1), p(3) &gt;&gt;&gt; True, True p(4) &gt;&gt;&gt; False</span></span></code> </pre> <br><p>  I will not give examples of all predicates, it is tiresome and long.  Predicates work well with the composition functions of <code>f.comp</code> , the <code>f.comp</code> super-predicate, the built-in <code>filter</code> function and the generic, which is discussed below. </p><br><h3>  Generics </h3><br><p>  <em>A generic (generic, generic)</em> is a callable object that has several strategies for calculating the result.  The choice of strategy is determined based on the incoming parameters: their composition, type or value.  Generic allows for a default strategy when no other is found for the passed parameters. </p><br><p>  In Python, there are no generics out of the box, and especially they are not needed.  Python is flexible enough to build its system of selection functions for incoming values.  And yet, I was so pleased with the implementation of generics in Common Lisp, that of sports interest, I decided to do something similar in my library. </p><br><p>  It looks like this.  First, create a generic instance: </p><br><pre> <code class="python hljs">gen = f.Generic()</code> </pre> <br><p>  Now we will expand it with specific handlers.  The <code>.extend</code> decorator accepts a set of predicates for this handler, one per argument. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.extend(f.p_int, f.p_str) def handler1(x, y): return str(x) + y @gen.extend(f.p_int, f.p_int) def handler2(x, y): return x + y @gen.extend(f.p_str, f.p_str) def handler3(x, y): return x + y + x + y @gen.extend(f.p_str) def handler4(x): return "-".join(reversed(x)) @gen.extend() def handler5(): return 42</span></span></code> </pre><br><p>  The logic under the hood is simple: the decorator stitches a function into the internal dictionary along with the predicates assigned to it.  Now the generic can be called with arbitrary arguments.  When calling, a function with the same number of predictors is searched.  If each predicate returns true for the corresponding argument, it is considered that the strategy is found.  The result of calling the function found is returned: </p><br><pre> <code class="python hljs">gen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"12"</span></span> gen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> gen(<span class="hljs-string"><span class="hljs-string">"fiz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"fizbazfizbaz"</span></span> gen(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"olleh"</span></span> gen() &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br><p>  What happens if no strategy comes up?  It depends on whether the default handler was set.  Such a handler must be ready to meet an arbitrary number of arguments: </p><br><pre> <code class="python hljs">gen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; TypeError exception goes here... @gen.default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"default"</span></span> gen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"default"</span></span></code> </pre> <br><p>  After decorating, the function becomes a generic instance.  An interesting technique - you can transfer the execution of one strategy to another.  Multiple-body functions are obtained, almost as in Kluch, Erlang or Haskell. </p><br><p>  The handler below will be called if you pass <code>None</code> .  However, inside he redirects us to another handler with two intas, this is <code>handler2</code> .  Which, in turn, returns the sum of the arguments: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.extend(f.p_none) def handler6(x): return gen(1, 2) gen(None) &gt;&gt;&gt; 3</span></span></code> </pre> <br><h3>  Collections </h3><br><p>  The library provides "enhanced" collections based on list, tuple, dictionary, and set.  By improvements, I mean additional methods and some features in the behavior of each of the collections. </p><br><p>  Enhanced collections are created either from ordinary class calls, or special syntax with square brackets: </p><br><pre> <code class="python hljs">fL[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#  f.List([1, 2, 3]) &gt;&gt;&gt; List[1, 2, 3] fT[1, 2, 3] #  f.Tuple([1, 2, 3]) &gt;&gt;&gt; Tuple(1, 2, 3) fS[1, 2, 3] #  f.Set((1, 2, 3)) &gt;&gt;&gt; Set{1, 2, 3} fD[1: 2, 2: 3] &gt;&gt;&gt; Dict{1: 2, 2: 3} #  f.Dict({1: 2, 2: 3})</span></span></code> </pre> <br><p>  Collections have methods <code>.join</code> , <code>.foreach</code> , <code>.map</code> , <code>.filter</code> , <code>.reduce</code> , <code>.sum</code> . </p><br><p>  The list and the tuple additionally implement <code>.reversed</code> , <code>.sorted</code> , <code>.group</code> , <code>.distinct</code> and <code>.apply</code> . </p><br><p>  Methods allow you to get the result by calling it from the collection without passing it to the function: </p><br><pre> <code class="python hljs">l1 = fL[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] l1.map(str).join(<span class="hljs-string"><span class="hljs-string">"-"</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"1-2-3"</span></span></code> </pre> <br><pre> <code class="python hljs">result = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, delta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> result.append(x + delta) l1.foreach(collect, delta=<span class="hljs-number"><span class="hljs-number">1</span></span>) result == [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><pre> <code class="python hljs">l1.group(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; List[List[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], List[<span class="hljs-number"><span class="hljs-number">3</span></span>]]</code> </pre> <br><p>  I will not bore a listing on each method, anyone can see the source code with comments. </p><br><p>  It is important that the methods return a <em>new</em> instance of <em>the same</em> collection.  This reduces the likelihood of accidental change.  Operation <code>.map</code> or any other on the list will return a list, on a tuple - a tuple, and so on: </p><br><pre> <code class="python hljs">fL[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].filter(f.p_even) &gt;&gt;&gt; List[<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br><pre> <code class="python hljs">fS[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].filter(f.p_even) &gt;&gt;&gt; Set{<span class="hljs-number"><span class="hljs-number">2</span></span>}</code> </pre> <br><p>  The dictionary is iterated over pairs <code>(, )</code> , which I have always dreamed of: </p><br><pre> <code class="python hljs">fD[<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>].filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (k, v): k + v == <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; Dict{<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}</code> </pre> <br><p>  Improved collections can be added to any other collection.  The result will be a new collection of this (left) type: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   fD(a=1, b=2, c=3) + {"d": 4, "e": 5, "f": 5} &gt;&gt;&gt; Dict{'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'f': 5} #  +   fS[1, 2, 3] + ["a", 1, "b", 3, "c"] &gt;&gt;&gt; Set{'a', 1, 2, 3, 'c', 'b'} #     fL[1, 2, 3] + (4, ) List[1, 2, 3, 4]</span></span></code> </pre> <br><p>  Any collection can be switched to another: </p><br><pre> <code class="python hljs">fL[<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].group(<span class="hljs-number"><span class="hljs-number">2</span></span>).D() &gt;&gt;&gt; Dict{<span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>} fL[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>].S().T() &gt;&gt;&gt; Tuple[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><p>  Combo! </p><br><pre> <code class="python hljs">fL(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>).map(ord).map(str).reversed().join(<span class="hljs-string"><span class="hljs-string">"-"</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"99-98-97"</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pair)</span></span></span><span class="hljs-function">:</span></span> k, v = pair <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k == <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v == <span class="hljs-string"><span class="hljs-string">"2"</span></span> fL[<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>].map(str).reversed() \ .group(<span class="hljs-number"><span class="hljs-number">2</span></span>).Dict().filter(pred) &gt;&gt;&gt; Dict{<span class="hljs-string"><span class="hljs-string">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>}</code> </pre> <br><h3>  Monads </h3><br><p>  The latest and most difficult section in the library.  After reading a series of articles about monads, I ventured to add them to the library too.  At the same time he allowed himself the following deviations: </p><br><ul><li><p>  Checks on input values ‚Äã‚Äãare not based on types, as in Haskell, but on predicates, which makes monads more flexible. </p><br></li><li><p>  The operator <code>&gt;&gt;=</code> in Haskell cannot be transferred to Python, so it appears as <code>&gt;&gt;</code> (aka <code>__rshift__</code> , <code>__rshift__</code> right shift).  The problem is that Haskell also has an <code>&gt;&gt;</code> operator, but it is used less frequently than <code>&gt;&gt;=</code> .  As a result, in Python, under <code>&gt;&gt;</code> we understand <code>&gt;&gt;=</code> from Haskell, and the original <code>&gt;&gt;</code> simply not used. </p><br></li><li>  Despite the efforts, I could not implement the Haskell do-notation due to syntax limitations in Python.  I tried the cycle, the generator, and context managers - all by. </li></ul><br><h4>  Maybe </h4><br><p>  The <em>Maybe</em> monad is <em>(possibly)</em> also known as Option.  This monad class is represented by two instances: <em>Just (or Some)</em> is a repository of a positive result, in which we are interested.  <em>Nothing (in other languages ‚Äã‚Äã- None)</em> - empty result. </p><br><p>  A simple example.  Define a <em>monad constructor</em> - an object that will convert <em>scalar (flat)</em> values ‚Äã‚Äãto <em>monadic ones</em> : </p><br><pre> <code class="python hljs">MaybeInt = f.maybe(f.p_int)</code> </pre> <br><p>  In another way it is called <em>unit</em> , or monad unit.  Now we get the monad values: </p><br><pre> <code class="python hljs">MaybeInt(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; Just[<span class="hljs-number"><span class="hljs-number">2</span></span>] MaybeInt(<span class="hljs-string"><span class="hljs-string">"not an int"</span></span>) &gt;&gt;&gt; Nothing</code> </pre> <br><p>  We see that a good result is only what is being tested for int.  Now we will try in business a <em>monadny pipeline (monadic pipeline)</em> : </p><br><pre> <code class="python hljs">MaybeInt(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: MaybeInt(x + <span class="hljs-number"><span class="hljs-number">2</span></span>)) &gt;&gt;&gt; Just[<span class="hljs-number"><span class="hljs-number">4</span></span>] MaybeInt(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: f.Nothing()) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: MaybeInt(x + <span class="hljs-number"><span class="hljs-number">2</span></span>)) &gt;&gt;&gt; Nothing</code> </pre> <br><p>  From the example it can be seen that <code>Nothing</code> interrupts the execution of the chain.  If to be absolutely accurate, the chain does not break, but passes to the end, only at each step <code>Nothing</code> returned. </p><br><p>  Any function can be covered with a monad decorator to get monadic representations of scalars from it.  In the example below, the decorator ensures that only the return of the inta is considered a success - this value will go to <code>Just</code> , all the rest - to <code>Nothing</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@f.maybe_wraps(f.p_num) def mdiv(a, b): if b: return a / b else: return None mdiv(4, 2) &gt;&gt;&gt; Just[2] mdiv(4, 0) &gt;&gt;&gt; Nothing</span></span></code> </pre> <br><p>  The <code>&gt;&gt;</code> operator is otherwise called a <em>monadic binding or a pipeline (monadic binding)</em> and is called by the <code>.bind</code> method: </p><br><pre> <code class="python hljs">MaybeInt(<span class="hljs-number"><span class="hljs-number">2</span></span>).bind(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: MaybeInt(x + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &gt;&gt;&gt; Just[<span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><p>  Both ways <code>&gt;&gt;</code> and <code>.bind</code> can take on not only a function, but also a <em>functional form</em> , which I have already written above: </p><br><pre> <code class="python hljs">MaybeInt(<span class="hljs-number"><span class="hljs-number">6</span></span>) &gt;&gt; (mdiv, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; Just[<span class="hljs-number"><span class="hljs-number">3</span></span>] MaybeInt(<span class="hljs-number"><span class="hljs-number">6</span></span>).bind(mdiv, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; Just[<span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><p>  To free a scalar value from a monad, use the <code>.get</code> method.  It is important to remember that it is not included in the classical definition of monads and is a kind of concession.  The <code>.get</code> method should be strictly at the end of the pipeline: </p><br><pre> <code class="python hljs">m = MaybeInt(<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: MaybeInt(x + <span class="hljs-number"><span class="hljs-number">2</span></span>)) m.get() &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><h4>  Either </h4><br><p>  This monad extends the previous one.  Maybe the problem is that the negative result is discarded, while we always want to know the reason.  Either consists of the Left and Right subtypes, left and right values.  The left value is responsible for the negative case, and the right - for the positive. </p><br><p>  The rule is easy to remember from the phrase "our cause is right (i.e. right)".  The word <em>right</em> in English also means "true." </p><br><p>  And here is a flashback from the past: do you agree, reminds a couple <code>(err, result)</code> from the beginning of the article?  Callbacks in Javascript?  Call results in Go (only in a different order)? </p><br><p>  That's the same thing.  All these are monads, just not decorated in containers and without a mathematical apparatus. </p><br><p>  The <code>Either</code> Monad is mainly used to catch errors.  An erroneous value goes to the left and becomes the result of a conveyor.  The correct result is sped to the right for the following calculations. </p><br><p>  The <code>Either</code> monadic constructor takes two predicates: for the left value and for the right one.  In the example below, the string values ‚Äã‚Äãgo to the left value, the numeric values ‚Äã‚Äãto the right. </p><br><pre> <code class="python hljs">EitherStrNum = f.either(f.p_str, f.p_num) EitherStrNum(<span class="hljs-string"><span class="hljs-string">"error"</span></span>) &gt;&gt;&gt; Left[error] EitherStrNum(<span class="hljs-number"><span class="hljs-number">42</span></span>) &gt;&gt;&gt; Right[<span class="hljs-number"><span class="hljs-number">42</span></span>]</code> </pre> <br><p>  Check conveyor: </p><br><pre> <code class="python hljs">EitherStrNum(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: EitherStrNum(x + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &gt;&gt;&gt; Right[<span class="hljs-number"><span class="hljs-number">2</span></span>] EitherStrNum(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: EitherStrNum(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) \ &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: EitherStrNum(x + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &gt;&gt;&gt; Left[error]</code> </pre> <br><p>  Decorator <code>f.either_wraps</code> makes a monad constructor from a function: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@f.either_wraps(f.p_str, f.p_num) def ediv(a, b): if b == 0: return "Div by zero: %s / %s" % (a, b) else: return a / b @f.either_wraps(f.p_str, f.p_num) def esqrt(a): if a &lt; 0: return "Negative number: %s" % a else: return math.sqrt(a) EitherStrNum(16) &gt;&gt; (ediv, 4) &gt;&gt; esqrt &gt;&gt;&gt; Right[2.0] EitherStrNum(16) &gt;&gt; (ediv, 0) &gt;&gt; esqrt &gt;&gt;&gt; Left[Div by zero: 16 / 0]</span></span></code> </pre> <br><h4>  Io </h4><br><p>  A monad of <em>IO (I / O)</em> isolates I / O data, such as reading a file, typing, typing on a screen.  For example, we need to ask for a username.  Without the monad, we would just <code>raw_input</code> , but this reduces the abstraction and clogs the code with a side effect. </p><br><p>  Here's how to isolate keyboard input: </p><br><pre> <code class="python hljs">IoPrompt = f.io(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> prompt: raw_input(prompt)) IoPrompt(<span class="hljs-string"><span class="hljs-string">"Your name: "</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  .   "Ivan"   RET &gt;&gt;&gt; IO[Ivan]</span></span></code> </pre> <br><p>  Since we got a monad, it can be forwarded further along the conveyor.  In the example below, we will enter a name and then display it.  The <code>f.io_wraps</code> decorator turns a function into a monadic constructor: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys @f.io_wraps <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> raw_input(msg) @f.io_wraps <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text, chan)</span></span></span><span class="hljs-function">:</span></span> chan.write(text) input(<span class="hljs-string"><span class="hljs-string">"name: "</span></span>) &gt;&gt; (write, sys.stdout) &gt;&gt;&gt; name: Ivan <span class="hljs-comment"><span class="hljs-comment">#   &gt;&gt;&gt; Ivan #   &gt;&gt;&gt; IO[None] # </span></span></code> </pre> <br><h4>  Error </h4><br><p>  Monad <em>Error, it is Try (Error, Attempt) is</em> extremely useful from a practical point of view.  It isolates exceptions, ensuring that the result of the calculation is either a <code>Success</code> instance with the correct value inside, or <code>Failture</code> with a wired exception. </p><br><p>  As with Maybe and Either, the monad pipeline is executed only for a positive result. </p><br><p>  The monadic constructor accepts a <em>function</em> whose behavior is considered unsafe.     <code>Success</code> ,  <code>Failture</code> : </p><br><pre> <code class="python hljs">Error = f.error(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a, b: a / b) Error(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; Success[<span class="hljs-number"><span class="hljs-number">2</span></span>] Error(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;&gt;&gt; Failture[integer division <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> modulo by zero]</code> </pre> <br><p>   <code>.get</code>   <code>Failture</code>   .     ?   <code>.recover</code> : </p><br><pre> <code class="python hljs">Error(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).get() ZeroDivisionError: integer division <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> modulo by zero <span class="hljs-comment"><span class="hljs-comment"># value variant Error(4, 0).recover(ZeroDivisionError, 42) Success[2]</span></span></code> </pre> <br><p>      (  ),     .    <code>Success</code>    .     .      ,      <code>Success</code> .       : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function">:</span></span> logger.exception(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Error(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).recover((ZeroDivisionError, TypeError), handler) &gt;&gt;&gt; Success[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>   .      : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@f.error_wraps def tdiv(a, b): return a / b @f.error_wraps def tsqrt(a): return math.sqrt(a) tdiv(16, 4) &gt;&gt; tsqrt &gt;&gt;&gt; Success[2.0] tsqrt(16).bind(tdiv, 2) &gt;&gt;&gt; Success[2.0]</span></span></code> </pre> <br><h4>     </h4><br><p> ,          .   ,   ,    ?   ? </p><br><p>        do-,      .    : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mfunc1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.Just(a) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mfunc2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.Just(a + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mfunc3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.Just(a + b) mfunc1(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: mfunc2(x) &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> y: mfunc3(x, y))) <span class="hljs-comment"><span class="hljs-comment"># 1 2 1 2 &gt;&gt;&gt; Just[3]</span></span></code> </pre> <br><p>      ,   <code>mfunc3</code>    ,    .    <code>x</code>  <code>y</code>   .        . </p><br><h3>  Conclusion </h3><br><p> ,     <code>f</code> . ,          .        ,           .   ‚Äî       . </p><br><p> <a href="https://github.com/igrishaev/f">  </a> .    ‚Äî  . <a href="https://pypi.python.org/pypi/f">  Pypi</a> . </p><br><p>  ,       . </p><br><p>     .  Thanks for attention. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305750/">https://habr.com/ru/post/305750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305738/index.html">What is big data, part 1</a></li>
<li><a href="../305740/index.html">Lepton Free Format Compresses JPEG Files by 22% Lossless</a></li>
<li><a href="../305742/index.html">Top performances by the WGDF</a></li>
<li><a href="../305746/index.html">Mail server gateway</a></li>
<li><a href="../305748/index.html">Trust Principle in HTTPS</a></li>
<li><a href="../305752/index.html">Release of the integration platform Ensemble 2016.1</a></li>
<li><a href="../305754/index.html">Security Week 28: Pok√©mon Privacy, Critical Online Infrastructure, Post-Quantum Cryptography in Chrome</a></li>
<li><a href="../305756/index.html">Path to React</a></li>
<li><a href="../305760/index.html">Internet advertising trends: from video to virtual reality</a></li>
<li><a href="../305766/index.html">Russian schoolchildren took four gold medals at the International Mathematics Olympiad in Hong Kong</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>