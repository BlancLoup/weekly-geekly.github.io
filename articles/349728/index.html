<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preamble 
 Our team is developing a small, easy-to-use, embedded, asynchronous HTTP server for modern C ++ called RESTinio . We started to do it becau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h1>  Preamble </h1><br>  Our team is developing a small, easy-to-use, embedded, asynchronous HTTP server for modern C ++ called <a href="">RESTinio</a> .  We started to do it because we needed exactly asynchronous processing of incoming HTTP requests, but there was nothing ready for us to like.  As life shows, asynchronous processing of HTTP requests in C ++ applications is needed not only by us.  Recently, the developers from one company got in touch with the question of whether it was possible to somehow make friends with asynchronous processing of incoming requests in RESTinio with issuing asynchronous outgoing requests via <a href="https://curl.haxx.se/libcurl/">libcurl</a> . <br><br>  As the situation was clarified, we found that this company was faced with the conditions that we faced, and because of which we started developing RESTinio.  The bottom line is that an application written in C ++ accepts an incoming HTTP request.  During the processing of the request, the application needs to contact a third-party server.  This server can respond for quite some time.  Say 10 seconds (although 10 seconds is still good).  If you make a synchronous request to a third-party server, then the working thread on which the HTTP request is executed is blocked.  This begins to limit the number of parallel requests that the application can handle. <br><a name="habracut"></a><br>  The solution is to allow the application to asynchronously process all requests: both incoming and outgoing.  Then, on a limited pool of working threads (or even generally on one single working thread), it will be possible to process simultaneously tens of thousands of requests, even if the processing time of a single request is tens of seconds. <br><br>  The trick was that the application for outgoing HTTP requests was already used by libcurl.  But in the form of <a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html">curl_easy</a> , i.e.  all requests were executed synchronously.  We were asked, is it possible to combine RESTinio and curl_multi?  The question for us turned out to be interesting, because  Before libcurl in the form of <a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html">curl_multi</a> it was not necessary to apply.  Therefore, it was interesting to immerse yourself in this topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Plunged.  Got a lot of impressions.  We decided to share with readers.  Maybe someone will be interested in how to live with curl_multi.  For, as practice has shown, it is possible to live.  But carefully ...;) What we will discuss in a small series of articles based on the experience of implementing a simple simulation of the situation described above with a slowly responding third-party service. <br><br><h2>  Required disclaimers </h2><br>  In order to prevent a useless and unconstructive flame in the comments (like what happened <a href="https://habrahabr.ru/post/348880/">with the previous article</a> ), I want to make a few warnings: <br><br><ul><li>  first, the following discussion will be about C ++.  If you do not like C ++, if you think that C ++ does not belong in the modern world in general and in similar tasks in particular, then this article is not for you.  And we have no goal to convince someone that C ++ is good and should be used in such tasks.  We only talk about how to solve a similar problem in C ++ if you suddenly had to do it in C ++.  Also, we will not argue about why this may be needed and why in real life one cannot simply take and rewrite existing C ++ code into something else; </li><li>  secondly, in C ++ there is no generally accepted code convention, therefore any claims from the followers of camelCase, PascalCase, Camel_With_Underscores_Case or even UPPER_CASE will not be perceived.  We tried to bring the code in a more or less similar to K &amp; R style, so that it looked familiar to the largest number of readers.  For our "corporate" design style of C ++ code does not exactly accept everything.  However, if the appearance of the code violates your aesthetic feelings and you are ready to comment in the comments your weighty "fi" about this, then think about it, that's what: there is always someone who does not like the style you use.  Is always.  Regardless of what style you use; </li><li>  thirdly, the code shown by us in no way pretends to be a model of quality and reliability.  This is not a production code.  What you will see is a quick-and-dirty prototype, which was made on the knee just a day and another day was spent on combing the resulting code a little bit and providing it with explanatory comments.  So claims like ‚Äúyes, who writes like that‚Äù or ‚Äúyou should beat your hands for such govnokod‚Äù are not accepted, because  we express them to ourselves;) </li></ul><br>  In general, if you do not like one of the above conditions, then we apologize for the time taken away.  Further reading does not make sense.  Well, if these warnings do not frighten you, then make yourself comfortable.  We hope that you will be interested. <br><br><h1>  What is the essence of the developed imitation? </h1><br>  For demonstration purposes, we have made several applications using RESTinio and libcurl.  The simplest of these is a third-party, slow-response simulator server, called delay_server.  To start the simulation, you need to run delay_server with the necessary set of parameters (address, port, desired delay times for responses). <br><br>  Also in the simulation includes several "fronts", called bridge_server_ *.  It is the bridge_server that receives requests from the user and redirects requests to delay_server.  It is assumed that the user starts delay_server first, then one of the bridge_servers, after which it starts to fire the bridge_server in a convenient way.  For example, through curl / wget or utilities like ab / wrk. <br><br>  The imitation includes three bridge_server implementations: <br><br><ul><li>  bridge_server_1.  Very simple option in which only two working threads are used.  On one RESTinio it processes incoming HTTP requests, and on the second, outgoing HTTP requests are executed using <a href="https://curl.haxx.se/libcurl/c/curl_multi_perform.html">curl_multi_perform</a> .  This implementation will be discussed in the second part of the series; </li><li>  bridge_server_1_pipe.  More complex option bridge_server_1.  There are also two working threads, but an additional pipe is used to send notifications from the RESTinio thread to the libcurl thread.  Initially, we did not plan to describe this implementation, but if someone has an interest, we can consider bridge_server_1_pipe in details in an additional article; </li><li>  bridge_server_2.  A more complex option that uses a pool of worker threads.  Moreover, this pool serves both RESTinio and libcurl (using <a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html">curl_multi_socket_action</a> ).  This implementation will be discussed in the final part of the series. </li></ul><br>  Let's start this series with a description of the implementation of delay_server.  The benefit is the most simple and perhaps the most understandable part.  Implementations of bridge_server will be much more hardcore. <br><br><h1>  delay_server </h1><br><h2>  What does delay_server do? </h2><br>  delay_server accepts HTTP GET requests for URLs like / YYYY / MM / DD, where YYYY, MM and DD are numeric values.  All other requests delay_server responds with the code 404. <br><br>  If an HTTP GET request is sent to the URL of the form / YYYY / MM / DD, then the delay_server pauses and then responds with a small text with the greeting ‚ÄúHello, World‚Äù and the value of the paused.  For example, if you run delay_server with parameters: <br><br><pre>  delay_server -a localhost -p 4040 -m 1500 -M 4000 </pre><br>  those.  he will listen on localhost: 4040 and pause for responses between 1.5s and 4.0s.  If then execute: <br><br><pre>  curl -4 http: // localhost: 4040/2018/02/22 </pre><br>  then we get: <br><br><pre>  Hello world!
 Pause: 2347ms. </pre><br><br>  Well, or you can turn on tracing what is happening.  For a server, this is: <br><br><pre>  delayed_server -a localhost -p 4040 -m 1500 -M 4000 -t </pre><br>  For curl, this is: <br><br><pre>  curl -4 -v http: // localhost: 4040/2018/02/22 </pre><br>  For delay_server, we will see something like: <br><br><pre>  [2018-02-22 16: 47: 54.441] TRACE: starting server on 127.0.0.1:4040
 [2018-02-22 16: 47: 54.441] INFO: init accept # 0
 [2018-02-22 16: 47: 54.441] INFO: server started on 127.0.0.1:4040
 [2018-02-22 16: 47: 57.040] TRACE: accept connection from 127.0.0.1Â§©8468 on socket # 0
 [2018-02-22 16: 47: 57.041] TRACE: [connection: 1] start connection with 127.0.0.1Â§©8468
 [2018-02-22 16: 47: 57.041] TRACE: [connection: 1] start waiting for request
 [2018-02-22 16: 47: 57.041] TRACE: [connection: 1] continue reading request
 [2018-02-22 16: 47: 57.041] TRACE: [connection: 1] received 88 bytes
 [2018-02-22 16: 47: 57.041] TRACE: [connection: 1] request received (# 0): GET / 2018/02/22
 [2018-02-22 16: 47: 59.401] TRACE: [connection: 1] append response (# 0), flags: {final_parts, connection_keepalive}, bufs count: 2
 [2018-02-22 16: 47: 59.401] TRACE: [connection: 1] sending resp data, buf count: 2
 [2018-02-22 16: 47: 59.402] TRACE: [connection: 1] outgoing data was sent: 206 bytes
 [2018-02-22 16: 47: 59.402] TRACE: [connection: 1] should keep alive
 [2018-02-22 16: 47: 59.402] TRACE: [connection: 1] start waiting for request
 [2018-02-22 16: 47: 59.402] TRACE: [connection: 1] continue reading request
 [2018-02-22 16: 47: 59.403] TRACE: [connection: 1] EOF and no request, close connection
 [2018-02-22 16: 47: 59.403] TRACE: [connection: 1] close
 [2018-02-22 16: 47: 59.403] TRACE: [connection: 1] destructor called </pre><br>  and for curl: <br><br><pre> * Trying 127.0.0.1 ... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 4040 (# 0)&gt; GET / 2018/02/22 HTTP / 1.1&gt; Host: localhost: 4040&gt; User-Agent: curl / 7.58.0&gt; Accept: * / *&gt; &lt;HTTP / 1.1 200 OK &lt;Connection: keep-alive &lt;Content-Length: 28 &lt;Server: RESTinio hello world server &lt;Date: Thu, 22 Feb 2018 13:47:59 GMT &lt; Content-Type: text / plain;  charset = utf-8 &lt;Hello world!  Pause: 2360ms.  * Connection # 0 to host localhost left intact </pre><br><h2>  How does delay_server do this? </h2><br>  Delay_server is a simple single-threaded C ++ application.  A built-in HTTP server is launched on the main thread, which pulls the callback assigned by the user when receiving a request for a suitable URL.  This callback creates an Asio-shny timer and cocks the created timer to a randomly selected pause (the pause is chosen so as to fall within the limits specified when starting the delay_server).  Then callback returns control to the HTTP server, which allows the server to accept and process the next request.  When a coded callback timer is triggered, a response to a previously received HTTP request is generated and sent. <br><br><h1>  Parsing the implementation of delay_server </h1><br><h2>  Main () function </h2><br>  Analysis of the implementation of delay_server will begin immediately with the function main (), gradually explaining what is happening inside and outside main () - a. <br><br>  So, the main () code looks like this: <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> ** argv) { try { const auto cfg = parse_cmd_line_args(argc, argv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.help_requested_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; //    io_context  ,      //     . restinio::asio_ns::io_context ioctx; //          . pauses_generator_t generator{cfg.config_.min_pause_, cfg.config_.max_pause_}; //    ,    //    ,       // (    ). auto actual_handler = [&amp;ioctx, &amp;generator](auto req, auto <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(ioctx, generator, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(req)); }; //     ,   //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.config_.tracing_) { run_server&lt;traceable_server_traits_t&gt;( ioctx, cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,    . run_server&lt;non_traceable_server_traits_t&gt;( ioctx, cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } // ,     . } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  What's going on here? <br><br>  First, we parse the command line arguments and get an object with a configuration for delay_server. <br><br>  Secondly, we create several objects that we need: <br><br><ul><li>  an asio :: io_context instance that will be used both for processing HTTP server IO operations and for timers that will be entered into the incoming HTTP request handler; </li><li>  random delay generator, which is needed just so that the HTTP server is slow to respond to requests; </li><li>  A lambda function stored in the variable actual_handler, which will be the same callback called by the HTTP server for incoming HTTP requests.  This callback should have a specific format.  But the handler () function, which performs the actual processing of requests and is discussed below, has a different format and requires additional arguments.  Here is the lambda function and captures the necessary handler () arguments, exposing the signature that RESTinio requires. </li></ul><br>  Thirdly, we are launching an HTTP server.  But the launch is done taking into account whether the user wants to see the server‚Äôs tracing or not.  Here comes into the small patterned magic that we actively use in RESTinio and about which we <a href="https://habrahabr.ru/post/345788/">have already talked a little about earlier</a> . <br><br>  Here, in fact, the whole delay_server :) <br><br>  But the devil, as usual, in the details.  Therefore, let's go further, consider what hides behind these simple actions. <br><br><h2>  Configuration and analysis of the command line </h2><br>  The delay_server uses a very simple structure to describe the server configuration: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ,   . struct config_t { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,       . std::string address_{"localhost"}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . std::uint16_t port_{8090}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . milliseconds min_pause_{4000}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . milliseconds max_pause_{6000}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ? bool tracing_{false}; };</span></span></code> </pre> <br>  Analysis of the command line is pretty voluminous, so we will not dive into it.  But anyone can look under the spoiler to make an impression about what is happening. <br><br><div class="spoiler">  <b class="spoiler_title">Details of parsing command line arguments</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     . auto parse_cmd_line_args(int argc, char ** argv) { struct result_t { bool help_requested_{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}; config_t config_; }; result_t result; long min_pause{result.config_.min_pause_.count()}; long max_pause{result.config_.max_pause_.count()}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     . using namespace clara; auto cli = Opt(result.config_.address_, <span class="hljs-string"><span class="hljs-string">"address"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-a"</span></span>][<span class="hljs-string"><span class="hljs-string">"--address"</span></span>] (<span class="hljs-string"><span class="hljs-string">"address to listen (default: localhost)"</span></span>) | Opt(result.config_.port_, <span class="hljs-string"><span class="hljs-string">"port"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-p"</span></span>][<span class="hljs-string"><span class="hljs-string">"--port"</span></span>] (<span class="hljs-string"><span class="hljs-string">"port to listen (default: 8090)"</span></span>) | Opt(min_pause, <span class="hljs-string"><span class="hljs-string">"minimal pause"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-m"</span></span>][<span class="hljs-string"><span class="hljs-string">"--min-pause"</span></span>] (<span class="hljs-string"><span class="hljs-string">"minimal pause before response, milliseconds"</span></span>) | Opt(max_pause, <span class="hljs-string"><span class="hljs-string">"maximum pause"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-M"</span></span>][<span class="hljs-string"><span class="hljs-string">"--max-pause"</span></span>] (<span class="hljs-string"><span class="hljs-string">"maximal pause before response, milliseconds"</span></span>) | Opt(result.config_.tracing_)[<span class="hljs-string"><span class="hljs-string">"-t"</span></span>][<span class="hljs-string"><span class="hljs-string">"--tracing"</span></span>] (<span class="hljs-string"><span class="hljs-string">"turn server tracing ON (default: OFF)"</span></span>) | Help(result.help_requested_); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ... auto parse_result = cli.parse(Args(argc, argv)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...      . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!parse_result) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"Invalid command line: "</span></span> + parse_result.errorMessage()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result.help_requested_) std::cout &lt;&lt; cli &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min_pause &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"minimal pause can't be less or equal to 0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(max_pause &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"maximal pause can't be less or equal to 0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(max_pause &lt; min_pause) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"minimal pause can't be less than "</span></span> <span class="hljs-string"><span class="hljs-string">"maximum pause"</span></span>); result.config_.min_pause_ = milliseconds{min_pause}; result.config_.max_pause_ = milliseconds{max_pause}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  For the analysis, we tried to use the <a href="https://github.com/catchorg/Clara">new Clara library</a> from the author of the widely known in narrow circles library for unit tests in C ++ called <a href="https://github.com/catchorg/Catch2">Catch2</a> (nee Catch). <br><br>  In general, there is nothing complicated here except for one focus: the parse_cmd_line_args function returns an instance of a locally defined structure.  On the good, here it would be necessary to return something like: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">help_requested_t</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cmd_line_args_parsing_result_t</span></span> = variant&lt;<span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">help_requested_t</span></span>&gt;;</code> </pre> <br>  But in C ++ 14, std :: variant is not, and I did not want to drag some variant / either implementation from a third-party library or rely on std :: experimental :: variant.  Therefore, they did it like this.  The code, of course, smacks, but for the imitation put together on the knee, it will go. <br></div></div><br><h2>  Random Delay Generator </h2><br>  Everything is simple here, in principle, there is nothing to discuss.  So just the code.  In order to be. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation pauses_generator_t</b> <div class="spoiler_text"><pre> <code class="hljs lua">//      . class pauses_generator_t { std::mt19937 generator_{std::random_device{}()}; std::uniform_int_distribution&lt;long&gt; distrib_; const milliseconds minimal_; public: pauses_generator_t(milliseconds <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>, milliseconds <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>) : distrib_{<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>).count()} , minimal_{<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>} {} auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> minimal_ + milliseconds{distrib_(generator_)}; } };</code> </pre> <br>  It is required only to pull the next () method when necessary and a random variable in the range [min, max] will be returned. <br></div></div><br><h2>  Handler () function </h2><br>  One of the key elements of the implementation of delay_server is a small handler () function, inside which the processing of incoming HTTP requests takes place.  Here is all the code for this function: <br><br><pre> <code class="hljs markdown">//   . restinio::request<span class="hljs-emphasis"><span class="hljs-emphasis">_handling_</span></span>status<span class="hljs-emphasis"><span class="hljs-emphasis">_t handler( restinio::asio_</span></span>ns::io<span class="hljs-emphasis"><span class="hljs-emphasis">_context &amp; ioctx, pauses_</span></span>generator<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; generator, restinio::request_</span></span>handle<span class="hljs-emphasis"><span class="hljs-emphasis">_t req) { //      (   ). const auto pause = generator.next(); //     Asio-. auto timer = std::make_</span></span>shared<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">restinio::asio_ns::steady_timer</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(ioctx); timer-&gt;expires<span class="hljs-emphasis"><span class="hljs-emphasis">_after(pause); timer-&gt;async_</span></span>wait([<span class="hljs-string"><span class="hljs-string">timer, req, pause</span></span>](<span class="hljs-link"><span class="hljs-link">const auto &amp; ec</span></span>) { if(!ec) { //   ,   . req-&gt;create<span class="hljs-emphasis"><span class="hljs-emphasis">_response() .append_</span></span>header(restinio::http<span class="hljs-emphasis"><span class="hljs-emphasis">_field::server, "RESTinio hello world server") .append_</span></span>header<span class="hljs-emphasis"><span class="hljs-emphasis">_date_</span></span>field() .append<span class="hljs-emphasis"><span class="hljs-emphasis">_header(restinio::http_</span></span>field::content<span class="hljs-emphasis"><span class="hljs-emphasis">_type, "text/plain; charset=utf-8") .set_</span></span>body( fmt::format("Hello world!\nPause: {}ms.\n", pause.count())) .done(); } } ); // ,         - //   . return restinio::request_accepted(); }</code> </pre> <br>  This function (via lambda created in main () - e) is called each time an HTTP server receives an incoming GET request to the desired URL.  The incoming HTTP request itself is passed in the req parameter of the type restinio :: request_handle_t. <br><br>  This very restinio :: request_handle_t is a smart pointer to an object with the contents of an HTTP request.  That allows you to save the value of req and use it later.  This is one of the cornerstones in RESTinio asynchrony: RESTinio jerks a user-supplied callback and sends an instance of request_handle_t to this callback.  The user can either immediately generate an HTTP response inside the callback (and then it will be a trivial synchronous processing), or he can save the req on his own or transfer the req to some other thread.  Then return control RESTinio.  And form the answer later, when the appropriate time comes for that. <br><br>  In this case, an instance of asio :: steady_timer is created and req is stored in the lambda function, which is passed to async_wait for the timer.  Accordingly, the HTTP request object is retained until the timer is triggered. <br><br>  A very important point in handler () - e is the value returned by it.  By the return value, RESTinio understands whether the user has taken responsibility for forming the response to the request or not.  In this case, the request_accepted value is returned, which means that the user has promised RESTinio to generate a response to an incoming HTTP request later. <br><br>  But if handler () returned, say, request_rejected (), then RESTinio would have finished processing the request and would have answered the user with code 501. <br><br>  So, handler () is called when an incoming HTTP request arrives at the desired URL (why this is discussed below).  In handler, the delay for the response is calculated.  Then the timer is created and cocked.  When the timer runs, a response to the request will be generated.  Well, the handler () promises RESTinio to form a response to the request by returning request_accepted. <br><br>  That's all.  Little trifle: <a href="https://github.com/fmtlib/fmt">fmtlib is</a> used to form the response body.  In principle, one could do without it here.  But, first of all, we really like fmtlib and we use fmtlib at an opportunity.  And, secondly, we still needed fmtlib in bridge_server, so there was no point in abandoning it in delay_server. <br><br><h2>  Function run_server () </h2><br>  The run_server () function is responsible for setting up and running an HTTP server.  It determines which requests the HTTP server will handle and how the HTTP server will respond to all other requests. <br><br>  Also in run_server () it is determined where the HTTP server will work.  For the case of delay_server, this will be the main thread of the application. <br><br>  Let's first take a look at the run_server () code, and then consider a few important points that we haven‚Äôt talked about yet. <br><br>  So, here is the code: <br><br><pre> <code class="hljs ruby">template&lt;typename Server_Traits, typename Handler&gt; void run_server( restinio::asio_ns::io_context &amp; ioctx, const config_t &amp; config, Handler &amp;&amp; handler) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      express-. auto router = std::make_unique&lt;express_router_t&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   URL   . router-&gt;http_get( R<span class="hljs-string"><span class="hljs-string">"(/:year(\d{4})/:month(\d{2})/:day(\d{2}))"</span></span>, std::forward&lt;Handler&gt;(handler)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-number"><span class="hljs-number">404</span></span>. router-&gt;non_matched_request_handler([](auto req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req-&gt;create_response(<span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not found"</span></span>) .append_header_date_field() .connection_close() .done(); }); restinio::run(ioctx, restinio::on_this_thread&lt;Server_Traits&gt;() .address(config.address<span class="hljs-number"><span class="hljs-number">_</span></span>) .port(config.port<span class="hljs-number"><span class="hljs-number">_</span></span>) .handle_request_timeout(config.max_pause<span class="hljs-number"><span class="hljs-number">_</span></span>) .request_handler(std::move(router))); }</code> </pre> <br>  What is happening in it and why is this happening exactly? <br><br>  First, for delay_server, functionality similar to the <a href="https://expressjs.com/">expressjs</a> query routing system will be used.  In RESTinio, this is called the <a href="https://stiffstream.com/en/docs/restinio/0.4/expressrouter.html">Express router</a> . <br><br>  You need to create an instance of the object that is responsible for routing requests based on regular expressions.  After that, in this object you need to put a list of routes and set each route its handler.  What we are doing.  Create a handler: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&gt;();</code> </pre> <br>  And we indicate the route that interests us: <br><br><pre> <code class="hljs lisp">router-&gt;http_get( <span class="hljs-name"><span class="hljs-name">R</span></span><span class="hljs-string"><span class="hljs-string">"(/:year(\d{4})/:month(\d{2})/:day(\d{2}))"</span></span>, std:<span class="hljs-symbol"><span class="hljs-symbol">:forward&lt;Handler&gt;</span></span>(<span class="hljs-name"><span class="hljs-name">handler</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  After that, we also set a handler for all other requests.  Which will simply answer code 404: <br><br><pre> <code class="hljs lisp">router-&gt;non_matched_request_handler([](<span class="hljs-name"><span class="hljs-name">auto</span></span> req) { return req-&gt;create_response(<span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not found"</span></span>) .append_header_date_field() .connection_close() .done()<span class="hljs-comment"><span class="hljs-comment">; });</span></span></code> </pre> <br>  This completes the preparation of the Express router we need. <br><br>  Secondly, when calling run (), we specify that the HTTP server should use the specified io_context and should work on the same thread on which the run () call was made.  Plus, the server sets the parameters from the configuration (because the IP address and port, the maximum allowable time for processing requests and the handler itself): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">restinio</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::run(ioctx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">restinio</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::on_this_thread</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Server_Traits</span></span>&gt;() <span class="hljs-selector-class"><span class="hljs-selector-class">.address</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.address_</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.port</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.port_</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.handle_request_timeout</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.max_pause_</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.request_handler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">std</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::move(router)))</span></span>;</code> </pre> <br>  Here the use of on_this_thread makes RESTinio run the HTTP server in the context of the same thread. <br><br><h3>  Why is run_server () a template? </h3><br>  The run_server () function is a template function that depends on two parameters: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Server_Traits, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Handler&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::asio_ns::io_context &amp; ioctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">config_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; config, Handler &amp;&amp; handler)</span></span></span></span>;</code> </pre> <br>  In order to explain why this is so, let's start with the second template parameter - Handle. <br><br>  Inside main () we create the actual request handler as a lambda function.  The real type of this lambda is known only by the compiler.  Therefore, in order to pass the lambda handler to run_server (), we need the template parameter Handle.  With its help, the compiler will display the required type of the argument handler in run_server (). <br><br>  But with the Server_Traits parameter, the situation is a bit more complicated.  The fact is that the HTTP server in RESTinio needs to set a set of properties that will determine various aspects of server behavior and implementations.  For example, whether the server will be adapted to work in multi-threaded mode.  Will the server log its operations, etc.?  All this is set by the template Traits parameter for the restinio :: http_server_t class.  In this example, this class is not visible, because  an instance of http_server_t is created inside run ().  But all the same Traits should be set.  Just the template Server_Traits parameter of the run_server () function and sets the Traits for http_server_t. <br><br>  We in delay_server needed to define two different types of Traits: <br><br><pre> <code class="hljs pgsql">//    express-router.     //   . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> express_router_t = restinio::router::express_router_t&lt;&gt;; //          http-. //    ,     . struct non_traceable_server_traits_t : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> restinio::default_single_thread_traits_t { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> request_handler_t = express_router_t; }; //    ,    . struct traceable_server_traits_t : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> restinio::default_single_thread_traits_t { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> request_handler_t = express_router_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> logger_t = restinio::single_threaded_ostream_logger_t; };</code> </pre> <br>  The first type, non_traceable_server_traits_t, is used when the server does not need to log its actions.  The second type, traceable_server_traits_t, is used when logging should be. <br><br>  Accordingly, inside the main () function, depending on the presence or absence of the "-t" key, the run_server () function is called either with non_traceable_server_traits_t, or with traceable_server_traits_t: <br><br><pre> <code class="hljs pgsql">//     ,   //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.config_.tracing_) { run_server&lt;traceable_server_traits_t&gt;( ioctx, cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,    . run_server&lt;non_traceable_server_traits_t&gt;( ioctx, cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); }</code> </pre> <br>  So assigning the right properties to an HTTP server is another reason why run_server () is a template function. <br><br>  The Traits for restinio :: http_server_t topic is covered <a href="https://habrahabr.ru/post/345788/">in</a> more detail <a href="https://habrahabr.ru/post/345788/">in our previous article on RESTinio</a> . <br><br><h1>  Conclusion of the first part </h1><br>  That is, in fact, all that could be told about the implementation of delay_server on the basis of RESTinio.  We hope that the material described was clear.  If not, we will be happy to answer questions in the comments. <br><br>  In subsequent articles, we will talk about the integration examples of RESTinio and curl_multi, examining the implementation of bridge_server_1 and bridge_server_2.  There, the parts that belong specifically to RESTinio will be no longer and no more complicated than what we have shown in this article.  And the bulk of the code and the main complexity will result from curl_multi.  But that's another story ... <br><br>  <a href="https://habrahabr.ru/post/349818/">To</a> be <a href="https://habrahabr.ru/post/349818/">continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/349728/">https://habr.com/ru/post/349728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349718/index.html">Creating a game on Lua and L√ñVE - 3</a></li>
<li><a href="../349720/index.html">Authorization using ssl certificate on nginx + Let's Encrypt</a></li>
<li><a href="../349722/index.html">How we built VDI with 14,000 jobs for the VTB Group</a></li>
<li><a href="../349724/index.html">How we improved technical support with cohort analysis</a></li>
<li><a href="../349726/index.html">Basics of programming on the SAS Base. Lesson 2. Access to data</a></li>
<li><a href="../349730/index.html">Best hackathon ravers: big data and mobile development</a></li>
<li><a href="../349732/index.html">Network code for the poor</a></li>
<li><a href="../349734/index.html">Theory and practice of time: what developers think about the management of working hours</a></li>
<li><a href="../349736/index.html">Seminar "Data Storage Systems for the Cloud and in the Cloud", March 1, St. Petersburg</a></li>
<li><a href="../349738/index.html">STM32 blink ++ or read incremental encoder data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>