<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 4a of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Course content 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: Removing inv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 4a of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Course content </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <b>4a: Construction of perspective distortion</b> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><br><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li></ul><br><br><br><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr><br><br><h1>  Building perspective distortion </h1><br><p>  The fourth article will be divided into two, the first part talks about building perspective distortion, the second about how to move the camera and what follows from this.  The task for today is to learn how to generate the following images: <br></p><br><img src="https://habrastorage.org/getpro/habr/post_images/394/67d/da6/39467dda61fdb644e68bdafc1e1f17f1.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Geometry on the plane </h2><br><h3>  Linear plane transform </h3><br><p>  A linear mapping on the plane is given by the corresponding matrix.  If we take the point (x, y), then its transformation is written as follows: <br></p><br><img src="https://members.loria.fr/dsokolov/files/habrahabr/04-geometry/img/f00.svg"><br><br><p>  The simplest (non-degenerate) transformation is given by the identity matrix; it simply leaves each point in place. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/06a/bdf/36a/06abdf36a5a721e2fa683e22ee073f39.svg"><br><br><p>  The coefficients on the diagonal of the matrix set the stretching / compression of the plane.  Let's illustrate with a picture: for example, if we write the following transformation: <br></p><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/c5b/71c/cc4c5b71cd1628c1738a748e9e130b05.svg"><br><br><p>  That white object (a square with a cut corner) is converted to yellow.  Red and green segments give unit vectors along the x and y axis, respectively. </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2aa/8b6/71e/2aa8b671e124f1511c3b47a37c47f150.png"><br><br><p>  All pictures for this article are generated <a href="https://github.com/ssloy/tinyrenderer/tree/a175be75a8a9a773bdfae7543a372e3bc859e02f">here by this</a> code. </p><br><br><p>  Why even use the matrix?  Because it is convenient.  To begin with, in the matrix form, the transformation of the entire object can be written like this: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/902/307/cb2/902307cb2779a94a1b14056a9f7c6b7a.svg"><br><br><p>  Here the transformation is the same as in the previous example, but the matrix in two rows and five columns is nothing more than an array of coordinates of our cube with a cut corner.  We simply took the entire array, multiplied by the transformation, and obtained the already transformed object.  Handsomely?  Okay, I agree, far-fetched. <br></p><br><br><p>  The real reason is that, extremely regularly, we want the object to undergo several transformations in a row.  Imagine that you are writing a type conversion function in your code. <br></p><pre> vec2 foo (vec2 p) return vec2 (ax + by, cx + dy);
 vec2 bar (vec2 p) return vec2 (ex + fy, gx + hy);
 [..]
 for (each p in object) {
     p = foo (bar (p));
 }
</pre><br>  This code makes two linear transformations for each vertex of the object, and they are calculated in millions.  And often we want transformations with a good ten.  Expensive.  And with the matrix approach, we multiply all the transformation matrices and multiply by our object once.  In multiplication, we can put brackets where we want, right? <br><p></p><br><br><p>  We continue the conversation, we know that the diagonal elements give us the scaling along the axes.  What are the two other matrix coefficients responsible for?  Let's look at this conversion: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/98a/422/61e/98a42261ee59cd8670a5a1e49aa457a4.svg"><br><br><p>  The corresponding picture: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb1/315/9ff/bb13159ffc0656ee622f9c4ebd108fed.png"><br><p>  Nothing but a simple shift along the x axis.  The second anti-diagonal element will give a shift along the y axis.  Thus, there are only two basic linear transformations on the plane: stretching along the axes and shifting along the axis.  Wait, they will tell me, but what about, for example, rotation around the origin? <br></p><br><br><p>  It turns out that the rotation can be represented as a composition of three shifts, here the white object is converted first to red, then to green, then to blue: <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/872/3ca/291/8723ca291b463b6eb44b9a91f5cbd26f.png"><br><br><p>  But let's not go to extremes, the counterclockwise rotation matrix around the origin can be written directly (remember about the placement of brackets?): </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/1c4/1f8/f711c41f8adcb36559a787a36631cc97.svg"><br><br><p>  We can, of course, multiply in any order, just let's not forget that for matrices multiplication is noncommutative: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a57/ee5/b31/a57ee5b3104793f9032f2da55af3dc49.svg"><br><br><p>  What is normal, move and then rotate (red object) is not the same as first rotate, and then move (green object): </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a8/5ee/0eb/7a85ee0ebed76be99ba9f97f0c89c5a4.png"><br><br><h3>  Affine transformations on the plane </h3><br><p>  That is, any linear transformation on the plane is a composition of stretchings and shifts.  Which means that whatever the matrix of our transformation, the origin always goes to the origin.  Thus, linear transformations are fine, but if we cannot imagine an elementary parallel translation, then our life will be sad.  Or can we?  But what if you add it separately and record the affine transformation as a composition of the linear part and parallel translation?  Like this: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/ffc/e76/f72ffce760c96e7f345d02ca5ba59d3b.svg"><br><br><p>  This is, of course, a wonderful record, but just let us see what the composition of two such transformations looks like (I remind you that in real life we ‚Äã‚Äãneed to be able to accumulate dozens of transformations): <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/ae1/c93/804ae1c9342e45d9cc6ade94f7d0687d.svg"><br><br><p>  It starts to look extremely unpleasant already for a single composition.  Try converting this expression to apply only one kind of linear transformation + parallel translation to our object.  Personally, I really do not want to do this. </p><br><br><h2>  Homogeneous coordinates </h2><br><p>  And what to do?  Cast a spell!  Imagine now that I‚Äôll add one line and one column to our transformation matrix and add a third coordinate, which is equal to one in the vector that we transform: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/06b/305/d32/06b305d32f3d72ad46053154dc690d4c.svg"><br><br><p> When multiplying this 3x3 matrix and our vector supplemented with a unit, we again obtained a vector with a unit in the third component, and the other two have exactly the form we wanted!  Witch. </p><br><br><p>  In fact, the idea is very simple: parallel translation is not a linear operation in a two-dimensional space. <br>  Therefore, we immerse our two-dimensional space in three-dimensional (adding one to the third component).  This means that our two-dimensional space is the plane z = 1 inside three-dimensional.  Then we do a linear transformation in three-dimensional space and project the entire three-dimensional space back onto our physical plane.  The parallel transfer from this did not become linear, but the pipeline is still simple. </p><br><br><p>  How exactly do we project the three-dimensional space back into our plane?  Very simple: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/022/7e5/9e20227e5a8082f98e4661cd4f47405d.svg"><br><br><h3>  Wait a second, but you can't divide by zero! </h3><br><p>  Who told you?  Joke.  Let's understand what is happening again. <br></p><ul><li>  We immerse our 2d space in 3d, making it the plane z = 1 </li><li>  We do what we want in 3d </li><li>  For each point that we want to project back to 2d, draw a line between the origin and this point and look for its intersection with the physical plane z = 1. </li></ul><br>  In this picture, our physical plane is purple, and the point (x, y, z) is projected to the point (x / z, y / z): <br><p></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/47c/f05/bf6/47cf05bf642df13f9b738e2c3040f648.png"><br><br><p>  Now, let's imagine a vertical rail passing through a point (x, y, 1).  Where is the point projected (x, y, 1)?  Of course, in (x, y): </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/549/67a/0c054967a27e66bf020844118a1750d8.png"><br><br><p>  Now let's start sliding down the rail, for example, a point (x, y, 1/2) is projected onto (2x, 2y): </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed2/4b2/2a0/ed24b22a0542f9f930e0386c598d5a77.png"><br><br><p>  Continue to slide: the point (x, y, 1/4) is projected at (4x, 4y): </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/658/d91/9e9658d91a6c8198606a8603012f048a.png"><br><br><p>  Continuing to slide to zero along z, our projection goes farther and farther from the center of coordinates in the direction (x, y). <br>  That is, the point (x, y, 0) is projected to an infinitely far point in the direction (x, y).  What is it?  That's right, it's a vector! <br>  Homogeneous coordinates make it possible to distinguish between a vector and a point.  If a programmer writes vec2 v (x, y), is it a vector or a dot? <br>  Hard to say.  And in homogeneous coordinates, everything with zero over the third component is a vector, everything else is end points. <br>  See: vector + vector = vector.  Vector vector = vector.  Point + vector = point.  Isn't it great? <br></p><br><br><h3>  Compound Transform Example </h3><br><p>  I have already said that we need to be able to accumulate dozens of transformations.  Why?  Suppose you need to rotate a flat object around a point (x0, y0).  How to do it?  You can go and look for formulas, and you can do it yourself, because we have all the tools. <br>  We can rotate around the center of coordinates, we can move.  What else does?  Shift x0, y0 to the center of coordinates, rotate, return back.  Freebie! <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/262/3f6/a5e/2623f6a5edf227c85a60083759ffa67d.svg"><br><br><p>  In the 3D sequence of actions will be a little longer, but the meaning remains the same: we only need to be able to do several basic transformations, and with their help we can code any complicated thing. <br></p><br><br><h2>  Wait, do I have the right to touch the bottom row of the 3x3 matrix? </h2><br><p>  And how!  Let's apply this conversion: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/14c/e2f/cae14ce2f670b8f0af51907f2d710dd3.svg"><br><p>  to our standard test object.  I remind you that the test object is white, single x and one vector are shown in red and green, respectively </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f3/6ab/01d/7f36ab01dad4a2937599de236c8d4d28.png"><br><br><p>  Here is our converted object: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff8/f6a/213/ff8f6a2130986fed747e55a26e054c6f.png"><br><br><p>  And here begins the most interesting.  Remember our exercise about buffer?  Here we will do almost the same thing. <br>  We will project our two-dimensional object onto the x = 0 line.  And now let's complicate the task: the projection will be central, our camera is at the point (5, 0) and looks at the origin of coordinates.  To find a projection, we must draw lines passing through a camera point and each vertex of our object (yellow lines), and then find their intersection from a straight screen (white vertical). <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/81e/13a/a7081e13ad5016aa33f87edb50b218f0.png"><br><br><p>  Now let's remove the original object and instead draw a transformed one. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/f23/379/2b9f233797ca0a8b2d9d9f9750c29a36.png"><br><p>  If we use the <b>usual orthogonal</b> projection of our transformed object, then we will find exactly the same points! <br>  What does this mapping do?  It each vertical edge leaves vertical, but at the same time stretches those that are close to the camera, and compresses those that are farther from the camera.  Having correctly selected the stretch-compression ratio, we can achieve the effect that with a simple orthogonal projection we get an image in perspective distortion!  In the next paragraph, we will add one dimension and show where the coefficient -1/5 came from. </p><br><br><h2>  It's time to move on to three dimensions. </h2><br><p>  Let's explain the magic that just happened. <br>  As in the case of two-dimensional affine transformations, we will also use homogeneous coordinates in three-dimensional space. <br>  We take the point (x, y, z), immerse it in four-dimensional space, add one to the fourth component, transform it in four dimensions and project it back into 3d.  For example, take the following conversion: <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5f/38b/3ba/d5f38b3ba42cbbc7801e7419ea6b0647.svg"><br><br><p>  A 3D projection gives the following coordinates: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/222/ed8/857/222ed8857a7e2ff9e9eeaabc7737de08.svg"><br><br><p>  Well remember this result, but postpone it for a couple of minutes.  Let's return to the standard definition of the central projection in the usual 3D, without uniform coordinates and other exotic things.  Suppose we have a point P = (x, y, z), which we want to project on the z = 0 plane, the camera is on the z axis at a distance c from the center of coordinates. <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/525/d39/304/525d3930435c3be900e4c7956edb5a1c.png"><br><br><p>  We know that the triangles ABC and ODC are similar.  That is, we can write | AB | / | AC | = | OD | / | OC |  =&gt; x / (cz) = x '/ c. <br></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/78d/876/80478d87638b5b1cca4f09db69e59f59.svg"><br><br><p>  Considering the triangles CPB and CP'D, one can easily come to a similar record for the y coordinate: </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/e7d/df4/d29e7ddf41f965294c4882a9259a1904.svg"><br><br><p>  So, it is very, very similar to the result of a projection through homogeneous coordinates, only there it was all considered one matrix multiplication.  We derived the dependence of the coefficients r = -1 / c. </p><br><br><h1>  To consolidate the material: the main formula for today </h1><br><p>  Although if you just take this formula without understanding the entire previous text, then I hate you.  So, if we want to build a central perspective with <b>(important!) A camera located on the <i>z</i> axis at a distance <i>c</i> from the origin</b> , we first immerse three-dimensional points in four-dimensional space, adding 1. Then multiply the following matrix and project the result back to 3D : <br></p><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/e61/567/ab8e61567f1a30f50b472b9da358964c.svg"><br><br><p>  We have deformed our object in such a way that now, to build a wire renderer with a perspective, we simply need to forget about the newly received z coordinate.  If we want to build a z-buffer, then, of course, we use it.  Snapshot code <a href="https://github.com/ssloy/tinyrenderer/tree/1cce85258d1f1cf75fd10fe4d62ebfdb669f8cf9">is available on github.</a>  The result of his work is visible at the very beginning of our article. <br></p></div><p>Source: <a href="https://habr.com/ru/post/248611/">https://habr.com/ru/post/248611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248599/index.html">"Durov, return the wall" or "Habrahabr + Geektimes + Megamind" in one tape</a></li>
<li><a href="../248601/index.html">Lovers of Ruby and Coffeescript - another bike?</a></li>
<li><a href="../248605/index.html">Piloting cloud-based MongoDB via VanillaJS or how to make a private todo list for 15 minutes for free</a></li>
<li><a href="../248607/index.html">Data-mining in 40 lines or with whom and against whom you are at the same time</a></li>
<li><a href="../248609/index.html">Announced Zend Framework 3 Roadmap</a></li>
<li><a href="../248613/index.html">We are speeding up the Yandex mobile browser for Android on WebKit</a></li>
<li><a href="../248615/index.html">How to write a quick scripting and database deployment system</a></li>
<li><a href="../248617/index.html">Server monitoring is now easier with WinLogViewer.com</a></li>
<li><a href="../248619/index.html">Usability - one Redmine plugin, providing a lot of useful things</a></li>
<li><a href="../248621/index.html">Again books at the free price on books.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>