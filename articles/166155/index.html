<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a cross-platform C ++ library to work with named pipes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 
 In the process of developing a single B2B project, it became necessary to access our application from various systems like 1C, Oracle, MS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a cross-platform C ++ library to work with named pipes</h1><div class="post__text post__text-html js-mediator-article"><h4>  Prehistory </h4><br>  In the process of developing a single B2B project, it became necessary to access our application from various systems like 1C, Oracle, MS Sql Server.  The first "universal" option that came to mind is to use web services.  But, unfortunately, the above-mentioned systems have a slightly different understanding of this standard (for example, not the fact that the same oracle and 1C will understand each other), besides, we did not want to inflate the project using heavy third-party libraries (at that time we used boost and Intel TBB, we still didn‚Äôt want to attract Qt or gSoap). <br>  Therefore, it was decided to write your bike. <br><a name="habracut"></a><br>  The aforementioned systems have a mechanism for extending the capabilities of internal languages ‚Äã‚Äãwith the help of dll-plug-ins, the so-called external components.  The idea of ‚Äã‚Äãusing them to communicate with the outside world is not new - there have already been articles on this topic on Habr√©: <br>  <a href="http://habrahabr.ru/post/149956/">habrahabr.ru/post/149956</a> <br>  <a href="http://habrahabr.ru/company/Centrobit/blog/165441/">habrahabr.ru/company/Centrobit/blog/165441</a> <br>  <a href="http://habrahabr.ru/post/163859/">habrahabr.ru/post/163859</a> <br>  So, we decided to use external components to solve the problem.  Then we had to decide in what way, moreover, preferably cross-platform (i.e., so that the component and the application could be assembled for different platforms by simple recompilation), we will associate the component with our application.  The easiest thing would be to not bother and find ready IPC solutions on this topic (QLocalSocket in Qt, Named Pipes in ACE), but again, for reasons of reducing the number of libraries used, it was decided to write my own small bicycle. <br>  The ideal solution would be boost :: interprocess :: message_queue, but it was not a simple queue, but a priority queue, which somewhat reduced performance (the desire for high performance was also one of the reasons why we abandoned web services).  In addition, we needed some kind of client-server solution. <br>  We refused from sockets through loopback right away - they have too much overhead in windows (see <a href="http://habrahabr.ru/post/81067/">habrahabr.ru/post/81067</a> ).  Therefore, we began to look towards the named pipes windows and domain sockets in unix. <br><br><h4>  Part 1. We make TZ </h4><br>  In fact, the meaning of our external components was only to receive some xml message from the system and send it to the channel (of course, the communication should be two-way, but we did not always implement the mechanism for sending messages to the system through the components).  Therefore, we decided that we would not dive into the wilds of asynchronous work with channels, and we would only have to implement the usual blocking read-write operations (and processing clients).  The requirements for read-write functions were as follows: <br><ul><li>  Functions must take two parameters. Void * pointer to the buffer to write to or read from and the size of the data to read / send. </li><li>  In case of any error (for example, the number of bytes received or sent is not equal to the parameter passed), the function should throw an exception std :: runtime_error (yes, exception handling slows down performance, you could use error codes) </li><li>  Within the framework of one class, both work with server channels (acceptance) and work with client channels is realized.  In the case of creating a server channel, read-write functions should not work, but should throw exceptions. </li></ul><br>  The last point requires an explanation - the server channel is only needed to perform a locking client wait method in a cycle, the return value of which is a channel object with a connected client (according to this ideology, the accept function for POSIX sockets works. In windows API, however, with channels on the contrary, in the case of blocking work, the waiting function simply stops the stream until a client appears at that end of the channel, then it needs to be processed, and for new clients to create a new listening channel, etc.) <br>  As a result, the following abstract INamedPipe class was composed from which the WinNamedPipe and POSIXNamedPipe classes are then inherited. <br><pre><code class="hljs rust">#pragma <span class="hljs-keyword"><span class="hljs-keyword">once</span></span> #include &lt;stdexcept&gt; class INamedPipe { protected: std::string _name; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> _server; INamedPipe(){}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void internalReadBytes(void* buf,size_t size)=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void internalWriteBytes(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> void* buf,size_t size)=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void internalFlush()=<span class="hljs-number"><span class="hljs-number">0</span></span>; public: INamedPipe(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string prefix, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; name, <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> server):_name(prefix),_server(server) { _name.append(name); } void ConnectOrOpen() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_server) open(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> connect(); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void ReadBytes(void* buf,size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!_server) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"Size is 0 or less"</span></span>); internalReadBytes(buf,size); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> throw std::runtime_error(<span class="hljs-string"><span class="hljs-string">"This operation is not supported on server pipe"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void WriteBytes(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> void* buf,size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!_server) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) throw std::out_of_range(<span class="hljs-string"><span class="hljs-string">"Size is 0 or less"</span></span>); internalWriteBytes(buf,size);</code> </pre> <br>  The INamedPipe constructor takes three parameters ‚Äî the path prefix where the channel will be located in the system, the name of the channel, and the parameter indicating the type of the channel ‚Äî client or server (it was decided to combine both types in the same class). <br>  The ConnectOrOpen () function calls the required method for opening a channel depending on its type (for the server, open (), for the client, connect ()). <br><br><h4>  Part 2. We write windows-implementation of WinNamedPipe </h4><br>  Before implementation, we decided to google examples.  First of all, tutorials from MSDN ( <a href="http://msdn.microsoft.com/ru-ru/library/windows/desktop/aa365592">msdn.microsoft.com/ru-ru/library/windows/desktop/aa365592</a> , <a href="http://msdn.microsoft.com/ru-ru/library/windows/desktop/aa365588">msdn.microsoft.com/ru-ru/library/windows/desktop/aa365588</a> ) and documentation in Russian - <a href="http://www.frolov-lib.ru/books/bsp/v27/ch2_3.htm">www. frolov-lib.ru/books/bsp/v27/ch2_3.htm</a> .  With the help of these articles, the first version of the WinNamedPipe class was written.  After some time, we found a good article on writing a class of working with named channels using the example of creating an external component for MetaTrader ( <a href="http://www.mql5.com/ru/articles/115">www.mql5.com/ru/articles/115</a> ), which we also recommend reading. <br>  In the WinNamedPipe constructor, a prefix is ‚Äã‚Äãalready set - according to MSDN requirements, the full path to the named pipe should look like "\\ computer_name \ pipe \ channel_name" and if it works with the named pipe on the local machine, it looks like \\. \ Pipe \ pipe_name (yes , named pipes in Windows allow you to share information over the network). <br>  The class also has a constructor that accepts a HANDLE type parameter as an input - a number that identifies some structure or object in the operating system (using this constructor, we can create a new instance of the WinNamedPipe class knowing only HANDLE of an already existing named pipe).  This constructor will be used in the WaitForConnection () function (see below) <br>  The open () implementation looks like this: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-type"><span class="hljs-type">WinNamedPipe</span></span>::open(){ _hPipe = <span class="hljs-type"><span class="hljs-type">CreateNamedPipe</span></span>( (<span class="hljs-type"><span class="hljs-type">LPSTR</span></span>)_name.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">(), //    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PIPE_ACCESS_DUPLEX</span></span></span><span class="hljs-class">, //       </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PIPE_TYPE_BYTE</span></span></span><span class="hljs-class"> | //  </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PIPE_WAIT</span></span></span><span class="hljs-class">, //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PIPE_UNLIMITED_INSTANCES</span></span></span><span class="hljs-class">, //     </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BUFFER_PIPE_SIZE</span></span></span><span class="hljs-class">, //     </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BUFFER_PIPE_SIZE</span></span></span><span class="hljs-class">, //     0, // -  (0=) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NULL</span></span></span><span class="hljs-class">); //     ‚Äì    if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_hPipe</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">INVALID_HANDLE_VALUE</span></span></span><span class="hljs-class">) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">THROW_LAST_ERROR</span></span></span><span class="hljs-class">("</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateNamedPipe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">failed</span></span></span><span class="hljs-class">"); }</span></span></code> </pre><br>  Note that the buffer size BUFFER_PIPE_SIZE we set at the very beginning of the file.  In fact, its size does not affect the maximum size of the transmitted data - in our project we successfully transferred pieces that were several times larger than the buffer. <br>  Special attention should be paid to the first parameter: (LPSTR) _name.data () <br>  Since the name of the channel in our class is stored in std :: string, for its correct transfer to WinAPI, the functions must be set in the project properties in Visual Studio ‚ÄúUse Multi-Byte character Set‚Äù (for more details see article <a href="http://habrahabr.ru/post/164193/">habrahabr.ru/post/164193</a> ) . <br>  A detailed description of the parameters of the CreateNamedPipe function can be found in MSDN ( <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365150">msdn.microsoft.com/en-us/library/windows/desktop/aa365150</a> and at <a href="http://www.frolov-lib.ru/books/bsp/v27/ch2_3.htm">www.frolov-lib.ru/books/bsp/v27/ch2_3.htm</a> ). <br>  Client connection to the channel is performed using the connect () function, which has the following implementation: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> WinNamedPipe::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { WaitNamedPipe((LPSTR)_name.data(), NMPWAIT_WAIT_FOREVER); _hPipe = CreateFile( (LPSTR)_name.data(), //   GENERIC_READ | //      GENERIC_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, //      OPEN_EXISTING, //    <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); // Break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the pipe handle <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> error!=<span class="hljs-number"><span class="hljs-number">232</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hPipe != INVALID_HANDLE_VALUE||GetLastError() != ERROR_PIPE_BUSY) break; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hPipe == INVALID_HANDLE_VALUE) THROW_LAST_ERROR("Could not open pipe"); DWORD dwMode = PIPE_TYPE_BYTE; <span class="hljs-type"><span class="hljs-type">BOOL</span></span> fSuccess = SetNamedPipeHandleState( _hPipe, //     &amp;dwMode, //  - <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, //       <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! fSuccess) { THROW_LAST_ERROR("SetNamedPipeHandleState failed"); } }</code> </pre><br>  First, with the help of the WaitNamedPipe function, we get up to the ‚Äúeternal‚Äù waiting for a free instance of the server channel, then with the help of CreateFile we connect to it.  After that, we check if the connection is successful.  If the pointer to the channel object is valid (or an error other than ERROR_PIPE_BUSY has occurred - an error indicating that there is no free channel), we exit the loop and set up the channel operation mode we need.  Otherwise, the cycle repeats until it connects normally, or an error other than ERROR_PIPE_BUSY occurs.  If the server named pipe with the given name does not exist, then WaitNamedPipe will end immediately, GetLastError will return error code 2 (The system cannot find the file specified) and connect () will throw an exception. <br>  According to our idea, WaitForConnection () should return a pointer to the new WinNamedPipe, to which the client is already connected and to which you can use the read-write functions.  However, in Windows, the standard client acceptance mechanism is different ‚Äî the ConnectNamedPipe function (which receives the created channel as an input) simply blocks the stream until a client appears at the other end of the channel.  Then, in order not to lose other clients, you need to create a new listening channel and transfer it to this function, etc.  Therefore, to implement our ideas, we have to call open () again from WaitForConnection. <br>  The WaitForConnection () function looks like this: <br><pre> <code class="hljs php">WinNamedPipe* WinNamedPipe::WaitForConnection() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_server) { DWORD error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ConnectNamedPipe(_hPipe, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)||(error=GetLastError())==ERROR_PIPE_CONNECTED) { HANDLE client=_hPipe; open(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WinNamedPipe(client); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"WaitForConnection failed"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"WaitForConnection is not supported on server pipe\n"</span></span>); } }</code> </pre> <br>  We note an important point - if there are a lot of client channels created, it is possible that the client will connect to the channel even before the call to ConnectNamedPipe.  In this case, GetLastError will return error code 535 (but this will not be an error) <br>  The read and write functions are both simple and straightforward without additional comments: <br><pre> <code class="hljs ruby">void WinNamedPipe::internalReadBytes(void* buf,size_t size) { DWORD cbBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; BOOL fSuccess = FALSE; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     fSuccess = ReadFile( _hPipe, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    buf, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -   size, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   &amp;cbBytesRead, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,       NULL); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fSuccess <span class="hljs-params"><span class="hljs-params">||</span></span> cbBytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span>cbBytesRead!=size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetLastError() == ERROR_BROKEN_PIPE) { THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"pipe disconnected"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"read failed"</span></span>); } } } void WinNamedPipe::internalWriteBytes(const void* buf,size_t size) { DWORD cbWritten; BOOL fSuccess = FALSE; fSuccess = WriteFile( _hPipe, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    buf, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        size, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     &amp;cbWritten, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         NULL); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fSuccess <span class="hljs-params"><span class="hljs-params">||</span></span> size != cbWritten) { THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"WriteFile failed"</span></span>); } }</code> </pre><br>  The function Close () should dwell in more detail.  To close the server channel and inform the client at the other end of it, use the DisconnectNamedPipe (HANDLE pipe).  After that, it can again expect new customers, and you can tell the operating system that it is not needed using the CloseHandle (HANDLE pipe).  CloseHandle can also be called on client channels, but this method should only be called once ‚Äî either on the server pipe with the client connected, or on the client.  Therefore, it was decided that we would call DisconnectNamedPipe and CloseHandle only on server instances of the channels, and on the client‚Äôs Close, it would be a dummy method. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> WinNamedPipe::<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_server||_server_with_client) { DisconnectNamedPipe(_hPipe); CloseHandle(_hPipe); //May throw an <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a debugger <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> attached <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the process <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> handle <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> } }</code> </pre><br>  You should also remember that when sending or receiving large amounts of data, the client must notify the opposite party that all data has been read, and the server should not close the channel before receiving this notification. <br>  To reduce copy-paste, a macro was created that gets GetLastError and throws exceptions: <br><pre> <code class="hljs vbscript">#define THROW_LAST_ERROR(e){ \ <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>=GetLastError(); \ std::stringstream <span class="hljs-built_in"><span class="hljs-built_in">err</span></span>; \ <span class="hljs-built_in"><span class="hljs-built_in">err</span></span>&lt;&lt;e&lt;&lt;<span class="hljs-string"><span class="hljs-string">", GLE="</span></span>&lt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>; \ throw std::runtime_error(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>.str().data()); \ }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Part 3. We write unix-implementation - PosixNamedPipe </h4><br>  To implement the posix-compatible part of the library, we decided to use Unix domain sockets (for more information about working with sockets in unix, read here - <a href="http://wiki.linuxformat.ru/index.php/LXF83">wiki.linuxformat.ru/index.php/LXF83</a> : Unix_API). <br>  Unlike windows, a pointer file to a local socket can be located anywhere in the file system.  We decided to pass the path / tmp / as a prefix.  It should be noted that if you pass an empty string as a prefix, the client will not be able to connect to the socket and will return a file not found error.  In addition, if a file with the name of a local socket exists before the function that creates a local socket, then no client can connect to the server (Connection refused error).  Therefore, before creating a socket, you should check the presence of this file and try to delete it.  Hence the idea of ‚Äã‚Äãa fixed prefix of the path arose - it is necessary to somehow eliminate the potential vulnerability, which makes it possible to wipe the file anywhere in the system (and here it would be nice to recall the access rights and use of the basename function).  It also follows from the fact that there are no more than one server copies of the PosixNamedPipe class with the same name ‚Äî only one instance of the class must correspond to each name to work correctly. <br>  The open () function code looks like this: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> PosixNamedPipe::<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>() { sock= socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sock == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR("Create_socket failed: "); } unlink(_name.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>.sun_family = AF_UNIX; strcpy(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>.sun_path, _name.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bind(sock, (sockaddr*)&amp;<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, sizeof(struct sockaddr_un)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR("Connection failed(bind): "); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(sock,SOMAXCONN) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR("Connection failed(listen): "); } }</code> </pre><br>  The connect () function is almost identical: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> PosixNamedPipe::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>() { sock= socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sock == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR("Create_socket failed: "); } <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>.sun_family = AF_UNIX; strcpy(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>.sun_path, _name.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(sock, (sockaddr*)&amp;<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, sizeof(struct sockaddr_un)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR("Connection failed(connect): "); } }</code> </pre><br>  In order to write WaitForConnection () according to our TK, unlike the windows version of the code, it did not even have to be perverted. <br><pre> <code class="hljs axapta">PosixNamedPipe* PosixNamedPipe::WaitForConnection() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>=accept(sock,NULL,NULL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>!=<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PosixNamedPipe(<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW_ERROR(<span class="hljs-string"><span class="hljs-string">"Accept error: "</span></span>); } }</code> </pre><br>  The constructor called in it is also trivial: <br><pre> <code class="hljs cpp">PosixNamedPipe::PosixNamedPipe(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pipe) { sock=pipe; _server=<span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;desc, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct sockaddr_un)); }</code> </pre><br>  Here it should be noted that for the bind and :: connect functions to work correctly, it is recommended to reset an instance of the sockaddr_un structure before initializing its fields, and therefore a line memset (&amp; desc, 0, sizeof (struct sockaddr_un)) was added to the class constructors. <br>  The read-write functions for sockets are also quite simple: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PosixNamedPipe::internalReadBytes(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buf,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((recv(sock, buf, size, MSG_WAITALL)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { THROW_ERROR(<span class="hljs-string"><span class="hljs-string">"Error while reading: "</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PosixNamedPipe::internalWriteBytes(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buf,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ret = send(sock, buf, size, <span class="hljs-number"><span class="hljs-number">0</span></span>)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>||ret!=size) { THROW_ERROR(<span class="hljs-string"><span class="hljs-string">"Error while sending: "</span></span>); } }</code> </pre><br>  In the channel closing function, just in case, the file is deleted when the server instance of the class is closed (and the call to the closing function is also automatically performed in the destructor): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> PosixNamedPipe::<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_server) unlink(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>.sun_path); <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(sock); } PosixNamedPipe::~PosixNamedPipe() { this-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>(); }</code> </pre><br><br><h4>  Part 4. We write a multi-threaded server for processing clients </h4><br>  So, classes for working with named pipes are created.  Now we will do a little trick not to write #ifdef _WIN32 and similar things when creating instances of these classes in our applications: <br><pre> <code class="hljs smalltalk">//<span class="hljs-type"><span class="hljs-type">NamedPipe</span></span>.h <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> once <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> _WIN32 <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"WinNamedPipe.h"</span></span> typedef <span class="hljs-type"><span class="hljs-type">WinNamedPipe</span></span> <span class="hljs-type"><span class="hljs-type">NamedPipe</span></span>; <span class="hljs-symbol"><span class="hljs-symbol">#else</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;unistd.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"PosixNamedPipe.h"</span></span> typedef <span class="hljs-type"><span class="hljs-type">PosixNamedPipe</span></span> <span class="hljs-type"><span class="hljs-type">NamedPipe</span></span>; <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre><br>  Now in any project we do #include "NamedPipe.h" and we can write code of the form NamedPipe * client = new NamedPipe ("NamedPipe.h", 0) without worrying about which operating system our application will be built for. <br>  For processing incoming requests from external components in our project a simple multithreaded class server based on the thread pool pattern was written using the boost :: thread and Intel TBB libraries.  The main idea was this - in one thread in an infinite loop, the call is called WaitForConnection (), and the pointers to Named objects with connected clients are added to the tbb :: concurrent_queue queue, from where they are taken by the threads that are directly occupied by reading-writing and processing incoming messages. <br>  The code of the function involved in receiving incoming connections is as follows: <br><pre> <code class="hljs php">void NamedPipeServer::run() { NamedPipe* client; _pipe=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipe(_name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { _pipe-&gt;ConnectOrOpen(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::exception&amp; e) { } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(_active) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { client=_pipe-&gt;WaitForConnection(); _clients.push(client); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::exception&amp; e) { } } delete _pipe; }</code> </pre><br>  Note that in place of the empty brackets after the catch, we had a call for logging macros, but in the code rewritten for this article, these calls were removed so as not to overload our library with dependencies. <br>  In our plan, work with clients should be described in the handleClient (NamedPipe * client) function, which is virtual in the server class and should be redefined in the derived class. <br>  In each thread handler, the following cycle is spinning: <br><pre> <code class="hljs ruby">void NamedPipeServer::workerProc() { NamedPipe* client; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(_active) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_clients.try_pop(client)) { handleClient(client); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> boost::this_thread::sleep(boost::posix_time::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); }</code> </pre><br>  In the loop, the thread tries to get the client out of the queue and, if successful, calls the handleClient, otherwise it falls asleep for a while in order to avoid idle CPU usage. <br>  To start all threads, the Start () method is called, which calls the startWorkers () method, which creates threads: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NamedPipeServer::Start() { _active=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; startWorkers(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NamedPipeServer::startWorkers() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _thread_pool_size; ++i) { boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;boost::thread&gt; thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> boost::thread(boost::bind(&amp;NamedPipeServer::workerProc, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>))); _threads.push_back(thread); } boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;boost::thread&gt; dispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> boost::thread(boost::bind(&amp;NamedPipeServer::run,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>))); _threads.push_back(dispatcher); }</code> </pre><br>  Note that the Start () method does not block the thread of execution.  To block it until the end of all server threads, use the JoinWorkers method: <br><pre> <code class="hljs matlab">void NamedPipeServer::JoinWorkers() { size_t <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=_threads.<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::size_t <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) _threads[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]-&gt;join(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::size_t <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) _threads[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>].reset(); _threads.clear(); }</code> </pre> <br>  In practice, in our application it is considered that the running servers work until the application closes.  This saved us the trouble of trying to stop the named pipes server threads. <br>  In order to try to stop the server streams, you can write, for example, such Stop () method: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NamedPipeServer::Stop() { _active=<span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;JoinWorkers(); }</code> </pre><br>  However, when calling this method, the thread will ‚Äúget up‚Äù.  The reason for this is the fact that one of the threads is blocked by the WaitForConnection () function. <br>  And the output is possible only after the next client joins us (respectively, after such a connection the client breaks off). <br>  The simplest (but not the best) solution to a possible blocking problem is to create a client named pipe in the Stop function and connect to our server, thereby resetting the WaitForConnection flow lock. <br>  To solve this problem more correctly, we need to change the behavior of the WaitForConnection () function by adding a timeout to it. <br>  The new feature for the Windows version looks like this: <br><pre> <code class="hljs cpp">WinNamedPipe* WinNamedPipe::WaitForConnection(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeout) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_server) { OVERLAPPED lpOverlapped = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; lpOverlapped.hEvent = CreateEvent(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ConnectNamedPipe(_hPipe, &amp;lpOverlapped)==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetLastError()==ERROR_PIPE_CONNECTED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetEvent(lpOverlapped.hEvent)) THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"AsyncWaitForConnection failed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = WaitForSingleObject(lpOverlapped.hEvent,timeout); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WAIT_OBJECT_0 == result) { HANDLE client=_hPipe; open(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WinNamedPipe(client); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW_LAST_ERROR(<span class="hljs-string"><span class="hljs-string">"AsyncWaitForConnection failed"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"WaitForConnection is not supported on client pipe\n"</span></span>); } }</code> </pre> <br>  In order for this method to work correctly, you need to change the call to the CreateNamedPipe function in open () as follows: <br><pre> <code class="hljs lisp">_hPipe = CreateNamedPipe( (<span class="hljs-name"><span class="hljs-name">LPSTR</span></span>)_name.data(), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, //        PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_PIPE_SIZE, BUFFER_PIPE_SIZE, <span class="hljs-number"><span class="hljs-number">0</span></span>, NULL)<span class="hljs-comment"><span class="hljs-comment">; // default security attribute</span></span></code> </pre><br>  The implementation for linux looks like this: <br><pre> <code class="hljs cpp">PosixNamedPipe* PosixNamedPipe::WaitForConnection(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeout) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nsock; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retour; fd_set readf; fd_set writef; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">;</span></span> FD_ZERO(&amp;readf); FD_ZERO(&amp;writef); FD_SET(sock, &amp;readf); FD_SET(sock, &amp;writef); to.tv_usec = timeout*<span class="hljs-number"><span class="hljs-number">1000</span></span>; retour = select(sock+<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readf, &amp;writef, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retour == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (FD_ISSET(sock, &amp;readf)) || (FD_ISSET(sock,&amp;writef))) { nsock = accept(sock, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PosixNamedPipe(nsock); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"invalid socket descriptor!\n"</span></span>); } }</code> </pre> <br>  In conclusion, we note that the destructor of the server class for correct operation must call the Stop () method and then clear the entire _clients queue if there are any raw clients there.  Since the client queue in the server consists of pointers, it must also be manually cleared: <br><pre> <code class="hljs cpp">NamedPipeServer::~NamedPipeServer(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Stop(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!_clients.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_clients.try_pop(_pipe)) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> _pipe; } }</code> </pre><br><h4>  Part 5. An example of using the library. </h4><br>  To test the library was written spamming, in an infinite loop creating two threads that are trying to connect to the server and send him 10 lines.  After completion of threads, the cycle repeats. <br>  Each stream looks like this: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spamming_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; words; words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"one "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"two "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"three "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"four "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"five "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"six "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"seven "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"eight "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"nine "</span></span>)); words.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"ten "</span></span>)); <span class="hljs-function"><span class="hljs-function">NamedPipe </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"NamedPipeTester"</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { client.ConnectOrOpen(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;words.size();++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"sending "</span></span>&lt;&lt;words[i]&lt;&lt;<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size=words[i].size(); client.WriteBytes(&amp;size,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(size)); client.WriteBytes(words[i].data(),size); } client.Close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Exception: "</span></span>&lt;&lt;e.what()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } }</code> </pre> <br>  Now we will write a server that accepts connections: <br><pre> <code class="hljs rust">#pragma <span class="hljs-keyword"><span class="hljs-keyword">once</span></span> #include <span class="hljs-string"><span class="hljs-string">"../NamedPipeServer.h"</span></span> class SimpleServer: public NamedPipeServer { protected: void handleClient(NamedPipe* client); public: SimpleServer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string &amp;name):NamedPipeServer(name,<span class="hljs-number"><span class="hljs-number">1</span></span>){}; ~SimpleServer(){}; }; void SimpleServer::handleClient(NamedPipe* client) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>;++i) { try { size_t size; client-&gt;ReadBytes(&amp;size,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(size)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* message=new <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>[size]; client-&gt;ReadBytes(message,size); <span class="hljs-comment"><span class="hljs-comment">//Using std::cout is bad in multi-threading apps //std::string msg(message,size); //std::cout&lt;&lt;"Message from pipe: "&lt;&lt;msg&lt;&lt;"\n"; delete[] message; } } catch(const std::exception&amp; e) { std::cout&lt;&lt;"Exception!:"&lt;&lt;e.what()&lt;&lt;"\n"; } } client-&gt;Close(); }</span></span></code> </pre> <br>  Run it, wait half a minute and try to stop: <br><pre> <code class="hljs php"> SimpleServer* s=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleServer(<span class="hljs-string"><span class="hljs-string">"NamedPipeTester"</span></span>); s-&gt;Start(); boost::this_thread::sleep(boost::posix_time::milliseconds(<span class="hljs-number"><span class="hljs-number">30000</span></span>)); delete s; system(<span class="hljs-string"><span class="hljs-string">"pause"</span></span>);</code> </pre> <br><h4>  Conclusion </h4><br>  This library has been successfully used for six months in our project.  For habr the library code has been corrected and supplemented.  However, since the article was written by a novice programmer, errors are possible in the code.  The author will be grateful for constructive criticism, comments and suggestions for improvement and for errors found. <br>  This article does not claim to be complete.  It does not consider such things as non-blocking reading and writing, setting permissions for named pipes, and an alternative to byte read / write mode ‚Äî messaging mode. <br>  All the source code for the article can be found at <a href="https://github.com/xpavlov/libNamedPipe">github.com/xpavlov/libNamedPipe</a> </div><p>Source: <a href="https://habr.com/ru/post/166155/">https://habr.com/ru/post/166155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166139/index.html">Boost.Asio Pinger and Unit Testing</a></li>
<li><a href="../166141/index.html">Smart stops or the capital of the 21st century</a></li>
<li><a href="../166145/index.html">Scala WAT: Processing Optional Values</a></li>
<li><a href="../166149/index.html">Prototype image processing software</a></li>
<li><a href="../166153/index.html">Review of the DVR Highscreen Black Box Full HD</a></li>
<li><a href="../166157/index.html">nanoCAD 4.5: raster editing</a></li>
<li><a href="../166161/index.html">Seventh Kiev Habravstrecha</a></li>
<li><a href="../166163/index.html">Cosmos: what to expect in 2013. Private traders</a></li>
<li><a href="../166171/index.html">Ganglia and Nagios. Complementary Remote Monitoring</a></li>
<li><a href="../166179/index.html">Meet the long-awaited plugins.jquery.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>