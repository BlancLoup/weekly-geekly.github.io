<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúJava-developers do not realize the problem with profilers‚Äù: Andrey Pangin and Nitsan Vakart about Java profiling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is easy to think that you should not expect big news from profiling: since developers have been profiling for decades, how could you not even figur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúJava-developers do not realize the problem with profilers‚Äù: Andrey Pangin and Nitsan Vakart about Java profiling</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/104/a16/0a5/104a160a58ac416d8502b4ffc936c648.jpg"><br><br>  It is easy to think that you should not expect big news from profiling: since developers have been profiling for decades, how could you not even figure it out?  But in Java profiling, serious pitfalls lie like safepoint bias, and new tools are emerging to solve such problems. <br><br>  <b>Andrey <a href="https://habrahabr.ru/users/apangin/" class="user_link">apangin</a> Pangin</b> (Odnoklassniki) recently created one of these tools: at the JPoint conference in April, he presented an open source project <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> , to which safepoint bias is not terrible.  Another expert in this topic is <b>Nitsan Waqard</b> : many people learned about the same problem with safepoints thanks to his <a href="http://psy-lob-saw.blogspot.ru/2016/02/why-most-sampling-java-profilers-are.html">blog post</a> ‚ÄúWhy (Most) Sampling Java Profilers Are Fucking Terrible‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We decided to talk to both of them at once, starting a conversation with the latest news about the async-profiler, and later moving on to the state of Java profiling in general. <br><a name="habracut"></a><br>  <b>JUG.ru: Recently, the async-profiler was moved to GitHub from Andrew‚Äôs personal repository to <a href="https://github.com/jvm-profiling-tools/">‚Äújvm-profiling-tools‚Äù</a> - what is jvm-profiling-tools, and what caused the displacement?</b> <br><br>  <b>Nitsan:</b> This is a combination of several repositories with similar goals.  The idea is to gather them in one place and stimulate the community to develop them more actively. <br><br>  <b>Andrei:</b> Exactly.  When it became clear that the async-profiler is interesting to the Java community, I decided to move it to a neutral place, because third-party developers are sometimes uncomfortable contributing to someone else's personal repository. <br><br>  <b>Nitsan:</b> The jvm-profiling-tools have <a href="https://github.com/jvm-profiling-tools/honest-profiler">Honest Profiler</a> , async-profiler and <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a> , and they fit the same topic from different sides: perf-map-agent opens up opportunities for profiling using Linux perf, Honest Profiler uses AsyncGetCallTrace that avoids safepoint bias, and async-profiler combines both in a very pleasant way. <br><br>  <b>Andrei:</b> Yes.  In fact, there is nothing cosmic in the idea of ‚Äã‚Äãcombining both approaches, but for some reason this had never occurred to anyone before. <br><br>  <b>Nitsan:</b> In general, it was in Solaris Studio, but the problem with Solaris Studio is that it is used by 20 people in the world. <br><br>  <b>Andrei:</b> But, as far as I know, it does not show kernel calls, right? <br><br>  <b>Nitsan:</b> Shows native code, but not the kernel. <br><br>  <b>JUG.ru: Since Honest Profiler and async-profiler have a common advantage of ‚Äúlack of safepoint bias‚Äù, now when looking at jvm-profiling-tools for newcomers to profiling, the question may appear: ‚ÄúWell, which of two similar tools can I use?‚Äù What can you tell them?</b> <br><br>  <b>Andrew:</b> I think that in terms of the accuracy of the profiling and the completeness of the information, async-profiler is far ahead.  After all, even AsyncGetCallTrace itself in HotSpot does not always work: in some borderline cases, the JVM cannot restore the stack trace, although the async-profiler can cope with such situations.  In addition, Honest Profiler does not show native stack traces at all.  But its great advantage is in the infrastructure around data presentation.  He knows how to display the results beautifully, he has a UI, and the async-profiler is just a Java agent launched from the console. <br><br>  <b>Nitsan:</b> I think the future is for async-profiler.  And I would like some Honest Profiler features to fall into the async-profiler.  There is another difference in the fact that Honest Profiler works on macOS, and the async-profiler is not there yet: supporting a large hipster community in our industry is important. <br><br><img src="https://habrastorage.org/web/d7f/dd9/3bf/d7fdd93bf591437aa2f30fb30edd029f.jpg"><br><br>  <b>JUG.ru: It seems that Vadim Tsesko of Odnoklassniki has already made it possible to work async-profiler on macOS?</b> <br><br>  <b>Andrei:</b> That was before I added support for perf events.  Linux-specific challenge broke macOS support.  But there is some good news: literally the other day I talked to Norman Maurer from Apple (the author of Netty), he is also interested in the async-profiler, and he kindly agreed to make a Mac port. <br><br>  <b>JUG.ru: In July, a hip profiler appeared in the async-profiler - can you tell about it?</b> <br><br>  <b>Andrew:</b> There are two main approaches to memory profiling in Java.  The first is the bytecode instrumentation.  But for production systems, it is terrible, because it affects the performance badly.  A number of compiler optimizations stop working: first of all, Escape Analysis no longer helps to avoid allocations in the heap. <br><br>  Another approach is to use DTrace probes, which is also extremely expensive, and can only be enabled at the start of the JVM. <br><br>  But that's not all.  There is still a much more efficient approach based on sampling TLAB (Thread Local Allocation Buffer).  It is implemented in the Java Mission Control / Java Flight Recorder, but requires the inclusion of the commercial functions of the Oracle JDK, and does not work with OpenJDK at all.  <a href="https://www.youtube.com/watch%3Fv%3DUykhZ36W04I">A similar method is</a> used inside Google, but it requires building a modified version of the JVM. <br><br>  I found a way to use this approach without connecting paid functions, including OpenJDK.  Now I will not dive into the details, but I will definitely tell you in a separate report. <br><br>  <b>Nitsan:</b> I think this is important.  Since Java Mission Control is now perhaps the only tool for profiling allocations, and working with similar processes in JMC is implemented in a very peculiar way, many people simply do not do such profiling.  I hope that this will help allocate profiling to become mainstream. <br><br>  <b>JUG.ru: It may seem strange that significant advances in profiling occur in 2017, when they would have been useful years ago.</b>  <b>What is the reason for this delay?</b> <br><br>  <b>Andrew:</b> Java is the root of all evil :) It makes life both better and worse.  On the one hand, because of the peculiarities of the JVM, standard approaches become inapplicable, but on the other hand, the JVM provides its own API for profiling. <br><br>  <b>Nitsan:</b> I think the Java world is similar to Windows.  Windows was a terrible OS (probably much better now), but, suffering from many flaws, it was also a great success.  Same story with java.  In the case of profiling tools, Java turned out badly.  I'm not quite sure why this is so. <br><br>  I think that JVM developers traditionally used Solaris Studio, so everything worked more or less normally, but only for them.  Specialists used specialized tools.  And most Java developers were pleased with what they had. <br><br>  But now Java had to face reality.  Native profiling, which worked in Solaris Studio, but then it was a niche solution, is becoming increasingly popular. <br><br>  <b>Andrey:</b> I consider it necessary to add that Java is not equal to HotSpot, and other JVMs can be more friendly to profilers. <br><br>  <b>Nitsan:</b> Maybe I missed something, but what kind of JVM are we talking about?  I know a lot about Zing, and I have some experience with IBM J9 ... <br><br>  <b>Andrei:</b> Now I have an Excelsior JET T-shirt, and therefore I remembered about this project.  He can precompile Java into native code, and as far as I know, safepoint bias does not suffer. <br><br>  <b>Nitsan:</b> Ah, ok.  Never used it.  I believe that in this case, you can immediately take the native profiler. <br><br><img src="https://habrastorage.org/web/f3a/f0e/6bf/f3af0e6bf9004c29af0b8221ea4a083d.jpg"><br><br>  <b>JUG.ru: AsyncGetCallTrace, which is used by async-profiler and Honest Profiler, is not an official API.</b>  <b>Is its use felt hack?</b>  <b>Do you worry that in the future it may cease to function?</b>  <b>Would more formal Oracle support for profiling help?</b> <br><br>  <b>Nitsan:</b> AsyncGetCallTrace has been running since the launch of OpenJDK 6, so it looks like it has always been and will work.  This is an "illegitimate child", but I do not think that they can take it and throw it away.  When something becomes an option to the JVM, it gets official support in some way.  So I think we should not worry too much about it.  Although I‚Äôm wondering how well AsyncGetCallTrace gets along with the new Graal compiler. <br><br>  Of course, more official support would help.  At the moment, Oracle provides JMC as a paid option, and the rest of the Java world is left with something like VisualVM.  Now in this money.  I think that Oracle is experiencing a conflict of interest: Java interests, on the one hand, and their own interests, on the other.  We can say that for them to contribute to the improvement of other JVM-profilers would mean worsening their own situation. <br><br>  I do not claim that they are actively experiencing because of this.  I have no idea what they want now.  Perhaps they will make things like JMC available to everyone.  Now that the work on Jigsaw is complete, they have plenty of time for another. <br><br>  <b>Andrei:</b> I agree that AsyncGetCallTrace is partly a ‚Äúhacker‚Äù API.  Besides, far from perfect: I myself <a href="https://bugs.openjdk.java.net/browse/JDK-8178287">reported</a> bugs.  But so far this is the best that is in the HotSpot JVM. <br><br>  <b>JUG.ru: Can there be something else besides the already existing things like AsyncGetCallTrace that will make life easier for profile creators?</b> <br><br>  <b>Andrei:</b> Yes.  Allocation profiling was recently discussed on the HotSpot mailing lists.  As a result, there was even a <a href="http://openjdk.java.net/jeps/8171119">JEP project</a> , which offers a new standardized API for hip sampling.  I think that raising such topics on the mailing lists and offering JEP is the right way.  So maybe someday in Java 11 ... <br><br>  <b>JUG.ru: What do you think about the future of Java profiling regardless of the actions of Oracle?</b>  <b>Profilers will be much better than now?</b> <br><br>  <b>Andrei:</b> I hope so.  In my reports, I try to convey to the developers the idea that the profilers they use now have big pitfalls.  It is necessary either to stop using them, or how to understand their shortcomings and traps.  And I think when more people realize the scale of the problem, the developers of these tools will begin to improve them. <br><br>  <b>Nitsan: Some</b> issues have <b>room</b> to grow.  With perf-map-agent, we gained the ability to track inline scaling when profiling, but going to async-profiler, we lose it again.  I would really like to see her embodied again. <br><br>  Another area is visualization.  If you use async-profiler when working with multi-threaded applications, where one thread uses 100% of the CPU, and all the rest just hang on waiting, you can get a confusing picture when profiling.  I am interested in data presentation problems, and I am sure that there are many similar problems. <br><br>  <b>Andrei:</b> Yes.  Today, FlameGraph is very popular as a visualization, but I would say that it is far from perfect. <br><br>  <b>JUG.ru: You both said (in reports and blog posts) that profilers can create a distorted picture.</b>  <b>Do you think that the industry is seriously harmed by the use of this distorted picture by people?</b>  <b>Could it be that the industry from profilers then generally do more harm than good?</b> <br><br>  <b>Nitsan:</b> Yes, I think it hurts the industry.  If you look at the Java performance discussion on the Internet, you‚Äôll see that it‚Äôs full of bulshit.  And the reason why there is so much of it is that the information is difficult to verify. <br><br>  Some people told me that the problem never happens in a HashMap.  And the reason why they never thought that a HashMap could be a problem is that the regular profiler will never show it to them.  I am not saying that it is specifically in their case that the problem is in him, but be that as it may, they will never know about it.  And when they look at the CPU time usage chart, they cannot see the time spent on the GC.  That is, if the GC turned out to be their ‚Äúbottleneck‚Äù, they will not be able to track it. <br><br>  <b>Andrei:</b> I agree with Nitsan, but I would add that it is better to have at least a bad tool than not to have any.  The main problem is not when the profiler instills, but when it is not used at all.  Many developers do not profile at all, although often the problem of performance lies in inefficient algorithms, and any sampling profiler will easily identify it. <br><br>  <b>Nitsan:</b> I agree that many people do not profile, and this is a problem.  But if your only tool is a bad profiler ... You look at him, see that he gives out some nonsense, and tell the others: ‚ÄúWe‚Äôd rather just put time marks‚Äù, this is how you get a conclusion, and it‚Äôs easy to understand how discourages people from using profilers. <br><br>  <b>JUG.ru: So, in order to improve the situation with Java profiling, we all need to work not only on improving the tools, but also on the community knowledge about them?</b> <br><br>  <b>Nitsan:</b> Yes.  I think the massive success story in the Java world is JMH, Java Microbenchmarking Harness.  And the reason is that this decision was very successful not only from a technological point of view, but also in the aspect of educating users, enabling them to become better acquainted with this area. <br><br>  I think that Andrei creates tools and tells people is very important. <br><br>  <b>Andrew:</b> Even the most powerful tools will be useless if you do not know how to use them.  With the same JMH: I have seen many times how people wrote nonsense in JMH, and then they made completely wrong conclusions.  Training is an integral part of success. <br><br>  <b>JUG.ru: Both of you are going to help this training with your reports at the nearest Joker, and both of you are going to present there new versions of reports previously presented at other conferences.</b>  <b>What will be the novelty?</b> <br><br>  <b>Nitsan:</b> After I <a href="https://www.infoq.com/presentations/profilers-hotspots-bottlenecks">presented</a> the ‚ÄúProfilers are lying hobbitses‚Äù report at QCon, I thought that the best thing about him was the name.  Therefore, I decided to keep the title, but the report itself will be very different.  We will again talk about profilers and how they can mislead us, but I think I will start with the darkest, and then I will show you how to get out.  In the past, the report was a series of surprises that led to the conclusion that ‚Äúnothing works‚Äù.  This time it will be like this: ‚Äúnothing works, but let's see how we deal with it.‚Äù <br><br>  <b>Andrei:</b> Initially, I planned to show the continuation of the async-profiler story launched at JPoint 2017. However, later the Program Committee and I found a great deal of similarity to my report with the Nitsan report, so I decided to take a new topic.  So far, I am not ready to say what exactly this will be, but in the near future <a href="https://jokerconf.com/">in the Joker 2017 program</a> you can see my new report!  So stay tuned. <br><br><hr><br>  The <b>Joker</b> java conference, where Nitsan and Andrei will speak, will be held in St. Petersburg on November 3-4.  As usual, after the reports Joker speakers find themselves in discussion zones, so that there it will be possible to ask them about profiling in person.  And besides Andrey and Nitsan, there will be dozens of other speakers there - on <a href="https://jokerconf.com/">the conference website</a> you can see the program (and purchase a ticket). </div><p>Source: <a href="https://habr.com/ru/post/335852/">https://habr.com/ru/post/335852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335842/index.html">Everything is relative, or the implementation of one simple task in python and tcl</a></li>
<li><a href="../335844/index.html">Automate workflow with the new platform. Part 1. Office. Work with "Incoming Documents"</a></li>
<li><a href="../335846/index.html">Logs as part of the product. How GrayLog Impacted Quality</a></li>
<li><a href="../335848/index.html">MIPSfpga - practical experience</a></li>
<li><a href="../335850/index.html">Taxes on IT-business in Russia</a></li>
<li><a href="../335854/index.html">The history of the development of machine learning in the LC</a></li>
<li><a href="../335856/index.html">EntityFramework: (anti) Repository pattern</a></li>
<li><a href="../335858/index.html">Why not rely on user error reports</a></li>
<li><a href="../335866/index.html">Memoization and Currying (Python)</a></li>
<li><a href="../335868/index.html">Redux store: horizontal expansion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>