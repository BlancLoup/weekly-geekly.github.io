<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Animated Lines in iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, iOS-developers and their sympathizers! I want to share with you one simple, but at the same time quite nice animation for text fields and ot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Animated Lines in iOS</h1><div class="post__text post__text-html js-mediator-article">  Good day, iOS-developers and their sympathizers!  I want to share with you one simple, but at the same time quite nice animation for text fields and other views on iOS.  I think everyone who has even had a glimpse of CALayer and Core Animation in general knows about these possibilities, but for beginners it can be interesting and push Corex to explore more deeply. <br><a name="habracut"></a><br>  The picture for the seed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/efd/89e/a17/efd89ea17eac4e948f98f827eb2cc1a2.gif"></div><br>  For those who do not like to read, and experience in action - a <a href="https://github.com/DimasSup/AnimatedLines">link to a test project</a> .  For everyone else - Let's start! <br><br>  For tests we create a new project Single View Application.  Add a new View to the main View Controller. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/786/79e/795/78679e79509344129cdc5402482a1501.jpeg"><br></div></div><br>  Create a Referencing Outlet with the name 'panel' in the ViewController class.  In viewDidLoad ViewController, we add the line: <br><br><pre><code class="objectivec hljs">_panel.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br>  To round the corners of the rectangle.  We start - now the application looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d82/80a/a83/d8280aa836b74172bc250b090ddd6916.jpeg"></div><br>  We are done with Interface Builder.  It actually begins for the sake of what we are here - animation! <br><br>  A little excursion into Core Animation.  The base rendering class in iOS is CALayer, which provides the basic features for animation and rendering - such as moving, transforming.  In general, this is somewhere between low-level rendering via Core Graphics and higher in the form of a UIView.  In our case, we are interested in the successor of CALayer - CAShapeLayer, which adds support for CGPath, as well as related methods for this, such as pouring and working with stroke (what the hell?). <br><br>  So.  Create a category that extends the UIView class - <i>UIView + AnimatedLines</i> .  To begin with, let's add a simple method of adding an animated stroke for VIew using CAShapeLayer. <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)animateLinesWithColor:(<span class="hljs-built_in"><span class="hljs-built_in">CGColorRef</span></span>)lineColor andLineWidth:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)lineWidth animationDuration:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)duration { }</code> </pre> <br>  Create a CAShapeLayer: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CAShapeLayer</span></span>* animateLayer = [<span class="hljs-built_in"><span class="hljs-built_in">CAShapeLayer</span></span> layer]; animateLayer.lineCap = kCALineCapRound;<span class="hljs-comment"><span class="hljs-comment">//       animateLayer.lineJoin = kCALineJoinBevel;//     animateLayer.fillColor = [[UIColor clearColor] CGColor];//    animateLayer.lineWidth = lineWidth; animateLayer.strokeEnd = 0.0;</span></span></code> </pre> <br>  Create a UIBezierPath in which we will draw a stroke. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span>* path = [<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> new]; [path setLineWidth:<span class="hljs-number"><span class="hljs-number">1.0</span></span>]; [path setLineCapStyle:kCGLineCapRound]; [path setLineJoinStyle:kCGLineJoinRound];</code> </pre><br>  Next, simple geometry - draw lines along the border of our view (a lot of code, meaningless and merciless): <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> bounds = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer.bounds;<span class="hljs-comment"><span class="hljs-comment">//   CGFloat radius = self.layer.cornerRadius;//        CGPoint zeroPoint = bounds.origin; //  BOOL isRounded = radius&gt;0; if(isRounded) { zeroPoint.x = bounds.origin.x+radius; //   -     ,   ,    . } [path moveToPoint:zeroPoint];//     //    4 .   CGPoint nextPoint = CGPointMake(bounds.size.width, 0); if(isRounded) { nextPoint.x-=radius; } [path addLineToPoint:nextPoint]; if(isRounded) { [path addArcWithCenter:CGPointMake(nextPoint.x, nextPoint.y+radius) radius:radius startAngle:-M_PI_2 endAngle:0 clockwise:YES];//   -  . } //  nextPoint = CGPointMake(bounds.size.width, bounds.size.height); if(isRounded) { nextPoint.y-=radius; } [path addLineToPoint:nextPoint]; if (isRounded) { [path addArcWithCenter:CGPointMake(nextPoint.x-radius, nextPoint.y) radius:radius startAngle:0 endAngle:M_PI_2 clockwise:YES]; } //  nextPoint = CGPointMake(0, bounds.size.height); if(isRounded) { nextPoint.x +=radius; } [path addLineToPoint:nextPoint]; if (isRounded) { [path addArcWithCenter:CGPointMake(nextPoint.x, nextPoint.y-radius) radius:radius startAngle:M_PI_2 endAngle:M_PI clockwise:YES]; } //  nextPoint = CGPointMake(0, 0); if(isRounded) { nextPoint.y +=radius; } [path addLineToPoint:nextPoint]; if (isRounded) { [path addArcWithCenter:CGPointMake(nextPoint.x+radius, nextPoint.y) radius:radius startAngle:M_PI endAngle:-M_PI_2 clockwise:YES]; }</span></span></code> </pre> <br>  Line drawing we finished.  Add Path to CAShapeLayer: <br><br><pre> <code class="objectivec hljs">animateLayer.path = path.CGPath; animateLayer.strokeColor = lineColor;</code> </pre><br>  And the layer itself on our twist: <br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:animateLayer];</code> </pre> <br>  Now we can already see the static result of our work, for this we add to the ViewController: <br><br><pre> <code class="objectivec hljs">_panel.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">5</span></span>; [_panel animateLinesWithColor:[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor].CGColor andLineWidth:<span class="hljs-number"><span class="hljs-number">2</span></span> animationDuration:<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre><br>  And we can run: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/091/ecc/e48/091ecce488504cbd95d3ef7dbbe1fd99.jpeg"></div><br>  Well, really so-so, you say?  And you will be right, because the same result can be achieved simply by making layer.borderWidth = 2. <br><br><blockquote>  Here you need a small digression. <br><br>  When you draw in Path (UIPath, CGPath) segments, circles and other primitives - they all have a beginning and an end.  StrokeEnd at CAShapeLayer means to what place it is worth drawing this line. <br><br>  StrokeStart, in turn, indicates where to start drawing a line.  The value should lie in the range 0.0 - 1.0 <br><br>  For example: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1f5/21c/4e1/1f521c4e1890430493e465be10c45fd7.png"></div></blockquote><br>  So what can you do with this information?  All we need to do is add a few lines of code.  In the place where we create CAShapeLayer we will add one more line: <br><br><pre> <code class="objectivec hljs">animateLayer.strokeEnd = <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre><br>  Then, after adding the layer, create an animation for the strokeEnd: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> *pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"strokeEnd"</span></span>]; pathAnimation.duration = duration; pathAnimation.timingFunction = [<span class="hljs-built_in"><span class="hljs-built_in">CAMediaTimingFunction</span></span> functionWithName:kCAMediaTimingFunctionLinear]; pathAnimation.fromValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">0.0</span></span>f]; pathAnimation.toValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">1.0</span></span>f]; pathAnimation.autoreverses = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [animateLayer addAnimation:pathAnimation forKey:<span class="hljs-string"><span class="hljs-string">@"strokeEndAnimation"</span></span>]; animateLayer.strokeEnd = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre><br>  (How do CABasicAnimation work you can read on the <a href="https://developer.apple.com/reference/quartzcore/cabasicanimation%3Flanguage%3Dobjc">official website of the epl</a> ) <br><br>  3. Run! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6dc/ff0/2ba/6dcff02badcd4748a30acedf343735ac.gif"></div><br>  As you can see the line beautifully rounds our UIView.  Now let's make it like on the KDPV. <br><br>  What information we need for this: the point from which the line will begin its movement to the borders.  Since it is necessary to wag the line - we will do this by splitting the section from the starting point to the point of the beginning of the perimeter into sections on which we will deflect the line with: <br><br><pre> <code class="objectivec hljs">[path addCurveToPoint:controlPoint1:controlPoint2:];</code> </pre> <br>  Let's make it possible to run the animation several times. <br><br>  Add a new class that will contain control points for Bezier curves: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinesCurvePoints</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">controlPoint1</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">controlPoint2</span></span></span><span class="hljs-class">; +(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curvePoints</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point2</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point2</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinesCurvePoints</span></span></span><span class="hljs-class"> +(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curvePoints</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point2</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGPoint</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point2</span></span></span><span class="hljs-class"> </span></span>{ LinesCurvePoints* point = [LinesCurvePoints new]; point.controlPoint1 = point1; point.controlPoint1 = point2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> point; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre> <br>  Add new fields to the method: <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)animateLinesWithColor:(<span class="hljs-built_in"><span class="hljs-built_in">CGColorRef</span></span>)lineColor andLineWidth:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)lineWidth startPoint:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)startFromPoint rollToStroke:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)rollToStroke curveControlPoints:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;LinesCurvePoints*&gt;*)curvePoints animationDuration:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)duration</code> </pre><br>  In the method, after determining zeroPoint, add the following code: <br><br><pre> <code class="objectivec hljs">[path moveToPoint:startFromPoint]; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c = curvePoints.count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i =<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=c; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nX = startFromPoint.x + (zeroPoint.x - startFromPoint.x)/(c)*i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nY = startFromPoint.y +(zeroPoint.y - startFromPoint.y)/(c)*i; LinesCurvePoints* point = curvePoints[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; [path addCurveToPoint:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX, nY) controlPoint1:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX+point.controlPoint1.x,nY+point.controlPoint1.y) controlPoint2:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX+ point.controlPoint2.y,nY+ point.controlPoint2.y)]; }</code> </pre><br>  It will divide the section from the starting point to the beginning of the perimeter into equal sections and draw them using the curves with the control points that we specified in curveControlPoints.  And the second part we need to add is the strokeStart motion: <br><br><pre> <code class="objectivec hljs">pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"strokeStart"</span></span>]; pathAnimation.duration = duration*<span class="hljs-number"><span class="hljs-number">1.2</span></span>; pathAnimation.timingFunction = [<span class="hljs-built_in"><span class="hljs-built_in">CAMediaTimingFunction</span></span> functionWithName:kCAMediaTimingFunctionEaseIn]; pathAnimation.fromValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">0.0</span></span>f]; pathAnimation.toValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:rollToStroke]; pathAnimation.autoreverses = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [animateLayer addAnimation:pathAnimation forKey:<span class="hljs-string"><span class="hljs-string">@"strokeStartAnimation"</span></span>]; animateLayer.strokeStart = rollToStroke;</code> </pre><br>  Add after the strokeEnd animation.  Unfortunately, the value for strokeStart will have to be selected empirically, I never managed to calculate the correct length of the section if I draw it with Bezier curves. <br><br>  The final method code should look like this: <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)animateLinesWithColor:(<span class="hljs-built_in"><span class="hljs-built_in">CGColorRef</span></span>)lineColor andLineWidth:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)lineWidth startPoint:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)startFromPoint rollToStroke:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)rollToStroke curveControlPoints:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;LinesCurvePoints*&gt;*)curvePoints animationDuration:(<span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>)duration { <span class="hljs-built_in"><span class="hljs-built_in">CAShapeLayer</span></span>* animateLayer = [<span class="hljs-built_in"><span class="hljs-built_in">CAShapeLayer</span></span> layer]; animateLayer.lineCap = kCALineCapRound; animateLayer.lineJoin = kCALineJoinBevel; animateLayer.fillColor = [[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> clearColor] <span class="hljs-built_in"><span class="hljs-built_in">CGColor</span></span>]; animateLayer.lineWidth = lineWidth; animateLayer.strokeEnd = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span>* path = [<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> new]; [path setLineWidth:<span class="hljs-number"><span class="hljs-number">1.0</span></span>]; [path setLineCapStyle:kCGLineCapRound]; [path setLineJoinStyle:kCGLineJoinRound]; <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> bounds = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer.bounds; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> radius = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer.cornerRadius; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> zeroPoint = bounds.origin; <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> isRounded = radius&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { zeroPoint.x = bounds.origin.x+radius; } [path moveToPoint:startFromPoint]; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c = curvePoints.count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i =<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=c; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nX = startFromPoint.x + (zeroPoint.x - startFromPoint.x)/(c)*i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nY = startFromPoint.y +(zeroPoint.y - startFromPoint.y)/(c)*i; LinesCurvePoints* point = curvePoints[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; [path addCurveToPoint:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX, nY) controlPoint1:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX+point.controlPoint1.x,nY+point.controlPoint1.y) controlPoint2:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nX+ point.controlPoint2.y,nY+ point.controlPoint2.y)]; } [path moveToPoint:zeroPoint]; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> nextPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(bounds.size.width, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { nextPoint.x-=radius; } [path addLineToPoint:nextPoint]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { [path addArcWithCenter:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nextPoint.x, nextPoint.y+radius) radius:radius startAngle:-M_PI_2 endAngle:<span class="hljs-number"><span class="hljs-number">0</span></span> clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } nextPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(bounds.size.width, bounds.size.height); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { nextPoint.y-=radius; } [path addLineToPoint:nextPoint]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isRounded) { [path addArcWithCenter:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nextPoint.x-radius, nextPoint.y) radius:radius startAngle:<span class="hljs-number"><span class="hljs-number">0</span></span> endAngle:M_PI_2 clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } nextPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, bounds.size.height); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { nextPoint.x +=radius; } [path addLineToPoint:nextPoint]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isRounded) { [path addArcWithCenter:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nextPoint.x, nextPoint.y-radius) radius:radius startAngle:M_PI_2 endAngle:M_PI clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } nextPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isRounded) { nextPoint.y +=radius; } [path addLineToPoint:nextPoint]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isRounded) { [path addArcWithCenter:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(nextPoint.x+radius, nextPoint.y) radius:radius startAngle:M_PI endAngle:-M_PI_2 clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } animateLayer.path = path.CGPath; animateLayer.strokeColor = lineColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:animateLayer]; <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> *pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"strokeEnd"</span></span>]; pathAnimation.duration = duration; pathAnimation.timingFunction = [<span class="hljs-built_in"><span class="hljs-built_in">CAMediaTimingFunction</span></span> functionWithName:kCAMediaTimingFunctionLinear]; pathAnimation.fromValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">0.0</span></span>f]; pathAnimation.toValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">1.0</span></span>f]; pathAnimation.autoreverses = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [animateLayer addAnimation:pathAnimation forKey:<span class="hljs-string"><span class="hljs-string">@"strokeEndAnimation"</span></span>]; animateLayer.strokeEnd = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"strokeStart"</span></span>]; pathAnimation.duration = duration*<span class="hljs-number"><span class="hljs-number">1.2</span></span>; pathAnimation.timingFunction = [<span class="hljs-built_in"><span class="hljs-built_in">CAMediaTimingFunction</span></span> functionWithName:kCAMediaTimingFunctionEaseIn]; pathAnimation.fromValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:<span class="hljs-number"><span class="hljs-number">0.0</span></span>f]; pathAnimation.toValue = [<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> numberWithFloat:rollToStroke]; pathAnimation.autoreverses = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [animateLayer addAnimation:pathAnimation forKey:<span class="hljs-string"><span class="hljs-string">@"strokeStartAnimation"</span></span>]; animateLayer.strokeStart = rollToStroke; }</code> </pre><br>  Calling a method in ViewController: <br><br><pre> <code class="objectivec hljs">[_panel animateLinesWithColor:[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor].CGColor andLineWidth:<span class="hljs-number"><span class="hljs-number">2</span></span> startPoint:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">-200</span></span>) rollToStroke:<span class="hljs-number"><span class="hljs-number">0.25</span></span> curveControlPoints:@[ [LinesCurvePoints curvePoints:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">-50</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>) point2:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)], [LinesCurvePoints curvePoints:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">-60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) point2:<span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] ] animationDuration:<span class="hljs-number"><span class="hljs-number">2</span></span> ];</code> </pre><br>  rollToStroke value is suitable for if the _panel is 240 pixels by 128 pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d67/37a/c26/d6737ac267a9436f8b3bbcb2ea8cbff6.gif"></div><br>  Another example of using this animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7e2/a3a/fa0/7e2a3afa04f241acb8e1bb0fe236c22a.gif"></div><br>  There are many games based on this animation, my favorite: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SYT8dd_idfA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  In general, in such a simple way you can make quite interesting animations in the application.  I would be glad if someone found it useful. </div><p>Source: <a href="https://habr.com/ru/post/318716/">https://habr.com/ru/post/318716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318704/index.html">Laravel Dusk is close</a></li>
<li><a href="../318706/index.html">Everything you wanted to know about financial bots</a></li>
<li><a href="../318710/index.html">Virtual office for real work</a></li>
<li><a href="../318712/index.html">Gigabyte history</a></li>
<li><a href="../318714/index.html">Legal risks of investing in startups of companies in the USA and Israel</a></li>
<li><a href="../318718/index.html">Coordinated work of macro and micro base stations in the creation of heterogeneous networks as the key to the development of mobile broadband</a></li>
<li><a href="../318720/index.html">Microservice at Golang</a></li>
<li><a href="../318722/index.html">Routing orthogonal connections in chart editors</a></li>
<li><a href="../318724/index.html">Platform to quickly create a RESTful API</a></li>
<li><a href="../318726/index.html">FPGA Debug Board - Frankenstein. Christmas tree controller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>