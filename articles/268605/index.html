<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Primary key - GUID or autoincrement? Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article , we considered the criteria for choosing between a GUID and an auto increment as the primary key. The main idea was that if f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Primary key - GUID or autoincrement? Part two</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/265437/">previous article</a> , we considered the criteria for choosing between a GUID and an auto increment as the primary key.  The main idea was that if for some basic criteria (replication, requirements for uniqueness, etc.) there is a need to use a GUID, then you need to take into account the nuances associated with its performance.  Tests of insertion of records showed that sequential GUIDs generated on the client are the fastest option, and the insertion in this case works even faster than when using autoincrement.  But the article did not consider the loss in sampling performance when using the GUID as a key.  In this article I will try to close this space. <br><a name="habracut"></a><br>  We will test the following scenarios: <br><ul><li>  Search for a separate entry by primary key with reading one child collection </li><li>  Search for a separate entry by the primary key with reading several collections </li><li>  Selection of several records with reading one child collection for each record </li><li>  Selection of several records with reading of several child collections for each record </li><li>  Selection of all records from the table with reading one child collection for each record </li><li>  Selection of all records from the table with reading of all child collections </li></ul><br>  Separation into a scenario with one child collection and several is needed to understand how much the number of joints (JOIN) affects the key in one query for the final result.  And how much performance decrease depends on the type of key. <br><br>  Using these scripts, we compare three key options: <br><ul><li>  Auto increment </li><li>  Sequential guid </li><li>  Inconsistent GUID </li></ul><br>  To do this, we need three sets of tables, each of which consists of a main table and 5 tables for the child records. <br><br>  Testing will be conducted, as in the previous article, using the Entity Framework 6.1.3.  Database - Microsoft SQL Server 2014 Developer Edition (64 bit).  Add 10,000 records to each of the main tables, where each record will have 5 child collections containing 10 elements each.  Thus, the tables in the child collections will contain 100,000 rows each. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The source code of the test program can be found <a href="https://github.com/YuriyIvon/BenchmarkPrimaryKeys">here</a> . <br><br>  Below are charts of the results.  For ease of comparison, percentages are indicated on them, where the minimum result of all the options is taken as 100%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/345/d1b/355/345d1b355fce4a33a5b736a50f7d3509.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d93/46b/92a/d9346b92a2cb4e50b28424b53857c7f9.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea0/190/21a/ea019021aaa244ac82a5587c0e39c512.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a1d/9e9/7a2/a1d9e97a21da4081a6dcab74cc0d0f53.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/323/cd1/097/323cd1097ff34f1bae867690c7f8fa5f.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a7/596/64c/1a759664c4fe48b0ac102b3f686f9b84.png"></div><br><br>  The results show that the sampling operations operating with integer keys are, of course, faster than in the case of the GUID.  But the difference in performance between a sequential GUID and an auto-increment is not so great as to tell a significant loss when choosing a GUID. <br><br>  It should also be noted that the percentage difference in the execution time is preserved with an increase in the number of connections in a single request.  What, in fact, was to be expected, but it was necessary to make sure. <br><br>  Inconsistent GUID showed in some cases noticeably worse results, which, again, is natural.  In practice, the difference between it and the other two options may turn out to be even greater - in cases where the database cannot be fully cached in RAM and a large amount of disk readings are required to obtain all the neighboring child records (a similar test was described in a previous article to insert records).  Accordingly, to use such a variant of the primary key in practice does not make sense. <br><br>  Despite the fact that this test showed a slight difference between auto-increment and sequential GUID, I would not consider the latter as an option that can be thoughtlessly used in all situations.  The GUID takes up more space, especially in the text view.  If there is a transformation of objects into text format (JSON, XML) in the system, and the portion of objects that is converted at one time contains a large number of identifiers - the difference in volume compared to integer keys can be significant.  The inverse transformation (deserialization) for GUID is much slower than for a number, but, in my opinion, this difference can be neglected.  This time is still very short - on my machine it takes 60 milliseconds to parse a hundred thousand GUIDs, compared to 12 milliseconds for integers.  A more tangible problem with the use of unique identifiers may be that they are much more difficult to operate with support and debugging than with integers. <br><br>  I would formulate the general conclusion on the basis of both articles as follows: if for any reasons not related to performance, there is a need to use the GUID as the primary key, then from the possible implementations, you should choose a sequential one generated on the client.  At the same time, in most cases, it is possible not to worry about the performance loss of read operations.  The main GUID problem in terms of sampling performance is not that the processor needs to do more actions for comparison (this is most likely optimized, and there is little comparison when searching by key, if it is not a scan), but that it takes 4 times the usual int, respectively, fewer pages of indexes and data can be cached in the same amount of RAM.  If in your database the indexes of primary and foreign keys occupy tens of percent of the total base volume and the amount of actively used data cannot be fully cached, and there is no possibility to increase the amount of RAM, it makes sense to think about lighter keys.  But this situation seems to me quite rare.  You should also pay attention to the potential problems with serialization / deserialization mentioned above.  However, the corresponding case that I saw in practice was not so much a problem of the GUID itself as a problem of incorrect API design - the entire collection was read at once without restrictions, paging, etc. </div><p>Source: <a href="https://habr.com/ru/post/268605/">https://habr.com/ru/post/268605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268585/index.html">Go Benchmarks</a></li>
<li><a href="../268587/index.html">Blocks. The internal structure of the Cach√© database file. Part 3</a></li>
<li><a href="../268593/index.html">Huawei and NTT DOCOMO successfully tested 5G technology in the field</a></li>
<li><a href="../268597/index.html">Mobile communications in Europe</a></li>
<li><a href="../268599/index.html">Enable HTTP / 2 in NGINX for the site</a></li>
<li><a href="../268607/index.html">Volker Simonis - Interiors of SAP JVM [Meeting JUG in St. Petersburg]</a></li>
<li><a href="../268609/index.html">Rust in details: we write scalable chat from scratch, part 1</a></li>
<li><a href="../268611/index.html">The digest of interesting materials for the mobile # 124 developer (October 5-11)</a></li>
<li><a href="../268613/index.html">Using hardlinks (hardlink) for Synology DSM incremental backup</a></li>
<li><a href="../268615/index.html">Programming with YII2: get down to work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>