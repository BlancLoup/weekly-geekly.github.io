<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Waf eyes hackers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Today we will talk about one of the modern mechanisms for protecting web applications, namely, WAF, Web Application Firewall. We will descri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Waf eyes hackers</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/webt/59/e5/55/59e555ea45527050889028.png">  Hi, Habr!  Today we will talk about one of the modern mechanisms for protecting web applications, namely, WAF, Web Application Firewall.  We will describe what modern WAFs are based on and how they work, what are the workarounds and bypass techniques, how to use them, and why you shouldn‚Äôt rely entirely on WAF by any means.  We will present our view of pentesters who have never participated in the development of WAF and who collected information from open sources and based on their experience, so we may not even be aware of some subtleties of the work of WAF. <br clear="left"><a name="habracut"></a><br><hr><br><h4>  Content </h4><br><ol><li>  Introduction </li><li>  What is the modern WAF </li><li>  Identify WAF </li><li>  WAF bypass cheatsheet </li><li>  Bypassing WAF in practice </li><li>  Conclusion </li></ol><br>  <i>The article turned out to be quite large, so technical specialists and those who are not interested in reading, why WAFs are used, as well as those who do not need to describe the mechanisms of WAF work, can immediately proceed to the presentation of workarounds and practical examples.</i> <br><br><h2>  Introduction </h2><br>  Recently, WAFs have become extremely popular, vendors offer a variety of solutions in different price categories, delivery packages and options designed for different consumers - from small businesses to large corporations.  Modern WAF is popular because it is considered a comprehensive means of protecting web applications and has a wide range of tasks covered, so web application developers can rely on it in some security issues, but with the proviso that this solution cannot guarantee absolute protection. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93092095133873.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, what should WAF be able to, so that its implementation is justified in a real project?  Its main function is to detect and block requests, in which, according to WAF analysis, there are some anomalies or an attacking vector is traced.  Such an analysis should not make it difficult for legitimate users to interact with a web application, but at the same time should accurately and timely detect any attack attempts.  In order to implement this functionality, WAF developers typically use regular expressions, tokenizers, behavioral analysis, reputational analysis, and machine learning, and often all of these technologies are used together.  In addition, WAF can also provide other functionality: protection against DDoS, blocking the IP addresses of attackers, tracking of suspicious IP addresses, adding security headers (X-XSS-Protection, X-Frame-Options, etc ...), adding http -only the flag to the cookie, the introduction of the HSTS mechanism, the addition of the functionality of CSRF tokens.  Also, some WAFs have a client module embedded in the site written in JavaScript. <br><br>  Of course, WAF creates a number of difficulties for the work of hackers and pentesters.  Detection and exploitation of vulnerabilities becomes a more time-consuming task, unless, of course, the attacker is not aware of effective 0day ways of circumventing a specific WAF.  Using automated scanners to analyze web applications under the protection of WAF is almost useless.  WAF reliably protects sites at least from scriptkiddies.  However, an experienced specialist or hacker, without proper motivation, may also decide not to spend a lot of time searching for workarounds.  Separately, we note that the more complex and multifunctional the web application, the greater the possible area of ‚Äã‚Äãattack, and the easier it will be to find a way around the WAF. <br><br>  Recently, quite often in our audits there are different WAFs, we will even tell about some cases below.  We have already tested some proprietary WAFs in two main scenarios: <br><br><ul><li>  We know the specific vulnerability in the web application and try to bypass WAF to exploit it. </li><li>  The specific vulnerability is unknown, the task is to detect it, regardless of WAF, and then exploit, bypassing WAF. </li></ul><br>  But first, let us dwell in more detail on the basic mechanisms of the work of the WAF and see what problems exist with this. <br><br><h2>  What is the modern WAF </h2><br>  In order to effectively detect various WAF bypass methods, a specialist needs to understand the modern query classification mechanisms.  Each WAF is individual and has a unique internal structure; however, there are some typical methods used for analysis.  Let's take them and consider. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93c4f468367566.png"><br><br><h4>  Regular Expression Based Rules </h4><br>  Most existing WAFs are based on regular expression based rules.  To create them, a certain known set of attacks is studied by the WAF developer, as a result, key syntactic constructions are determined, by the presence of which it is possible to assert that an attack has been carried out.  Based on the results obtained, regular expressions are written that can find such constructions.  It seems that everything is simple, but this approach has several disadvantages.  The zone of applicability of a regular expression is limited to one request, and more often even to a specific request parameter, which obviously reduces the effectiveness of such rules and creates a number of ‚Äúblind zones‚Äù for such a mechanism.  Secondly, the syntax of regular expressions, the complex logic of text protocols, which can be replaced by equivalent constructs and the use of different representations of characters, lead to errors in creating such rules.  There is a <a href="https://xakep.ru/2016/12/19/web-application-firewalls-bypasses/">great study</a> on this topic from Vladimir Ivanov. <br><br><h4>  Scorebuilding </h4><br>  This mechanism should be familiar to anyone who was interested in building firewalls and antiviruses.  By itself, it does not detect attacks, but it complements other methods, making them more accurate and flexible.  The reason for the appearance of the tool is that the presence of some ‚Äúsuspicious‚Äù construct in the request is not a sufficient condition for detecting an attack or, on the contrary, can lead to a large number of false-positive errors.  This problem is solved by the introduction of a point system.  For example, each rule based on regular expressions is supplemented with information on the criticality of its operation;  after identifying all the rules that have worked, their criticality is summarized.  In the case of overcoming a certain threshold value, the attack is detected, and the request is blocked.  This mechanism, despite its simplicity, has proven itself in tasks of this class and is used everywhere. <br><br><h4>  Tokenizers </h4><br>  This approach to detecting attacks was introduced at Black Hat 2012 as a C / C ++ <a href="https://github.com/client9/libinjection">library of libinjection</a> , which allows you to quickly and accurately detect attacks of the SQL injection class.  At the moment, for the library of libinjection, there are ports for various programming languages, including PHP, Lua, Python, etc ... In fact, the mechanism boils down to finding signatures represented as a sequence of tokens.  A certain number of signatures is entered into the built-in blacklist and is considered invalid or malicious.  In other words, before analyzing any request, it first leads to a set of tokens.  Tokens are divided into different types, for example, variable, string, regular operator, unknown, number, comment, union-like operator, function, comma, etc ... One of the main disadvantages of this method is that it is possible to build such a structure, which will lead to incorrect formation of tokens, therefore, the request signature will be different from the expected one.  Such constructions are usually called token breakers, we will tell about them a bit later. <br><br><h4>  Behavior analysis </h4><br>  Detection of exploitation attempts in the request parameters is not the only task of WAF.  It is important to identify the very procedure of searching for vulnerabilities, which can manifest itself in attempts to scan, brute force directories, fuzzing parameters and other methods of vulnerability detection that are often used by automated tools, and react accordingly to them.  More advanced WAFs even know how to build chains of requests, ‚Äútypical‚Äù for normal user behavior, and block attempts to send requests in a different way than standard behavior.  This mechanism does not so much counteract attacks as complicates the process of finding vulnerabilities.  The limit on the number of requests per minute does not affect the typical user, but it will be a significant obstacle for the scanner working in several streams. <br><br><h4>  Reputation Analysis </h4><br>  Another mechanism directly inherited from firewalls and antiviruses.  Today, almost any WAF includes address lists of VPN services, anonymizers, Tor network nodes, botnet members, which can be used to block requests originating from suspicious addresses.  More advanced WAFs are able to automatically update their databases and add additional entries to them based on the analyzed traffic. <br><br><h4>  Machine learning </h4><br>  One of the most controversial points in the WAF.  This mechanism is the most difficult to describe, and there are many reasons.  For a start, it is worth noting that the very concept of ‚Äúmachine learning‚Äù is very extensive and in fact includes many technologies and techniques.  In addition, ‚Äúmachine learning‚Äù is considered only one of the classes of AI methods.  ‚ÄúImplementing machine learning‚Äù or ‚Äúusing AI‚Äù is a very popular marketing move.  It is often unclear what methods and algorithms are used in practice, and sometimes from the attacker, it seems that machine learning in WAF is just beautiful words.  Among those market players who were really able to subdue the full power of machine learning, few people are willing to share their experiences.  All this adds up to a rather sad picture for a ‚Äúperson from the outside‚Äù who wants to understand the question.  And still try to select at least a couple of sound ideas based on available information. <br><br>  First, machine learning is completely dependent on the data on which it was based, and this is often a big problem.  It requires that the company-developer has an up-to-date and complete collection of existing attacks and their methods of application, which is rather difficult.  For this reason, many suppliers carefully log the results of their WAF and work with other companies that offer IDS, SIEM systems to access real-world examples of attacks.  Secondly, a model trained on a ‚Äúspherical web application in vacuum‚Äù may simply be ineffective when installed on a real client web application.  For the best effect, it is considered correct to conduct additional model training at the WAF implementation stage at the client, which requires additional expenses, time, organizational difficulties, and also does not guarantee a better result. <br><br><h2>  Identify WAF </h2><br>  WAF developers have a different approach to notifying the user that WAF has blocked the request.  Therefore, analyzing the response to our attacking request, we can understand how WAF is protected by the web application.  For this, the term WAF Fingerprint is often used.  This may help if the WAF is not updated for any reason (this usually refers to open source WAF).  Proprietary WAF developers take care of customers and implement an auto-update mechanism.  Also, if we were able to identify WAF and it was updated to the latest version, anyway, information about a specific WAF will help us learn a little about the specifics of its work. <br><br>  We list the main places by which WAF can be identified: <br><br><ul><li>  Additional cookies </li><li>  Additional headers added to any response or request </li><li>  Content of the response (in case of blocking the request) </li><li>  Response code (in case of request blocking) </li><li>  IP address (refers to Cloud WAF) </li><li>  JS module (Client-side WAF) </li></ul><br>  For clarity, we give a few examples. <br><br>  <b>PT AF</b> <br>  Response code when blocking: 403 <br>  It can be embedded in the response page client module waf.js. <br>  Response body when blocking: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>Request ID: 2017-07-31-13-59-56-72BCA33A11EC3784<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Additional header that adds waf.js: <br><br><pre> <code class="xml hljs">X-RequestId: cbb8ff9a-4e91-48b4-8ce6-1beddc197a30</code> </pre> <br>  <b>Nemesida WAF</b> <br>  Response code when blocking: 403 <br>  Response body when blocking: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"font-size: 16px; align: center;"</span></span></span><span class="hljs-tag">&gt;</span></span> Suspicious activity detected. Access to the site is blocked. If you think that is's an erroneous blocking, please email us at <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mailto:nwaf@pentestit.ru"</span></span></span><span class="hljs-tag">&gt;</span></span>nwaf@pentestit.ru<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> and specify your IP-address. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Wallarm</b> <br>  Response code when blocking: 403 <br>  Additional title: nginx-wallarm <br><br>  <b>Citrix NetScaler AppFirewall</b> <br>  Additional cookies: <br><br><pre> <code class="xml hljs">ns_af=31+LrS3EeEOBbxBV7AWDFIEhrn8A000; ns_af_.target.br_%2F_wat=QVNQU0VTU0lP TklEQVFRU0RDU0Nf?6IgJizHRbTRNuNoOpbBOiKRET2gA</code> </pre> <br>  <b>Mod_Security ver.</b>  <b>2.9</b> <br>  Response code when blocking: 403 <br>  Response body when blocking: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>403 Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>You don't have permission to access /form.php on this server.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag"> /&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Mod_Security ver.</b>  <b>&lt;2.9</b> <br>  Response code when blocking: 406 or 501 <br>  Response body when blocking: <br>  In the response body you can find mod_security, Mod_Security or NOYB <br><br>  <b>Varnish FireWall</b> <br>  Adds view headers to the response: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">X-Varnish</span></span>: 127936309 131303037. <span class="hljs-selector-tag"><span class="hljs-selector-tag">X-Varnish</span></span>: 435491096 <span class="hljs-selector-tag"><span class="hljs-selector-tag">Via</span></span>: 1<span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">varnish-v4</span></span></code> </pre> <br>  The WAF developers themselves decide which response code to return in the event of a request blocking, there are also specific codes.  For example, code 999 will return Web_Knight WAF if the request is blocked, and dotDefender will return code 200 with an empty response body or containing an error message. <br><br>  Also, do not forget that WAF, like any other application, is being developed and modified.  Therefore, it is always important to check the relevance of the ‚Äúprints‚Äù known to you.  In addition, developers can make a custom response page when blocking with any other content. <br><br><h2>  WAF bypass cheatsheet </h2><br>  The general idea of ‚Äã‚Äãfinding ways to bypass WAF is to bring the request we need to a form in which it is still understandable to the attacked web application, but it is not clear or seems harmless to WAF.  It is important to note that one type of WAF must be able to serve a large number of different types of servers, including exotic, such as Unicorn, Tornado, Weblogic, Lighttpd etc ... Each server can perceive different or other exceptional cases of HTTP request parsing, which should be counted in the WAF.  Thus, an attacker can use the specifics of parsing an HTTP request from the server being attacked in order to find a way to bypass WAF. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395afb9650235665851.png"><br><br>  All possible ways of circumventing WAF are difficult to classify in any way according to the WAF protection mechanisms against which they may be used, or according to the application.  The same workarounds can be interconnected with each other and affect simultaneously the various components of the WAF.  Also it is necessary to take into account the large possible area of ‚Äã‚Äãapplication of detection bypass techniques, both by the types of attacks and by the specific place of their use.  The techniques described below were collected from open sources and found in the course of their own research, and proved to be one of the most effective.  Special thanks to want to express <a href="https://habrahabr.ru/users/bo0om/" class="user_link">Bo0oM</a> and its <a href="https://t.me/webpwn">channel</a> in the Telegram. <br><br><h4>  Adding special characters </h4><br>  Various special characters can violate the logic of WAF and at the same time be understandable to the server itself.  Variations of special characters can also be any: they can be converted to urlencode (but most WAFs have been doing this for a long time) or other encodings.  You can also insert special characters in the request without any encoding, in raw format, which can be quite unexpected for WAF.  For example, \ r \ n \ r \ n in this form can be interpreted as the end of the HTTP-request body, and null byte can break the logic of regular expressions and parsers of various data formats in general.  Other special characters from the first two dozen ASCII-table characters may also be useful. <br><br>  Examples of useful special characters: <br><br><ul><li>  0x00 - Null byte; </li><li>  0x0D - Carriage return; </li><li>  0x0A - Line feed; </li><li>  0x0B - Vertical Tab; </li><li>  0x09 - Horizontal tab; </li><li>  0x0C - New page </li></ul><br>  When searching for bypass, it will be useful to insert special characters in various places in the request body, not limited to including the parameter in the value.  For example, if the request is in JSON format, then you can insert null byte both in one of the parameters, and between the parameters, and at the beginning of JSON, and at the end.  The same applies to the other body formats of the POST request.  In general, we recommend exploring and having fun, looking for places that can be checked or parsed by WAF, and try different special characters there. <br><br>  For example: <br><br><pre> <code class="hljs objectivec">{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-string"><span class="hljs-string">"string0x00"</span></span>:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>} {<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-string"><span class="hljs-string">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">"test'/*0x00*/ or sleep(9)#"</span></span>} {<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-string"><span class="hljs-string">"string"</span></span><span class="hljs-number"><span class="hljs-number">0x0A0</span></span>x0D:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>}</code> </pre> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja0x09vas0x0A0x0Dcript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs">id=1337<span class="hljs-comment"><span class="hljs-comment">/*0x0C*/</span></span>1 UNION <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>() <span class="hljs-comment"><span class="hljs-comment">--</span></span></code> </pre> <br>  For clarity, we replaced the special characters with their hex representation. <br><br><h4>  Replacing whitespace characters </h4><br>  A separate category is to allocate the replacement of spaces with equivalent characters.  For example, most syntaxes presuppose the separation of keywords and operators by whitespace, but it does not strictly indicate which character should be used.  Thus, instead of the usual <b>0x20</b> (Space), <b>0x0B</b> (Vertical Tab), <b>0x09</b> (Horizontal tab) can be used.  Also in this category is to include the replacement of whitespace characters on the dividing structures that do not carry the semantic load.  In SQL, for example, this is <b>/ ** /</b> (multi-line SQL comment), <b># \ r \ n</b> (single-line SQL comment, ending with a line break), <b>- \ r \ n</b> (alternative single-line SQL comment, ending with a line break).  Here are some examples: <br><br><pre> <code class="html hljs xml">http://test.com/test?id=1%09union/**/select/**/1,2,3 http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3</code> </pre> <br>  You can also change the expression so that, using the syntax of the language, get rid of spaces.  For example, in SQL, you can use brackets: <br><br><pre> <code class="sql hljs">UNION(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,(<span class="hljs-number"><span class="hljs-number">6</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Users</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span>(login=<span class="hljs-string"><span class="hljs-string">'admin'</span></span>))</code> </pre> <br>  And in JS use the symbol /: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confirm(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Change encoding </h4><br>  The method is based on the use of different encodings in such a way that WAF does not decode data in certain places.  For example, after replacing one character with its url-code, WAF will not be able to decode the data and skip the request, while the same parameter will be accepted and successfully decoded by the web application. <br><br>  HTML character decimal representation: <b>&amp; # 106</b> or <b>&amp; # 0000106</b> .  WAF may be aware of a short representation of characters (as in the first option), but not aware of the option with the addition of additional zeros, the total number of characters should not be more than 7. Similarly, the hexadecimal representation of the HTML character: <b>&amp; # x6A</b> or <b>&amp; # x000006A</b> . <br><br>  There is also a trick with escaping some characters with the <b>\</b> character, for example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on</span></span></span><span class="hljs-tag">\</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">load</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">a\lert(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  However, this depends on how the web application handles such input.  That is, the sequence of characters <b>\ l</b> will be perceived as shielded <b>l</b> and converted to one character, WAF can perceive each character separately.  Thus, WAF will not see the keywords.  Using this technique, you cannot escape the <b>\ n</b> , <b>\ r</b> , <b>\ t</b> characters, since they will be converted to completely different characters: line breaks, carriage returns and tabs. <br><br>  HTML-encode can also be used inside tag properties, for example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onmouseover</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;confirm&amp;lpar;1rpar;"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Instead of such characters, it is quite realistic to substitute any other HTML representation of the target characters.  Various options for character conversion can be found <a href="https://dev.w3.org/html5/html-author/charref">here</a> . <br><br>  In addition to HTML encode, you can insert characters using \ u: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:\u0061lert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>Clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confir\u006d(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Another separate touch on the vector associated with the insertion of special characters.  We divide payload using HTML encode: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja&amp;Tab;vas&amp;#x0000A;cript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In this case, you can substitute other separating characters. <br><br>  Thus, we recommend combining different encodings with other methods, for example, to encode special characters. <br><br><h4>  Search for atypical equivalent syntax </h4><br>  This method is to find a method of operation that could not be taken into account by the WAF developers, or the vector was missing in the training set for machine learning.  Some simple javascript functions include: this, top self, parent, frames, tag properties: data-bind, ontoggle, onfilterchange, onbeforescriptextete, onpointerover, srcdoc, and SQL statements: lpad, field, bit_count. <br><br>  Here are some examples: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">window</span></span></span><span class="javascript">[</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'alert'</span></span></span><span class="javascript">](</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">parent[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">self[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">2</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">LPAD</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>())=<span class="hljs-string"><span class="hljs-string">'5.7'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>),<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br>  You can also use the symbolic representation of JavaScript expressions: <br><br><ul><li>  <a href="http://www.jsfuck.com/">JSFuck</a> ; </li><li>  <a href="http://utf-8.jp/public/jjencode.html">Jjencode</a> ; </li><li>  <a href="https://syllab.fr/projets/experiments/xcharsjs/5chars.pipeline.html">Xchars.js</a> . </li></ul><br>  The obvious problem with this JS view is the large length of the resulting payload. <br><br>  Separately, we note that bypassing WAF using this technique depends on the specific attack and exploited technology stack.  As an example, we can take the situation with the sensational ImageTragick exploit. <br><br>  Most WAFs for protection against this attack blacklisted the keywords url, capacity, label that were used in most articles and PoC describing this vulnerability.  However, it was soon discovered that in addition to these keywords, others could be used, for example, ephemeral, pango.  As a result, WAF could be circumvented by using these keywords as a vector. <br><br><h4>  HTTP Parameter Pollution (HPP) and HTTP Parameter Fragmentation (HPF) </h4><br>  HPP‚Äôs attack uses a server-specific parameter handling feature.  Here are some possible ways to work around WAF: <br><br>  The server uses the last parameter received, and WAF only checks the first one. <br>  The server combines the value of all the same parameters, and the WAF checks them separately.  You can compare the difference in processing the same parameters by different servers using the following table: <br><br><img src="https://habrastorage.org/webt/59/e3/77/59e3770e949f3269504620.png"><br><br>  In turn, the HPF attack is that if the logic of the web application combines two or more parameters in the request, then the attacker can break his request into parts, and thereby bypass some WAF checks. <br><br>  An example of such an attack is an SQL injection of the form: <br><br><pre> <code class="html hljs xml">http://test.com/url?a=1+select&amp;b=1+from&amp;c=base</code> </pre> <br>  HPF and HPP are very similar attacks, but if the first is directed at a web application, then the second is on the environment in which it operates.  The use of these techniques simultaneously increases the chances of circumventing WAF. <br><br><h4>  Unicode normalization </h4><br>  Unicode has one feature - Unicode Normalization.  This was done in order to be able to compare some Unicode characters that are similar in spelling, for example, the characters <b>' '</b> and <b>' ·µÉ '</b> have different codes, but they don‚Äôt differ much more, after normalization, both of them will be converted to the simple character <b>' a '</b> and will be considered the same.  Normalization allows you to convert some complex Unicode characters to their simpler counterparts.  There is a <a href="http://unicode.org/charts/normalization/">table</a> that lists all possible Unicode characters with their possible normalization.  With it, you can make various payload and combine them with other methods.  However, this does not work in all web applications. <br><br>  For example, in the table above, you can find that the characters <b><code>Ôºú</code></b> and <b><code>Ôπ§</code></b> converted to the character <b><code>&lt;</code></b> .  But it should be noted that the stage at which normalization takes place is important, because if the application uses HTML encoding after normalization, then most likely the <b><code>&lt;</code></b> character received after normalization will be encoded in <b><code>&amp;lt;</code></b>  .  However, otherwise, the developers might well have ignored this feature and did not encode Unicode characters.  Thus, we get unencoded characters <b>&lt;</b> and <b>&gt;</b> that can be turned into XSS.  WAF may also have problems understanding Unicode characters, it may simply have no rules for such tricks, and machine learning may also be powerless.  If you find a way to bypass WAF in web applications that have Unicode normalization, you can also replace not only the characters <b>&lt;&gt;</b> , but also change other characters from the payload. <br><br>  For example: <br><br><pre> <code class="html hljs xml">Ôºúimg srcÔπ¶x onerrorÔºùalertÔ∏µ1)&gt;</code> </pre> <br>  Recently, Rockstar on HackerOne also found this problem, but there was no WAF there, and there was only hard filtering of user input: <br><br>  <a href="https://hackerone.com/reports/231444">hackerone.com/reports/231444</a> <br>  <a href="https://hackerone.com/reports/231389">hackerone.com/reports/231389</a> <br><br><h4>  Token Breakers </h4><br>  Attacks aimed at tokenizers are associated with attempts to disrupt the logic of dividing a request into tokens with the help of so-called token breakers.  These are characters that allow you to influence the choice of matching a line item to a specific token, and thus bypass the search by signatures.  An example of an attack using a token breaker is the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>-@<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>()</code> </pre> <br>  where <b>- @</b> - this is the token breaker. <br><br>  In open access there is some cheat sheet, obtained by fuzzing mysql and then checking queries in libinjection, it can be found <a href="https://github.com/attackercan/cpp-sql-fuzzer">here</a> . <br><br>  The topic of finding problems in libinjection has long been new, more details can be found here: <br><br>  <a href="https://github.com/2d8/libinjection-fuzzer">Another phaser</a> <br>  <a href="https://waf.ninja/libinjection-fuzz-to-bypass/">Article once</a> <br>  <a href="https://medium.com/%40d0znpp/how-to-bypass-libinjection-in-many-waf-ngwaf-1e2513453c0f">Article two</a> <br><br><h4>  Using RFC features </h4><br>  In the specifications for the HTTP / 1.1 protocol and various request formats, such as multipart / form-data, you can find some interesting points related to boundary cases or tricks when processing headers and parameters.  WAF developers often do not take into account such moments, which is why WAF can incorrectly parse the request and miss part of the data in which the attacking vector can hide.  Most of the problems in WAF are related to the processing of multipart / form-data and specific values ‚Äã‚Äãof the boundary parameter, which defines the boundaries of the parameters in such requests.  In addition, server developers can also be mistaken and do not always fully support the specifications, which is why undocumented features can be found in the server's HTTP parser. <br><br>  The boundary parameter in an HTTP request with multipart / form-data, as we wrote above, is responsible for distinguishing between various parameters in the request body.  According to the RFC, before each new POST parameter, the previously designated boundary is indicated with a prefix containing ‚Äú-‚Äù, thus the server distinguishes various request parameters. <br><br><pre> <code class="hljs pgsql">POST /vuln.php HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: test.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: multipart/form-data; boundary=<span class="hljs-number"><span class="hljs-number">1049989664</span></span> Content-Length: <span class="hljs-number"><span class="hljs-number">192</span></span> <span class="hljs-comment"><span class="hljs-comment">--1049989664 Content-Disposition: form-data; name="id" 287356 --1049989664--</span></span></code> </pre> <br>  The attack may be that the server and WAF handle the situation differently when the boundary parameter is empty.  Based on the RFC, in such a situation the boundary between the parameters will be a sequence of characters ‚Äú-‚Äù.  However, the WAF can use a parser that does not take into account this feature, which is why WAF will skip the request, because the data from the POST request parameters simply will not get into the analyzer.  The web server, in turn, can parse such a situation without problems and transfer data further for processing. <br><br><pre> <code class="hljs pgsql">POST /vuln.php HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: test.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: multipart/form-data; boundary= Content-Length: <span class="hljs-number"><span class="hljs-number">192</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Content-Disposition: form-data; name="id" 123' or sleep(20)# ----</span></span></code> </pre> <br>  We will give some more interesting examples from the Bo0om <a href="https://www.slideshare.net/ssusera0a306/zeronights-2016-a-blow-under-the-belt-how-to-avoid-wafipsdlp-wafipsdlp">report</a> at ZeroNights 2016 and explain them: <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">POST</span></span> /vuln.php <span class="hljs-type"><span class="hljs-type">HTTP</span></span>/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-type"><span class="hljs-type">Host</span></span>: test.com <span class="hljs-type"><span class="hljs-type">Content</span></span>-<span class="hljs-type"><span class="hljs-type">Type</span></span>: multipart/form-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; boundary=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FIRST</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Content</span></span></span><span class="hljs-class">-</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">: multipart/form-</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; boundary=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SECOND</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Content</span></span></span><span class="hljs-class">-</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">: multipart/form-</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; boundary=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">THIRD</span></span></span><span class="hljs-class">; </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--THIRD Content-Disposition: form-data; name=param UNION SELECT version() --THIRD--</span></span></span></span></code> </pre><br>  In this attack, we are trying to determine which of the boundary parameters will be accepted by WAF and which web server.  Accordingly, if the web server and WAF take on various boundary parameters, it is possible to conduct an attack by specifying a final boundary that WAF will not see.  Such an attack is somewhat similar to HPP. <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">POST</span></span> /vuln.php <span class="hljs-type"><span class="hljs-type">HTTP</span></span>/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-type"><span class="hljs-type">Host</span></span>: test.com <span class="hljs-type"><span class="hljs-type">Content</span></span>-<span class="hljs-type"><span class="hljs-type">Type</span></span>: multipart/form-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; xxxboundaryxxx=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FIRST</span></span></span><span class="hljs-class">; boundary=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SECOND</span></span></span><span class="hljs-class">; </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--FIRST Content-Disposition: form-data; name=param UNION SELECT version() --FIRST--</span></span></span></span></code> </pre><br>  This attack is designed for another possible difference in the HTTP request parsing between the WAF and the web server.  The difference should be as follows, the parser on the side of the web server searches for the first occurrence of the boundary, then searches for the '=' sign and only then determines the value of the boundary, the WAF parser in turn only searches for the entry of the string 'boundary =' and then determines boundary value  If these conditions are met, then upon receiving such a request, WAF will not be able to find the specified boundary and, therefore, will not be able to find and analyze the parameter.  The web server will receive the request and process the parameter.  This attack can work, and vice versa, when the web server parser is looking for an 'boundary =', and the WAF parser is only looking for a 'boundary', in which case you only need to change the real boundary from FIRST to SECOND. <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">POST</span></span> /somepage.php <span class="hljs-type"><span class="hljs-type">HTTP</span></span>/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-type"><span class="hljs-type">Host</span></span>: test.com <span class="hljs-type"><span class="hljs-type">Content</span></span>-<span class="hljs-type"><span class="hljs-type">Type</span></span>: multipart/form-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; boundary=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Test0x00othertext</span></span></span><span class="hljs-class">; </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--Test Content-Disposition: form-data; name=param Attack --Test--</span></span></span></span></code> </pre><br>  This attack is also connected with the addition of special characters.  A null byte has been added to the boundary parameter with the expectation that the web server will cut the boundary parameter to null byte, and WAF will accept it entirely.  In this case, WAF again will not be able to analyze the parameter, since it will not find its boundaries. <br><br><h4>  Learning bypass </h4><br>  The essence of the detour is obvious - to make such an attack that would satisfy the parameters of a trained statistical model.  But it very much depends on how and on which sample WAF was trained.  Sometimes a loophole can be found, and sometimes a detour is not possible in principle.  Typically, when deploying to a client, a machine-learning WAF needs some additional training based on the requests that come into the client's web application.  And the problem for pentesters here may be the following: parameters that have the same appearance or do not vary greatly from request to request will be impossible to test in any way, since any step away from the usual type of parameter may already be perceived as an anomaly.  Let's explain with an example.  Suppose we have a conditional query to <code>http://api.test.com/getuser?id=123</code> , the id parameter is always numeric, and in the training set it also always remained numeric.  If the machine learning module detects anything other than numbers in this parameter, it will most likely decide that this is an anomaly.  In another case, suppose that WAF was trained to classify a POST request to <code>http://api.test.com/setMarkDown</code> with POST parameters in which there is a markaun.  Of course, quotes, special characters, and anything else may be present in Markdown.  In this case, the machine learning module will be much easier to get around, since WAF will be tolerant of quotes and special characters. <br><br>  Also, using examples from practice, we will show that the matter may not always reach the machine learning module, due to the problems with parsing the parameters caused by the circumvention methods described above. <br><br>  In general, it is necessary to take into account the specifics of the test query and the parameters in it, to assume possible options for the values ‚Äã‚Äãof the parameters to which WAF can tolerate, and then to build on them. <br><br><h4>  When does WAF not help? </h4><br>  WAF focuses on analyzing queries and looking for abnormal behavior in them, but there are several classes of vulnerabilities that WAF cannot detect.  These may be any logical vulnerabilities, in this case, the requests do not have any abnormal behavior, but there are some actions that violate the logic of the web application.  WAF is also likely to be useless when detecting vulnerabilities such as race condition, IDOR and unsafe user authentication. <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Existing Applications </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To automate the search for WAF workarounds, there are some tools written by enthusiasts in this area. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the most interesting ones that you should pay attention to: </font></font><br><br> <a href="https://github.com/lightbulb-framework/lightbulb-framework"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lightbulb-framework</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a whole framework for testing WAF-protected web applications. </font><font style="vertical-align: inherit;">It is written in Python and additionally ported as a plugin for Burp Suite. </font><font style="vertical-align: inherit;">Its main feature is two algorithms:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GOFA is an active learning algorithm that allows analyzing filtering and sanitizing parameters in a web application. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFADiff is a black box differential testing algorithm based on learning using symbolic state machines (SFA). </font><font style="vertical-align: inherit;">It allows you to find differences in the operation of web applications, which, in turn, helps identify WAF and find a workaround.</font></font></li></ul><br> <a href="https://portswigger.net/bappstore/bapps/details/ae2611da3bbc4687953a1f4ba6a4e04c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bypass WAF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - plugin for Burp Suite, which allows you to easily configure the automatic change of elements in the request body by various rules and encoding changes, including automates the HPP attack. </font></font><br><br> <a href="https://github.com/EnableSecurity/wafw00f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAFW00F</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a WAF identification program written in Python. </font><font style="vertical-align: inherit;">It has a pretty good base WAF and is maintained to this day. </font><font style="vertical-align: inherit;">However, the result may still be inaccurate, since different WAFs update much faster than the project itself.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bypassing WAF in practice </font></font></h2><br><img src="https://habrastorage.org/webt/59/e4/fc/59e4fc4eee061363676501.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's pass to real cases from our practice. We conducted an audit of some online store, whose site was protected by PT AF. Because of the WAF, it was difficult to find a vulnerable spot that could be repelled and looked for workarounds. But soon non-standard behavior on the part of the web application was discovered, which WAF did not filter. The anomaly was found in the functionality of the search for the history of purchased goods and was as follows: The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">request was transmitted in JSON format and looked like this:</font></font><br><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phone"</span></span>}}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When substituting the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone '</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone' + '</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values ‚Äã‚Äãin the ItemName parameter </font><font style="vertical-align: inherit;">, it was discovered that the server returned different answers for these two cases. The answer to the request with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone '</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was empty, and the answer to the request with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone' + '</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contained the same data about the goods with the word Phone in the title, as if the ItemName parameter would have just the value </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This behavior is familiar to many hackers and pentesters, and clearly indicates that the web application has a problem with filtering user input, which leads, among other things, to SQL injections.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us explain why this happens on the example of SQL injection for those who do not know about it. </font><font style="vertical-align: inherit;">The point is that if this behavior is detected in the web application, then most likely the data for the SQL query is simply concatenated with the query itself, and in the first case, when the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter is passed </font><font style="vertical-align: inherit;">, the SQL query will be generated:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone''</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a request will obviously not be executed due to incorrect syntax and will not return any result. </font><font style="vertical-align: inherit;">And the second request with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phone '+'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter </font><font style="vertical-align: inherit;">, in turn, will look like this:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone'</span></span>+<span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a query has the correct syntax and will fetch goods by the name of Phone. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method of detecting vulnerabilities has a great advantage when testing a web application that is protected by WAF. The single quote character is not considered by most modern WAFs as a sufficient anomaly in the parameter and skips the query with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the detection, we figured out, and how now to bypass the WAF and exploit the vulnerability? After going through some of the workarounds, a problem was found in the WAF under study. It turned out that WAF is vulnerable to special characters added to JSON parameters. In fact, substituting the characters </font><b><font style="vertical-align: inherit;">\ r \ n</font></b><font style="vertical-align: inherit;"> into any JSON text field</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in raw format without any encoding, WAF simply missed the request, and the web application considered the data correct and processed. Apparently, the problem was in the JSON parser, which was not designed for the appearance of special characters and parsed JSON exactly to the place of the appearance of these characters. Thus, an incomplete request got into the WAF analyzer, and after the special characters any attack vector could be inserted. In addition to line breaks, other special characters also worked, for example, null byte. As a result, it was possible to create the following request, which in fact disconnected WAF when trying to verify the entire request (the characters of the line break and carriage return are replaced with their textual representation):</font></font><br><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"kill-waf"</span></span>:<span class="hljs-string"><span class="hljs-string">"die\r\n"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:[<span class="hljs-string"><span class="hljs-string">"'+(SELECT 'Phone'+CHAR(ASCII(substring(@@version,1,1))-24))+'"</span></span>]}}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, it was possible to quickly and conveniently test all the parameters for the presence of any vulnerabilities (as a result, the couple was found in other queries). Bypassing WAF and operating this injection completely compromised all users of the web application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similar problems were also found in Nemesida WAF. The only difference was that the request was not in JSON format, but was a regular POST request with parameters, and the parameter in the web application was substituted into the SQL query as a number. Unfortunately, we can not publish now the technical details, because the developer of Nemesida WAF has forbidden them to publish at the moment. However, we will publish them later. Problems were reported to Pentestit and they were fixed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we see, WAFs can be very modern and very intelligent, but, unfortunately, they can sometimes be circumvented by simply inserting one special character. </font><font style="vertical-align: inherit;">The problem here is that in WAF it is currently impossible to lay all possible input data for all possible servers, and machine learning, which, it would seem, is exactly what WAF needs, stumbles over parsers, which at the sight of some special characters horrified.</font></font><br><br><h2>  Conclusion </h2><br><img align="left" src="https://habrastorage.org/webt/59/e5/54/59e55464f2331285132470.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, is it worth fully relying on WAF? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The answer is no.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, not all developers understand this and for some reason consider WAF a silver bullet from hackers. For example, in one of the audits, we also discovered a WAF workaround that allowed us to exploit vulnerabilities. As we learned after the audit, the developers had already conducted an audit of the web application when it was not yet protected by WAF, and during the last audit these vulnerabilities were already found, but instead of closing them, it was decided to buy modern WAF with machine learning and fully rely on it. It is unfortunate that the WAF vendor did not insist on web application developers fixing known vulnerabilities. Either the developers themselves decided that WAF would protect them better than fixing bugs in the code. But we do not know the details. One way or another, both are very bad practices from both the WAF vendor,and from the developers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would also like to note that while machine learning in WAF remains a black box, it will be perceived rather as a marketing move, rather than a real effective way of protection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, Web Application Firewall is a modern and good protection tool, and it will never be more than enough for your web applications. But it is necessary to remember once and for all that WAF currently only complicates the search for vulnerabilities and their exploitation, and does not completely eliminate you from vulnerabilities. And this situation, apparently, will continue for a long time. You can get rid of vulnerabilities in a web application only by fixing the code that causes these vulnerabilities, otherwise nothing and no one will protect you. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bypassed the WAFs and collected material:</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bulatov Ilya </font></font><a href="https://habrahabr.ru/users/barracud4/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barracud4</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rybin Denis</font></font><a href="https://habrahabr.ru/users/thefaeriedragon/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thefaeriedragon</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexander Romanov </font></font><a href="https://habrahabr.ru/users/web_rock/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">web_rock</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/340144/">https://habr.com/ru/post/340144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340126/index.html">Automation of work with Logs API in AppMetrica. Lecture in Yandex</a></li>
<li><a href="../340132/index.html">Planning practices. Assessment of tasks</a></li>
<li><a href="../340136/index.html">Weekend Reading: 22 independent development, security, testing and game development blogs</a></li>
<li><a href="../340138/index.html">The digest of interesting materials for the mobile developer # 225 (October 9-October 15)</a></li>
<li><a href="../340140/index.html">WiFi roaming - 802.11i / r / k / v / OKC, what we really need and how to recognize it</a></li>
<li><a href="../340146/index.html">Five easy steps for understanding JSON Web Tokens (JWT)</a></li>
<li><a href="../340148/index.html">Digital events for the week</a></li>
<li><a href="../340150/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ284 (October 9 - 15, 2017)</a></li>
<li><a href="../340154/index.html">Change sex and race on a selfie using neural networks</a></li>
<li><a href="../340156/index.html">FrontFest.JS: ClojureScript in production, optimization of React rendering and how to (not) get depressed with Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>