<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate node.js: native modules and CUDA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes developers of various web projects are faced with the need to process large amounts of data or use a resource-intensive algorithm. Older too...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate node.js: native modules and CUDA</h1><div class="post__text post__text-html js-mediator-article">  Sometimes developers of various web projects are faced with the need to process large amounts of data or use a resource-intensive algorithm.  Older tools no longer provide the necessary performance, you have to rent / buy additional computing power, which pushes you to rewrite the slow parts of the code in C ++ or other fast languages. <br><br>  In this article I will discuss how you can try to speed up the work of Node.JS (which in itself is considered to be quite fast).  It's about native extensions written with C ++. <br><a name="habracut"></a><br><h3>  Briefly about extensions </h3><br>  So, you have a web server on Node.JS and you received a task with a resource-intensive algorithm.  To accomplish the task, it was decided to write a module in C ++.  Now we need to deal with what it is - a native extension. <br><br>  Node.JS architecture allows you to connect modules packaged in libraries.  For these libraries js-wrappers are created with which you can call the functions of these modules directly from your server's js-code.  Many standard Node.JS modules are written in C ++, but this does not prevent us from using them with such convenience, as if they were written in javascript itself.  You can pass any parameters into your extension, catch exceptions, execute any code, and return the processed data back. <br>  In the course of the article, we will understand how to create native extensions and perform several performance tests.  For tests, let's take a non-complicated, but resource-intensive algorithm, which we will execute in js and in C ++.  For example - we calculate the double integral. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What to count? </h4><br>  Take the function: <br><img src="https://habrastorage.org/storage2/cfa/ab2/39f/cfaab239f703239cc92966fdfb4b8e88.gif"><br>  This function sets the following surface: <br><img src="https://habrastorage.org/storage2/f68/9af/99e/f689af99eca4d44ff69ea9ac7f369cca.gif"><br>  To find the double integral, we need to find the volume of the figure bounded by this surface.  To do this, divide the shape into a set of parallelepipeds, with a height equal to the value of the function.  The sum of their volumes will give us the volume of the whole figure and the numerical value of the integral itself.  To find the volume of each parallelepiped, we divide the area under the figure into many small rectangles, then multiply their area by the value of our function in points at the edges of these rectangles.  The more parallelepipeds, the higher the accuracy. <br>  The js code that does this integration and shows us the execution time: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(x*y)/(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(x*x+y*y))+<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">integrateJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x0,xN,y0,yN,iterations</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterations; i++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; iterations; j++){ <span class="hljs-comment"><span class="hljs-comment">//    var x = x0 + (xN - x0) / iterations * i; var y = y0 + (yN - y0) / iterations * j; var value = func(x, y); //   //        result+=value*(xN-x0)*(yN-y0)/(iterations*iterations); } } console.log("JS result = "+result); console.log("JS time = "+(new Date().getTime() - time)); }</span></span></code> </pre> <br><h3>  Preparing to write an extension </h3><br>  Now we will perform all the same operations on C ++.  Personally, I used Microsoft Visual Studio 2010. First we need to download the source code for Node.JS.  Go to the <a href="http://nodejs.org/download/">official website</a> and pull up the latest version of the source.  In the source folder is the file vcbuild.bat, which creates the necessary projects for Visual Studio and configs.  The installed Python is required for the batch file to work.  If you do not have it - we put off the <a href="http://www.python.org/">off site</a> .  We set the paths to python in the Path environment variable (for Python 2.7, these will be C: \ Python27; C: \ Python27 \ Scripts).  Run the batch file, get the necessary files.  Next, create the .cpp file of our module.  Further we write the description of our module in json-format: <br><br><pre> <code class="javascript hljs"> { <span class="hljs-string"><span class="hljs-string">"targets"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"target_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"funcIntegrate"</span></span>, <span class="hljs-string"><span class="hljs-string">"sources"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"funcIntegrate.cpp"</span></span> ] } ] }</code> </pre><br>  Save as binding.gyp and set the <a href="https://github.com/TooTallNate/node-gyp">utility</a> on it, which we install using npm.  This utility creates a properly configured vcxproj studio file for windows or a linux makefile.  Just one comrade was created batch file, even more simplifies setting up and creating a project for the studio.  You can take from him, along with an example <a href="http://botsikas.blogspot.com/2011/12/building-simple-native-nodejs-module-on.html">helloworld-module</a> .  Edit the file, run the batch file - get the ready .node module.  You can create a Visual Studio project manually and also manually enter all the settings - set the paths to the libs and headers, node.js, configuration type set to .dll, the target extension is .node. <br><br><h3>  Native extension </h3><br>  Everything is set up, start writing the code. <br><br>  In the .cpp file, we must declare the class inherited from ObjectWrap.  All methods of this class must be static. <br>  There must be an initialization function that we drive into the NODE_MODULE macro.  In the initialization function using the NODE_SET_PROTOTYPE_METHOD macro, we specify the methods that will be available from Node.JS.  We can receive the passed parameters, check their number and types and, if necessary, throw exceptions.  A detailed description of all the necessary things to create an extension you can find <a href="http://nodejs.org/api/addons.html">here.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs django"><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">node.h</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">v8.h</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">math.h</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> using namespace node; using namespace v8; //,       js float func(float x, float y){ return sin(x*y)/(1+sqrt(x*x+y*y))+2; } char* funcCPU(float x0, float xn, float y0, float yn, int iterations){ double x,y,value,result; result=0; for (int i = 0; i </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">iterations</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++){ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">iterations</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++){ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">x0</span></span></span></span><span class="xml"><span class="hljs-tag"> + (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">xn</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x0</span></span></span></span><span class="xml"><span class="hljs-tag">) / </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">iterations</span></span></span></span><span class="xml"><span class="hljs-tag"> * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">y0</span></span></span></span><span class="xml"><span class="hljs-tag"> + (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">yn</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">y0</span></span></span></span><span class="xml"><span class="hljs-tag">) / </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">iterations</span></span></span></span><span class="xml"><span class="hljs-tag"> * </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">func(x,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">result</span></span></span></span><span class="xml"><span class="hljs-tag">+=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">value*(xn-x0)*(yn-y0)/(iterations*iterations);</span></span></span></span><span class="xml"><span class="hljs-tag"> } } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">char</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">new</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">char</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">20</span></span></span></span><span class="xml"><span class="hljs-tag">]; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sprintf</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag">,"%</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">f</span></span></span></span><span class="xml"><span class="hljs-tag">",</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">result</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag">; } //  ,    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ObjectWrap</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">funcIntegrate:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ObjectWrap</span></span></span></span><span class="xml"><span class="hljs-tag">{ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">public:</span></span></span></span><span class="xml"><span class="hljs-tag"> //</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag">        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">static</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">static</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">void</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Init</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Handle</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Object</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> target){ HandleScope scope; Local</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FunctionTemplate</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> t = FunctionTemplate::New(New); Persistent</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FunctionTemplate</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> s_ct = Persistent</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FunctionTemplate</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">::New(t); s_ct-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1); //    javascript s_ct-&gt;SetClassName(String::NewSymbol("NativeIntegrator")); //,   javasript NODE_SET_PROTOTYPE_METHOD(s_ct, "integrateNative", integrateNative); target-&gt;Set(String::NewSymbol("NativeIntegrator"),s_ct-&gt;GetFunction()); } funcIntegrate(){ } ~funcIntegrate(){ } //    Node.JS      new static Handle</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> New(const Arguments&amp; args){ HandleScope scope; funcIntegrate* hw = new funcIntegrate(); hw-&gt;Wrap(args.This()); return args.This(); } // ,   javasript static Handle</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> integrateNative(const Arguments&amp; args){ HandleScope scope; funcIntegrate* hw = ObjectWrap::Unwrap</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">funcIntegrate</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(args.This()); //   args,    double   funcCPU. //     Local</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">String</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> result = String::New(funcCPU(args[0]-&gt;NumberValue(),args[1]-&gt;NumberValue(),args[2]-&gt;NumberValue(),args[3]-&gt;NumberValue(),args[4]-&gt;NumberValue())); return scope.Close(result); } }; extern "C" { static void init (Handle</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Object</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> target){ funcIntegrate::Init(target); } NODE_MODULE(funcIntegrate, init); };</span></span></code> </pre><br></div></div><br>  Compiling this code we get a .node file (a regular DLL with a different extension) that can be connected to our Node.JS project.  The file contains the prototype of the jative object NativeIntegrator, which has an integrateNative method.  Let's connect the received module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> funcIntegrateNative = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./build/funcIntegrate.node"</span></span>); nativeIntegrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> funcIntegrateNative.NativeIntegrator(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">integrateNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x0,xN,y0,yN,iterations</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); result=nativeIntegrator.integrateNative(x0,xN,y0,yN,iterations); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Native result = "</span></span>+result); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Native time = "</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime() - time)); }</code> </pre><br>  Add this code to the already finished project on Node.JS, call the functions, compare: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ integrateJS(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); integrateNative(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); } main();</code> </pre><br>  We get the result: <br>  JS result = 127.99999736028109 <br>  JS time = 127 <br>  Native result = 127.999997 <br>  Native time = 103 <br><br>  The difference is minimal.  Increase the number of iterations on axes by 8 times.  We obtain the following results: <br><br>  JS result = 127.99999995875444 <br>  JS time = 6952 <br>  Native result = 128.000000 <br>  Native time = 6658 <br><br><h3>  findings </h3><br>  The result is surprising.  We have received almost no winnings.  The result on Node.JS is obtained almost exactly the same as that obtained on pure C ++.  We guessed that the V8 is a fast engine, but so much so ... Yes, even purely mathematical operations can be written in pure js.  We will lose a little from this, if we lose anything at all.  To get the benefits of native expansion, we need to use low-level optimization.  But it will be too much.  The performance gain from the native module does not always pay back the cost of writing a sishnogo or even assembly code.  What to do?  The first thing that comes to mind is the use of openmp or native streams to solve the problem in parallel.  This will speed up the solution of each individual task, but will not increase the number of tasks solved per unit of time.  So this solution is not for everyone.  The load on the server will not decrease.  Perhaps we will also get a win when working with large amounts of memory - Node.JS will still have additional overhead and the total occupied memory will be more.  But memory is now far from being as critical as CPU time.  What conclusions can we draw from this study? <br><br><ul><li>  Node.JS is really very fast.  If you do not know how to write high-quality C ++ code with low-level optimization, then there is no point in trying to write a native extension to speed up performance.  You just get extra problems. <br></li><li>  Use native extensions where you really need it ‚Äî for example, where you need access to some system API that is not in Node.JS. <br></li></ul><br><h3>  We need to go deeper </h3><br>  But let's try to speed up the work of our code?  Since we have access from the native extension to anything, that is, access to the video card.  We use CUDA! <br><br>  For this we need the CUDA SDK, which can be found on <a href="http://developer.nvidia.com/cuda/cuda-downloads">the Nvidia website</a> .  I will not talk here about the installation and configuration, for this, and so there are many manuals.  After installing the SDK, we need to make some changes to the project - rename the source from .cpp to .cu.  Add CUDA support to build settings.  Add the necessary dependencies to the CUDA compiler settings.  Here is the new extension code, with comments on changes and additions: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;node.h&gt; #include &lt;v8.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.h&gt; #include &lt;cuda_runtime.h&gt; //  CUDA using namespace node; using namespace v8; //  __device__ __host__ //      CPU,    GPU. __device__ __host__ float func(float x, float y){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x*y)/(<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x*x+y*y))+<span class="hljs-number"><span class="hljs-number">2</span></span>; } //__global__ -   CPU,   GPU __global__ void funcGPU(float x0, float xn, float y0, float yn, float *result){ float x = x0 + (xn - x0) / gridDim.x * blockIdx.x; float y = y0 + (yn - y0) / blockDim.x * threadIdx.x ; float value = func(x, y); result[gridDim.x * threadIdx.x + blockIdx.x] = value*(xn-x0)*(yn-y0)/(gridDim.x*blockDim.x); } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* funcCPU(float x0, float xn, float y0, float yn, int iterations){ double x,y,value,result; result=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterations; i++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; iterations; j++){ x = x0 + (xn - x0) / iterations * i; y = y0 + (yn - y0) / iterations * j; value = func(x, y); result+=value*(xn-x0)*(yn-y0)/(iterations*iterations); } } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *c = new <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>[<span class="hljs-number"><span class="hljs-number">20</span></span>]; sprintf(c,<span class="hljs-string"><span class="hljs-string">"%f"</span></span>,result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } class funcIntegrate: ObjectWrap{ private: static dim3 gridDim; //    static dim3 blockDim; static float *result; static float *resultDev; public: static void Init(Handle&lt;Object&gt; target){ HandleScope scope; Local&lt;FunctionTemplate&gt; t = FunctionTemplate::New(New); Persistent&lt;FunctionTemplate&gt; s_ct = Persistent&lt;FunctionTemplate&gt;::New(t); s_ct-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class="hljs-number"><span class="hljs-number">1</span></span>); s_ct-&gt;SetClassName(String::NewSymbol(<span class="hljs-string"><span class="hljs-string">"NativeIntegrator"</span></span>)); NODE_SET_PROTOTYPE_METHOD(s_ct, <span class="hljs-string"><span class="hljs-string">"integrateNative"</span></span>, integrate); //     GPU,  Node.JS NODE_SET_PROTOTYPE_METHOD(s_ct, <span class="hljs-string"><span class="hljs-string">"integrateCuda"</span></span>, integrateCuda); target-&gt;Set(String::NewSymbol(<span class="hljs-string"><span class="hljs-string">"NativeIntegrator"</span></span>),s_ct-&gt;GetFunction()); //   CUDA gridDim.x = <span class="hljs-number"><span class="hljs-number">256</span></span>; blockDim.x = <span class="hljs-number"><span class="hljs-number">256</span></span>; result = new float[gridDim.x * blockDim.x]; cudaMalloc((void**) &amp;resultDev, gridDim.x * blockDim.x * sizeof(float)); } funcIntegrate(){ } ~funcIntegrate(){ cudaFree(resultDev); } //    static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* cudaIntegrate(float x0, float xn, float y0, float yn, int iterations){ cudaEvent_t start, stop; cudaEventCreate(&amp;start); cudaEventCreate(&amp;stop); //    CPU  GPU //           GPU - //      bCount,   //  GPU   int bCount = iterations/gridDim.x; float bSizeX=(xn-x0)/bCount; float bSizeY=(yn-y0)/bCount; double res=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bCount; i++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bCount; j++){ cudaEventRecord(start, <span class="hljs-number"><span class="hljs-number">0</span></span>); //  //   GPU funcGPU&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(x0+bSizeX*i, x0+bSizeX*(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), y0+bSizeY*j, y0+bSizeY*(j+<span class="hljs-number"><span class="hljs-number">1</span></span>), resultDev); cudaEventRecord(stop, <span class="hljs-number"><span class="hljs-number">0</span></span>); cudaEventSynchronize(stop); //  //    GPU    cudaMemcpy(result, resultDev, gridDim.x * blockDim.x * sizeof(float), cudaMemcpyDeviceToHost); //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;gridDim.x * blockDim.x; k++) res+=result[k]; } } cudaEventDestroy(start); cudaEventDestroy(stop); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *c = new <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>[<span class="hljs-number"><span class="hljs-number">200</span></span>]; sprintf(c,<span class="hljs-string"><span class="hljs-string">"%f"</span></span>, res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } static Handle&lt;Value&gt; New(const Arguments&amp; args){ HandleScope scope; funcIntegrate* hw = new funcIntegrate(); hw-&gt;Wrap(args.This()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.This(); } static Handle&lt;Value&gt; integrate(const Arguments&amp; args){ HandleScope scope; funcIntegrate* hw = ObjectWrap::Unwrap&lt;funcIntegrate&gt;(args.This()); Local&lt;String&gt; result = String::New(funcCPU(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">3</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">4</span></span>]-&gt;NumberValue())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope.Close(result); } //     CUDA static Handle&lt;Value&gt; integrateCuda(const Arguments&amp; args){ HandleScope scope; funcIntegrate* hw = ObjectWrap::Unwrap&lt;funcIntegrate&gt;(args.This()); Local&lt;String&gt; result = String::New(cudaIntegrate(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;NumberValue() ,args[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">3</span></span>]-&gt;NumberValue(),args[<span class="hljs-number"><span class="hljs-number">4</span></span>]-&gt;NumberValue())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope.Close(result); } }; extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> { static void init (Handle&lt;Object&gt; target){ funcIntegrate::Init(target); } NODE_MODULE(funcIntegrate, init); }; dim3 funcIntegrate::blockDim; dim3 funcIntegrate::gridDim; float* funcIntegrate::result; float* funcIntegrate::resultDev;</code> </pre><br></div></div><br>  Write a handler on js: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">integrateCuda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x0,xN,y0,yN,iterations</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); result=nativeIntegrator.integrateCuda(x0,xN,y0,yN,iterations); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"CUDA result = "</span></span>+result); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"CUDA time = "</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime() - time)); }</code> </pre><br>  Let's start testing on the following data: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ integrateJS(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); integrateNative(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); integrateCuda(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); }</code> </pre><br>  Get the results: <br><br>  JS result = 127.99999736028109 <br>  JS time = 119 <br>  Native result = 127.999997 <br>  Native time = 122 <br>  CUDA result = 127.999997 <br>  CUDA time = 17 <br><br>  As we see, the handler on the video card already shows a strong lead.  And this is despite the fact that I summarized the results of the work of each video card stream on the CPU.  If you write an algorithm that runs entirely on the GPU, without using a central processor, the performance gain will be even more tangible. <br>  We test on the following data: <br><br><pre> <code class="javascript hljs"> integrateJS(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">16</span></span>); integrateNative(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">16</span></span>); integrateCuda(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">16</span></span>);</code> </pre><br>  We get the result: <br>  JS result = 127.99999998968899 <br>  JS time = 25401 <br>  Native result = 128.000000 <br>  Native time = 28405 <br>  CUDA result = 128.000000 <br>  CUDA time = 3568 <br><br>  As we can see, the difference is huge.  An optimized algorithm at CUDA would give us a performance difference of more than an order of magnitude.  (And the C ++ code on this test even fell behind Node.JS in performance). <br><br><h3>  Conclusion </h3><br>  The situation considered by us is rather exotic.  Resource-intensive computing on a web server with Node.JS, which is installed on a machine with a video card that supports CUDA technology.  This is not often seen.  But if you ever have to deal with such a thing - you know, such things are real.  In fact, you can embed any piece that you can write in C ++ into your Node.JS server.  That is, anything. <br><div class="spoiler">  <b class="spoiler_title">Useful links for creating native extensions</b> <div class="spoiler_text">  <a href="http://nodejs.org/api/addons.html">nodejs.org/api/addons.html</a> <br>  <a href="http://botsikas.blogspot.com/2011/12/building-native-modules-for-nodejs-06.html">botsikas.blogspot.com/2011/12/building-native-modules-for-nodejs-06.html</a> <br>  <a href="https://www.cloudkick.com/blog/2010/aug/23/writing-nodejs-native-extensions/">www.cloudkick.com/blog/2010/aug/23/writing-nodejs-native-extensions</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/151117/">https://habr.com/ru/post/151117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151111/index.html">Three month programmer</a></li>
<li><a href="../151112/index.html">Image Blur Filter Kuwahara</a></li>
<li><a href="../151113/index.html">Raspberry Pi and Blue Electrical Tape</a></li>
<li><a href="../151114/index.html">Nokia Lumia 920: Real Photos</a></li>
<li><a href="../151116/index.html">Safe dose of coffee</a></li>
<li><a href="../151118/index.html">Mobile application monetization - LoopMe Media</a></li>
<li><a href="../151122/index.html">Making a Wi-Fi antenna out of available tools.</a></li>
<li><a href="../151123/index.html">BigVideo.js: full screen background video</a></li>
<li><a href="../151124/index.html">Happy Tester's Day '12!</a></li>
<li><a href="../151125/index.html">Simulator for testing software APCS: Example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>