<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Not) safe frontend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 
 Not so long ago I spoke at the FrontendConf 2015 (RIT ++) conference with the topic of this article. And when preparing the report, I began to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Not) safe frontend</h1><div class="post__text post__text-html js-mediator-article"><h1>  <font color="#56A5EC">Intro</font> </h1><br>  Not so long ago I spoke at the <a href="http://frontendconf.ru/2015/abstracts/1769">FrontendConf 2015</a> (RIT ++) conference with the topic of this article.  And when preparing the report, I began to look for information, and who spoke at all on this topic and what is on the web at the moment. <br><br>  It turned out that quite a bit of information, more or less one could mention the report by Mike West from Google, <a href="https://mikewest.org/2013/09/frontend-security-frontendconf-2013">mikewest.org/2013/09/frontend-security-frontendconf-2013</a> , but some kind of "non-penster" look and very little material .  And <a href="http://www.slideshare.net/eoftedal/web-application-security-in-front-end">www.slideshare.net/eoftedal/web-application-security-in-front-end</a> where the topic is <a href="http://www.slideshare.net/eoftedal/web-application-security-in-front-end">covered in</a> more detail, but the 2011 presentation.  And for 4 years, technology and attacks in place did not stand. <br><br>  It‚Äôs long and difficult to choose topics, what to tell the front-end developers about security, while at the same time touching the backend (in some places it‚Äôs still indivisible), we got a report, and here‚Äôs a text retelling. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  <font color="#56A5EC">What do you talk about?</font> </h1><br>  And really, what is there to talk about?  Speaking about hacks and security, involuntarily theses come to mind - they merged the database, got access to the execution of OS commands on the server, read someone else's correspondence.  But this is all - server side code.  And what can "pile up" a front-end?  The main danger, of course, is bypassing the attacking SOP - the Same Origin Policy, the main browser security policy that regulates work in different Origin.  But not only, let's understand. <br><br><a name="habracut"></a><br><h1>  <font color="#56A5EC">Crossite scripting</font> </h1><br><img src="https://habrastorage.org/files/291/03a/242/29103a242077459cacd9a5c8b820cc70.png"><br>  <i>Cross Site Scripting</i> <br>  The XSS theme is trashed as much as possible, but usually it‚Äôs about incorrect processing of parameters on the server side (an attacker can embed his JS code into the page and execute it, including in the victim‚Äôs browser, on behalf of the vulnerable origin, the result is an SOP bypass).  And there they identified 2 types of XSS attacks - stored (‚Äúevil‚Äù js is stored on the server) and reflected (given by the server without saving). <br><br>  Well, what about the front-end?  And here is another case - the attacker's JS is not transmitted to the server (with some exceptions, but the point is not in them), but is embedded in the DOM at the expense of legitimate JS code.  Hence the name for the third type of XSS attack, the DOM XSS. <br><br>  A typical example of vulnerable JS code: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.write(<span class="hljs-string"><span class="hljs-string">"Site is at: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.href);</code> </pre> <br>  Now open the page at <br><br><pre> <code class="bash hljs">http://victim.com/action<span class="hljs-comment"><span class="hljs-comment">#&lt;script&gt;alert('xss')&lt;/script&gt;—ï</span></span></code> </pre><br>  JS will add the value of document.location.href to the tree, where the ‚Äúmalicious‚Äù js is inserted.  As you can already see from this example, to search for vectors for this type of attack, we need two things: to influence something in the user's browser (sources) and to do something (sinks). <br><br>  Examples of "sources" (sources): <br><ul><li>  document.URL </li><li>  location </li><li>  document.referrer </li><li>  window.name </li><li>  localStorage </li><li>  cookies </li></ul><br><br>  Sinks examples <br><ul><li>  eval </li><li>  document.write </li><li>  (element) .innerHTML </li><li>  (element) .src </li><li>  setTimeout / setInterval </li><li>  execScript </li></ul><br>  For more information on this topic, please click on the links - <a href="https://code.google.com/p/domxsswiki/">code.google.com/p/domxsswiki</a> (and get a regular search from here to find potential vulnerabilities) and <a href="http://habrahabr.ru/company/xakep/blog/189210/">habrahabr.ru/company/xakep/blog/189210</a> , an article from my colleague Alexei Tyurin <br><br>  Here is an example of a vulnerable code (real) from twitter.com ( <a href="http://blog.mindedsecurity.com/2010/09/twitter-domxss-wrong-fix-and-something.html">full story</a> ) <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a=location.href.split(<span class="hljs-string"><span class="hljs-string">"#!"</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a){g.location=g.HBR=a;}})(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>);</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/77e/695/f34/77e695f34bca9e1f8f775abde7a6e1d4.jpg" alt="image"><br>  <i>DOM XSS example on twititer.com</i> <br><br><h1>  <font color="#56A5EC">Information leaks</font> </h1><br>  It often happens that JS / CSS files contain information about the system infrastructure. <br><br><h2>  <font color="#56A5EC">About javascript</font> </h2><br>  When projects become very large and different environments for an application enter (test / dev / prod), the crutches and definition start, including on the client, in what environment you need to work. <br><br>  An example of such a real file, mail.ru - <a href="">img.imgsmail.ru/r/webagent/release/loader.js</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dl = (<span class="hljs-string"><span class="hljs-string">''</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location), host = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.host, branch = <span class="hljs-string"><span class="hljs-string">'master'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'release/467'</span></span>, base = <span class="hljs-string"><span class="hljs-string">'r/webagent/'</span></span>, probability = [ {<span class="hljs-string"><span class="hljs-string">"branch"</span></span>: <span class="hljs-string"><span class="hljs-string">"wa-514"</span></span>, <span class="hljs-string"><span class="hljs-string">"deprecated"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} ], lastForcedVersion = <span class="hljs-string"><span class="hljs-string">'20131126154524'</span></span>, isLocalhost = dl.indexOf(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>, testServer = host.match(<span class="hljs-regexp"><span class="hljs-regexp">/[^.]+\.((?:f|my\.rapira)\d*)\.mail\.ru/</span></span>), devServer = host.match(<span class="hljs-regexp"><span class="hljs-regexp">/^.+\.dev\.mail\.ru$/</span></span>), isRapira = testServer &amp;&amp; testServer[<span class="hljs-number"><span class="hljs-number">1</span></span>].indexOf(<span class="hljs-string"><span class="hljs-string">'my.rapira'</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>, utf = <span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-comment"><span class="hljs-comment">//!!window.IS_UTF, domainProps = {}, domain = '//img.imgsmail.ru', login = getUserLogin(), useBranch = (dl.match(/\Wwa_use_branch=([a-z0-9-]*)/i)||[0,false])[1], useLang = (dl.match(/\Wwa_lang=([az]{2})/i)||[0,false])[1], useOnce = (dl.match(/\Wbranch=([a-z0-9-]*)/i)||[0,false])[1], appVersion = (dl.match(/\Wwa_appver=([\.0-9]*)/i)||[0,false])[1], usedBranch = branch;</span></span></code> </pre><br>  As can be seen from the file, by regulars, you can define domains (and pull down valid ones?) For tests and development.  In this case, the information may not be very critical (if mail.ru is up to date), but sometimes there are also such constructions: <br><br><pre> <code class="javascript hljs">internalDevHOST = <span class="hljs-string"><span class="hljs-string">'172.16.22.2'</span></span>; internalProdHOST = <span class="hljs-string"><span class="hljs-string">'172.16.22.5'</span></span>;</code> </pre><br>  And sometimes with external IPs (although internal ones can also be useful, for example, with SSRF). <br><br><h2>  <font color="#56A5EC">CSS</font> </h2><br>  CSS is the same.  Projects are growing, developers are starting to use various ‚Äúcollectors‚Äù who just leave and leave ‚Äútasty‚Äù information, for example - <a href="https://hackerone.com/reports/2221">hackerone.com/reports/2221</a> <br><br><pre> <code class="bash hljs">file\:\/\/\/applications\/hackerone\/releases\/20140221175929\/app\/assets\/stylesheets\/application\/browser-not-supported\.scss file\:\/\/\/applications\/hackerone\/releases\/20140221175929\/app\/assets\/stylesheets\/application\/modules\/add-category\.scss file\:\/\/\/applications\/hackerone\/releases\/20140221175929\/app\/assets\/stylesheets\/application\/modules\/<span class="hljs-built_in"><span class="hljs-built_in">alias</span></span>-preview\.scss ...</code> </pre><br><h1>  <font color="#56A5EC">MVC frameworks</font> </h1><br>  Various JS MVC frameworks are becoming more popular: AngularJS, Knockout, EmberJS, etc.  They are very cool, they allow you to expand your work with the DOM, create new elements (), create "binding", etc.  Naturally, something new could not pass unnoticed by the world of security. <br><br>  In particular, we are interested in logic-less templates. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"phone in phones"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>{{phone.name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{{phone.snippet}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Which allow to significantly reduce the number of "copy-paste" and assign values ‚Äã‚Äãto the specified variables inside the brackets. <br><br>  Or a mustache, if the bracket is rotated 90 ¬∞.  Mustache!  <a href="http://mustache.github.io/">mustache.github.io</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f7/61a/abc/0f761aabce5b2716f2a50898140f8bab.jpg" alt="image"><br><br>  This is how the mustache security project, code.google.com/p/mustache-security, <a href="https://code.google.com/p/mustache-security/">appeared</a> , about the security of MVC frameworks.  Already have information about: <br><br><ul><li>  Vuejs </li><li>  AngularJS </li><li>  Canjs </li><li>  Underscore.js </li><li>  Knockoutjs </li><li>  Ember.js </li><li>  Polymer </li><li>  Ractive.js </li><li>  jQuery </li><li>  Jsrender </li><li>  Kendo ui </li></ul><br>  So let's go back, what bad can happen here?  Take AngularJS.  For example, there are situations when an attacker just falls just inside these brackets.  And of them somehow you need to run your JS, but this is not possible by default.  The task is to bypass the sandbox. <br><br>  Example with AngularJS (1.1.5) <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ng-app"</span></span></span><span class="hljs-tag">&gt;</span></span> {{constructor.constructor('alert(1)')()}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  So, it‚Äôs still not very tricky in the AngularJS version &lt;1.1.5, you could get out of the sandbox and ‚Äúreach‚Äù the window object (in the example above, just call alert (1)), the entire browser window.  Google released the fix, and ... <br><br>  AngularJS (1.2.18), after fixes <br><br><pre> <code class="html hljs xml">{{ (_=''.sub).call.call({}[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')() }}</code> </pre><br>  The desired alert (1) is also received! <br><br>  So what am I.  Updating the framework is important not only for functionality, but also for security! <br><br><h1>  <font color="#56A5EC">Cookies</font> </h1><br>  Considering this point, we are already starting to touch on a little backend.  But quite a bit. <br>  How do cookies are usually set on the server side? <br><br>  PHP example: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> setcookie(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>,<span class="hljs-string"><span class="hljs-string">'bar1'</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br>  Python example: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Cookie C = Cookie.SimpleCookie() C[<span class="hljs-string"><span class="hljs-string">"foo"</span></span>] = <span class="hljs-string"><span class="hljs-string">"bar"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> C</code> </pre><br><br>  Both in the first and in the second case the server will respond with the header: <br><pre> <code class="bash hljs">Set-Cookie: foo=bar</code> </pre><br>  Those.  just tell the browser, set the bar value to the foo key.  But you need to think it over and check yourself by checklist: <br><ol><li>  Specify the domain to set cookies.  In the example above, IE will set cookies for both the current subdomain and all subdomains.  Those.  if XSS is found on some ‚Äúleft‚Äù subdomain, the data may be compromised.  <a href="http://habrahabr.ru/post/143276/">More details</a> . </li><li>  HttpOnly flag for session values ‚Äã‚Äã(phpsessid, for example, defaults without it).  It is necessary for the browser to deny access to this value from JS (when XSS reduces the risk of theft of the user account) </li><li>  The Secure flag in case the site works only over HTTPS and there is no need to send important values ‚Äã‚Äãthrough an insecure channel. </li></ol><br><br><h1>  <font color="#56A5EC">Switch to HTTPS</font> </h1><br>  The third paragraph was about HTTPS.  And let's just discuss this, because it is directed just to work with the browser.  Including  transitions are usually server administration issues - choosing a certificate, setting up a web server, and when ready - <b>redirecting from HTTP to HTTPS</b> <br><br>  As it happens in life.  Admin puts a redirect when entering the site via HTTP on HTTPS and that's it.  But just this moment, the user initially comes in via HTTP and it is at this moment that you can ‚Äúdrop‚Äù the redirect to HTTPS and proxy the traffic further, without giving the user the HTTPS version of the site. <br><br>  Why do people come to the site also via HTTP?  Because for all of them in bookmarks everything is also HTTP. <br><br>  Let's take a look at the cool story :) <br><br><img src="https://habrastorage.org/files/4ab/56e/ac3/4ab56eac30704015b7d6b2800db23144.jpg"><br>  <i>The story is right below this picture.</i> <br><br>  <font color="white">I can not tell you about the "beloved" VK.</font>  <font color="white">Now the wave of ‚Äúhijackings‚Äù of accounts in the VC has passed / is going on.</font>  <font color="white">Most often, these are just hacked users' routers (there are enough vulnerabilities in the routers) with modified DNS servers, on which VC addresses are different, namely ‚Äúmalicious servers of malicious intruders‚Äù.</font>  <font color="white">They just use this trick, do not allow the user to visit the HTTPS version of the site, ‚Äúrejecting‚Äù the redirect, since users of the site are still in mortgages on the HTTP version (daw on h_ttps: //vk.com/settings? Act = security yet not forced https).</font> <br><br>  So how to treat? <br>  For this came up with the HSTS header <br><pre> <code class="bash hljs">Strict-Transport-Security: max-age=31536000;</code> </pre><br>  He tells the browser that on this site via HTTP no more request.  Specifies the time during which this rule works (and optionally, you can set the distribution of this rule to subdomains). <br><br>  And if you turn on the paranoid mode and imagine that the first time you visit the site, the traffic is intercepted and the user does not receive this header - then you can add your resource to the HSTS preload list - <a href="http://www.chromium.org/hsts">www.chromium.org/hsts</a> , a list of resources for which the browser will always be visit via HTTPS (i.e. the resource list is ‚Äúsewn up‚Äù directly into the browser, shared between browsers). <br><br><h1>  <font color="#56A5EC">HTML5 Security</font> </h1><br>  The article is quite large, do not despair: 0 Talking about HTML5, not only in the context of new elements, but also new API methods, it (HTML5) brought a lot of useful and safe, including  on cross domain work.  And what did they not invent, and the files ‚Äúproxy.php‚Äù in the root of the server, and other awful crutches. <br><br><h2>  <font color="#56A5EC">Window.postMessage ()</font> </h2><br>  Imagine that we have two window objects (for example, the current window and the window from the iframe or after window.open). <br><br>  A page on the abc.com domain sends a ‚Äúsecret‚Äù message to another window. <br><pre> <code class="javascript hljs">otherWindow.postMessage(message, targetOrigin);</code> </pre><br><br>  A page on the xyz.com domain listens to messages and checks where they came from <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, receiveMessage, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiveMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.origin !== <span class="hljs-string"><span class="hljs-string">"http://example.org:8080"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><br>  In general, this option is correct - specify origin, where to send (so as not to send to the attacker in the ‚Äúwindow‚Äù), and receive, checking where the message came from.  But in reality, this is rarely the case, and more often you need such a solution for the entire project (all subdomains) <br><br>  <b>Vulnerable code!</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(message.orgin.indexOf(<span class="hljs-string"><span class="hljs-string">".example.com"</span></span>)!=<span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  And sometimes you can find such a <b>vulnerable</b> code.  example.com.attacker.com is also matched (attacker's domain).  So that: <br><br><ul><li>  We check where we send the data </li><li>  Checking where they got them </li><li>  Recheck our checks to not get as above </li></ul><br><br><h2>  <font color="#56A5EC">HTTP access control (CORS)</font> </h2><br>  And again about cross-domain work.  CORS is a cool, fashionable, safe thing that is hard to put on.  Very difficult, but ... it happens :) <br><br>  It also allows the browser to tell you how to work around SOP.  When cross-domain operation and the first OPTIONS request, the server returns something of the type <br><pre> <code class="bash hljs">Access-Control-Allow-Origin: *</code> </pre><br>  Or <br><pre> <code class="bash hljs">Access-Control-Allow-Origin: example.com</code> </pre><br>  In the first case, it is reported that it is possible to bypass the SOP to work from any domain, in the second - only with example.com.  In this case, you can specify the methods by which it is available, etc. <br><br>  But by default, the identification data (for example, cookies) the browser still does not send, which is most often necessary.  Need to add a headline <br><pre> <code class="bash hljs">Access-Control-Allow-Credentials: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Which will inform the browser that now do cross-domain requests together with cookies (allows you to work with the user session).  But!  The most interesting thing is that Allow-Origin already confusing: * (any site) + Allow-Credentials do not work together.  The browser will not send cookies and this is good (as in this case, the attacker will not be able to perform actions from the user with the session).  Those.  This option works only when specifically allowed domains. <br><br>  About "it happens."  The developer specifies the allowed domains from the GET parameter (curtain). <br><br><h2>  <font color="#56A5EC">Web sockets</font> </h2><br>  Speaking about Web Sockets (WS), first of all, it should be noted that for them there are several standards with quite significant changes.  Therefore, there are quite common things here. <br><br><ul><li>  There is no authorization in WS (each finishes himself) </li><li>  WS - transmit data in unencrypted form.  WSS should be used for important data. </li><li>  No one has canceled data validation in them, either on the server (an attacker can also write his data to the socket) and on the client </li><li>  Check Origin, from where the data came, does not cancel p.1 </li><li>  ... </li></ul><br>  Here I‚Äôll just refer to owasp.org, busy reading - <a href="https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet">www.owasp.org/index.php/HTML5_Security_Cheat_Sheet</a> , albeit incomplete (in addition to service workers - <a href="http://sirdarckcat.blogspot.ru/2015/05/service-workers-secure-open-redirect.html">sirdarckcat.blogspot.ru/2015/05/service-workers-secure -open-redirect.html</a> , <a href="http://sirdarckcat.blogspot.ru/2015/05/service-workers-new-apis-new-vulns-fun.html">sirdarckcat.blogspot.ru/2015/05/service-workers-new-apis-new-vulns-fun.html</a> ) <br><br><h2>  <font color="#56A5EC">Content Security Policy</font> </h2><br>  In general, the browser he is so trusting, from where he was told to upload data - CSS / JS / images, he downloaded from there.  It is also useful for an attacker, just connect your malicious js file from another domain during an XSS attack.  To reduce the risks of XSS attacks (and not only) came up with Content Security Policy (CSP). <br><br>  This header tells the browser where you can load resources (for example, js), and where you cannot.  Accordingly, an attacker even having the ability to inject js will not be able to perform it (for example, if inline js + external domains from trusted domains are prohibited). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b54/ead/b59/b54eadb59cdfef5166e12d5f1fb16f16.png" alt="image"><br>  <i>Error loading JS file from a domain that is not in the white list</i> <br><br>  But it so happens that an attacker can still upload his js and execute it, for example, if applications (to a letter, message) are on a domain from the white list. <br><br>  CSP understood it in more detail many times, including at the last meeting of OWASP Russia in Moscow, presentation - <a href="http://www.slideshare.net/OWASP-Russia/yourprezi-49135416">www.slideshare.net/OWASP-Russia/yourprezi-49135416</a> <br><br><h1>  <font color="#56A5EC">Flash</font> </h1><br> <a href="https://sergeybelove.ru/nyancat/"><img src="https://habrastorage.org/getpro/habr/post_images/861/006/7c3/8610067c3ed6a44fb1a3f6621004231f.jpg" alt="image"><br></a> <br>  Am i serious  About flash?  In fact yes.  For some, this is relevant, but for many it historically works somewhere else.  Yes, this year already there was one large-scale case with a flush with a ‚Äúnew-old‚Äù bug, about which nobody wrote about it in runet :( But let's order. <br><br><h2>  <font color="#56A5EC">crossdomain.xml</font> </h2><br>  The most popular flash related is the crossdomain.xml file.  This is an xml file that tells the flash application a policy for working with this domain (again, this is about SOP).  And here the situation as with CORS will not pass.  If it is indicated that any domain has access (together with cookies), it means any.  And this, of course, is bad.  An example of such a file: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to-ports</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"80"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  A flash drive from any domain can access this resource (where this crossdomain is located) along with the user's cookies.  But this is the most frequent case, it is more interesting. <br><br>  From the experience of bughunting on wamba.com - they had a lot of domains in this file (they moved and changed the name of the resource many times).  As a result of the file were domains that have long expired.  You could successfully register and attack users of wamba.com.  Gave 3 thousand (: <br><br><h2>  <font color="#56A5EC">XSS via Flash</font> </h2><br>  XSS is also possible through Flash files.  Example of vulnerable AS code <br><pre> <code class="actionscript hljs">getURL(_root.URI,<span class="hljs-string"><span class="hljs-string">'_targetFrame'</span></span>);</code> </pre><br>  Example of operation: <br><pre> <code class="bash hljs">http://victim/file.swf?URI=javascript:evilcode</code> </pre><br>  Flash will try to go to javascript: and execute arbitrary JS code.  SWF is easy to decompile, so the source code is (directly) not needed.  You can read more about this method of attack and find a list of available functions at OWASP - <a href="https://www.owasp.org/index.php/Testing_for_Cross_site_flashing_">www.owasp.org/index.php/Testing_for_Cross_site_flashing_</a> (OTG-CLIENT-008) <br><br><h2>  <font color="#56A5EC">CVE-2011-2461 IS BACK!</font> </h2><br>  Well, now from fresh flash about flash from 2015. This spring Troopers presented a working PoC and tools for analyzing how to exploit one old vulnerability in flash files compiled on Adobe Flex (the vulnerable version).  This is a very popular framework for flash developers.  Such a vector - we find such a flash drive on a resource (assembled with vulnerable Adobe Flex), generate a special payload (resource) for it and connect it.  A flash drive is being executed from the load domain with our payload.  The bottom line is the SOP bypass. <br><br>  To check these files (SWF vulnerable or not) you can use the tool - <a href="https://github.com/ikkisoft/ParrotNG/">github.com/ikkisoft/ParrotNG</a> , it is very easy to start <br><pre> <code class="bash hljs">java -jar parrotng_v0.2.jar &lt;SWF File | Directory&gt;</code> </pre><br>  More information <br><ul><li>  <a href="http://blog.nibblesec.org/2015/03/the-old-is-new-again-cve-2011-2461-is.html">blog.nibblesec.org/2015/03/the-old-is-new-again-cve-2011-2461-is.html</a> </li><li>  <a href="http://www.slideshare.net/ikkisoft/the-old-is-new-again-cve20112461-is-back">www.slideshare.net/ikkisoft/the-old-is-new-again-cve20112461-is-back</a> </li></ul><br>  The authors of the study found such flash drives on Google and on other well-known resources (for example, Qiwi, Yandex).  His "cut down" :) <br><br><h2>  <font color="#56A5EC">Infrastructure leaks</font> </h2><br>  The same leaks are possible as in the cases with JS / CSS.  Servers, API keys, etc. <br><br><h1>  <font color="#56A5EC">JSONP Information Disclosure</font> </h1><br>  I already wrote about this in the article about the security of the API, but it is worth repeating, for completeness of this article. <br>  Sometimes the API is provided not only for some end user, and sometimes for sending data within the project.  This is often found on large, large sites with different domains.  And somehow it is necessary to interact on the client side between domains, and then JSONP comes to the rescue.  This is such a JSON with the necessary ones on domain 1, which turns into a callback.  When accessing a domain, 1 user will send his cookies, and you can check whether he is authorized and give the necessary data.  On the second domain is inserted a similar JS <br><br><pre> <code class="javascript hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"application/javascript"</span></span> src=<span class="hljs-string"><span class="hljs-string">"http://server1.example.com/api/getUserInfo?jsonp=parseResponse"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><br>  with the already defined parseResponse function.  But the bottom line is that an attacker can also insert this script on his domain, define his callback and, if there is sensitive data, use it somehow.  A perfect example of using such a vulnerability is shown in the article <a href="http://habrahabr.ru/post/186160/">‚ÄúFighting anonymity</a> . <a href="http://habrahabr.ru/post/186160/">‚Äù</a> <br><br><h1>  <font color="#56A5EC">X-Frame-Options</font> </h1><br>  It seems about this 1000 and once said, but again we repeat.  Each resource without add.  settings can be shown in the frame.  The frame is loaded with the current user's cookies, i.e.  in the frame it opens the resource authorized (if logged in, of course).  This frame is built in by the attacker on his page, something that calls for action is drawn over (press a button, etc.), the user clicks, but in fact he clicks on the elements in the frame (for example, he subscribes to groups).  The attack is called Clickjacking. <br><br>  X-Frame-Options in the response of the web server allows <br><ul><li>  Completely prohibit the display of the page in the frame </li><li>  Partially forbid (for example, allow only for the same origin) </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9af/f2c/c8d/9aff2cc8d831d0e4cb03b0ca6d0e9707.jpg" alt="image"><br><br>  <a href="http://habrahabr.ru/post/186616/">The article about clickJacking on VK</a> <br><br><h1>  <font color="#56A5EC">Extensions / SmartTV</font> </h1><br>  To expand the capabilities of the browser there are plug-ins (for example, Flash), and there are extensions.  The latter are written using just HTML / CSS / JS, which is the point of this article.  Applications for SmartTV are written in a similar way using the enhanced API of TVs (for example, access to the camera).  And naturally, and then you can nakosyachit.  I have already <a href="http://habrahabr.ru/company/dsec/blog/192294/">talked</a> about the security of extensions, and we will discuss the security of SmarTV applications (and attack vectors for SmartTV users) later.  I leave only the video <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/5Nr-taiAC6s%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgJITFYy2i132bFJ7Fa6Dm46jw7eg" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  <font color="#56A5EC">For dessert</font> </h1><br>  Well, if for some readers from the front-end it is ‚ÄúI JUST WRITE CSS and INSERT PICTURES!  TELL ME ABOUT SECURITY! ‚Äù... this is the story. <br><br>  In the transition (in "typical" conditions) by reference <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äúhttp://external.com‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>Go!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The browser in the request will give the referer, the address of the previous page.  And what about styles, pictures, etc.?  Are they loaded passing referer or not?  I suggest right now to stop reading and answer the question for myself. <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Yes transmitted <br></div></div><br>  What is bad?  On the hackerone.com resource, the layout designer inserted the comic into the password recovery page (where the user comes with the token in the GET parameter) from ... an external resource.  As a result, the owner of this resource, when downloading this comic, saw in his access.log all tokens for resetting passwords.  With the necessary account automation, you can quickly "hijack". <br>  And it would seem - "I just insert the pictures in html" (: <br><br>  Presentation from performance <br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.slideshare.net/slideshow/embed_code/48484878&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiSqHgm_qMABsk9ughd_Wj21c5BVw" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></div><p>Source: <a href="https://habr.com/ru/post/259389/">https://habr.com/ru/post/259389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259377/index.html">Developing a successful international business with Google Play</a></li>
<li><a href="../259379/index.html">Opera browsers, their modes and engines</a></li>
<li><a href="../259381/index.html">100 Years Later: Ramanujan Records Complete</a></li>
<li><a href="../259383/index.html">OpenEMS dipole antenna simulation</a></li>
<li><a href="../259385/index.html">Why did we open the code Virtuozzo</a></li>
<li><a href="../259391/index.html">How to organize interaction of processes in Oracle BPM</a></li>
<li><a href="../259393/index.html">Skype Skype for Windows and Mac OS DoS Exploit</a></li>
<li><a href="../259397/index.html">AI, BigData & HPC Digest # 1 (May 7 - June 3)</a></li>
<li><a href="../259399/index.html">FastNetMon 1.1.2 release for open DoS / DDoS attack monitoring solution</a></li>
<li><a href="../259401/index.html">Forwarding several identical USB devices to virtual machine libvirt + QEMU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>