<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding garbage collection and memory leak detection in Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bad press reviews about Node.js often refer to performance issues. This does not mean that Node.js has more problems than with other technologies. Jus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding garbage collection and memory leak detection in Node.js</h1><div class="post__text post__text-html js-mediator-article">  Bad press reviews about Node.js often refer to performance issues.  This does not mean that Node.js has more problems than with other technologies.  Just the user must keep in mind some features of its work.  Although the technology has a flat learning curve, the mechanisms ensuring its operation are quite complex.  You need to understand them to prevent performance errors.  And if something goes wrong, you need to know how to quickly put everything in order.  In this article, Daniel Hahn talks about how Node.js manages memory and how to track down memory-related problems. <br><br><img src="https://habrastorage.org/files/5f4/e00/697/5f4e00697ace420ca2ff18aa23e35adf.jpg"><br><a name="habracut"></a><br>  Unlike platforms like PHP, applications on Node.js are long-term processes.  There are a number of positive aspects - for example, the ability to connect to the database once and use this connection for all queries.  But this feature can create problems.  First, let's take a look at the basics of Node.js. <br><br><img src="https://habrastorage.org/files/591/b5f/6a8/591b5f6a831f4f10a01b79f0f6333f6e.png"><br>  <i>Real Austrian garbage collector</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Node.js is a C ++ program controlled by a V8 JavaScript engine</b> <br><br>  <a href="https://developers.google.com/v8/">Google V8</a> is an engine that was originally written for Google Chrome, but could also be used autonomously.  Therefore, it is ideal for Node.js and is, in fact, the only part of the platform that "understands" JavaScript.  V8 compiles javascript into machine code and executes it.  During execution, the engine controls the allocation and cleaning of memory as needed.  This means that when it comes to memory management in Node.js, we are in fact talking about V8. <br><br>  <a href="https://developers.google.com/v8/get_started">Here</a> you can see a simple example of how to use V8 from the point of view of C ++. <br><br>  <b>V8 memory circuit</b> <br><br>  A running program can always be represented after a certain amount of space allocated in memory.  This place is called Resident Set.  V8 uses a scheme similar to the Java Virtual Machine scheme, and divides the memory into segments: <br><br>  <b>Code: the</b> currently executing code. <br>  <b>Stack:</b> contains all primitive types of values ‚Äã‚Äã(like integer or Boolean) with pointers that refer to objects on the heap and define the control flow of the program. <br>  <b>Heap:</b> a memory segment for storing reference types like objects, strings, and closures. <br><br><img src="https://habrastorage.org/files/1cd/f83/aaa/1cdf83aaa96a4402ae1ff7ceb1398ce3.png"><br>  <i>V8 memory circuit</i> <br><br>  In Node.js, current memory usage data can be obtained by calling <a href="https://nodejs.org/api/process.html">process.memoryUsage ().</a> <br><br>  The function returns an object containing: <br><br><ul><li>  Resident Set size; </li><li>  total heap size; </li><li>  the amount of space used in the heap. </li></ul><br><br>  This function can be used to record memory usage over time and plot a graph that displays how the V8 manages memory. <br><br><img src="https://habrastorage.org/files/9df/d8f/932/9dfd8f9328a94bf897b17c3e9f00391d.png"><br>  <i>Node.js memory usage over time</i> <br><br>  We see that the graph of used space in the heap is extremely unstable, but always remains within certain limits in order to keep the value of average consumption constant.  The process that allocates and frees memory is called <b>garbage collection.</b> <br><br>  <b>Introduction to Garbage Collection</b> <br><br>  Each program that consumes memory requires a reservation and freeing mechanism.  In C and C ++, this function is performed by the malloc () and free () commands, as shown in the example below: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buffer; buffer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Do something with buffer free (buffer);</span></span></code> </pre> <br><br>  We see that the programmer is responsible for freeing unused memory.  If the program only allocates memory and does not free it, the heap will grow until the memory used is exhausted, which will cause the program to crash.  We call it <b>a memory leak.</b> <br><br>  As we already know, in Node.js, JavaScript is compiled into native code using V8.  The data structures obtained after compilation cannot do anything with their original representation and are simply controlled using V8.  This means that we cannot actively allocate and clear memory in JavaScript.  V8 uses to solve this problem a well-known mechanism - garbage collection. <br><br>  The principle of garbage collection is quite simple: if no one refers to a memory segment, we can assume that it is not used and clean it up.  However, the process of obtaining and storing this information is rather complicated, since the code may contain chain references and redirections that form a complex graph structure. <br><br><img src="https://habrastorage.org/files/944/ca4/339/944ca4339eea451fa17005893f4d9e7b.png"><br>  <i>Count Heap.</i>  <i>A red object can only be deleted if it is no longer referenced.</i> <br><br>  Garbage collection is a rather expensive process because it interrupts the execution of the application, which naturally affects performance.  To remedy this situation, V8 uses 2 types of garbage collection: <br><br><ul><li>  Scavenge - fast, but incomplete; </li><li>  Mark-Sweep is relatively slow, but clears all unused links. </li></ul><br><br>  An excellent post containing very detailed information about garbage collection can be found <a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">at this link.</a> <br><br>  Now, looking at the graph obtained using process.memoryUsage (), you can easily distinguish between different types of garbage collection: a pattern resembling saw teeth, notes the work of Scavenge, falling down - Mark-Sweep. <br><br>  Using the built-in <a href="https://github.com/bretcope/node-gc-profiler">node-gc-profiler</a> module, you can get even more information about the work of the garbage collector.  The module subscribes to garbage collector events and translates them into JavaScript. <br><br>  The returned object indicates the type of garbage collection and the duration.  Again, this data can be easily displayed graphically to make it clearer how things work. <br><br><img src="https://habrastorage.org/files/92b/3c7/58d/92b3c758da8d477b9afc05afa5550f0d.png"><br>  <i>Duration and frequency of launches of the garbage collector</i> <br><br>  You can clearly see that Scavenge runs much more often than Mark-Sweep.  Depending on the complexity of the application, the duration may vary.  It is noteworthy that on this graph you can see frequent and short-term launches of Mark-Sweep, the function of which is not clear to me yet. <br><br>  <b>When something goes wrong</b> <br><br>  If the garbage collector cleans the memory, why should we worry?  In fact, memory leaks can easily occur in your logs. <br><br><img src="https://habrastorage.org/files/34d/885/3c6/34d8853c6fde4c418de236e66b601536.png"><br>  <i>Memory Leak Exception</i> <br><br>  Using the previously created schedule, we can observe how the memory is constantly clogged! <br><br><img src="https://habrastorage.org/files/2cf/831/8b4/2cf8318b44b040f59f4a30ee7db8ec2e.png"><br>  <i>Memory leak progress</i> <br><br>  The garbage collector is doing everything possible to free up memory.  But with each launch, we see that memory consumption is constantly increasing, and this is a clear sign of a memory leak.  Since we know how to accurately detect a memory leak, let's see what needs to be done to trigger it. <br><br>  <b>We create a memory leak</b> <br><br>  Some leaks are obvious - like storing data in global variables (for example, folding the IP addresses of all logged-in users into an array).  Others are not so noticeable - for example, a well-known <a href="https://www.joyent.com/blog/walmart-node-js-memory-leak">memory leak</a> from <a href="https://www.joyent.com/blog/walmart-node-js-memory-leak">Walmart</a> due to the omission of a <a href="https://github.com/nodejs/node-v0.x-archive/commit/16934d9210546bf19d4af8d98652aa5d636ce693">small expression</a> in the Node.js core code, which took weeks to find the source. <br><br>  I am not going to look at errors in the kernel code here.  Let's just take a look at a hard-to-find leak in the code <a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak">from the Meteor blog,</a> which you can easily admit in your code. <br><br><img src="https://habrastorage.org/files/46a/f96/29f/46af9629fb6c49ecbc132d3cfd77c7fd.png"><br>  <i>Entering an error in your JavaScript code</i> <br><br>  At first glance it looks fine.  One would think that theThing is overwritten with every call to replaceThing ().  The problem is that someMethod has its own private scope as context.  This means that someMethod () knows about unused () and, even if unused () is never called, this fact will prevent the garbage collector from freeing memory from originalThing.  Just because there are too many indirect calls.  This is not a bug, but can lead to memory leaks that are difficult to track down. <br><br>  True, it would be great if you could look in a bunch and see what is there now?  Fortunately, there is such an opportunity!  V8 allows you to dump heaps at the current moment, and V8-profiler allows you to use this functionality for JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Simple userland heapdump generator using v8-profiler * Usage: require('[path_to]/HeapDump').init('datadir') * * @module HeapDump * @type {exports} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> profiler = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'v8-profiler'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _datadir = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextMBThreshold = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Init and scheule heap dump runs * * @param datadir Folder to save the data to */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">datadir</span></span></span><span class="hljs-function">) </span></span>{ _datadir = datadir; setInterval(tickHeapDump, <span class="hljs-number"><span class="hljs-number">500</span></span>); }; <span class="hljs-comment"><span class="hljs-comment">/** * Schedule a heapdump by the end of next tick */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tickHeapDump</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setImmediate(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ heapDump(); }); } <span class="hljs-comment"><span class="hljs-comment">/** * Creates a heap dump if the currently memory threshold is exceeded */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heapDump</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memMB = process.memoryUsage().rss / <span class="hljs-number"><span class="hljs-number">1048576</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(memMB + <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span> + nextMBThreshold); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memMB &gt; nextMBThreshold) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Current memory usage: %j'</span></span>, process.memoryUsage()); nextMBThreshold += <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snap = profiler.takeSnapshot(<span class="hljs-string"><span class="hljs-string">'profile'</span></span>); saveHeapSnapshot(snap, _datadir); } } <span class="hljs-comment"><span class="hljs-comment">/** * Saves a given snapshot * * @param snapshot Snapshot object * @param datadir Location to save to */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveHeapSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">snapshot, datadir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); snapshot.serialize( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, length</span></span></span><span class="hljs-function">) </span></span>{ buffer += data; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = stamp + <span class="hljs-string"><span class="hljs-string">'.heapsnapshot'</span></span>; fs.writeFile(datadir + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + name , buffer, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Heap snapshot written to '</span></span> + name); }); } ); }</code> </pre><br><br>  This simple module creates a heap dump file if memory usage is constantly increasing.  Yes, there are much more complex approaches to defining anomalies, but for our purposes this will be enough.  In the event of a memory leak, you may have many such files.  So you need to closely monitor this and add the ability to alert this module.  The same functionality for working with the heap dump is provided by Chrome, and you can use Chrome Developer Tools to analyze the dumps of the V8-profiler. <br><br><img src="https://habrastorage.org/files/b51/130/53f/b5113053f0a042c2b568f88058e5eb56.png"><br>  <i>Chrome Developer Tools</i> <br><br>  One heap dump may not help, because you will not see how the heap changes over time.  Therefore, Chrome Developer Tools allows you to compare different files.  Comparing 2 dumps, we get a delta of values, which shows which structures increase between two dumps: <br><br><img src="https://habrastorage.org/files/013/231/4de/0132314dea8d495a9f72f8ec301d3ec5.png"><br>  <i>A comparison of the dumps shows our leakage.</i> <br><br>  Here we see our problem.  The variable that contains a string of asterisks and is called longStr is referenced by the originalThing, referenced by some method that is referenced ... I think you understand.  This is a long series of nested references and closure contexts that do not allow to clear longStr.  Although this example leads to obvious results, the process is always the same: <br><br><ul><li>  Create multiple heap dumps with a time difference and with a different amount of allocated memory. </li><li>  Compare several dumps to see which values ‚Äã‚Äãgrow. </li></ul><br><br>  <b>Finally</b> <br><br>  As you can see, the garbage collection process is quite complex, and even valid code can cause memory leaks.  Using the built-in V8 functionality along with Chrome Developer Tools, you can understand what causes memory leaks and, if you embed this functionality in your application, have everything you need to solve a similar problem when it occurs. <br><br>  One question remains: how can I fix a leak?  The answer is simple: just add theThing = null;  at the end of the function, and you are saved. </div><p>Source: <a href="https://habr.com/ru/post/277129/">https://habr.com/ru/post/277129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277119/index.html">Unicorn in space: check the source code of 'Space Engineers'</a></li>
<li><a href="../277121/index.html">Resource Binding in Microsoft DirectX 12. Performance Issues</a></li>
<li><a href="../277123/index.html">Open letter @ignored test</a></li>
<li><a href="../277125/index.html">Results of 2015: IT industry</a></li>
<li><a href="../277127/index.html">Record of the webinar "Centralized Management with MyKerio"</a></li>
<li><a href="../277131/index.html">A series of technical webinars: "Managing server and personal security in Kerio Connect"</a></li>
<li><a href="../277135/index.html">Fortinet framework for protection against advanced threats</a></li>
<li><a href="../277137/index.html">Go sync.Pool</a></li>
<li><a href="../277139/index.html">Cisco ASA Critical Vulnerability: What is the Problem, and How to Protect</a></li>
<li><a href="../277141/index.html">Like this - to be a software developer for cars. Part 1/2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>