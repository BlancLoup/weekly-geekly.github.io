<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tugging a Camel or integration with Camel. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apache Camel Integration Scenarios 

 How many application integration patterns (EIP) do you know? How many of them can you use? 

 Cute "camel" is he...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tugging a Camel or integration with Camel. Part 2</h1><div class="post__text post__text-html js-mediator-article"><h1>  Apache Camel Integration Scenarios </h1><br><img src="https://habrastorage.org/files/58f/07b/103/58f07b10399f4186baf580046ce7d32c.jpg" width="314" height="329" align="left"><br>  How many application integration patterns (EIP) do you know?  How many of them can you use? <br><br>  Cute "camel" is here again, which means I present to you the continuation of a series of articles on Apache Camel.  In this article there are both the most necessary and very interesting patterns of integration.  I will tell about how they fall on our integration. <br><br>  If you are familiar with the templates, but decide whether to contact the "camel", then our examples will help you figure it out.  If you are interested in the path from usage scenarios to integration implementation, then this article is just about that.  I ask under the cat. <br><a name="habracut"></a><br><br clear="all">  Let me remind you, we built our service bus on Apache Camel.  The prehistory was described in the <a href="http://habrahabr.ru/company/naumen/blog/230265/">previous part</a> .  Now Camel for us is a given, with which we must fight.  In our "zoo" was added, except for the last, we have two systems.  The first is our main system, which is built on the classic three-tier ‚Äúclient-server‚Äù architecture.  It is a <a href="http://ru.wikipedia.org/wiki/BPM_(%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2586%25D0%25B5%25D0%25BF%25D1%2586%25D0%25B8%25D1%258F)">BPMS</a> system, the complexity of which is due to the long-term process of ‚Äúdopilivaniya‚Äù small ‚Äúhotelok.‚Äù  The second is a small and simple, like a felt boot, system of the same architecture.  We will call it a sales office.  Disassemble the use cases will be just for her example. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Questionnaire system with the need for integration. </h2><br>  Our sales office is an application that does not have complicated logic.  It implements the process of registering customers and entering the documents required for the order.  This system is open to customers after registration, so the response time and throughput requirements are of a higher order than the main system.  Restrictions on security, bandwidth, independent configuration, and the need to maintain a separate development cycle led to the separation of a sales office as a standalone application.  To service the sales process, we needed its integration into our customer's IT infrastructure. <br>  Familiarity with the integration will begin with the options for using the sales office.  We have identified two main roles in the business process of our application: customer and administrator.  It is these user groups that work with it. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/f81/c51/c20/f81c51c2099545eabd95db102290b98b.png" width="652" height="445"></div><br><div class="spoiler">  <b class="spoiler_title">Detailed use case diagram</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/95f/455/e2f/95f455e2fb52460e987502f9540e593b.png"></div></div></div><br>  The scheme dismantled the main uses.  Pay attention to the right side of the scheme, a few precedents go beyond the sales office and require certain actions from the main system.  It is these precedents we will analyze further. <br><br>  To form a holistic view of our office, let‚Äôs analyze the scheme.  Our buyers submit applications for participation in auctions.  Carrying out auctions is the main process of the sales office.  To participate in them, buyers must register and fill out applications, filling out a large number of boring registration forms.  The administrator performs the functions of preparing and conducting auctions.  For this purpose, a special application form - a questionnaire is prepared for each of the auctions; therefore, the class of such systems is sometimes called personal ones.  The auction process is completed for the sales office by transmitting information on submitted applications to the main system for selecting the winner and processing the transaction. <br><br>  Qualitative requirements for integration processes: <br><ul><li>  Losses of normative-reference information are permissible and should not lead to disruption of the functioning of the subsystems; </li><li>  Contacting external systems should not disrupt the auction process in case of failure of external systems and / or communication channels; </li><li>  Applications must be guaranteed to be transmitted and delivered between subsystems; </li><li>  Files must be guaranteed to be transferred and delivered between subsystems; </li><li>  The user burden on auctions should fall entirely on the sales office, unloading the main system.  Therefore, interactions between systems should be minimized; </li><li>  At the disposal of the user of the sales office there should be no mechanisms for influencing the main system. </li></ul><br>  The following architectural tasks arose when parsing the precedents identified: <br><ol><li>  Transport organization; </li><li>  Distribution of functions between subsystems; </li><li>  Directory synchronization; </li><li>  Transfer of dependent entities; </li><li>  Monitoring the exchange process; </li><li>  File transfer </li></ol><br>  Let us analyze the solutions of these architectural problems by the example of usage scenarios and correlate them with EIP templates. <br><br><h2>  The organization of transport. </h2><br>  The transport includes both the systems described above and Camel.  The latter has already been said a lot in the previous part of the article, so let's go further. <br>  All three systems are connected by an ActiveMQ broker using AMQP protocol. <br><br>  Let me remind you that systems exchange packets using JMS.  With the payload of these packages, we decided to make XML and serialize into it objects of one of the systems using JAXB.  But what objects to take as a basis, while at the same time minimize the time spent on creating integration?  There are two systems, which means there can be two formats.  We decided to stop at the sales office objects, this system is more lightweight, the domain domain objects are connected with other architectural layers of this application with only JPA annotations.  Allocation of transport objects on its basis was not difficult.  An alternative solution (to use the objects of the main system) seemed almost impossible due to the presence of a large amount of metadata and complex links with other business entities that go beyond the boundaries of the sales office service we are interested in.  Another remaining option is the creation of new transport facilities.  He was not even considered, as he demanded the implementation of the procedure and import and export in both systems, which in the first case for the sales office subsystem could be refused. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/152/34c/bbf/15234cbbf4734891a12b42f639725635.png" width="234" height="166"></div><br>  Perhaps you were surprised that we chose XML as the payload of our packages?  But, I assure you, there were reasons for this.  Serialization using the JAXB standard is included in the JVM ‚Äî it simplifies working with it and does not require additional modules.  At the time of integration development, we already had experience with JAXB, so no overhead was required for familiarization.  Another ‚Äúbun‚Äù is that XML is a text format, which means that in case of emergency situations you can interfere with its structure and make the necessary adjustments.  But there were disadvantages: it is known that the structure of the XML format significantly increases the amount of data.  However, the information we planned to share, according to initial estimates, did not exceed 100 MB for reference information, and 1 MB for applications for applications.  This, you see, is not very big numbers.  In addition, the exchange of information had to occur at a time, and there were no requirements for efficiency. <br><br>  Few details about the architecture of the formation and analysis of messages. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/31f/b19/aa2/31fb19aa2d2a44868e7f59f12ab714ca.png" width="602" height="140"></div><br>  Before that, we described the mechanisms for transmitting and working with messages, without touching Camel directly.  It is time to tell what functions were assigned to it, and how it was built into the integration system. <br><br>  So, the functions: <br><ol><li>  Independent configuration of message routing; </li><li>  Transmission of messages from office queues to the main system queues and vice versa; </li><li>  Matching formats for endpoint unification. </li></ol><br>  To simplify the connection of systems with a single message broker, the names of queues and topics should be unified.  We use such an agreement: <code>[ ].[  ].[    ]</code> <br>  However, it soon turned out that the fewer points in a complex system, the easier the setting.  All the functionality for parsing messages and routing is easily transferred to the service bus.  So for our main system, only one endpoint is left to send data: <code>bpms.office.export</code> <br><br><h2>  Distribution of functions between subsystems. </h2><br>  Let's look at this distribution in terms of integration architecture.  The sales office is responsible for: <br><ul><li>  processing, setting and placement of lots; </li><li>  all tasks of the formation and verification of data packages with information about applications; </li><li>  preparation and transfer of additional files of registered applications; </li><li>  synchronization of regulatory information. </li></ul><br>  Service Bus: <br><ul><li>  the transfer of regulatory information; </li><li>  transferring information about lots and auctions; </li><li>  transmission of application data. </li></ul><br>  Main system: <br><ul><li>  preparation and sending of regulatory information; </li><li>  initiation and dispatch of the auction; </li><li>  building a further business process for processing applications; </li></ul><br>  Go ahead, now real examples. <br><br><h2>  Synchronization of reference books. </h2><br>  The process of synchronization of reference books is based on the precedents mentioned earlier.  The scheme is as follows: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/0e8/44a/491/0e844a49197b4ca1b05842a65b1c50cb.png" width="702" height="203"></div>  It can be seen that, compared with the use case diagram, synchronization here is performed on the sales office side.  We have already mentioned this before, but again, sales offices can be many, which means that regulatory information should be uploaded to each of them.  Since the requirements for reliability of transmission, as well as ensuring guaranteed delivery are not so strict here, you can use JMS channels like ‚Äúpublish-subscribe‚Äù.  The following is a diagram of data transmission in the form of EIP templates. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b5a/aec/627/b5aaec6272b34a35ae11e0710eab3ae4.png" width="722" height="288"></div><br>  The diagram shows that two routes are used in the service bus.  Messages pass through a single output channel of the main system (BPMS), are filtered and transmitted to a specialized channel responsible for working with reference information.  Here, the message format is consistent with the office system, they are combined into directories (aggregated) and transmitted to the sales office system via another JMS channel. <br><br>  The scheme uses several <a href="http://camel.apache.org/eip.html">EIP</a> patterns: <br><ol><li>  <a href="http://camel.apache.org/message-channel.html">Message channel</a> - message channel; </li><li>  <a href="http://camel.apache.org/message-endpoint.html">Endpoint</a> - the end point; </li><li>  <a href="http://camel.apache.org/message-filter.html">Message filter</a> - message filter; </li><li>  <a href="http://camel.apache.org/message-translator.html">Message translator</a> - template for the message format conversion component; </li><li>  <a href="http://camel.apache.org/aggregator2.html">Aggregator</a> - a template that allows you to combine multiple messages into one. </li></ol><br>  Why so hard?  Let's go in order.  Using the message filter is necessary to simplify the configuration and appeared here after merging the output endpoints into one.  Cons of the approach: <br><ul><li>  mutual blocking of message passing is possible.  A high message exchange rate of one of the served types (for example, with reference information) can overflow the buffer of a single channel and block the transmission of messages of another type.  It turns out that the exchange of messages of one type depends on the messages of another type. </li></ul><br>  This possibility cannot be completely excluded, but the effect can be reduced by creating additional buffer channels for each type of message.  The ActiveMQ broker maintains a separate setting for the allocation of resources for each such channel, so you can take care of the necessary memory and disk space, taking into account the exchange rate. <br><br>  Let's return to our route, then the messages are transmitted just over such a buffer JMS channel.  The next interesting point is the component that unites the packages.  It is required due to the fact that to perform synchronization requires a complete set of directory elements.  The easiest way to ensure completeness is to collect all the elements in one message.  The critical minus message merge is the large volume of the message received, which can be a problem for both the broker and the service bus. <br>  Fortunately, our directories are not so large, and simplicity came out on top.  But this problem should not be underestimated; a limited amount of RAM is allocated for each channel in the broker settings, exceeding which can lead to a critical error. <br><br>  Sample routes: <br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:topic:bpms.office.request"</span></span>).routeId(<span class="hljs-string"><span class="hljs-string">"catalog-synchronization-filter"</span></span>) .filter( header(<span class="hljs-string"><span class="hljs-string">"destination"</span></span>).isEqualTo( <span class="hljs-string"><span class="hljs-string">"portal.export.catalog"</span></span> ) ) .setHeader(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>, simple(<span class="hljs-string"><span class="hljs-string">"${header.catalog}"</span></span>)) .inOnly(<span class="hljs-string"><span class="hljs-string">"jms:topic:catalog.synchronized"</span></span>); from(<span class="hljs-string"><span class="hljs-string">"jms:topic:catalog.synchronized"</span></span>).routeId(<span class="hljs-string"><span class="hljs-string">"catalog-synchronization-topic"</span></span>) .filter( header(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>).in( ... <span class="hljs-string"><span class="hljs-string">"GRNTI"</span></span>,<span class="hljs-string"><span class="hljs-string">"OKATO"</span></span>,<span class="hljs-string"><span class="hljs-string">"OKFS"</span></span>,<span class="hljs-string"><span class="hljs-string">"OKOGU"</span></span>,<span class="hljs-string"><span class="hljs-string">"OKOPF"</span></span>,<span class="hljs-string"><span class="hljs-string">"OKVED"</span></span>, ‚Ä¶ ) ) .setHeader(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>) .groovy( <span class="hljs-string"><span class="hljs-string">"switch( request.getHeaders().get('catalogCode') ){"</span></span> + ... <span class="hljs-string"><span class="hljs-string">" case \"GRNTI\": return \"GRNTICatalog\""</span></span> + <span class="hljs-string"><span class="hljs-string">" case \"OKATO\": return \"okatoCatalog\""</span></span> + <span class="hljs-string"><span class="hljs-string">" case \"OKFS\": return \"okfsCatalog\""</span></span> + <span class="hljs-string"><span class="hljs-string">" case \"OKOGU\": return \"okoguCatalog\""</span></span> + <span class="hljs-string"><span class="hljs-string">" case \"OKOPF\": return \"okopfCatalog\""</span></span> + <span class="hljs-string"><span class="hljs-string">" case \"OKVED\": return \"okvedCatalog\""</span></span> + ... <span class="hljs-string"><span class="hljs-string">"}"</span></span>) .inOnly( <span class="hljs-string"><span class="hljs-string">"direct:office.synchronization"</span></span>); from(<span class="hljs-string"><span class="hljs-string">"direct:office.synchronized"</span></span>).routeId(<span class="hljs-string"><span class="hljs-string">"catalog-import-office-filter"</span></span>) .aggregate(header(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CatalogItemAggregationStrategy()).completionTimeout(<span class="hljs-number"><span class="hljs-number">3000</span></span>) .inOnly(<span class="hljs-string"><span class="hljs-string">"jms:topic:office.catalog.synchronization?timeToLive=200000"</span></span>);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">the details</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatalogItemAggregationStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AggregationStrategy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Exchange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aggregate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Exchange oldExchange, Exchange newExchange)</span></span></span><span class="hljs-function"> </span></span>{ String newBody = newExchange.getIn().getBody(String.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldExchange != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String oldCode = (String)oldExchange.getIn().getHeader(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>); String newCode = (String)newExchange.getIn().getHeader(<span class="hljs-string"><span class="hljs-string">"catalogCode"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( StringUtils.equals( oldCode, newCode) ) { String oldBody = oldExchange.getIn().getBody(String.class); oldExchange.getIn().setBody( StringUtils.substringBeforeLast( oldBody, <span class="hljs-string"><span class="hljs-string">"\n&lt;/catalogs&gt;"</span></span>) + StringUtils.substringAfter( newBody, <span class="hljs-string"><span class="hljs-string">"?&gt;"</span></span>) + <span class="hljs-string"><span class="hljs-string">"\n&lt;/catalogs&gt;"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oldExchange; } } StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder( newBody ); builder.insert( builder.indexOf(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;catalogs&gt;\n"</span></span>); builder.append( <span class="hljs-string"><span class="hljs-string">"&lt;/catalogs&gt;\n"</span></span> ); newExchange.getIn().setBody( builder.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newExchange; } }</code> </pre><br></div></div><br><br><h2>  Transfer of dependent entities. </h2><br>  To begin with, let's draw up a diagram of the process of publishing a lot with an eye on the precedent diagram. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/1d3/b77/3db/1d3b773db7f549a9818170b1d8feacc3.png" width="550" height="177"></div><br>  As you can see, the transfer process is relatively simple.  You can shift the process diagram to EIP, you get the scheme already known from the previous part: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/7c3/f5f/d2d/7c3f5fd2d3c74483b04a7958579149a7.png" width="702" height="181"></div><br>  There is a weak point in simplicity, pay attention to the detailed layout of lots in BPMN notation. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/8e3/853/b53/8e3853b539714d80875efa85fe046303.png" width="732" height="357"></div><br>  So it turns out that you can unload a lot only after the auction is created.  The auction publishing process is depicted in the first diagram of this section in gray.  To solve the problem of related processes, two solutions were proposed: <br><ol><li>  Implement support for distributed transactions and wrap a group of messages in a transaction; </li><li>  Transfer all data in one message. </li></ol><br>  The second option seemed to be easier and faster to implement, and stopped at it.  We needed to create stubs and transmit minimal information about missing objects.  Example messages: <br><pre> <code class="java hljs">&lt;office&gt; &lt;lot&gt; &lt;id&gt;fs000000000is3ro0d708me9ms&lt;/id&gt; &lt;code&gt;<span class="hljs-number"><span class="hljs-number">2011</span></span>-<span class="hljs-number"><span class="hljs-number">1.5</span></span>-<span class="hljs-number"><span class="hljs-number">051</span></span>-<span class="hljs-number"><span class="hljs-number">001</span></span>&lt;/code&gt; &lt;theme&gt;&lt;/theme&gt; &lt;aims&gt;  &lt;/aims&gt; &lt;auction&gt; &lt;id&gt;fs000000000gtk9f5oa05h426o&lt;/id&gt; &lt;topic&gt; &lt;/topic&gt; &lt;/auction&gt; &lt;/lot&gt; &lt;/office&gt;</code> </pre><br>  The example shows that the message contains information about the lot and minimal information about the auction. <br>  As a result, the solution we used - to transfer related objects to preserve the completeness of changes - was a good alternative to distributed transactions.  Go ahead. <br><br><h2>  Monitoring the exchange process. </h2><br>  Let us analyze this problem by the example of the process of obtaining and recording the results, which remains key for both integration and sales office.  The process diagram is shown in the figure: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/367/cc6/b40/367cc6b40d3744e5a0d6a9991509e6f3.png" width="782" height="286"></div><br>  The process begins in the main system by sending a request for proposals for a lot; this part is not shown in the diagram because a similar route has already been discussed in the previous section.  Further, when the request arrives at the remote office, the collection and verification of the bids submitted by the buyers for the lot begins.  Only fully completed and verified applications are processed at the time of the request from the main system.  Applications are divided into fragments.  Fragmentation allows you to use less memory and speed up processing.  When the package with applications gets into the main system, it starts parsing and creating on its basis the entities of the main system (import).  We did not experiment here with parallelism in order not to encounter database consistency problems in parallel transactions.  All lengthy operations of sending and importing applications are divided into phases, each phase is completed by sending a notification and the user has the opportunity to observe the import process. <br>  The scheme of transfer of applications in EIP patterns. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/426/0d5/0b0/4260d50b08cc4eb991396055d27c14df.png" width="882" height="437"></div><br>  Example of routes infusions: <br><br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:topic:bpms.office.request"</span></span>).routeId(<span class="hljs-string"><span class="hljs-string">"bpms-request-order"</span></span>) .filter( header(<span class="hljs-string"><span class="hljs-string">"destination"</span></span>).isEqualTo( <span class="hljs-string"><span class="hljs-string">"office.order.request"</span></span> ) ) .inOnly(<span class="hljs-string"><span class="hljs-string">"jms:topic:bpms-to-office.order.request"</span></span>); ‚Ä¶ from(<span class="hljs-string"><span class="hljs-string">"jms:queue:office.order.export"</span></span>).routeId(<span class="hljs-string"><span class="hljs-string">"bpms-responce-order"</span></span>) .log(<span class="hljs-string"><span class="hljs-string">"going to bpms import: ${headers.JMSDestination}"</span></span>) .wireTap(<span class="hljs-string"><span class="hljs-string">"direct:order.audit"</span></span>) .choice() .when( header(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).isEqualTo(<span class="hljs-string"><span class="hljs-string">"bpms.import"</span></span>)) .log(<span class="hljs-string"><span class="hljs-string">"filling conumer trying recieve: ${headers.JMSDestination}, ${headers.importType}"</span></span>) .inOnly(<span class="hljs-string"><span class="hljs-string">"jms:queue:from.office.to.bpms.order.import"</span></span>) .otherwise() .to(<span class="hljs-string"><span class="hljs-string">"log:office?multiline=true"</span></span>);</code> </pre><br>  The process of sending a request is generally the same as in other cases.  The new pattern used in it is " <b>WireTap</b> ".  This component allows you to add an observer to the message exchange process; in our example, it forwards the packet with the application to the audit channel.  Example: <br><br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"direct:order.audit"</span></span>) .split( xpath(<span class="hljs-string"><span class="hljs-string">"//*[local-name()='demand']"</span></span>) ) .process( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Processor() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Exchange item )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Message in = item.getIn(); Message out = item.getOut(); out.setHeaders( in.getHeaders() ); out.setHeader(<span class="hljs-string"><span class="hljs-string">"cliendId"</span></span>, in.getMessageId()); out.setHeader(<span class="hljs-string"><span class="hljs-string">"level"</span></span>, <span class="hljs-string"><span class="hljs-string">"DEBUG"</span></span>); out.setBody( String.format( <span class="hljs-string"><span class="hljs-string">"  ‚Ññ%s\n "</span></span> + <span class="hljs-string"><span class="hljs-string">" :%s\n "</span></span> + <span class="hljs-string"><span class="hljs-string">" callback:%s\n\n"</span></span>, xpath(<span class="hljs-string"><span class="hljs-string">"//*[local-name()='fullNumber']/text()"</span></span>).evaluate(item, String.class), in.getHeader(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>), in.getHeader(<span class="hljs-string"><span class="hljs-string">"callbackUUID"</span></span>)) ); } }) .inOnly(<span class="hljs-string"><span class="hljs-string">"jms:topic:system.audit"</span></span>);</code> </pre><br>  This route is much more interesting than the previous one, the messages here are applications serialized in XML.  We split the incoming packet into separate requests using a special component splitter and xpath expression.  Next, we no longer need the entire application, so we leave only the information needed for the audit, and send the package to the JMS general audit channel <code>jms:topic:system.audit</code> .  This channel accumulates notifications on the status of transfer and import of applications, and on all abnormal situations.  Messages are returned to the main system and are associated with the initiator of receiving results on the ‚Äú <b>callbackUUID</b> ‚Äù property.  An example of a route returning a part of audit messages to the main system: <br><pre> <code class="java hljs">from(<span class="hljs-string"><span class="hljs-string">"jms:topic:system.audit"</span></span>) .filter( PredicateBuilder.and( header(<span class="hljs-string"><span class="hljs-string">"callbackUUID"</span></span>).isNotNull(), header(<span class="hljs-string"><span class="hljs-string">"fcntp.audit"</span></span>).isNull() ) ) .setHeader(<span class="hljs-string"><span class="hljs-string">"system.audit"</span></span>, simple( <span class="hljs-string"><span class="hljs-string">"true"</span></span>, Boolean.class )) .inOnly(<span class="hljs-string"><span class="hljs-string">"fcntpJms:topic:fcntp.audit?timeToLive=10000"</span></span>);</code> </pre><br>  Advantages of the approach: <br><ul><li>  all messages are accumulated in one channel and processed in a uniform way. </li><li>  you only need to configure one channel, which means fewer settings in the message broker. </li></ul><br>  Newly used EIP templates: <br><ol><li>  <a href="http://camel.apache.org/wire-tap.html">Wire Tap</a> - routing a copy of the message; </li><li>  <a href="http://camel.apache.org/splitter.html">Splitter</a> is a component that allows you to split a large message into fragments. </li></ol><br><br><h1>  File transfer </h1><br>  File transfer - the task is not very simple, especially if solved by means of JMS.  Let's sort this case.  There was nothing formalized in the requirements for this task, it was necessary to transfer data of unlimited size.  In Camel, there was no ready-made solution to transfer the file from one server to another.  The implementation of splitting files into fixed pieces followed by gluing together encountered a number of difficulties: <br><ul><li>  it was necessary to control the order of the fragments; </li><li>  implement your own file recovery mechanism from fragments; </li><li>  debug transfer. </li></ul><br>  We decided to go the other way: in Camel, copying files between local folders was implemented simply and flexibly, this mechanism suited us.  The complete file processing scheme is as follows: the file is put by one system into a network folder, Camel finds it and copies it to another folder, and after copying it informs the main system that the file has been transferred.  Here is the diagram: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/5c5/e43/fb1/5c5e43fb1cd94bc2901c27db7ef4b545.png" width="652" height="358"></div><br>  To complete the picture - here is the route that we use: <br><pre> <code class="java hljs">RouteDefinition fileExport = (RouteDefinition)from(<span class="hljs-string"><span class="hljs-string">"file:{{office.transport.dir}}?delete=true&amp;exclude=.*\\.tmp"</span></span>) .onException(IOException.class) .maximumRedeliverise(<span class="hljs-number"><span class="hljs-number">1</span></span>) .handled(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .useOriginalMessage() .wireTap(<span class="hljs-string"><span class="hljs-string">"jms:topic:system.audit"</span></span>) .transform(exceptionMessage()) .end() .to(<span class="hljs-string"><span class="hljs-string">"file:{{office.failed.dir}}"</span></span>).end() .process( TimsetampProcsseor.newInstance(<span class="hljs-string"><span class="hljs-string">"sendtimsetamp"</span></span>) ) .wireTap(<span class="hljs-string"><span class="hljs-string">"jms:queue:office.files.import"</span></span>) .newExchangeHeader(<span class="hljs-string"><span class="hljs-string">"fileName"</span></span>, simple(<span class="hljs-string"><span class="hljs-string">"${headers.CamelFileName}"</span></span>)) .newExchangeBody( constant(<span class="hljs-string"><span class="hljs-string">"progress"</span></span>) ) .end() .to(<span class="hljs-string"><span class="hljs-string">"file:{{bpms.transport.dir}}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// notify bpms by topic:office.files.import fileExport .transform().constant("ok") .delay( 20 ) .process( TimsetampProcessor.newInstance("sendtimsetamp") ) .setHeader("fileName", simple("${headers.CamelFileName}")) // send notify .inOnly("jms:queue:office.files.import");</span></span></code> </pre><br>  As you can see in the picture above, the files are copied in three steps.  On the first, the files are copied from the file storage to the transport folder of the sales office.  Routing in the service bus explains the route, it starts only when the files become available in the transport folder of the remote office subsystem.  The service bus constantly scans this folder and, as soon as the file gets there, it immediately moves it to the transport folder of the main system.  Next, the service bus creates a notification about the file movement and sends it to the <code>office.files.import</code> .  In this route, we use the exception handling mechanism; it ensures that if the file gets into the transport folder of the sales office, the main system will receive an alert regardless of the success or failure of the file movement.  It's time to sum up. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/aa3/872/237/aa38722376a0471c98673087422203ab.png" width="400" height="263"></div><br><br><h2>  Results </h2><br>  Using the example of one of our systems, we became acquainted with the main integration scenarios.  All examples are excerpts from the real application and now they are used by us.  Our examples show how simple Camel routs lie on integration patterns.  The main architectural tasks given in the article are covered by the means offered by Camel.  Even such complex tasks as, for example, copying files can be solved using Camel.  Let me remind you that the article focuses on message-based integration.  I hope that you, after reading the article, were able to make sure that the ‚ÄúCamel‚Äù is really good. <br><br>  I plan to write about errors and how to solve them in the next article (a kind of ‚ÄúTo be continued ...‚Äù).  Therefore, to new meetings. <br><br><h6>  Useful links: </h6><br><ol><li>  <a href="http://camel.apache.org/components.html">Supported Apache Camel components and protocols;</a> </li><li>  <a href="http://camel.apache.org/eip.html">Integration patterns</a> </li><li>  <a href="http://camel.apache.org/books.html">Ploznaya literature on the topic</a> </li><li>  <a href="https://github.com/camelinaction">Source code examples from the book Camel in Action</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/231861/">https://habr.com/ru/post/231861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231849/index.html">Old trick - always works?</a></li>
<li><a href="../231851/index.html">Visual Studio: VS developers fixed Caps Lock on their keyboards</a></li>
<li><a href="../231853/index.html">Hundreds of broken sites, or how code.jquery.com forgot to renew the SSL certificate</a></li>
<li><a href="../231855/index.html">Front-end developer tips</a></li>
<li><a href="../231859/index.html">The player continues to compete with the deceased father and does not want him to win, so as not to erase the ghost</a></li>
<li><a href="../231863/index.html">How-to: What is Russian Volatility Index and how it is calculated</a></li>
<li><a href="../231865/index.html">What's so complicated, or how I broke a new quadrocopter</a></li>
<li><a href="../231869/index.html">As we did a small security system on the RPi. Part 1</a></li>
<li><a href="../231871/index.html">Alexander Zharov gave an interview for Vedomosti</a></li>
<li><a href="../231875/index.html">How to use .NET from LoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>