<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a chatbot using Q & A Maker and Microsoft Graph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Most recently, we conducted a hackathon for developers in Bucharest and Cluj. The main task of the group in Cluj was to create an effective ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a chatbot using Q & A Maker and Microsoft Graph</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  Most recently, we conducted a hackathon for developers in Bucharest and Cluj.  The main task of the group in Cluj was to create an effective chat program with Endava support and using Microsoft Graph and Q &amp; A Maker.  Today we will talk about this project, affecting the management of authentication to interact with the robot program through any channel, integrating Q &amp; A Maker and using Microsoft Graph in conjunction with SharePoint.  More under the cut! <br><br><img src="https://habrastorage.org/webt/u5/wb/pd/u5wbpd9fu1jbrvhsxnajt8cwhpi.jpeg"><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  This project was created during a private hackathon for <a href="http://www.endava.com/en/">Endava</a> and Microsoft developers.  This hackathon was held in the cities of Cluj and Bucharest (Romania).  The participants' main task was to create prototypes of AI components that would improve the Endava web application used for IT support (for example, allow users to exchange natural language messages with chat software or optimize call management using machine learning technologies) . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The hackathon was conducted from January 30 to February 2, 2018. This GitHub page presents a piece of work that was completed in Cluj over three days.  The development team included: <br><br><ul><li>  Corina Ciocanya (Corina Ciocanea), developer (Endava) </li><li>  Alexandru Marchis (Alexandru Marchis), developer (Endava) </li><li>  Tudor Muresan, developer (Endava) </li><li>  Laurent Ellerbach, Team Leader, Technical Evangelists (Microsoft) </li></ul><br><h2>  Project Description </h2><br>  The main task of the group in Cluj was to create an effective chat program with support for several functions: <br><br><ul><li>  Convenient (for the user) creating a request directly in the Endava case management system. </li><li>  Creating an experimental version of a robot program that will request access to SharePoint through the Microsoft Graph, sending an email directly to the SharePoint owner or preparing a request to create an application in a specialized company application called Service Now. </li><li>  Use Q &amp; A Maker to find answers to user questions in the Endava pages with answers to questions. </li><li>  All authentication operations must be done through integration with Endava Active Directory. </li><li>  The solution should support the processing of e-mails, as previously the vast majority of users created appeals by sending e-mails. </li></ul><br>  Information contained in this document: <br><br><ul><li>  How to manage authentication to interact with the robot program through any channel, including e-mail. </li><li>  How to integrate Q &amp; A Maker with a robot program (the creation of a Q &amp; A Maker robot program will not be considered here). </li><li>  Use Microsoft Graph in combination with SharePoint and sending email.  The code here is part of a more complex solution that was developed in three days. </li></ul><br>  Architectural solution: <br><br><img src="https://habrastorage.org/webt/55/sn/ls/55snlsan3edtfwyx0-6h0hpzrp8.png"><br><br><h2>  Used technologies </h2><br>  The code for this solution uses the following technologies: <br><br><ul><li>  <a href="https://qnamaker.ai/">Q &amp; A Maker</a> ; </li><li>  <a href="https://dev.botframework.com/">Microsoft Bot Framework</a> ; </li><li>  <a href="https://developer.microsoft.com/en-us/graph/">Microsoft Graph</a> ; </li><li>  <a href="https://azure.microsoft.com/en-us/services/active-directory/">Azure Active Directory</a> ; </li><li>  <a href="http://luis.ai/">LUIS.ai</a> - a cognitive text recognition service with the ability to analyze sentences; </li><li>  all services were hosted in <a href="https://azure.microsoft.com/">Microsoft Azure</a> , the robot program was implemented as a web application; </li><li>  all code was written in C # in <a href="https://www.visualstudio.com/">Visual Studio Enterprise</a> ;  VSTS platform was used as a code repository. </li></ul><br><h2>  Authentication </h2><br>  Our idea was to provide the robot program with access to the context with information about a specific user (for example, to SharePoint sites) and the ability to send e-mail.  Therefore, the robot program was supposed to be safe and accessible only to employees. <br><br>  To solve these problems, authentication was required.  Its implementation was associated with a number of difficulties, for example, the robot program must be able to process e-mail, and therefore be able to authenticate the user in the absence of an internal authentication procedure.  Endava Azure Active Directory is an AAD version 1 service. Therefore, we used AAD 1 as the platform for the main robot program. When implementing authentication, it is recommended to consider the following: <br><br><ul><li>  If you use the code from the AuthBot example, be sure to save (copy) this mechanism.  This is important for security reasons.  The chat robot and your browser are in different contexts, blocking some attack vectors. </li><li>  Configure your AAD service to authorize for a specific application.  You will receive a client ID and a secret that will need to be entered in the desired part of the web.config file. </li><li>  Ensure that the correct return URL is in the application configuration file.  You can create several such addresses (for example, for the debug and for the working version), all of them must exactly match the redirect URL, so you need to specify the full path, including the protocol (https / http). </li><li>  Make sure that the AAD settings for the application for specific roles (for example, Sites.Read.All, Mail.ReadWrite, User.Read, People.Read, Directory.AccessAsUser.All) have the correct authorization parameters. </li></ul><br><br>  Authentication, security and authorization in the finished project are arranged as follows: <br><br><img src="https://habrastorage.org/webt/m5/oz/d0/m5ozd0ul6ixjsel7kzl0h9jhbko.png"><br><br>  As you can see, the main context depends on the authentication in AAD.  The following components work on the basis of AAD: <br><br><ul><li>  Internal Service Service Now, which we will not consider here. </li><li>  The core of the robot program, of which the web application is a part.  It uses the classic client ID and key. </li><li>  The program itself is a robot and cognitive services LUIS.  It also uses the classic client ID and key. </li><li>  Robot software and Q &amp; A Maker service.  It also uses the classic client ID and key. </li></ul><br><h2>  Configure keys and IDs to access all services </h2><br><h4>  AAD Setup </h4><br>  Now, after setting the necessary environment, you need to enter the correct values ‚Äã‚Äãof the parameters listed below into the web.config file. <br><br><ul><li>  The Tenant parameter matches your domain name for AAD.  This can be a second-level domain (yourdomain.com) or third (yourdomain.onmicrosoft.com), depending on the configuration. </li><li>  Settings ClientId (client ID) and ClientSecret (secret) you get when you configure the application. </li><li>  RedirectURL (redirect URL) - the URL where the robot program will be deployed.  In our example, this is a local node.  For a working version of the system, the URL will be different.  We remind you that when you configure the application, you can specify multiple URLs for all possible cases. </li></ul><br><pre><code class="cs hljs">&lt;!--  AAD Auth v1--&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.Mode"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"v1"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.ResourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"https://graph.microsoft.com/"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.EndpointUrl"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"https://login.microsoftonline.com"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.Tenant"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"YOUR_DOMAIN.COM"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.ClientId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"client_ID"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.ClientSecret"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"super_secret"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"ActiveDirectory.RedirectUrl"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"http://localhost:3979/api/OAuthCallback"</span></span> /&gt;</code> </pre> <br>  This setting is not the easiest task.  In case of an authentication error, the system will display a message that will help you understand where to look for the cause.  These messages are very detailed and quite helpful in troubleshooting.  In general, this setup can be quite complex;  You may need to contact your domain administrator to obtain certain access rights.  It is highly recommended to allocate enough time for this stage.  The good news is: as soon as this component works, you will not need to return to its configuration. <br><br><h4>  Setting up robot programs </h4><br>  At the stage of <a href="https://dev.botframework.com/">creating and registering a robot</a> program, the robot program name, ID and client key are generated.  These values ‚Äã‚Äãshould be added to the following lines in the web.config file: <br><br><pre> <code class="cs hljs"> &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"BotId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"YourBotId"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"MicrosoftAppId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"MicrosoftAppPassword"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> /&gt;</code> </pre> <br><h4>  Q &amp; A Maker Setup </h4><br>  When creating a <a href="https://qnamaker.ai/">Q &amp; A Maker,</a> you will also receive an ID and key.  They will be required in order to contact the service and receive recommendations.  Put the appropriate keys in the following lines of the web.config file: <br><br><pre> <code class="cs hljs"> &lt;!--  QnaMaker --&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"QnaMaker.KbId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"QAMaker_ID"</span></span> /&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span> key=<span class="hljs-string"><span class="hljs-string">"QnaMaker.KbKey"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=<span class="hljs-string"><span class="hljs-string">"QAMaker_Key"</span></span> /&gt;</code> </pre> <br><h4>  LUIS Setup </h4><br>  <a href="http://luis.ai/">LUIS is</a> used in the SharePoint Dialog to retrieve the URL or resource name of the SharePoint you want to access, as well as the type of access.  When you create and configure this (like almost any other) service, you will receive the ID and secret.  You will need to mark the class of the main dialog with the LUIS attribute: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">LuisModel(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Key-with-dash"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"secret"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SpDialog</span></span> : <span class="hljs-title"><span class="hljs-title">LuisDialog</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt;</code> </pre> <br><h2>  Code Authentication Management </h2><br>  Different authentication operations are implemented in the code a little differently.  The main authentication procedure is to contact the AAD service, in which the solution receives a token for subsequent calls to the Microsoft Graph. <br><br><h4>  Authentication in AAD </h4><br>  This mechanism works as follows: <br><br><img src="https://habrastorage.org/webt/m8/-6/qg/m8-6qgab-hehve8y_omvo4pphms.png"><br><br>  Most of the code is related to the AuthBot component.  As we have already discussed, it is important to migrate the code unchanged in order to block certain attack vectors.  Remember that the token is very important because it contains all the credentials needed to access a variety of information (including, in our case, to send email from the user's address).  Never try to save effort when working with a security system.  Protection should be given maximum attention. <br><br>  AAD authentication also works for email.  Please note: you can verify authentication when communicating via email only if the robot program runs in a production environment.  Emails are received from an Office 365 account and are processed approximately every ___ minutes. <br><br>  For a user, interaction with the system via e-mail is almost the same as other channels.  The user sends an email, the robot program sends an invitation to enter the system, in response to which the user must send the code.  The AuthBot base code has been changed in such a way as to make the interaction more convenient (in particular, reduce the number of emails sent and simplify code extraction). <br><br>  In response to the first letter, the robot program sends the user a message asking to follow the link in order to be authenticated.  After that, the user must send the code: <br><br><img src="https://habrastorage.org/webt/5j/ma/gn/5jmagnbxk2qh_vmgv4jip72bs84.png"><br><br>  After receiving it, the robot program sends a message about successful authentication.  All other messages that the user sends will be processed by the utility processes of the robot program, taking into account the context for this user.  Regardless of the communication channel (Teams or any other), the user can perform the same operations.  However, the e-mail channel is slightly different from others: in particular, it is worthwhile to limit the volume of letters sent to the user and take into account a number of additional assumptions.  More on this below. <br><br><img src="https://habrastorage.org/webt/rv/hx/fp/rvhxfpbem5doe5wjujyiohaypvg.png"><br><br>  Additional information about AuthBot is available on the appropriate <a href="https://github.com/MicrosoftDX/AuthBot">GitHub page</a> . <br><br><h4>  Authentication to interact with the robot program </h4><br>  For authentication when interacting with a robot program, components from the SDK are used to develop such programs.  If the main controller is marked with the attribute BotAuthentication, then the authentication mechanism using the key and secret mentioned in the previous section (in the section on configuration) will be used for it.  It is completely transparent, and if you copy these two elements to the web.config file without errors, it will work fine.  ID and secret you will need even in debug mode.  The emulator supports this mechanism and is great for checking if your pair is working. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">BotToQuerySharepoint</span></span> { [BotAuthentication] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessagesController</span></span> : <span class="hljs-title"><span class="hljs-title">ApiController</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> POST: api/Messages </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [BotAuthentication] public async Task</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;HttpResponseMessage&gt;</span></span></span><span class="hljs-comment"> Post([FromBody]Activity activity) { //  } } }</span></span></code> </pre> <br><h4>  Q &amp; A Maker Authentication </h4><br>  Keys are used to access the REST API.  The work is organized in a simple and obvious way.  Here is the code snippet: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageReceivedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, IAwaitable&lt;IMessageActivity&gt; item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> item; { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> kbId = ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"QnaMaker.KbId"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> kbKey = ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"QnaMaker.KbKey"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> qnaUrl = <span class="hljs-string"><span class="hljs-string">$"https://westus.api.cognitive.microsoft.com/qnamaker/v2.0/knowledgebases/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{kbId}</span></span></span><span class="hljs-string">/generateAnswer"</span></span>; HttpClient client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { question = strtosend, top = <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(JsonConvert.SerializeObject(json), Encoding.UTF8, <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>); content.Headers.Add(<span class="hljs-string"><span class="hljs-string">"Ocp-Apim-Subscription-Key"</span></span>, kbKey); HttpResponseMessage response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.PostAsync(qnaUrl, content); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.StatusCode == HttpStatusCode.OK) { <span class="hljs-comment"><span class="hljs-comment">//  ,   ,       } } }</span></span></code> </pre> <br>  The API is very simple.  Documentation is available <a href="https://westus.dev.cognitive.microsoft.com/docs/services/58994a073d9e04097c7ba6fe/operations/58994a073d9e041ad42d9baa">here</a> .  We use only one of the API, which returns no more than three answers to each question. <br><br><h4>  Authentication in LUIS </h4><br>  As explained in the previous section, to enable authentication, we simply specified a class attribute.  This mechanism is completely transparent. <br><br><h2>  Email Channel </h2><br>  As already mentioned, the email channel (like the SMS channel) has certain features.  In both cases, it is reasonable to strive to reduce the volume of transmitted messages.  To do this, we slightly changed the authentication process to reduce the number of emails and extract the code from the email. <br><br>  By sending an e-mail message, the user is unlikely to delete the previous correspondence and other unnecessary information - he will simply add a new text.  As a result, the letter will contain the user's signature and other elements.  Therefore, when interacting through this channel, additional work will be required to remove them.  As an example, here is the AzureAuthDialog code snippet from AuthBot: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.Text == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.ChannelId != <span class="hljs-string"><span class="hljs-string">"email"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(<span class="hljs-string"><span class="hljs-string">$",       ."</span></span>); } context.Wait(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MessageReceivedAsync); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,         (,          Teams)      string cleanedText = msg.Text; Match firstmatchedValue = Regex.Match(msg.Text, @"\d+", RegexOptions.IgnorePatternWhitespace); if (firstmatchedValue.Length &gt; 0) cleanedText = firstmatchedValue.Value; if (cleanedText.Length &gt;= 6 &amp;&amp; magicNumber.ToString() == cleanedText.Substring(0, 6)) { context.UserData.SetValue&lt;string&gt;(ContextConstants.MagicNumberValidated, "true"); context.Done($" {authResult.UserName}. You are now logged in. "); } else { context.UserData.RemoveValue(ContextConstants.AuthResultKey); context.UserData.SetValue&lt;string&gt;(ContextConstants.MagicNumberValidated, "false"); context.UserData.RemoveValue(ContextConstants.MagicNumberKey); await context.PostAsync($" ,     . ,      ."); context.Wait(this.MessageReceivedAsync); } }</span></span></code> </pre> <br>  To reduce the number of emails sent to the user, we do not just ask him to send back the received authentication code, but output it on the web page and ask the user to reply to the email.  As can be seen from the OAuthCallbackController code, the authentication procedure in AuthBot depends on the communication channel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Conversation.ResumeAsync(resumptionCookie, message); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.ChannelId == <span class="hljs-string"><span class="hljs-string">"skypeforbusiness"</span></span>) resp.Content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(<span class="hljs-string"><span class="hljs-string">$"&lt;html&gt;&lt;body&gt; !   , ,         :&lt;br/&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{magicNumber}</span></span></span><span class="hljs-string"> &lt;/body&gt;&lt;/html&gt;"</span></span>, System.Text.Encoding.UTF8, <span class="hljs-string"><span class="hljs-string">@"text/html"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.ChannelId == <span class="hljs-string"><span class="hljs-string">"email"</span></span>) resp.Content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(<span class="hljs-string"><span class="hljs-string">$"&lt;html&gt;&lt;body&gt; !   , ,              :&lt;br/&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{magicNumber}</span></span></span><span class="hljs-string"> &lt;/body&gt;&lt;/html&gt;"</span></span>, System.Text.Encoding.UTF8, <span class="hljs-string"><span class="hljs-string">@"text/html"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.Content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(<span class="hljs-string"><span class="hljs-string">$"&lt;html&gt;&lt;body&gt; !   , ,         :&lt;br/&gt; &lt;h1&gt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{magicNumber}</span></span></span><span class="hljs-string">&lt;/h1&gt;.&lt;/body&gt;&lt;/html&gt;"</span></span>, System.Text.Encoding.UTF8, <span class="hljs-string"><span class="hljs-string">@"text/html"</span></span>);</code> </pre> <br>  Each channel has a unique name.  This allows you to easily adapt the actions of your robot program to the type of channel. <br><br>  Another example is contained in the Q &amp; A Dialog (kbDialog) code of the main robot program: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> strtosend = message.Text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.ChannelId == <span class="hljs-string"><span class="hljs-string">"email"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = strtosend.Split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxidx = str.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxidx &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) maxidx = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; maxidx; i++) strtosend += str[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span>; }</code> </pre> <br>  The purpose of this code is to extract only the first part of the email and remove the signature.  It is assumed that a possible question is contained in the first three lines.  Below are the previous letters or the user's signature.  This is only an assumption, and it is not always satisfied, but during our three-day hackathon it worked perfectly. <br><br>  Another example is the Q &amp; A Maker code snippet, which controls the return of the response.  Usually the solution provides the user with no more than three options and asks him which one best suits him.  But if the user sends the question by e-mail, he expects to receive an answer, not a counter request.  We decided to do this: if the question was received by e-mail, the solution simply returns the first answer.  The option to include in the email the detailed content of all responses was also considered.  The following code snippet shows how this processing is performed: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qnaResponse.answers.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync( <span class="hljs-string"><span class="hljs-string">"      . \n    -     QNA?"</span></span>); context.Done(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((qnaResponse.answers.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) || (message.ChannelId == <span class="hljs-string"><span class="hljs-string">"email"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(qnaResponse.answers.First().answer); context.Done(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><h2>  Microsoft Graph and SharePoint </h2><br>  <a href="https://developer.microsoft.com/en-us/graph/">Microsoft Graph</a> is a single REST API for reading, modifying, and creating user data (examples: custom calendar, email, SharePoint content, and OneDrive).  As part of this project, we were interested in Graph API components for interacting with SharePoint and e-mail. <br><br>  To simplify our task, we used the Microsoft.Graph Nuget package.  Components from the Nuget-package process all requests and return objects.  But you need to authenticate and get the token yourself.  Fortunately, we have already prepared the authentication mechanism (and discussed above). <br><br>  As an example, the following is the function code that returns the name of the owner of a certain SharePoint site: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;UserInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOwnerNameForSite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> token, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> siteId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graphService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphServiceClient( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelegateAuthenticationProvider( (requestMessage) =&gt; { requestMessage.Headers.Authorization = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationHeaderValue(<span class="hljs-string"><span class="hljs-string">"bearer"</span></span>, token); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-number"><span class="hljs-number">0</span></span>); })); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> graphService.Sites[siteId] .Drives.Request() .GetAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> graphService.Users[s.First().CreatedBy.User.Id].Request().GetAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserInfo() { EmailAddress = user.Mail, Name = user.DisplayName }; }</code> </pre> <br>  When you create a GraphServiceClient object, you only need to transfer the token, as shown in the code, and after that you can call the necessary Graph functions. <br><br>  All returned items are very easy to analyze, so working with them is simple and logical.  In our case, we want to send an email to the SharePoint owner, so we need to get an email address and a name.  Then we will be able to contact the user by name and send a letter. <br><br>  Send an email using Microsoft Graph is also very simple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendEmail</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> accessToken, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> emailAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> body, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subject</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Message(); message.Body = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemBody() { Content = body, ContentType = BodyType.Text }; message.ToRecipients = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Recipient&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Recipient() {EmailAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmailAddress() {Address = emailAddress}} }; message.Subject = subject; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graphserviceClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphServiceClient( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelegateAuthenticationProvider( (requestMessage) =&gt; { requestMessage.Headers.Authorization = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationHeaderValue(<span class="hljs-string"><span class="hljs-string">"bearer"</span></span>, accessToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-number"><span class="hljs-number">0</span></span>); })); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> graphserviceClient.Me.SendMail(message, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).Request().PostAsync(); }</code> </pre> <br>  In this example, a simple text message is sent, but HTML is also supported.  It is also possible to send letters to several recipients.  We had only three days to release a ready-made solution, so we decided to create a working, but as simple as possible code. <br><br>  If the user has authenticated with his own credentials, the email will be sent from his mailbox and will be available in the Sent Items folder. <br><br>  You can experiment with all the features of Microsoft Graph on <a href="https://developer.microsoft.com/en-us/graph/graph-explore">this</a> site.  You can authenticate by specifying your own credentials, work with any functions, see how adding or deleting an area will affect the results. <br><br><h2>  Q &amp; A Maker Tips </h2><br>  Q &amp; A Maker is a great tool for preparing question-answer pairs very quickly and for launching a cognitive service from which you can get answers to questions.  This tool is very easy to integrate and very easy to use.  Work on this service is still underway.  The available version is for guidance only.  Here's what it looks like: <br><br><img src="https://habrastorage.org/webt/eq/du/o7/eqduo7ggbujw0oghe6oesom50jm.png"><br><br>  There are several ways to fill the list.  You can use the API (documentation is available <a href="https://westus.dev.cognitive.microsoft.com/docs/services/58994a073d9e04097c7ba6fe/operations/58994a073d9e041ad42d9baa">here</a> ), import the tsv file, or specify the URL. <br><br>  To use the Endava knowledge base, authentication was required, but to work with the Q &amp; A Maker, it was not.  Therefore, we had to export the base.  The data was stored in various formats, including HTML code, and we needed to clean this code. <br><br>  We cleaned the data with regular expressions: we removed the HTML tags, added tabs and line breaks.  Here is the code snippet: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    (   ‚Äî  ) result = System.Text.RegularExpressions.Regex.Replace(result, @"&lt;( )*style([^&gt;])*&gt;", "&lt;style&gt;", System.Text.RegularExpressions.RegexOptions.IgnoreCase); result = System.Text.RegularExpressions.Regex.Replace(result, @"(&lt;( )*(/)( )*style( )*&gt;)", "&lt;/style&gt;", System.Text.RegularExpressions.RegexOptions.IgnoreCase); result = System.Text.RegularExpressions.Regex.Replace(result, "(&lt;style&gt;).*(&lt;/style&gt;)", string.Empty, System.Text.RegularExpressions.RegexOptions.IgnoreCase); //    &lt;td&gt;   result = System.Text.RegularExpressions.Regex.Replace(result, @"&lt;( )*td([^&gt;])*&gt;", "\\t", //\t System.Text.RegularExpressions.RegexOptions.IgnoreCase);</span></span></code> </pre> <br>  You may ask why the tab character is written as \\ t rather than \ t.  The answer is the same as for the \\ n symbol.  The fact is that Q &amp; A Maker stores and returns answers in the form of raw text data.  The tsv file used cannot contain carriage returns or additional tabs, otherwise the system may not process it correctly.  The handlers for all channels correctly display the \ t and \ n characters, which makes it possible to better format the answer. <br><br>  Important note: in Q &amp; A Maker, you can store data with Markdown markup, but be aware that some channels may not support it!  The screenshot shows some of the line breaks \ n. <br><br>  We also added a link to the knowledge base home page in each answer.  These pages look better than plain text, and may contain images that we completely removed from our main code.  We tried to make the user as comfortable as possible. <br><br>  When you select the appropriate answer, Q &amp; A Maker analyzes the text of both the question and the answer.  Therefore, the answers should also be as detailed as possible. <br><br><h2>  LUIS Service Tips </h2><br>  Setting up the LUIS service is quite simple.  In our example, only one intent and three entities are used. <br><br>  LUIS works like this: <br><br><ul><li>  User request: I would like to have [read] access to the [Development] sharepoint site. </li><li>  LUIS understands the intent ‚Äî access to SharePoint ‚Äî and extracts two entities: [read] and [Development]. </li></ul><br>  To process an intent and call a specific function from your LUIS dialog class, simply mark the function with an attribute with the name of your intent, as shown below: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">LuisIntent(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sp-access"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSpAccessRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, LuisResult luisResult</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessToken = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.GetAccessToken( ConfigurationManager.AppSettings[ <span class="hljs-string"><span class="hljs-string">"ActiveDirectory.ResourceId"</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//,   ‚Äî Graph API SpFormHandler formHandler = new SpFormHandler(); IFormDialog&lt;SharepointModel&gt; formDialog = formHandler.GetFormDialog(luisResult.Entities, accessToken); context.Call(formDialog, OnFormComplete); }</span></span></code> </pre> <br>  The interaction with the SharePoint robot program is much more linear, so we replace the LUIS dialogue with a dialogue through a form, which is much easier to work with in the case of linear questions.  Most of the SharePoint issue handling code belongs to the SpFormHandler form.  This is an elegant way to combine multiple dialogs.  As can be seen from the code, any object can be passed to the constructor: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SpFormHandler</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IFormDialog&lt;SharepointModel&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFormDialog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;EntityRecommendation&gt; entities, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharepointModel(); spForm.Token = token; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (EntityRecommendation entity <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> entities) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity.Type == <span class="hljs-string"><span class="hljs-string">"sp-sitename"</span></span> || entity.Type == <span class="hljs-string"><span class="hljs-string">"builtin.url"</span></span>) { spForm.SitenameOrUrl = entity.Entity; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity.Type == <span class="hljs-string"><span class="hljs-string">"sp-accessright"</span></span>) { Enum.TryParse(entity.Entity, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> AccessRights rights); spForm.AccessRights = rights; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormDialog&lt;SharepointModel&gt;(spForm, BuildForm, FormOptions.PromptInStart); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IForm&lt;SharepointModel&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildForm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } }</span></span></code> </pre> <br>  Both entities from LUIS and token are transmitted.  Entities are used to obtain the URL or resource name of the SharePoint, as well as the type of access requested.  LUIS contains many embedded entities, such as a URL.  We strongly recommend using them: they work well and help save time. <br><br>  Branching various dialogs, combining LUIS dialogs, dialogs using forms and ordinary dialogs with regard to solvable subtasks is a fully justified and workable approach. <br><br><h2>  Conclusion and further action </h2><br>  The code for this project is only part of the code written in three days, but it is a good example of a combination of different technologies: authentication via Azure Active Directory, interaction with a robot program through various channels, including email, use of cognitive services, such as Q &amp; A Maker and LUIS, via Microsoft Graph. <br><br>  The published code and documentation form a fully functional solution.  You can try out in practice both a partial and complete solution.  To work with the Microsoft Graph component, you will need to authenticate and get a token.     ¬´¬ª,   Azure Active Directory     ,      .         . <br><br>        ,            . <br><br><h2>  about the author </h2><br><img src="https://habrastorage.org/webt/1d/cw/dy/1dcwdypupdqumgtbsq8uytibl5k.jpeg" align="left" width="120"> <b><a href="https://www.github.com/ellerbach"> </a></b>          ,    ,  -  , ,      .        ,      ,         .      Microsoft,    20    .         ,   ,    . </div><p>Source: <a href="https://habr.com/ru/post/351944/">https://habr.com/ru/post/351944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351932/index.html">Installing Debian with a root on an encrypted ZFS mirror</a></li>
<li><a href="../351936/index.html">New life for XMPP. Making an instant messenger that fails to block</a></li>
<li><a href="../351938/index.html">Video Streaming with Azure and .NET</a></li>
<li><a href="../351940/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "Conscience, Values ‚Äã‚Äãand Own Ideals"</a></li>
<li><a href="../351942/index.html">Why putting the most selective columns in the composite index prefix is ‚Äã‚Äãnot always good</a></li>
<li><a href="../351946/index.html">Arduino controller with temperature sensor and Python interface for dynamic identification of control objects</a></li>
<li><a href="../351948/index.html">Analysis of data in sports: the interaction of scientists, clubs and federations. Lecture in Yandex</a></li>
<li><a href="../351950/index.html">The artist encrypted the keys to the cryptocross in Lego-installations, and we will try to get them from there</a></li>
<li><a href="../351952/index.html">Data collection terminal for USAIS, or the illusion of deception</a></li>
<li><a href="../351958/index.html">FastTrack Training. "Network Basics". "Cisco Software Products for Security." Eddie Martin December 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>