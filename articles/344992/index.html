<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stack: analyze parameter values</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Very often, looking at the fall stack, I want to see, and with what values ‚Äã‚Äãof the parameters the calls were made. Under the debugger in VisualStudio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stack: analyze parameter values</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rg/o7/u7/rgo7u7eooe3q72no75h_jdfyelg.jpeg"></div><br>  Very often, looking at the fall stack, I want to see, and with what values ‚Äã‚Äãof the parameters the calls were made.  Under the debugger in VisualStudio we can see these values.  But what if the program is launched without a debugger and handles exceptions on its own?  For answers, welcome under cat. <br><a name="habracut"></a><br>  The question of the values ‚Äã‚Äãof the parameters for us is not idle.  Is it almost the first question that developers ask when they try our <a href="https://github.com/DevExpress/Logify.Alert.Clients/tree/develop/dotnet">crash reporter</a> : ‚ÄúCan we see the parameter values?‚Äù <br><br>  Well, we investigate the problem in more detail. <br><br>  Regardless of whether the exception is handled by us or not, initially we have the Exception object itself (and its InnerException chain). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The drop stack is extracted from the <a href="https://msdn.microsoft.com/en-us/library/system.exception.stacktrace(v%3Dvs.110).aspx">Exception.StackTrace</a> property, or you can get it in a slightly more detailed form by creating an object of type <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.stacktrace%2528v%3Dvs.110%2529.aspx">System.Diagnostics.StackTrace</a> .  And if the <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.stackframe(v%3Dvs.110).aspx">frames</a> contained in StackTrace can determine which <a href="https://msdn.microsoft.com/en-us/library/system.reflection.methodinfo(v%3Dvs.110).aspx">methods</a> were called, and what <a href="https://msdn.microsoft.com/en-us/library/system.reflection.methodbase.getparameters(v%3Dvs.110).aspx">signatures</a> they have, then the values ‚Äã‚Äãof the parameters and the links to the objects (this) cannot be determined. <br><br>  What to do?  Once the runtime from the box does not give us the information we need, we will try to collect it ourselves. <br><br>  Take the simplest code: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work</span></span></span><span class="hljs-function">)</span></span> { DoInnerWork(work, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoInnerWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> times</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; o.ToString(); }</code> </pre> <br>  Wrap up the contents of the try / catch methods.  We will register each caught exception along with the values ‚Äã‚Äãof the method parameters and send further: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DoInnerWork(work, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogifyAlert.Instance.TrackArguments(ex, work); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoInnerWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> innerWork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> times</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; o.ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogifyAlert.Instance.TrackArguments(ex, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, innerWork, times); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br>  The Track method will have a signature: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception ex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  and it will add the values ‚Äã‚Äãof the arguments to the internal list or to the dictionary so that they can be bound to the corresponding lines from <a href="https://msdn.microsoft.com/en-us/library/system.exception.stacktrace(v%3Dvs.110).aspx">Exception.StackTrace</a> .  It is also important to clear the received list at the right moments, otherwise its contents will become irrelevant already for the second exception thrown.  What are these moments?  Logging into the method and successful (without throwing an exception) quitting it, as well as logging into the global exception handler.  Like this: <br><br><div class="spoiler">  <b class="spoiler_title">Warning, govnokod</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work</span></span></span><span class="hljs-function">)</span></span> { LogifyAlert.Instance.ResetTrackArguments(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DoInnerWork(work, <span class="hljs-number"><span class="hljs-number">5</span></span>); LogifyAlert.Instance.ResetTrackArguments(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogifyAlert.Instance.TrackArguments(ex, work); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoInnerWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> innerWork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> times</span></span></span><span class="hljs-function">)</span></span> { LogifyAlert.Instance.ResetTrackArguments(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; o.ToString(); LogifyAlert.Instance.ResetTrackArguments(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogifyAlert.Instance.TrackArguments(ex, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, innerWork, times); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodWithHandledException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work</span></span></span><span class="hljs-function">)</span></span> { LogifyAlert.Instance.ResetTrackArguments(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DoInnerWork(work, <span class="hljs-number"><span class="hljs-number">5</span></span>); LogifyAlert.Instance.ResetTrackArguments(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { HandleException(ex); LogifyAlert.Instance.ResetTrackArguments(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentDomain_UnhandledException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, UnhandledExceptionEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = LogifyAlert.Instance.MethodArgumentsMap; ExceptionTracker.Reset(); <span class="hljs-comment"><span class="hljs-comment">// handle exception below }</span></span></code> </pre><br></div></div><br>  It looks enchanting, the code finally turned into something unreadable <s>shit</s> .  The first reaction is to tear down and forget, like a bad dream.  It stops only that, whatever one may say, the principle is unchanged, and you still have to collect the values ‚Äã‚Äãof the parameters <a href="https://www.youtube.com/watch%3Fv%3DhD8ch1scAjs">with your own hands</a> (carefully, 18+, a lot of mate).  The beauty questions of the code will definitely be solved, but only after we have achieved the efficiency of the system. <br><br>  How to bind parameter values ‚Äã‚Äãto stack lines?  According to the sequence number of the frame in the stack, certainly!  At that moment, when we create <a href="https://msdn.microsoft.com/en-us/library/system.diagnostics.stacktrace%2528v%3Dvs.110%2529.aspx">System.Diagnostics.StackTrace</a> , the current frame always has an index of 0, and the number of frames may be different.  When the exception is thrown for the first time, the number of frames (stack depth) is maximum, in all subsequent rethrows of the same exception, the stack depth will only be less.  Thus, the line number on the stack (for a specific exception) is the difference between the maximum and current stack depth.  In the form of code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception ex, MethodCallInfo call</span></span></span><span class="hljs-function">)</span></span> { StackTrace trace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackTrace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameCount = trace.FrameCount; MethodCallStackArgumentMap map; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!MethodArgumentsMap.TryGetValue(ex, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> map)) { map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallStackArgumentMap(); map.FirstChanceFrameCount = frameCount; MethodArgumentsMap[ex] = map; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineIndex = map.FirstChanceFrameCount - frameCount; map[lineIndex] = call; }</code> </pre><br>  Where MethodCallInfo looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MethodCallInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MethodBase Method { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; Arguments { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Bind done.  We write in crash report, send it to the server along with <a href="https://msdn.microsoft.com/en-us/library/system.exception.stacktrace(v%3Dvs.110).aspx">Exception.StackTrace</a> , and there we will deal with the display.  We get something similar to: <br><br><img src="https://habrastorage.org/webt/gb/mu/cg/gbmucgeqma6nd6fdrfvs44jqk_o.png"><br><br>  The principal performance of the approach is proven, now we need to make sure that the code does not become as scary as a nuclear war, and ideally, that there would be no need to write any code at all. <br><br>  We recall about such a useful thing in the household as <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25BF%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">AOP</a> . <br><br>  We try, for example, <a href="https://github.com/castleproject/Core">Castle.DynamicProxy</a> , create an interceptor: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MethodParamsInterceptor</span></span> : <span class="hljs-title"><span class="hljs-title">IInterceptor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intercept</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IInvocation invocation</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { LogifyAlert.Instance.ResetTrackArguments(); invocation.Proceed(); LogifyAlert.Instance.ResetTrackArguments(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogifyAlert.Instance.TrackArguments( ex, CreateMethodCallInfo(invocation) ); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-function"><span class="hljs-function">MethodCallInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMethodCallInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IInvocation invocation</span></span></span><span class="hljs-function">)</span></span> { MethodCallInfo result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallInfo(); result.Method = invocation.Method; result.Arguments = invocation.Arguments; result.Instance = invocation.Proxy; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  We connect the crash reporter: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = LogifyAlert.Instance; client.ApiKey = <span class="hljs-string"><span class="hljs-string">"&lt;my-api-key&gt;"</span></span>; client.StartExceptionsHandling();</code> </pre><br>  Create a test class using an interceptor: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxy = generator.CreateClassProxy&lt;ThrowTestExceptionHelper&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodParamsInterceptor() ); proxy.DoWork(<span class="hljs-string"><span class="hljs-string">"work"</span></span>);</code> </pre><br>  Perform and look at the result: <br><br><img src="https://habrastorage.org/webt/8i/jg/eq/8ijgeq9ybrtgazu91_0lbdpqy20.png"><br><br>  Everything worked well, but there are as many as BUT: <br><br><ul><li>  The stack is now very cluttered with Castle's frames. </li><li>  Interception only works with virtual methods and interfaces. </li><li>  Creating objects has become rather cumbersome. </li></ul><br>  The last point is the most critical - we will have to significantly rewrite the project‚Äôs message just for the sake of the parameter values ‚Äã‚Äãon the stack.  A game of powder is hardly worth it. <br><br>  Or maybe "there is the same, but with pearl buttons"?  And there is, <a href="https://www.postsharp.net/">PostSharp</a> .  We realize the aspect: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Assembly | AttributeTargets.Module)</span></span>] [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">OnMethodBoundaryAspect</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompileTimeValidate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodBase method</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.GetCustomAttribute(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IgnoreCallTrackingAttribute)) != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || method.Name == <span class="hljs-string"><span class="hljs-string">"Dispose"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CompileTimeValidate(method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEntry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodExecutionArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnEntry(args); LogifyAlert.Instance.ResetTrackArguments(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSuccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodExecutionArgs args</span></span></span><span class="hljs-function">)</span></span> { LogifyAlert.Instance.ResetTrackArguments(); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnSuccess(args); } [MethodImpl(MethodImplOptions.NoInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodExecutionArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Exception == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Method != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; args.Arguments != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; args.Instance != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) LogifyAlert.Instance.TrackArguments(args.Exception, CreateMethodCallInfo(args)); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnException(args); } <span class="hljs-function"><span class="hljs-function">MethodCallInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMethodCallInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodExecutionArgs args</span></span></span><span class="hljs-function">)</span></span> { MethodCallInfo result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallInfo(); result.Method = args.Method; result.Arguments = args.Arguments; result.Instance = args.Instance; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  There are several nuances in the code.  First, we forbid PostSharp to instruct methods marked with the IgnoreCallTrackingAttribute attribute.  For what?  We recall this code here: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentDomain_UnhandledException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, UnhandledExceptionEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = LogifyAlert.Instance.MethodArgumentsMap; ExceptionTracker.Reset(); <span class="hljs-comment"><span class="hljs-comment">// handle exception below }</span></span></code> </pre><br>  What happens if I call it if PostSharp overwrites it?  The OnEntry method of the aspect will be called, which, first of all, will clean up the call parameters we collected with such difficulty.  Epic Fail.  Therefore, all methods where we need to refer to MethodCallArgumentsTracker should be marked with the IgnoreCallTrackingAttribute attribute. <br><br>  Second: forbid rewriting Dispose.  It would seem, why <s>here Luzhkov</s> ?  And then, that we have an exception from the depths of the application, and along the way, the catch, finally and other code are executed with might and main, the references to local objects are lost, the GC starts cleaning them.  In general, the likelihood of Dispose being performed during this period is quite high, and in order to ruin the contents of LogifyAlert.Instance.MethodArgumentsMap ‚Äúone tablet is enough‚Äù. <br><br>  The third nuance in the strange test: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Method != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; args.Arguments != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; args.Instance != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) LogifyAlert.Instance.TrackArguments( args.Exception, CreateMethodCallInfo(args) );</code> </pre><br>  The fact is that PostSharp aggressively optimizes code that embeds in methods.  And if we do not explicitly turn to the MethodExecutionArgs fields, then we get quite kosher null in the values ‚Äã‚Äãof these fields, which, of course, will make us all further logic meaningless. <br><br>  So, with a slight movement of the hand, we apply the aspect to the entire assembly: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: CollectParams</span></span>]</code> </pre><br>  Perform and watch crash report: <br><br><img src="https://habrastorage.org/webt/nd/tr/in/ndtrin7mcldok2czvutl7fhyxxq.png"><br><br>  The stack looks <s>as good</s> as old, nothing superfluous.  Changes in the existing code are minimal.  The result is close to the ideal!  Of the potential drawbacks - use PostSharp, as such, in the build process.  Perhaps this will alienate someone. <br><br>  What other options are there besides PostSharp and others like it? <br><br>  First of all, this is writing a profiler and using the methods <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method">ICorProfilerInfo :: GetILFunctionBody</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilerinfo-setilfunctionbody-method">ICorProfilerInfo :: SetILFunctionBody</a> in order to modify the bodies of the methods directly during program execution.  A good series of articles on how to do this can be found <a href="http://blog.monstuff.com/archives/000058.html">here</a> .  A good selection of links on the topic <a href="http://mcsimm.blogspot.ru/2009/01/getting-started-with-net-profiling-api.html">here</a> . <br><br>  pros <br><br><ul><li>  CLR features are used; </li><li>  no modification of the source code is required at all; </li><li>  Everything will work in runtime. </li></ul><br>  Minuses <br><br><ul><li>  will work in runtime, which means a bit to slow down the program. </li><li>  The profiler <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview">cannot be written</a> in managed code. </li><li>  the profiler assembly must be registered in the system </li><li>  Before starting the application, you need to properly <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/setting-up-a-profiling-environment">configure the environment</a> . </li></ul><br>  There are still hacker methods, only hardcore, worthy of <a href="http://lurkmore.to/%25D0%25A7%25D0%25B0%25D0%25BA_%25D0%259D%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581">Chuck Norris</a> , who is known: <br><br><img src="https://habrastorage.org/webt/4u/zn/xg/4uznxgc0zadnejiue0swglzhfrg.jpeg"><br><br>  Here is described the approach that if you manage to correctly determine the addresses of some non-public functions of the JIT implementation, you can try to carefully use them to replace the IL-code of the methods immediately before compiling them into the native code.  The disadvantages are that it is not easy to determine the addresses of functions correctly, and that they can change regularly with updates.  So, the author simply did not earn an example from the article, since  necessary addresses could not be determined.  Another minus is that the approach will not work if the assembly has been processed with <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator">NGen</a> . <br><br>  Another <a href="https://habrahabr.ru/post/307088/">elegant description of the</a> original method of intercepting methods was published by ForwardAA <a href="https://habrahabr.ru/users/forwardaa/" class="user_link">comrade</a> , here, in Habr√©.  It is quite possible that with proper file modification, his approach can be adapted for the task of collecting the values ‚Äã‚Äãof the call arguments.  Of the benefits, it is likely that the approach will work even after processing the assembly with <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator">NGen</a> . <br><br><h4>  Conclusion </h4><br>  The most reliable method at the moment to collect the values ‚Äã‚Äãof the call arguments at the moment of the exception is the use of Postsharp.  <a href="https://github.com/DevExpress/Logify.Alert.Clients/tree/develop/dotnet">Logify</a> client can bind collected values ‚Äã‚Äãto the stack written when an exception occurred.  Due to this, in some cases, the resulting crash report may be much more informative than containing only the stack. </div><p>Source: <a href="https://habr.com/ru/post/344992/">https://habr.com/ru/post/344992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344982/index.html">Lectures of the Technosphere. Neural networks in machine learning</a></li>
<li><a href="../344984/index.html">Automated correction of indentation in layout based on typographic styles and text metrics</a></li>
<li><a href="../344986/index.html">Dependency injection in .Net Mark Siman 3 - Cross-cutting aspects of the application, interception, decorator</a></li>
<li><a href="../344988/index.html">Seriously, games?</a></li>
<li><a href="../344990/index.html">Avito Product Analytics Meetup - video, photo, slides</a></li>
<li><a href="../344994/index.html">Netflix selects the best movie covers for each viewer.</a></li>
<li><a href="../344996/index.html">Evaluation of option premiums - analytical formulas vs modeling</a></li>
<li><a href="../344998/index.html">One day at Alpha Lab: Java development</a></li>
<li><a href="../345000/index.html">R and Information Security. How to eliminate the contradiction of interests and run R on Linux in offline mode</a></li>
<li><a href="../345002/index.html">Naive Spellchecking, or search for the nearest words from the dictionary by Levenshtein's metric on Scala</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>