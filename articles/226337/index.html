<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's play evolution? Genetic Algorithms in a Screensaver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last month in the army. Gradually freeing up time for various interesting projects. It remains only to decide what exactly to occupy the brain. I fini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's play evolution? Genetic Algorithms in a Screensaver</h1><div class="post__text post__text-html js-mediator-article">  Last month in the army.  Gradually freeing up time for various interesting projects.  It remains only to decide what exactly to occupy the brain.  I finished reading <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BA%25D0%25B8%25D0%25BD%25D0%25B7,_%25D0%259A%25D0%25BB%25D0%25B8%25D0%25BD%25D1%2582%25D0%25BE%25D0%25BD_%25D0%25A0%25D0%25B8%25D1%2587%25D0%25B0%25D1%2580%25D0%25B4">Richard Dawkins's</a> ‚Äú <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25B3%25D0%25BE%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B3%25D0%25B5%25D0%25BD">Selfish Gene</a> ‚Äù and the idea was formulated - I want to make a visualization using the principles of evolution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95c/c05/053/95cc05053b5177df860df891633b54b8.jpg" alt="image"><br>  Figure 1. The bacterial population rearranges the environment to fit its needs. <br><br>  So, go ahead! <br><a name="habracut"></a><br><ul><li>  Petri dish and program idea </li><li>  Programming language, environment, libraries </li><li>  Working version too simple </li><li>  Additional ideas </li><li>  The first interesting results </li><li>  Optimization, config </li><li>  Behavior programming </li><li>  Useful features </li><li>  Debriefing, plans </li><li>  Links to the program, source code, instructions </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ZHPl4VeZuyA%3Ffeature%3Doembed&amp;xid=17259,1500004,15700023,15700186,15700191,15700253&amp;usg=ALkJrhgEpymxChblRTgQoLBUMnGYPWfG9Q" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Petri dish and program idea </h5><br>  Imagine a Petri dish with a viscous nutrient fluid on a flat surface.  Somewhere the concentration of food is higher, somewhere - below.  We added a viscous poison to some parts of the cup, a signal substance (‚Äúpheromone‚Äù) to some, and then we evenly distributed a colony of bacteria over the surface.  All that remains for us is to observe their growth, interesting mutations that increase adaptability to a particular environment.  I wanted to do something similar. <br><br>  With the Petri dish itself (the playing field), everything was clear from the very beginning - a two-dimensional array of concentrations of food, poison and pheromone, which each frame slowly mixes (with ordinary blur).  The game field is closed - is the surface of the torus.  But with the implementation of bacteria is not so simple.  If they are discretely located on the field, each in a specific cell, I will receive another cellular automaton, only with complex rules.  Therefore, it is worth making for them an elementary physical model - without collisions, but with float coordinates, speed and friction.  And the food, poison or pheromone with which the bacterium interacts will be selected from the nearest field cell. <br><br>  Bacteria receive energy from the nutrient medium, capable of releasing poison and pheromone.  Accumulated food is spent every second, any action (movement, turns, release) also spends internal resources.  Bacteria multiply free of charge, by simple division, after having accumulated a certain amount of food.  In addition, the body has glasses of life, decreasing in a toxic environment or during hunger.  A dying bacterium leaves behind a small supply of food.  The poison will restrain the reproduction of bacteria, and the signal substance will allow one creature to inform others: ‚Äúthis territory is already occupied, it is not profitable to get food here‚Äù (the more bacteria in one place, the greater the pheromone concentration there and, probably, the less food there is). <br>  The idea is formulated, it's time to start implementation. <br><br><h5>  Programming language, environment, libraries </h5><br>  I cheated a little and used my recent project as a starting point, at the core of which I had everything I needed - working with configs, mouse, keyboard and camera.  Language - C ++ 11 ( <a href="http://sourceforge.net/projects/mingwbuilds/">GCC 4.8.1, on MinGW</a> ), development environment - <a href="https://netbeans.org/">NetBeans 7.4</a> (and sometimes <a href="http://www.sublimetext.com/3">Sublime Text 3</a> ) I chose <a href="http://www.sfml-dev.org/">SFML 2.1</a> as a library for working with graphics (OpenGL), and jsoncpp to save configuration <a href="http://sourceforge.net/projects/jsoncpp/">files</a> .  Unfortunately, at the beginning of development it was not possible to install a version control system, and this greatly spoiled life.  As soon as such an opportunity appeared - <a href="http://mercurial.selenic.com/">mercurial</a> with <a href="http://tortoisehg.bitbucket.org/">tortoiseHg</a> .  As you can see, everything is cross-platform and, if desired, it will be possible to play on other systems (at the moment there is only XP at hand). <br><br><h5>  Working version too simple </h5><br>  I initially made the field for liquids as arrays of floating point numbers, because of this the slowest part of the program was the blurring of this field on the CPU.  However, about optimizations later.  Movement of bacteria is very simple, in fact, all of physics is successfully processed by this piece of code (using <a href="http://ru.wikipedia.org/wiki/%25C8%25ED%25F2%25E5%25E3%25F0%25E8%25F0%25EE%25E2%25E0%25ED%25E8%25E5_%25C2%25E5%25F0%25EB%25E5">Verlet</a> integration): <br><br><pre><code class="cpp hljs">Math::Vector tmp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;position += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;position - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;old_position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;old_position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;position - (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;settings.friction) * (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;position - tmp);</code> </pre> <br><br>  Now about mutational variability and behavior.  There was no wish to change ‚Äúphysical‚Äù parameters, such as movement speed or size, because it is much more interesting to change behavior.  Therefore, each bacterium contains an array of actions: <br><br><pre> <code class="cpp hljs">MOVE, ROTATE_LEFT, ROTATE_RIGHT, CREATE_FEROMON, CREATE_POISON</code> </pre><br><br>  Each action is a floating point number, its value determines the ‚Äústrength‚Äù of the movement.  Thus, when cloning a bacterium, the value of any action may change with some probability. <br><br>  Obviously, you cannot boil porridge with such a ‚Äúcomplex‚Äù behavior, but the result was even worse than we would like.  All the bacteria that released the poison, quickly died, leaving no offspring.  Nobody (except for me) paid attention to the pheromone secreted (bacteria have not had sensors yet).  As a result, everyone just swam, devouring food under him and with the accumulation of food needed for reproduction, they created the same confused creatures. <br><br>  The only beautiful result came out when I tuned up the bacteria for low resistance to poison, but a large amount of food released after death.  In this case, although they were dying from the venom excreted, they managed to leave enough offspring to continue the race in a nutrient and aggressive environment. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36f/4e5/195/36f4e51959487dd025082c2e6ed06b19.png" alt="image"><br>  Figure 2. Rapid Cloning and Toxic Environment <br><br><h5>  Additional ideas </h5><br>  Apparently, the idea of ‚Äã‚Äãa toxic "poison" and a signal "pheromone" works very badly: <br><ul><li>  It is not profitable to produce poison, which kills the manufacturer and its descendants. </li><li>  It is not profitable to produce pheromone (and in the presence of receptors, too), which indicates the presence of bacteria, but does not report its "form" </li></ul><br><br>  I gave up two independent substances with different properties and instead of them made ‚Äúan ideal environment point‚Äù for each bacterium - the ratio of two liquids (POISON and FEROMON, left the names different for convenience), at which the environment does not cause bacteria damage.  The stronger the ratio, the more toxic this mixture is for the creature.  The value of this point (resist) is transmitted from the parent bacteria to the daughter with a small distortion. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71f/7cf/88a/71f7cf88ad28b52a9d2d2282e486b7ee.png" alt="image"><br>  Scheme 1. The ideal environment for the body <br><br><h5>  The first interesting results </h5><br>  Thus, there are whole populations of living beings that can survive in different environments and who benefit from transforming the world around them.  There should have been competition, because the ideal environment of one population is poison for another, and each population needs to get food.  So it happened: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57b/605/344/57b605344e000377b7980219e987f3ff.gif" alt="image"><br>  Figure 3. Two different populations rebuilding the environment. <br><br><h5>  Optimization </h5><br>  The result is interesting, but the speed leaves much to be desired: 50 - 60 milliseconds per frame give 16-20 FPS.  For profiling, I use gprof, but without it, it is clear that the bottleneck of the program is the blurring of the array of ‚Äúliquids‚Äù on the CPU.  And the current implementation (3 liquids of different colors, should be blurred and displayed on the screen) and asks to be rewritten on the GPU.  In SFML it is very easy to work with shaders and texture rendering.  One drawback - there is no support for floating-point textures.  So we transfer all fluids from float (from -1.0 to 1.0) to unsigned char (0, 255) and store as sf :: Image.  When updating the field, we render it in texture, with a shader blur.  We write the GLSL fragmentary shader (for a start, the usual arithmetic average of the current texel and its neighbors is enough, perhaps with some coefficients): <br><br><pre> <code class="hljs pgsql">uniform sampler2D texture; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> blurSize; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> horizontalPass; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> sigma; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> width; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> height; vec2 ranged(vec2 v) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vx &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) vx += <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vx &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) vx -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vy &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) vy += <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vy &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) vy -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; } <span class="hljs-type"><span class="hljs-type">void</span></span> main() { vec2 texcoordOffset = vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) / vec2(width, height); <span class="hljs-type"><span class="hljs-type">float</span></span> k0 = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> k1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> k2 = <span class="hljs-number"><span class="hljs-number">0.357</span></span>; vec4 avgValue = texture2D(texture, gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st) * k0 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>))) * k1 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>))) * k1 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>))) * k1 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>))) * k1 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>))) * k2 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>))) * k2 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>))) * k2 + texture2D(texture, ranged(gl_TexCoord[<span class="hljs-number"><span class="hljs-number">0</span></span>].st - texcoordOffset * vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>))) * k2; gl_FragColor = avgValue / (k0 + <span class="hljs-number"><span class="hljs-number">4.0</span></span> * k1 + <span class="hljs-number"><span class="hljs-number">4.0</span></span> * k2); }</code> </pre><br><br>  The speed of work immediately increased by 2 - 2.5 times.  Spaces for optimizations remain.  Using <a href="http://en.wikipedia.org/wiki/Gprof">gprof</a> , we find some more bottlenecks. <br><br>  But still, the most unpleasant bottleneck is the magic numbers in the code, due to which the project has to be re-compiled each time the settings are changed.  Transfer all settings to json-config is quite simple, but the result is worth it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52c/6c2/bca/52c6c2bca607da304b1762cd5b321577.gif" alt="image"><br>  Figure 5. Restructuring the environment with similar populations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95e/b67/e3e/95eb67e3ef89bf42cae45ca75b299a25.gif" alt="image"><br>  Figure 6. Slow Colony Growth <br><br><h5>  Behavior programming </h5><br>  At the moment, the bacteria can not change their behavior.  The array of actions defining its actions varies slightly only among the descendants of the bacterium, remaining constant throughout its life.  In general, the behavior of the population is gradually changing, due to the evolutionary process - harmful mutations are cut off, useful - accumulate.  But the benefits here are a very relative concept. <br><br>  For example, the bacterium is in the environment {FEROMON = -0.5, POISON = 0.2}, and its ideal medium is {FEROMON = 0.6, POISON = 0.6}.  It means that it is advantageous to produce both substances in a small amount in order to bring the environment closer to the ideal one.  But she will not be able to stop, and after a while, continuing to synthesize poison and pheromone, she will move away from the ideal and destroy herself.  What if you ‚Äúteach the bacterium‚Äù to monitor the environment and make decisions? <br><br>  It remains to decide how to do it.  There is an idea of ‚Äã‚Äãan assembly-like language, whose instructions will constitute the genocode of the bacterium.  But in this case, you need a lot of mutations to move from one useful program of action to another, and the vast majority of mutations will be completely lethal. <br><br>  Perhaps neural networks?  I tried for each bacterium to make a brain from a small perceptron in 2 layers and several feedbacks.  The weights of bonds in the creation of the first bacteria are random and mutate in their descendants.  It turned out even worse than no brain at all.  I did not expect that this small experiment will bring positive results - I confess, I almost never worked with neural networks of any kind.  I suppose that evolutionary selection was simply not able to leave the best-fit neural networks, since  the environment around the bacteria is too aggressive for a long life, and the neural networks at first are completely untrained and give out meaningless, or even harmful, commands for the bacteria. <br><br>  Soon a new idea appeared - conditions.  The condition in my case looks like this: <br>  1 Receptor - which input data will influence the result: FOOD, FEROMON, POISON, SPEED, FAT, LIFE, FEROMON_RESIST, POISON_RESIST; <br>  2 Conditional interval - interval, receptor values, in which the condition will be considered true <br>  3 Action - what exactly the condition affects: MOVE, ROTATE_LEFT, ROTATE_RIGHT, CREATE_FEROMON, CREATE_POISON <br>  4 Operation - how the action will change when the condition is fulfilled: APPEND (the action value is added to "impact force"), DEDUCT (the action force is subtracted from the action value), CLEAR (action value becomes zero) <br>  5 Impact force - the number by which the action will change. <br><br>  So, the condition: <br><br><pre> <code class="cpp hljs">RECEPTOR[min, max], ACTION,OPERATION,VALUE.</code> </pre><br><br>  Take the situation with the bacterium in the environment {-0.5, 0.2} and with the ideal medium {0.6, 0.6}.  Such a set of conditions will ensure that it creates and maintains an ideal environment: <br><br><pre> <code class="cpp hljs">FEROMON[<span class="hljs-number"><span class="hljs-number">-1.0</span></span>,<span class="hljs-number"><span class="hljs-number">-0.4</span></span>] CREATE_FEROMON APPEND <span class="hljs-number"><span class="hljs-number">0.1</span></span> FEROMON[<span class="hljs-number"><span class="hljs-number">0.6</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>] CREATE_FEROMON DEDUCT <span class="hljs-number"><span class="hljs-number">0.1</span></span> POISON[<span class="hljs-number"><span class="hljs-number">-1.0</span></span>,<span class="hljs-number"><span class="hljs-number">-0.5</span></span>] CREATE_ POISON APPEND <span class="hljs-number"><span class="hljs-number">0.1</span></span> POISON [<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>] CREATE_ POISON DEDUCT <span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre><br><br>  And such conditions will allow you to efficiently get food: <br><br><pre> <code class="cpp hljs">FOOD [<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>] MOVE APPEND <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,     FOOD [2.0, 10.0] MOVE CLEAR 0.0 // ,    </span></span></code> </pre><br><br>  Wrote a separate class of DNA that stores all the genetic information.  When bacteria multiply, each gene can with a certain probability be deleted or duplicated.  There is a possibility of adding new, happy genes conditions.  In addition to a set of conditions, the maximum speed of the bacteria and the value of the ideal medium are stored in the DNA.  I tried multiplication of bacteria to do another action, for the activation of which also need to use the conditions, but the result was dull.  But one feature of the use of such "conditional" genes seemed curious to me.  For example, some kind of bacteria is beneficial to constantly rotate at a low speed.  But when moving, all receptors will change their values, as bacteria indicate that it needs to always rotate?  Evolution sometimes selected those individuals whose conditions were obviously true, for example, POSION_RESIST [0.3, 0.6] with a resistance to poison 0.4.  On the one hand, this approach allows bacteria to perform a certain action regardless of the environment and receptor parameters, on the other hand, it limits the mutational variability of the ideal environment (since those bacteria whose resistance goes beyond certain limits lose all their unconditional actions). <br><br>  By the way, the challenge of one condition also spends food stocks, therefore creating a large amount of junk genes conditions is evolutionarily unprofitable.  You can notice the dependence (by looking at the DNA of individual bacteria) - the more food, the more junk genes are stored in DNA. <br><br>  On the visual side, the downside was the ability of bacteria to generate different colors (the ratio of pheromone and poison), depending on the conditions, and the beautiful division into colored populations has sunk into oblivion. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f9/715/451/7f9715451c20fe6f01bfcfe0de24c33c.gif" alt="image"><br>  Figure 7. The absorption of food by the population with conditional behavior. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/jOrTtJ31u4g%3Ffeature%3Doembed&amp;xid=17259,1500004,15700023,15700186,15700191,15700253&amp;usg=ALkJrhjIJt6-tnxV40hJ9ZYwRQPEQSz6EA" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Useful features </h5><br>  It was impossible not to add interactivity to the program.  For example, the ability to draw with poison, food or pheromone.  I will describe all the management features: <br><br><ol><li>  Camera control: <br><ol><li>  <b>Scroll</b> - camera zoom in / out </li><li>  <b>Drag with</b> scroll <b>pressed</b> - camera movement </li></ol></li><li>  Drawing: <ol><li>  <b>Left mouse button</b> - draw with the current brush </li><li>  <b>Up</b> - change brush size </li><li>  <b>Down</b> - change the "ink" </li><li>  Clear all liquids from the screen - <b>q</b> </li></ol></li><li>  Visualization: <br><ol><li>  Display / show bacteria - <b>space</b> </li><li>  Save each frame in * .png - <b>F8</b> </li><li>  Dying bacteria turn red, and starving people take on a cyan hue </li></ol></li><li>  Speed: <br><ol><li>  Switch operation mode (slow / fast / pause) - <b>right mouse button</b> </li></ol></li><li>  Information: <br><ol><li>  Get information about the DNA of the bacteria closest to the mouse (it is better to use when stopping time, 1/0 before the gene - whether the condition was fulfilled in the last frame) - <b>i</b> </li></ol></li><li>  Program settings: <br><ol><li>  Window settings - <b>data / settings.json</b> </li><li>  Folder Save Settings - <b>data / screensaver.json</b> </li><li>  Field settings, bacteria, etc.  - <b>ai.json</b> (if the file is damaged or deleted, it will automatically recover) </li></ol></li></ol><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/WubDKqd8sj0%3Ffeature%3Doembed&amp;xid=17259,1500004,15700023,15700186,15700191,15700253&amp;usg=ALkJrhh6ebuopfXcL1LkMNxBdWiuuUV32Q" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Debriefing, plans </h5><br>  The program was originally created as a micro-prototype, play for 15 minutes.  But tightened.  Therefore, the code has all the shortcomings of the prototype, which, however, I plan to eliminate.  The result was not as beautiful as the intermediate versions (without DNA and with multi-colored populations), it is worth thinking about other imaging options, for example, to stain bacteria depending on their origin.  Another important problem is the lack of balancing the amount of food: it is difficult to choose the settings so that the program can work all night and the populations do not become extinct. <br><br>  Here is what I want to change soon: <br><br><ol><li>  Restoration of the floating-point field cell values ‚Äã‚Äã(but still on the video card) in order to remove the permanent conversion (loss) from float to uchar </li><li>  Optimization.  Many bottlenecks, such as the cloning of bacteria. </li><li>  Parallelization.  The program works in one thread, while the program should be perfectly parallelized. </li><li>  Autobalance substances.  Add food to the field if necessary </li><li>  The Garden of Eden.  Selection of the most successful bacteria for their subsequent cultivation. </li></ol><br><br><h5>  Links to the program, source code, instructions </h5><br>  <a href="https://sourceforge.net/projects/ai-evolution/files/">Last compiled version of the program</a> <br>  <a href="https://sourceforge.net/p/ai-evolution/">The sources of the program</a> (in the run folder is the compiled version), you will need <a href="http://www.sfml-dev.org/">SFML 2.1</a> and <a href="http://sourceforge.net/projects/jsoncpp/">jsoncpp</a> .  It should be noted that until the last moment I used b2vec2 from box2d as a vector (legacy of the past project) and only in recent commits I replaced it with a samopisny vector.  Therefore, if you want to build the old version, transfer the new Math :: Vector from core / math / vector.h there <br><br>  You play with the settings in ai.json, run ai.exe and follow the evolution (or actively intervene). <br><br>  Enjoyable evolution! </div><p>Source: <a href="https://habr.com/ru/post/226337/">https://habr.com/ru/post/226337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226327/index.html">What should "PHP Junior Developer without experience" know?</a></li>
<li><a href="../226329/index.html">Apple Metal API: what's the trick?</a></li>
<li><a href="../226331/index.html">Setting up a remote interpreter on Pycharm for Django</a></li>
<li><a href="../226333/index.html">Reduced component connectivity of C ++ code</a></li>
<li><a href="../226335/index.html">How did SQL Server switch every two to three hours to using a non-optimal query execution plan?</a></li>
<li><a href="../226339/index.html">How to assemble an electric bike in seven days</a></li>
<li><a href="../226341/index.html">We sit, do not touch anyone, we repair old headphones</a></li>
<li><a href="../226343/index.html">Gamification or gamification</a></li>
<li><a href="../226345/index.html">Recover Apple Key Aluminum after Fluid</a></li>
<li><a href="../226347/index.html">About seals, dogs, machine learning and deep learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>