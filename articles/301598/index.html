<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TV countdown timer on AVR microcontroller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, a friend of mine asked me what I would do with a countdown timer so that I could show big numbers on the TV. It is clear that you can connect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TV countdown timer on AVR microcontroller</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f02/a4e/2db/f02a4e2db9eb4e8c9ae89eb778097167.jpg" alt="First result"><br><br>  One day, a friend of mine asked me what I would do with a countdown timer so that I could show big numbers on the TV.  It is clear that you can connect a laptop / iPad / Android and write an application, only a laptop is cumbersome, and writing a mobile application neither a friend nor I have ever done. <br><br>  And then I remembered that I saw on the network projects of TV terminals on the AVR microcontroller.  Immediately, an idea appeared in my head to combine small characters into large ones and we decided to try.  It somehow happened that I had to do the main work. <br><a name="habracut"></a><br>  Of course, I have little experience in developing devices on the MK, but it is always easier to get ready, so I started with an active search for a ready solution for outputting to a TV.  The main criterion for the search was, first of all, simplicity, if possible, the use of C language without assembly inserts, high image quality. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many projects were found, but it turned out that most of them do not meet the criteria.  Subsequently, it became clear that the main thing is to understand the principle of the formation of a video signal, and then it will go further.  But at this stage, the unconditional favorite was the <a href="http://www.vga-avr.narod.ru/">project ‚ÄúSimple VGA / Video Adapter‚Äù by Maxim Ibragimov</a> , he formed the basis of my crafts.  However, in the process of work, only the structure remained of it, the implementation had to be redone almost completely. <br><br>  An additional task, which I practically invented myself, was the task of starting time from the IR remote control. <br><br>  As the main controller, I decided to use ATMega168, running at 20 MHz.  The hardware part of the video signal conditioner looks like this: <br><br><img src="https://habrastorage.org/files/844/d12/cef/844d12cef6e84145ad740d3f89c3c452.jpg" alt="video driver circuit"><br><br>  I started by throwing out everything that concerns VGA from the project, since I did not plan to do it.  Along the way, I studied the video coding standards, the most accessible picture seemed to me from <a href="http://martin.hinner.info/vga/pal.html">the Martin Hinner site</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/413/ad4/3f0/413ad43f095d65cef1f7ca2af726dc2f.jpg" alt="image">  . <br><br>  For this picture did the synchronization signal generator. <br><br>  At the heart of the generator - Timer1 in fastPWM mode.  Additionally, a global variable has a clock counter.  For each timer overflow interrupt, the sync pulse number is checked for a key value, a change in the duration of the next sync pulse and a period of the next sync pulse (full line / half line).  If no changes are required, standard actions are made ‚Äî the clock counter increases, other variables change. <br><br><div class="spoiler">  <b class="spoiler_title">#define</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2. System definitions #define Timer_WholeLine F_CPU/15625 //One PAL line 64us #define Timer_HalfLine Timer_WholeLine/2 //Half PAL line = 32us #define Timer_ShortSync Timer_WholeLine/32 //2us #define Timer_LongSync Timer_ShortSync*15 //30us #define Timer_NormalSync Timer_WholeLine/16 //4us #define Timer_blank Timer_WholeLine/8 //8us //Global definitions for render PAL #define PAL_FPS 50 #define pal_first_visible_line1 40 #define pal_last_visible_line1 290 //pal_first_visible_line1+pal_row_count*pal_symbol_height #define horiz_shift_delay 15</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Timer initialization (function fragment)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Initialize Sync for PAL synccount = 1; VIDEO_DDR |= (1&lt;&lt;SYNC_PIN); OCR1B = Timer_LongSync; TCCR1A = (1&lt;&lt;COM1B1)|(1&lt;&lt;COM1B0)|(0&lt;&lt;WGM10)|(1&lt;&lt;WGM11); //Fast PWM,Set OC1B on Compare Match, // clear OC1B at BOTTOM (inverting mode) TCCR1B = (1&lt;&lt;WGM12)|(1&lt;&lt;WGM13)|(1&lt;&lt;CS10); //full speed;TOP = ICR1 ICR1 = Timer_HalfLine; //     . TIMSK1 = (1&lt;&lt;OCIE1B); //enable interrupt from row_render=0; y_line_render=0;</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Clock signal generator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  volatile unsigned int synccount; //    EMPTY_INTERRUPT (TIMER1_COMPB_vect); void MakeSync(void) { switch (synccount) { case 5://++++++++++++++++++++++++++++++++++++++++++++++++++++++++= Sync=Timer_ShortSync; synccount++; break; case 10://++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ICR1 = Timer_WholeLine; Sync= Timer_NormalSync; synccount++; break; case 315://++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ICR1 = Timer_HalfLine; Sync= Timer_ShortSync; synccount++; break; case 321://++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Sync=Timer_LongSync; synccount=1; framecount++; linecount = 0; break; default://++++++++++++++++++++++++++++++++++++++++++++++++++++++++ synccount++; video_enable_flg = ((synccount&gt;pal_first_visible_line1)&amp;&amp;(synccount&lt;pal_last_visible_line1)); break; } }</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/files/c91/d4d/dcd/c91d4ddcd5d345fdb37b2ad9655bf882.jpg" alt="PAL standard frame sync signal"><br><br>  At the end of each line, the controller goes into sleep, interrupts the timer overflow, wakes up immediately after the MakeSync () function sets the timer settings for the next synchronization period, after which, if the number of the synchrometer enters the visible area, video output begins. <br><br>  Video output is organized via SPI, operating at a maximum frequency equal to half the clock frequency. <br><br><div class="spoiler">  <b class="spoiler_title">#define</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MOSI PORTB3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MISO PORTB4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCK PORTB5 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define VIDEO_PORT SPI_PORT #define VIDEO_DDR SPI_DDR #define VIDEO_PIN MOSI #define VIDEO_OFF DDRB=0b00100100; #define VIDEO_ON DDRB=0b00101100;</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SPI Initialization (snippet)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Set SPI PORT DDR bits VIDEO_DDR |= (1&lt;&lt;MOSI)|(1&lt;&lt;SCK)|(0&lt;&lt;MISO); SPSR = 1 &lt;&lt; SPI2X; SPCR = (1 &lt;&lt; SPE) | (1 &lt;&lt; MSTR); //SPI enable as master ,FREQ = fclk/2</span></span></code> </pre><br></div></div><br>  The output process itself is carried out in each line by the function DrawString, which is passed as a pointer to an array of digits for output, a pointer to the font used and the number of characters to be output as parameters.  Also, the output uses global variable numbers of the displayed line in each font and character numbers.  Within each character, in a loop with the number of iterations equal to the width of this character in bytes, these bytes of the font are transferred to the SPDR register. <br><br>  In addition, the hardware implementation of SPI in the AVR controller cannot transmit several data bytes in a row.  After each byte, one bit is skipped, which causes gaps in the image. <br><br><img src="https://habrastorage.org/files/408/ca6/3bc/408ca63bc4cc4189a352aede1f2f5823.jpg" alt="breaks through SPI"><br><div class="spoiler">  <b class="spoiler_title">Small explanation</b> <div class="spoiler_text">  Even a little bit wrong.  The MOSI output remains at a high level after the transfer of a byte, and on this photo the video output is switched on via the 74S04 inverter, and the font bytes are inverted before being output, therefore the gaps are black.  Without an inverter, white vertical stripes are obtained. <br></div></div><br><br>  To defeat this drawback, we had to use the trick proposed in the <a href="http://www.batsocks.co.uk/products/Other/TellyMate.htm">TellyMate</a> project, which consists in switching the video output pin to a high-impedance state when necessary, and thus repeating the last bit in the output byte.  This part of the function is very time critical and the failure of the assembler has led to the need to <s>use a tambourine to</s> find a tricky solution. <br><br><div class="spoiler">  <b class="spoiler_title">Line output function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str_buffer[], struct FONT_INFO *font, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str_symbols)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> symbol_width; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _ptr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _ptr1; y_line_render++; <span class="hljs-comment"><span class="hljs-comment">//Set pointer for render line (display buffer) _ptr = &amp;str_buffer[row_render * str_symbols]; unsigned char j; register unsigned char _S; unsigned char _S1; //Cycle for render line i = str_symbols; while(i--) { symbol_width = font-&gt;width[(* _ptr)]; //Set pointer for render line (character generator) _ptr1 = &amp;font-&gt;bitmap[font-&gt;offset[* _ptr]+y_line_render*symbol_width]; _S1 = 0; //  _S = pgm_read_byte(_ptr1); //  _ptr1++; j=symbol_width; //   while (1) { if (_S1 &amp; 0b1) { goto matr; } VIDEO_OFF; matr: NOP; SPDR = _S; VIDEO_ON; _S1 = _S; _S = pgm_read_byte(_ptr1++); NOP; NOP; if (!--j) break; } _ptr++; VIDEO_OFF; } }</span></span></code> </pre><br></div></div><br>  After the image was received, it became clear that there was no talk of receiving and parsing the IR parcels from the console, just not enough speed, so I left the reception of commands via the UART.  IR reception will be done by another microcontroller. <br><br>  Also added a second buffer that is needed to display the clock.  Accordingly, there will be two fonts too.  The structure of the font file consists of the actual character bitmaps, the font height constant, and the arrays of the offsets of each character and the width of each character. <br><br>  There is also a structure describing the font for easier access from the program. <br><br><div class="spoiler">  <b class="spoiler_title">Font</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Character bitmaps for Digital-7 Mono 120pt const unsigned char PROGMEM Digital7_Bitmaps[] = { // @0 '0' (71 pixels wide) 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x80, // ############################################# # 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xE0, // ############################################### ### 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF0, // ############################################### ##### 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF8, // ################################################ ###### ... ... } const unsigned char Digital7_Height = 105; const unsigned char Digital7_Width[] = { 9, /* 0 */ 9, /* 1 */ 9, /* 2 */ 9, /* 3 */ 9, /* 4 */ 9, /* 5 */ 9, /* 6 */ 9, /* 7 */ 9, /* 8 */ 9, /* 9 */ 3 /* : */ }; const unsigned int Digital7_Offset[] = { 0 , /* 0 */ 945, /* 1 */ 1890, /* 2 */ 2835, /* 3 */ 3780, /* 4 */ 4725, /* 5 */ 5670, /* 6 */ 6615, /* 7 */ 7560, /* 8 */ 8505, /* 9 */ 9450 /* : */ };</span></span></code> </pre><br></div></div><br>  Fonts generated by the <a href="https://github.com/pavius/the-dot-factory">DotFactory</a> program. <br><br>  During the invisible part of the frame, the clock and timer move is made, as well as the reaction to the commands received via the UART. <br><br><div class="spoiler">  <b class="spoiler_title">UART reception</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> clock_left; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> clock_set; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> MinTens, MinOnes; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> SecTens, SecOnes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pal_terminal_handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> received_symbol = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Parser received symbols from UART while(UCSR0A &amp; (1&lt;&lt;RXC0)) { received_symbol = UDR0; if (received_symbol=='#') { clock_left=5; clock_set = true; } if ((received_symbol&gt;0x2F)&amp;&amp;(received_symbol&lt;0x3A)) { if (clock_set) { time_array[5-clock_left] = received_symbol - 0x30; clock_left--; if (clock_left==3) { clock_left--; } if (clock_left==0) { time_array[6] = 0; time_array[7] = 0; clock_set = false; } } else { if ((pause==0)||_Stop) { MinTens = 0; } else { MinTens = MinOnes; } MinOnes = received_symbol - 0x30; SecTens = 0; SecOnes = 0; pause = 4; _Stop = false; str_array[0] = MinTens; str_array[1] = MinOnes; str_array[2] = 0x0A; str_array[3] = SecTens; str_array[4] = SecOnes; } //time_array[] = {1, 2, 10, 5, 5}; } } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Main () function;</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _Stop; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FONT_INFO</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * bitmap; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * width; } Digital7, comdot; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ avr_init(); <span class="hljs-comment"><span class="hljs-comment">//fonts Digital7.bitmap = &amp;Digital7_Bitmaps; Digital7.height = Digital7_Height; Digital7.offset = &amp;Digital7_Offset; Digital7.width = &amp;Digital7_Width; comdot.bitmap = &amp;comdotshadow_Bitmaps; comdot.height = comdotshadow_Height; comdot.offset = &amp;comdotshadow_Offset; comdot.width = &amp;comdotshadow_Width; MinTens = 0; MinOnes = 0; SecTens = 0; SecOnes = 0; str_array[0] = MinTens; str_array[1] = MinOnes; str_array[2] = 0x0A; str_array[3] = SecTens; str_array[4] = SecOnes; unsigned char *semicolon = &amp;time_array[2]; sei(); while (1) { sleep_mode(); MakeSync(); if (UCSR0A &amp; (1&lt;&lt;RXC0)) { //Parse received symbol pal_terminal_handle(); //Can easealy add here RX polling buffer //to avoid display flickering continue; } //Check visible field if(video_enable_flg) { linecount++; //OK, visible //Main render routine #define firstline 36 #define secondline 200 //To make horizontal shift rendered image unsigned char k; for (k=horiz_shift_delay; k&gt;0; k--) { NOP; } if ((linecount == firstline)||(linecount == secondline)) { row_render = 0; y_line_render = 0; } if ((linecount&gt; firstline) &amp;&amp; (linecount&lt; firstline+(Digital7.height))) { DrawString(&amp;str_array, &amp;Digital7, 5); } if ((linecount&gt; secondline) &amp;&amp; (linecount&lt; secondline+(comdot.height))) { DrawString(&amp;time_array, &amp;comdot, 5); } } else { //Not visible //Can do something else.. //You can add here your own handlers.. // VIDEO_OFF; if (framecount==PAL_FPS) { framecount=0; //========================================= if (*semicolon== 11) { *semicolon=10; } else { *semicolon=11; } if (++time_array[7] == 10) { framecount = 1;//   time_array[7]=0; if (++time_array[6]==6) { framecount = 3; //   time_array[6]=0; if (++time_array[4]==10) { time_array[4]=0; if (++time_array[3]==6) { time_array[3]=0; if ((++time_array[1]==4) &amp;&amp; (time_array[0]==2)) { time_array[0]=0; time_array[1]=0; } if (time_array[1]== 9) { time_array[1]=0; time_array[0]++; } } } } } //========================================= if ((pause==0)&amp;&amp;(_Stop==false)) { if ((SecOnes--)==0) { SecOnes=9; if ((SecTens--) == 0) { SecTens = 5; if ((MinOnes--) == 0) { MinOnes = 9; if (MinTens == 0) { _Stop = true; } else { MinTens--; } } } } if (!_Stop) { str_array[0] = MinTens; str_array[1] = MinOnes; str_array[2] = 0x0A; str_array[3] = SecTens; str_array[4] = SecOnes; } } else { pause--; } } } } }</span></span></code> </pre><br></div></div><br>  As a controller that decodes the IR remote and sends commands via the UART, I took ATTiny45.  Since it does not have a hardware UART, on the Internet, a very compact <a href="http://www.avrfreaks.net/forum/code-c-avr-gcc-software-transmit-only-uart">function of a software UART</a> that works only on sending was found, as well as a simple <a href="http://we.easyelectronics.ru/Soft/prostoy-universalnyy-dekoder-ik-du.html">function of reading commands from the console</a> (without decoding). <br><br>  All this was quickly compiled and compiled.  Codes of buttons of the console are rigidly stitched in the code.  Additionally made a flashing LED when receiving a command. <br><br><div class="spoiler">  <b class="spoiler_title">IR receiver and UART</b> <div class="spoiler_text">  / * <br>  * Tiny85_UART.c <br>  * <br>  * Created: 04/19/2016 21:22:52 <br>  * Author: Antonio <br>  * / <br><br>  #include &lt;avr / io.h&gt; <br>  #include "dbg_putchar.h" <br>  #include &lt;avr / interrupt.h&gt; <br>  // # include &lt;stdlib.h&gt; <br>  #include &lt;stdbool.h&gt; <br><br>  // threshold value for comparing the length of pulses and pauses <br>  static const char IrPulseThershold = 9; // 1024/8000 * 9 = 1.152 msec <br>  // determines the timeout for receiving the parcel <br>  // and limits the maximum length of the pulse and pause <br>  static const uint8_t TimerReloadValue = 100; <br>  static const uint8_t TimerClock = (1 &lt;&lt; CS02) |  (1 &lt;&lt; CS00); // 8 MHz / 1024 <br><br>  volatile unsigned char blink = 0; <br><br>  #define blink_delay 3; <br><br>  volatile struct ir_t <br>  { <br>  // flag start receiving polylka <br>  uint8_t rx_started; <br>  // received code <br>  uint32_t code, <br>  // receive buffer <br>  rx_buffer; <br>  } ir; <br><br>  static void ir_start_timer () <br>  { <br><br>  TCNT0 = 0; <br>  TCCR0B = TimerClock; <br>  } <br><br>  // when the timer overflows, we believe that the parcel is accepted <br>  // copy the received code from the buffer <br>  // reset the flags and stop the timer <br>  ISR (TIMER0_OVF_vect) <br>  { <br>  ir.code = ir.rx_buffer; <br>  ir.rx_buffer = 0; <br>  ir.rx_started = 0; <br>  if (ir.code == 0) <br>  TCCR0B = 0; <br>  TCNT0 = TimerReloadValue; <br>  } <br><br>  ISR (TIMER1_OVF_vect) <br>  { <br>  if (blink == 0) <br>  { <br>  OCR1B = 0; <br>  } <br>  else <br>  { <br>  OCR1B = 200; <br>  blink--; <br>  } <br>  } <br><br>  // external interrupt on the front and the decline <br>  ISR (INT0_vect) <br>  { <br>  uint8_t delta; <br>  if (ir.rx_started) <br>  { <br>  // if the pulse / pause duration is more than the threshold <br>  // move the buffer unit one otherwise zero. <br>  delta = TCNT0 - TimerReloadValue; <br>  ir.rx_buffer &lt;&lt; = 1; <br>  if (delta&gt; IrPulseThershold) ir.rx_buffer | = 1; <br>  } <br>  else { <br>  ir.rx_started = 1; <br>  ir_start_timer (); <br>  } <br>  TCNT0 = TimerReloadValue; <br>  } <br><br>  void dbg_puts (char * s) <br>  { <br>  while (* s) dbg_putchar (* s ++); <br>  } <br><br>  int main (void) <br>  { <br><br>  GIMSK | = _BV (INT0); <br>  MCUCR | = (1 &lt;&lt; ISC00) |  (0 &lt;&lt; ISC01); <br>  TIMSK = (1 &lt;&lt; TOIE0) | (1 &lt;&lt; TOIE1); <br>  ir_start_timer (); <br><br>  dbg_tx_init (); <br><br>  DDRB | = _BV (PB4); <br><br>  TCCR1 | = (1 &lt;&lt; CS13) | (1 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (0 &lt;&lt; CS10); <br>  GTCCR | = (1 &lt;&lt; COM1B1) | (0 &lt;&lt; COM1B0) | (1 &lt;&lt; PWM1B); <br>  OCR1C = 255; <br>  OCR1B = 0; <br>  blink = 0; <br>  sei (); <br><br>  // dbg_puts (&amp; HelloWorld); <br>  while (1) <br>  { <br>  // if ir.code is not zero, then we have adopted a new command <br>  if (ir.code) <br>  { <br>  // convert the code to a string <br>  //ultoa(ir.code, buf, 16); <br>  // dbg_puts (buf);  // and output to port <br>  // =============================================== ================== <br>  switch (ir.code) <br>  { <br>  case 0x2880822a: blink = blink_delay;  dbg_putchar ('1');  break; <br>  case 0x8280282a: blink = blink_delay;  dbg_putchar ('2');  break; <br>  case 0x8a0020aa: blink = blink_delay;  dbg_putchar ('3');  break; <br>  case 0x0a00a0aa: blink = blink_delay;  dbg_putchar ('4');  break; <br>  case 0x0280a82a: blink = blink_delay;  dbg_putchar ('5');  break; <br>  case 0x2a888022: blink = blink_delay;  dbg_putchar ('6');  break; <br>  case 0x0200a8aa: blink = blink_delay;  dbg_putchar ('7');  break; <br>  case 0x0a80a02a: blink = blink_delay;  dbg_putchar ('8');  break; <br>  case 0x22888822: blink = blink_delay;  dbg_putchar ('9');  break; <br>  case 0x20888a22: blink = blink_delay;  dbg_putchar ('0');  break; <br>  case 0x0008aaa2: blink = blink_delay;  dbg_putchar ('O');  break; <br>  case 0x280882a2: blink = blink_delay;  dbg_putchar ('U');  break; <br>  case 0x8880222a: blink = blink_delay;  dbg_putchar ('D');  break; <br>  case 0x0808a2a2: blink = blink_delay;  dbg_putchar ('L');  break; <br>  case 0xa0080aa2: blink = blink_delay;  dbg_putchar ('R');  break; <br>  case 0x20088aa2: blink = blink_delay;  dbg_putchar ('*');  break; <br>  case 0x220888a2: blink = blink_delay;  dbg_putchar ('#');  break; <br>  default: break; <br>  } <br>  ir.code = 0; <br>  // =============================================== =================== <br><br>  } <br>  } <br>  } <br></div></div><br>  The final scheme was as follows: <br><br><img src="https://habrastorage.org/files/ba5/ef8/30a/ba5ef830a863499682c83ad89133c744.gif" alt="Timer circuit"><br><br>  The first version was assembled on a breadboard with the use of pieces of plexiglass as a case. <br><br><img src="https://habrastorage.org/files/093/ac4/276/093ac427691940bb9999d2b046a04f8b.jpg" alt="assembly"><br><br>  The power supply unit bought the simplest 12V 500mA at a local store. <br><br>  Pultik <a href="http://www.ebay.com/itm/400985211071%3F_trksid%3Dp2057872.m2749.l2649%26ssPageName%3DSTRK%253AMEBIDX%253AIT">ordered on ebay.</a> <br><br><img src="https://habrastorage.org/files/dcf/e85/a57/dcfe85a57e6349568d55f2fd280ef78a.jpg" alt="assembly"><br><br>  Here is the result: <br><br><img src="https://habrastorage.org/files/883/7c8/006/8837c8006bb949e3a1f8d0e264924307.jpg" alt="resulting image"><br><br>  The timer is used to inform the speaker from the department of the allotted time. <br><br><img src="https://habrastorage.org/files/be6/e78/a76/be6e78a76cf74f19a589395fef3d1927.jpg" alt="use timer"><br><br>  The plans - to remake on stm32, fit into one controller, draw in the case more beautiful. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/301598/">https://habr.com/ru/post/301598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301584/index.html">Geo-distributed s3 cluster in active-active mode</a></li>
<li><a href="../301588/index.html">Javascript-only: homogeneous web project architecture</a></li>
<li><a href="../301590/index.html">Choosing a processor for the server: how to choose and not make a mistake?</a></li>
<li><a href="../301592/index.html">How bitcoin will bury states</a></li>
<li><a href="../301594/index.html">Lint CSS using stylelint</a></li>
<li><a href="../301600/index.html">Swift present and future: questions for adults</a></li>
<li><a href="../301602/index.html">Expensive futility of ‚Äúloyalty programs‚Äù</a></li>
<li><a href="../301604/index.html">5 mistakes to be avoided when creating micro-interactions</a></li>
<li><a href="../301606/index.html">Microsoft opened the source Xamarin.Forms. We could not miss the chance to check them with PVS-Studio</a></li>
<li><a href="../301610/index.html">VectorDrawable - Part Two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>