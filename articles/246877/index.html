<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile client-server application architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To add an external server sooner or later comes any complex project. The reasons, however, are quite different. Some download additional information f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile client-server application architecture</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/047/df5/f37/047df5f37b5d48dd9a09c67dd2ff257b.png"><br>  To add an external server sooner or later comes any complex project.  The reasons, however, are quite different.  Some download additional information from the network, others synchronize data between client devices, and others transfer the logic of the application execution to the server side.  As a rule, most of the "business" applications belong to the latter.  As we move away from the sandbox paradigm, in which all actions are performed only within the framework of the original system, the logic of the processes is intertwined, intertwined, tied with nodes so that it becomes difficult to understand what is the starting point for entering the application process.  At this moment, not the functional properties of the application itself come to the first place, but its architecture, and, as a result, the opportunities for scaling. <br>  The foundation laid allows either to create a majestic architectural ensemble, or ‚Äúnakrednozh‚Äù - a hut on chicken legs, which crumbles from one push of the ‚Äúgood fellow‚Äù of which, apparently, invisibly during its existence, because, looking at multiple building defects, the customer is inclined to change not the original project, but the construction team. <br>  Planning is the key to the success of the project, but it is the customer who is given the minimum amount of time.  Building patterns are the ace in the sleeve of a developer who covers unfavorable combinations where time is the decisive factor.  Taken as a basis, working solutions allow you to make a quick start to go to the tasks that seem to be most relevant to the customer (such as painting a chimney on a roof that has not yet been built). <br>  In this article I will try to set forth the principle of building a scalable system for mobile devices, covering 90-95% of client-server applications, and ensuring the maximum distance from the sacramental "nooknuru". <br><a name="habracut"></a><br><br>  While doing the revision of this article, a similar article was published on Habr√© ( <a href="http://habrahabr.ru/company/redmadrobot/blog/246551/">http://habrahabr.ru/company/redmadrobot/blog/246551/</a> ).  I do not agree with all the accents of the author, but in general, my vision does not contradict and does not overlap with the material presented there.  The reader will be able to determine which of the approaches is more flexible and more relevant. <br><br><img src="https://habrastorage.org/files/6a1/110/1a3/6a11101a317540949c479bc345bf7a2b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The general structure of client-server interaction from the server is presented here: <a href="http://www.4stud.info/networking/lecture5.html">www.4stud.info/networking/lecture5.html</a> However, we are more interested in the same view from the client, and in this regard, there is no difference between dvzvennoy and sober architecture: <br>  It is important to understand two things: <br><ol><li>  There may be many customers using one account to communicate with the north. </li><li>  Each client usually has its own local storage.  * </li></ol><br><br>  * In some cases, local storage can be synchronized with the cloud, and, accordingly, with each of the clients.  Since this is a special case and, for the most part, does not affect the architecture of the application, we omit it. <br><br>  It should be noted that since, some developers seek to get rid of the "server side", some applications are built around the synchronization of their storages in the "cloud".  That is, in fact, they have the same two-link system, but with the transfer of its deployment architecture to the level of the operating system.  In some cases, such a structure is justified, but such a system is not so easily scaled, and its capabilities are very limited. <br><br><img src="https://habrastorage.org/files/58e/b67/84e/58eb6784e881468bb091add688b53a31.png"><br><br>  <b>General structure of the application</b> <br><br>  At the most primitive level of abstraction, a server-oriented application consists of the following architectural layers: <br><ol><li>  The core of the application, which includes system components that are not available for user interaction. </li><li>  Graphical user interface </li><li>  Reusable components: libraries, visual components and more. </li><li>  Environment files: AppDelegate, .plist, etc. </li><li>  Application resources: graphic files, sounds, necessary binary files. </li></ol><br>  The most important condition for building a stress-resistant architecture is to separate the system core from the GUI, so that one could successfully function without the other.  Meanwhile, the majority of RAD systems come from the opposite direction - the molds form the skeleton of the system, and its muscles build up functions.  As a rule, this means that the application does not become limited by its interface.  And, the interface acquires an unambiguous interpretation both from the point of view of the user and from the point of view of the class hierarchy. <br><br><img src="https://habrastorage.org/files/150/d62/5a7/150d625a7f9b491fa3a34d2873ae46f5.png"><br><br>  <b>Core</b> <br><br>  The core of the application consists of the following layers: <br><ol><li>  (Start layer) The start layer, which defines the workflow, starts program execution. </li><li>  (Network layer) A network layer that provides a mechanism for transport interaction. </li><li>  (API layer) An API layer that provides a unified system of commands for interaction between the client and the server. </li><li>  (Network Cache Layer) A network caching layer that accelerates client and server network interactions. </li><li>  (Validation Items Layer) Validation layer of data received from the network </li><li>  (Network Items Layer) Network Entry Layer </li><li>  (Data Model) A data model that provides interaction between data entities. </li><li>  (Local cache layer) A local cache layer that provides local access to already acquired network resources. </li><li>  (Workflow layer) A workflow layer that includes classes and algorithms specific to this application. </li><li>  (Local storage) Local storage </li></ol><br>  One of the main tasks facing the developers of the system is to ensure the mutually independent functioning of these layers.  Each layer should only ensure the performance of its functions.  As a rule, a layer located at a higher level of the hierarchy should not be aware of the specifics of the implementation of other layers. <br><br>  Consider the process of solving the problem with the currents of Junior and Senior developers. <br>  Objective: to write a program "currency calculator" that would receive data from the network, and build a graph of rate changes. <br>  <b>Junior:</b> <br>  1) Based on the formulation of the problem, we know that the application will consist of the following parts: <br><ol><li>  Form for mathematical operations (addition, subtraction) </li><li>  Form for displaying graphics </li><li>  Additional forms: splash screen, about. </li></ol><br>  2) We do the following form dependency: the form of calculations is the main one in our application.  It starts up a splash form that hides after a certain period of time, the form of graphs and about by clicking on a certain button. <br>  3) The display time of splashscreen is equivalent to the time for downloading data from the network. <br>  4) Since the download from the network is performed only during the display of the splash form, the data loading code is placed inside the form, and upon completion of the form, is removed from memory along with the form. <br><br>  How efficient is this application?  I think that no one has any doubt that using Delphi or Visual Studio can at the moment solve this problem.  Using Xcode to make it a little more difficult, but you can also not straining too much.  However, after the advent of the prototype, scalability issues begin to appear.  It becomes obvious that to display the graph it is necessary to store data for the previous period.  Not a problem, you can add data storage inside the form of graphs.  However, data can come from different providers and in different formats.  In addition, arithmetic operations can be carried out with different currencies, which means that it is necessary to ensure their choice.  To make such a choice on the form of graphs is somewhat illogical, although it is possible, however, it depends on such settings what we will display on the graph.  This means that if we add additional parameters to the settings window, we will have to somehow pass them through the main form to the graphs window.  In this case, it will be logical to make a local variable in which to store the passed parameters, and to provide access from one form to another form through the main form.  Well, and so on.  The chain of reasoning can be built for a very long time, and the complexity of interactions will increase. <br><br>  <b>Senior:</b> <br>  Task setting allows you to select several subtasks that can be described by separate classes: <br>  1) Download data from the network. <br><ol><li>  Verification of the data </li><li>  Saving data in permanent storage. </li><li>  Calculation of data. </li><li>  addition operation </li><li>  subtraction operation </li><li>  Filtering data by specified criteria (application settings) </li><li>  Application start class. </li></ol><br>  2) Provide an interface related operation that consists of the following main forms: <br><ol><li>  Main controller (may be invisible) </li><li>  Calculation form </li><li>  Graph form </li><li>  Splash and About </li><li>  Optionally form settings. </li></ol><br>  3) After the application is launched at runtime, the object responsible for loading the data is created (instantiated) (in the overwhelming majority of cases asynchronous) and starts the process.  The main controller of the application displays a splash screen, and at this time, forms a form that will take its place on hiding the splash form. <br>  4) After the data loading is completed, a validator object and a local storage provider object are created.  If the data has been validated, it can be transferred to the local storage provider. <br>  5) To display the graph, a local storage object and a data settings object are created.  Data settings are transferred to a local storage provider to retrieve data with installed filters. <br>  6) For carrying out calculations, a calculator object is created, and operation objects.  The data received from the form is transferred to the calculator object, and one of the two operation objects that know how to exactly perform the calculations. <br><br>  Of course, this approach requires more programming efforts, and, accordingly, initially requires more time.  However, based on the subtask, it is clear that firstly, it is easy to parallelize the work on it ‚Äî while one developer is busy building the core ‚Äî the other creates and debugs the UI.  The kernel can safely work within the framework of the console, the UI can be clicked on the device and, among other things, independent unit tests can be bolted to both parts.  Another undoubted advantage is that the second approach is much more scalable.  In the case of revising the functionality of the project, any changes will be made many times faster, because there is simply no restrictive framework for visual representations.  The visual forms themselves (GUI) display the necessary minimum based on the tasks existing in the core. <br><br><img src="https://habrastorage.org/files/97d/2be/5e6/97d2be5e650341fe9ce98caaa3098f40.png"><br><br>  <b>Start layer:</b> <br>  In iOS, the application starts functioning by running the delegate class object.  Its purpose is to accept and transfer system calls to the application, as well as to carry out the initial configuration of the application's GUI.  All algorithms and mechanisms that are not related to the start of the application, or receiving messages from the system should be placed in separate classes.  Immediately after completing the initial configuration, control should be transferred to the class that performs the remaining operations of the application setup: authorization, interface reconfiguration depending on conditions, initial data loading, obtaining necessary tokens, and so on.  A typical developer error is a monstrous controlnet code hosted in AppDelegate.  It is understandable, almost all examples of external frameworks for ease of understanding, this is where your code is located.  Unlucky programmers do not spend time on refactoring, and simply copy "as there".  The situation is quite typical for those who use the coreData creation template. <br>  Often there you can see the implementation of the following functions: <br><ol><li>  Setting up and maintaining Facebook sessions </li><li>  Set up a tab manager if the application supports UITabbarController. </li><li>  Clearing CoreData and saving data when entering the Background. </li><li>  Check and initialize updates </li><li>  Notification of external statistics servers </li><li>  Synchronization Data Models </li></ol>  A much more elegant solution would be to create a singleton class Start, and transfer there the data coming to AppDelegate, and even to Start to dilute the data by workflow: for CoreData - one flow-class, for social networks - another. <br><br>  <b>Network Layer:</b> <br>  Provides basic transport-level algorithms for transferring messages from the client to the server, and getting the necessary information from it.  As a rule, messages can be transmitted in JSON and Multipart formats, although in some exotic cases it may be XML or a binary stream in general.  In addition, each message may have a header with service information.  For example, there can be described the duration of the storage of the request / response in the application cache. <br>  Network Layer has no idea about the servers used by the application, or its command system.  Error handling network connection is carried out by virtual methods at the following levels of the application.  The task of this layer is to make a call to the processing method and transfer the information received from the network to it. <br>  In addition, before directly requesting information from the network, the network layer polls the local cache, and if there is an answer there, it immediately returns it to the user. <br>  The content of this layer largely depends on which transport technology is closest to you.  In the developer‚Äôs arsenal, the following options are most in demand: <br><ul><li>  Socket is the lowest-level approach, which includes synchronous and asynchronous requests, and has the ability to work with both TCP and UDP connections.  It allows you to do almost anything, but it requires a high degree of concentration on the task, not a lot of plodding, and a large amount of code. </li><li>  WebSocket is an approach based on using headers on top of TCP.  Details can be read here: <a href="http://habrahabr.ru/post/79038/">habrahabr.ru/post/79038</a> In mobile development, it is used infrequently, since it is not flexible enough and still requires a fairly large amount of code for its support. </li><li>  WCF is probably the most perfect mechanism, but having such a serious minus, which outweighs all the advantages.  The approach invented in the depths of Microsoft relies on the creation of a proxy class that mediates the relationship between application logic and the remote north.  It works "with a bang" in the event that it is possible to generate a proxy class based on WSDL schemes ( <a href="https://en.wikipedia.org/wiki/Web_Services_Description_Language">en.wikipedia.org/wiki/Web_Services_Description_Language</a> ), which is a task, to put it mildly, not trivial.  In addition, this class must be regenerated after each update of the server API.  And if for developers of Visual Studio this is done with the ease of Marshmallow, then for iOS developers it is an extremely heavy task, even those who use MonoTouch in development. </li><li>  REST is a reliable, time-tested compromise of all the above approaches ( <a href="https://ru.wikipedia.org/wiki/REST">ru.wikipedia.org/wiki/REST</a> ).  Of course, some of the capabilities of each approach must be abandoned, but this is done quickly and extremely efficiently with a minimum of effort. </li></ul><br><br>  GitHub contains many libraries that allow you to use REST connections for iOS, AFNetworking is the most popular. <br><br>  REST relies on using GET, POST, PUT, HEAD, PATCH and DELETE requests.  Such a zoo is called RESTFul ( <a href="http://habrahabr.ru/post/144011/">habrahabr.ru/post/144011</a> ) and, as a rule, it is used only when a universal API is written for the operation of mobile applications, websites, desktops and space stations in the same bundle. <br>  The vast majority of applications limit the command system to two types, GET and POST, although only one is enough - POST. <br>  The GET request is transmitted as a string that you use in the browser, and the parameters for the request are transferred separated by '&amp;' characters.  The POST request also uses the ‚Äúbrowser string‚Äù but hides the parameters inside the invisible message body.  The last two statements discourage those who have not previously encountered requests, in fact, the technology has been developed to such an extent that it is completely transparent to the developer, and one does not have to go into such nuances. <br>  Above, it has been described what is sent to the server.  But what comes from the server is much more interesting.  If you use AFNetworking, then from the server side you will receive. As a rule, iOS developers call the JSON serialized dictionary, but this is not quite so.  True JSON has a slightly more complex format, but in its pure form it is almost never used.  However, the fact that there is a difference need to know - there are nuances. <br>  If you are working with a service installed on a Microsoft Windows Server, then most likely WCF will be used there.  However, starting with the Windows Framework 4, there is an opportunity for clients supporting only the REST protocol to make access completely transparent, in a declarative way.  You can even spend no time getting explanations about the API - the documentation about the command system is generated automatically by IIS (Microsoft Web server). <br><br>  Below is the minimum code to implement Network Layer with Objective-C using AFNetworking 2. <br><div class="spoiler">  <b class="spoiler_title">Listing 1</b> <div class="spoiler_text">  ClientBase.h <br><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AFHTTPRequestOperationManager.h"</span></span></span><span class="hljs-meta"> NS_ENUM(NSInteger, REQUEST_METHOD) { GET, HEAD, POST, PUT, PATCH, DELETE }; @interface ClientBase : AFHTTPRequestOperationManager @property (nonatomic, strong) NSString *shortEndpoint; - (void)request:(NSDictionary *)data andEndpoint:(NSString *)endpoint andMethod:(enum REQUEST_METHOD)method success:(void(^)(id response))success fail:(void(^)(id response))fail; @end</span></span></code> </pre> <br><br>  ClientBase.m <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ClientBase.h"</span></span></span><span class="hljs-meta"> @implementation ClientBase - (void)request:(NSDictionary *)data andEndpoint:(NSString *)endpoint andMethod:(enum REQUEST_METHOD)method success:(void(^)(id response))success fail:(void(^)(id response))fail { self.requestSerializer = [AFJSONRequestSerializer serializer]; if(data == nil) data = @{}; AFHTTPRequestOperation *operation = [self requestWithMethod:method path:endpoint parameters:data success:success fail:fail]; [operation start]; } - (AFHTTPRequestOperation *)requestWithMethod:(enum REQUEST_METHOD)method path:endpoint parameters:data success:(void(^)(id response))success fail:(void(^)(id response))fail{ switch (method) { case GET: return [self requestGETMethod:data andEndpoint:endpoint success:success fail:fail]; case POST: return [self requestPOSTMethod:data andEndpoint:endpoint success:success fail:fail]; default: return nil; } } - (AFHTTPRequestOperation *)requestGETMethod:(NSDictionary *)data andEndpoint:(NSString *)endpoint success:(void(^)(id response))success fail:(void(^)(id response))fail { return [self GET:endpoint parameters:data success:^(AFHTTPRequestOperation *operation, id responseObject) { [self callingSuccesses:GET withResponse:responseObject endpoint:endpoint data:data success:success fail:fail]; [KNZHttpCache cacheResponse:responseObject httpResponse:operation.response]; } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\n--- ERROR: %@"</span></span></span><span class="hljs-meta">, operation); NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n--- DATA: %@"</span></span></span><span class="hljs-meta">, data); [self callingFail:fail error:error]; }]; } - (AFHTTPRequestOperation *)requestPOSTMethod:(NSDictionary *)data andEndpoint:(NSString *)endpoint success:(void(^)(id response))success fail:(void(^)(id response))fail { return [self POST:endpoint parameters:data success:^(AFHTTPRequestOperation *operation, id responseObject) { [self callingSuccesses:POST withResponse:responseObject endpoint:endpoint data:data success:success fail:fail]; } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\n--- ERROR: %@"</span></span></span><span class="hljs-meta">, operation); NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n--- DATA: %@"</span></span></span><span class="hljs-meta">, data); [self callingFail:fail error:error]; }]; } - (void)callingSuccesses:(enum REQUEST_METHOD)requestMethod withResponse:(id)responseObject endpoint:(NSString *)endpoint data:(NSDictionary *)data success:(void(^)(id response))success fail:(void(^)(id response))fail { if(success!=nil) success(responseObject); } - (void)callingFail:(void(^)(id response))fail error:(NSError *)error { if(fail!=nil) fail(error); } @end</span></span></code> </pre><br><br></div></div><br>  This is quite enough to transmit network GET and POST messages.  For the most part, you will not need to adjust these files anymore. <br><br>  <b>API Layer:</b> <br>  Describes REST commands and selects a host.  API Layer is completely separated from knowledge of the implementation of network protocols and any other features of the application.  Technically, it can be completely replaced, without any changes in the rest of the application. <br><br>  The class is inherited from ClientBase.  Class code is so simple that there is no need to even give it entirely - it consists of a uniform description of the API: <br><div class="spoiler">  <b class="spoiler_title">Listing 2</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define LOGIN_FACEBOOK_ENDPOINT @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/api/v1/member/login/facebook/"</span></span></span><span class="hljs-meta"> #define LOGIN_EMAIL_ENDPOINT @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/api/v1/member/login/email/"</span></span></span><span class="hljs-meta"> - (void)loginFacebook:(NSDictionary *)data success:(void(^)(id response))success fail:(void(^)(id response))fail { [self request:data andEndpoint:LOGIN_FACEBOOK_ENDPOINT andMethod:POST success:success fail:fail]; } - (void)loginEmail:(NSDictionary *)data success:(void(^)(id response))success fail:(void(^)(id response))fail { [self request:data andEndpoint:LOGIN_EMAIL_ENDPOINT andMethod:POST success:success fail:fail]; }</span></span></code> </pre><br></div></div><br>  As the saying goes: "Nothing superfluous." <br><br>  <b>Network Cache Layer:</b> <br>  This caching layer is used to speed up network communication between the client and the server at the iOS SDK level.  The choice of answers is carried out by the party beyond the control of the system, and does not guarantee a reduction in network traffic, but speeds it up.  There is no access to data or implementation mechanisms either from the application or from the system.  This uses SQLite repository. <br><br>  The code required for this is too simple not to use it in any project that has access to the network: <br><div class="spoiler">  <b class="spoiler_title">Listing 3</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define memoCache 4 * 1024 * 1024 #define diskCache 20 * 1024 * 1024 #define DISK_CACHES_FILEPATH @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@/Library/Caches/httpCache"</span></span></span><span class="hljs-meta"> - (void)start { NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:memoCache diskCapacity:diskCache diskPath:nil]; [NSURLCache setSharedURLCache:URLCache]; }</span></span></code> </pre><br></div></div><br>  You need to call from anywhere in the application once.  For example from the starting layer. <br><br>  <b>Validation Items layer:</b> <br>  The format of the data received from the network is more dependent on the server developers.  An application cannot physically control the use of the initially specified format.  For difficult-structured data, error correction is comparable in complexity to the development of the application itself.  The presence of errors, in turn, is fraught with the crash of the application.  Using the data validation mechanism significantly reduces the risk of misbehavior.  The validation layer consists of JSON schemes for most requests to the server, and a class that checks the received data for compliance with the loaded scheme.  If the received packet does not match the scheme, it is rejected by the application.  The calling code will receive an error notification.  A similar notification will be recorded in the console log.  In addition, a server command can be called to transfer to the server side of the report about the error that occurred.  The main thing is to provide a way out of recursion, if the command to send such a message also causes some kind of error (4xx or 5xx). <br>  It makes sense to send the following data to the server: <br><ul><li>  For which account an error occurred. </li><li>  Which team caused the error. </li><li>  What data was transferred to the server. </li><li>  What response was received from the server. </li><li>  UTC time <b>*</b> </li><li>  Status code of the team.  For validation errors, it is always 200. </li><li>  A scheme that the server response does not satisfy. </li></ul><br><br>  <b>*</b> UTC time is the time when the command was called, not when the response was returned to the server.  As a rule, they coincide, but since the application may have a request queue mechanism, then theoretically, months can pass between the invocation of the failed command and the registration of the record by the server. <br>  It is assumed that JSON request schemes are provided by server developers after implementing new API commands. <br><br>  Each scheme, like each team, must meet certain previously agreed criteria.  In the above example, the server response should contain two primary and one optional fields. <br>  ‚ÄúStatus‚Äù is required.  It contains an OK or ERROR identifier (or an HTTP code of type ‚Äú200‚Äù). <br>  ‚ÄúReason‚Äù mandatory Contains a text description of the reason for the error, if it occurred.  Otherwise, this field is empty. <br>  "Data" is optional.  Contains the result of the command.  In case of error is absent. <br>  Example schema: <br><div class="spoiler">  <b class="spoiler_title">Listing 4</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"updateconfig"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1/member/updateconfig/"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"reason"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"status"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"data"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>:<span class="hljs-string"><span class="hljs-string">"object"</span></span> } }, <span class="hljs-string"><span class="hljs-string">"required"</span></span>: [<span class="hljs-string"><span class="hljs-string">"reason"</span></span>, <span class="hljs-string"><span class="hljs-string">"status"</span></span>] }</code> </pre><br></div></div><br>  Thanks to the library developed by Maxim Lunin, it became very easy to do this.  ( <a href="http://habrahabr.ru/post/180923/">habrahabr.ru/post/180923</a> ) <br><br>  Validation class code is provided below <br><div class="spoiler">  <b class="spoiler_title">Listing 5</b> <div class="spoiler_text">  ResponseValidator.h <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ResponseValidator.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SVJsonSchema.h"</span></span></span><span class="hljs-meta"> @implementation ResponseValidator + (instancetype)sharedInstance { static ResponseValidator *sharedInstance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[ResponseValidator alloc] init]; }); return sharedInstance; } #pragma mark - Methods of class + (void)validate:(id)response endpoint:(NSString *)endpoint success:(void(^)())success fail:(void(^)(NSString *error))fail { [[ sharedInstance] validate:response endpoint:endpoint success:success fail:fail]; } + (NSDictionary *)schemeForEndpoint:(NSString *)endpoint { NSString *cmd = [[ResponseValidator sharedInstance] extractCommand:endpoint]; return [[ResponseValidator sharedInstance] validatorByName:cmd]; } #pragma mark - Methods of instance - (void)validate:(id)response endpoint:(NSString *)endpoint success:(void(^)())success fail:(void(^)(NSString *error))fail { NSString *cmd = [self extractCommand:endpoint]; NSDictionary *schema = [self validatorByName:cmd]; SVType *validator = [SVType schemaWithDictionary:schema]; NSError *error; [validator validateJson:response error:&amp;error]; if(error==nil) { if(success!=nil) success(); } else { NSString *result = [NSString stringWithFormat:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@ : %@"</span></span></span><span class="hljs-meta">, cmd, error.description]; if(fail!=nil) fail(result); } } - (NSString *)extractCommand:(NSString *)endpoint { NSString *cmd = [endpoint.stringByDeletingLastPathComponent lastPathComponent]; return cmd; } - (NSDictionary *)validatorByName:(NSString *)name { static NSString *ext = @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"json"</span></span></span><span class="hljs-meta">; NSString *filePath = [[NSBundle mainBundle] pathForResource:name ofType:ext]; NSString *schema = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil]; if(schema == nil) return nil; NSData *data = [schema dataUsingEncoding:NSUTF8StringEncoding]; NSError *error; NSDictionary *result = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; return result; } @end</span></span></code> </pre><br></div></div><br>  The challenge of validation is quite simple: <br><div class="spoiler">  <b class="spoiler_title">Listing 6</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"> [ResponseValidator validate:responseObject endpoint:endpoint success:^{ <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> } fail:^(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *error) { <span class="hljs-comment"><span class="hljs-comment">/*  .  - ,     .    . */</span></span> }];</code> </pre><br></div></div><br>  <b>Network Items layer:</b> <br>  It is on this layer that the responsibility for mapping data from JSON to the deserialized representation lies.  This layer is used to describe the classes that perform object or object-relational transformation.  In the network there are a large number of libraries that carry out object-relational transformations.  For example, JSON Model ( <a href="https://github.com/icanzilb/JSONModel">github.com/icanzilb/JSONModel</a> ) or the same Maxim Lunin library.  However, not everything is so rosy.  They do not relieve the problems of mapping. <br><br>  Let us explain what mapping is: <br>  Suppose there are two queries that return the same data structure.  For example, users of the application and friends of the user who possess such fields as "identifier" and "user name".  The trouble is that server developers in one request can transfer the fields: ‚Äúid‚Äù, ‚Äúusername‚Äù, and in the second ‚Äúident‚Äù, ‚Äúuser_name‚Äù.  Such a discrepancy can have a whole set of troubles: <br><ol><li>  A de-serialized data object in Objective-C cannot have an ‚Äúid‚Äù field when using CoreData </li><li>  Serialized data in the ‚Äúid‚Äù and ‚Äúident‚Äù fields can contain both a string and NSNumber.  When outputting them to the console, the difference between the two numbers will not, but.  their hashcode will be different, and the dictionary will perceive the meaning of these fields in different ways. </li><li>  Differences between field names are the responsibility of the server, and server developers can simply not make contact, to replace their names with uniform, convenient client developers. </li></ol><br>  There is no universal solution to these problems, but they are not so complex as to require significant intellectual effort. <br><br>  <b>Local cache layer:</b> <br><br><img src="https://habrastorage.org/files/c4e/619/ff3/c4e619ff3d65434d9ee350a8c204f64e.png"><br><br>  The tasks of this layer include: <br><ol><li>  Caching images uploaded from the network. </li><li>  Caching server requests / responses </li><li>  Queuing requests in the case of a lack of a network and user work offlan. </li><li>  Monitor cached data and clean up data that has expired. </li><li>  Notification of the application about the inability to obtain information about a given object from the network. </li></ol><br>  In general, this layer is the subject of a separate large article.  But there are a certain number of nuances that developers should consider. <br>  For query caching, you can slightly modernize the procedures in Listing 1. I strongly recommend using virtual methods to do this, but for simplicity, a direct call to the class method will be demonstrated: <br><div class="spoiler">  <b class="spoiler_title">Listing 7</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)request:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)data andEndpoint:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)endpoint andMethod:(<span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> REQUEST_METHOD)method success:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))success fail:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))fail queueAvailable:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)queueAvailable { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestSerializer = [AFJSONRequestSerializer serializer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) data = @{}; <span class="hljs-comment"><span class="hljs-comment">// Returning cache response. NSDictionary *cachedResponse = [HttpCache request:endpoint]; if(cachedResponse !=nil) { [self callingSuccesses:method withResponse:cachedResponse endpoint:endpoint data:data success:success fail:fail]; return; } AFHTTPRequestOperation *operation = [self requestWithMethod:method path:endpoint parameters:data success:success fail:fail]; [self consoleLogRequest:data operation:operation]; [operation start]; } - (AFHTTPRequestOperation *)requestPOSTMethod:(NSDictionary *)data andEndpoint:(NSString *)endpoint success:(void(^)(id response))success fail:(void(^)(id response))fail { return [self POST:endpoint parameters:data success:^(AFHTTPRequestOperation *operation, id responseObject) { [self callingSuccesses:POST withResponse:responseObject endpoint:endpoint data:data success:success fail:fail]; [HttpCache cacheResponse:responseObject httpResponse:operation.response]; } failure:^(AFHTTPRequestOperation *operation, NSError *error) { NSLog(@"\n\n--- ERROR: %@", operation); NSLog(@"\n--- DATA: %@", data); [self callingFail:fail error:error]; }]; }</span></span></code> </pre><br><br></div></div><br>  In the HttpCache class, along with methods for storing query results, there is another interesting method: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 8</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define CacheControlParam @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Cache-Control"</span></span></span><span class="hljs-meta"> #define kMaxAge @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"max-age="</span></span></span><span class="hljs-meta"> - (NSInteger)timeLife:(NSHTTPURLResponse *)httpResponse { NSString *cacheControl = httpResponse.allHeaderFields[CacheControlParam]; if(cacheControl.length &gt; 0) { NSRange range = [cacheControl rangeOfString:kMaxAge]; if(range.location!=NSNotFound) { cacheControl = [cacheControl substringFromIndex:range.location + range.length]; return cacheControl.integerValue; } } return 0; }</span></span></code> </pre><br></div></div><br>  It allows you to extract key information from the server response header about how many seconds the life of the received packet will expire (the date will expire).  Using this information, you can write data to the local storage, and when you repeat a similar request, just read the previously obtained data.  If the method returns 0, then such data can be omitted. <br>  Thus, on the server it is possible to regulate what exactly should be cached on the client.  It is worth noting that standard header fields are used.  So, in terms of the standard, the bicycle is not invented. <br><br>  By another small modification of Listing 1, the queue issue is easily resolved: <br><div class="spoiler">  <b class="spoiler_title">Listing 9</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)request:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)data andEndpoint:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)endpoint andMethod:(<span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> REQUEST_METHOD)method success:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))success fail:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))fail queueAvailable:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)queueAvailable { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestSerializer = [AFJSONRequestSerializer serializer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) data = @{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(queueAvailable) { [HttpQueue request:data endpoint:endpoint method:method]; } AFHTTPRequestOperation *operation = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> requestWithMethod:method path:endpoint parameters:data success:success fail:fail]; [operation start]; }</code> </pre><br></div></div><br>  The HttpQueue class checks whether there is currently a connection to the network and, if it does not exist, writes a request to the repository indicating the time of the request made to the nearest millisecond.  When the connection is resumed, data is read from the storage and transferred from to the server, while simultaneously clearing the request queue.  This makes it possible to provide a certain client-server operation without direct connection to the network. <br><br>  Network connectivity is verified using Apple‚Äôs AFNetworkReachabilityManager or Reachability classes ( <a href="https://developer.apple.com/library/ios/samplecode/Reachability/Introduction/Intro.html">developer.apple.com/library/ios/samplecode/Reachability/Introduction/Intro.html</a> ) together with the observer pattern.  His device is too primitive to describe in the framework of the article. <br>  However, not all requests must be sent to the queue.  Some of them may not be relevant at the time of the appearance of the network.  Deciding which teams should be written to the cache queue, and how to be relevant at the time of the call can be both at the level of the cache layer and at the level of the API layer. <br><br>  In the first case, in Listing 9, instead of calling the save method in the queue, you need to insert a virtual method, and inherit the LocalCacheLayerWithQueue and LocalCacheLayerWithoutQueue classes from the ApiLayer class.  Then in the specified virtual method of the LocalCacheLayerWithQueue class make a call [HttpQueue request: endpoint: method:] <br><br>  In the second case, the call request from the ApiLayer class will change slightly. <br><div class="spoiler">  <b class="spoiler_title">Listing 10</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)trackNotification:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)data success:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))success fail:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response))fail { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request:data andEndpoint:TRACKNOTIFICATION_ENDPOINT andMethod:POST success:success fail:fail queueAvailable:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br></div></div><br><br>  Listing 9 provides the if (queueAvailable) condition for this particular case. <br><br>  Also, a separate issue is the issue of caching images.  In general, the question is not complicated, and therefore, it has an infinite number of realizations.  For example, the SDWebImage library does this quite successfully: ( <a href="https://github.com/rs/SDWebImage">github.com/rs/SDWebImage</a> ). <br><br>  Meanwhile, there are some things that she does not know how to do.  For example, it cannot clear the cache of images according to specified criteria (the number of images, the date they were created, etc.), logging or correction of specific errors, that is, the developer still has to reinvent his bikes for caching. <br><br>  I will give an example of an asynchronous download of an image from the network, with correction of a MIME error (for example, Amazon often gives the wrong MIME type, with the result that their web server sends the image, not as a binary file with a picture, but as a data stream). <br><div class="spoiler">  <b class="spoiler_title">Listing 11</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define LOCAL_CACHES_IMAGES_FILEPATH @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@/Library/Caches/picture%ld.jpg"</span></span></span><span class="hljs-meta"> - (void)loadImage:(NSString*)link success:(void(^)(UIImage *image))success fail:(void(^)(NSError *error))fail { UIImage *image = [ImagesCache imageFromCache:link.hash]; if(image == nil) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ __block NSData *data; __block UIImage *remoteImage; __block NSData *dataImage; __block NSString *imgFilePath = [NSString stringWithFormat:LOCAL_CACHES_IMAGES_FILEPATH, NSHomeDirectory(), (unsigned long)link.hash]; data = [NSData dataWithContentsOfURL: [NSURL URLWithString:link]]; // Reading DATA if(data.length &gt; 0) { remoteImage = [[UIImage alloc] initWithData: data]; // TRANSFORM DATA TO IMAGE if(remoteImage!=nil) { dataImage = [NSData dataWithData:UIImageJPEGRepresentation(remoteImage, 1.0)]; // TRANSFORM IMAGE TO JPEG DATA if(dataImage!=nil &amp;&amp; dataImage.length &gt; 0) [dataImage writeToFile:imgFilePath atomically:YES]; // Writing JPEG file } else // try to fix BINARY image type (first method) { [dataImage writeToFile:imgFilePath atomically:YES]; remoteImage = [UIImage imageWithContentsOfFile:imgFilePath]; } } else // try to fix BINARY image type (second method) { NSURLRequest *urlRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:link]]; NSURLResponse *response = nil; NSError *error = nil; data = [NSURLConnection sendSynchronousRequest:urlRequest returningResponse:&amp;response error:&amp;error]; if (error == nil) { remoteImage = [[UIImage alloc] initWithData: data]; // TRANSFORM DATA TO IMAGE if(remoteImage!=nil) { dataImage = [NSData dataWithData:UIImageJPEGRepresentation(remoteImage, 1.0)]; // TRANSFORM IMAGE TO JPEG DATA if(dataImage!=nil &amp;&amp; dataImage.length &gt; 0) [dataImage writeToFile:imgFilePath atomically:YES]; // Writing JPEG file } NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"USED SECONDARY METHOD FOR LOAD OF IMAGE"</span></span></span><span class="hljs-meta">); } else NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DATA WASN'T LOAD %@\nLINK %@"</span></span></span><span class="hljs-meta">, error, link); } dispatch_async(dispatch_get_main_queue(), ^{ if(remoteImage!=nil &amp;&amp; success!=nil) { success(remoteImage); [ImagesCache update:link.hash]; } else { if(data.length == 0) NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n============================\nDETECTED ERRROR OF DOWNLOAD IMAGE\nFILE CAN'T LOAD\nUSED PLACEHOLDER\n============================\n"</span></span></span><span class="hljs-meta">); else NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n============================\nDETECTED ERRROR OF DOWNLOAD IMAGE\nUSED PLACEHOLDER\n============================\n"</span></span></span><span class="hljs-meta">); NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LINK %@"</span></span></span><span class="hljs-meta">, link); UIImage *placeholder = [LoadImage userPlaceholder]; if (success) success(placeholder); // if(fail!=nil) // fail([NSError errorWithDomain:[NSString stringWithFormat:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%@ not accessible"</span></span></span><span class="hljs-meta">, link] code:-1 userInfo:nil]); } }); }); } else { success(image); } }</span></span></code> </pre><br></div></div><br>  The method may seem very redundant, but easily modified to the specific needs of the developer.  From the important points, it should be noted that the image URL hash is used as the key for caching.  It is almost impossible for such an approach to have a collision within the device file system. <br>  Each time the file is read from the cache, the access date is modified.  Files that are not reread for a long time, you can safely delete even at the start of the application. <br><br>  When it comes to reading the file from the application bundle, there is a nuance that developers forget: the iOS SDK provides us with methods such as [UIImage imageNamed:] and [UIImage imageWithContentsOfFile:].  It is simpler to use the first one, but it significantly affects the memory load - the fact is that the file loaded with it remains in the device‚Äôs memory until the application is completed.  If it is a file that has a large amount, then this can be a problem.  It is recommended to use the second method as often as possible.  It is also helpful to make a slight improvement in the boot method: <br><div class="spoiler">  <b class="spoiler_title">Listing 12</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *)fromBundlePng:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)name { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[LoadImage sharedInstance] fromBundlePng:name]; } - (<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *)fromBundle:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)name { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> downloadFromBundle:name.stringByDeletingPathExtension ext:name.pathExtension]; } - (<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *)downloadFromBundle:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)name ext:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)ext { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *filePath = [[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] pathForResource:name ofType:ext]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(filePath == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *filename = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:<span class="hljs-string"><span class="hljs-string">@"%@@2x"</span></span>, name]; filePath = [[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] pathForResource:filename ofType:ext]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageWithContentsOfFile:filePath]; }</code> </pre><br></div></div><br>  Now you don‚Äôt have to wonder what resolution the file is in. <br><br>  Workflows layer: <br>  All implemented algorithms that do not belong to the kernel layers and do not constitute a GUI should be placed in classes of specific workflow sequences.  Each of these processes is designed in its own style, and is connected to the main part of the application by adding references to an instance of the corresponding class in the GUI.  In most cases, all these processes are not visual.  However, there are some exceptions, for example, when it is necessary to carry out a long sequence of predefined animation frames, with specified display algorithms <br>  The calling code must have minimal knowledge of this functionality.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All flow settings must be encapsulated. </font><font style="vertical-align: inherit;">Google gives as an example the code for notification from the analytics server, and suggests including it in the place where the event occurs.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 13</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// Analytics [Analytics passedEvent:ANALYTICS_EVENT_PEOPLE_SELECT ForCategory:ANALYTICS_CATEGORY_PEOPLE WithProperties:nil];</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, if there is a need to notify another server, next to this code you will need to add the same code with your own settings. Such an approach is unjustified and unacceptable. Instead, you need to create a class that has a class method to call analytical servers with the specified functionality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are quite advanced workflows, the functioning logic of which depends on the internal state. Such processes should be implemented using the Strategy or State Machine patterns. As a rule, the ‚Äúmediator‚Äù pattern is used in conjunction with the ‚Äústrategy‚Äù pattern, which mediates a call to one or another algorithm.</font></font><br>      ‚Äî    ‚Äî        ¬´ ¬ª.  ,    flow     ¬´¬ª  ,         (Network Layer,  Validation Items). <br><br>          (callback),                 .           ,   . <br>  ,      ,  -         .    ,      .          ,    , ,   ,        .       ,   ‚Äî  ,   . . .      ,     ,         . <br><br> <b>Local storage:</b> <br>       , ,    , ,   .           CoreData.   ,          ,    ,    Apple ,    . <br>           .  CoreData    ,         . ,       ,       CoreData     .  , ,             ,        ,   ,    ,      . <br><br>  CoreData ( <a href="http://habrahabr.ru/post/191334/">habrahabr.ru/post/191334</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), in addition, it also requires compliance with certain procedures, algorithms and architectural solutions, which limits us in choosing the development strategy, and also significantly complicates the debugging mechanisms of our application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a rule, the use of permanent storage is designed to ensure a significant reduction in network traffic, due to the use of information already received from the network. However, in some cases this does not happen because the source of this information is the server, which makes decisions about the relevance of this information. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local storage based on the file system</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using NSDictionary as the format of the received data allows you to automatically solve a number of architectural problems:</font></font><br><ol><li>          ,       . </li><li>       ,       POST  (. .        ,       ,    ,     POST  ). </li><li>       . </li><li>        . </li><li>   ACID : <a href="https://en.wikipedia.org/wiki/ACID">en.wikipedia.org/wiki/ACID</a> </li><li>     . </li><li>    . </li><li>    . </li><li>     (1 ). </li></ol><br><br>   /  iOS SDK  NSDictionary       ,      . <br><br>         ,    .       ,     . <br><br>     ,       , ,   ,       5,     ,  ,       ,    ,     , ,  ViewController  .        ()    SQL     (      ),     ,   ,     .     ,      ,      .  ,     . <br><br> <b>    CoreData.</b> <br><br> CoreData       .      - ,      .      API profile,       copyDataFromRemoteJSON,     ,         (  NSManagedObject). <br>   ,   : <br><br><div class="spoiler"> <b class="spoiler_title"> 14</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"> [[Client client] profile:@{} success:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response) { [[Member getCurrentMember] copyDataFromRemoteJSON:[response valueForKey:<span class="hljs-string"><span class="hljs-string">@"data"</span></span>]]; } fail:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response) { }];</code> </pre><br></div></div><br>     ,   callback  API      , ,   ,   . <br><br>      : <br><ol><li>           . </li><li>          ,       .     . </li><li>     ,    ,      . </li><li>      (   )     .   . </li><li>       . (. .       , ,     ,     ,  /,   ,  ). </li><li>  ,         </li></ol><br><br> <b>  :</b> <br>  ,      NSFetchController        ,       .  ,          .  .   -  .        .    , ,   ,    . <br><br> <b>  :</b> <br><ol><li>           ,     (    ): </li><li>       , ,    SQLite  ,      ¬´¬ª .        ,  -  ,   ,  CoreData  SQLite. </li><li>       ,     . </li><li>          . ,       ,  .  ,        . </li><li>      Database        , ,    ,     . </li><li> ACID    SQLite    CoreData.            .       MagicRecords. </li><li>       .       ,    ,         ,      ,        . </li><li>   CoreData  .          ,   CoreData     . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the relevance of the data is determined by the server, and not by the application, the data that was not received from the network still has to be deleted. </font><font style="vertical-align: inherit;">Thus, the use of CoreData does not affect the network traffic in this scheme.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The amount of code is many times greater than that needed to maintain storage based on the file system. </font><font style="vertical-align: inherit;">Also, the use of CoreData imposes certain restrictions on the user interface.</font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secondly, the shortcomings of the approach should also include the fact that: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CoreData requires a certain discipline for working from various application threads, and choosing the actual context. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data synchronization can reduce the performance of the device so much that the issue of using 4S devices will be very relevant. </font></font></li><li>    .   ,         MagicalRecords (https://github.com/magicalpanda/MagicalRecord)      . </li></ol><br>      CoreData,   ,        ,       .         ‚Äî  CoreData     , ,    ,         ,      NoSQL    XML. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using the MagicalRecords library, a situation arises when the table view must be part of the UITableViewController for the application to function properly, otherwise it becomes difficult to use the NSFetchController underlying CoreData data loading. Thus, there is a dependency in the use of the user interface, on local storage. That is, CoreData implementation limits the development of the UI. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative view</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despite objections, using CoreData can, indeed, potentially increase performance with increasing data volume, if you use the following alternatives: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative 1</font></font></b> <br>    API .       ,    ,    ,      . <br>  In this case: <br>      ,    . <br>         ,     ,   . <br>          . <br><br> <b> 2</b> <br>        :    CoreData    JSON    ,     .     ,  ,  ,   . <br>  : <br><ol><li>   ¬´ ¬ª      JSON . </li><li>        , . .   . </li><li>     . </li><li>       ,        . </li><li>     SQLite     . </li><li>     . </li></ol><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion: The</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article was quite long, and I doubt that most readers will master it to the end. For this reason, the part related to the GUI I decided to throw out from here. Firstly, it related to building the user interface via UITabbar, and secondly, in one of the Skype groups, a very interesting discussion took place regarding the use of the well-known MVC and MVVM patterns. To state the principles of building an interface does not make sense without a rigorous presentation of existing practices and approaches that lead developers to a dead end. But this is a big topic for another multi-page article. Here, I tried to consider only issues related to the operation of the application core.</font></font><br>        ,        ,      . </div><p>Source: <a href="https://habr.com/ru/post/246877/">https://habr.com/ru/post/246877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246865/index.html">10 key strategic technologies of 2015 according to Gartner</a></li>
<li><a href="../246867/index.html">As a student to have an up-to-date schedule, as wardens and teachers send messages to the whole group at once.</a></li>
<li><a href="../246869/index.html">Generator do-it-yourself at 220 volts. Now the blackouts are not scary.</a></li>
<li><a href="../246873/index.html">The release of the educational program for startups ABRT-Mangrove CEO Camp 2.0</a></li>
<li><a href="../246875/index.html">About the personal effectiveness of the programmer, or How to focus on the most important, not forgetting everything else</a></li>
<li><a href="../246881/index.html">Tutorial AngularJS: A Comprehensive Guide, Part 1</a></li>
<li><a href="../246883/index.html">6 Flappy Bird Lessons for Entrepreneurs</a></li>
<li><a href="../246885/index.html">How I got a code medal</a></li>
<li><a href="../246891/index.html">How a lighter and cheaper radio module can change the future of telecommunications</a></li>
<li><a href="../246893/index.html">IT trends in corporations in 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>