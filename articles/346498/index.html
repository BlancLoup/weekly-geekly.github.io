<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tutorial on the Unreal Engine. Part 9: Artificial Intelligence</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the video game industry, artificial intelligence (Artificial Intelligence, AI) is usually called the decision-making process by non-player-controll...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tutorial on the Unreal Engine. Part 9: Artificial Intelligence</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/597/510/6f3597510e114b09862a516686123acd.jpg" alt="image"></div><br>  In the video game industry, artificial intelligence (Artificial Intelligence, AI) is usually called the decision-making process by non-player-controlled characters.  It can be simple: the enemy sees the player and attacks.  Or more difficult, for example, a controlled AI opponent in real-time strategy. <br><br>  In the Unreal Engine, AI can be created using <em>behavior trees</em> .  The behavior tree is a system for determining the <em>behavior</em> used by AI.  For example, he may have a fight or run behavior.  You can create a behavior tree in which the AI ‚Äã‚Äãwill fight a player if his health is higher.  If it is below 50%, then it will run away. <br><br>  In this tutorial you will learn the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Create an AI entity that can control the Pawn element. </li><li>  Create and use behavior trees and blackboard </li><li>  Use AI Perception to give pawn vision </li><li>  Create behaviors so Pawn can walk and attack enemies. </li></ul><a name="habracut"></a><br>  <em>Note:</em> This article is one of the nine parts of the Unreal Engine tutorial series: <br><br><ul><li>  <a href="https://habrahabr.ru/post/344394/">Part 1: Introduction to the engine</a> </li><li>  <a href="https://habrahabr.ru/post/344446/">Part 2: Blueprints</a> </li><li>  <a href="https://habrahabr.ru/post/344522/">Part 3: Materials</a> </li><li>  <a href="https://habrahabr.ru/post/344600/">Part 4: UI</a> </li><li>  <a href="https://habrahabr.ru/post/344690/">Part 5: How to create a simple game</a> </li><li>  <a href="https://habrahabr.ru/post/344840/">Part 6: Animation</a> </li><li>  <a href="https://habrahabr.ru/post/345018/">Part 7: Sound</a> </li><li>  <a href="https://habrahabr.ru/post/345110/">Part 8: Particle Systems</a> </li><li>  Part 9: Artificial Intelligence </li><li>  <a href="https://habrahabr.ru/post/347036/">Part 10: How to create a simple FPS</a> </li></ul><br><h2>  Getting Started </h2><br>  Download the <a href="">project blank</a> and unpack it.  Navigate to the project folder and open <em>MuffinWar.uproject</em> . <br><br>  Click on <em>Play</em> to start the game.  <em>Press the left mouse button</em> inside the enclosed area to create a muffin. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/076/839/57c/07683957cf5ea272891834036e694af9.gif"></div></div></div><br>  In this part of the tutorial, we will create an AI that will roam around the screen.  When an enemy muffin comes into the view of the AI, he approaches the enemy and attacks him. <br><br>  To create an AI character, we need three things: <br><br><ol><li>  <em>Body: the</em> physical shape of the character.  In our case, the body is a muffin. </li><li>  <em>Soul: the</em> essence that controls the character.  This can be a player or an AI. </li><li>  <em>Brain:</em> how AI makes decisions.  The brain can be created in various ways, for example, using C ++ code, Blueprints, or behavior trees. </li></ol><br>  We already have a body, so we need more soul and brain.  First we will create a <em>controller</em> that will be the ‚Äúsoul‚Äù. <br><br><h2>  What is a ‚Äúcontroller‚Äù? </h2><br>  A controller is a non-physical actor that can <em>move</em> into Pawn.  Universe allows the controller (as you might guess) <em>to control the</em> pawn.  But what does ‚Äúmanage‚Äù mean in this context? <br><br>  For the player, this means that when you press the key, Pawn will do something.  The controller receives the player's input and sends the entered data to the pawn.  Also, the controller can process the input itself and tell Pawn to perform the action. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/6cd/297/6e46cd297ff9f63f2c0b33fe925d7fd6.jpg"></div><br>  In the case of an AI, Pawn may receive information from a controller or brain (depending on how you implement it). <br><br>  To control the muffins using AI, you need to create a special type of controller, called <em>an AI controller</em> . <br><br><h3>  Create AI Controller </h3><br>  Go to <em>Characters \ Muffin \ AI</em> and create a new <em>Blueprint Class</em> .  Select <em>AIController</em> as the parent class and name it <em>AIC_Muffin</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a7/456/997/7a7456997b78d1919a72e65bf2ddadeb.jpg"></div><br>  Then you need to tell the muffin to use the new AI controller.  Go to <em>Characters \ Muffin \ Blueprints</em> and open <em>BP_Muffin</em> . <br><br>  By default, the Details panel should display the default Blueprint parameters.  If not, then click on the <em>Class Defaults</em> in the Toolbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a0/83e/d6a/4a083ed6a6d1b06c26b4dd4452ba61b5.jpg"></div><br>  Go to the Details panel and find the <em>Pawn</em> section.  Set the <em>AI Controller Class</em> to <em>AIC_Muffin</em> .  This will create an instance of the controller when creating a muffin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/4d7/9d3/ce74d79d34f059296800fc813d7dc8bf.jpg"></div><br>  As we create the muffins dynamically, we also choose <em>Spawned</em> for <em>Auto Possess AI</em> .  So <em>AIC_Muffin</em> will automatically <em>populate the BP_Muffin</em> when it is created. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22c/78f/9e2/22c78f9e23cd7881163d12e12fa9a9dd.jpg"></div><br>  Click on <em>Compile</em> and close <em>BP_Muffin</em> . <br><br>  Now we will create a logic that will control the behavior of the muffin.  You can use <em>behavior trees for this</em> . <br><br><h2>  Create a Behavior Tree </h2><br>  Go to <em>Characters \ Muffin \ AI</em> and select <em>Add New \ Artificial Intelligence \ Behavior Tree</em> .  Call it <em>BT_Muffin</em> and open it. <br><br><h3>  Behavior Tree Editor </h3><br>  There are two new panels in the behavior tree editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/2d2/470/2f82d2470b0924b66274ee2b45a20f6d.jpg"></div><br><ol><li>  <em>Behavior Tree:</em> this is a graph in which we will create nodes for the behavior tree </li><li>  <em>Details:</em> the properties of the selected nodes are displayed here. </li><li>  <em>Blackboard: Blackboard</em> keys (more about them later) and their meanings are displayed in this panel.  Displayed only when the game is running. </li></ol><br>  Like Blueprint, a behavior tree consists of nodes.  There are four types of nodes in behavior trees.  The first two are <em>task</em> and <em>composite</em> . <br><br><h3>  What is Task and Composite? </h3><br>  As the name implies, a task is a node that "does" something.  It can be something complicated, for example, a chain of combos, or something simple, for example, waiting. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/e99/382/f76e99382c6aecb5bb69bf1b80617f6d.jpg"></div><br>  To perform tasks you need to use composites (composite).  A behavior tree consists of many branches (behaviors).  At the root of each branch is a composite.  Different types of composites have different ways of performing their child nodes. <br><br>  Suppose we have the following sequence of actions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/8a7/032/d948a703293c2f034579f21f732ce8db.jpg"></div><br>  To perform each action sequentially, we need to use the <em>Sequence</em> composite, because the Sequence runs its children from left to right.  Here is what it will look like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b39/e9b/773/b39e9b7731ec7ab4216eaa68d84bec47.jpg"></div><br>  <em>Note:</em> anything that begins with a composite can be called a <em>subtree</em> .  This is usually a behavior.  In our example, the <em>Sequence</em> , <em>Move To Enemy</em> , <em>Rotate Towards Enemy,</em> and <em>Attack</em> can be considered the ‚Äúattack the enemy‚Äù behavior. <br><br>  If any of the child nodes of the Sequence <em>fails to execute</em> , then the Sequence stops executing. <br><br>  For example, if Pawn cannot move to the enemy, then <em>Move To Enemy</em> will fail.  This means that <em>Rotate Towards Enemy</em> and <em>Attack</em> will not be executed.  However, they will be executed if Pawn manages to move towards the enemy. <br><br>  We will also learn about the composite <em>selector</em> later.  For now, we'll use <em>Sequence</em> to move Pawn to a random point and then wait. <br><br><h3>  Movement to a random point </h3><br>  Create a <em>Sequence</em> and connect it to <em>Root</em> . <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/aa1/1ed/23eaa11ed38e18b953156c5ff28b9920.gif"></div></div></div><br>  Now we need to move the pawn.  Create a <em>MoveTo</em> and connect it to the <em>Sequence</em> .  This node will move Pawn to the specified point or actor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/812/d69/f4e/812d69f4e9cd89285d0aba3529e44057.jpg"></div><br>  Then create <em>Wait</em> and connect it to <em>Sequence</em> .  It is necessary to place this node to the <em>right</em> of <em>MoveTo</em> .  The order here is important because the child nodes run from left to right. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/993/296/6e6/9932966e62c12fee6e9a3428c4fac3c3.jpg"></div><br>  <em>Note:</em> you can check the order of execution by looking at the numbers in the upper right corner of each node.  The smaller the value, the higher the priority of the nodes. <br><br>  Congratulations, you have just created your first behavior!  It will move the pawn to the selected point, and then wait five seconds. <br><br>  To move Pawn you need to specify a point.  However, <em>MoveTo</em> can only get values ‚Äã‚Äãreceived from <em>blackboard</em> , so let's create it. <br><br><h2>  Blackboard creation </h2><br>  Blackboard is a resource whose sole purpose is to store variables (called <em>keys</em> ).  It can be considered its AI memory. <br><br>  Although it is not necessary to use them, blackboard provides a convenient way to read and save data.  It is convenient because many nodes in behavior trees can only receive blackboard keys. <br><br>  To create a blackboard, go back to the Content Browser and select <em>Add New \ Artificial Intelligence \ Blackboard</em> .  Call it <em>BB_Muffin</em> and open it. <br><br><h3>  Blackboard editor </h3><br>  The blackboard editor consists of two panels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/2be/5cd/2872be5cd36c14307b5c2b18d2343337.jpg"></div><br><br><ol><li>  <em>Blackboard: a</em> list of keys is displayed in this panel. </li><li>  <em>Blackboard Details: the</em> properties of the selected key are displayed in this panel. </li></ol><br>  Now we need to create a key that will contain the target point. <br><br><h3>  Creating the key of the target point </h3><br>  Since we store points in 3D space, we need to store them as vectors.  Click on <em>New Key</em> and select <em>Vector</em> .  Call it <em>TargetLocation</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/b07/57f/93ab0757fc02e52800e5f52263d58596.jpg"></div><br>  Now we need a way to generate a random point and save it in blackboard.  To do this, we will use the third type of node of the behavior tree: <em>service</em> . <br><br><h2>  What is a service? </h2><br>  Services are similar to the tasks with which we do something.  However, rather than forcing Pawn to perform actions, we use services to perform checks or update blackboard. <br><br>  Services are not separate nodes, they are attached to tasks or composites.  Due to this, a more ordered tree is created, because we have to work with fewer nodes.  This is how the use of the task looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ef/272/9be/4ef2729be7dc36cb9f8792ebe00ef490.jpg"></div><br>  And this is what the use of the service looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e72/c6e/2dae72c6e7dc9f86ca0fadc21283d9b4.jpg"></div><br>  Now we can create a service that generates a random point. <br><br><h3>  Service creation </h3><br>  Go back to <em>BT_Muffin</em> and click on <em>New Service</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/996/312/8a8/9963128a8531b8f0ed0abcbb0eb697fc.jpg"></div><br>  This will create and automatically open a new service.  Call it <em>BTService_SetRandomLocation</em> .  To rename it, you will need to return to the Content Browser. <br><br>  The service should only be performed when Pawn needs to move.  To do this, attach it to <em>MoveTo</em> . <br><br>  Open <em>BT_Muffin</em> and <em>right-click</em> on <em>MoveTo</em> .  Choose <em>Add Service \ BTService Set Random Location</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/f03/acc/eb6f03acc1260cf0aa22d73fba455d46.gif"></div><br>  Now <em>BTService_SetRandomLocation</em> will be activated when <em>MoveTo</em> is activated. <br><br>  Next we need to generate a random target point. <br><br><h3>  Random Point Generation </h3><br>  Open Open <em>BTService_SetRandomLocation</em> . <br><br>  To find out when the service is activated, create an <em>Event Receive Activation AI</em> node.  It will be executed when the parent is activated (the node to which it is attached). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/5cd/543/c355cd543f1ebab2825abc9f7d213804.jpg"></div><br>  <em>Note:</em> There is also an <em>Event Receive Activation</em> event that does the same.  The difference between the two events is that the <em>Event Receive Activation AI</em> also provides a <em>Controlled Pawn</em> . <br><br>  To generate a random point, add the selected node.  The parameter <em>Radius is</em> assigned the value <em>500</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/1df/4da/6fb1df4daadd8ea9972286ce72a9f899.jpg"></div><br>  This will give us a random point within <em>500</em> units of Pawn, which you can reach. <br><br>  <em>Note:</em> to determine if you can get to the point, <em>GetRandomPointInNavigableRadius</em> uses navigation data (called <em>NavMesh</em> ).  In this tutorial, I pre-created NavMesh.  You can visualize it by going to Viewport and selecting <em>Show \ Navigation</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/148/911/00e/14891100e01eb9e5a9cc46008a17d6fe.jpg"></div><br>  If you want to create your own NavMesh, then create a <em>Nav Mesh Bounds Volume</em> .  Change its scale so that it restricts the area that should be available for movement. <br><br>  Now we need to save the point in the blackboard.  There are two ways to select the key to use: <br><br><ol><li>  You can specify a key using its name in the <em>Make Literal Name</em> node </li><li>  You can make the variable visible in the behavior tree.  This will allow you to select a key from the drop-down list. </li></ol><br>  We will use the second method.  Create a variable of type <em>Blackboard Key Selector</em> .  Name it <em>BlackboardKey</em> and turn on <em>Instance Editable</em> .  This will make the variable visible when selecting a service in the behavior tree. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/487/b41/4b6487b413d43fcb28a58f0fbbca94b4.jpg"></div><br>  Next, create the following selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/ccb/946/5a2ccb946ae6f8f7ee2c803b9aec566e.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Event Receive Activation AI</em> runs when its parent is activated (in this case, <em>MoveTo</em> ) </li><li>  <em>GetRandomPointInNavigableRadius</em> returns a random navigation point within a radius of <em>500</em> units from a controlled muffin. </li><li>  <em>Set Blackboard Value as Vector</em> sets the blackboard key (transmitted via <em>BlackboardKey</em> ) to a random point value. </li></ol><br>  Click on <em>Compile</em> and close <em>BTService_SetRandomLocation</em> . <br><br>  Now we want to tell the behavior tree to use our blackboard. <br><br><h3>  Blackboard selection </h3><br>  Open <em>BT_Muffin</em> and make sure nothing is selected.  Go to the Details panel.  In <em>Behavior Tree,</em> set <em>Blackboard Asset</em> to <em>BB_Muffin</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c71/378/915/c713789152e212c6b9e87be89fb544f6.jpg"></div><br>  After this, <em>MoveTo</em> and <em>BTService_SetRandomLocation</em> will automatically use the first blackboard key.  In our case, this is <em>TargetLocation</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c10/e4e/d25/c10e4ed257df13b177c9bebaef2219ed.jpg"></div><br>  Finally, we need to order the AI ‚Äã‚Äãcontroller to start the behavior tree. <br><br><h2>  Execution of the behavior tree </h2><br>  Open <em>AIC_Muffin</em> and connect the <em>Run Behavior Tree</em> to the <em>Event BeginPlay</em> .  Select <em>BT_Muffin</em> for <em>BTAsset</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/e12/a2b/0aee12a2b8945d0fce53812d7ec8c6df.jpg"></div><br>  So <em>BT_Muffin</em> will be launched when creating <em>AIC_Controller</em> . <br><br>  Click on <em>Compile</em> and return to the main editor.  Click on <em>Play</em> , create some muffins and see how they wander around the screen. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ec/83a/429/9ec83a429dc3d1e636019295aab4f341.gif"></div></div></div><br>  We had to work hard, but we did it!  Now we need to configure the AI ‚Äã‚Äãcontroller so that it recognizes enemies in its area of ‚Äã‚Äãvisibility.  To do this, you can use <em>AI Perception</em> . <br><br><h2>  Configure AI Perception </h2><br>  AI Perception is a component that can be added to actors.  With it, you can give AI <em>feelings</em> (such as sight and hearing). <br><br>  Open <em>AIC_Muffin</em> and add an <em>AIPerception</em> component. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/a29/d57/6f9a29d570e3a1709a776880061b083e.jpg"></div><br>  Now we need to add a feeling.  We want the muffin to recognize another muffin falling into the field of view, so we need to add <em>vision</em> . <br><br>  Select <em>AIPerception</em> and go to the Details panel.  In the <em>AI Perception</em> section, add a new element to the <em>Senses Config</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/4d6/c6d/de34d6c6dd621bbcac98fe31693f362b.jpg"></div><br>  Set element <em>0</em> for <em>AI Sight config</em> and expand it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/26a/905/51d26a90588076e1b6083f199d345b60.jpg"></div><br>  Vision has three main parameters: <br><br><ol><li>  <em>Sight Radius: the</em> maximum distance that a muffin can see.  Leave here the value of <em>3000</em> . </li><li>  <em>Lose Sight Radius:</em> if the muffin saw the enemy, this is the value by which the enemy must move away for the muffin to lose sight of him.  Leave here the value of <em>3500</em> . </li><li>  <em>Peripheral Vision Half Angle Degrees: the</em> angle of view of the muffin.  Set the value to <em>45</em> .  This will give the muffin a viewing angle of <em>90</em> degrees. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/fcb/4fc/61cfcb4fc8f6f365ef580cc2a38597d9.jpg"></div><br>  By default, AI Perception recognizes only enemies (actors assigned to another <em>team</em> ).  However, by default, actors have no command.  If the actor has no command, then AI Perception considers it <em>neutral</em> . <br><br>  At the time of writing, there was no way to assign commands using Blueprints.  Instead, you can simply order AI Perpcetion to recognize neutral actors.  To do this, expand <em>Detection by Affiliation</em> and turn on <em>Detect Neutrals</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/7ad/9d0/9527ad9d0ca3c86632e601bfd2df83f7.jpg"></div><br>  Click on <em>Compile</em> and return to the main editor.  Click on <em>Play</em> and create some muffins.  Press the <em>'</em> key to display the AI ‚Äã‚Äãdebug screen.  Press key <em>4</em> on the number <em>pad</em> to visualize AI Perception.  When the muffin comes into view, a green sphere appears. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec7/ceb/686/ec7ceb6863e68e1b22a3e36f72c82770.gif"></div></div></div><br>  Now we need to move the muffin towards the enemy.  For this, the behavior tree must <i>know</i> about the enemy.  This can be done by saving the link to the enemy in the blackboard. <br><br><h2>  Creating an enemy key </h2><br>  Open <em>BB_Muffin</em> and add an <em>Object</em> key.  Rename it to <em>Enemy</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/a30/f24/1faa30f248790de722dae93c3795ccfb.jpg"></div><br>  While we can not use <em>Enemy</em> in <em>MoveTo</em> , because the key is of type <em>Object</em> , but <em>MoveTo</em> can only receive keys of type <em>Vector</em> or <em>Actor</em> . <br><br>  To fix this, select <em>Enemy</em> and expand <em>Key Type</em> .  Select <em>Base Class for</em> <em>Actor</em> .  This will allow the behavior tree to recognize <em>Enemy</em> as <em>Actor</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb0/f9d/cda/eb0f9dcda7e22bf50eac98074d607497.jpg"></div><br>  Close <em>BB_Muffin</em> .  Now we need to create a behavior to move towards the enemy. <br><br><h3>  Movement towards the enemy </h3><br>  Open <em>BT_Muffin</em> and separate the <em>Sequence</em> from the <em>Root</em> .  This can be done by <em>holding down Alt and left-clicking</em> on the <em>wire</em> connecting them.  For now, let's leave the subtree of random motion alone. <br><br>  Now create the selected nodes and set the <em>Blackboard Key</em> value to <em>Enemy</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/593/498/b3e/593498b3ee09b23ae16b02328b7caa9c.jpg"></div><br>  In this case, Pawn will move to <em>Enemy</em> .  In some cases, Pawn does not completely turn to the target, so you need to use also <em>Rotate to face BB entry</em> . <br><br>  Now you need to set <em>Enemy</em> when AI Perception recognizes another muffin. <br><br><h3>  Set the key Enemy </h3><br>  Open <em>AIC_Muffin</em> and select the <em>AIPerception</em> component.  Add an <em>On Perception Updated</em> event. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe3/356/dfc/fe3356dfc48b449fabebbac3f878f0f5.jpg"></div><br>  This event is executed when the feeling is updated.  In our case, it is executed when the AI ‚Äã‚Äãsees or loses someone.  This event also transmits a list of actors that are currently detected by the senses. <br><br>  Add highlighted nodes.  Make sure the <em>Make Literal Name</em> is set to <em>Enemy</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a36/87d/dd1/a3687ddd1acea1186c384d1da1436b09.jpg"></div><br>  This will allow you to check if the AI ‚Äã‚Äãis already an enemy.  If not, we must give him an enemy.  To do this, add the selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/367/3f3/20f3673f3d30a45181615ca5d6e0333e.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>IsValid</em> checks if the <em>Enemy</em> key is set </li><li>  If it is not specified, then all currently detected actors cycle </li><li>  <em>Cast To BP_Muffin</em> checks if the actor is a muffin </li><li>  If he is a muffin, then we check to see if he is dead. </li><li>  If <em>IsDead</em> returns <em>false</em> , then set the muffin as the new <em>Enemy</em> and stop the cycle </li></ol><br>  Click on <em>Compile</em> and close <em>AIC_Muffin</em> .  Click on <em>Play</em> and create two muffins so that one is in front of the other.  The muffin, located behind, will automatically begin to move to another. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dd/81a/5f9/6dd81a5f9bb7c53f0c9423aeac046e09.gif"></div></div></div><br>  Now we will create our own task for the muffin to carry out the attack. <br><br><h2>  Creating an attack task </h2><br>  We can create a task in the Content Browser instead of the behavior tree editor.  Create a new <em>Blueprint Class</em> and select <em>BTTask_BlueprintBase</em> as the parent class. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c42/129/ee2/c42129ee2c67adaedba44c5656e6275a.jpg"></div><br>  Call it <em>BTTask_Attack</em> and open it.  Add an <em>Event Receive Execute AI</em> node.  This node will be executed when the behavior tree executes <em>BTTask_Attack</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/941/719/3aa941719ecafd6e1ed3335bc5249373.jpg"></div><br>  First we need to make the muffin attack.  <em>BP_Muffin</em> contains the <em>IsAttacking</em> variable.  If it is set, the muffin will execute the attack.  To do this, add the selected nodes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/db3/8fb/631db38fb830b9eed09882844da72909.jpg"></div><br>  If you use the task in its current state, the execution will stop at it, because the behavior tree does not know whether the task has completed.  To fix this, add a <em>Finish Execute</em> to the end of the chain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/93e/852/a2f93e852d5c43680fa1fe78e5157262.jpg"></div><br>  Then turn on <em>Success</em> .  We use <em>Sequence</em> , so this will allow the nodes to execute after <em>BTTask_Attack</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/a9d/ecc/065a9decc5b625adf492d1a53e980015.jpg"></div><br>  Here is how the graph should look like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/12b/f31/46812bf31988d7b5b43819bd7e2f09c3.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>Event Receive Execute AI</em> is executed when the behavior tree starts <em>BTTask_Attack</em> </li><li>  <em>Cast To BP_Muffin</em> checks if <em>Controlled Pawn is of</em> type <em>BP_Muffin.</em> </li><li>  If yes, then its variable <em>IsAttacking is set</em> </li><li>  <em>Finish Execute</em> makes the behavior tree understand that the task was completed <em>successfully</em> . </li></ol><br>  Click on <em>Compile</em> and close <em>BTTask_Attack</em> . <br><br>  Now we need to add <em>BTTask_Attack to the</em> behavior <em>tree</em> . <br><br><h3>  Adding an attack to the behavior tree </h3><br>  Open <em>BT_Muffin</em> .  Then add the <em>BTTask_Attack</em> node to the end of the <em>Sequence</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/752/946/1fd/7529461fdc35ec799b613188872e59ee.jpg"></div><br>  Next, add a <em>Wait</em> node to the end of the <em>Sequence</em> .  Change the value of its <em>Wait Time</em> variable to <em>2</em> .  Because of this, the muffin will not attack constantly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca4/a04/7d4/ca4a047d480dea1d303b049f15fe2fcf.jpg"></div><br>  Return to the main editor and click on <em>Play</em> .  Like last time, create two muffins.  The muffin will begin to move and turn towards the enemy.  Then he attacks and waits two seconds.  If he sees another enemy, he will repeat the same sequence again. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/85c/d73/0af85cd738cd4cb63408a59b5d8a4b8b.gif"></div><br>  In the last part, we will combine the subtrees of attack and random movement. <br><br><h2>  Subtree association </h2><br>  To combine subtrees, you can use the <em>Selector</em> composite.  Like the Sequence, it also runs from left to right.  However, the Selector stops when the child node <em>succeeds</em> , and does not fail.  With this behavior, we can make the behavior tree execute only one subtree. <br><br>  Open <em>BT_Muffin</em> and create a <em>Selector</em> after the <em>Root</em> node.  Then connect the subtrees as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/701/c20/0c4701c20b806cd7eefb1db4c02dff39.jpg"></div><br>  In this scheme, only one subtree will be executed at a time.  Here is how each subtree runs: <br><br><ul><li>  <em>Attack: The</em> <em>selector</em> will launch the first subtree of the attack.  If all tasks are completed successfully, the <em>Sequence</em> will also complete successfully.  <em>The selector will</em> detect this and stop execution.  Due to this, the subtree of random movement will not be executed. </li><li>  <em>Roam: The</em> selector will first attempt to execute an attack subtree.  If <em>Enemy is</em> not set, then <em>MoveTo</em> will fail.  Therefore, the <em>Sequence</em> will also fail.  Since the subtree of the attack failed, the <em>Selector</em> will execute the next child, that is, the subtree of the random move. </li></ul><br>  Return to the main editor and click on <em>Play</em> .  Create some muffins to test the job. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/cdc/6e0/43acdc6e04e19761052c00f2c1796487.gif"></div><br>  Wait, but why doesn't the muffin immediately attack another muffin? <br><br>  In traditional behavior trees, execution begins with each update from the root.  This means that with each update, the tree first tries to execute the subtree of attack, and then the subtree of random motion.  This means that the behavior tree can instantly change subtrees when the <em>Enemy</em> value changes. <br><br>  However, the Unreal behavior trees work differently.  In Unreal, execution continues from the last node executed.  Since AI Perception does not immediately sense other actors, the subtree of random motion begins to run.  Now the behavior tree must wait for the random movement tree to complete, and only then check the ability to execute the subtree of the attack. <br><br>  To fix this, we can use the last node type: <em>decorators</em> . <br><br><h2>  Creating a decorator </h2><br>  Like services, decorators are attached to tasks or composites.  Typically, decorators are used to perform checks.  If the result is true, then the decorator also returns true, and vice versa.  Thanks to decorators, we can manage the execution of their parent elements. <br><br>  In addition, decorators have the ability to <em>terminate a</em> subtree.  This means that you can complete the execution of the random tree subtree if <em>Enemy is</em> specified.  Thus, the muffin will be able to attack the enemy immediately after its detection. <br><br>  To use termination execution, we can use the <em>Blackboard</em> decorator.  It simply checks if the blackboard key is set.  Open <em>BT_Muffin</em> and <em>right-click</em> on the <em>Sequence of the</em> attack subtree.  Select <em>Add Decorator \ Blackboard</em> .  At the same time, the Blackboard decorator is added to the Sequence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/96f/faa/a7496ffaa7564438bd4dce7433b4b9db.jpg"></div><br>  Now select the <em>Blackboard</em> decorator and go to the Details panel.  Set the <em>Blackboard Key</em> to <em>Enemy</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/d63/8f0/bc2d638f047dcdd27dd324ae2a15c7d7.jpg"></div><br>  So we will check if <em>Enemy is set</em> .  If it is not specified, the decorator will fail and result in a failed <em>Sequence</em> .  This will allow random subtree to run. <br><br>  To stop executing a random motion subtree, we will need to use the <em>Observer Aborts</em> parameter. <br><br><h3>  Using Observer Aborts </h3><br>  Observer aborts stops running the subtree when the selected blackboard key is changed.  There are two types of termination: <br><br><ol><li>  <em>Self:</em> This parameter allows the attack subtree to stop its own execution when <em>Enemy</em> becomes invalid.  This can happen when <em>Enemy</em> dies before completing the attack subtree. </li><li>  <em>Lower Priority:</em> This parameter allows you to stop the execution of trees with a lower priority when setting <em>Enemy</em> .  Since the subtree of random motion is located after the attack, it has a lower priority. </li></ol><br>  Choose <em>Observer Aborts for</em> <em>Both</em> to enable both types of termination. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/68d/368/79568d36801075fca0a2d8c46a0e650b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the subtree of attack will immediately proceed to random movement in the absence of the enemy. </font><font style="vertical-align: inherit;">And the subtree of random movement will immediately switch to attack mode when an enemy is detected. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is what the finished behavior tree looks like:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/597/510/6f3597510e114b09862a516686123acd.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To summarize the attack subtree: </font></font><br><br><ol><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selector</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starts an attack subtree if set to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enemy</font></font></em> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If it is set, then Pawn will move and turn towards the enemy. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then he will execute the attack </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, Pawn will wait two minutes. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sum up the random motion subtree: </font></font><br><br><ol><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The selector</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starts a random subtree if the attack subtree fails. </font><font style="vertical-align: inherit;">In our case, it fails if </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enemy</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is not specified </font><font style="vertical-align: inherit;">.</font></font></li><li> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BTService_SetRandomLocation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generates a random point</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pawn moves to the generated point. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then he waits five seconds </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Close </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BT_Muffin</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and click on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Play</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Create some muffins and get ready for the greatest "Royal Battle"!</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/008/017/289008017798436cfa8fc22f06d645e5.gif"></div></div></div><br><h2>  Where to go next? </h2><br>  The finished project can be downloaded <a href="">from here</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, a simple AI character is very easy to create. </font><font style="vertical-align: inherit;">If you want to create more sophisticated AI, then study the </font></font><a href="https://docs.unrealengine.com/latest/INT/Engine/AI/EnvironmentQuerySystem/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Environment Query System</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This system allows the AI ‚Äã‚Äãto collect and respond to environmental data.</font></font></div><p>Source: <a href="https://habr.com/ru/post/346498/">https://habr.com/ru/post/346498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346488/index.html">21 tips to make better use of Composer</a></li>
<li><a href="../346490/index.html">What to look at the weekend? Review of the best reports in the public domain. Part Two, JBreak 2017</a></li>
<li><a href="../346492/index.html">A story about how I live via meltdown on your phones using npm</a></li>
<li><a href="../346494/index.html">Expectations and reality - our experience in creating and promoting mobile games</a></li>
<li><a href="../346496/index.html">A new ‚Äúpassword‚Äù vulnerability has been discovered on Mac OS High Sierra.</a></li>
<li><a href="../346500/index.html">JavaScript features that I didn't know existed</a></li>
<li><a href="../346502/index.html">What hung the system: a bug or flare at the sun?</a></li>
<li><a href="../346504/index.html">AB-DOC beta testing</a></li>
<li><a href="../346506/index.html">How I searched for dependencies through include files in java</a></li>
<li><a href="../346508/index.html">Perhaps the most unusual puzzle on Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>