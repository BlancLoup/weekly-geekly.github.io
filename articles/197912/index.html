<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Battlefield - Hypervisor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the tasks of the in-person tour of the hacker competition NeoQUEST-2013, the quest participants were confronted by a formidable opponent - t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Battlefield - Hypervisor</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/17c/77d/bb6/17c77dbb6a55474c518e14259c9e87a5.jpg" alt="image">  In one of the tasks of the in-person tour of the hacker competition NeoQUEST-2013, the quest participants were confronted by a formidable opponent - the hypervisor!  To escape from prison, they needed only to read a line from the memory of the process.  But there were a few BUT ... The hypervisor in every possible way complicated the lives of our contestants, namely: <br>  ‚Ä¢ did not allow just to read the process memory, controlling the address space <br>  ‚Ä¢ served as an anti-debugger <br>  ‚Ä¢ checked the integrity of the process image by computing the hash of its section <br>  ‚Ä¢ linked the program to a computer, etc. <br><br>  Participants had to smash their heads to find a non-trivial solution to bypass the hypervisor!  Imagine yourself in their place and fight the hypervisor, step by step, stuffing "bumps", continually going back a step, and in the end, we will achieve victory and get the key!  Below the cut is a detailed look at how the hypervisor controlled access to the key, and what methods the participants attempted to bypass. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  How it all began </h4><br>  Participants in the NeoQUEST 2013 full-time tour - the winners of the February <a href="http://habrahabr.ru/company/neobit/blog/170679/">online tour of NeoQUEST</a> - had a powerful incentive to win.  They had to get out of the cold and damp walls of the prison in order to avoid being executed on a plausible electric chair!  The prison, of course, was virtual, but the chair was real! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/92d/bf0/46592dbf0396f417eb786d9fc339db70.jpg"><br><br>  The contestants were given 8 hours to ‚Äúescape‚Äù, and, hoping that it would take about 2 hours to complete each task, we prepared 5 tasks (one spare!), But it turned out, as we thought, no one task passed that four tasks turned out to be enough). <br>  The NeoQUEST-2013 tasks concerned the security of both common areas of information security - cryptography, cloud and web technologies, botnets, and much more, and the security of non-standard devices and technologies (hypervisors, smart cards, etc.), which required even programming "Bare" iron, in particular, the controller Arduino SDK.  The <a href="http://nightsite.info/blog/10960-neoquest-2013-final.html">winner of the quest</a> , AVictor, just recently returned from Amsterdam from <a href="http://www.rsaconference.com/events/eu13">the RSA conference</a> , <a href="http://nightsite.info/blog/10960-neoquest-2013-final.html">wrote a</a> little about each of the tasks, and the trip was the main prize of the NeoQUEST-2013 full-time tour!  The second place went to <a href="https://habrahabr.ru/users/v0s/" class="user_link">v0s</a> (Vlad Roskov), who received the <a href="http://habrahabr.ru/post/170721/">Cat</a> C15 protected smartphone <a href="http://habrahabr.ru/post/170721/">Caterpillar</a> as an award. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9eb/b19/eeb/9ebb19eeb90c39a42ba34688a4cb9e51.jpg" alt="image"><br><br><h4>  And now about the hypervisor! </h4><br>  Only <a href="https://habrahabr.ru/users/v0s/" class="user_link">v0s</a> managed to bypass the hypervisor.  The task was formulated as follows: two identical Windows computers are available, on which the executable KeyReader.exe is present.  At the entrance, he gets a member ID, and then displays <b>‚ÄúKey successfully readed.</b>  <b>Press any key for exit. ‚Äù</b> And hangs, completing its work by pressing the key.  By default, members work under an account with administrator rights.  Required to get the key. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b2/b51/766/3b2b51766b244733588bc9d98832a69e.jpg"><br><br>  When running on any other machines besides these two, KeyReader.exe reports an error: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ff/d6d/964/0ffd6d964189aeb7879d0b49c734a003.jpg"><br><br>  Imagine yourself in the place of participants and try to get to the bottom of the truth!  Judging by the message, the key is in the memory of the process, and we need to read it from there.  It sounds easy, try it.  Run the Windows Task Manager, find the KeyReader.exe process, dump it while waiting for a keystroke, and feed the dump to the Russinovich <a href="http://technet.microsoft.com/en-us/sysinternals/bb897439.aspx">strings</a> utility.  The dump weighs 3.3 MB, and the utility finds 55,000 lines.  It is not very obvious how to search for a key among them, but if you search for the word key, the following line will be found: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89e/d06/cca/89ed06cca93a37f3b7a58a5938465aef.jpg"><br><br>  It seems that this is not what is needed.  It is not yet clear what exactly happened, and why the dump contains this line, but this is clearly not a password.  Let's try to figure out how KeyReader.exe works with IDA, and already with a great understanding of what is happening, perform the task.  The program is easily decompiled, and in general terms its meaning becomes clear.  The main logic is presented below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5af/270/51b/5af27051bbcb6861f00321837d0d4a9c.jpg"><br><br>  The memory page aligned to the page is <b>highlighted</b> , reset, then the participant's Id is read and the <b>AcquireKey</b> function is <b>called</b> .  The <b>AcquireKey</b> function <b>is</b> small, and it contains the following code, which used to be an assembler insert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3b/e44/8e4/a3be448e42928507a513785aa26f6d3d.jpg"><br><br>  In the code there is a vmcall instruction that performs a call to the hypervisor with the parameters passed through the registers.  The EAX register contains the 'NeoQ' value, the EDX register is the 'strt' value, the EBX register is a pointer to the previously allocated memory page, the ECX register is the page size, the EDI register is the participant id.  The result of the call is returned through the ESI register.  For simplicity, we can assume that the vmcall instruction transfers control to the hypervisor if the hypervisor is present or calls #UD if it is not present. <br><br>  A full description of the operation algorithm can be found in the document <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2b-manual.html">64-ia-32-architectures-software-developer-vol-2b-manual</a> from Intel.  Now it is clear that the key is stored in the hypervisor and is copied into the program memory when accessing it via the vmcall instruction with certain parameters. <br><br>  Let's try to debug the program in steps and see what will be in memory after accessing the hypervisor.  We will use OllyDbg 2.01 as a debugger.  We start KeyReader.exe under debugging, we set breakpoint on the following instruction after vmcall.  Enter the participant's id, press Enter, and get into the set breakpoint.  The EBX register contains the address 0x1F5000, but zeros are located on it.  In ESI, too, 0. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c0/9ca/571/1c09ca571d62178f9d2e996e0cbfaa06.jpg"><br><br>  Press F9 and see that an error has occurred. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/434/ded/94c/434ded94cb1729abf47ae252295f6402.jpg"><br><br>  There are three debugging mechanisms: <br>  ‚Ä¢ code tooling instructions int3 <br>  ‚Ä¢ step-by-step debugging with interrupt int1 after each instruction <br>  ‚Ä¢ debug registers D0-D7, which allow you to catch calls to memory <br>  In our case, when setting breakpoint on the instruction, we rewrote the first byte of the instruction to 0xcc (int 0x3).  When the program reaches this place, int3 is executed, control passes to the debugger, it restores the rubbed byte, executes the restored instruction, and writes int3 again over the instruction.  Thus, breakpoints change the executable image, and the hypervisor, apparently, checks its integrity before copying the key into the program's memory.  Also hinted at this error message. <br><br>  This problem is easily solved in the following way.  Set a breakpoint for a few instructions before vmcall, after hitting the breakpoint, remove it and execute the code step by step.  Having executed Vmcall, we will receive: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f08/a0b/545/f08a0b54541b9df242890f1d39e6fe72.jpg"><br><br>  In the EBX register, the address is 0x165000, where the familiar string <b>‚Äúkey: NICE TRY, THIS IS NOT A KEY‚Äù is located</b> .  The hypervisor still does not read the key. <br><br>  You can write a small driver that would use the KeStackAttachProcess and KeUnstackDetachProcess functions to read the process memory, but let's say right away that this would not work either.  You can go the thorny path and force Windows to unload the memory of the process of interest to us on the disk, in order to then parse pagefile.sys and find the page corresponding to the buffer with the key.  But on this page we would see all the same line. <br><br>  Let's try the following method - inject our dll into the KeyReader process, and from it read the memory in which the key is located.  To begin with we will start process, we will attach to it by means of Olly Dbg and we will look at the address on which the buffer with a key is located.  The pointer to the buffer is located at 0x40eb3c. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/596/d42/f83/596d42f836eeaea493f0405fd5ef8fb6.jpg"><br><br>  In our case, the memory for the buffer was allocated at 0x600000, deattachy debugger, the application continues to work.  We write a dll that will read the memory at this address and save it to disk in the file a.txt.  The code will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/667/f75/5a5667f759dca20542d0a3e5701f9b0b.jpg"><br><br>  As an injector, we used <a href="">an example</a> from the book Windows via C / C ++.  Inject dll and get the output file a.txt, containing the following line: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/07b/c0d/e3007bc0ded224e7902fc7f32e03fe85.jpg"><br><br>  This is the key. <br><br>  Any variation on the subject of code injection would not be in the KeyReader process image would be the solution.  For example, one of the participants in the debugger corrected the code of the ReadConsoleInputA function in kernel32.dll, which is called by the getch function, and read a line from it at a known address.  As you can see, the task is not the most difficult, but only one person ended up with it.  Most likely, this was due to a lack of time, and the task itself is such that it almost does not imply a logical chain that would lead to an answer.  Participants had to go through all the ways they knew to read the memory of someone else's process in order to stumble upon a working option at some point. <br><br>  In general, it was even more interesting to prepare this task than to go through it :).  To control access to the page, it was necessary to control changes in all related translation tables from the virtual to the physical address.  Given the variety of maping options and the fact that the address of the physical page to which we control access may change, this is not so trivial. <br><br>  By what principle did the hypervisor in one case give access to the key, but not in the other?  When accessing a page with a key, he checked 3 conditions: <br>  ‚Ä¢ Reading must be from user mode <br>  ‚Ä¢ The hash of that section of the .text image of the process from which the key is being accessed must be strictly defined <br>  ‚Ä¢ Reading a key is possible only from the address space in which the vmcall call occurred to receive the key. <br><br>  The first condition discarded all attempts to read the key from the kernel.  These include the ReadProcessMemory function and writing your own driver.  The second condition did not allow changing the image code and setting break points.  By the way, only the text section was checked, so that you could add your own section with a code that would have been called differently and change the entry point to it.  Then call the key retrieval function from your code and save it to disk.  The third condition did not allow other processes, in which the memory of the KeyReader process was mapped, to read the key.  This condition is somewhat contrived, since in order to obtain such a situation, you will have to write your own driver and your application that would communicate with it, since we did not find ready-made utilities with such functionality on Windows7.  Under Windows XP, the WinHex RAM Editor worked in a similar way when reading physical memory.  The main purpose of the conditions was the inability to perform the task using only ready-made utilities, and without writing a single line of code. <br><br><h4>  In conclusion... </h4><br>  While preparing the task with the hypervisor, we wanted to make the participants wonder at the unusual nature of the task.  After all, it would seem, what problems can there be with reading a line from the process memory?  And judging by the fact that only one participant completed the task, we succeeded!  We hope that Habr's readers were interested!  Soon, expect articles with a detailed analysis of the most "iron" job NeoQUEST-2013! </div><p>Source: <a href="https://habr.com/ru/post/197912/">https://habr.com/ru/post/197912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197902/index.html">Startup Game at Java Seminars</a></li>
<li><a href="../197904/index.html">A magic keyword - VALUES ...</a></li>
<li><a href="../197906/index.html">Cisco wireless controller device and root access</a></li>
<li><a href="../197908/index.html">Fortuna: paranoid random number generator</a></li>
<li><a href="../197910/index.html">Application rejects in AppStore</a></li>
<li><a href="../197914/index.html">Configuring I2P Out Proxy</a></li>
<li><a href="../197918/index.html">RevealApp - Firebug for iOS applications</a></li>
<li><a href="../197920/index.html">What is the Entity System Framework and why is it needed in game devs?</a></li>
<li><a href="../197924/index.html">October 21-22, we invite you to Tizen Hackathon in Yaroslavl</a></li>
<li><a href="../197926/index.html">Java vs go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>