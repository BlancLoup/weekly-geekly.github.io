<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell: about one method of implementing functions with a variable number of parameters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Have you seen the Turtle "How would"? 
 ‚ÄúNo,‚Äù said Alice. - I don't even know who that is. 
 ‚ÄúOf course,‚Äù said the Queen. - This is what ‚ÄúTurtle Sou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell: about one method of implementing functions with a variable number of parameters</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/b0e/1f9/cd0/b0e1f9cd0fac4e4d828e3920c5a892a9.png"></div><br>  <i>- Have you seen the Turtle "How would"?</i> <i><br></i>  <i>‚ÄúNo,‚Äù said Alice.</i>  <i>- I don't even know who that is.</i> <i><br></i>  <i>‚ÄúOf course,‚Äù said the Queen.</i>  <i>- This is what ‚ÄúTurtle Soup‚Äù is made of.</i> <i><br></i> <br><pre>  Lewis Carroll, 
                            "Alice in Wonderland" </pre><br>  <i>- Judging by your speeches, do you know Fangorn well?</i>  <i>- Aragorn asked in response.</i> <i><br></i>  <i>- What is there!</i>  <i>- responded the old man.</i>  <i>- A hundred lives are not enough for this.</i>  <i>But I sometimes come back here.</i> <i><br></i> <br><pre>  John R. R. Tolkien, 
                           "Lord of the Rings" - to the word of my knowledge of Haskell;) </pre><br><br>  <i>Homines dum docent, discunt.</i>  <i>(Explain to others - you will understand.)</i> <br><pre>  popular Latin saying </pre><br><br>  Everyone knows that any Haskell function is inherently a function of a single parameter.  The ‚Äúas if‚Äù functions of several parameters simply taking the first argument, return another function that takes the second argument (of the original function) and returns the return function, etc.  before the final function, which already returns a value of a non-functional type ( <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">currying</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It would seem what variable number of parameters can we talk about in this situation?  However, on reflection, looking at the source of <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Text.Printf.html">printf</a> or simply reading <a href="https://wiki.haskell.org/Varargs">wiki.haskell</a> it becomes obvious that just the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">OP</a> provides the key to a rather beautiful, although somewhat "casuistic" solution of this problem. <br><br>  In this publication, I will look at one of the ways to implement such a mechanism using simple examples, and also offer some generalized solution based on <a href="https://wiki.haskell.org/Template_Haskell">Template Haskell</a> to turn a family of ordinary functions with the last parameter of the list type into a function with ‚Äúas if with a variable number of parameter‚Äù (further the text is simply ‚Äúwith a variable number of parameters‚Äù). <br><a name="habracut"></a><br>  I will briefly describe the essence of the solution, starting with an extremely simple example. <br><br><pre><code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE FlexibleInstances, RankNTypes #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- (0) class VarArgs a where prc :: String -&gt; a -- (1) instance VarArgs String where prc = id -- (2) instance (Show a, VarArgs r) =&gt; VarArgs (a -&gt; r) where -- (3) prc acc = \x -&gt; prc $ acc ++ " " ++ show x magic = prc [] useMagic :: (forall a. VarArgs a =&gt; a) -&gt; IO () -- (4) useMagic f = do putStrLn $ f 1 putStrLn $ f 1 "qwe" putStrLn $ f 1 "qwe" [1, 2, 3] main :: IO () main = do putStrLn $ magic 1 2 "qwe" [1,2,3] 123.456 useMagic magic -- (5)</span></span></code> </pre> <br>  What happens here and how is it possible to transfer the magic functions not only to an arbitrary number of parameters, but also to parameters of different types? <br><br>  So in (1) we declare the class <i>VarArgs</i> with the only method <i>prc</i> simply able to create a value of a given type from a string.  Further, in (2) we implement an instance of this class for the type String (also known as [Char]).  Please note that you had to use the FlexibleInstances (0) extension - otherwise this instance will be ‚Äúout of the law‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">There is an alternative solution, but it also uses the TypeFamilies extension or GADTs.</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TypeFamilies #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> a ~ <span class="hljs-type"><span class="hljs-type">Char</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">VarArgs</span></span> [a] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prc = id</code> </pre><br></div></div><br>  The <i>VarArgs String</i> instance is actually the ‚Äúbody‚Äù of a function with a variable number of parameters.  In the example, we simply return the accumulated parameters.  We now turn to the most interesting, in (3) we declare a <i>VarArgs</i> instance for the functional type <i>(a -&gt; r)</i> , while requiring that the type of the argument <i>a be</i> able to be displayed on the string, and the type of the result <i>r would</i> again belong to the class <i>VarArgs</i> . <br><br>  This is where ‚Äúthe dog rummaged‚Äù - by instantiating a class with a functional type with a return type that also allows (in particular) a function, we allow the <i>prc</i> method, depending on the call context, to return both the final value of the <i>String</i> type if the context requires a string, and The result type of the <i>prc</i> call is derived from the context as functional. <br><br>  Now consider the definition of <i>prc</i> for an instance of <i>VarArgs (a -&gt; r)</i> .  If we print the type <i>prc</i> , we get <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prc</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">VarArgs</span></span> r) =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; (a -&gt; r)</code> </pre><br>  Those.  we have to return a function that does something with a value representable as a string.  The <i>acc</i> argument is the essence of the ‚Äúaccumulator‚Äù of the result of the sequential processing of parameters.  In this case, we simply add to it a string representation of the parameter separated by a space. <br><br>  The important point is that we do not just return the incremental ‚Äúaccumulator‚Äù, but call (in the ‚Äúbody‚Äù of the resulting function) recursively <i>prc</i> to get the desired type of result <i>r</i> .  What kind of <i>prc</i> implementation will be called (i.e., what type will be output) depends on the context (do not forget that the Haskell functions are equations, and the calculation process is the successive substitution of expressions with the actualization of parameters). <br><br>  The most interesting thing is that despite the ‚Äúsemi-legal‚Äù status, we can quite transfer (4) and use (5) a function with a variable number of parameters as an argument to another function.  True, for this we had to use another extension, <i>RankNTypes</i> (0) and the <i>forall</i> quantifier in the definition of the calling function (4). <br><br>  It sounds a bit confusing, so let's take a look at how the expression to the right of <i>$</i> in (4) is calculated: <br><br><ol><li>  magic (also <i>prc []</i> ) is called with parameter <i>1</i> i.e.  used in a functional context, so the instance is running <br>  <i>VarArgs (a -&gt; r)</i> , eventually returns ... </li><li>  ... again function  we again have argument <i>2</i> i.  functional context present again </li><li>  <i>qwe</i> and <i>[1,2,3] are</i> processed in the same way </li><li>  finally, the result of the last call of the <i>prc</i> function with accumulated string representations of the previous parameters and the current parameter <i>123.456</i> will already require a string context, like the parameter of the <i>putStrLn</i> function ‚Äî the <i>prc</i> is started from the <i>VarArgs String</i> instance </li></ol><br><a name="RPN"></a>  Now let's look at another, slightly more complicated example: the calculator of expressions in <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">reverse Polish notation</a> .  Something like: <br><br><pre> <code class="haskell hljs">&gt; calcRPN <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> (*) <span class="hljs-number"><span class="hljs-number">2</span></span> (+) <span class="hljs-comment"><span class="hljs-comment">-- 5*8 + 2 42</span></span></code> </pre><br>  The most primitive implementation might look something like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE ExtendedDefaultRules, FlexibleInstances, GADTs #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Op</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">) calcRPN' :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class">] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> calcRPN' = head . foldr rpnStep [] . reverse rpnStep :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> -&gt; [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">] -&gt; [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">] rpnStep (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) stack = n : stack rpnStep (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Op</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">) = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fxy</span></span></span><span class="hljs-class">) : stack class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgPrc</span></span></span><span class="hljs-class"> a where prc :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class">] -&gt; a class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgSrc</span></span></span><span class="hljs-class"> a where toArg :: a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgPrc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> where prc = calcRPN' . reverse instance (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgSrc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgPrc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgPrc</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) where prc acc = prc . (: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">) . toArg </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- (2) instance ArgSrc Expr where toArg = id instance a ~ Double =&gt; ArgSrc (a -&gt; a -&gt; a) where toArg = Op instance ArgSrc Integer where toArg = Num . fromIntegral instance ArgSrc String where toArg = Num . fst . head . (reads :: ReadS Double) instance ArgSrc [Double] where toArg = Num . sum calcRPN :: ArgPrc a =&gt; a calcRPN = prc [] main = do print $ calcRPN' [Num 5, Num 5, Op (*)] print $ calcRPN [1::Double,2,3] "5" (*) 7 (*)</span></span></span></span></code> </pre><br>  The scheme for implementing a variable number of parameters is the same as in the previous example, only now we will be: <br><br><ul><li>  accumulate arguments (of type <i>Expr</i> ) in the list for further processing instead of immediately building the result (2); </li><li>  use the ‚Äúwrapper‚Äù class <i>ArgSrc</i> for type declarations that can act as ‚Äúexpressions‚Äù ( <i>Expr</i> ) </li><li>  use some "trick" (extension GADTs) to implement an instance <br>  <i>instance a ~ Double =&gt; ArgSrc (a -&gt; a -&gt; a)</i> <br></li></ul><br><a name="printf"></a>  Finally, let's look at a schematic implementation of the printf function: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GADTs, FlexibleInstances, ExtendedDefaultRules #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FmtRes</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PfVal</span></span></span><span class="hljs-class"> a where doFmt :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FmtRes</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PfVal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> where doFmt (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">) x = let (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) = span (/= '%') fmt in (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class"> ++ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">), b ++ show x) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PfVal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> where doFmt (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">) x = let (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) = span (/= '%') fmt in (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class"> ++ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">), b ++ x) class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> a where prc :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FmtRes</span></span></span><span class="hljs-class"> -&gt; a instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> where prc = uncurry (++) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> ()) where prc = putStrLn . uncurry (++) instance (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PfVal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) where prc st = prc . doFmt st printf fmt = prc (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">, "") main :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">() main = do putStrLn $ printf "%d %s" 1 "qwe" printf "%s %d" "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">This</span></span></span><span class="hljs-class"> is" 123</span></span></code> </pre><br>  I suppose the code does not need any special comments, I‚Äôll just note that now we are again generating the result on the fly, instead of accumulating parameters and implementing <i>two</i> terminal instances of the <i>ArgProc</i> class: for the <i>String</i> type and for the <i>IO () type</i> . <br><br>  If we generalize the illustrated scheme, we can distinguish the following elements: <br><br><ol><li>  Some type is a battery (let's call it <i>A</i> ) a preliminary result of calculations based on parameters of type <i>a</i> .  The degree of ‚Äúpreliminary‚Äù can vary from a simple accumulation of parameters in some kind of list-type container (as in the example with <a href="https://habr.com/ru/post/324190/">reverse Polish notation</a> ) to an almost finished result for the current parameter set (as in the example with <a href="https://habr.com/ru/post/324190/">printf</a> ).  All we need from this type is the presence of an operation like <br><br><pre> <code class="haskell hljs"> <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br></li><li>  The main class (let's call it <i>ArgProc</i> ), through the instances of which the whole ‚Äúmechanics‚Äù of a variable number of parameters is implemented.  This class has a single method (let's call it <i>prc</i> ) that does something with battery <i>A</i> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> prc :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; a</code> </pre><br></li><li>  A class of types that can act as parameters (let's call <i>ArgSrc</i> ) supporting the function of converting values ‚Äã‚Äãinto a type of parameters (some type a admitting an operation <i>:: A -&gt; a -&gt; A</i> ) <br><br></li><li>  An instance of the main class that is responsible for processing parameters and accumulating a preliminary result: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgSrc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> prc :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; (a -&gt; r)</code> </pre><br>  In the example with <a href="https://habr.com/ru/post/324190/">printf</a> , the result is immediately accumulated (the second element of the pair) and the state (format string) is processed simultaneously.  In the example with <a href="https://habr.com/ru/post/324190/">reverse Polish notation, the</a> parameters are simply added to the list for further processing. <br><br></li><li>  Terminal instance (s) of the main class, responsible for the final processing of the preliminary result: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgProc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> prc :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">R1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">ArgProc</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prc :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">R2</span></span> ...</code> </pre><br>  In the example with the <a href="https://habr.com/ru/post/324190/">reverse Polish notation,</a> there is only one such instance for the resulting type Double - it simply starts the calculation for the list of previously accumulated parameters.  In the example with <a href="https://habr.com/ru/post/324190/">printf, an</a> instance for String simply concatenates a formatted string with the remainder of the format (meaning that flat text is left there).  The instance for IO () additionally displays the result. <br><br></li><li>  The initializer of the initial state of the preliminary result of the calculation A. In general, it is a function of a set of fixed parameters, in the examples it is the constant value <i>[]</i> and the function <br><br><pre> <code class="haskell hljs"> \x -&gt; (x, <span class="hljs-string"><span class="hljs-string">""</span></span>) :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>)</code> </pre> </li></ol><br>  It is easy to see that such a scheme can be implemented by means of "black magic" <a href="https://wiki.haskell.org/Template_Haskell">Template Haskell</a> .  This is a good exercise to consolidate the material, as well as a good platform for <s>dancing with a tambourine</s> experiments with <a href="https://wiki.haskell.org/Template_Haskell">Template Haskell</a> . <br><br>  In the current implementation, I limited myself to a subset of the general scheme: a drive is simply a list of values ‚Äã‚Äãof a certain type, the initializer, respectively, is simply <i>[]</i> .  Such restrictions certainly have certain disadvantages, but the idea is to transform a family of ordinary functions with an identical type of parameters, the last of which is a list, and various types of return, into a function that accepts a variable number of parameters (in addition to fixed ones that go to the list) . <br><br>  Along the way, we automate the process of ‚Äúimplicit reduction‚Äù (in the terminology of other PLs) of specified types to the type of elements of the parameter list.  Another restriction - ‚Äúdonor‚Äù functions must have ‚Äúsimple‚Äù types (non-polymorphic types without quantifiers and restrictions). <br><br>  I will immediately begin again with examples of use, the idea will be clear, and only then I will briefly go through the implementation.  So let's start with something simple: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TemplateHaskell, FlexibleInstances, ExtendedDefaultRules #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Function.Vargs <span class="hljs-comment"><span class="hljs-comment">-- (1) -- (2) tester' q (x : y : z) = putStrLn $ "Fixed parameter " ++ q ++ ", next x = " ++ x ++ " and y = " ++ y ++ " and rest = " ++ show z $( return [] ) -- (3) -- (4) defVargsFun "tester" ['tester'] (''Integer, [| ("Int " ++) . show |]) -- (5) (''(), [| const "NULL" |]) -- (6) ([t| [Int] |], [| ("[Int] " ++) . show |]) -- (7) ([t| [Double] |], [| ("[Double] " ++) . show |]) -- (8) main :: IO () main = do tester "&lt;const&gt;" "qwe" 100500 () [1::Int,2,3] [4::Double,5,6] -- (9)</span></span></code> </pre><br>  In this example, we create a <i>tester</i> wrapper function for the <i>tester '</i> function, which has the type: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tester'</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">String</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br>  Let's go through the text: <br><br><ul><li>  (1) - we connect the module that implements a variable number of parameters </li><li>  (2) - we define the "experimental" function for the transformation </li><li>  (3) - a trick, for guaranteed <a href="http://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/Language-Haskell-TH-Syntax.html">reify</a> work (for details, for example, <a href="https://ghc.haskell.org/trac/ghc/ticket/9813">here</a> ) </li><li>  (4) - we define a function with a variable number of parameters <br>  Parameters starting from the 3rd - values ‚Äã‚Äãof one of the types: <br><br><ul><li>  <i>(Name, ExpQ)</i> </li><li>  <i>(TypeQ, ExpQ)</i> </li></ul><br>  they describe how you can convert values ‚Äã‚Äãof a given type (Integer, (), etc.) into values ‚Äã‚Äãof the type of the elements of the parameter list (String).  The type is specified either by the name ((5), (6)) or by the expression ((7), (8)).  Please note that the elements themselves are also passed as variable parameters! <br></li><li>  (9) - the actual function call with a variable number of parameters of different types (reducible to the string) in arbitrary order </li></ul><br>  Go ahead, or rather return to the example <a href="https://habr.com/ru/post/324190/">with the reverse Polish notation</a> : <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TemplateHaskell, FlexibleInstances, ExtendedDefaultRules, GADTs #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- import Data.Function.Vargs data Expr = Num Double | Op (Double -&gt; Double -&gt; Double) calcRPN' :: [Expr] -&gt; Double calcRPN' = head . foldr rpnStep [] . reverse rpnStep :: Expr -&gt; [Double] -&gt; [Double] rpnStep (Num n) stack = n : stack rpnStep (Op f) (x:y:stack) = (fxy) : stack $( return [] ) defVargsFun "calcRPN" ['calcRPN'] (''Integer, [| Num . fromIntegral |]) (''String, [| Num . fst . head . (reads :: ReadS Double) |]) (Genz [t| Double -&gt; Double -&gt; Double |], [| Op |]) -- (1) ([t| [Double] |], [| Num . sum |]) main = do print $ calcRPN' [Num 5, Num 5, Op (*)] print $ calcRPN [1::Double,2,3] "5" (+) 7 (*)</span></span></code> </pre><br>  In this example, everything is similar to the previous one, with the exception of one interesting point (1): here we use not just TypeQ, but some <i>Genz</i> wrapper over it.  This wrapper causes the generator to build an instance of the form: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> a ~ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgSrc</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span></code> </pre><br>  instead of the standard <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgSrc</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span></code> </pre><br>  which in this case will not pass type checking. <br><br>  Well, and the last example, the very function printf, or rather its schematic analog: <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TemplateHaskell, FlexibleInstances, ExtendedDefaultRules, ExistentialQuantification #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Function.Vargs type FmtRes = (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) class PfVal a where doFmt :: FmtRes -&gt; a -&gt; FmtRes instance PfVal Integer where doFmt (<span class="hljs-title"><span class="hljs-title">fmt</span></span>, <span class="hljs-title"><span class="hljs-title">res</span></span>) x = let (<span class="hljs-title"><span class="hljs-title">b</span></span>, <span class="hljs-title"><span class="hljs-title">s</span></span>) = span (/= '%') fmt in (<span class="hljs-title"><span class="hljs-title">res</span></span> ++ (<span class="hljs-title"><span class="hljs-title">tail</span></span> . <span class="hljs-title"><span class="hljs-title">tail</span></span> $ <span class="hljs-title"><span class="hljs-title">s</span></span>), b ++ show x) instance PfVal Double where doFmt (<span class="hljs-title"><span class="hljs-title">fmt</span></span>, <span class="hljs-title"><span class="hljs-title">res</span></span>) x = let (<span class="hljs-title"><span class="hljs-title">b</span></span>, <span class="hljs-title"><span class="hljs-title">s</span></span>) = span (/= '%') fmt in (<span class="hljs-title"><span class="hljs-title">res</span></span> ++ (<span class="hljs-title"><span class="hljs-title">tail</span></span> . <span class="hljs-title"><span class="hljs-title">tail</span></span> $ <span class="hljs-title"><span class="hljs-title">s</span></span>), b ++ show x) instance PfVal String where doFmt (<span class="hljs-title"><span class="hljs-title">fmt</span></span>, <span class="hljs-title"><span class="hljs-title">res</span></span>) x = let (<span class="hljs-title"><span class="hljs-title">b</span></span>, <span class="hljs-title"><span class="hljs-title">s</span></span>) = span (/= '%') fmt in (<span class="hljs-title"><span class="hljs-title">res</span></span> ++ (<span class="hljs-title"><span class="hljs-title">tail</span></span> . <span class="hljs-title"><span class="hljs-title">tail</span></span> $ <span class="hljs-title"><span class="hljs-title">s</span></span>), b ++ x) data PfValWrap = forall a. PfVal a =&gt; Val a <span class="hljs-comment"><span class="hljs-comment">-- (1) printf_String :: String -&gt; [PfValWrap] -&gt; String -- (2) printf_String fmt vs = uncurry (flip (++)) $ foldl step (fmt, "") vs where step fmt (Val f) = doFmt fmt f printf_IO :: String -&gt; [PfValWrap] -&gt; IO () -- (3) printf_IO fmt = putStrLn . printf_String fmt $( return [] ) defVargsFun "printf" ['printf_String, 'printf_IO] -- (4) [''Integer, ''Double, ''String] main :: IO () main = do let fmt = "Number one is %d, number two is %f and string is \"%s\"" printf_IO fmt [Val 100, Val 123.456, Val "ok"] putStrLn $ printf fmt 100 123.456 "ok" printf fmt 100 123.456 "ok"</span></span></code> </pre><br>  There are three new points to note here: <br><br><ul><li>  using a wrapper type (1) for processing values ‚Äã‚Äãof arbitrary types that support a <i>PfVal</i> class <i>contract</i> (able to output themselves to a string according to a specified format) </li><li>  the presence of <i>two</i> parameter handlers (2) - (3) for different types of result ( <i>String</i> and <i>IO ()</i> ) </li><li>  automatic code generation for converting the values ‚Äã‚Äãof the specified types into the <i>PfValWrap</i> wrapper <i>type</i> (in fact, the only constructor of the type, <i>Val,</i> is simply pulled through reflection) </li></ul><br>  Now a few words about how it all works.  Actually, all that <i>defVargsFun</i> does <i>is</i> that it creates several classes and instances, based on the information received from <a href="http://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/Language-Haskell-TH-Syntax.html">reify</a> , as well as the declaration and definition of the function itself with a variable number of parameters.  All this "kitchen" corresponds to the general scheme previously discussed with examples.  Again, it will be clearer and easier to demonstrate with an example what exactly is generated.  Consider the code generated by the call: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">defVargsFun</span></span> <span class="hljs-string"><span class="hljs-string">"printf"</span></span> ['printf_String, 'printf_IO] [''<span class="hljs-type"><span class="hljs-type">Integer</span></span>, ''<span class="hljs-type"><span class="hljs-type">Double</span></span>, ''<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre><br>  This code can be viewed if you run <i>ghc</i> with the <i>-ddump-splices key</i> .  For clarity, I corrected the formatting and removed the extra brackets: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ArgPrc_printf_aa3M</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- (1) prc_printf_aa3O :: String -&gt; [PfValWrap] -&gt; a -- (2) class ArgSrc_printf_aa3N a where -- (3) toArg_printf_aa3Q :: a -&gt; PfValWrap -- (4) instance ArgPrc_printf_aa3M String where -- (5) prc_printf_aa3O a1 = printf_String a1 . reverse instance ArgPrc_printf_aa3M (IO ()) where -- (6) prc_printf_aa3O a1 = printf_IO a1 . reverse -- (7) instance (ArgSrc_printf_aa3N a, ArgPrc_printf_aa3M r) =&gt; ArgPrc_printf_aa3M (a -&gt; r) where prc_printf_aa3O a1 acc_printf_aa3P = prc_printf_aa3O a1 . (: acc_printf_aa3P) . toArg_printf_aa3Q -- (8) instance ArgSrc_printf_aa3N PfValWrap where toArg_printf_aa3Q = id instance ArgSrc_printf_aa3N Integer where toArg_printf_aa3Q = Val instance ArgSrc_printf_aa3N Double where toArg_printf_aa3Q = Val instance ArgSrc_printf_aa3N String where toArg_printf_aa3Q = Val -- (9) printf :: forall a. ArgPrc_printf_aa3M a =&gt; String -&gt; a printf a1 = prc_printf_aa3O a1 []</span></span></code> </pre><br>  The monad Q provides us with the generation of unique names - hence the "intricate" endings in the names.  Let's go through the text: <br><br><ul><li>  the main class handler of a variable number of parameters (1) and its key method (2) are declared </li><li>  class (3) is declared for ‚Äúimplicit reduction‚Äù of values ‚Äã‚Äãof given types to the type of parameter list element ( <i>PfValWrap</i> ) with a single method (4) </li><li>  ‚Äúterminal‚Äù instances of our main class (1) are defined for the types String (5) and IO () (6), the implementation of the methods is the essence of a call to the specified function with the transfer of all fixed parameters and a list of accumulated ‚Äúvariables‚Äù parameters.  Since  if we accumulate parameters from the head of the list, then before calling the native function, the <i>reverse</i> is called </li><li>  the instance (7) of the main class (1) is defined for the functional type <i>(a -&gt; r)</i> - here the value of the types belonging to the specially created class (3) is converted by calling the method (4) to the type of the parameter list elements ( <i>PfValWrap</i> ) , and, further, placing this value in the list </li><li>  below (8), instances of class (3) are determined for all the specified types + an instance for the <i>PfValWrap</i> type <i>itself</i> (such a ‚Äútautology‚Äù is necessary since method (4) is called for conversion) </li><li>  and finally the wrapper function itself is declared and defined with a variable number of parameters. </li></ul><br>  The source code of the Data.Function.Vargs module with comments, as well as the above examples of its use are <a href="https://github.com/wardopdem/vargs">here</a> , the documentation in the <a href="https://www.haskell.org/haddock/">haddoc</a> format is available <a href="https://wardopdem.github.io/vargs/vargs-0.1.0.0/Data-Function-Vargs.html">here</a> and as part of the package.  At the moment the package is in the experimental stage from the word "absolutely";) <br><br>  Perhaps with time I will bring to mind - at a minimum, it is necessary to do the analysis and handling of error situations (invalid or incompatible types), as a maximum: <br><br><ul><li>  implement a generalized scheme and support for polymorphic types in the "parent" functions; </li><li>  allow meaningful naming of the created classes and methods, in particular, to enable the transfer of the wrapper function as a parameter to other functions; </li><li>  It is possible to consider <a href="http://okmij.org/ftp/Haskell/polyvariadic.html">alternative</a> implementation schemes. </li></ul>  Then, I think, it would not be a shame to put it on <a href="http://hackage.haskell.org/">hackage</a> (although there are already decent <a href="http://hackage.haskell.org/package/HList">HList-</a> type <a href="http://hackage.haskell.org/package/HList">packages</a> on similar topics). <br><br>  Useful links on the topic: <br><br><ol><li>  <a href="https://wiki.haskell.org/Varargs">Varargs</a> </li><li>  <a href="https://wiki.haskell.org/Polyvariadic_functions">Polyvariadic functions</a> </li><li>  <a href="https://wiki.haskell.org/Template_Haskell">Template hakell</a> </li><li>  <a href="https://wiki.haskell.org/Existential_type">Existential type</a> </li><li>  <a href="http://hackage.haskell.org/package/HList">Hlist</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/324190/">https://habr.com/ru/post/324190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324178/index.html">Download trusted environment or easy way to paranoia in IT</a></li>
<li><a href="../324180/index.html">Glitch - a new approach to application development</a></li>
<li><a href="../324182/index.html">We solve standard problems for PM on projects. Part 1</a></li>
<li><a href="../324184/index.html">9 interesting services for the web designer. Special selection</a></li>
<li><a href="../324188/index.html">DEV Labs 2017. Online conference for Java and Web developers. March 25</a></li>
<li><a href="../324192/index.html">We adjusted VTL under Centos 7</a></li>
<li><a href="../324194/index.html">Simple, reliable and convenient monitoring of servers on Linux</a></li>
<li><a href="../324196/index.html">A brief history of javascript. Part 1</a></li>
<li><a href="../324200/index.html">MAC addresses are different</a></li>
<li><a href="../324202/index.html">Excursion to the Moscow production of components for communication networks. Part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>