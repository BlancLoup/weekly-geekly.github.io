<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We learn bash-scripts, we write Xonix</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I read a couple of weeks ago on the Habr√© article. Learn to bash-scripts, write Sokoban and thought that I also know bash and can write something, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We learn bash-scripts, we write Xonix</h1><div class="post__text post__text-html js-mediator-article">  I read a couple of weeks ago on the Habr√© article. <a href="http://habrahabr.ru/blogs/linux/120198/">Learn to bash-scripts, write Sokoban</a> and thought that I also know bash and can write something, and at the same time learn even better bash.  I also thought about it and remembered that I had long wanted to write Xonix, once I played on this game on my old 386th.  And so, a few sleepless nights and the script is ready.  If you are interested in how it was written, what problems arose, then welcome to habrakat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad6/a4f/463/ad6a4f4638347221ffd403097694fc90.png"><br><a name="habracut"></a><br>  The rules of the game Xonix can be found in <a href="http://ru.wikipedia.org/wiki/Xonix">Wikipedia</a> .  But since in the implementation I once played, there were no land opponents, they will not be in my implementation. <br><br>  When writing, I used many different features of bash and the environment, I‚Äôll focus on the most interesting ones, in my opinion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Functions </h5><br>  Since it is immediately clear that the script will turn out great, it is reasonable to use functions.  There is nothing difficult about functions in bash.  The function is defined as follows. <br><pre><code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span></span>() { cmd1 cmd2 ... cmdn }</code> </pre> <br><br>  And it is called like this: <br><pre> <code class="bash hljs">func param1 param2 ... paramn</code> </pre> <br>  Parameters in the function body are accessed using <code>$1</code> , <code>$2</code> , ... You can also declare local variables with <code>local</code> .  But there are two features.  The first is that the variables have a dynamic scope, rather than the usual static one, that is, the following code <br><pre> <code class="bash hljs">i=3 <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> i=5 f } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> i=10 f } g h</code> </pre> <br>  will display 5 and 10. <br><br>  Similar javascript code <br><pre> <code class="bash hljs">var i = 3; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { alert(i); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span></span>() { var i = 5; f(); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span></span>() { var i = 10; f(); } g(); h();</code> </pre> <br>  habitually displays two times 3. <br><br>  The second feature is that the function body cannot be empty (as well as any block in bash).  This is resolved with a colon.  So the stub function will look like this: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { : }</code> </pre><br>  Also, when you need to comment out the function body for any reason, instead of <code>#</code> you can simply write <code>:</code> <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { : cmd1 : cmd2 : cmd3 }</code> </pre><br><br><h5>  User interaction </h5><br>  How to display colored characters in the console is well known, it uses the escape sequence <code>"\e[ <i></i> ; <i></i> ; <i></i> m"</code> .  The cursor is positioned using the <code>"\e[ <i></i> ; <i></i> f"</code> escape sequence.  In this case, the count comes from the unit.  Two more escape sequences are convenient: <code>"\e[2K"</code> to clear the entire current line, <code>"\e[2J"</code> to clear the entire screen.  More details can be found in <code>man console_codes</code> . <br><br>  We also need to know the dimensions of the console, they are stored in the variables <code>COLUMNS</code> and <code>LINES</code> .  But they are only available online, so the first line is to write <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash -i</span></span></code> </pre> <br>  Next, you need to suppress the echo output from the user, for this we write <br><pre> <code class="bash hljs">stty -<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  When you need it, we write <br><pre> <code class="bash hljs">stty <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  Since we need to redraw the field at fixed intervals, and still determine which keys the user pressed, the main loop looks like this: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runLevel</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -l key <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -i time=0 <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -i newTime ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> key=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -t <span class="hljs-variable"><span class="hljs-variable">$TIMEOUT</span></span> -n 1 key newTime=$((`date +%s` * 100 + (10<span class="hljs-comment"><span class="hljs-comment">#`date +%N` / 10000000))) case "$key" in $UP_KEY) playerDY=-1 playerDX=0;; $DOWN_KEY) playerDY=1 playerDX=0;; $LEFT_KEY) playerDX=-1 playerDY=0;; $RIGHT_KEY) playerDX=1 playerDY=0;; $EXIT_KEY) break 3;; "") ;; esac if [[ $((newTime - time)) -ge DELAY ]]; then movePlayer moveOpponents time=newTime fi ... done }</span></span></code> </pre><br>  Here the following points are of interest.  The <code>-l</code> attribute of the <code>key</code> variable allows you to forget about the fact that the CAPS LOCK key can be pressed, since the value of the variable will always be in lower case.  And the expression whose value is assigned to newTime calculates the time with an accuracy of millisecond. <br><br><h5>  Arrays </h5><br>  For realization, we obviously need a two-dimensional array to store the field, as well as arrays of structures, to store, for example, the coordinates and directions of movement of opponents.  Unfortunately, in bash, arrays can only be one-dimensional, but that will be enough for us: we just pull out two-dimensional arrays line by line.  We do the same with arrays of structures.  Also, to avoid tedious checks of the array boundaries, we will add boundary elements along the perimeter of the field.  Thus, the field initialization function will look something like this: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initMap</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -ii <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -ij <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 1; i &lt; MAP_HEIGHT - 1; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((j = 1; j &lt; MAP_WIDTH - 1; ++j)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> map[i * MAP_WIDTH + j]=<span class="hljs-variable"><span class="hljs-variable">$SEA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 0; i &lt; MAP_HEIGHT; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> map[i * MAP_WIDTH]=<span class="hljs-variable"><span class="hljs-variable">$LAND</span></span> map[i * MAP_WIDTH + MAP_WIDTH - 1]=<span class="hljs-variable"><span class="hljs-variable">$LAND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((j = 0; j &lt; MAP_WIDTH; ++j)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> map[j]=<span class="hljs-variable"><span class="hljs-variable">$LAND</span></span> map[(MAP_HEIGHT - 1) * MAP_WIDTH + j]=<span class="hljs-variable"><span class="hljs-variable">$LAND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> }</code> </pre> <br>  I note that there are holes in the array.  And also in bash there are associative arrays. <br><br>  To organize a table of records, you must write an array to a file and read an array from a file.  For convenience, we will write each element of the array on a separate line.  Then reading the array with the results from the file will look like this: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeTopScores</span></span></span></span>() { (IFS=$<span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${topScores[*]}</span></span></span><span class="hljs-string">"</span></span> &gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TOP_SCORES_FILE_NAME</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br>  Short explanation: <code>${a[*]}</code> means the substitution of all elements of an array.  Moreover, if this expression is found in double quotes, then the first character from the <code>IFS</code> variable will be taken as the delimiter. <br>  The array is also read simply: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readTopScores</span></span></span></span>() { topScores=() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -r <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TOP_SCORES_FILE_NAME</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -t topScores &lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TOP_SCORES_FILE_NAME</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br><br><h5>  Removing reclaimed pieces of the sea </h5><br>  Obviously, programs written in bash are slow.  At the same time, similar code written in Java or C would be executed instantly.  You start to notice time.  And there is no optimization.  Therefore, it is realistic to feel all the optimization methods that I once studied, but now I‚Äôm used to, that the compiler performs them.  As: removal of a repeating code from the loop body, rewriting the if-elif-elif-else-fi construct in decreasing order of the probability of fulfilling the condition, etc. <br><br>  It turned out that the subtask of removing the conquered pieces of the sea is an interesting subtask.  First, a simple algorithm was implemented based on the area fill algorithm: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteFreeAreas</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -a points <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -ii <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 0; i &lt; countOpponents; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> points[i]=$((opponents[4 * i] * mapWidth + opponents[4 * i + 1])) <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -i countPoints=<span class="hljs-variable"><span class="hljs-variable">$countOpponents</span></span> <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -i index <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [[ countPoints -ne 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> index=$((points[--countPoints])) map[index]=<span class="hljs-variable"><span class="hljs-variable">$opponentArea</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${map[index + 1]}</span></span> == <span class="hljs-variable"><span class="hljs-variable">$sea</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> points[countPoints++]=$((index + 1)) <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${map[index - 1]}</span></span> == <span class="hljs-variable"><span class="hljs-variable">$sea</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> points[countPoints++]=$((index - 1)) <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${map[index + mapWidth]}</span></span> == <span class="hljs-variable"><span class="hljs-variable">$sea</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> points[countPoints++]=$((index + mapWidth)) <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${map[index - mapWidth]}</span></span> == <span class="hljs-variable"><span class="hljs-variable">$sea</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> points[countPoints++]=$((index - mapWidth)) <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> ... }</code> </pre> <br><br>  But it was very, very, very slow.  After spending two or three hours on optimization, I rewrote it this way and that, I accelerated it two times, I realized that I needed a different approach, and went to sleep.  And in the morning on Habr√© saw the article <a href="http://habrahabr.ru/blogs/image_processing/119244/">Counting Objects in a binary image.</a>  <a href="http://habrahabr.ru/blogs/image_processing/119244/">Part 1</a> This was what we needed.  Immediately implemented the algorithm given there, the time of which was completely satisfactory: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteFreeAreas</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -a marks=() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -i mark=MARK_0 ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 1; i &lt; MAP_HEIGHT - 1; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((j = 1; j &lt; MAP_WIDTH - 1; ++j)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> index=$((i * MAP_WIDTH + j)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${tracks[index]}</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> map[index]=<span class="hljs-variable"><span class="hljs-variable">$LAND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> a=<span class="hljs-variable"><span class="hljs-variable">${map[index]}</span></span> b=<span class="hljs-variable"><span class="hljs-variable">${map[(i - 1) * MAP_WIDTH + j]}</span></span> c=<span class="hljs-variable"><span class="hljs-variable">${map[i * MAP_WIDTH + j - 1]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ a -eq SEA ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ b -ne LAND &amp;&amp; c -ne LAND ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${marks[b]}</span></span> -eq <span class="hljs-variable"><span class="hljs-variable">${marks[c]}</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> map[index]=<span class="hljs-variable"><span class="hljs-variable">${marks[b]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> d=$(((b &lt; c) ? b : c)) e=$(((b &lt; c) ? c : b)) map[index]=<span class="hljs-variable"><span class="hljs-variable">${marks[d]}</span></span> m=<span class="hljs-variable"><span class="hljs-variable">${marks[e]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((k = MARK_0; k &lt; mark; ++k)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${marks[k]}</span></span> -eq m ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> marks[k]=<span class="hljs-variable"><span class="hljs-variable">${marks[d]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ b -eq LAND &amp;&amp; c -eq LAND ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> map[index]=<span class="hljs-variable"><span class="hljs-variable">$mark</span></span> marks[mark]=<span class="hljs-variable"><span class="hljs-variable">$mark</span></span> ((++mark)) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ b -ne LAND &amp;&amp; c -eq LAND ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> map[index]=<span class="hljs-variable"><span class="hljs-variable">${marks[b]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ b -eq LAND &amp;&amp; c -ne LAND ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> map[index]=<span class="hljs-variable"><span class="hljs-variable">${marks[c]}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 0; i &lt; countOpponents; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m=<span class="hljs-variable"><span class="hljs-variable">${marks[${map[$(( ${opponents[4 * i]}</span></span> * MAP_WIDTH + <span class="hljs-variable"><span class="hljs-variable">${opponents[4 * i + 1]}</span></span>))]}]} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((j = 0; j &lt; mark; ++j)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${marks[j]}</span></span> -eq m ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> marks[j]=<span class="hljs-variable"><span class="hljs-variable">$OPPONENT_AREA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> ... }</code> </pre><br><br><h5>  Moving opponents </h5><br>  Another interesting subtask was writing a code to reflect enemies from borders.  At first I tried to write code with a bunch of checks of various options, but it turned out to be cumbersome and clumsy working.  I had to think again. <br><br>  It is easy to understand that to determine the next position of the enemy, it is necessary to know a piece of the 3x3 field, and that only 2 ^ 8 = 256 options of obstacles around the enemy are possible. <br><br>  But I don‚Äôt want to encode all 256 variants either, so we‚Äôll remember about pattern matching.  Note that in some cases the direction of further movement depends only on the key pieces of the border and does not depend on what is in other places, for example: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">_</span></span> X _ XXXXX _ _ XX _ <span class="hljs-number"><span class="hljs-number">1</span></span> _ _ <span class="hljs-number"><span class="hljs-number">1</span></span> _ _ <span class="hljs-number"><span class="hljs-number">1</span></span> _ _ <span class="hljs-number"><span class="hljs-number">1</span></span> _ _ _ <span class="hljs-number"><span class="hljs-number">2</span></span> _ _ <span class="hljs-number"><span class="hljs-number">2</span></span> _ _ <span class="hljs-number"><span class="hljs-number">2</span></span> _ _ <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  We introduce the following notation: X - land, _ - sea,?  - anything. <br><br>  Then the configurations above and some others are given by the following pattern: <br><pre> <code class="hljs">? X ? ? o _ ? _ _</code> </pre> <br>  And that's all, it remains only to write the pattern matching function and come up with a set of templates that completely cover all possible wall variants. <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -r -a pattern=(<span class="hljs-variable"><span class="hljs-variable">$1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -r -ax=(<span class="hljs-variable"><span class="hljs-variable">$2</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -ii <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i = 0; i &lt; 8; ++i)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${pattern[i]}</span></span> -ne ANY &amp;&amp; <span class="hljs-variable"><span class="hljs-variable">${pattern[i]}</span></span> -ne <span class="hljs-variable"><span class="hljs-variable">${x[i]}</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0 } rules=( <span class="hljs-comment"><span class="hljs-comment"># pattern dy dx "$ANY $SEA $SEA $ANY $SEA $ANY $ANY $ANY" 1 1 "$ANY $LAND $ANY $ANY $SEA $ANY $SEA $SEA" -1 1 "$SEA $SEA $ANY $SEA $LAND $ANY $ANY $ANY" 1 -1 "$ANY $ANY $LAND $ANY $ANY $LAND $ANY $ANY" 0 0 "$ANY $LAND $ANY $ANY $ANY $ANY $LAND $ANY" 0 0 "$ANY $ANY $ANY $LAND $LAND $ANY $ANY $ANY" 0 0 ... "$ANY $LAND $ANY $ANY $ANY $LAND $ANY $LAND" 0 0 ) declare -r -i COUNT_RULES=$((${#rules[*]} / 3)) function findRule() { local -rx=$1 for ((i = 0; i &lt; COUNT_RULES; ++i)); do if compare "${rules[i * 3]}" "$x"; then echo ${rules[i * 3 + 1]} ${rules[i * 3 + 2]} break fi done } function moveOpponents() { local -ii local -iy local -ix local -i dx local -i dy local -a cells local -a rule for ((i = 0; i &lt; countOpponents; ++i)); do y=${opponents[4 * i]} dy=${opponents[4 * i + 2]} x=${opponents[4 * i + 1]} dx=${opponents[4 * i + 3]} clearOpponent $y $x cells[0]=${map[(y + dy) * MAP_WIDTH + x - dx]} cells[1]=${map[(y + dy) * MAP_WIDTH + x]} cells[2]=${map[(y + dy) * MAP_WIDTH + x + dx]} cells[3]=${map[y * MAP_WIDTH + x - dx]} cells[4]=${map[y * MAP_WIDTH + x + dx]} cells[5]=${map[(y - dy) * MAP_WIDTH + x - dx]} cells[6]=${map[(y - dy) * MAP_WIDTH + x]} cells[7]=${map[(y - dy) * MAP_WIDTH + x + dx]} rule=(`findRule "${cells[*]}"`) ((dy *= rule[0])) ((dx *= rule[1])) ((y += dy)) ((x += dx)) opponents[4 * i]=$y opponents[4 * i + 2]=$dy opponents[4 * i + 1]=$x opponents[4 * i + 3]=$dx drawOpponent $y $x done ... }</span></span></code> </pre> <br>  And finally, two funny mistakes that I made while writing the script. <br><br><ul><li>  The variable, which is now called tracks, I first called the PATH.  And then I could not understand why the script falls with incomprehensible errors. </li><li>  Line <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -t topScores &lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TOP_SCORES_FILE_NAME</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  I first wrote as <br><pre> <code class="bash hljs">cat <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TOP_SCORES_FILE_NAME</span></span></span><span class="hljs-string">"</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -t topScores</code> </pre> <br>  Although I knew, I knew that the pipeline was being executed in a separate process with all the consequences. <br></li></ul><br>  And how many missed dollar icons, spaces - do not count. <br><br>  The script can be found at <a href="http://codepad.org/UfTfcMxj">http://codepad.org/UfTfcMxj</a> .  It is recommended to run in console size 80x25.  If you expand to full screen, then on weak computers brakes are possible. <br><br>  <b>UPD1.</b>  If the script is downloaded from codepad.org as raw code, the end of line characters are saved as CRLF.  And the script starts to crash at startup.  You must either manually insert the text into the file, or set on a dos2unix file. <br><br>  <b>UPD2.</b>  It dawned that the rules in the case of pressing the reverse movement of the key differ.  If someone wants to avoid taking life in this case, he can use the <a href="https://habrahabr.ru/users/tzlom/" class="user_link">tzlom</a> <a href="http://codepad.org/slUUrueq">http://codepad.org/slUUrueq</a> <a href="https://habrahabr.ru/users/tzlom/" class="user_link">habrayuzer</a> patch. </div><p>Source: <a href="https://habr.com/ru/post/122029/">https://habr.com/ru/post/122029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122022/index.html">How to count other people's money</a></li>
<li><a href="../122025/index.html">iPad ‚Üí iPADrom - S03E07. IPad software review</a></li>
<li><a href="../122026/index.html">Android slider from LG with two screens</a></li>
<li><a href="../122027/index.html">How to study source codes</a></li>
<li><a href="../122028/index.html">IPO for dummies. Part V: Life after IPO</a></li>
<li><a href="../122030/index.html">Choosing a microcontroller together</a></li>
<li><a href="../122031/index.html">Interview Mark Shuttleworth: in Ubuntu, the default browser will be Google Chrome</a></li>
<li><a href="../122033/index.html">Kinect for Windows SDK beta</a></li>
<li><a href="../122034/index.html">PDF rendering using HTML5 and JavaScript (pdf.js)</a></li>
<li><a href="../122035/index.html">Startup from scratch: the story of Github</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>