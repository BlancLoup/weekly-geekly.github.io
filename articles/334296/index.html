<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monitoring of actors in Akka.Net, but on F #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At once I will tell, there is no hub for F # on the Habr√©, therefore I write in C #. 

 For those who are not familiar with F #, but familiar with C #...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monitoring of actors in Akka.Net, but on F #</h1><div class="post__text post__text-html js-mediator-article">  <i>At once I will tell, there is no hub for F # on the Habr√©, therefore I write in C #.</i> <br><br>  <i>For those who are not familiar with F #, but familiar with C #, I recommend the <a href="https://blogs.msdn.microsoft.com/dotnet/2017/07/24/get-started-with-f-as-a-c-developer/">latest article</a> from Microsoft.</i> <i><br></i>  <i>It will help you experience less WTF moments while reading, because</i>  <i>My article is not a syntax tutorial.</i> <br><br><h1>  Task context </h1><br>  There is a service written in Akka.NET, it dumps a bunch of information into different text logs.  The operations department stirs these logs, fries them with regexps to find out about the number of errors (business and not so much), the number of incoming messages in the service, and the number of outgoing ones.  Further, this information is poured into ElasticDB, InfluxDB and is shown in Grafana and Kibana in different sections and aggregations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It sounds difficult, and parsing the text logs of the service that generates several dozen GB of text garbage per day is a thankless task.  Therefore, there was a problem - the service should be able to raise endpoints, which can be pulled and get all the information about it at once. <br><br>  We will solve the problem as follows: <br><br><ol><li>  Write a domain model for metrics </li><li>  Zapaim domain model metrics on the implementation of <a href="https://github.com/alhardy/AppMetrics">App.Metrics</a> and raise apishchku </li><li>  Let's make a structured domain logger, which we put on Akka internal logger </li><li>  Make a wrapper for functional actors that will hide work with metrics and logger </li><li>  Putting it all together and running </li></ol><a name="habracut"></a><br><h1>  Domain Model for Metrics </h1><br>  There are 6 types of views in App.Metrics: <br><br><ul><li>  Counters </li><li>  Apdex </li><li>  Gauges </li><li>  Histograms </li><li>  Meters </li><li>  Timers </li></ul><br>  In the first iteration, we have enough counters, timers and ... meters :) <br>  In the beginning we will describe the types and interfaces (I will not give you everything, you can look in the repository, the link is at the end). <br><br>  We also agree that all our messages for metrics will come to a special actor (we will define it later) via the EventStream (the message bus in Akka.Net itself). <br><br>  For example, a timer that should be able to measure a certain amount of time for an object: <br><br><pre><code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> IMetricsTimer = <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Measure : Amount -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Measure : Amount * Item -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span></code> </pre> <br>  Or a counter that should be able to increase / decrease both with and without quantity indication: <br><br><pre> <code class="hljs delphi"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> IMetricsCounter = <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Decrement : <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Decrement : Amount -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Decrement : Amount * Item -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Increment : <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Increment : Amount -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> member Increment : Amount * Item -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span></code> </pre><br>  And a couple of examples of commands for the bus: <br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DecrementCounterCommand</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CounterId</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CounterId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DecrementAmount</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Amount</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Item</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Item</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCounterCommand</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CounterId</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CounterId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Context</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ContextName</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MetricName</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MeasurementUnit</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MeasurementUnit</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReportItemPercentages</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReportSetItems</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResetOnReporting</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  The most important thing is to determine the possible messages that can go along the bus, and to which our metrics-actor will react.  To do this, we use Discriminated Union: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MetricsMessage = | DecrementCounter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DecrementCounterCommand | IncrementCounter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> IncrementCounterCommand | MarkMeter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MarkMeterCommand | MeasureTime <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MeasureTimeCommand | CreateCounter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> CreateCounterCommand | CreateMeter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> CreateMeterCommand | CreateTimer <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> CreateTimerCommand</code> </pre><br>  Now we need to implement the interfaces and finish the first paragraph.  We will implement them in a functional style, i.e.  through functions. <br><br>  Example of creating a meter: <br><br><pre> <code class="hljs kotlin"> let <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> createMeter (evtStream: EventStream) meterId = { new IMetricsMeter with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Mark amount = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Mark (amount, Item None) member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Mark item = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Mark (Amount <span class="hljs-number"><span class="hljs-number">1L</span></span>, item) member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Mark (amount, item) = evtStream.Publish &lt;| MarkMeter { MeterId = meterId; Amount = amount; Item = item }</code> </pre><br>  For people from the world of C # I give an analogue: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IMetricsMeter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventStream evtStream, MeterId meterId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TempClass</span></span> : <span class="hljs-title"><span class="hljs-title">IMetricsMeter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount</span></span></span><span class="hljs-function">)</span></span> { Mark(amount, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { Mark(<span class="hljs-number"><span class="hljs-number">1</span></span>, item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { evtStream.Publish(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MarkMeter {...});<span class="hljs-comment"><span class="hljs-comment">//omitted } } return new TempClass(); }</span></span></code> </pre><br>  Do not be confused that the analog is not compiled, this is normal, because  the private class in the body of the method is confused by the compiler.  But in F # you can return an anonymous class through the interface. <br><br>  The main thing you need to pay attention to is that we throw a message on the bus that we need to move the meter, which is determined via MeterId. <br><br>  We do the same with the IMetricsAdapter, but since  I will give many methods for one: <br><br><pre> <code class="hljs pgsql"> member this.CreateMeter (<span class="hljs-type"><span class="hljs-type">name</span></span>, measureUnit, rateUnit) = let cmd = { MeterId = MeterId (toId <span class="hljs-type"><span class="hljs-type">name</span></span>) Context = context <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-type"><span class="hljs-type">name</span></span> MeasurementUnit = measureUnit RateUnit = rateUnit } evtStream.Publish &lt;| CreateMeter cmd createMeter evtStream cmd.MeterId</code> </pre><br>  When we request a timer, we send a creation message to the bus, and the caller is returned the result of the createMeter method with the arguments evtStream and cmd.MeterId. <br>  The result of it, as seen above - IMetricsMeter. <br><br>  After that, create an extension for ActorSystem so that you can call our IMetricsAdapter from anywhere: <br><br><pre> <code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActorContext</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetMetricsProducer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class"> </span></span>= createAdapter x.<span class="hljs-type"><span class="hljs-type">System</span></span>.<span class="hljs-type"><span class="hljs-type">EventStream</span></span> context</code> </pre><br><h1>  Actors for metrics and apishechka </h1><br>  We need two actors: <br><br><ul><li>  The first one will listen to the bus for MetricsMessage in it and create / write metrics. </li><li>  The second actor will keep WebApi with one method, which will ship all collected information on a GET request. </li></ul><br>  Immediately think ApiController, it is trivial: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MetricController(metrics: IMetrics) = <span class="hljs-keyword"><span class="hljs-keyword">inherit</span></span> ApiController() [&lt;HttpGet&gt;] [&lt;Route("metrics")&gt;] member __.GetMetrics() = __.Ok(metrics.<span class="hljs-keyword"><span class="hljs-keyword">Snapshot</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>())</code> </pre><br>  Next, we declare the function of an actor that will read all MetricsMessage from the EventStream and do something with them.  Introduce the IMetrics dependency to the function through arguments, inside we create caches for all metrics through ordinary Dictionary. <br><br>  Why not ConcurrentDictionary, you ask?  And because the actor processes messages in turn.  In order to catch the race condition inside the actor, you need to purposefully shoot yourself in the foot. <br><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> createRecorder (metrics: <span class="hljs-type"><span class="hljs-type">IMetrics</span></span>) (mailbox: <span class="hljs-type"><span class="hljs-type">Actor</span></span>&lt;_&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> self = mailbox.<span class="hljs-type"><span class="hljs-type">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counters = new <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CounterId</span></span>, <span class="hljs-type"><span class="hljs-type">ICounter</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> meters = new <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">MeterId</span></span>, <span class="hljs-type"><span class="hljs-type">IMeter</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timers = new <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerId</span></span>, <span class="hljs-type"><span class="hljs-type">ITimer</span></span> * <span class="hljs-type"><span class="hljs-type">TimeUnit</span></span>&gt;() //    ... <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = function | <span class="hljs-type"><span class="hljs-type">DecrementCounter</span></span> evt -&gt; match counters.<span class="hljs-type"><span class="hljs-type">TryGetValue</span></span> evt.<span class="hljs-type"><span class="hljs-type">CounterId</span></span> with | (false, _) -&gt; () | (true, c) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-type"><span class="hljs-type">Amount</span></span> am) = evt.<span class="hljs-type"><span class="hljs-type">DecrementAmount</span></span> match evt.<span class="hljs-type"><span class="hljs-type">Item</span></span> with | <span class="hljs-type"><span class="hljs-type">Item</span></span> (<span class="hljs-type"><span class="hljs-type">Some</span></span> i) -&gt; c.<span class="hljs-type"><span class="hljs-type">Decrement</span></span> (i, am) | <span class="hljs-type"><span class="hljs-type">Item</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> -&gt; c.<span class="hljs-type"><span class="hljs-type">Decrement</span></span> (am) | <span class="hljs-type"><span class="hljs-type">CreateMeter</span></span> cmd -&gt; match meters.<span class="hljs-type"><span class="hljs-type">TryGetValue</span></span> cmd.<span class="hljs-type"><span class="hljs-type">MeterId</span></span> with | (false, _) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-type"><span class="hljs-type">ContextName</span></span> ctxName) = cmd.<span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-type"><span class="hljs-type">MetricName</span></span> name) = cmd.<span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> options = new <span class="hljs-type"><span class="hljs-type">MeterOptions</span></span>( <span class="hljs-type"><span class="hljs-type">Context</span></span> = ctxName, <span class="hljs-type"><span class="hljs-type">MeasurementUnit</span></span> = toUnit cmd.<span class="hljs-type"><span class="hljs-type">MeasurementUnit</span></span>, <span class="hljs-type"><span class="hljs-type">Name</span></span> = name, <span class="hljs-type"><span class="hljs-type">RateUnit</span></span> = toTimeUnit cmd.<span class="hljs-type"><span class="hljs-type">RateUnit</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> m = metrics.<span class="hljs-type"><span class="hljs-type">Provider</span></span>.<span class="hljs-type"><span class="hljs-type">Meter</span></span>.<span class="hljs-type"><span class="hljs-type">Instance</span></span> options meters.<span class="hljs-type"><span class="hljs-type">Add</span></span>(cmd.<span class="hljs-type"><span class="hljs-type">MeterId</span></span>, m) | _ -&gt; () //    match  subscribe typedefof&lt;<span class="hljs-type"><span class="hljs-type">MetricsMessage</span></span>&gt; self mailbox.<span class="hljs-type"><span class="hljs-type">Context</span></span>.<span class="hljs-type"><span class="hljs-type">System</span></span>.<span class="hljs-type"><span class="hljs-type">EventStream</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop() = actor { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = mailbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() handle msg return! loop() } loop()</code> </pre><br>  The short meaning is that they declared the internal state in the form of dictionaries of different metrics, declared the message processing function of MetricsMessage, subscribed to MetricsMessage and returned the recursive message processing function from the mailbox. <br><br>  Messages for working with metrics are processed as follows: <br><br><ol><li>  We look exactly what message (through the pattern matching) </li><li>  We are looking for a metric with this Id in the corresponding dictionary (for this there is a wonderful pattern after a couple (bool, obj), which returns TryGetValue in F # </li><li>  If this is a request to create a metric and there is none </li><li>  If this is a request for the use of a metric and it is - use </li></ol><br>  We also need an actor that raises the Owin host with the controller above. <br>  To do this, we write a function that accepts a dependency in the form of a config and an IDependencyResolver.  In order not to fail at the start, the actor sends a message to itself, which initiates a possible Dispose () of the old API and the creation of a new one.  And again, because  the actor is synchronous inside itself, we can use mutable state. <br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMetricApiConfig</span></span></span><span class="hljs-class"> = abstract member </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Host</span></span></span><span class="hljs-class">: string abstract member </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class">: int </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ApiMessage</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReStartApiMessage</span></span></span><span class="hljs-class"> let createReader (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMetricApiConfig</span></span></span><span class="hljs-class">) resolver (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mailbox</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Actor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">&gt;) = let startUp (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">app</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IAppBuilder</span></span></span><span class="hljs-class">) = let httpConfig = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HttpConfiguration</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DependencyResolver</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolver</span></span></span><span class="hljs-class">) httpConfig.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Formatters</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonFormatter</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SerializerSettings</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Converters</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MetricDataConverter</span></span></span><span class="hljs-class">()) httpConfig.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Formatters</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonFormatter</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Indent</span></span></span><span class="hljs-class"> &lt;- true httpConfig.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MapHttpAttributeRoutes</span></span></span><span class="hljs-class">() httpConfig.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EnsureInitialized</span></span></span><span class="hljs-class">() app.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UseWebApi</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">httpConfig</span></span></span><span class="hljs-class">) |&gt; ignore let uri = sprintf "http://%s:%d" config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Host</span></span></span><span class="hljs-class"> config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class"> let mutable api = {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IDisposable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dispose</span></span></span><span class="hljs-class">() = ()} let handleMsg (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReStartApiMessage</span></span></span><span class="hljs-class">) = api.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dispose</span></span></span><span class="hljs-class">() api &lt;- </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebApp</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Start</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uri</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startUp</span></span></span><span class="hljs-class">) mailbox.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Defer</span></span></span><span class="hljs-class"> api.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dispose</span></span></span><span class="hljs-class"> mailbox.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Self</span></span></span><span class="hljs-class"> &lt;! </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReStartApiMessage</span></span></span><span class="hljs-class"> let rec loop() = actor { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mailbox</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Receive</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handleMsg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loop</span></span></span><span class="hljs-class">() } loop()</span></span></code> </pre><br>  We also throw the api.Dispose method into deferred tasks during the final stop of the actor using mailbox.Defer.  And for the initial state of the variable api, we use a stub through an object expression that constructs an empty IDisposable object. <br><br><h1>  We make a structured logger </h1><br>  The meaning of the task is to make a wrapper for the logger from Akka.Net (it is presented through the ILoggingAdapter interface), which can be used to measure the operation time and typed information transfer (not just strings, but distinct business cases). <br><br>  All logger typing is enclosed in one union. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Fragment = | OperationName <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string | OperationDuration <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TimeSpan | TotalDuration <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TimeSpan | ReceivedOn <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DateTimeOffset | MessageType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> exn</code> </pre><br>  And the logger itself will work on this interface: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ILogBuilder = <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> OnOperationBegin: <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> OnOperationCompleted: <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>: LogLevel -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>: Fragment -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> Fail: exn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> Supress: <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> TryGet: Fragment -&gt; Fragment option</code> </pre><br>  We will create it through the usual class: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger: ILoggingAdapter</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logFragments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;System.Type, Fragment&gt;() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutable logLevel = LogLevel.DebugLevel <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ILogBuilder</span></span> <span class="hljs-title"><span class="hljs-title">with</span></span> <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br>  Maybe you ask why the usual Dictionary?  As mentioned above, this LogBuilder is intended for use inside the actor when processing a single operation.  It makes no sense to use a competitive data structure. <br><br>  I will give an example of methods for implementing the interface: <br><br><pre> <code class="hljs sql"> let <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> fragment = logFragments.[fragment.GetType()] &lt;- fragment <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> x.OnOperationBegin() = stopwatch.Start() <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> this.Fail e = logLevel &lt;- LogLevel.ErrorLevel <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> &lt;| <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> this.OnOperationCompleted() = stopwatch.Stop() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> &lt;| OperationDuration stopwatch.Elapsed <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tryGet &lt;| ReceivedOn DateTimeOffset.MinValue <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> (ReceivedOn <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> &lt;| TotalDuration (DateTimeOffset.UtcNow - <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) | _ -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | Active -&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (logLevel) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | LogLevel.DebugLevel -&gt; logger.Debug(message()) | LogLevel.InfoLevel -&gt; logger.Info(message()) | LogLevel.WarningLevel -&gt; logger.Warning(message()) | LogLevel.ErrorLevel -&gt; logger.Error(message()) | x -&gt; failwith(sprintf <span class="hljs-string"><span class="hljs-string">"Log level %s is not supported"</span></span> &lt;| <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> x) | Supressed -&gt; ()</code> </pre><br>  The most interesting is the logic of the work OnOperationCompleted (): <br><br><ul><li>  Stop the timer and write the elapsed time to the logger through the fragment OperationDuration </li><li>  If we have the ReceivedOn fragment in the log (which in my model means the time the message arrived at the service IN GENERAL), then we write to the log the total time the message was found in the service through TotalDuration </li><li>  If the logger was not turned off (via the Supress () method, then we write info to Akka via the message () method, which I did not bring, but it just somehow collects all the Fragments into a string, taking into account the types of messages </li></ul><br><h1>  Create a wrapper for functional actors. </h1><br>  The most magical part that allows us to write simple message processing functions without a boilerplate, which carries total logging. <br><br>  What do we want to achieve?  First we want to secure: <br><br><ul><li>  What are we doing.  In our case, this is the name of the operation, since  functional actors have one type of funcActor </li><li>  Type of message being processed </li><li>  How many such functions (essentially actors) live in the system </li><li>  Show the time it took to complete the operation </li><li>  Show the total time that has passed since the message was received at the entrance to the service. </li><li>  Pledge an error, if any, in a special way. </li><li>  be able to write simple message handling functions without thinking about everything above </li></ul><br>  Linq.Expressions will help us to do all of the above.  How to do this through QuotationExpressions from F # I do not know, because  I did not find a simple way to compile them.  I would be glad if someone offers options. <br><br>  And so, for starters, let's declare a couple of auxiliary types and one method: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">'TLog</span></span> when <span class="hljs-symbol"><span class="hljs-symbol">'TLog</span></span> :&gt; ILogBuilder&gt; = Expression&lt;System.Action&lt;Actor&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt;, <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'TLog</span></span>&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> member Handler(e: Expression&lt;System.Action&lt;Actor&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt;, <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>, #ILogBuilder&gt;&gt;) = e <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> toExprName (expr: Expr&lt;_,_&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> expr.Body with | :? MethodCallExpression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> methodCall -&gt; methodCall.Method.Name | x -&gt; x.<span class="hljs-built_in"><span class="hljs-built_in">ToString</span></span>()</code> </pre><br>  Expr is an expression that contains the Action from the mailbox (in case you need to have children, stop yourself or children and in general), the message being processed and the logger (if you need to do some special actions with it). <br><br>  Wrap.Handler (Expr) - let us write to it ordinary F # expressions of the form ‚Äúfun mb msg log -&gt; ()‚Äù, and get Linq.Expressions at the output. <br><br>  toExprName is a method that receives a method name if the expression is a method call (MethodCallExpression) or just tries to cast our expression to a string. <br>  For an expression like ‚Äúfun mb msg log -&gt; handleMsg msg‚Äù - toExprName returns ‚ÄúhandleMsg‚Äù. <br><br>  Now we will write a wrapper for creating functional actors.  The beginning of the announcement looks like this: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loggerActor&lt;<span class="hljs-symbol"><span class="hljs-symbol">'TMsg</span></span>&gt; (handler: Expr&lt;<span class="hljs-symbol"><span class="hljs-symbol">'TMsg</span></span>,_&gt;) (mailbox: Actor&lt;<span class="hljs-symbol"><span class="hljs-symbol">'TMsg</span></span>&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> exprName = handler |&gt; toExprName <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> metrics = mailbox.Context.GetMetricsProducer (ContextName exprName) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger = mailbox.Log.Value</code> </pre><br>  At the entrance, we will submit only the handler, because  mailbox then Akka itself (partial application). <br><br>  Using the extension we wrote to the ActorSystem, we get an instance of the IMetricsAdapter to the value metrics.  We also get the Akka logger in the logger value. <br><br>  Then we will create all the necessary metrics for this actor and use them right away: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errorMeter = metrics.<span class="hljs-type"><span class="hljs-type">CreateMeter</span></span> (<span class="hljs-type"><span class="hljs-type">MetricName</span></span> <span class="hljs-string"><span class="hljs-string">"Error Rate"</span></span>, <span class="hljs-type"><span class="hljs-type">Errors</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instanceCounter = metrics.<span class="hljs-type"><span class="hljs-type">CreateCounter</span></span> (<span class="hljs-type"><span class="hljs-type">MetricName</span></span> <span class="hljs-string"><span class="hljs-string">"Instances Counter"</span></span>, <span class="hljs-type"><span class="hljs-type">Items</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> messagesMeter = metrics.<span class="hljs-type"><span class="hljs-type">CreateMeter</span></span> (<span class="hljs-type"><span class="hljs-type">MetricName</span></span> <span class="hljs-string"><span class="hljs-string">"Message Processing Rate"</span></span>, <span class="hljs-type"><span class="hljs-type">Items</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operationsTimer = metrics.<span class="hljs-type"><span class="hljs-type">CreateTimer</span></span> (<span class="hljs-type"><span class="hljs-type">MetricName</span></span> <span class="hljs-string"><span class="hljs-string">"Operation Durations"</span></span>, <span class="hljs-type"><span class="hljs-type">Requests</span></span>, <span class="hljs-type"><span class="hljs-type">MilliSeconds</span></span>, <span class="hljs-type"><span class="hljs-type">MilliSeconds</span></span>) instanceCounter.<span class="hljs-type"><span class="hljs-type">Increment</span></span>() mailbox.<span class="hljs-type"><span class="hljs-type">Defer</span></span> instanceCounter.<span class="hljs-type"><span class="hljs-type">Decrement</span></span></code> </pre><br>  As you can see, we increase the value of instanceCounter and lay down the decrease of this counter at the stop of the actor. <br><br>  We will need a couple more methods that will fill in the known parameters to the logger and pull the required metrics. <br><br>  In this piece of code, we throw the name of the operation into the logger, call the completion of its logging, throw the operation time into the timer metric, and type the message into the message messaging metric: <br><br><pre> <code class="hljs pgsql"> let completeOperation (msgType: <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) (logger: #ILogBuilder) = logger.<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> (OperationName exprName) logger.OnOperationCompleted() match logger.TryGet(OperationDuration TimeSpan.Zero) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(OperationDuration dur) -&gt; operationsTimer.Measure(Amount (int64 dur.TotalMilliseconds), Item (<span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> exprName)) | _ -&gt; () messagesMeter.Mark(Item (<span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> msgType.Name))</code> </pre><br>  The following method will help us in handling exceptions inside the actor: <br><br><pre> <code class="hljs pgsql"> let registerExn (msgType: <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) e (logger: #ILogBuilder) = errorMeter.Mark(Item (<span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> msgType.Name)) logger.Fail e</code> </pre><br>  It remains a bit to make it work.  Let's tie everything together through a wrapper over the handler: <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> wrapHandler handler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logBuilder: unit -&gt; #ILogBuilder</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> innherHandler mb msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger = logBuilder() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> msgType = msg.GetType() logger.Set (MessageType msgType) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> logger.OnOperationBegin() handler mb msg logger with | e -&gt; registerExn msgType e logger; reraise() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> completeOperation msgType logger innherHandler mb</code> </pre><br>  wrapHandler has a complex signature.  In C #, it would look like this: <br><br><pre> <code class="cs hljs">Func&lt;TMsg, TResult&gt; wrapHandler&lt;Tmsg, TResult, TLogBuilder, TMailbox&gt;( Func&lt;TMailbox, TMsg, TLogBuilder, TResult&gt; handler, TMailbox mb, Func&lt;TLogBuilder&gt; logBuilder) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TLogBuilder: ILogBuilder</code> </pre><br>  At the same time on all other types <b>there</b> are <b>no restrictions</b> . <br><br>  According to the meaning, wrapHandler should give a function at the output that receives TMsg and returns TResults.  The procedure for this function will be as follows: <br><br><ul><li>  We begin operation logging </li><li>  Perform operation </li><li>  In the case of an exception that is unhandled in the handler, log it and forward it above (to the parent of this actor) </li><li>  We finish logging </li></ul><br>  To convert the Expression to Action and submit to each action of the actor a new instance of the logger, we will make one more auxiliary function: <br><br><pre> <code class="hljs kotlin"> let wrapExpr (expr: Expr&lt;_,_&gt;) mailbox logger = let action = expr.Compile() wrapHandler (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> mb msg log -&gt; action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mailbox, msg, log)</span></span></span></span>) mailbox (<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; new LogBuilder(logger))</code> </pre><br>  In it, we just get our Expression, compile it and submit it to wrapHandler above, along with the mailbox and the function to get the new LogBuilder (). <br><br>  The signature of this method is also not easy.  On C #, it would look like this: <br><br><pre> <code class="cs hljs">Action&lt;TMsg&gt; wrapExpr&lt;TMsg&gt;( Expr&lt;TMsg, LogBuilder&gt; expr, Actor&lt;TMsg&gt; mb, ILoggingAdapterlogger)</code> </pre><br>  There are still no restrictions on TMsg. <br><br>  It remains only to create a recursive function :) <br><pre> <code class="hljs pgsql"> let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() = actor { let! msg = mailbox.Receive() wrapExpr <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> mailbox akkaLogger msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>()</code> </pre><br>  This expression ‚ÄúwrapExpr handler mailbox akkaLogger‚Äù, as can be seen from the explanation above, returns an Action, i.e.  a method in which you can submit any type of input and get a unit (void in c #). <br><br>  Having added ‚Äúmsg‚Äù at the end of the expression, we throw the msg argument into this function and perform our action on the received message. <br><br>  At this point, we ended up coding our problem and move on to examples! <br><br><h1>  How to start all this? </h1><br>  For this all to work it is not necessary to write a lot of code <br>  You can generally write only message handlers without knowing that we need mailboxes, loggers, or error handling. <br><br>  A simple case might look like this: <br><br><pre> <code class="hljs vbscript">type ActorMessages = | Wait of <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> waitProcess = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> | Wait d -&gt; Async.Sleep d |&gt; Async.RunSynchronously | <span class="hljs-keyword"><span class="hljs-keyword">Stop</span></span> -&gt; ()</code> </pre><br><br>  And to wrap this function in loggerActor and get all the buns for which we tried so hard, you can write this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawnWaitWorker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> = loggerActor &lt;| Wrap.Handler(fun mb msg log -&gt; waitProcess msg) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> waitWorker = spawn system <span class="hljs-string"><span class="hljs-string">"worker-wait"</span></span> &lt;| spawnWaitWorker() waitWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ~1000 waitWorker &lt;! Wait 500</span></span></code> </pre><br>  If you have complex logic and need access to the mailbox and logger: <br><br><pre> <code class="hljs pgsql">let failOrStopProcess (mailbox: Actor&lt;_&gt;) msg (<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>: ILogBuilder) = try match msg <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | Wait d -&gt; failwith "can't wait!" | Stop -&gt; mailbox.Context.Stop mailbox.Self <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | e -&gt; <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>.Fail e let spawnFailOrStopWorker() = loggerActor &lt;| Wrap.<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>(fun mb msg <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> -&gt; failOrStopProcess mb msg <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>) let failOrStopWorker = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-vocal" &lt;| spawnFailOrStopWorker() failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">1000</span></span> //   "can't wait!" failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> //   "can't wait!" failOrStopWorker &lt;! Stop failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> //     DeadLetters</code> </pre><br>  EntryPoint program itself, the creation of ActorSystem, raising metrics and actors can be viewed under the spoiler, there is nothing remarkable there. <br><br><div class="spoiler">  <b class="spoiler_title">Program.fs</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> Akka.FSharp <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> SimpleInjector <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> App.Metrics; <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> Microsoft.Extensions.DependencyInjection <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> SimpleInjector.Integration.WebApi <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Reflection <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> Metrics.MetricActors <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> ExampleActors let createSystem = let configStr = <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.File.ReadAllText("system.json") <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> "system-for-metrics" (<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>.parse(configStr)) let createMetricActors <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> container = let dependencyResolver = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SimpleInjectorWebApiDependencyResolver(container) let apiConfig = { <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IMetricApiConfig <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> member x.Host = "localhost" member x.Port = <span class="hljs-number"><span class="hljs-number">10001</span></span> } let metricsReaderSpawner = createReader apiConfig dependencyResolver let metricsReader = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "metrics-reader" metricsReaderSpawner let metricsRecorderSpawner = createRecorder (container.GetInstance&lt;IMetrics&gt;()) let metricsRecorder = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "metrics-recorder" metricsRecorderSpawner () <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> member x.AddMetrics() = let serviceCollection = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ServiceCollection() let entryAssemblyName = Assembly.GetEntryAssembly().GetName() let metricsHostBuilder = serviceCollection.AddMetrics(entryAssemblyName) serviceCollection.AddLogging() |&gt; ignore let provider = serviceCollection.BuildServiceProvider() x.Register(fun () -&gt; provider.GetRequiredService&lt;IMetrics&gt;()) [&lt;EntryPoint&gt;] let main argv = let container = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Container() let <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> = createSystem container.RegisterSingleton <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> container.AddMetrics() container.Verify() createMetricActors <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> container let waitWorker1 = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-wait1" &lt;| spawnWaitWorker() let waitWorker2 = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-wait2" &lt;| spawnWaitWorker() let waitWorker3 = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-wait3" &lt;| spawnWaitWorker() let waitWorker4 = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-wait4" &lt;| spawnWaitWorker() let failWorker = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-fail" &lt;| spawnFailWorker() let waitOrStopWorker = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-silent" &lt;| spawnWaitOrStopWorker() let failOrStopWorker = spawn <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> "worker-vocal" &lt;| spawnFailOrStopWorker() waitWorker1 &lt;! Wait <span class="hljs-number"><span class="hljs-number">1000</span></span> waitWorker2 &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> waitWorker3 &lt;! Wait <span class="hljs-number"><span class="hljs-number">5000</span></span> waitWorker4 &lt;! Wait <span class="hljs-number"><span class="hljs-number">8000</span></span> failWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">5000</span></span> waitOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">1000</span></span> waitOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> waitOrStopWorker &lt;! Stop waitOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">1000</span></span> failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> failOrStopWorker &lt;! Stop failOrStopWorker &lt;! Wait <span class="hljs-number"><span class="hljs-number">500</span></span> Console.ReadKey() |&gt; ignore <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br></div></div><br>  The most important thing is metrics! <br><br>  If during the work go to the link localhost: 10001 / metrics, we will see a fairly large json, which will have a lot of information.  I will give a piece for the waitProcess function: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Context"</span></span>: <span class="hljs-string"><span class="hljs-string">"waitProcess"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Counters"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Instances Counter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Unit"</span></span>: <span class="hljs-string"><span class="hljs-string">"items"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"Meters"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Message Processing Rate"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Unit"</span></span>: <span class="hljs-string"><span class="hljs-string">"items"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"FifteenMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">35.668327519112893</span></span>, <span class="hljs-attr"><span class="hljs-attr">"FiveMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">35.01484385742755</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Items"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"FifteenMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"FiveMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Item"</span></span>: <span class="hljs-string"><span class="hljs-string">"Wait"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MeanRate"</span></span>: <span class="hljs-number"><span class="hljs-number">13.082620551464204</span></span>, <span class="hljs-attr"><span class="hljs-attr">"OneMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percent"</span></span>: <span class="hljs-number"><span class="hljs-number">100.0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"MeanRate"</span></span>: <span class="hljs-number"><span class="hljs-number">13.082613248856632</span></span>, <span class="hljs-attr"><span class="hljs-attr">"OneMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">31.356094372926623</span></span>, <span class="hljs-attr"><span class="hljs-attr">"RateUnit"</span></span>: <span class="hljs-string"><span class="hljs-string">"min"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"Timers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Operation Durations"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Unit"</span></span>: <span class="hljs-string"><span class="hljs-string">"req"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ActiveSessions"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"DurationUnit"</span></span>: <span class="hljs-string"><span class="hljs-string">"ms"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Histogram"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"LastUserValue"</span></span>: <span class="hljs-string"><span class="hljs-string">"waitProcess"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"LastValue"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Max"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MaxUserValue"</span></span>: <span class="hljs-string"><span class="hljs-string">"waitProcess"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Mean"</span></span>: <span class="hljs-number"><span class="hljs-number">3927.1639786164278</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Median"</span></span>: <span class="hljs-number"><span class="hljs-number">5021.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Min"</span></span>: <span class="hljs-number"><span class="hljs-number">1078.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MinUserValue"</span></span>: <span class="hljs-string"><span class="hljs-string">"waitProcess"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percentile75"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percentile95"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percentile98"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percentile99"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Percentile999"</span></span>: <span class="hljs-number"><span class="hljs-number">8001.0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SampleSize"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"StdDev"</span></span>: <span class="hljs-number"><span class="hljs-number">2932.0567172627871</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Sum"</span></span>: <span class="hljs-number"><span class="hljs-number">15190.0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Rate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"FifteenMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.00059447212531854826</span></span>, <span class="hljs-attr"><span class="hljs-attr">"FiveMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.00058358073095712587</span></span>, <span class="hljs-attr"><span class="hljs-attr">"MeanRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.00021824579927905906</span></span>, <span class="hljs-attr"><span class="hljs-attr">"OneMinuteRate"</span></span>: <span class="hljs-number"><span class="hljs-number">0.00052260157288211038</span></span> } } ] }</code> </pre><br></div></div><br>  From it you can learn that: <br><br><ul><li>  We currently have 4 workProcess instances active. </li><li>  They processed 4 Wait messages. </li><li>  Median message processing time 5021 ms </li></ul><br>  In the console will be about the <a href="">following</a> . <br><br><h1>  Conclusion </h1><br>  There are a lot of code in this article and, most likely, there is little explanation (I‚Äôll answer in comments if something is not clear), but this is because the article is intended to show the solution of several routine tasks from a real project. <br><br>  Maybe someone will come in handy, especially since this code was originally written for actors in C #, so if you want, you can transfer all this (I will give you a hint, you can make your version of Receive () with the same inside). <br><br>  I recommend to study F # to those who are engaged in modeling of complex domain models, since  its type system is much richer, the absence of null and <a href="https://fsharpforfunandprofit.com/ddd/">design in types</a> allows you to make the model resistant to programmer errors. <br><br>  An example repository is <a href="https://github.com/Szer/Akka.FSharp.ActorMonitoring">here</a> . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/334296/">https://habr.com/ru/post/334296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334286/index.html">Internet travel. Analysis of foreign SIM-cards</a></li>
<li><a href="../334288/index.html">The ghost of a locomotive or the stock market through the prism of correlations</a></li>
<li><a href="../334290/index.html">SOAP and REST services using the Spyne Python library</a></li>
<li><a href="../334292/index.html">Anatomy of Google Analytics</a></li>
<li><a href="../334294/index.html">About Agile, Scrum and teamwork. How are the processes of product development in the Alpha Laboratory</a></li>
<li><a href="../334298/index.html">Here you are not DevOps: the fate of a sysadmin in a small business</a></li>
<li><a href="../334300/index.html">Artificial stupidity: the art of intentional mistakes</a></li>
<li><a href="../334302/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 27</a></li>
<li><a href="../334304/index.html">EmerDNS - an alternative to DNSSEC</a></li>
<li><a href="../334306/index.html">Job search in the Czech Republic on their own experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>