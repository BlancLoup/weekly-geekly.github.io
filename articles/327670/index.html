<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To monitor the status of running applications, it is necessary to monitor them continuously. And if applications run in a well-scalable environment li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5ef/caf/37d/5efcaf37d522457a8c415a0f08aa5a07.jpg"><br><p>  To monitor the status of running applications, it is necessary to monitor them continuously.  And if applications run in a well-scalable environment like Docker Swarm, then a well-scalable monitoring tool will also be required.  This article talks about setting up just such a tool. </p><br><p>  In the process, we will install <a href="https://github.com/google/cadvisor">cAdvisor</a> agents on each node to collect host metrics and containers.  Metrics will be stored in <a href="https://github.com/influxdata/influxdb">InfluxDB</a> .  To plot graphs based on these metrics, use <a href="https://github.com/grafana/grafana">Grafana</a> .  These tools are distributed open source and can be deployed as containers. </p><br><p>  To build a cluster, we will use Docker Swarm Mode and deploy the necessary services in the form of a stack.  This will allow organizing a dynamic monitoring system that can automatically begin monitoring new nodes as they are added to the swarm.  Project files can be found <a href="https://github.com/botleg/swarm-monitoring">here</a> . </p><a name="habracut"></a><br><h2 id="obzor-instrumentov">  Tool overview </h2><br><p>  The choice of monitoring systems is quite large.  To build our stack, we will use open source services that work well in containers.  Next, I will describe the composition of the stack. </p><br><h3 id="cadvisor">  cAdvisor </h3><br><p>  <a href="https://github.com/google/cadvisor">cAdvisor</a> will collect metrics of hosts and containers.  It is installed as a docker image with a docker socket and the root file system on the host connected as a shared volume.  cAdvisor can record collected metrics in several types of time series databases (including time-series database), including InfluxDB, Prometheus, etc. It even has a web interface in which graphs are plotted from the collected data. </p><br><h3 id="influxdb">  InfluxDB </h3><br><blockquote>  Scalable storage for metrics, events, and real-time analytics. </blockquote><p>  <a href="https://github.com/influxdata/influxdb">InfluxDB</a> is an open source time series database that allows you to store numeric metrics and assign tags to them.  This system implements an SQL-like query language that can be used to work with stored data.  We will filter events using tags by host or even container. </p><br><h3 id="grafana">  Grafana </h3><br><blockquote>  Grafana is a feature-rich open source system that allows you to create toolbars and graphs based on metrics from Graphite, Elasticsearch, OpenTSDB, Prometheus, and InfluxDB. </blockquote><p>  <a href="https://github.com/grafana/grafana">Grafana</a> is a popular visualization tool that allows you to create toolbars, retrieving data from Graphite, Elasticsearch, OpenTSDB, Prometheus and, of course, InfluxDB.  Starting with the fourth version, it became possible to customize alerts based on the results of queries.  We will create a toolbar with which you can display data on a specific host and service. </p><br><h2 id="docker-swarm-mode">  Docker swarm mode </h2><br><p> <code>Swarm Mode</code> appeared in Docker since version 1.12.0.  It allows you to easily create a swarm from a host of hosts and easily manage it.  To ensure the operation of the built-in mechanisms for discovering services and orchestration, key-value storage is implemented in Swarm mode.  Hosts can play the role of manager (manager) or working node (worker).  In general, the manager is responsible for the function of the orchestration, and containers are executed on the worker nodes.  Since this is a demo installation, we will place InfluxDB and Grafana on the manager. </p><br><p>  In Swarm Mode there is an interesting function of the <strong>routing grid (routing mesh)</strong> , which performs the role of a virtual load balancer.  Suppose we have 10 containers listening to the 80th port, which run on 5 nodes.  When trying to access the 80 port of one of these containers, the request can be sent to any of them, even running on a different host.  Thus, by publishing the IP address of any node, you automatically turn on balancing requests between ten containers. </p><br><p>  If you plan to independently execute the commands given in this demonstration in your system, you will need the following programs: </p><br><ul><li>  <strong>Docker</strong> : version&gt; = 1.13 (for Docker Compose File version 3 and Swarm Mode); </li><li>  <strong>Docker Machine</strong> : version&gt; = 0.8; </li><li>  <strong>Docker Compose</strong> : version&gt; = 1.10 (for Docker Compose File version 3). </li></ul><br><p>  The swarm will consist of three local virtual machines, which we deploy with the help of the <strong>docker-machine</strong> plugin <strong>Virtualbox</strong> .  To do this, you must have <a href="https://www.virtualbox.org/">Virtualbox installed</a> .  Using other plug-ins, you can deploy virtual machines in cloud services.  Steps after creating machines will be the same for all plugins.  More information about the docker-machine can be found <a href="https://docs.docker.com/machine/get-started/">here</a> . </p><br><p>  When creating virtual machines, we will leave the default options.  <a href="https://docs.docker.com/machine/drivers/virtualbox/">Here</a> is more detailed information about available options.  The host that performs the swan manager function is called <strong>manager</strong> , and the worker nodes are <strong>agent1</strong> and <strong>agent2</strong> .  You can create as many nodes as you like.  Just repeat the above commands with a different host name.  To create a virtual machine, run the following commands: </p><br><pre> <code class="bash hljs">docker-machine create manager docker-machine create agent1 docker-machine create agent2</code> </pre> <br><p>  It may take some time to execute these commands.  After the machines are created, the <code>docker-machine ls</code> output should look something like this: </p><br><pre> <code class="bash hljs">NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS agent1 - virtualbox Running tcp://192.168.99.101:2376 v17.03.1-ce agent2 - virtualbox Running tcp://192.168.99.102:2376 v17.03.1-ce manager - virtualbox Running tcp://192.168.99.100:2376 v17.03.1-ce</code> </pre> <br><p>  To use the docker engine on the <strong>manager‚Äôs manager,</strong> you need to switch the context.  Further we will execute commands in docker installed on the host <strong>manager</strong> , and NOT on the local system.  To do this, run the command: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> `docker-machine env manager`</code> </pre> <br><p>  Now that we have switched to docker on <strong>manager</strong> , we initialize this host as a swarm manager.  We will need its IP, which will be published on other connected nodes.  The <code>docker-machine ip manager</code> allows you to get the necessary information.  So, to create a swarm, run the following command: </p><br><pre> <code class="bash hljs">docker swarm init --advertise-addr `docker-machine ip manager`</code> </pre> <br><p>  Now we need two working nodes.  To do this, you must transfer the <em>Join Token</em> and IP published when creating the swarm.  To get the token, issue the <code>docker swarm join-token -q worker</code> .  The <code>docker-machine ip manager</code> , as before, will allow you to get the IP manager and its standard port 2377. We could add new machines to the swarm by switching to the context of each work node, but it is much easier to execute these commands via SSH.  To attach the work nodes to the swarm, run the following commands: </p><br><pre> <code class="bash hljs">docker-machine ssh agent1 docker swarm join --token `docker swarm join-token -q worker` `docker-machine ip manager`:2377 docker-machine ssh agent2 docker swarm join --token `docker swarm join-token -q worker` `docker-machine ip manager`:2377</code> </pre> <br><p>  The list of members in a swarm of nodes can be displayed using the <code>docker node ls</code> .  After adding work nodes, the output should look like this: </p><br><pre> <code class="bash hljs">ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS 3j231njh03spl0j8h67z069cy * manager Ready Active Leader muxpteij6aldkixnl31f0asar agent1 Ready Active y2gstaqpqix1exz09nyjn8z41 agent2 Ready Active</code> </pre> <br><h2 id="docker-stack">  Docker stack </h2><br><p>  With the third version of <strong>docker-compose</strong> file in one file, you can define the entire service stack, including the deployment strategy, and deploy it with a single command, <strong>deploy</strong> .  The main difference between the third version of the docker-compose file and the second one was the appearance of the <em>deploy</em> parameter in the description of each service.  This parameter defines the way containers are deployed.  The <strong>docker-compose</strong> file for the test monitoring system is shown below: </p><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">version:</span></span> <span class="hljs-string"><span class="hljs-string">'3'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">services:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">influx:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">image:</span></span> influxdb <span class="hljs-symbol"><span class="hljs-symbol">volumes:</span></span> - <span class="hljs-symbol"><span class="hljs-symbol">influx:</span></span>/var/lib/influxdb <span class="hljs-symbol"><span class="hljs-symbol">deploy:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">replicas:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">placement:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">constraints:</span></span> - node.role == manager <span class="hljs-symbol"><span class="hljs-symbol">grafana:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">image:</span></span> grafana/grafana <span class="hljs-symbol"><span class="hljs-symbol">ports:</span></span> - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">80</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">volumes:</span></span> - <span class="hljs-symbol"><span class="hljs-symbol">grafana:</span></span>/var/lib/grafana <span class="hljs-symbol"><span class="hljs-symbol">depends_on:</span></span> - influx <span class="hljs-symbol"><span class="hljs-symbol">deploy:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">replicas:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">placement:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">constraints:</span></span> - node.role == manager <span class="hljs-symbol"><span class="hljs-symbol">cadvisor:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">image:</span></span> google/cadvisor <span class="hljs-symbol"><span class="hljs-symbol">hostname:</span></span> <span class="hljs-string"><span class="hljs-string">'{{.Node.ID}}'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">command:</span></span> -logtostderr -docker_only -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=<span class="hljs-symbol"><span class="hljs-symbol">influx:</span></span><span class="hljs-number"><span class="hljs-number">8086</span></span> <span class="hljs-symbol"><span class="hljs-symbol">volumes:</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/:/rootfs</span></span><span class="hljs-symbol"><span class="hljs-symbol">:ro</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/var/run</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/var/run</span></span><span class="hljs-symbol"><span class="hljs-symbol">:rw</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/sys:/sys</span></span><span class="hljs-symbol"><span class="hljs-symbol">:ro</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/var/lib</span></span><span class="hljs-regexp"><span class="hljs-regexp">/docker/</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/var/lib/docker</span></span><span class="hljs-symbol"><span class="hljs-symbol">:ro</span></span> <span class="hljs-symbol"><span class="hljs-symbol">depends_on:</span></span> - influx <span class="hljs-symbol"><span class="hljs-symbol">deploy:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> global <span class="hljs-symbol"><span class="hljs-symbol">volumes:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">influx:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">driver:</span></span> local <span class="hljs-symbol"><span class="hljs-symbol">grafana:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">driver:</span></span> local</code> </pre> <br><p>  Our stack has 3 services, which are described below. </p><br><h3 id="influx">  influx </h3><br><p>  Here we will use the <em>influxdb</em> image.  For persistent storage, create the <em>influx</em> volume, which will be mounted in the container folder <em>/ var / lib / influxdb</em> .  We only need one copy of InfluxDB, which will be hosted on the host <strong>manager</strong> .  The docker server is running on the same host, so the commands for the container can be executed here.  Since both of the remaining services need influxDB, we will add the <em>depends_on</em> key with the value <em>influx</em> to the description of these services. </p><br><h3 id="grafana-1">  grafana </h3><br><p>  We will use the image of <em>grafana / grafana</em> and <em>forward the</em> 3000th port of the container to the 80th port of the host.  <strong>The route grid</strong> allows you to connect to the grafana through the 80th port of any host that is part of the swarm.  To permanently store data, create another volume called <em>grafana</em> .  It will be mounted in the container folder <em>/ var / lib / grafana</em> .  Grafana will also be deployed to the host <strong>manager</strong> . </p><br><h3 id="cadvisor-1">  cadvisor </h3><br><p>  To configure cAdvisor, you will have to work a little more than with previous services.  More information is available at <a href="https://github.com/google/cadvisor">this link</a> .  The choice of the <em>hostname</em> value in this case is not an easy task.  We are going to install agents on each node, and this container will collect the metrics of the node and the containers working on it.  When cAdvisor sends metrics to InfluxDB, it sets the <em>machine</em> tag, which contains the name of the container with cAdvisor.  Its value must match the ID of the node on which it is running.  In Docker stacks you can use patterns in the names.  More information can be found <a href="">here</a> .  We gave the containers names containing the ID of the node on which they are running, and thus we can determine where the metric came from.  This is achieved using the following expression <code>'{{.Node.ID}}'</code> . </p><br><p>  We will also add several command line options to cadvisor.  The <em>logtostderr option</em> redirects the <em>cadvsior</em> generated logs to <em>stderr</em> , which makes debugging easier.  The <em>docker_only</em> flag says that we are only interested in docker containers.  The following three parameters determine the location in the repository where the collected metrics should be placed.  We will ask cAdvisor to put them in the <em>cadvisor</em> database on the InfluxDB server listening to <em>influx: 8086</em> .  This will enable us to send metrics to the influx service of our stack.  Inside the stack, all ports are open (exposed), so they do not need to be specified separately. </p><br><p>  The volumes specified in the file are needed by cAdvisor to collect metrics from the host and docker.  To deploy cadvisor, we will use the <em>global</em> mode.  This will ensure that only one instance of the cadvisor service is executed on each node of the swarm. </p><br><p>  At the end of the file we have the key <em>volumes</em> in which the <em>influx</em> and <em>grafana</em> volumes are indicated.  Since both volumes will be hosted on the <strong>manager's</strong> host, we will assign the <em>local</em> driver for them. </p><br><p>  To deploy the stack, save the above file as <em>docker-stack.yml</em> and run the following command: </p><br><pre> <code class="bash hljs">docker stack deploy -c docker-stack.yml monitor</code> </pre> <br><p>  It will start the stack <em>monitor</em> services.  The first launch of the command may take some time, since nodes must load images of containers.  You will also need to create a database for storing metrics called <em>cadvisor in InfluxDB</em> . </p><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> `docker ps | grep -i influx | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span>` influx -execute <span class="hljs-string"><span class="hljs-string">'CREATE DATABASE cadvisor'</span></span></code> </pre> <br><p>  The execution of the command may fail with the message that the <em>influx</em> container does not exist.  The reason for the error is that the container is not ready yet.  Wait a bit and execute the command again.  We can execute commands in the <em>influx</em> service, since it is running on the <strong>manager manager</strong> and we use the docker installed here.  To find out the container ID with InfluxDB, you can use the <code>docker ps | grep -i influx | awk '{print $1}'</code> <code>docker ps | grep -i influx | awk '{print $1}'</code>  <code>docker ps | grep -i influx | awk '{print $1}'</code> , and to create a database named <em>cadvisor,</em> execute the command <code>influx -execute 'CREATE DATABASE cadvisor'</code> . </p><br><p>  To display a list of stack services, run the <code>docker stack services monitor</code> .  The output of the command will look something like this: </p><br><pre> <code class="bash hljs">ID NAME MODE REPLICAS IMAGE 0fru8w12pqdx monitor_influx replicated 1/1 influxdb:latest m4r34h5ho984 monitor_grafana replicated 1/1 grafana/grafana:latest s1yeap330m7e monitor_cadvisor global 3/3 google/cadvisor:latest</code> </pre> <br><p>  The list of running containers can be obtained from the command <code>docker stack ps monitor</code> , the output of which will be something like this: </p><br><pre> <code class="bash hljs">ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS n7kobaozqzj6 monitor_cadvisor.y78ac29r904m8uy6hxffb7uvn google/cadvisor:latest agent2 Running Running about a minute ago 1nsispop3hsu monitor_cadvisor.z52c9vloiutl5dbuj5lnykzvl google/cadvisor:latest agent1 Running Running about a minute ago 9n6djc80mamd monitor_cadvisor.qn82bfj5cpin2cpmx9qv1j56s google/cadvisor:latest manager Running Running about a minute ago hyr8piriwa0x monitor_grafana.1 grafana/grafana:latest manager Running Running about a minute ago zk7u8g73ko5w monitor_influx.1 influxdb:latest manager Running Running about a minute ago</code> </pre> <br><h2 id="nastroyka-grafana">  Grafana Setup </h2><br><p>  After all the services are deployed, you can open the grafana.  For this, the IP of any node of the swarm is suitable.  We will specify the IP manager by running the following command: </p><br><pre> <code class="bash hljs">open http://`docker-machine ip manager`</code> </pre> <br><p>  The default login for grafana is <em>admin</em> username and <em>admin</em> password.  InfluxDB should be added to grafana as a data source.  On the home page should be a link to <strong>Create your first data source</strong> , click on it.  If there is no link, select <strong>Add data source</strong> from the <strong>Data Sources</strong> menu, which will open the form for adding a new Data Source. </p><br><img src="https://habrastorage.org/files/d20/30a/5aa/d2030a5aaec9462bb67d4a8b8d2f2251.jpg"><br><p>  <em>Adding Data Source to Grafana</em> </p><br><p>  The data source can be given any name.  Check the <em>default</em> checkbox so that you don‚Äôt have to specify it in other forms in the future.  Next, set the Type to <strong>InfluxDB</strong> , the URL is <strong><a href="http://influx:8086/">http: // influx: 8086</a></strong> and Access - <strong>proxy</strong> .  So we pointed to our InfluxDb container.  In the Database field, enter <strong>cadvisor</strong> and click <strong>Save and Test</strong> ‚Äî the message <strong>Data source is working</strong> should appear. </p><br><p>  In the <a href="https://github.com/botleg/swarm-monitoring">github repository of the</a> project there is a <em>dashboard.json</em> file created for importing into Grafana.  It describes the dashboard for monitoring systems and containers that run in a swarm.  Now we are only importing this toolbar, and we'll talk about it in the next section.  Hover over the <strong>Dashboards</strong> menu item and select <strong>Import Option</strong> .  Click the <strong>Upload .json file</strong> button and select <em>dashboard.json</em> .  Next, select the data source and click the <strong>Import</strong> button. </p><br><h3 id="grafana-dashboard">  Grafana dashboard </h3><br><img src="https://habrastorage.org/files/2bb/a78/809/2bba788094c4456b8185ce5590201936.jpg"><br><p>  <em>Grafana dashboard</em> </p><br><p>  The toolbar imported into Grafana is designed to monitor hosts and containers of the swarm.  You can drill down to the level of the host and the containers running on it.  We need two variables, which require the functionality of working with templates to add to the Grafana toolbar.  More information about working with templates in conjunction with InfluxDB is on <a href="http://docs.grafana.org/features/datasources/influxdb/">this page</a> .  We have two variables: <em>host</em> to select the node and <em>container</em> to select the container.  To see these variables, on the toolbar page, select <strong>Settings</strong> and click <strong>Templating</strong> . </p><br><p>  The first variable, <em>host</em> , allows you to select a node and its metrics.  When cAdvisor sends metrics to InfluxDB, it adds several tags to them that can be used for filtering.  We have a tag called <em>machine</em> that contains the hostname of the cAdvisor instance.  In this case, it will match the host ID in the swarm.  To get the tag values, use the query <code>show tag values with key = "machine"</code> . </p><br><p>  The second variable, <em>container</em> , allows you to drill down to the report level.  We have a tag called <em>container_name</em> , which quite predictably contains the name of the container.  We also need to filter the metrics by the value of the <em>host</em> tag.  The query will look like this: <code>show tag values with key = "container_name" WHERE machine =~ /^$host$/</code> .  It will return to us a list of containers in which the <em>host</em> variable contains the name of the host of interest. </p><br><p>  The container name will look something like this: </p><br><p>  <em>monitor_cadvisor.y78ac29r904m8uy6hxffb7uvn.3j231njh03spl0j8h67z069cy</em> .  However, we are only interested in its <em>monitor_cadvisor-parts</em> (up to the first point).  If several instances of the same service are running, their data will need to be output in separate lines.  To get a substring up to the first point, apply the regular expression / (/ <code>/([^.]+)/</code> . <code>/([^.]+)/</code> . </p><br><p>  We set up variables, now we can use them in charts.  Further, the conversation will focus on the graphics <strong>Memory</strong> , and with the rest you can work on the same principle.  Data related to memory is in InfluxDB in the <em>memory_usage row</em> , so the query will start with <code>SELECT "value" FROM "memory_usage"</code> . </p><br><p>  Now you need to add filters to the <em>WHERE clause</em> .  The first condition will be if the <em>machine is</em> equal to the value of the <em>host</em> variable: <code>"machine" =~ /^$host$/</code> .  In the following condition, <em>container_name</em> must begin with the value of the variable <em>container</em> .  Here we will use the ‚Äústarts with‚Äù operator, since we have filtered the <em>container</em> variable to the first point: <code>"container_name" =~ /^$container$*/</code> .  The latter condition imposes a limit on the time of events in accordance with the time interval <em>$ timeFilter</em> selected in the grafana toolbar.  The query now looks like this: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"memory_usage"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-string"><span class="hljs-string">"container_name"</span></span> =~ /^$<span class="hljs-keyword"><span class="hljs-keyword">container</span></span>$*/ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">"machine"</span></span> =~ /^$host$/ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> $timeFilter</code> </pre> <br><p>  Since we need separate lines for different hosts and containers, we need to group the data based on the values ‚Äã‚Äãof the <em>machine</em> and <em>container_name</em> tags: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"memory_usage"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-string"><span class="hljs-string">"container_name"</span></span> =~ /^$<span class="hljs-keyword"><span class="hljs-keyword">container</span></span>$*/ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">"machine"</span></span> =~ /^$host$/ <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> $timeFilter <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-string"><span class="hljs-string">"machine"</span></span>, <span class="hljs-string"><span class="hljs-string">"container_name"</span></span></code> </pre> <br><p>  We also created an alias for this request: <code>Memory {host: $tag_machine, container: $tag_container_name}</code> .  Here <em>$ tag_machine</em> will be replaced with the value of the <em>machine</em> tag, and <em>tag_container_name</em> will be replaced with the value of the <em>container_name</em> tag.  The remaining graphs are configured in a similar way, only the names of the series change.  You can create alerts for these metrics in Grafana.  For more information about the alert system (Alerting), see <a href="http://docs.grafana.org/alerting/rules/">here</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, we created a scalable monitoring system for Docker Swarm, which automatically collects metrics from all the hosts and containers in the swarm.  In the process, we learned about the popular open source tools: Grafana, InfluxDB and cAdvisor. </p><br><p>  After completing the demonstration, the stack can be removed with the command: </p><br><pre> <code class="bash hljs">docker stack rm monitor</code> </pre> <br><p>  Unnecessary virtual machines are stopped and deleted by the commands: </p><br><pre> <code class="bash hljs">docker-machine stop manager agent1 agent2 docker-machine rm -f manager agent1 agent2</code> </pre> <br><p>  References: </p><br><ol><li>  Original: <a href="https://botleg.com/stories/monitoring-docker-swarm-with-cadvisor-influxdb-and-grafana/">Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</a> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327670/">https://habr.com/ru/post/327670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327656/index.html">The digest of interesting materials for the mobile developer # 201 (April 24 - 30)</a></li>
<li><a href="../327658/index.html">What's new in Rails 5.1</a></li>
<li><a href="../327662/index.html">Swift Generics: Styles for UIView and more. # 1</a></li>
<li><a href="../327666/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ260 (April 24 - 30, 2017)</a></li>
<li><a href="../327668/index.html">Quick start on React Native</a></li>
<li><a href="../327674/index.html">Bucardo: Multimaster replication</a></li>
<li><a href="../327676/index.html">We raise our VPN server on Amazon EC2 under Windows Server 2008 r2</a></li>
<li><a href="../327678/index.html">Linus Torvalds introduced the Linux kernel 4.11</a></li>
<li><a href="../327680/index.html">Crowd Marketing: Top 10 Popular Questions</a></li>
<li><a href="../327682/index.html">Encryption in EXT4. How it works?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>