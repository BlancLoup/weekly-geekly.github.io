<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda the ripper</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Although Java 9 was recently released with a new modular system, many still continue to use the usual eighth version, with lambdas. For six months, I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda the ripper</h1><div class="post__text post__text-html js-mediator-article"><p>  Although <a href="https://docs.oracle.com/javase/9/whatsnew/">Java 9 was</a> recently <a href="https://docs.oracle.com/javase/9/whatsnew/">released</a> with a new modular system, many still continue to use the usual eighth version, with lambdas.  For six months, I worked closely with her and all her innovations.  If everything is clear with the new collection and Optional methods, it‚Äôs not so obvious with lambdas.  In particular, how they are implemented and how they affect performance.  And most importantly - how do they differ from the good old anonymous classes. </p><br><img src="https://habrastorage.org/webt/zh/vg/_9/zhvg_9irphcayzbjxf50n9jb194.png"><a name="habracut"></a><br><br>  In this article, I will not understand the syntax of Java 8 - there are enough such articles and books already written.  I was interested in the questions of how this all works, so I decided: <br><br><ol><li>  Understand the theory </li><li>  See what's inside the lambda </li><li>  Understand their performance impact. </li></ol><br><h2>  Quite a bit of theory </h2><br><p>  For a start, it would be nice to deal with the types of lambda.  It's all quite simple, there are two types: </p><br><ul><li>  <strong>Non-capturing</strong> - the most simple, not tied to the environment.  Do not contain references to external variables.  Do not call instance methods.  Can call static methods. </li><li>  <strong>Capturing</strong> - have a connection with the outside world, such functions are also called <strong>closures</strong> .  They, in turn, can be divided into two subtypes: those that refer to variables inside a method or class, and those that call an instance method. </li></ul><br><h2>  First approximation </h2><br><p>  I will act in order.  Let's see how the code compiles with lambdas.  Let's take the simplest example that creates and immediately causes lambda: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestRun</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{   ((Callable&lt;Integer&gt;) (() -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>)).call();  } }</code> </pre> <br><p>  While I have enough standard functionality built into the JDK.  To view the contents of a class file, you can use: </p><br><p>  <em>javap -p -c -v -constants TestRun.class</em> </p><br><p>  This command will output the contents of the methods and the <em>constant pool</em> for the class: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Constant</span></span> pool:        #<span class="hljs-number"><span class="hljs-number">2</span></span> = InvokeDynamic    #<span class="hljs-number"><span class="hljs-number">0</span></span>:#<span class="hljs-number"><span class="hljs-number">30</span></span>     // #<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>:()Ljava/util/concurrent/Callable;        #<span class="hljs-number"><span class="hljs-number">3</span></span> = InterfaceMethodref #<span class="hljs-number"><span class="hljs-number">31.</span></span>#<span class="hljs-number"><span class="hljs-number">32</span></span>     // java/util/concurrent/Callable.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>:()Ljava/lang/<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>;        #<span class="hljs-number"><span class="hljs-number">4</span></span> = Methodref      #<span class="hljs-number"><span class="hljs-number">33.</span></span>#<span class="hljs-number"><span class="hljs-number">34</span></span>     // java/lang/<span class="hljs-type"><span class="hljs-type">Integer</span></span>.valueOf:(I)Ljava/lang/<span class="hljs-type"><span class="hljs-type">Integer</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> main(java.lang.String[]) throws java.lang.<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>; Code:        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokedynamic #<span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-number"><span class="hljs-number">0</span></span>        // InvokeDynamic #<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>:()Ljava/util/concurrent/Callable;        <span class="hljs-number"><span class="hljs-number">5</span></span>: invokeinterface #<span class="hljs-number"><span class="hljs-number">3</span></span>,  <span class="hljs-number"><span class="hljs-number">1</span></span>       // InterfaceMethod java/util/concurrent/Callable.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>:()Ljava/lang/<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>; private static java.lang.Integer lambda$main$<span class="pgsql"><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql">() throws java.lang.</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">Exception</span></span></span><span class="pgsql">; Code:        </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql">: bipush     </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">10</span></span></span><span class="pgsql">        </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql">: invokestatic  #</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">4</span></span></span><span class="pgsql">          // </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">Method</span></span></span><span class="pgsql"> java/lang/</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">Integer</span></span></span><span class="pgsql">.valueOf:(I)Ljava/lang/</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">Integer</span></span></span><span class="pgsql">;        </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">5</span></span></span><span class="pgsql">: areturn</span></span></code> </pre> <br><p>  In the <em>main</em> method there are only two instructions: <em>invokedynamic</em> creates an instance of a certain class, and <em>invokeinterface</em> calls the <em>call ()</em> method on the object that lies on the stack.  There is also a constant pool in the class, it contains the description of the # 2 method for which the lambda will be created, and # 3 the description of the interface method.  A strange <em>lambda $ main $ 0 ()</em> method also appeared, which we did not order.  But if you look closely, then it contains the lambda code: it creates an <em>Integer</em> variable and returns it.  It is referred to by structure # 2 of the <em>constant pool</em> . </p><br><p>  Just a couple of links: <br>  - <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">Invokedynamic instruction specification</a> <br>  - <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Structure description from constant pool</a> </p><br><p>  This example gives more questions than answers.  It is completely incomprehensible how the call to the interface method leads us to the generated <em>lambda $ main $ 0 ()</em> .  To clarify this will have to climb into the contents of the lambda. </p><br><h2>  What gut? </h2><br><p>  To move on, I will need special tools.  I would like to know what is inside the objects from which we call the method.  For these purposes, you can use an additional parameter: </p><br><p>  <em>-Djdk.internal.lambda.dumpProxyClasses = [dir]</em> </p><br><p>  If you add it, then at runtime we get in the <em>[dir]</em> folder of the proxy classes that the factory generates. </p><br><h2>  Lambdas easier </h2><br><p>  I will move further from simple too.  First, I will analyze an example with lambdas that do not contain references to the surrounding context: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonCapturing</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{  Callable&lt;Integer&gt; r = () -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>; } }</code> </pre> <br><p>  The code will generate <em>TestNonCapturing $$ Lambda $ 1.class</em> , which is very simple: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonCapturing</span></span></span><span class="hljs-class">$$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lambda</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TestNonCapturing$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>() { } <span class="hljs-meta"><span class="hljs-meta">@Hidden</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TestNonCapturing.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(); } }</code> </pre> <br><p>  This is the final class that works with a statically generated method <em>TestNonCapturing.lambda $ main $ 0 ()</em> .  The calling code from <em>main</em> accesses its own method through a wrapper that the <em>invokedynamic</em> instruction will <em>generate</em> at runtime. </p><br><h2>  Lambda more difficult </h2><br><p>  Now we will look inside lambdas which refer to environment variables.  For this, it suffices, for example, to refer to the method variable in which the lambda is created: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCapturingVariable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> methodVariable = <span class="hljs-number"><span class="hljs-number">5</span></span>;  Callable&lt;Integer&gt; r = () -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> + methodVariable; } }</code> </pre> <br><p>  <em>TestCapturingVariable $$ Lambda $ 1.class</em> will be a bit more complicated: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCapturingVariable</span></span></span><span class="hljs-class">$$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lambda</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg$<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TestCapturingVariable$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var1) {  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg$<span class="hljs-number"><span class="hljs-number">1</span></span> = var1; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Callable get$Lambda(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var0) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestCapturingVariable$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>(var0); } <span class="hljs-meta"><span class="hljs-meta">@Hidden</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TestCapturingVariable.lambda$main$<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg$<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><p>  Here the context has already appeared, the constructor has the argument <em>int var1</em> .  By calling <em>TestCapturingVariable.lambda $ main $ 0</em> , we pass the local variable <em>arg $ 1</em> .  A copy of the lambda is obtained through the getter.  Why did the getter appear over the constructor - I honestly do not know.  I guess these are implementation details in the JVM.  If you have an answer to this question, I will be glad to know it in the comments. </p><br><p>  Let me try to complicate the example a bit and add a call to the class instance method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCapturingMethod</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{  TestCapturingMethod v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestCapturingMethod();  Callable&lt;Integer&gt; r = v::instanceMethod; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instanceMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; } }</code> </pre> <br><p>  <strong>Suddenly:</strong> <em>Exception in thread "main" java.lang.VerifyError</em> </p><br><p>  In this case, the JVM was embarrassed by the fact that the <em>instanceMethod is</em> private and is being called from another class.  You can make it public or add <em>‚Äìnoverify</em> to the command line.  The contents of the <em>TestCapturingMethod $$ Lambda $ 1.class</em> will be as follows: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCapturingMethod</span></span></span><span class="hljs-class">$$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lambda</span></span></span><span class="hljs-class">$1 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestCapturingMethod arg$<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TestCapturingMethod$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>(TestCapturingMethod var1) {  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg$<span class="hljs-number"><span class="hljs-number">1</span></span> = var1; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Callable get$Lambda(TestCapturingMethod var0) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestCapturingMethod$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>(var0); } <span class="hljs-meta"><span class="hljs-meta">@Hidden</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg$<span class="hljs-number"><span class="hljs-number">1</span></span>.instanceMethod()); } }</code> </pre> <br><p>  As can be seen from the decompiled code, the difference is small, <em>arg $ 1</em> from the parameter turned into an instance of the class that has the method called.  In the method <em>call ()</em> still appeared autoboxing. </p><br><h2>  How it works </h2><br><p>  Now it is more or less clear what is inside the objects themselves.  Let me try to figure out how this works and whether there are differences between closures and simple lambdas in this example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaRun</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local = <span class="hljs-number"><span class="hljs-number">10</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) {   Callable&lt;Integer&gt; nonCapturing =  () -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>;   Callable&lt;Integer&gt; capturing =  () -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> + local;   System.out.println(<span class="hljs-string"><span class="hljs-string">"Non-capturing: "</span></span> + nonCapturing.hashCode());   System.out.println(<span class="hljs-string"><span class="hljs-string">"Capturing: "</span></span> + capturing.hashCode());  } } }</code> </pre> <br><p>  Here, in the loop, exciting and non-capturing lambdas are generated, then their hash is printed.  The output will be something like this: </p><br><pre> <code class="hljs">Capturing: 231987608 Non-capturing: 1595428806 Capturing: 1549385383 Non-capturing: 1595428806 Capturing: 1879451745 Non-capturing: 1595428806</code> </pre> <br><p>  Obviously, in one case, a new object is created each time, but not in the other.  It seems that the JVM has optimized something, and the lambda factory generates new objects only when it is really necessary.  It is logical to use the object again if its content does not depend on the environment.  When you call a lambda that captures the context, a new object will be created each time - and this case is of greater interest for research, since  GC load may be implicitly added.  But it also turned out not so simple. </p><br><h2>  To stack or not to stack </h2><br><p>  The enlightened reader will notice that if the object is not beyond the scope of the method, then it will most likely fall under the <em>escape analysis</em> , it will be created on the stack and there will be no load on the GC.  But who causes the lambda in the same method where it creates them?  The basic idea here: lambda is a higher-order function, a function that accepts or returns another function.  Thus, lambda almost always goes beyond the boundaries of the method where it was created.  Any book or article on Java 8 is filled with similar examples. </p><br><p>  An even more enlightened reader will notice that sometimes methods can be included into each other by the JIT compiler at runtime ‚Äî and then the <em>escape analysis</em> will work. </p><br><p>  Just a couple of links on the topic: <br>  - <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html">Escape analysis</a> <br>  - <a href="http://www.oracle.com/technetwork/java/whitepaper-135217.html">Method inlining</a> </p><br><p>  Take the following example.  If before that the examples were artificial, then this one is close to reality.  In the loop, a closure is created that is created in a separate method, which can be considered a higher order function: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CapturingLambdaLongRun</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{  CapturingLambdaLongRun run = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CapturingLambdaLongRun();  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) {   getLambda(run).run();  } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Runnable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CapturingLambdaLongRun run)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; {   run.i++;  }; } }</code> </pre> <br><p>  I will run this code under VisualVM for one minute: </p><br><img src="https://habrastorage.org/webt/ku/nk/su/kunksusrhcu_rmp_byqrghyxouy.png"><br><p>  Strangely enough, there is nothing criminal here, although a new object should be created for every <em>getLambda</em> call.  Now I will try to disable inline by adding the <em>-XX</em> parameter <em>: MaxInlineLevel = 0</em> .  And here the picture changes a lot: </p><br><img src="https://habrastorage.org/webt/xo/-r/9w/xo-r9wwrxkfla-5cmgxnlzsgnqi.png"><br><p>  Why at first everything was smooth and smooth, and then changed?  When JIT worked to its fullest and I did not put a stick in his wheels, the <em>getLambda</em> method <em>was</em> included in main, and the new Runnable was allocated on the method stack.  Therefore, there were no problems.  When disconnecting inline, everything began to work exactly as it looks in Java code, both optimizations were turned off ( <em>inlining</em> , followed by <em>escape analysis</em> ), and there was a load on the GC, since  creation of objects passed from stack to heap. </p><br><p>  In this example, I artificially turned off the optimization, but I think it is easy to imagine the following situations: </p><br><ul><li>  In the process of project development, the closure method has grown and ceased to inline due to restriction.  By default, <em>MaxInlineSize = 35</em> . </li><li>  When refactoring, the environment variable was added to the large method that creates the lambda, so the type changed and a new object on the heap was created for each call. </li></ul><br><h2>  Total </h2><br><p>  It's time to summarize my little research.  What did you find out: <br>  - There are different types of lambda expressions: although they have the same syntax, inside they are arranged differently and work differently. <br>  - Quite discreetly, you can switch from one type of lambda to another, thus changing the load on the GC. <br>  - The lambda method call itself is no different from any other method call, there is no reflection here. </p><br><p>  And a couple of words about the good old anonymous classes, I will try to compare them with lambda expressions: </p><br><p>  - An anonymous class is generated at compile time, the lambda code creates a factory at run time. <br>  - Code generation on the fly can be faster than loading from the <em>classpath</em> .  Since  A call to the <em>classpath</em> may cause a disk read, some tests confirm that a cold start is faster for lambdas than for anonymous classes. <br>  - The code of the lambda is placed in the generated method of the same class where it is created.  All the code of the anonymous class is contained in it. <br>  - Anonymous classes have explicit syntax.  We know for sure that one object will be created for each call.  Non-capturing lambdas here make optimization and implicitly reuse one object. </p><br><h2>  How to live on </h2><br><p>  I hope this article has helped lift the veil of secrecy.  Understand how lambda expressions work and what's inside them.  Now I consciously add the dependence of the closures on the surrounding context, knowing what this may lead to.  What to do next with all this information: </p><br><p>  - If you are developing an application that does not have strict performance requirements, then you can rely on the JIT compiler.  In most cases, he saves.  But even here one should not forget about such simple rules as, for example, not to make big methods.  This affects not only readability. <br>  - In the critical load code, you need to be careful with lambdas.  If they suddenly turn into closures, this may have consequences.  Therefore: <br>  - Avoid references to method variables or class instance. <br>  - It is best to refer to static methods </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/343624/">https://habr.com/ru/post/343624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343610/index.html">PHP 7.2.0 released</a></li>
<li><a href="../343612/index.html">About creating payloads for different platforms using msfvenom</a></li>
<li><a href="../343614/index.html">Learn CSS Grid in 5 minutes</a></li>
<li><a href="../343616/index.html">Another Telegram-bot for video surveillance</a></li>
<li><a href="../343622/index.html">Eight C ++ 17 features that every developer should use</a></li>
<li><a href="../343628/index.html">DevDay about microservices. Record the best reports</a></li>
<li><a href="../343630/index.html">Indie developer started phone tech support, and that's what happened</a></li>
<li><a href="../343632/index.html">How much does a CRM system cost?</a></li>
<li><a href="../343634/index.html">Announcement of the meeting WordPress Meetup # 4 in Kharkov</a></li>
<li><a href="../343636/index.html">XML string constructor from PHP array</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>