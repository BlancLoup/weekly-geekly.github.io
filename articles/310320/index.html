<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The language of arithmetic expressions with the let construction as dsl on Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the cat, the implementation of the language of simple arithmetic expressions with let construction will be described. Reading will be interestin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The language of arithmetic expressions with the let construction as dsl on Kotlin</h1><div class="post__text post__text-html js-mediator-article">  Under the cat, the implementation of the language of simple arithmetic expressions with let construction will be described.  Reading will be interesting for people who are not familiar with the language of kotlin or who are just starting their way into functional programming. <br><br><pre><code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>) * <span class="hljs-number"><span class="hljs-number">2016</span></span> where (<span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (<span class="hljs-string"><span class="hljs-string">"habr"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  In the article, the reader will get acquainted with such Kotlin constructions as extensions function, pattern matching, operator overriding, infix functions and some principles of functional programming.  Writing a parser is not included in the topic of the article; therefore, we will implement our language inside the kotlin language, like the scripting languages ‚Äã‚Äãof the build systems with respect to the scripting languages ‚Äã‚Äãthat were first written (grodle: groovy).  The material is served in sufficient detail.  Preferred knowledge of Java. <br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br><ul><li>  determine the syntax of the language of arithmetic expressions; </li><li>  implement the calculation; </li><li>  adhere to the principles of functional programming </li></ul><br>  In our language there must be integer constants, named expressions (let, where), addition and multiplication operations (for simplicity). <br><br><h3>  Syntax </h3><br><ul><li>  <code>const(2)</code> is a constant; </li><li>  <code>variable("x")</code> is a named expression.  ‚ÄúX‚Äù is not a variable in terms of the value assignment operation.  This is just the name of a certain expression defined before or after the current expression; </li><li>  <code>const(2) + const(2)</code> is an example of the addition operation; </li><li>  <code>variable("y") * 2</code> is an example of a multiply operation; </li><li>  <code>variable("y") * const(2)</code> is an example of a multiply operation; </li><li>  <code>"x" let (const(2)) inExr (variable("x") * 4)</code> is an example of a variable naming operation in an expression; </li><li>  <code>(variable("x") * 4) where ("x" to 1)</code> is an example of a variable naming operation in an expression. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Implementation </h3><br>  To formalize the syntax of a language, it is convenient to represent expressions in the <a href="https://en.wikipedia.org/wiki/Backus%25E2%2580%2593Naur_Form">Backus ‚Äì Naur form</a> .  In this scheme, number is an integer, string is a string from the standard library: <br><br><pre> <code class="hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> ::= (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span>) | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">const</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">operator</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">const</span></span></span><span class="hljs-tag">&gt;</span></span> := const(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">number</span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> := variable(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag">&gt;</span></span> := <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> let <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">number</span></span></span><span class="hljs-tag">&gt;</span></span> inExpr (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span>) | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> let <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> inExpr (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span>) | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag">&gt;</span></span> := (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span>) where (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pair</span></span></span><span class="hljs-tag">&gt;</span></span> ) | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag">&gt;</span></span> and (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pair</span></span></span><span class="hljs-tag">&gt;</span></span> ) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">let</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">where</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pair</span></span></span><span class="hljs-tag">&gt;</span></span> ::= <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">const</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">number</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">var</span></span></span><span class="hljs-tag">&gt;</span></span> to (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">operator</span></span></span><span class="hljs-tag">&gt;</span></span> := <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> * <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> + <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> * <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">number</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">expr</span></span></span><span class="hljs-tag">&gt;</span></span> + <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">number</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Where possible, const is replaced by number for concise syntax.  The issues of its implementation will be described at the end of the article.  Now we will be interested in the calculation. <br><br><h3>  Calculations </h3><br>  We describe the structure of terms in the form of classes.  We will use the sealed class, since it will be convenient for us to use it as a <a href="https://kotlinlang.org/docs/reference/control-flow.html">model</a> .  In Cotlin, the pattern matching mechanism is syntactic sugar over switch case, isInstace from java constructs, but not a full-fledged comparison with a sample from the world of functional languages. <br><br><pre> <code class="hljs pgsql">sealed <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Expr { //     <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Const(val c: <span class="hljs-type"><span class="hljs-type">Int</span></span>): Expr() //    <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Var(val <span class="hljs-type"><span class="hljs-type">name</span></span> : String) : Expr() //let         ,     //        <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Let(val <span class="hljs-type"><span class="hljs-type">name</span></span>: String, val <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: Expr, val expr: Expr) : Expr() //  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Sum(val left : Expr, val right: Expr) : Expr() //  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Sum(val left : Expr, val right: Expr) : Expr() override fun toString(): String = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(this) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Const -&gt; "$c" <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Sum -&gt; "($left + $right)" <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Mult -&gt; "($left * $right)" <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Var -&gt; <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Let -&gt; "($expr, where $name = $value)" } }</code> </pre><br>  Depending on the type of expr, we get the available fields defined in its descendants.  This is implemented with the help of <a href="https://kotlinlang.org/docs/reference/typecasts.html">smart-casts</a> : implicit type casting inside the body of <code>if (obj is Type)</code> structures.  In similar code in java, you would have to manually type types. <br><br>  Now we can describe expressions by exporting the constructors of classes-heirs Expr, and so far this is enough for us.  In the syntax section, we describe functions that allow you to write expressions more succinctly. <br><br><pre> <code class="hljs vbscript">val example = Expr.Sum(Expr.<span class="hljs-keyword"><span class="hljs-keyword">Const</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), Expr.<span class="hljs-keyword"><span class="hljs-keyword">Const</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br>  We will calculate expressions with the help of a recursive function by successively ‚Äúexpanding‚Äù expressions.  Then it's time to remember about naming.  To implement the let construct, we need to store the named expressions somewhere.  Let us introduce the notion of calculation context: a list of pairs name -&gt; expression <code>context: Map&lt;String, Expr?&gt;</code> .  If you encounter a variable in the course of the calculation, we need to get the expression out of context. <br><br><pre> <code class="hljs pgsql">fun solve(expr: Expr, context: Map&lt;String, Expr? &gt;? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) : Expr.Const = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (expr) { //     ,   <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Const -&gt; expr //       <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Mult -&gt; Expr.Const(solve(expr.left, context).c * solve(expr.right, context).c) //       <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Sum -&gt; Expr.Const(solve(expr.left, context).c + solve(expr.right, context).c) //      <span class="hljs-type"><span class="hljs-type">name</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>    expr    <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Let -&gt; { val newContext = context.orEmpty() + Pair(expr.name, expr.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) solve(expr.expr, newContext) } //     expr.name,   ,     <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Var -&gt; { val exprFormContext : Expr? = context?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(expr.name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exprFormContext == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw IllegalArgumentException("undefined var ${expr.name}") } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { solve(exprFormContext, context!!.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { it.key != expr.name }) } } }</code> </pre> <br>  A few words about the code: <br><br><ul><li>  The context uses immutable objects.  This means that by adding a new pair to the context, we get a new context.  This is important for subsequent calculations: functions called from this should not change the current context.  This is a fairly common approach in functional programming. </li><li>  From the point of view of pure functions and their calculations, exceptions are not allowed.  The function should define the mapping of one set to another.  You can solve the error problem during the calculation by entering the type for the result of the calculation: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Some</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> t: Expr) : Result() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: Expr) : Result() }</code> </pre><br></li><li>  Using the functions from the standard library, you can shorten the code somewhat; this will be done at the end of the article. </li></ul><br>  There are cases when we can predict the result of a calculation before it is completed.  For example, when multiplying by 0, the result will be 0. Entering the function-extension <code>fun Expr.isNull() = if (this is Expr.Const) c == 0 else false</code> multiplication takes the following form: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Expr.Mult -&gt; when { p1.<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">isNull</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p1.<span class="hljs-built_in"><span class="hljs-built_in">right</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">isNull</span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(solve(p1.<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>, context).c * solve(p1.<span class="hljs-built_in"><span class="hljs-built_in">right</span></span>, context).c) }</code> </pre> <br>  A similar approach can be resorted to when implementing other operations.  For example, the division will require verification of the division by 0 <br><br><h3>  Syntax </h3><br>  To implement the syntax, <a href="https://kotlinlang.org/docs/reference/extensions.html">extension-functions</a> and <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">operator-overloading are used</a> .  It looks very clearly. <br><br><pre> <code class="hljs pgsql">fun variable(<span class="hljs-type"><span class="hljs-type">name</span></span>: String) = Expr.Var(<span class="hljs-type"><span class="hljs-type">name</span></span>) fun const(c : <span class="hljs-type"><span class="hljs-type">Int</span></span>) = Expr.Const(c) //const(<span class="hljs-number"><span class="hljs-number">1</span></span>) * const(<span class="hljs-number"><span class="hljs-number">2</span></span>) == const(<span class="hljs-number"><span class="hljs-number">1</span></span>).times(const(<span class="hljs-number"><span class="hljs-number">2</span></span>)) infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.times(expr: Expr): Expr = Expr.Mult(this, expr) infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.times(expr: <span class="hljs-type"><span class="hljs-type">Int</span></span>): Expr = Expr.Mult(this, const(expr)) infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.times(expr: String) : Expr = Expr.Mult(this, Expr.Var(expr)) //   infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.plus(expr: Expr): Expr = Expr.Sum(this, expr) infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.plus(expr: <span class="hljs-type"><span class="hljs-type">Int</span></span>): Expr = Expr.Sum(this, const(expr)) infix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> fun Expr.plus(expr: String) : Expr = Expr.Sum(this, Expr.Var(expr)) //<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> infix fun Expr.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(pair: Pair&lt;String, Expr&gt;) = Expr.Let(pair.first, pair.second, this) @JvmName("whereInt") infix fun Expr.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(pair: Pair&lt;String, <span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) = Expr.Let(pair.first, const(pair.second), this) @JvmName("whereString") infix fun Expr.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(pair: Pair&lt;String, String&gt;) = Expr.Let(pair.first, variable(pair.second), this) //let <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> infix fun Expr.<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>(pair: Pair&lt;String, <span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) = Expr.Let(pair.first, const(pair.second), this) @JvmName("andExr") infix fun Expr.<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>(pair: Pair&lt;String, Expr&gt;) = Expr.Let(pair.first, pair.second, this) //let    : // ("s".let(<span class="hljs-number"><span class="hljs-number">1</span></span>)).inExr(variable("s")) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ExprBuilder(val <span class="hljs-type"><span class="hljs-type">name</span></span>: String, val <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: Expr) { infix fun inExr(expr: Expr): Expr = Expr.Let(<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, expr) } infix fun String.let(expr: Expr) = ExprBuilder(this, expr) infix fun String.let(constInt: <span class="hljs-type"><span class="hljs-type">Int</span></span>) = ExprBuilder(this, const(constInt))</code> </pre><br><h3>  Examples </h3><br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shouldEquals: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Expr</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Const</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = solve(expr) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$expr</span></span></span><span class="hljs-string"> = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$c</span></span></span><span class="hljs-string">, correct: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${shouldEquals.c == cc}</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> helloHabr = variable(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) * variable(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (<span class="hljs-string"><span class="hljs-string">"hello"</span></span> to <span class="hljs-number"><span class="hljs-number">1</span></span>) and (<span class="hljs-string"><span class="hljs-string">"habr"</span></span> to <span class="hljs-number"><span class="hljs-number">2</span></span>) testSolve(helloHabr, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)) * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) testSolve(e, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) *<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e2 = <span class="hljs-string"><span class="hljs-string">"x"</span></span>.let(<span class="hljs-number"><span class="hljs-number">10</span></span>) inExr (<span class="hljs-string"><span class="hljs-string">"y"</span></span>.let(<span class="hljs-number"><span class="hljs-number">100</span></span>) inExr (variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) + variable(<span class="hljs-string"><span class="hljs-string">"y"</span></span>))) testSolve(e2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">110</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e3 = (variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) * variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (<span class="hljs-string"><span class="hljs-string">"x"</span></span> to <span class="hljs-number"><span class="hljs-number">2</span></span>) testSolve(e3, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e4 = <span class="hljs-string"><span class="hljs-string">"x"</span></span> let (<span class="hljs-number"><span class="hljs-number">1</span></span>) inExr (variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) + (variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (<span class="hljs-string"><span class="hljs-string">"x"</span></span> to <span class="hljs-number"><span class="hljs-number">2</span></span>))) testSolve(e4, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e5 = <span class="hljs-string"><span class="hljs-string">"x"</span></span> let (<span class="hljs-number"><span class="hljs-number">0</span></span>) inExr (variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) * <span class="hljs-number"><span class="hljs-number">1000</span></span> + variable(<span class="hljs-string"><span class="hljs-string">"x"</span></span>)) testSolve(e5, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)) }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="hljs swift">((((hello * habr) * <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> hello = <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> habr = <span class="hljs-number"><span class="hljs-number">2</span></span>) = <span class="hljs-number"><span class="hljs-number">6</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span>) = <span class="hljs-number"><span class="hljs-number">9</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span> (((x + y), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> y = <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>) = <span class="hljs-number"><span class="hljs-number">110</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span> (((x * x) * <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>) = <span class="hljs-number"><span class="hljs-number">8</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ((x + (x, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>) = <span class="hljs-number"><span class="hljs-number">3</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span> (((x * <span class="hljs-number"><span class="hljs-number">1000</span></span>) + x), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span>, correct: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> </div></div><br><br><h3>  Disadvantages of the solution </h3><br>  Statement of the problem and the solution are educational.  The solution can highlight the following disadvantages: <br>  <b>Pragmatic:</b> <br><ul><li>  The inefficiency of methods for calculating and representing terms; </li><li>  Absence of the described grammar and priority of operations; </li><li>  Limited syntax (despite expressiveness, kotlin imposes restrictions); </li><li>  Lack of types other than integer. </li></ul><br>  <b>Ideological</b> <br><ul><li>  Exceptions destroy the beauty of pure functions; </li><li>  Lack of laziness calculations inherent in some functional languages. </li></ul><br><br>  PS <br>  Criticism to the presentation and code is welcome. <br><br>  <a href="https://github.com/punksta/KotlinExpr">Source code with addition of division, real numbers and If expression</a> </div><p>Source: <a href="https://habr.com/ru/post/310320/">https://habr.com/ru/post/310320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310308/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ228 (September 12 - 18, 2016)</a></li>
<li><a href="../310310/index.html">So, the manager asked to fix the bug ...</a></li>
<li><a href="../310312/index.html">Programmer on Mars: Shutdown Dammit Until</a></li>
<li><a href="../310314/index.html">Inheritance implementations: bury stewardess</a></li>
<li><a href="../310318/index.html">Getting Started with Intel Active Management (AMT)</a></li>
<li><a href="../310324/index.html">Rag I limp or have power?</a></li>
<li><a href="../310326/index.html">UWP beginner: Window title in applications (VB.NET + C #)</a></li>
<li><a href="../310328/index.html">Database Performance Testing with tSQLt and SQLQueryStress</a></li>
<li><a href="../310330/index.html">Azure-IaaS-Digest number 10 (August-September)</a></li>
<li><a href="../310332/index.html">DetectNet: Deep Neural Network for Object Detection at DIGITS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>