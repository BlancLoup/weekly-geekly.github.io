<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebGL Oscilloscope</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In electronic music there is an interesting direction - music for oscilloscopes, which draws interesting pictures, if the audio card output is connect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebGL Oscilloscope</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/bee/ca9/ab6/beeca9ab6f764261958f16c93fba50d0.png"><br><br>  In electronic music there is an interesting direction - music for oscilloscopes, which draws interesting pictures, if the audio card output is connected to an oscilloscope in XY mode. <br>  For example, <a href="https://www.youtube.com/watch%3Fv%3Ds1eNjUgaB-g">Youscope</a> , <a href="https://www.youtube.com/watch%3Fv%3DJ1ylMJwfLmM">Oscillofun</a> and <a href="https://www.youtube.com/watch%3Fv%3DvAyCl4IHIz8">Khr·∫≠ng</a> . <br><br>  All the beautiful videos generated by such music are created by recording the work of this oscilloscope on a video camera.  When I searched the network for oscilloscopes emulators, I was not able to find those that draw soft lines, like in a real oscilloscope. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This led me to create my oscilloscope emulator on WebGL: <a href="http://m1el.github.io/woscope/">woscope</a> . <br><br>  In this post I will talk about how exactly the oscilloscope lines are drawn in the woscope. <br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br>  There is a stereo audio file.  Each sample is interpreted as the coordinates of a point on the plane. <br>  We want to get a line that looks like a line on the oscilloscope when it is connected in XY mode. <br><br>  I decided that I would draw each line segment using a rectangle that covers the area of ‚Äã‚Äãthe screen touched by the beam. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/0f9/f25/36d0f9f2536ee95e8bba9d6307401b08.png" alt="image"><br><br>  The brightness of all segments will be collected using <code>gl.blendFunc(gl.SRC_ALPHA, gl.ONE);</code>  . <br><br><h3>  Vertex Generation </h3><br>  For a line segment, the coordinates of the four vertices of the rectangle are calculated from the beginning of the segment, the end of the segment, and the index of the vertex in the rectangle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/789/222/6df/7892226dfe76cd44d2123463d7d24ff3.png" alt="image"><br><br>  The first two points are closer to the beginning of the segment, and the last two - to the end of the segment. <br>  Even points are shifted ‚Äúto the left‚Äù of the segment, and odd points - ‚Äúto the right‚Äù. <br><br>  Such a transformation is quite simple to write in vertex shader: <br><br><pre> <code class="hljs dos">#define EPS <span class="hljs-number"><span class="hljs-number">1</span></span>E-<span class="hljs-number"><span class="hljs-number">6</span></span> uniform float uInvert; uniform float uSize; attribute vec2 aStart, aEnd; attribute float aIdx; // uvl.xy is used later <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fragment shader varying vec4 uvl; varying float vLen; void main () { float tang; vec2 current; // All points <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> quad contain the same data: // segment <span class="hljs-built_in"><span class="hljs-built_in">start</span></span> point and segment end point. // We determine point position using its index. float idx = mod(aIdx,<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); // `<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>` vector is storing the normalized difference // between end and <span class="hljs-built_in"><span class="hljs-built_in">start</span></span> vec2 <span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> = aEnd-aStart; uvl.z = length(<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uvl.z &gt; EPS) { <span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> / uvl.z; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the segment is too short, just draw a square <span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> = vec2(<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); } // norm stores direction normal to the segment difference vec2 norm = vec2(-<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>.y, <span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>.x); // `tang` corresponds to <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> "forward" or "backward" <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) { current = aEnd; tang = <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; uvl.x = -uSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { current = aStart; tang = -<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; uvl.x = uvl.z + uSize; } // `side` corresponds to <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> to the "right" or "left" float side = (mod(idx, <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>)-<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>)*<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; uvl.y = side * uSize; uvl.w = floor(aIdx / <span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>); gl_Position = vec4((current+(tang*<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>+norm*side)*uSize)*uInvert,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br><h3>  Calculate the brightness at the point </h3><br>  Knowing the coordinates of the vertices of the rectangle, you need to calculate the total intensity from the moving beam at a point on the rectangle. <br><br>  In my model, the beam intensity is described by a normal distribution, which is quite common in the real world. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/313/53b/33e/31353b33ea8e43e1ac95012abe83090c.png"></div><br>  Where œÉ is the beam spread. <br><br>  In order to calculate the total intensity at a point, I integrate the intensity of the beam over the time when the beam moves from the beginning to the end of the segment. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/832/ee2/e3d/832ee2e3d4174abda96aad22a88de228.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa5/e26/d44/aa5e26d4441ca30188834dbdb2dae292.png" alt="image"></div><br><br>  If you use a reference system in which the beginning of the segment has coordinates (0,0) and the end is (length, 0), you can write the distance (t) as: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/aab/a5e/ce5/aaba5ece5a1c42db8d66c7b858a8c12a.png"></div><br><br>  Now, <br><div style="text-align:center;"><img src="https://habrastorage.org/files/60e/bea/ccf/60ebeaccfc73438bbe14d0f364d8a09b.png"></div><br><br>  Insofar as <img src="https://habrastorage.org/files/e10/8e5/dbf/e108e5dbf2fa460f8cd3cb8fe274257e.png">  is constant <img src="https://habrastorage.org/files/dd6/224/e07/dd6224e07f6946f9ba9e6ba1633db60a.png">  can be taken out of the integration sign: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/132/ded/a99/132deda99ab943b395fe0fa3b2e35402.png"></div><br><br>  Let's slightly simplify the integral by replacing t with u / l: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/480/fc8/0f8/480fc80f833e4cca8a9ebf257ab1334b.png"></div><br><br>  The integral of the normal distribution is an error function. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/896/0c2/19f/8960c219f558477a9661f9143f62bd61"></div><br><br>  Finally, <br><div style="text-align:center;"><img src="https://habrastorage.org/files/20f/da6/7d8/20fda67d84934b0e96e7d0c57d41eb3a.png"></div><br><br>  Knowing the approximation of the error function, it is easy to write this formula in fragment shader <br><br><h3>  Fragment shader </h3><br>  <abbr title="varying">The</abbr> <code>uvl</code> <abbr title="varying">parameter</abbr> generated in the vertex shader contains the coordinates of a point in the reference system where the beginning of the segment has coordinates (0,0) and the end is (length, 0). <br>  This parameter will be linearly interpolated between the vertices of the triangles, which is what we need. <br><br><pre> <code class="hljs mel">#define EPS <span class="hljs-number"><span class="hljs-number">1E-6</span></span> #define TAU <span class="hljs-number"><span class="hljs-number">6.283185307179586</span></span> #define TAUR <span class="hljs-number"><span class="hljs-number">2.5066282746310002</span></span> #define SQRT2 <span class="hljs-number"><span class="hljs-number">1.4142135623730951</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uSize; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uIntensity; precision highp <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; varying vec4 uvl; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gaussian(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sigma) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span>(-(x * x) / (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * sigma * sigma)) / (TAUR * sigma); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">erf</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>(x), a = <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(x); x = <span class="hljs-number"><span class="hljs-number">1.0</span></span> + (<span class="hljs-number"><span class="hljs-number">0.278393</span></span> + (<span class="hljs-number"><span class="hljs-number">0.230389</span></span> + (<span class="hljs-number"><span class="hljs-number">0.000972</span></span> + <span class="hljs-number"><span class="hljs-number">0.078108</span></span> * a) * a) * a) * a; x *= x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s - s / (x * x); } void main (void) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> len = uvl.z; vec2 xy = uvl.xy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sigma = uSize/<span class="hljs-number"><span class="hljs-number">4.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; EPS) { <span class="hljs-comment"><span class="hljs-comment">// If the beam segment is too short, just calculate intensity at the position. alpha = exp(-pow(length(xy),2.0)/(2.0*sigma*sigma))/2.0/sqrt(uSize); } else { // Otherwise, use analytical integral for accumulated intensity. alpha = erf(xy.x/SQRT2/sigma) - erf((xy.x-len)/SQRT2/sigma); alpha *= exp(-xy.y*xy.y/(2.0*sigma*sigma))/2.0/len*uSize; } float afterglow = smoothstep(0.0, 0.33, uvl.w/2048.0); alpha *= afterglow * uIntensity; gl_FragColor = vec4(1./32., 1.0, 1./32., alpha); }</span></span></code> </pre><br><br><h3>  What can be improved </h3><br><ul><li>  In this emulator, the point moves in a straight line in each segment, which sometimes leads to apparently broken lines. To avoid this, you can use sinc interpolation by increasing the number of samples several times </li><li>  Pixel saturation occurs too quickly, this could have been avoided using float textures, but there are problems with their support in WebGL.  At the moment there are small red and blue values ‚Äã‚Äãin the beam, which ‚Äúoverflows‚Äù the value into white pixels. </li><li>  Monitor gamma correction is not taken into account. </li><li>  No bloom, but it may not be necessary, given the method of generating lines </li><li>  Make a native program with this functionality? </li></ul><br><br><h3>  Results </h3><br>  The result was a fairly realistic oscilloscope emulator on WebGL, and mathematics played a big role in creating a beautiful picture. <br>  This method can be used to generate other soft lines. <br>  I hope the article was informative and interesting for the reader. <br><br>  <i>Shader code is given to the public domain.</i>  <i>The full woscope code is available on <a href="https://github.com/m1el/woscope">github.</a></i> </div><p>Source: <a href="https://habr.com/ru/post/268801/">https://habr.com/ru/post/268801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268789/index.html">HackedSim. Call from any number - fiction or reality?</a></li>
<li><a href="../268791/index.html">How to create a cross-platform Half-Life or "Headcrabs inside your watch"</a></li>
<li><a href="../268793/index.html">We return the auto-login to the Wi-Fi network of the Moscow metro in Android</a></li>
<li><a href="../268795/index.html">Introduction to arrow functions in javascript ES6</a></li>
<li><a href="../268799/index.html">Create a proxy checker worth 100 million for a couple of days</a></li>
<li><a href="../268805/index.html">3CX Softphone got the BLF panel, import from Google and ...</a></li>
<li><a href="../268807/index.html">ZFS on CentOS: work on the bugs</a></li>
<li><a href="../268809/index.html">The task of Alexander Ivanovich Koreyko</a></li>
<li><a href="../268811/index.html">How to protect your company from zero-day attacks</a></li>
<li><a href="../268813/index.html">Engineering infrastructure as the basis of the information system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>