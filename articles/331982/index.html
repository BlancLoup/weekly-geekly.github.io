<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We use Laravel IoC container at full capacity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Laravel has a powerful IoC container, but, unfortunately, the official Laravel documentation does not describe all its capabilities. I decided to stud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We use Laravel IoC container at full capacity</h1><div class="post__text post__text-html js-mediator-article"><p>  Laravel has a powerful IoC container, but, unfortunately, the <a href="https://laravel.com/docs/5.4/container">official</a> Laravel <a href="https://laravel.com/docs/5.4/container">documentation</a> does not describe all its capabilities.  I decided to study it and document it for my own use. </p><br><p>  The examples in this article are based on Laravel 5.4.26, other versions may vary. </p><br><h2 id="vvedenie-v-dependency-injection">  Introduction to Dependency Injection </h2><br><p>  I will not explain what DI and IoC are in this article - if you are not familiar with these principles, you can read the article " <a href="http://fabien.potencier.org/what-is-dependency-injection.html">What is Dependency Injection?</a> " From Fabien Potencier (the creator of the <a href="http://symfony.com/">symfony</a> framework). <a name="habracut"></a></p><br><h2 id="poluchenie-konteynera-container">  Container receipt </h2><br><p> In Laravel, there are several ways to get the container entity <sup>*</sup> and the simplest of them is to call the <code>app()</code> helper: </p><br><pre> <code class="php hljs">$container = app();</code> </pre> <br><p>  I will not describe other ways, instead I will focus my attention on the container itself. </p><br><p>  <code>*</code> In Laravel, there is an <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Foundation/Application.php">Application</a> class that inherits from Container (which is why the helper is called <code>app()</code> ), but in this article I will describe only the methods of the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Container/Container.php">Container</a> class. </p><br><h2 id="ispolzovanie-illuminatecontainer-vne-laravel">  Using Illuminate \ Container outside Laravel </h2><br><p>  To use the Laravel container outside of the framework, you need to <a href="https://packagist.org/packages/illuminate/container">install it</a> using Composer, after which we can get the container like this: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>; $container = Container::getInstance();</code> </pre> <br><h2 id="primer-ispolzovaniya">  Usage example </h2><br><p>  The easiest way to use a container is to specify in the constructor the classes that your class needs using type hinting: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $dependency; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AnotherClass $dependency)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;dependency = $dependency; } }</code> </pre> <br><p>  Then, instead of creating an object with the help of <code>new MyClass</code> , let's call the container's <code>make()</code> method: </p><br><pre> <code class="php hljs">$instance = $container-&gt;make(MyClass::class);</code> </pre> <br><p>  The container will automatically create and inject dependencies, which will be equivalent to the following code: </p><br><pre> <code class="php hljs">$instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnotherClass());</code> </pre> <br><p>  (Except when <code>AnotherClass</code> has its own dependencies. In this case, the container will automatically create and inject its dependencies, dependencies of its dependencies, etc.) </p><br><h2 id="realnyy-primer">  Real example </h2><br><p>  Below is a more realistic example, which is taken from the <a href="http://php-di.org/doc/getting-started.html">PHP-DI</a> documentation.  In it, the message sending logic is separated from the user registration logic: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mailer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($recipient, $content)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Send an email to the recipient // ... } }</span></span></code> </pre> <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $mailer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mailer $mailer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;mailer = $mailer; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email, $password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create the user account // ... // Send the user an email to say hello! $this-&gt;mailer-&gt;mail($email, 'Hello and welcome!'); } }</span></span></code> </pre> <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>; $container = Container::getInstance(); $userManager = $container-&gt;make(UserManager::class); $userManager-&gt;register(<span class="hljs-string"><span class="hljs-string">'dave@davejamesmiller.com'</span></span>, <span class="hljs-string"><span class="hljs-string">'MySuperSecurePassword!'</span></span>);</code> </pre> <br><h2 id="svyazyvanie-interfeysa-i-realizacii">  Interface binding and implementation </h2><br><p>  First, let's define the interfaces: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">MyInterface</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">AnotherInterface</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Then create the classes that implement these interfaces.  They may depend on other interfaces (or other classes, as was previously the case): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $dependency; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AnotherInterface $dependency)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;dependency = $dependency; } }</code> </pre> <br><p>  Now we will <code>bind()</code> interfaces with the implementation using the <code>bind()</code> method: </p><br><pre> <code class="php hljs">$container-&gt;bind(MyInterface::class, MyClass::class); $container-&gt;bind(AnotherInterface::class, AnotherClass::class);</code> </pre> <br><p>  And pass the interface name instead of the class name to the <code>make()</code> method: </p><br><pre> <code class="php hljs">$instance = $container-&gt;make(MyInterface::class);</code> </pre> <br><p>  <strong>Note:</strong> If you forget to bind the interface to the implementation, you will get a slightly strange error: </p><br><pre> <code class="hljs vbscript">Fatal <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: Uncaught ReflectionException: <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyInterface does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist</code> </pre> <br><p>  This is because the container is trying to create an instance of the interface ( <code>new MyInterface</code> ), which is not a class. </p><br><h2 id="realnyy-primer-1">  Real example </h2><br><p>  Below is a real example of binding an interface to a specific implementation ‚Äî a modifiable cache driver: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key, $value)</span></span></span></span>; }</code> </pre> <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedisCache</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key, $value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $cache; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cache = $cache; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use the cache for something... $result = $this-&gt;cache-&gt;get('worker'); if ($result === null) { $result = do_something_slow(); $this-&gt;cache-&gt;put('worker', $result); } return $result; } }</span></span></code> </pre> <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>\<span class="hljs-title"><span class="hljs-title">Container</span></span>; $container = Container::getInstance(); $container-&gt;bind(Cache::class, RedisCache::class); $result = $container-&gt;make(Worker::class)-&gt;result();</code> </pre> <br><h2 id="svyazyvanie-abstraktnyh-i-konkretnyh-klassov">  Linking abstract and concrete classes </h2><br><p>  Binding can also be used with an abstract class: </p><br><pre> <code class="php hljs">$container-&gt;bind(MyAbstract::class, MyConcreteClass::class);</code> </pre> <br><p>  Or to replace a class with its descendant (a class that inherits from it): </p><br><pre> <code class="php hljs">$container-&gt;bind(MySQLDatabase::class, CustomMySQLDatabase::class);</code> </pre> <br><h2 id="custom-bindings">  Custom bindings </h2><br><p>  If the object requires additional configuration during creation, you can pass the closure with the second parameter to the <code>bind()</code> method instead of the class name: </p><br><pre> <code class="php hljs">$container-&gt;bind(Database::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MySQLDatabase(MYSQL_HOST, MYSQL_PORT, MYSQL_USER, MYSQL_PASS); });</code> </pre> <br><p>  Each time the Database class is requested, a new MySQLDatabase instance will be created with the specified configuration (if you need to have only one instance of the class, use the Singleton, described below). </p><br><p>  The closure receives as the first parameter an instance of the Container class, which can be used to create other classes, if necessary: </p><br><pre> <code class="php hljs">$container-&gt;bind(Logger::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ $filesystem = $container-&gt;make(Filesystem::class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileLogger($filesystem, <span class="hljs-string"><span class="hljs-string">'logs/error.log'</span></span>); });</code> </pre> <br><p>  A closure can also be used to configure a class after creation: </p><br><pre> <code class="php hljs">$container-&gt;bind(GitHub\Client::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GitHub\Client; $client-&gt;setEnterpriseUrl(GITHUB_HOST); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $client; });</code> </pre> <br><h2 id="resolving-callbacks">  Resolving Callbacks </h2><br><p>  Instead of completely rewriting the binding, we can use the <code>resolving()</code> method to register callbacks that will be called after creating the required object: </p><br><pre> <code class="php hljs">$container-&gt;resolving(GitHub\Client::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($client, Container $container)</span></span></span><span class="hljs-function"> </span></span>{ $client-&gt;setEnterpriseUrl(GITHUB_HOST); });</code> </pre> <br><p>  If several callbacks have been registered, they will all be called.  This also works for interfaces and abstract classes: </p><br><pre> <code class="php hljs">$container-&gt;resolving(Logger::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger $logger)</span></span></span><span class="hljs-function"> </span></span>{ $logger-&gt;setLevel(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); }); $container-&gt;resolving(FileLogger::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileLogger $logger)</span></span></span><span class="hljs-function"> </span></span>{ $logger-&gt;setFilename(<span class="hljs-string"><span class="hljs-string">'logs/debug.log'</span></span>); }); $container-&gt;bind(Logger::class, FileLogger::class); $logger = $container-&gt;make(Logger::class);</code> </pre> <br><p>  It is also possible to register a callback, which will be called when creating any class (this can be useful for logging or debugging): </p><br><pre> <code class="php hljs">$container-&gt;resolving(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($object, Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre> <br><h2 id="rasshirenie-klassa">  Class extension </h2><br><p>  You can also use the <code>extend()</code> method to wrap the original class and return another object: </p><br><pre> <code class="php hljs">$container-&gt;extend(APIClient::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($client, Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> APIClientDecorator($client); });</code> </pre> <br><p>  The class of the returned object must implement the same interface as the class of the object being wrapped, otherwise you will get an error. </p><br><h2 id="singleton">  Singleton </h2><br><p>  Every time a need arises in any class (if the name of a class or a binding created with the <code>bind()</code> method is specified), a new instance of the required class is created (or a closure is called).  In order to have only one instance of the class, you must call the <code>singleton()</code> method instead of the <code>bind()</code> method: </p><br><pre> <code class="php hljs">$container-&gt;singleton(Cache::class, RedisCache::class);</code> </pre> <br><p>  Closing example: </p><br><pre> <code class="php hljs">$container-&gt;singleton(Database::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MySQLDatabase(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'testdb'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'pass'</span></span>); });</code> </pre> <br><p>  In order to get a singleton from a class, you must pass it by omitting the second parameter: </p><br><pre> <code class="php hljs">$container-&gt;singleton(MySQLDatabase::class);</code> </pre> <br><p>  A singleton instance will be created only once, the same object will be used later. </p><br><p>  If you already have an entity that you want to reuse, then use the <code>instance()</code> method.  For example, Laravel uses this to ensure that the Container class has only one instance: </p><br><pre> <code class="php hljs">$container-&gt;instance(Container::class, $container);</code> </pre> <br><h2 id="proizvolnoe-nazvanie-bindinga">  Arbitrary Binding Name </h2><br><p>  When binding, you can use an arbitrary string instead of the name of the class or interface, but you can no longer use type hinting and you will need to use the <code>make()</code> method: </p><br><pre> <code class="php hljs">$container-&gt;bind(<span class="hljs-string"><span class="hljs-string">'database'</span></span>, MySQLDatabase::class); $db = $container-&gt;make(<span class="hljs-string"><span class="hljs-string">'database'</span></span>);</code> </pre> <br><p>  To have a class name and a short name at the same time, you can use the <code>alias()</code> method: </p><br><pre> <code class="php hljs">$container-&gt;singleton(Cache::class, RedisCache::class); $container-&gt;alias(Cache::class, <span class="hljs-string"><span class="hljs-string">'cache'</span></span>); $cache1 = $container-&gt;make(Cache::class); $cache2 = $container-&gt;make(<span class="hljs-string"><span class="hljs-string">'cache'</span></span>); assert($cache1 === $cache2);</code> </pre> <br><h2 id="sohranenie-proizvolnogo-znacheniya">  Saving an arbitrary value </h2><br><p>  The container allows storing arbitrary values ‚Äã‚Äã(for example, configuration data): </p><br><pre> <code class="php hljs">$container-&gt;instance(<span class="hljs-string"><span class="hljs-string">'database.name'</span></span>, <span class="hljs-string"><span class="hljs-string">'testdb'</span></span>); $db_name = $container-&gt;make(<span class="hljs-string"><span class="hljs-string">'database.name'</span></span>);</code> </pre> <br><p>  Also supported is the array-access syntax, which looks more familiar: </p><br><pre> <code class="php hljs">$container[<span class="hljs-string"><span class="hljs-string">'database.name'</span></span>] = <span class="hljs-string"><span class="hljs-string">'testdb'</span></span>; $db_name = $container[<span class="hljs-string"><span class="hljs-string">'database.name'</span></span>];</code> </pre> <br><p>  This can be useful when using it with binding-closure: </p><br><pre> <code class="php hljs">$container-&gt;singleton(<span class="hljs-string"><span class="hljs-string">'database'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MySQLDatabase( $container[<span class="hljs-string"><span class="hljs-string">'database.host'</span></span>], $container[<span class="hljs-string"><span class="hljs-string">'database.name'</span></span>], $container[<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>], $container[<span class="hljs-string"><span class="hljs-string">'database.pass'</span></span>] ); });</code> </pre> <br><p>  (Laravel itself does not use a container for storing the configuration, for this there is a separate class - Config, but <a href="http://php-di.org/doc/php-definitions.html">PHP-DI</a> does this). </p><br><p>  <strong>Tip: You</strong> can use the array-access syntax to create objects instead of the <code>make()</code> method: </p><br><pre> <code class="hljs perl">$db = $container[<span class="hljs-string"><span class="hljs-string">'database'</span></span>];</code> </pre> <br><h2 id="dependency-injection-dlya-funkciy-i-metodov">  Dependency Injection for Functions and Methods </h2><br><p>  So far, we have used DI only for constructors, but Laravel also supports DI for arbitrary functions: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } $result = $container-&gt;call(<span class="hljs-string"><span class="hljs-string">'do_something'</span></span>);</code> </pre> <br><p>  Additional parameters can be passed as a simple or associative array: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache, $id, $tab = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'details'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">// show_product($cache, 1) $container-&gt;call('show_product', [1]); $container-&gt;call('show_product', ['id' =&gt; 1]); // show_product($cache, 1, 'spec') $container-&gt;call('show_product', [1, 'spec']); $container-&gt;call('show_product', ['id' =&gt; 1, 'tab' =&gt; 'spec']);</span></span></code> </pre> <br><p>  DI can be used for any methods called: </p><br><h5 id="zamykaniya">  <strong>Closures</strong> </h5><br><pre> <code class="php hljs">$closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; $container-&gt;call($closure);</code> </pre> <br><h5 id="statichnye-metody">  <strong>Static methods</strong> </h5><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br><pre> <code class="php hljs">$container-&gt;call([<span class="hljs-string"><span class="hljs-string">'SomeClass'</span></span>, <span class="hljs-string"><span class="hljs-string">'staticMethod'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// or: $container-&gt;call('SomeClass::staticMethod');</span></span></code> </pre> <br><h5 id="metody-obekta">  <strong>Object methods</strong> </h5><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache, $id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br><pre> <code class="php hljs">$controller = $container-&gt;make(PostController::class); $container-&gt;call([$controller, <span class="hljs-string"><span class="hljs-string">'index'</span></span>]); $container-&gt;call([$controller, <span class="hljs-string"><span class="hljs-string">'show'</span></span>], [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>]);</code> </pre> <br><h2 id="sokrascheniya-dlya-vyzova-metodov-obekta">  Abbreviations for calling object methods </h2><br><p>  Container allows you to use an abbreviation of the form <code>ClassName@methodName</code> to create an object and call its method.  Example: </p><br><pre> <code class="php hljs">$container-&gt;call(<span class="hljs-string"><span class="hljs-string">'PostController@index'</span></span>); $container-&gt;call(<span class="hljs-string"><span class="hljs-string">'PostController@show'</span></span>, [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>]);</code> </pre> <br><p>  The container is used to create an instance of a class, i.e .: </p><br><ol><li>  Dependencies are passed to the class constructor, as well as to the method being called. </li><li>  You can declare a class as a singleton if you want to reuse the same object. </li><li>  You can use an interface or an arbitrary name instead of a class name. </li></ol><br><p>  The example below will work: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br><pre> <code class="php hljs">$container-&gt;singleton(<span class="hljs-string"><span class="hljs-string">'post'</span></span>, PostController::class); $container-&gt;call(<span class="hljs-string"><span class="hljs-string">'post@index'</span></span>);</code> </pre> <br><p>  Finally, you can pass the name of the "default method" as the third parameter.  If the first parameter is the class name and the method name is not specified, the default method will be called.  Laravel uses this in event handlers: </p><br><pre> <code class="php hljs">$container-&gt;call(MyEventHandler::class, $parameters, <span class="hljs-string"><span class="hljs-string">'handle'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Equivalent to: $container-&gt;call('MyEventHandler@handle', $parameters);</span></span></code> </pre> <br><h2 id="podmena-metodov-obekta">  Substitution of object methods </h2><br><p>  The <code>bindMethod()</code> method allows you to override the method call, for example, to pass parameters: </p><br><pre> <code class="php hljs">$container-&gt;bindMethod(<span class="hljs-string"><span class="hljs-string">'PostController@index'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($controller, $container)</span></span></span><span class="hljs-function"> </span></span>{ $posts = get_posts(...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $controller-&gt;index($posts); });</code> </pre> <br><p>  All the examples below will work, and a closure instead of the present method will be called: </p><br><pre> <code class="php hljs">$container-&gt;call(<span class="hljs-string"><span class="hljs-string">'PostController@index'</span></span>); $container-&gt;call(<span class="hljs-string"><span class="hljs-string">'PostController'</span></span>, [], <span class="hljs-string"><span class="hljs-string">'index'</span></span>); $container-&gt;call([<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostController, <span class="hljs-string"><span class="hljs-string">'index'</span></span>]);</code> </pre> <br><p>  However, any additional parameters passed to the <code>call()</code> method will not be passed to the closure and they cannot be used: </p><br><pre> <code class="php hljs">$container-&gt;call(<span class="hljs-string"><span class="hljs-string">'PostController@index'</span></span>, [<span class="hljs-string"><span class="hljs-string">'Not used :-('</span></span>]);</code> </pre> <br><p>  <strong>Notes: The</strong> <code>bindMethod()</code> method is not part of the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Contracts/Container/Container.php">Container</a> interface, it is only in the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Container/Container.php">Container</a> class.  See <a href="https://github.com/laravel/framework/pull/16800">Pull Request for a description of</a> why parameters are not passed during the override. </p><br><h2 id="binding-na-osnove-konteksta">  Context Binding </h2><br><p>  It may happen that you want to have different implementations of the same interface depending on where it is needed.  The following is a slightly modified example from the <a href="https://laravel.com/docs/5.4/container">Laravel documentation</a> : </p><br><pre> <code class="php hljs">$container -&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(LocalFilesystem::class); $container -&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(S3Filesystem::class);</code> </pre> <br><p>  Now the PhotoController and VideoController controllers may depend on the Filesystem interface, but each of them will get its own implementation of this interface. </p><br><p>  You can also pass a closure to the <code>give()</code> method, as you do in the <code>bind()</code> method: </p><br><pre> <code class="php hljs">$container -&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Storage::disk(<span class="hljs-string"><span class="hljs-string">'s3'</span></span>); });</code> </pre> <br><p>  Or you can use a named dependency: </p><br><pre> <code class="php hljs">$container-&gt;instance(<span class="hljs-string"><span class="hljs-string">'s3'</span></span>, $s3Filesystem); $container -&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(<span class="hljs-string"><span class="hljs-string">'s3'</span></span>);</code> </pre> <br><h2 id="binding-parametrov-k-primitivnym-tipam">  Binding parameters to primitive types </h2><br><p>  In addition to objects, the container allows for the binding of primitive types (strings, numbers, etc.).  To do this, pass the variable name (instead of the interface name) to the <code>needs()</code> method, and the <code>give()</code> method to pass the value that will be substituted by the container when the method is called: </p><br><pre> <code class="php hljs">$container -&gt;when(MySQLDatabase::class) -&gt;needs(<span class="hljs-string"><span class="hljs-string">'$username'</span></span>) -&gt;give(DB_USER);</code> </pre> <br><p>  We can also pass the closure to the <code>give()</code> method, in order to postpone the calculation of the value until it is needed: </p><br><pre> <code class="php hljs">$container -&gt;when(MySQLDatabase::class) -&gt;needs(<span class="hljs-string"><span class="hljs-string">'$username'</span></span>) -&gt;give(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config(<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>); });</code> </pre> <br><p>  We cannot pass a class name or a named dependency to a <code>give()</code> method (for example, <code>give('database.user')</code> ), because it will be returned as it is.  But we can use the closure: </p><br><pre> <code class="php hljs">$container -&gt;when(MySQLDatabase::class) -&gt;needs(<span class="hljs-string"><span class="hljs-string">'$username'</span></span>) -&gt;give(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $container[<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>]; });</code> </pre> <br><h2 id="dobavlenie-tegov-k-bindingam">  Add tags to binders </h2><br><p>  You can use the container to add tags to related (as intended) binders: </p><br><pre> <code class="php hljs">$container-&gt;tag(MyPlugin::class, <span class="hljs-string"><span class="hljs-string">'plugin'</span></span>); $container-&gt;tag(AnotherPlugin::class, <span class="hljs-string"><span class="hljs-string">'plugin'</span></span>);</code> </pre> <br><p>  And then get an array of entities with the specified tag: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($container-&gt;tagged(<span class="hljs-string"><span class="hljs-string">'plugin'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $plugin) { $plugin-&gt;init(); }</code> </pre> <br><p>  Both parameters of the <code>tag()</code> method also accept an array: </p><br><pre> <code class="php hljs">$container-&gt;tag([MyPlugin::class, AnotherPlugin::class], <span class="hljs-string"><span class="hljs-string">'plugin'</span></span>); $container-&gt;tag(MyPlugin::class, [<span class="hljs-string"><span class="hljs-string">'plugin'</span></span>, <span class="hljs-string"><span class="hljs-string">'plugin.admin'</span></span>]);</code> </pre> <br><h2 id="rebinding">  Rebinding </h2><br><p>  <strong>Note</strong> : this feature of the container is used quite rarely, so you can safely skip its description. </p><br><p>  A callback registered using the <code>rebinding()</code> method is called when the binding is changed.  In the example below, the session was replaced after it was used by the Auth class, so the Auth class should be informed about the change: </p><br><pre> <code class="php hljs">$container-&gt;singleton(Auth::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ $auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Auth; $auth-&gt;setSession($container-&gt;make(Session::class)); $container-&gt;rebinding(Session::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($container, $session)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($auth)</span></span></span><span class="hljs-function"> </span></span>{ $auth-&gt;setSession($session); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $auth; }); $container-&gt;instance(Session::class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Session([<span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'dave'</span></span>])); $auth = $container-&gt;make(Auth::class); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $auth-&gt;username(); <span class="hljs-comment"><span class="hljs-comment">// dave $container-&gt;instance(Session::class, new Session(['username' =&gt; 'danny'])); echo $auth-&gt;username(); // danny</span></span></code> </pre> <br><p>  More information on this topic can be found <a href="https://stackoverflow.com/questions/38974593/laravels-ioc-container-rebinding-abstract-types">here</a> and <a href="https://code.tutsplus.com/tutorials/digging-in-to-laravels-ioc-container--cms-22167">here</a> . </p><br><h3 id="refresh">  refresh () </h3><br><p>  There is also an abbreviation that can be useful in some cases - the <code>refresh()</code> method: </p><br><pre> <code class="php hljs">$container-&gt;singleton(Auth::class, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container $container)</span></span></span><span class="hljs-function"> </span></span>{ $auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Auth; $auth-&gt;setSession($container-&gt;make(Session::class)); $container-&gt;refresh(Session::class, $auth, <span class="hljs-string"><span class="hljs-string">'setSession'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $auth; });</code> </pre> <br><p>  It also returns an existing instance of a class or binding (if it exists), so you can do this: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      `singleton()`  `bind()`    $container-&gt;singleton(Session::class); $container-&gt;singleton(Auth::class, function (Container $container) { $auth = new Auth; $auth-&gt;setSession($container-&gt;refresh(Session::class, $auth, 'setSession')); return $auth; });</span></span></code> </pre> <br><p>  Personally, this syntax seems a bit confusing to me, so I prefer a more detailed version, which is described above. </p><br><p>  <strong>Note:</strong> these methods are not part of the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Contracts/Container/Container.php">Container</a> interface, they are only in the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Container/Container.php">Container</a> class. </p><br><h2 id="overriding-constructor-parameters">  Overriding Constructor Parameters </h2><br><p>  The <code>makeWith()</code> method allows you to pass additional parameters to the constructor.  At the same time, existing instances or singletons are ignored (that is, a new object is created).  This can be useful when creating objects with different parameters and that have any dependencies: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Database $db, int $id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br><pre> <code class="php hljs">$post1 = $container-&gt;makeWith(Post::class, [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>]); $post2 = $container-&gt;makeWith(Post::class, [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <strong>Note:</strong> In Laravel&gt; = 5.3, this method is simply called <code>make($class, $parameters)</code> .  It was <a href="https://github.com/laravel/internals/issues/391">removed</a> in Laravel 5.4, but then <a href="https://github.com/laravel/framework/pull/18271">returned back</a> under the name <code>makeWith</code> in version 5.4.16.  It seems that in Laravel 5.5 its name will be <a href="https://github.com/laravel/framework/pull/19201">changed</a> to <code>make()</code> <a href="https://github.com/laravel/framework/pull/19201">again</a> . </p><br><h2 id="prochie-metody">  Other methods </h2><br><p>  I described all the methods that seemed useful to me, but for the sake of completeness, I will describe the remaining available methods. </p><br><h3 id="bound">  bound () </h3><br><p>  The <code>bound()</code> method checks if there is a class or alias associated with the <code>bind()</code> , <code>singleton()</code> , <code>instance()</code> or <code>alias()</code> methods: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! $container-&gt;bound(<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  You can also use the isset method and the array-access syntax: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($container[<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>])) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  The value specified in the methods <code>binding()</code> , <code>instance()</code> , <code>alias()</code> can be removed using <code>unset()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($container[<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>]); var_dump($container-&gt;bound(<span class="hljs-string"><span class="hljs-string">'database.user'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br><h3 id="bindif">  bindIf () </h3><br><p>  The <code>bindIf()</code> method does the same thing as the <code>bind()</code> method, except that it creates a binding only if it does not exist (see the description of the <code>bound()</code> method above).  Theoretically, it can be used in a package to register a binding by default, allowing the user to override it. </p><br><pre> <code class="php hljs">$container-&gt;bindIf(Loader::class, FallbackLoader::class);</code> </pre> <br><p>  There is no <code>singletonIf()</code> method; instead, you can use bindIf ($ abstract, $ concrete, true): </p><br><pre> <code class="php hljs">$container-&gt;bindIf(Loader::class, FallbackLoader::class, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre> <br><p>  Or write the verification code yourself: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! $container-&gt;bound(Loader::class)) { $container-&gt;singleton(Loader::class, FallbackLoader::class); }</code> </pre> <br><h3 id="resolved">  resolved () </h3><br><p>  The <code>resolved()</code> method returns true if an instance of the class was previously created. </p><br><pre> <code class="php hljs">var_dump($container-&gt;resolved(Database::class)); <span class="hljs-comment"><span class="hljs-comment">// false $container-&gt;make(Database::class); var_dump($container-&gt;resolved(Database::class)); // true</span></span></code> </pre> <br><p>  It is reset when the <code>unset()</code> method is called (see the description of the <code>bound()</code> method above). </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($container[Database::class]); var_dump($container-&gt;resolved(Database::class)); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br><h3 id="factory">  factory () </h3><br><p>  The <code>factory()</code> method returns a closure that takes no parameters and calls the <code>make()</code> method when invoked. </p><br><pre> <code class="hljs ruby">$dbFactory = $container-&gt;factory(Database::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">);</span></span> $db = $dbFactory();</code> </pre> <br><h3 id="wrap">  wrap () </h3><br><p>  The <code>wrap()</code> method wraps the closure in yet another closure that will inject the dependencies into the wrapper that is being called.  The method takes an array of parameters that will be passed to the wrapped closure;  the return closure does not accept any parameters: </p><br><pre> <code class="php hljs">$cacheGetter = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cache $cache, $key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $cache-&gt;get($key); }; $usernameGetter = $container-&gt;wrap($cacheGetter, [<span class="hljs-string"><span class="hljs-string">'username'</span></span>]); $username = $usernameGetter();</code> </pre> <br><p>  <strong>Note:</strong> the <code>wrap()</code> method is not part of the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Contracts/Container/Container.php">Container</a> interface, it is only in the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Container/Container.php">Container</a> class. </p><br><h3 id="afterresolving">  afterResolving () </h3><br><p>  The <code>afterResolving()</code> method works in the same way as the <code>resolving()</code> method, with the exception that callbacks registered with it are called after callbacks registered using the <code>resolving()</code> method. </p><br><h2 id="i-nakonec">  And finally ... </h2><br><p>  <code>isShared()</code> - Checks if a singleton / instance exists for the specified type. <br>  <code>isAlias()</code> - Checks if an alias exists with the specified name. <br>  <code>hasMethodBinding()</code> - Checks if there is a binding for the specified method in the container <br>  <code>getBindings()</code> - Returns an array of all registered bindings. <br>  <code>getAlias($abstract)</code> - Returns the alias for the specified class / binding <br>  <code>forgetInstance($abstract)</code> - Removes the specified class instance from the container. <br>  <code>forgetInstances()</code> - Removes all instances of classes. <br>  <code>flush()</code> - Removes all bindings and created instances of classes, completely clearing the container <br>  <code>setInstance()</code> - Replaces the object returned by getInstance () (hint: use <code>setInstance(null)</code> to clean up, a new container instance will be created later) </p><br><p>  <strong>Note:</strong> None of these methods are part of the <a href="https://github.com/laravel/framework/blob/5.4/src/Illuminate/Contracts/Container/Container.php">Container</a> interface. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331982/">https://habr.com/ru/post/331982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331968/index.html">Enterprise Software Update: Option for PDM / PLM Systems</a></li>
<li><a href="../331972/index.html">Benefits of interactive prototyping</a></li>
<li><a href="../331974/index.html">Phantom: large garbage collection</a></li>
<li><a href="../331976/index.html">Kotlin and the cost of developing the game (+ a little offtopic)</a></li>
<li><a href="../331978/index.html">Day after the Petya virus</a></li>
<li><a href="../331986/index.html">Football as an exact science: how ITMO University helps the organizers of the Confederations Cup and the 2018 World Cup</a></li>
<li><a href="../331988/index.html">Graphics for indie games. What to do if the roundels and sticks do not suit you</a></li>
<li><a href="../331990/index.html">Tale about NePetu, or rather not about Petya</a></li>
<li><a href="../331992/index.html">‚ÄúIceberg instead of Oscar!‚Äù Or as I tried to learn the basics of DataScience on kaggle</a></li>
<li><a href="../331994/index.html">Ruining people not beer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>