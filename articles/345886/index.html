<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why programmers need restrictions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We were born in culture with the motto ‚ÄúNo Borders‚Äù or ‚ÄúPush the Limits‚Äù , but in fact we need borders. With them, we become better, but it must be th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why programmers need restrictions</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/bcf/3dd/942bcf3dd5903c6ff20e1ad32605b4d9.jpg"></div><br>  We were born in culture with the motto <strong><em>‚ÄúNo Borders‚Äù</em></strong> or <strong><em>‚ÄúPush the Limits‚Äù</em></strong> , but in fact we need borders.  With them, we become better, but it must be the right boundaries. <br><br><h4>  Censorship for quality music </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/438/197/738/4381977382e7dd75267ad6ac95a2434c.png"></div><br>  When we face external constraints on what can be said in a song, book, or film, authors must use metaphors to convey the right meaning. <br><a name="habracut"></a><br>  Take for example the classic <strong><em>Cole Porter</em></strong> song of 1928 <a href="https://www.youtube.com/watch%3Fv%3DlXYKGL6MgKM" rel="nofollow noopener">Let's Do It (Let's Fall in Love)</a> .  We all understand what is meant by ‚ÄúIt‚Äù and this is definitely <strong>not</strong> ‚Äúlet's fall in love‚Äù.  I suspect that the author had to add a part in brackets to avoid censorship. <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DfTWgjg2ZQe" rel="nofollow noopener">Fast forward</a> to 2011 and look at the <strong><em>Three 6 Mafia</em></strong> <a href="https://www.youtube.com/watch%3Fv%3DfTWgjg2ZQe" rel="nofollow noopener">Slob on my Knob</a> .  Except for the first metaphorical verse, everything else is disgustingly obvious. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we ignore for a moment the artistic execution (or lack thereof), then we can say that the Cole Porter song hints that the Three 6 Mafia dumps us with unbearable details that leave nothing to the imagination to do. <br><br>  The problem is that if you do not share the views on sex described in the texts of Three 6 Mafia, you will find the song at best vulgar and completely non-revealing.  And by including the song of Cole Porter, the listener can conjure up his own imagination. <br><br>  <strong>That is, restrictions can make the subject more attractive.</strong> <br><br><h4>  Shark broke </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dbe/35e/ab4dbe35e1d789d6452d9414af7564f1.png"></div><br>  Initially, Steven Spielberg planned to tell the story "Jaws" through scenes with a shark.  But she <strong><em>constantly</em></strong> broke.  Most of the time the film crew could not show the shark - the star of this film. <br><br>  The tape, which has become a blockbuster, would not exist in its current form, if the difficulties with the mechanics did not impose restrictions on the possibilities of Spielberg. <br><br>  Why is this movie much better than the one in which the shark is shown?  Because each viewer independently fills the gaps with the help of his imagination.  He recalls his own phobias and projects them onto the screen.  Therefore, fear is personal for each viewer. <br><br>  Animators this principle has been known for a long time.  Turn on the sound of falling behind the screen, and then show its consequences.  There are two advantages to this.  First, you do not need to animate the fall, and secondly, the fall occurs in the mind of the viewer. <br><br>  Almost all people believe that they saw how Bambi's mother was shot.  But we not only do not see how they shoot at her - we never even saw her AFTER the shot.  But people can swear that they saw both scenes.  <a href="https://www.youtube.com/watch%3Fv%3DJTZPMJj-X9M" rel="nofollow noopener">But this NEVER showed</a> . <br><br>  <strong>So the constraints are doing better.</strong>  <strong>Much better.</strong> <br><br><h4>  Choice everywhere </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9da/bfa/631/9dabfa631131870430006f535dabe004.jpg"></div><br>  Imagine that you are an artist, and I ask you to paint a picture.  The only thing I ask is: ‚ÄúDraw me something beautiful.  What I like. <br><br>  You come to your studio and sit there, looking at a blank canvas.  You look at it endlessly, and you just can‚Äôt start writing.  Why? <br><br>  Because there are too many options.  You can literally draw anything.  I have not put before you any restrictions.  This phenomenon is called the <a href="https://www.youtube.com/watch%3Fv%3DVO6XEQIsCoM" rel="nofollow noopener">paradox of choice</a> . <br><br>  However, if I asked to draw a <strong><em>landscape</em></strong> that I would like, I would at least eliminate half of the endless options.  Even though there are still an infinite number of options, any thoughts about the <strong><em>portrait</em></strong> will be quickly dismissed. <br><br>  If I went further and said that I like seascapes and waves breaking on the shore during a golden sunset, there would still be an infinite number of possible pictures, but these restrictions would actually help you think about what to draw. <br><br>  And while unknowingly you could start writing a seascape. <br><br>  <strong>So, restrictions make creativity easier.</strong> <br><br><h4>  Hardware is simpler than software </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/7e8/a37/2cf7e8a37939ab4dc144e22602bf69d0.jpg"></div><br>  In hardware, it never happens that a transistor or capacitor is used by several components of a computer.  Resistors in the keyboard circuit cannot be used by a graphic card. <br><br>  The graphics card has its own resistors, which controls only it.  Hardware engineers are not doing this because they want to sell more resistors.  They do this because they have no choice. <br><br>  The laws of the universe say that such a system cannot be created without causing chaos.  The universe sets the rules for the developers of "hardware", that is, limits the limits of the possible. <br><br>  <strong>Such restrictions make working with hardware easier than working with software.</strong> <br><br><h4>  There is nothing impossible in programs </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa2/75c/698/aa275c698acc900478daa2726d0115ec.jpg"></div><br>  We now turn to software, in which almost everything is possible.  Nothing prevents a software developer from using a variable in any part of the program.  Such variables are called global. <br><br>  In assembly language, we can simply go to any point in the code and start its execution.  And this can be done at any time.  You can even write to the data, causing the program to run unsolicited code.  This method is used by hackers who exploit <a href="https://www.youtube.com/watch%3Fv%3D1S0aBV-Waeo" rel="nofollow noopener">buffer overflow</a> vulnerabilities. <br><br>  Typically, the operating system limits the actions that a program can perform outside of its limits.  But no restrictions are imposed on what she can do with the code and data she owns. <br><br>  <strong>It is the absence of restrictions that makes writing and supporting software such a difficult task.</strong> <br><br><h4>  How to set restrictions in software development </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/6c5/963/0906c5963db1b49294057e9ce0b5d272.jpg"></div><br>  We know that when developing software we need limitations, and we know from experience that limitations in other creative professions can be for our benefit. <br><br>  We also know that we cannot allow society to randomly censor our code or place mechanical barriers that limit our paradigms.  And we cannot expect from users of such a level of qualification that they put appropriate restrictions in software design. <br><br>  We must limit ourselves.  But we must ensure that these restrictions will go to all good.  So what boundaries should we choose and how should we make such decisions at all? <br><br>  To answer this question, we can rely on our experience and years of practice.  But the most useful tool is our past mistakes. <br><br>  <strong>The pain of our previous actions, for example, when we touched the hot plate, tells us what limitations we have to put on ourselves in order to get rid of such torment in the future.</strong> <br><br><h4>  Let my people go </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd2/56a/583/fd256a583cfb903f76b30e51cb551c84.jpg"></div><br>  A long time ago people wrote programs whose code was jumping from one place to another.  This was called <strong><em>spaghetti code</em></strong> , because tracking such a code was like watching one macaroni in a pan. <br><br>  The industry realized that this practice was counterproductive and at first prohibited the use of the languages ‚Äã‚Äãin which it was allowed in the GOTO construct. <br><br>  Over time, new programming languages ‚Äã‚Äãcompletely abandoned GOTO support.  They began to be called <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow noopener">structural programming</a> languages.  And today, all popular high-level languages ‚Äã‚Äãdo not contain GOTO. <br><br>  When this happened, some began to complain that new languages ‚Äã‚Äãare too strict and that when using GOTO it is easier to write code. <br><br>  But the more progressive-minded won, and we should be grateful for their rejection of such a destructive tool. <br><br>  Progressive-minded people realized that the code is much more readable than written or changed.  That is, it may be less convenient for conservatives, but in the long run, life with this restriction will be much better. <br><br>  Computers can still run GOTO.  In fact, they even need it.  We just, as an industry as a whole, decided to limit the <strong>direct</strong> use of them by programmers.  All computer languages ‚Äã‚Äãare compiled into code using GOTO.  But language developers have created constructs that use more ordered branching, for example, using the <strong><em>break</em></strong> construct, which exits the <strong><em>for</em></strong> loop. <br><br>  <strong>The software industry has greatly benefited from the limitations set by language developers.</strong> <br><br><h4>  Putting on the shackles </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/f5e/599/509f5e59999eb3aef60a12d977358a6e.png"></div><br>  So what is GOTO today and what language developers are preparing for us, unsuspecting programmers? <br><br>  To answer this question, we need to consider the problems that we face daily. <br><br><ol><li>  Complexity </li><li>  Reuse </li><li>  Global changeable state </li><li>  Dynamic typing </li><li>  Testing </li><li>  Moore's Collapse </li></ol><br>  How can we limit the ability of programmers to solve these problems? <br><br><h4>  Complexity </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/98d/e4a/b5a98de4ad2fe60fbaaa696873a31fe0.jpg"></div><br>  The difficulty grows with time.  What is initially a simple system evolves over time into a complex one.  What begins as a complex system evolves over time into chaos. <br><br>  So how do we limit programmers to help them reduce complexity? <br><br>  First, we can force programmers to write code that is completely broken down into small pieces.  Although it is difficult, if not impossible, we can create languages ‚Äã‚Äãthat encourage and reward such behavior. <br><br>  Many functional programming languages, especially the <strong><em>purest</em></strong> , implement both of these effects. <br><br>  Writing a function that is a computation forces one to write code that is very much broken into pieces.  It also makes you think through the mental model of the task. <br><br>  We can also impose restrictions on what programmers can do in functions, for example, to make all functions <strong><em>clean</em> .</strong>  <strong><em>Pure functions</em></strong> are those that have no side effects, for example, functions cannot access data outside of them. <br><br>  Pure functions work only with the data passed to them, calculate their results and transfer them.  Each time you call a pure function with the same input data, it will ALWAYS produce the same output. <br><br>  This makes working with pure functions much more logical, because all the tasks they perform are entirely within the function itself.  It is also easier for them to perform unit testing, because they are self-sufficient units.  If the calculations of such functions turn out to be costly, then their results can be cached.  If you have the same input data, then you can be sure that the output is always the same too - the perfect scenario for using the cache. <br><br>  <strong>By limiting programmers to pure functions, we significantly limit complexity, because functions can have only local influence;</strong>  <strong>In addition, it helps developers naturally break apart their program.</strong> <br><br><h4>  Reuse </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/378/b0a/dbc/378b0adbce320fcee6a6a4e4ebd1c84a.png"></div><br>  The software industry has been struggling with this problem almost from the very beginning of programming.  First we had libraries, then structured programming, and then object-oriented inheritance. <br><br>  All of these approaches have limited appeal and success.  But there is one way that always works and has been used by almost every programmer - Copy / Paste, or copy-paste. <br><br><blockquote>  If you copy and paste your code, then you do something wrong. </blockquote><br>  We cannot forbid programmers to copy-paste, because they still write programs in the form of text, but we can give them something better. <br><br>  In functional programming, there are standard practices that are much better than copy-paste, namely <strong><em>, higher-order functions</em></strong> , <strong><em>currying (currying),</em></strong> and <strong><em>composition</em></strong> . <br><br>  <strong><em>Higher-order functions</em></strong> allow programmers to pass parameters that are data <strong><em>and</em></strong> functions.  In languages ‚Äã‚Äãthat do not support this feature, the only solution is to copy and paste the function and then edit the <strong><em>logic</em></strong> .  Thanks to higher-order functions, logic can be passed as a parameter as a function. <br><br>  <strong><em>Currying (currying)</em></strong> allows you to apply to a function one parameter at a time.  This allows programmers to write generalized versions of functions and bake <strong><em>some</em></strong> of the parameters to create more specialized versions. <br><br>  <strong><em>The composition</em></strong> allows programmers to assemble functions like Lego cubes, allowing them to reuse the functionality that they or others have built into the pipeline, in which data passes from one function to another.  The simplified form of this is Unix pipelines. <br><br>  <strong>So, although we cannot get rid of copy-paste, we can make it optional thanks to the support of the language and by analyzing the code that prohibits its presence in the code bases.</strong> <br><br><h4>  Global changeable state </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98b/604/8cb/98b6048cb66caad0ed7a3da4d075224b.png"></div><br>  This is probably the greatest problem in programming, although many do not realize it as a problem. <br><br>  Have you ever wondered why most often software ‚Äúbugs‚Äù are corrected by restarting the computer or restarting the problem application?  This happens because of the condition.  The program damages its condition. <br><br>  Somewhere in the program, the state changes in an unacceptable way.  Such "bugs" are usually one of the most difficult to fix.  Why?  Because they are very difficult to reproduce. <br><br>  If you fail to consistently reproduce such a "bug", then you can not find a way to fix it.  You can check your fix and nothing will happen.  But did it happen because the problem is fixed, or because it has not yet arisen? <br><br>  <strong>Proper state management is the most important principle that needs to be implemented to ensure program reliability.</strong> <br><br>  Functional programming solves this problem by setting restrictions for programmers at the language level.  <strong><em>Programmers cannot create mutable variables.</em></strong> <br><br>  At first it seems that the developers have gone too far, and it is time to raise them on the forks.  But when you really work with such systems, you can see that you can control the state, at the same time making all data structures <strong><em>immutable</em></strong> , that is, after the variable gets its value, it can <strong>never</strong> change. <br><br>  This does not mean that the state can not change.  It simply means that to do this, you must pass the current state to the function that creates the new state.  While you, hacking lovers, have not begun to sharpen your pitchfork again, I can assure you that there are mechanisms for optimizing such operations "behind the scenes" with the help of <a href="https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504" rel="nofollow noopener">Structural Sharing</a> . <br><br>  Please note that such changes occur "under the hood."  As in the old days of GOTO destruction, the compiler and the executable program still use GOTO.  They are simply not available to programmers. <br><br>  Where side effects should occur, functional programming has ways of limiting potentially dangerous parts of a program.  In good implementations, these parts of the code are clearly marked as dangerous and are separated from the clean code. <br><br>  And when in 98% of the code there are no side effects, the spoiling state of the bugs can remain only in the remaining 2%.  This gives the programmer a good chance to find errors of this type, because the dangerous parts are driven into a pen. <br><br>  <strong>That is, by limiting programmers to purely (or at most) pure functions, we create more secure and reliable programs.</strong> <br><br><h4>  Dynamic typing </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/cc7/c7e/1c9cc7c7e9c60b377dae05d378bf5e6c.jpg"></div><br>  There is another long and old argument about <strong><em>static typing</em></strong> and <strong><em>dynamic typing</em></strong> .  <strong><em>Static typing</em></strong> is when the type of a variable is checked at compile time.  After you specify the type, the compiler helps you determine if you are using it correctly. <br><br>  The objections against static typing are that it puts an unnecessary burden on the programmer and contaminates the code with detailed typing information.  And this typing information is syntactically ‚Äúnoisy‚Äù because it is next to the definition of functions. <br><br>  With <strong><em>dynamic typing, the</em></strong> type of the variable is never specified and is not checked at the compilation stage.  In fact, most languages ‚Äã‚Äãwith dynamic typing are non-compiled. <br><br>  The objections against dynamic typing are that despite significant code cleaning, the programmer cannot track all instances of the variable being misused.  They cannot be detected until the program is launched.  This means that, despite all efforts, type errors get to the production stage. <br><br>  So what's better?  Since here we are considering the restriction of programmers, you probably expect me to advocate static typing, despite its shortcomings.  Generally yes, but why don't we take the best of both worlds? <br><br>  It turns out that not all systems with static typing are created equal.  Many functional programming languages ‚Äã‚Äãsupport <strong><em>type inference</em></strong> , in which the compiler can determine the types of functions you create based on how you use them. <br><br>  This means that we can use static typing without setting too much types.  Recommendations tell us that typing should be defined, not determined by the compiler, but in languages ‚Äã‚Äãsuch as Haskell and Elm, the typing syntax does not actually destroy the structure and is quite useful. <br><br>  Non-functional, i.e.  imperative languages ‚Äã‚Äãwith static typing make it hard for a programmer to specify types without giving almost anything in return. <br><br>  Compared to them, the Haskell and Elm type systems actually help programmers to code better and notify them at compile time if the program does not work correctly. <br><br>  <strong>So, by limiting programmers to good static typing, the compiler can help in recognizing errors, identify types and help in coding, and not burden the developer with verbose, obsessive information about types.</strong> <br><br><h4>  Testing </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aef/75c/4b8/aef75c4b843af44c8488674f58a3727d.jpg"></div><br>  Writing test code poisons the life of a modern programmer.  Very often, developers spend more time writing test code than on the test code itself. <br><br>  Writing test code for functions interacting with databases or web servers is difficult (if not impossible) to automate.  Usually there are two options. <br><br><ol><li>  Do not write tests </li><li>  Simulate database or server </li></ol><br>  Option 1 is definitely not the best, but many people choose it, because imitating complex systems can be more time consuming than writing a module that needs to be tested. <br><br>  But if we restrict the code to pure functions, they will not be able to <strong><em>directly</em></strong> interact with the database, because this can lead to side effects or mutations.  We still need to access the database, but now our layer of dangerous code will be a very thin interface layer, while most of the module remains clean. <br><br>  Testing pure functions is much easier.  But we still need to write the test code that will poison our lives.  Or not? <br><br>  It turns out that there are programs for <strong><em>automatic testing of</em></strong> functional programs.  The only thing that a programmer should provide are properties that functions should follow, for example, inverse functions.  Haskell‚Äôs automated tester is called <a href="https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing" rel="nofollow noopener">QuickCheck</a> . <br><br>  <strong>So, by limiting most of the functions so that they are clean, we make testing much easier, and in some cases just trivial.</strong> <br><br><h4>  Moore's Collapse </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/20d/581/95820d5816c07e220131f73a812aeacd.jpg"></div><br>  <strong><em>Moore's law</em></strong> is not really a law, but a practical observation, is that the computing power of computers doubles every two years. <br><br>  This law has been fair for over 50 years.  But, unfortunately, we have reached the limits of modern technology.  And the development of technology for creating computers not based on silicon may take decades. <br><br>  Until then, the best way to double the speed of a computer is to double the number of cores, i.e.  the number of computing "engines" of the CPU.  But the problem is not that the manufacturers of "iron" can not give us more cores.  The problem is batteries and software. <br><br>  Doubling the processing power means doubling the power consumed by the processor.  This will lead to even more battery consumption than today.  Battery technology lags far behind the insatiable appetites of users. <br><br>  Therefore, instead of adding new cores, discharging batteries, we may need to optimize the use of existing cores.  This is where software comes into play.  In modern imperative programming languages, it is very difficult to make programs run in parallel. <br><br>  Today, the implementation of parallelism is a heavy burden for a programmer.  The program must be cut lengthwise and across into parallel parts.  This is not an easy task.  And in practice, in languages ‚Äã‚Äãsuch as JavaScript, programmers cannot control this, because the code cannot run in parallel, it is single-threaded. <br><br>  But when using pure functions, it does not matter in which order they are performed.  The most important thing about them is the availability of input data.  This means that the compiler or the execution system can determine when and what functions to perform. <br><br>  <strong>Limiting only to pure functions, the programmer gets rid of the concern for concurrency.</strong> <br><br>  Functional programs will be able to optimally <a href="https://wiki.haskell.org/Haskell_for_multicores" rel="nofollow noopener">use the advantages of multi-core machines</a> without increasing the complexity for the developer. <br><br><h4>  Do more with less </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/e49/a5e/8e3e49a5e4b1d534cc4121fb43aa3af3.jpg"></div><br>  As we can see, with the right restrictions, we can significantly improve our artwork, design and life itself. <br><br>  The hardware developers have greatly benefited from the natural limitations of their tools, which have simplified their work and have made amazing progress over the past decades. <br><br>  It seems to me that for us, software developers, it is time to limit ourselves in order to achieve more. </div><p>Source: <a href="https://habr.com/ru/post/345886/">https://habr.com/ru/post/345886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345874/index.html">Publish the application in the AppStore. A play without dialogue in several acts</a></li>
<li><a href="../345876/index.html">Hack Hill's cipher? Easy</a></li>
<li><a href="../345880/index.html">IT history lawyer. Life is business outsourcing. Part 1</a></li>
<li><a href="../345882/index.html">Exhaustive javascript reference for your next job interview. Part 1</a></li>
<li><a href="../345884/index.html">Don't you program yourself a burnout?</a></li>
<li><a href="../345890/index.html">Third cosmic speed for MS SQL Server</a></li>
<li><a href="../345892/index.html">MegaFon Big Data Challenge: big data against "deer", loneliness and much more</a></li>
<li><a href="../345894/index.html">Reiser4 code check with PVS-Studio static analyzer</a></li>
<li><a href="../345896/index.html">Flexible methodology for mobile development</a></li>
<li><a href="../345898/index.html">Dagger 2 for novice Android developers. Dagger 2. Advanced. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>