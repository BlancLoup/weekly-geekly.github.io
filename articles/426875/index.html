<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The architecture of the meta-server mobile online shooter Tacticool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Another report from Pixonic DevGAMM Talks - this time from our colleagues from PanzerDog. Lead Software Engineer of the company Pavel Platto dismantle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The architecture of the meta-server mobile online shooter Tacticool</h1><div class="post__text post__text-html js-mediator-article">  Another report from <a href="https://habr.com/company/pixonic/blog/420789/">Pixonic DevGAMM Talks</a> - this time from our colleagues from PanzerDog.  Lead Software Engineer of the company Pavel Platto dismantled the game's meta-server with a service-oriented architecture, told what solutions and technologies were chosen, what and how they scale, and what difficulties they had to face.  The text of the report, slides and links to other presentations from the mitap, as always, under the cut. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JcuOHUzXXHw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  First I want to demonstrate a small trailer for our game: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yIpGvbbMCn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The report will consist of 3 parts.  In the first, I will talk about what technologies we have chosen and why, in the second, how our meta-server works, and in the third I will talk about the various supporting infrastructure that we use and how we have implemented the update without downtime. . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/-s/fg/tz/-sfgtzhre4ij6b0n9-b_r0cako4.png"><br>  <i>Technology stack</i> <br><br>  The meta server is hosted on Amazon and written in the Elixir language.  This is a functional programming language with an actor computation model.  Since we do not have Ops, programmers are involved in the operation, and most of the infrastructure is described in the form of code using HashiCorp's Terraform. <br><br>  At the moment, Tacticool is at the stage of open beta test, the meta-server is in development a little over a year and in operation for almost a year.  Let's see how it all began. <br><br><img src="https://habrastorage.org/webt/zs/a0/fa/zsa0favmdahf0gdsnt0-goxhrnq.png"><br><br>  When I joined the company, we already had the basic functionality implemented as a monolith on a mixture of C / C ++ and PostageSQL stores.  This implementation had some problems. <br><br>  First, because of the low-level C, there were quite a few elusive bugs.  For example, for some players, matchmaking was tightly suspended due to incorrect resetting of the array before re-using it.  Of course, to find the relationship of these two events was quite difficult.  And since the state from several threads was modified throughout the code, it was not without Race conditions. <br><br>  A parallel processing of a large number of tasks was also out of the question, because the server started at the start about 10 workflow processes that were blocked when querying Amazon or the database.  And even if we forget about these blocking requests, the service began to crumble on a couple of hundreds of connections that did not perform any operations other than ping.  In addition, the service was impossible to scale horizontally. <br><br>  After a couple of weeks spent searching for and fixing the most critical bugs, we decided that it was easier to rewrite everything from scratch than to try to fix all the shortcomings of the current solution. <br><br>  And when you start from scratch, it makes sense to try to choose a language that will help avoid some of the previous problems.  We had three candidates: <br><br><ul><li>  C #; </li><li>  Go; </li><li>  Elixir. </li></ul><br><img src="https://habrastorage.org/webt/_f/vt/q5/_fvtq51jwvlo2uuquqy-4vwsnhw.png"><br><br>  C # got to the list of "an acquaintance", because  Our client and game server are written in Unity and the most experience in the team was with this programming language.  Go and Elixir were considered, because these are modern and quite popular languages ‚Äã‚Äãcreated for developing server applications. <br><br>  The problems of the previous iteration helped us determine the criteria for evaluating candidates. <br><br>  The first criterion was the convenience of working with asynchronous operations.  In C #, convenient work with asynchronous operations did not appear on the first attempt.  This led to the fact that we have a ‚Äúzoo‚Äù of solutions, which, in my opinion, still stand a little to the side.  In Go and Elixir, this problem was taken into account when designing these languages, they both use lightweight flows (in Go they are gorutines, in Elixir they are processes).  These streams have a much smaller overhead projector than the system ones, and since we can create them by tens and hundreds of thousands, we don‚Äôt feel sorry for blocking them. <br><br>  The second criterion was the ability to work with competitive processes.  C # out of the box does not offer anything other than routepools and shared memory, access to which needs to be protected using various synchronization primitives.  Go has a less error-prone model in the form of gorutin and channels.  Elixir, on the other hand, offers an actorless model with no shared memory and communication through messaging.  The lack of shared memory made it possible to implement in the runtime such technologies that are useful for a competitive environment of execution, such as honest displacing multitasking and garbage collection without stopping the world. <br><br>  The third criterion was the availability of tools for working with immutable data types.  All my development experience has shown that quite a large part of the bugs are related to incorrect data changes.  The solution for this exists long ago - immutable data types.  In C #, you can create these types of data, but at the cost of a ton of boilerplate.  In Go, this is generally not possible.  And in Elixir, all data types are immutable. <br><br>  And the last criterion was the number of specialists.  Here the results are obvious.  In the end, we opted for Elixir. <br><br>  With the choice of hosting everything was much easier.  Game servers we already hosted at Amazon GameLift, in addition, Amazon offers a large number of services that would allow us to reduce development time. <br><br><img src="https://habrastorage.org/webt/f2/zm/jn/f2zmjnyjejb3ffw0vhs69hvqjoi.png"><br><br>  We have completely ‚Äúsurrendered‚Äù to the cloud and are not deploying any third-party solutions ourselves ‚Äî the database, the message queue ‚Äî all of this is managed by Amazon.  In my opinion, this is the only solution for a small team that wants to develop an online game, and not an infrastructure for it. <br><br>  With the choice of technology figured out, let's move on to how the meta-server works. <br><br><img src="https://habrastorage.org/webt/q1/jy/m8/q1jym8itnftw6e3tqyvsbqh-uva.png"><br><br>  In general terms, clients connect to the load balancer at Amazon using web socket connections;  The balancer scatters these connections between several frontend instances, the frontend sends client requests to backends.  But the frontend and backend communicate indirectly through message queues.  For each type of message there is a separate queue and the frontend, by the type of messages, determines where to write it, and the backends listen to these queues. <br><br>  In order for the backend to send a response to a request to the client, or some event, a separate queue is attached to each front end (specially allocated for it).  And in each request, the backend gets the frontend identifier to determine which queue to write the response to.  If he needs to send an event, he accesses the database to find out which frontend instance is connected to the client. <br><br>  With the general scheme of everything, let's get to the details. <br><br><img src="https://habrastorage.org/webt/xe/rr/u-/xerru-5vn3tx-dwqbylflu18mrm.png"><br><br>  First, I will talk about some of the features of client-server interaction.  We use our binary protocol because it is quite efficient and saves traffic.  Secondly, for any operations with an account that change it, the server sends to the client not these changes, but the full (updated) version of this account.  This is a little less efficient, but it still doesn‚Äôt take up so much space and makes life much easier for us both on the client and on the server.  Also, the frontend ensures that the client performs no more than one request at a time.  This allows you to catch bugs on the client, for example, when it goes to another screen before the player sees the result of the previous operation. <br><br>  Now a little about how the frontend works. <br><br><img src="https://habrastorage.org/webt/te/-k/ff/te-kffgzvatzj_3tjwcus5lvpdk.png"><br><br>  A frontend is, in essence, a web server that listens to web socket connections.  For each session, two processes are created.  The first process serves the web socket connection itself, and the second is the state machine that describes the current state of the client.  Based on this state, it determines whether requests from the client are valid.  For example, almost all requests cannot be executed until authorization is complete.  Since there is no state on the frontend except for these sessions, it is very easy to add new frontend instances, but it is a bit more difficult to delete old ones.  Before deleting, you must let all clients complete their current requests and ask them to reconnect to another instance. <br><br>  Now how the backend looks like.  At the moment it consists of five services. <br><br><img src="https://habrastorage.org/webt/qh/cj/x4/qhcjx4ckmzg8lcqpriouhi8rnee.png"><br><br>  First deals with everything related to accounts - from purchases for in-game currency to completing quests.  The second works with everything related to matches - it directly interacts with GameLift and game servers.  The third service is shopping for real money.  The fourth and fifth are responsible for social interaction - one for friends, the other for the game of party. <br><br>  Each of the back-end services from an architectural point of view looks absolutely identical.  They are a set of pipelines, each of which processes one type of message.  Pipeline consists of two elements: producer and consumer. <br><br><img src="https://habrastorage.org/webt/ym/di/eh/ymdiehrcngon3im1my2d8nbbgsk.png"><br><br>  The producer‚Äôs sole task is to read messages from the queue.  Therefore, it is implemented completely in a general form and for each pipeline we only need to specify how many producers there are, from which queue to read and how many consumer'ov each producer will serve.  Consumer is implemented for each pipeline separately and is a module with the only mandatory function that accepts one message, does all the necessary work and returns a list of messages that need to be sent to other services to the client, or to the game server.  The producer also implements back pressure so that with a sharp increase in the number of messages there is no overload, and it requests no more messages than it has free consumers. <br><br>  Backend services do not contain any state, so it is easy for us to add and remove old instances.  The only thing you need to do before deleting is to ask the producers to stop reading the new messages and give the consumer some time to finish processing the active messages. <br><br>  How does the interaction with GameLift'om.  GameLift consists of several parts.  Of those that we use, this is the matchmaker FlexMatch, the queue of placements, which determines in which particular region to place the gaming session with these players, and the fleets themselves, consisting of game servers. <br><br><img src="https://habrastorage.org/webt/c8/ge/5h/c8ge5huiowlmu5q7b9izd4sew4y.png"><br><br>  How does this interaction occur?  Meta directly communicates only with the matchmaker, sends him requests to find a match.  And he notifies Meta about all events during matchmaking through the same message queues.  And as soon as he finds a suitable group of players to start a match, he sends an application to the queue for postings, which in turn selects a server for them. <br><br>  Interaction meta with the game server is extremely simple.  The game server needs information about accounts, bots, and the map, and all this information is sent to the queue by the queue created specifically for this match in a single message. <br><br><img src="https://habrastorage.org/webt/vv/zo/y5/vvzoy5ycub5em-qiovlo911pg0k.png"><br><br>  When the game server is activated, it starts listening to this queue and receives all the data it needs.  At the end of the match, he sends his results to the general queue that meta listens to. <br><br>  We now turn to the additional infrastructure that we use. <br><br><img src="https://habrastorage.org/webt/l-/st/nu/l-stnuybsqrbk_be4fhlgrsdgpa.png"><br><br>  Deploying services is quite simple.  They all work in docker containers, and for orchestration we use Amazon ECS.  It is much simpler than Kubernetes, of course, less sophisticated, but it performs the tasks that we need from it.  Namely: scaling services and rolling releases, when we need to fill in some bugfix. <br><br>  And the last service we also use is AWS Fargate.  It saves us from the need to independently manage the cluster of machines that run our docker containers. <br><br><img src="https://habrastorage.org/webt/q1/xl/8m/q1xl8mppdukmbjoezzm6pzlbl9k.png"><br><br>  We use DynamoDB as our primary storage.  First of all, we chose it because it is very easy to exploit and scale.  We also use Redis as additional storage through the managed Amazon ElasiCache service.  We use it for the global player rating task and for caching basic account data in situations where we need to return data on hundreds of game accounts to the client at once (for example, in the same rating table or in the list of friends). <br><br>  For storing configs, meta-gameplay mechanics, descriptions of weapons, heroes, etc.  we use a JSON file that we enclose in the images of the services that need it.  Because it is much easier for us to roll out a new version of the service with updated data (if any bug was discovered) than to make a solution that will dynamically update this data from some external storage in runtime. <br><br>  For logging and monitoring, we use quite a lot of services. <br><br><img src="https://habrastorage.org/webt/lh/ub/3u/lhub3urulc1urcn8omuxprcn0rg.png"><br><br>  Let's start with CloudWatch.  This is a monitoring service in which metrics from all Amazonian services flow.  Therefore, we decided to send metrics from our meta-server there too.  And for logging, we use a common approach both on the client and on the game server and on the meta server.  All logs we send to the Amazon service Kinesis Firehose, which in turn shifts them to Elasticseach and S3. <br><br>  In Elasticseach, we store only relatively fresh data and with the help of Kibana we look for errors, solve some of the problems of game analytics and build operational dashboards, for example, with the CCU schedule and the number of new installations.  In S3 there are all historical data and we use them through the Athena service, which provides a SQL interface over the data in S3. <br><br>  Now a little about how we use Terraform. <br><br><img src="https://habrastorage.org/webt/o8/jj/-q/o8jj-qfa1hsyq1qposebwbof4dc.png"><br><br>  Terraform is a tool that allows you to declare the infrastructure declaratively and with any change in the description, it automatically determines the actions that must be performed to bring your infrastructure to an updated form.  Thus, having a single description, we get an almost identical environment for staging and production.  Also, these environments are completely isolated, because they are deployed under different accounts.  The only significant drawback of Terraform for us is the incomplete support for GameLift. <br><br>  I‚Äôll also tell you how we implemented the update without downtime. <br><br><img src="https://habrastorage.org/webt/_l/ge/va/_lgevakn50wndn5tvfipi1_ujam.png"><br><br>  When we release updates, we pick up a copy of most resources: services, message queues, some labels in the database.  And those players who download the new version of the game will connect to this updated cluster.  But those players who have not yet been updated can continue to play the old version of the game for some time, connecting to the old cluster. <br><br>  How we implemented it.  First, using the modular mechanism in Terraform.  We selected a module in which we described all versioned resources.  And these modules can be imported several times, with different parameters.  Accordingly, for each version we import this module, indicating the number of this version.  Also, the lack of a scheme in DynamoDB helped us, which makes it possible to perform data migration not during an update, but to postpone them for each account until its owner logs into the new version of the game.  And in the balancer, we simply indicate for each version of the rule, so that he knows where to route the players with different versions. <br><br>  Finally, a couple of things that we have learned.  First, the configuration of the entire infrastructure must be automated.  Those.  we set up some things with our hands for some time, but sooner or later we were mistaken in the settings, because of what fakapu happened. <br><br><img src="https://habrastorage.org/webt/5i/3n/7f/5i3n7fuurk18kiak_krk6jy8w8s.png"><br><br>  And the last - for each element of your infrastructure you need to have either a replica or a backup copy.  And if for some reason it is not done, then it is this thing that will ever let us down. <br><br><h3>  Questions from the audience </h3><br>  <b>- Does it bother you that autoscaling can zaskeilitsya too much up due to some kind of error and you will get a lot of money?</b> <br><br>  - For autoscaling, limits are set anyway.  We will not put too big a limit, so as not to get a lot of money.  This is a basic solution + monitoring.  You can set alerts if something zaskeylilos too much. <br><br>  <b>- At the moment you have any limits?</b>  <b>Relative to current infrastructure as a percentage.</b> <br><br>  - Now we have a stage of open beta test in 11 countries, so not so big CCU to at least somehow evaluate.  Now the infrastructure is too overprovisioned for the number of people we have. <br><br>  <b>- And there are no limits yet?</b> <br><br>  - There are, they are just 10-100 times larger than the SSU with us.  Do not do less. <br><br>  <b>- You said that you have a queue between the front and backend - this is very unusual.</b>  <b>Why not directly?</b> <br><br>  ‚ÄúWe wanted stateless services to easily implement a backprese mechanism so that the service does not request more messages than it has free handlers.  Also, for example, when the handler fills, the queue will issue the same message to another handler - maybe something will work out. <br><br>  <b>- Does the queue persist somehow?</b> <br><br>  - Yes.  This is Amazon SQS service. <br><br>  <b>- Regarding the queues: how many channels do you have during the game?</b>  <b>Do you have a certain number of channels for every match?</b> <br><br>  - It is created relatively little.  Most of the queues, such as request queues, are static.  There is a queue of requests for authorization, there is a queue at the start of the match.  From the dynamically created queues, we only have queues for each frontend (it starts up for incoming messages for customers) and for each match we create one queue.  In this service, it costs almost nothing, they have every request is the same.  Those.  Any request to SQS (create a queue, read something from it) is the same and at the same time we do not delete these queues to save, they themselves are then deleted.  And the fact that they exist does not cost us anything. <br><br>  <b>- In this architecture, it will not be your limit?</b> <br><br>  - Not. <br><br><h3>  More reports from Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://habr.com/company/pixonic/blog/424777/">Using Consul to scale stateful services</a> (Ivan Bubnov, DevOps at BIT.GAMES); </li><li>  <a href="https://habr.com/company/pixonic/blog/425813/">CICD: Seamless Deploy on Distributed Cluster Systems without Downtime</a> (Egor Panov, Pixonic System Administrator); </li><li>  <a href="https://habr.com/company/pixonic/blog/426115/">Practice using the model of actors in the back-platform platform of the Quake Champions game</a> (Roman Rogozin, backend developer of Saber Interactive); </li><li>  <a href="https://habr.com/company/pixonic/blog/427359/">How ECS, C # Job System and SRP change the approach to architecture</a> (Valentin Simonov, Field Engineer in Unity); </li><li>  <a href="https://habr.com/company/pixonic/blog/427797/">KISS principle in development</a> (Konstantin Gladyshev, Lead Game Programmer at 1C Game Studios); </li><li>  <a href="https://habr.com/company/pixonic/blog/429312/">General game logic on the client and server</a> (Anton Grigoriev, Deputy Technical Officer in Pixonic). </li><li>  <a href="https://habr.com/company/pixonic/blog/428349/">Cucumber in the cloud: using BDD scripts for load testing a product</a> (Anton Kosyakin, Technical Product Manager in ALICE Platform). </li></ul></div><p>Source: <a href="https://habr.com/ru/post/426875/">https://habr.com/ru/post/426875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426861/index.html">New hunt for dark matter passes under the mountain</a></li>
<li><a href="../426863/index.html">Available on quaternions and their benefits</a></li>
<li><a href="../426865/index.html">Understandable dashboard design for complex advertising management system</a></li>
<li><a href="../426869/index.html">How to effectively conduct videoconferencing with foreign customers</a></li>
<li><a href="../426873/index.html">Automatic control using Windows registry remote access</a></li>
<li><a href="../426879/index.html">Configuring an electrical constraint system for projects using high-speed interfaces</a></li>
<li><a href="../426881/index.html">Launch of online software for developers</a></li>
<li><a href="../426889/index.html">How to participate in machine learning competitions. Lecture in Yandex</a></li>
<li><a href="../426891/index.html">SAP Process Mining or how to understand your business processes</a></li>
<li><a href="../426893/index.html">How to run an iOS application through React Native</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>