<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What tests do you need? Part 2. Test matrix</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 In the first part of a series of articles, I talked about what the choice of tests depends on. Having in mind the understanding of what y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What tests do you need? Part 2. Test matrix</h1><div class="post__text post__text-html js-mediator-article"><h5>  annotation </h5><br>  <a href="http://habrahabr.ru/post/246211/">In the first part of a</a> series of articles, I talked about what the choice of tests depends on.  Having in mind the understanding of what you want to achieve with testing, you can take the next step - choose tests.  For this you need to understand what tests are in general. <br><br>  Almost all articles devoted to types of testing, have a grouping of tests in some categories.  Only this division does not always coincide.  Reading into such articles, you often find discrepancies in terminology among different authors. <br><br>  I set myself the goal to sort through, visualize a variety of tests to help those who choose which tests they need and those who study the testing itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I do not undertake to give clear definitions of the types of testing in this article.  The interpretation of the terms used for the name of the species will be discussed in the third part.  This division is associated with the amount of information. <br><a name="habracut"></a><br><h4>  Classification of types of testing </h4><br>  At the types of tests can be viewed from different sides.  And classify them as difficult as, for example, culinary dishes.  You can group dishes according to national cuisine, you can by reception time (for breakfast, for lunch, for dinner), you can by ingredients used, you can by calorie and so on.  The products themselves - can also be divided into groups according to various criteria.  At the same time, everyone understands that a steak can be an evening meal, while it does not cease to be a meat dish and cause controversy about belonging to the national cuisine.  So tests - regression test can be an integration. <br><blockquote>  Belonging to one category does not exclude belonging to another. </blockquote><br>  Another example - fatty food can be called both a dish and a product - cheburek and vegetable oil.  A vulnerability test can be a set of automated scripts and one test case in a set of functional acceptance tests of the input form. <br><blockquote>  A test type is a characteristic that can be possessed by both a single test script and a whole collection of tests. </blockquote><br>  See what kind of cute minds with wine: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/769/a47/abd/769a47abd2e65f8c948b5d716f2a6bd1.png" alt="the blame" width="200"></a> <br>  It would seem that it completely covers all types of wines.  And now look at it again and list the wines by country of production, as they are placed in the supermarket or in the restaurant menu.  Does not work?  How, then, to choose?  This card is not suitable for selection by manufacturers.  If you look closely - there is a postscript "in style and taste." <br><br>  That's the same with the types of tests. <br><blockquote>  By limiting ourselves to one criterion for grouping, we lose sight of the whole variety of tests. </blockquote><br>  A grouping criterion may be a key selection criterion. <br><br><h5>  Test Type Map </h5><br><br>  I like the approach that was <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">used in the Wikipedia article about software testing</a> , since a lot of cuts were considered. <br><br>  I took this list as a basis and supplemented it with information drawn from other sources and personal experience and compiled the mind map (knowledge map).  This map is useful to me in the process of planning tests - I check if I have forgotten what.  I share the scheme with you: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c9/cfb/c77/8c9cfbc77e03070ba6f2ba47eeec6cc2.png" alt="image"><br><br>  <a href="">View full size.</a> <br>  Download the source in xmind format <a href="http://www.xmind.net/m/5HiG/">here</a> . <br><br>  Test titles are in English to avoid translation inaccuracies. <br><br><h6>  Flower Growers </h6><br><ul><li>  <b>Blue</b> highlights the features applicable to test sets. </li><li>  <b>Yellow</b> highlights characteristics applicable only to test cases. </li><li>  <b>Green</b> highlights universal specifications. </li></ul><br>  This division is conditional, there may be exceptions. <br><br><h6>  About yellow blocks in the knowledge map </h6><br>  Looking at my map, you might think that the division of tests according to the types of scenarios is not so important.  In fact, specific test cases many times more than sets, and <br><blockquote>  having missed some kind, you lose a bunch of valuable checks, and, therefore, defects. </blockquote><br><br>  The types of tests that are listed in the Scripts node are actually the names of the scripting techniques.  Compliance with these techniques gives specific tests at the output.  Therefore, in my opinion, it is appropriate to present them as types of tests. <br><br>  The mentioned techniques are considered to be the types of black box tests.  Why these tests on my scheme do not apply to the Black Box?  Because even when testing a specification, you need to think about what will happen if you enter a value larger than the allowable one, and how the system should react to errors in general.  One has to think about this when writing unit tests, which are not related to the Black Box. <br><br><h6>  About green blocks in the knowledge map </h6><br>  In fact, these names are types of requirements.  Tests covering a specific type of requirement are logical to call tests of this requirement.  Most of the names of the tests placed in blue blocks also came out of the names of the requirements.  For example, ‚Äúthe application must be fault tolerant‚Äù generates fault tolerance tests. <br><br>  Green blocks differ from blue ones in that they are rarely mentioned in Russian-speaking reviews of test types.  However, if you, for example, look for the phrase ‚Äúsuitability testing‚Äù, you will find many useful things. <br><br><h4>  How to use the card </h4><br>  My mind map of types of testing, in fact, is a graph, specifically a tree.  My favorite XMind application makes it very easy to change the structure of a knowledge map with a tree and other views.  But there are many letters in the text, therefore the tree becomes wide and not convenient for perception. <br><br>  This tree has 10 large branches - the first level of the graph is the classification criteria.  Obviously, they are not types of tests themselves. <br><br>  I hope that you know the difference between a wide search and a deep search.  In my deep conviction, errors in understanding and choosing tests occur because of the desire to find a satisfactory solution in a faster way, which pushes to search in depth.  2-level (heading - list) lists of types of testing this greatly contribute. <br><br>  Need to search in width.  Because on each branch of the given graph there are tests that you need.  It should also be done when trying to characterize existing test kits.  The same test will have several different characteristics. <br><blockquote>  Spoiler: when you study all types of tests, you will find that in each category there are types of tests you need </blockquote><br><br><h4>  Classification criteria </h4><br>  Let's start, let's go over the width of the upper level of the tree. <br><br><h5>  1. Type of requirements </h5><br>  All tests depend on what is required from the software being developed. <br><br>  If we have something to develop, then there is something to test.  The presence of formally described requirements is a very important thing, but it is not mandatory.  It does not matter whether you have a piece of paper called ‚ÄúTK‚Äù / ‚ÄúSRS‚Äù or not - there are always requirements on the basis of which you are conducting the check. <br><br>  We can clarify, of course, what operations are needed, or understand and do it according to our vision, but somehow we already have the minimum requirements. <br><blockquote>  No requirements - no development.  The reverse is also true - there is a development -&gt; there are requirements. </blockquote><br>  We can assume that there are no requirements if the developers did not understand what was expected of them and could not get to work.  I know good developers who do not start development until they get an answer to the question: ‚Äúwhy should this software do this and that?  What is the end use? ‚Äù <br><br>  If the developers work, then there are requirements, another question is the accuracy of their understanding. <br><br>  For example, ‚Äúthe task is to make a calculator, which will have buttons, and which will perform all mathematical operations‚Äù contains a lot of requirements in itself. <br><br>  Understand your current understanding of what is expected from the software being developed, by the types of requirements that you see in my mind file.  If you are aiming for a full test coverage, then <br><blockquote>  You need all kinds of tests from the first group. </blockquote><br>  If you need only the "minimum required", and not "necessary and sufficient" - use the functional suitability and accuracy tests. <br><br>  Details on the functional tests will be discussed in the third part. <br><br>  At this step, many stop.  " <i>We need functional tests</i> ."  But we must go further. <br><br><h5>  2. The object of testing </h5><br>  The most fertile approach to classifying tests is categorization by test object.  There is a great variety of technologies, interfaces, architectures, functional purposes and system characteristics.  Everything requires its own approach to testing.  Different methods and tools. <br><br>  I will attach this group separately: <br><img src="https://habrastorage.org/files/515/9f4/587/5159f45874db409c9ffd72d95303f28d.PNG"><br><br>  On the right, I wrote three groupings, <u>they are conditional</u> , so they are not parent nodes.  Because these requirements can be both functional and non-functional, depending on what we develop.  In general, we will carry out infrastructure before and for transfer to production.  And the operational ones will be carried out on a prod-like environment, when it will be already determined what hardware our system will live on. <br><br>  Full security testing, for example for certification in the FSB, can be part of infrastructure tests if you use hardware protection methods or external system modules that we do not develop ourselves.  And some security tools will be ‚Äúsewn‚Äù into our software and tested as part of the functional requirements. <br><br>  For example, as part of testing the function of sending a transaction message from an ATM to an issuing bank, we will verify the encryption of the PIN code. <br><br>  It is very important to understand that <br><blockquote>  Types of tests for test objects are not types of functional tests. </blockquote><br>  As well as performance tests, fault tolerance, etc.  - not always types of NFR. <br><br>  Consider the examples. <br><br>  <b>Example 1.</b> There is a non-functional requirement ‚Äúif a component fails, its functions must be performed by another, parallel component‚Äù.  Accordingly, the requirement will be covered by non-functional tests - stress tests, reliability and stability tests. <br><br>  <b>Example 2.</b> Consider the case where fault tolerance is a functional requirement.  For example, a failover cluster is being developed and tested, not a system in which it is used.  The purpose of the development is to create a product that will provide fault tolerance.  In this case, we deal with functional tests of fault tolerance. <br><br>  <b>Example 3.</b> <a href="http://jmeter.apache.org/">Jmeter</a> application <a href="http://jmeter.apache.org/">development</a> .  This is a popular tool for stress testing.  Its functionality is load testing.  This is a case where the subject of testing has become the object of testing.  Recursive, right?  JMeter load testing tests are functional. <br><br>  Other possible examples include the development of a crypto module (functional tests of information security), the development of an interface between systems (functional integration tests), the development of a front-office web interface as a thin client while observing the separation of business logic from data presentation (functional UI tests).  And so on. <br><br>  It is because of such cases that it is not appropriate to divide functional tests by types of functionality (only by types of requirements).  And it is not appropriate to classify the functional tests themselves as objects when categorizing ‚Äúby test object‚Äù. <br><br><h5>  3. Knowledge of the system </h5><br>  Depending on the knowledge of the system, tests are tests of a black, gray and white box.  These terms come from Management Theory, and I hope that you are familiar with them in a wider sense than the types of tests. <br><br>  It is possible to consider both a monochrome box as the entire system as a whole, and its separate part. <br><br>  The most common approach to testing is to <b>conduct functional black suitability tests</b> .  They are also called acceptance tests at the same time, but we have not yet reached acceptance tests, wait.  It is on such testing that most novice testers are trained. <br><blockquote>  It is a common misconception that conducting such tests is necessary and sufficient, and if it does not lead to an increase in the quality of the product, then testers have done a poor job. </blockquote><br><br>  My entire series of articles on the selection of tests is aimed at relieving readers of this delusion. <br><br>  In detail about the impact of knowledge of the system on testing I will write separately. <br><br><h5>  4. The degree of automation </h5><br>  About automation write everywhere and a lot.  I myself love this topic very much. <br><br>  What I don‚Äôt like is the fact that automation is most often considered in this context: ‚Äúhere we have accumulated regression functional tests, there is no one to chase them away, we must somehow have it‚Äù.  Therefore, many will look at this branch of the tree and say, "well, this later." <br><blockquote>  Automation is not only an evolutionary development of tests.  Some necessary types of tests simply can not be manual. </blockquote><br><br>  We need to think about automation when answering the question: <br><blockquote>  "How do we check this?" </blockquote><br>  Some situations are simply impossible to reproduce manually.  Sometimes we need external system simulators.  Sometimes - auxiliary tools for the preparation of test data.  Almost always - tools for load testing. <br>  Some tools you take ready, some write yourself.  We need to put resources on this, therefore <br><blockquote>  think about automation in advance. </blockquote><br><br><h5>  5. The degree of isolation of components </h5><br>  It is possible to test the ‚Äúfrom-and-to‚Äù system for safety, for compliance with standards, for convenience of operation.  It is about the scale - when you take everything entirely. <br>  You can check the individual parts at different levels of aggregation.  You can check not the components themselves, but how they interact - whether data is lost, distorted, or distorted. <br><br>  The choice of scale on which this or that test will be held depends on the purpose - what mistakes you are looking for, what requirements you want to check.  And more on the knowledge and availability of the system. <br><br>  End-to-end testing can be a black box, for example, on acceptance tests during initial commissioning.  And before the transfer - the gray box, when testers know how the system works and where it has bottlenecks.  Fill in the data at the front entrance and wait for the flow from all the slots and the expected result from the rear exit itself.  From knowledge of the system depends on the preparation of test data.  Knowing where it can break through, you can slip something into the right slot.  In this case, it may be that a potentially defective component is not accessible on its own - therefore, it is not a question of testing a component.  The whole machine is started, and defects can be detected not only where they are expected. <br><br>  If you isolate a component and only input data to it and check the result only at its output, this will be the component testing. <br><br>  Depending on how finely the system is crushed, there are discrepancies in terminology regarding the types of testing.  This will be discussed in another part. <br><br><h5>  6. Testing time </h5><br>  When determining the necessary types of tests, you must answer the question <br><blockquote>  when will we test? </blockquote><br>  My favorite army anecdote: "Dig from the fence and before sunset."  In terms of our work: <br><blockquote>  "Test from a critical defect to release." </blockquote><br>  I believe that this approach leads to the fact that it is impossible to achieve an effective test coverage. <br><br>  The question of the timing of a particular test depends largely on the methodology of the project.  According to SCRUM you will take only those tests that you can catch in an iteration.  You will have a release date fixed, and you will be able to guess when it is time to make a Smoke, when it makes sense to start a regression, and all the rest of the time you will rake the bug fix and conduct full-fledged tests of new features.  Build can be collected every day, and you can drive Smoke and / or regression tests on it.  Someone builds a build just before the release and sits at night to verify or double-check everything that can be done. <br><br>  In my understanding, the trait that separates tests by time is release.  Part of the tests is done before the release, inside the team - these are alpha tests, part - after the transfer into operation - these are beta, gamma, delta ... omega tests. <br><br>  Everyone knows the law of dependence of the cost of a defect on the time of its detection.  Therefore, a maximum of tests should be performed on the alpha stage. <br><br>  Beta tests are usually understood as ‚Äúprerelease‚Äù.  When the product seems to be ready, and it is already used, but it is still not complete.  The practice of full beta testing is common in the gamedev-industry and in open source-projects. <br><br><h5>  7. The degree of test readiness </h5><br>  You need to decide: <br><ul><li>  You either lay the time to prepare the tests, or - no. </li><li>  You either have a common standard for test plans and test reports ‚Äî or not. </li><li>  You are using or are going to use a test management system or not. </li></ul><br>  Over time, these theses for you may change. <br><br>  Be that as it may, even if you answered ‚Äúno‚Äù on all items at the beginning, this does not mean that only research testing will be carried out on your project.  You can take the TK and check whether what is written in it is done - it will be quite prepared testing.  <i>When you know what to look for.</i> <br><blockquote>  The lack of execution of tests does not mean their unpreparedness. </blockquote><br><br>  More - in another part. <br><br><h5>  8. Depth of testing </h5><br>  I read about Test-to-pass and Test-to-fail in <b>Software Testing By Ron Patton</b> .  Here is a quote: <br><blockquote>  There are two fundamental approaches to the testing software: test-to-pass and test-to-fail.  When you test-to-pass, you really only need that software minimally works.  You don't push its capabilities.  You can not break it.  Use the gloves and the most straightforward test cases. <br></blockquote><br>  Patton writes that tests that must pass successfully (Test-to-pass) should be checked first.  If they did not pass, then the rest can not be checked. <br><br>  It doesn‚Äôt surprise me that this test splitting is hardly mentioned anywhere else.  The reason - this characteristic is almost equivalent to the division of test scenarios into positive and negative.  In fact, the way it is, except for one moment: <br><blockquote>  Positive and negative are test cases.  With the ‚Äútest-to-pass‚Äù and ‚Äútest-to-fail‚Äù labels you can group test sets for smoke, acceptance and regression tests, which can contain both negative and positive scenarios. </blockquote><br><br>  <b>Tets-to-pass</b> are tests in the normal, most frequently used mode of operation. <br><br>  <b>Test-to-fail</b> are tests in uncharted territory that may be a minefield.  You will not carry out these tests after each assembly.  They are needed only to search for specific system states in which the occurrence of a previously undetected defect or even a complete system failure is possible.  Such tests can be ad hock, and negative tests - these can be cases that are checked when making a bug fix, and they must pass successfully. <br><br>  The goal of a negative test is to make sure that the system responds correctly to the wrong action.  The goal of test-to-fail is to break the system. <br><br>  Remember that the sooner the defects are found, the better.  And that by the end of the iteration, the system should be tested as much as possible, and the basic scenarios should certainly be successful.  Thus, we get the alternation of tests in depth. <br><br>  The first portion of tests should allow detecting a number of show-stopper defects.  When the first portion of the Test-To-Pass is successful, go to the second ‚Äî Test-To-Fail, which should reveal the largest possible number of defects of all degrees of criticality.  And after the last portion of tests, defects should not occur at all - they should be Test-To-Pass again. <br><br><h5>  9. Scripts </h5><br>  About the relevance of the cast in the scheme of the types of scenarios already written above. <br>  Thinking scenarios is not a strategic task.  When planning a testing strategy, one thing is certain <br><blockquote>  scripts need all possible. </blockquote><br>  Otherwise you will miss the defects. <br><br><h5>  10. Dynamism </h5><br>  If during testing there are manipulations with the application - it is dynamic.  If the state of the system does not change - this is static testing. <br>  Static testing is often overlooked.  How can I test without changing anything? <br>  The answer is in the diagram.  Code review and documentation testing help identify a significant proportion of errors without wasting time on setting the system in motion. <br><br>  On this viewing in width is over.  Preview in depth leave the next time. <br><br><h4>  Drawing up a matrix of tests </h4><br><br>  So, each set of tests can be described by listing 9 characteristics: <br><ul><li>  Type of Requirements </li><li>  Test object </li><li>  Knowledge of the system </li><li>  Degree of automation </li><li>  The degree of test readiness </li><li>  Testing depth </li><li>  Testing time </li><li>  The degree of isolation of components </li><li>  Dynamic </li></ul><br><br>  Speaking of a specific project, it will be possible to split all the test objects into functional and non-functional groups, that is, by type of requirements.  <i>- 1 measurement.</i> <br><br>  You will take on one or another set of tests depending on the development stage, so you can group the tests by time.  They can be marked as tests that must pass successfully, and as tests by which defects should be detected.  <i>- 2 measurements</i> <br><br>  Conducting static tests can be laid as a standard practice at the organizational level.  Code review after each commit with the closure of the ticket, and test the specification when new requirements are received or at the design test stage.  <i>- 1 measurement.</i> <br><br>  Ad hock / research testing should be carried out during outages or in the first days of the project‚Äôs life / new functionality.  All other tests considered prepared. <br><br>  There are 4 characteristics of the tests: <br><ul><li>  Type of requirements * Test object = Functional component of the system </li><li>  Knowledge of the system </li><li>  Degree of automation </li><li>  The degree of isolation of components </li></ul><br><br>  Now it is possible to create a matrix of possible combinations of types of testing. <br><br><img src="https://habrastorage.org/files/692/c82/215/692c8221560c48118535873bb3875b71.PNG"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c0/d37/7ff/9c0d377ff5fc9754f0404252d07eb789.jpg" alt="image"><br><br>  I here considered that even according to the 4 characteristics of the types of tests it turns out so much that it makes no sense to generate them. <br><br>  Matrix, matrix ... I consider this very Mind Map with the types of tests to be the matrix of tests.  Looking at it you just have to keep in mind the fact that every single test at the same time is a kind of test of all the listed top-level categories. <br><br><h4>  Conclusion </h4><br><br>  So many tests are huge.  Having an understanding of the purpose of testing and a systematic idea of ‚Äã‚Äãthe types of tests it is already possible to answer the question - what types of tests do you need. <br><br>  Finally, here's a checklist ‚Äî questions that need to be answered by determining the right kinds of tests: <br><ol><li>  What functional and non-functional requirements are imposed on the system? </li><li>  What will the system consist of? </li><li>  How well do testers know the structure of the system? </li><li>  How and what to reproduce test situations? </li><li>  In which areas and on what scale will the system be tested? </li><li>  At what stage of development will tests be conducted? </li><li>  How will you describe and store the tests? </li><li>  Do your testers know how to write test scripts? </li><li>  Will the developers check themselves and each other? </li><li>  Is the specification perfect? </li></ol><br>  (These questions were raised when reviewing test types wide.) <br><br>  I hope I have not confused readers even more, and my matrix will be useful to you. </div><p>Source: <a href="https://habr.com/ru/post/257159/">https://habr.com/ru/post/257159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257147/index.html">IPv6 is not needed?</a></li>
<li><a href="../257149/index.html">Factory sites (F.CMS) lost the court</a></li>
<li><a href="../257151/index.html">Several useful ruby ‚Äã‚Äãtricks that (possibly) will improve your code.</a></li>
<li><a href="../257153/index.html">A simple example of using ES6 today</a></li>
<li><a href="../257155/index.html">Our report on the strike: "How to get rid of persistent database dependencies"</a></li>
<li><a href="../257161/index.html">Goals, objectives and principles of automation</a></li>
<li><a href="../257163/index.html">Error in AFNetworking code allows you to intercept user HTTPS traffic</a></li>
<li><a href="../257165/index.html">Own browser - the way of the mouse: meeting with the Rat</a></li>
<li><a href="../257167/index.html">Mono 4.0 release with import code from referencesource.microsoft.com and corefx</a></li>
<li><a href="../257171/index.html">Application Development for Apple Watch (iPhone and iPad) using Wolfram Language (Mathematica)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>