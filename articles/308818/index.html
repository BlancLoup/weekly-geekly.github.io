<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When "O" brings a big</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The "O" is a great tool. It allows you to quickly select the appropriate data structure or algorithm. But sometimes a simple analysis of ‚ÄúO‚Äù big can f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When "O" brings a big</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/4a0/c6d/412/4a0c6d41220e4f0dab29886f2407df5b.png"></p><br><p>  The "O" is a great tool.  It allows you to quickly select the appropriate data structure or algorithm.  But sometimes a simple analysis of ‚ÄúO‚Äù big can fool us, if you don‚Äôt think carefully about the influence of constant factors.  An example that is often encountered when programming on modern processors is associated with the choice of data structure: an array, a list, or a tree. </p><br><h3>  Memory, slow-slow memory </h3><br><p>  In the early 1980s, the time required to obtain data from RAM and the time required to perform calculations with this data were approximately the same.  It was possible to use an algorithm that randomly moved through the dynamic memory, collecting and processing data.  Since then, processors began to perform calculations many times faster, from 100 to 1000 times, than to receive data from RAM.  This means that while the processor is waiting for data from memory, it is idle for hundreds of cycles, doing nothing.  Of course, it would be completely stupid, so modern processors contain several levels of embedded cache.  Each time you request a single piece of data from memory, additional adjacent pieces of memory will be written to the processor cache.  As a result, with a sequential pass through memory, you can access it almost as quickly as the processor can process information, because chunks of memory will be constantly recorded in the L1 cache.  If you move to random memory addresses, then often the cache will not work, and performance can suffer greatly.  If you want to know more, <a href="https://www.youtube.com/watch%3Fv%3DrX0ItVEVjHc">Mike Acton‚Äôs CppCon report</a> is a great starting point (and a great time). <a name="habracut"></a></p><br><p>  As a result, arrays have become a better data structure when performance is important, even if, according to analysis ‚ÄúO‚Äù, a large array should work slower.  Where you wanted to use a tree, a sorted binary search array might be better.  Where you would like to use a queue, a growing array may come up better, and so on. </p><br><h3>  Linked list and dynamic array </h3><br><p>  When you understand the importance of accessing sequential memory, it will not be a surprise to you that if you need to quickly go through the collection, the array will be faster than a coherent list.  Environments with smart memory management and garbage collectors will probably keep the linked list nodes more consistent, but they cannot guarantee this.  Using a raw array usually requires more complex code, especially when you need to insert or add new elements, as you have to handle the growth of the array, the movement of elements, and so on.  Most languages ‚Äã‚Äãhave native libraries containing one or another implementation of dynamic arrays.  In C ++, there is a <a href="http://www.cplusplus.com/reference/vector/vector/">vector</a> , in C # there is a <a href="https://msdn.microsoft.com/en-us/library/6sh2ey19(v%3Dvs.110).aspx">List (in F # it is used under the name ResizeArray)</a> , and in Java there is an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> .  Usually these structures provide the same or similar interface as the linked list.  <strong>In this article I will call such structures dynamic arrays (Array List), but keep in mind that the examples in C # use the List class, and not the older ArrayList.</strong> </p><br><p>  What if you need a data structure in which you can quickly insert elements and quickly pass through them?  Let's imagine, for this example, that we have such a case: we will insert at the beginning of the collection about 5 times more often than go through it.  Let's also imagine that both the coherent list and the dynamic array in our environment have equally pleasant interfaces.  It remains only to decide what will be a more effective solution.  We can refer to the analysis of "O" big to optimize our valuable time.  Let us refer to the <a href="http://bigocheatsheet.com/">useful hint about the ‚ÄúO‚Äù large</a> , the corresponding difficulties for these data structures are: </p><br><table><thead><tr><th></th><th>  Pass </th><th>  Insert </th></tr></thead><tbody><tr><td>  Dynamic array </td><td>  O (n) </td><td>  O (n) </td></tr><tr><td>  Linked list </td><td>  O (n) </td><td>  O (1) </td></tr></tbody></table><br><p>  The problem of dynamic arrays is to insert, at a minimum, each element must be copied and moved one point past the insertion point to make room for the new element.  Hence, O (n).  Sometimes you need to create a new array, larger in size so that there is a place to insert.  In our case, insertion occurs 5 times more often than a pass, so it seems that the conclusion is obvious.  As long as n is large enough, a coherent list should generally be more efficient. </p><br><h3>  Experiment </h3><br><p>  But to make sure, it is better to count.  Let's experiment with C # using <a href="https://github.com/PerfDotNet/BenchmarkDotNet">BenchMarkDotNet</a> .  In C #, there is a LinkedList collection, which is a classic linked list, and a List, which is a dynamic array.  The interfaces of both are similar, and both can be easily applied in our case.  Consider the worst case for a dynamic array ‚Äî the insert always occurs at the beginning, so you have to copy the entire array with each insert.  The configuration of the test environment is as follows: </p><br><pre><code class="hljs sql">Host Process Environment Information: BenchmarkDotNet.Core=v0.9.9.0 OS=Microsoft Windows NT 6.2.9200.0 Processor=Intel(R) Core(TM) i7-4712HQ CPU 2.30GHz, ProcessorCount=8 Frequency=2240910 ticks, Resolution=446.2473 ns, Timer=TSC CLR=MS.NET 4.0.30319.42000, Arch=64-bit <span class="hljs-keyword"><span class="hljs-keyword">RELEASE</span></span> [RyuJIT] GC=<span class="hljs-keyword"><span class="hljs-keyword">Concurrent</span></span> Workstation JitModules=clrjit-v4<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.1590</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>=Bench <span class="hljs-keyword"><span class="hljs-keyword">Mode</span></span>=Throughput</code> </pre> <br><h3>  Test Cases: </h3><br><pre> <code class="hljs pgsql"> [Benchmark(Baseline=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> ArrayTest() { //<span class="hljs-keyword"><span class="hljs-keyword">In</span></span> C#, List&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> backed list. List&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = arrayList; <span class="hljs-type"><span class="hljs-type">int</span></span> localInserts = inserts; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; localInserts; i++) { <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); //<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> the number <span class="hljs-number"><span class="hljs-number">1</span></span> at the front } // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> loops iterate <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> List&lt;T&gt; much faster than <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Count; i++) { sum += <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>[i]; //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> here so the JIT doesn<span class="hljs-string"><span class="hljs-string">'t elide the loop entirely } return sum; } [Benchmark] public int ListTest() { LinkedList&lt;int&gt; local = linkedList; int localInserts = inserts; int sum = 0; for (int i = 0; i &lt; localInserts; i++) { local.AddFirst(1); //Insert the number 1 at the front } // Again, iterating the fastest possible way over this collection var node = local.First; for (int i = 0; i &lt; local.Count; i++) { sum += node.Value; node = node.Next; } return sum; }</span></span></code> </pre><br><h3>  Results: </h3><br><table><thead><tr><th>  Method </th><th>  The size </th><th>  Inserts </th><th>  Median </th></tr></thead><tbody><tr><td>  ArrayTest </td><td>  100 </td><td>  five </td><td>  38.9983 us </td></tr><tr><td>  Listtest </td><td>  100 </td><td>  five </td><td>  51.7538 us </td></tr></tbody></table><br><p>  The dynamic array wins with a good margin.  But this is a small list, ‚ÄúO‚Äù large describes the performance of only growing to large sizes <code>n</code> , so the test results should eventually turn upside down with increasing <code>n</code> .  Let's try: </p><br><table><thead><tr><th>  Method </th><th>  The size </th><th>  Inserts </th><th>  Median </th></tr></thead><tbody><tr><td>  ArrayTest </td><td>  100 </td><td>  five </td><td>  38.9983 us </td></tr><tr><td>  Listtest </td><td>  100 </td><td>  five </td><td>  51.7538 us </td></tr><tr><td>  ArrayTest </td><td>  1000 </td><td>  five </td><td>  42.1585 us </td></tr><tr><td>  Listtest </td><td>  1000 </td><td>  five </td><td>  49.5561 us </td></tr><tr><td>  ArrayTest </td><td>  100,000 </td><td>  five </td><td>  208.9662 us </td></tr><tr><td>  Listtest </td><td>  100,000 </td><td>  five </td><td>  312.2153 us </td></tr><tr><td>  ArrayTest </td><td>  1,000,000 </td><td>  five </td><td>  2,179.2469 us </td></tr><tr><td>  Listtest </td><td>  1,000,000 </td><td>  five </td><td>  4,913.3430 us </td></tr><tr><td>  ArrayTest </td><td>  10,000,000 </td><td>  five </td><td>  36,103.8456 us </td></tr><tr><td>  Listtest </td><td>  10,000,000 </td><td>  five </td><td>  49,395.0839 us </td></tr></tbody></table><br><p><img src="https://habrastorage.org/files/da4/62f/ed5/da462fed5ee74fd69adcdd84a2e5fc5c.png"></p><br><p>  Unexpected results for many.  No matter how large <code>n</code> , the dynamic array is still better.  To make the performance worse, the <em>ratio of</em> inserts to aisles must change, not just the size of the collection.  Note that this is not an error of the ‚ÄúO‚Äù analysis of a big one, it is just a human error - we incorrectly apply the method.  If you go deep into mathematics, then ‚ÄúO‚Äù will show a lot that both data structures will grow at the same speed as long as the ratio of inserts to the passes does not change. </p><br><p>  Where the tipping point lies depends on many factors, but a good approximate rule is suggested by <a href="https://www.youtube.com/watch%3Fv%3DfHNmRkzxHWs">Chandler Carruth</a> from Google: a dynamic array will be more efficient than a coherent list until the inserts are an order of magnitude larger than the passes.  In our case, the rule works well, because with a 10: 1 ratio, you can see a shift towards the linked list: </p><br><table><thead><tr><th>  Method </th><th>  The size </th><th>  Inserts </th><th>  Median </th></tr></thead><tbody><tr><td>  ArrayTest </td><td>  100,000 </td><td>  ten </td><td>  328,147.7954 ns </td></tr><tr><td>  Listtest </td><td>  100,000 </td><td>  ten </td><td>  324,349.0560 ns </td></tr></tbody></table><br><h3>  The devil is in the details </h3><br><p>  The dynamic array wins because the numbers that pass through are in memory sequentially.  Each time a number is requested from memory, a whole set of numbers is added to the L1 cache, so the next 64 bytes of data are ready for processing.  When working with a linked list, each <code>node.Next</code> call redirects a pointer to the next node, and there is no guarantee that this node will be in memory immediately after the previous one.  Therefore, sometimes we will get past the cache.  But we do not always have to work with types that store values ‚Äã‚Äãdirectly, especially in object-oriented languages, where the passage often takes place on reference types.  In this case, despite the fact that in the dynamic array the pointers themselves are in memory sequentially, the objects to which they point are not.  The situation is still better than with a coherent list, where you have to dereference the pointers for each item twice, but how does this affect the overall performance? </p><br><p>  Performance deteriorates significantly, depending on the size of objects and the features of hardware and software.  If in the example above, the numbers are replaced with small objects (12 bytes), then the ‚Äúbreak point‚Äù drops to 4 inserts in one pass: </p><br><table><thead><tr><th>  Method </th><th>  The size </th><th>  Inserts </th><th>  Median </th></tr></thead><tbody><tr><td>  ArrayTestObject </td><td>  100,000 </td><td>  0 </td><td>  674.1864 us </td></tr><tr><td>  ListTestObject </td><td>  100,000 </td><td>  0 </td><td>  1,140.9044 us </td></tr><tr><td>  ArrayTestObject </td><td>  100,000 </td><td>  2 </td><td>  959.0482 us </td></tr><tr><td>  ListTestObject </td><td>  100,000 </td><td>  2 </td><td>  1,121.5423 us </td></tr><tr><td>  ArrayTestObject </td><td>  100,000 </td><td>  four </td><td>  1,230.6550 us </td></tr><tr><td>  ListTestObject </td><td>  100,000 </td><td>  four </td><td>  1,142.6658 us </td></tr></tbody></table><br><p>  Managed C # code suffers greatly in this case, because going through a dynamic array creates unnecessary checks on the array boundaries.  A vector in C ++ is likely to work more efficiently.  If we are quite aggressive in solving this problem, then we can write a faster class for the dynamic array using the unsafe C # code to avoid checking the bounds of the array.  The relative difference will also depend heavily on how the memory allocator and the garbage collector manage dynamic memory, how large objects are and other factors.  Larger objects usually improve the performance of dynamic arrays in my environment.  When it comes to whole applications, the relative performance of dynamic arrays can also improve with increased fragmentation of dynamic memory, but to be sure, testing is needed. </p><br><p>  One more thing.  If objects are quite small (from 16 to 32 bytes or less in different situations), then it is worth considering the option of storing them by value ( <code>struct</code> in .NET), and not in the object.  This will not only greatly improve performance due to consistent memory allocation, but also theoretically reduce the additional workload due to garbage collection, depending on the usage scenario for this data: </p><br><table><thead><tr><th>  Method </th><th>  The size </th><th>  Inserts </th><th>  Median </th></tr></thead><tbody><tr><td>  ArrayTestObject </td><td>  100,000 </td><td>  ten </td><td>  2,094.8273 us </td></tr><tr><td>  ListTestObject </td><td>  100,000 </td><td>  ten </td><td>  1,154.3014 us </td></tr><tr><td>  ArrayTestStruct </td><td>  100,000 </td><td>  ten </td><td>  792.0004 us </td></tr><tr><td>  ListTestStruct </td><td>  100,000 </td><td>  ten </td><td>  1,206.0713 us </td></tr></tbody></table><br><p>  Java can show better results here because it automatically makes smart changes to small objects, or you can simply use separate arrays of primitive types.  And although this is very tedious to write, <a href="https://software.intel.com/en-us/articles/memory-layout-transformations">it can be faster</a> than an array of structures.  It all depends on the specifics of accessing the data in your code.  Keep this in mind when performance is especially important. </p><br><h3>  Make sure the abstraction justifies itself. </h3><br><p>  Often people do not agree with such conclusions, and their arguments are the purity of the code, correctness and maintainability.  Of course, each sphere has its own priorities, but I believe that when abstraction only slightly improves cleanliness when, and performance suffers greatly, you need to make it a rule to choose performance.  If you do not regret the time to study the environment, then you can learn about cases where there is a faster and no less clear solution, as is often the case with dynamic arrays instead of lists. </p><br><p>  Things to think about: here are seven different ways to find the sum of a list of numbers in C #, with execution time and memory usage.  Everywhere overflow checking arithmetic is used, so that the comparison with Linq, where the Sum method uses just such arithmetic, is correct.  Notice <em>how much</em> better the method is faster than others  Notice how costly the most popular way.  Note that the <code>foreach</code> abstraction works well with arrays, but not with dynamic arrays or linked lists.  Whatever your language and environment, it is important to understand these details in order to make the right decisions by default. </p><br><table><thead><tr><th>  Method </th><th>  Length </th><th>  Median </th><th>  Bytes Allocated / Op </th></tr></thead><tbody><tr><td>  LinkedListLinq </td><td>  100,000 </td><td>  990.7718 us </td><td>  23,192.49 </td></tr><tr><td>  RawArrayLinq </td><td>  100,000 </td><td>  643.8204 us </td><td>  11,856.39 </td></tr><tr><td>  LinkedListForEach </td><td>  100,000 </td><td>  489.7294 us </td><td>  11,909.99 </td></tr><tr><td>  LinkedListFor </td><td>  100,000 </td><td>  299.9746 us </td><td>  6,033.70 </td></tr><tr><td>  ArrayListForEach </td><td>  100,000 </td><td>  270.3873 us </td><td>  6,035.88 </td></tr><tr><td>  ArrayListFor </td><td>  100,000 </td><td>  97.0850 us </td><td>  1,574.32 </td></tr><tr><td>  RawArrayForEach </td><td>  100,000 </td><td>  53.0535 us </td><td>  1,574.84 </td></tr><tr><td>  RawArrayFor </td><td>  100,000 </td><td>  53.1745 us </td><td>  1,577.77 </td></tr></tbody></table><br><pre> <code class="hljs pgsql"> [Benchmark(Baseline = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> LinkedListLinq() { var <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = linkedList; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Sum(); } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> LinkedListForEach() { var <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = linkedList; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; checked { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>) { sum += node; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> LinkedListFor() { var <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = linkedList; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; var node = <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.First; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Count; i++) { checked { sum += node.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; node = node.Next; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> ArrayListFor() { //<span class="hljs-keyword"><span class="hljs-keyword">In</span></span> C#, List&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> backed list List&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = arrayList; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Count; i++) { checked { sum += <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>[i]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> ArrayListForEach() { //<span class="hljs-keyword"><span class="hljs-keyword">In</span></span> C#, List&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> backed list List&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = arrayList; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; checked { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>) { sum += x; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> RawArrayLinq() { <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = rawArray; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Sum(); } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> RawArrayForEach() { <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = rawArray; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; checked { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>) { sum += x; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } [Benchmark] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> RawArrayFor() { <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = rawArray; <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>.Length; i++) { checked { sum += <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>[i]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308818/">https://habr.com/ru/post/308818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308802/index.html">Empty shelves, a bottle of gasoline and the girl factor: we open a store</a></li>
<li><a href="../308804/index.html">FConsole - debugging tool for PIxi.js (Canvas / WebGL) applications</a></li>
<li><a href="../308812/index.html">Mesos. Container Cluster Management System</a></li>
<li><a href="../308814/index.html">Thorny road to sales on Themeforest.net - Part 2</a></li>
<li><a href="../308816/index.html">Virtual User Session vs. VDI: Perspectives and Potential</a></li>
<li><a href="../308820/index.html">What's new in IntellIJ IDEA 2016.3 EAP</a></li>
<li><a href="../308822/index.html">What is the source of strength and leadership qualities Cheryl Sandberg</a></li>
<li><a href="../308824/index.html">The Certification Authority from China mistakenly issued an SSL certificate to the user for the GitHub domain.</a></li>
<li><a href="../308826/index.html">Lectures of the Technosphere. Perl Programming (Fall 2015)</a></li>
<li><a href="../308828/index.html">Bitcoin - money for everyone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>