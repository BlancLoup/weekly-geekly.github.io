<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stream data from a REST service to an MQ queue</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 In this article, I will describe a way to develop a REST service that allows you to receive files and save them to the messaging system i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stream data from a REST service to an MQ queue</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  In this article, I will describe a way to develop a REST service that allows you to receive files and save them to the messaging system in streaming mode without having to store the entire file on the service side.  A reverse scenario will also be described, in which the client will receive a file hosted in the messaging system as a response. <br><br>  For clarity, I will provide code samples of the developed service on JEE7 for the IBM WebSphere Liberty Server application server, and the IBM MQ will act as a messaging system. <br>  Nevertheless, the described method is also suitable for other similar platforms, i.e.  Any JMS API provider can act as a messaging system, and any JEE server (for example, Apache Tomcat) can act as an application server. <br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br>  There was a need to implement a solution that would allow both receiving large files from the client (&gt; 100 Mb) and transfer them to another geographically remote system, and in the opposite direction ‚Äî transfer files from this system to the client as an answer.  In view of the unreliable network channel between the client‚Äôs network and the application‚Äôs network, a messaging system is used to ensure guaranteed delivery between them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The high-level solution includes three components: <br><br><ol><li>  REST service - the task of which is to provide the client with the ability to transfer a file (or request). </li><li>  MQ - is responsible for sending messages between different networks. </li><li>  Application - the application responsible for storing files and issuing them on request. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/9j/vt/k49jvtxkuphxkedfhlvmwswde0a.jpeg" alt="image"></div><br>  In this article I describe how to implement a REST service, the tasks of which include: <br><br><ul><li>  Receiving a file from a client. </li><li>  Transfer the resulting file to MQ. </li><li>  File transfer from MQ to client as an answer. </li></ul><br><h2>  Solution Method </h2><br>  In view of the large size of the file being transferred, there is no possibility of placing it completely in RAM, moreover, there is a limitation imposed by MQ - the maximum size of a single message in MQ cannot exceed 100 Mb.  Thus, my decision will be based on the following principles: <br><br><ul><li>  Retrieving a file and storing it in the MQ queue should be performed in streaming mode, without storing the entire file in memory. </li><li>  The MQ file will be placed in the queue as a set of small messages. </li></ul><br>  Graphically, the location of the file on the client, REST service and MQ is shown below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/s7/fk/bas7fkcqokygdffbfaa0aebm0gi.jpeg" alt="image"></div><br>  On the client side, the file is completely located on the file system, only the file portion is stored in the REST service, and on the MQ side, each file portion is placed as a separate message. <br><br><h2>  REST service development </h2><br>  For clarity, the proposed solution method will be developed demo REST service, containing two methods: <br><br><ul><li>  upload - receives a file from the client and writes it to the MQ queue, returns the message group identifier (in base64 format) as a response. </li><li>  download - receives the message group identifier from the client (in base64 format) and returns the file stored in the MQ queue. </li></ul><br><h3>  Method of receiving a file from the client (upload) </h3><br>  The task of the method is to receive the stream of the incoming file and then write it to the MQ queue. <br><br><h4>  Receive stream incoming file </h4><br>  To receive an incoming file from the client, the method expects as an input parameter an object with the interface com.ibm.websphere.jaxrs20.multipart.IMultipartBody, which provides the ability to get a link to the input file stream <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PUT</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"upload"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMultipartBody body)</span></span></span><span class="hljs-function"> </span></span>{ ... IAttachment attachment = body.getAttachment(<span class="hljs-string"><span class="hljs-string">"file"</span></span>); InputStream inputStream = attachment.getDataHandler().getInputStream(); ... }</code> </pre> <br>  This interface (IMultipartBody) is located in the JAR archive com.ibm.websphere.appserver.api.jaxrs20_1.0.21.jar, shipped with the IBM Liberty Server and is located in the folder: &lt; <i>WLP_INSTALLATION_PATH</i> &gt; / dev / api / ibm. <br><br>  Note: <br><br><ul><li>  <i>WLP_INSTALLATION_PATH</i> is the path to the WebSphere Liberty Profile directory. </li><li>  It is expected that the client will transfer the file in a parameter named "file". </li><li>  If you use another application server, you can use the alternative library from Apache CXF. </li></ul><br><h4>  Stream file saving in MQ </h4><br>  The method receives as input the stream of the incoming file, the name of the MQ queue where the file should be written, and the identifier of the group of messages that will be used to link the messages.  The group identifier is generated on the service side, for example, by the org.apache.commons.lang3.RandomStringUtils utility: <br><br><pre> <code class="java hljs">String groupId = RandomStringUtils.randomAscii(<span class="hljs-number"><span class="hljs-number">24</span></span>);</code> </pre> <br>  The algorithm for saving an incoming file in MQ consists of the following steps: <br><br><ol><li>  Initializing MQ Connection Objects. </li><li>  Cyclic reading of a portion of the incoming file until the file is completely read: <ol><li>  A portion of the file data is recorded as a separate message in the MQ. </li><li>  Each message file has its own sequence number (property "JMSXGroupSeq"). </li><li>  All file messages have the same group value (the ‚ÄúJMSXGroupID‚Äù property). </li><li>  The last message has a sign indicating that this message is final (property ‚ÄúJMS_IBM_Last_Msg_In_Group‚Äù). </li><li>  The constant SEGMENT_SIZE contains the portion size.  For example, 1Mb. </li></ol></li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream inputStream, String queueName, String groupId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, JMSException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ( Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(); MessageProducer producer = session.createProducer(session.createQueue(queueName)); ) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[SEGMENT_SIZE]; BytesMessage message = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> readBytesSize = <span class="hljs-number"><span class="hljs-number">1</span></span>, sequenceNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; readBytesSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; sequenceNumber++) { readBytesSize = inputStream.read(buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { message.setBooleanProperty(<span class="hljs-string"><span class="hljs-string">"JMS_IBM_Last_Msg_In_Group"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } producer.send(message); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { message = session.createBytesMessage(); message.setStringProperty(<span class="hljs-string"><span class="hljs-string">"JMSXGroupID"</span></span>, groupId); message.setIntProperty(<span class="hljs-string"><span class="hljs-string">"JMSXGroupSeq"</span></span>, sequenceNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readBytesSize == SEGMENT_SIZE) { message.writeBytes(buffer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.writeBytes(Arrays.copyOf(buffer, readBytesSize)); } } } } }</code> </pre><br><h3>  Method of sending file to client (download) </h3><br>  The method receives the group identifier of messages in base64 format, by which it reads messages from the MQ queue and sends it as a streaming response. <br><br><h4>  Retrieving message group id </h4><br>  As an input parameter, the method gets the ID of the message group. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PUT</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"download"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">download</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@QueryParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"groupId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String groupId) </span></span>{ ... }</code> </pre> <br><h4>  Stream client response </h4><br>  To transfer a file stored as a set of individual messages to MQ in streaming mode, create a class with the javax.ws.rs.core.StreamingOutput interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQStreamingOutput</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamingOutput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String groupId; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String queueName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MQStreamingOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String groupId, String queueName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.groupId = groupId; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queueName = queueName; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutputStream outputStream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, WebApplicationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MQWorker().read(outputStream, queueName, groupId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(NamingException | JMSException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(e); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { outputStream.flush(); outputStream.close(); } } }</code> </pre><br>  In the class, we implement the write method, which receives as input a link to the outgoing stream to which messages from MQ will be written.  I added to the class another queue name and group identifier whose messages will be read. <br><br>  An object of this class will be passed as a parameter to create a response to the client: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path</span></span>(<span class="hljs-string"><span class="hljs-string">"download"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">download</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@QueryParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"groupId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String groupId) </span></span>{ ResponseBuilder responseBuilder = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { MQStreamingOutput streamingOutput = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MQStreamingOutput(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(Utils.decodeBase64(groupId)), Utils.QUEUE_NAME); responseBuilder = Response.ok(streamingOutput); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { e.printStackTrace(); responseBuilder.status(Status.INTERNAL_SERVER_ERROR).entity(e.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> responseBuilder.build(); }</code> </pre> <br><h4>  Stream file read from MQ </h4><br>  The algorithm for reading messages from MQ to the outgoing stream consists of the following steps: <br><br><ol><li>  Initializing MQ Connection Objects. </li><li>  Cyclic reading of messages from MQ until the message with the terminator sign in the group is read (property ‚ÄúJMS_IBM_Last_Msg_In_Group‚Äù): <br><ol><li>  Before each reading of a message from the queue, a filter (messageSelector) is set, which specifies the identifier of the message group and the sequence number of the message in the group. </li><li>  The content of the read message is written to the outgoing stream. </li></ol><br></li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutputStream outputStream, String queueName, String groupId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, JMSException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>( Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(); ) { connection.start(); Queue queue = session.createQueue(queueName); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sequenceNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; isMessageExist == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; ) { String messageSelector = <span class="hljs-string"><span class="hljs-string">"JMSXGroupID='"</span></span> + groupId.replaceAll(<span class="hljs-string"><span class="hljs-string">"'"</span></span>, <span class="hljs-string"><span class="hljs-string">"''"</span></span>) + <span class="hljs-string"><span class="hljs-string">"' AND JMSXGroupSeq="</span></span> + sequenceNumber++; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>( MessageConsumer consumer = session.createConsumer(queue, messageSelector); ) { BytesMessage message = (BytesMessage) consumer.receiveNoWait(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) message.getBodyLength()]; message.readBytes(buffer); outputStream.write(buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.getBooleanProperty(<span class="hljs-string"><span class="hljs-string">"JMS_IBM_Last_Msg_In_Group"</span></span>)) { isMessageExist = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } } } }</code> </pre> <br><h2>  Call REST service </h2><br>  To check the service, I will use the curl tool. <br><br><h3>  Sending file </h3><br><pre> <code class="bash hljs">curl -X PUT -F file=@&lt;__&gt; http://localhost:9080/Demo/rest/service/upload</code> </pre> <br>  In response, a base64 string will be received containing the message group identifier, which we will indicate in the following method to get the file. <br><br><h3>  Receiving a file </h3><br><pre> <code class="bash hljs">curl -X GET http://localhost:9080/Demo/rest/service/download?groupId=&lt;base64____&gt; -o &lt;_____&gt;</code> </pre> <br><h2>  Conclusion </h2><br>  The article considered the approach to developing a REST service, which allows streaming both to receive and store large data in the messaging system queue, and to read them from the queue for return as a response.  This method allows to reduce the use of resources, and thereby increase the throughput of the solution. <br><br><h2>  Additional materials </h2><br>  Learn more about the IMultipartBody interface used to receive the incoming file stream - <a href="https://www.ibm.com/support/knowledgecenter/en/was_beta_liberty/com.ibm.websphere.javadoc.liberty.doc/com.ibm.websphere.appserver.api.jaxrs20_1.0-javadoc/com/ibm/websphere/jaxrs20/multipart/IMultipartBody.html">link</a> . <br><br>  An alternative library for streaming files in REST services is <a href="http://cxf.apache.org/docs/jax-rs-multiparts.html">Apache CXF</a> . <br><br>  Interface StreamingOutput for streaming return REST response to the client - <a href="https://docs.oracle.com/javaee/7/api/javax/ws/rs/core/StreamingOutput.html">link</a> . </div><p>Source: <a href="https://habr.com/ru/post/424941/">https://habr.com/ru/post/424941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424929/index.html">Asian miracle Shimano: the story of the legendary manufacturer of cycling equipment</a></li>
<li><a href="../424933/index.html">How we reworked bad prediction for a little more good (continued)</a></li>
<li><a href="../424935/index.html">Product Design Digest, September 2018</a></li>
<li><a href="../424937/index.html">Digital events in Moscow from October 1 to 7</a></li>
<li><a href="../424939/index.html">Polymorphic Quine</a></li>
<li><a href="../424945/index.html">Smartphone drives a toy car</a></li>
<li><a href="../424947/index.html">Gesture Recognition with APDS-9960</a></li>
<li><a href="../424949/index.html">PHP Digest 140 (September 17 - 30, 2018)</a></li>
<li><a href="../424951/index.html">Hooray! It was not paranoia</a></li>
<li><a href="../424955/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ332 (September 24 - 30, 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>