<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perl Golf from REG.RU on YAPC :: Europe 2013</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A regular conference of perl-developers YAPC :: Europe 2013 took place from August 12 to 14 in Kiev. Consciousness-expanding reports, insider informat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perl Golf from REG.RU on YAPC :: Europe 2013</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/34d/80b/07e/34d80b07e6ba9cfd71040493e444faa8.png"><br><br>  A regular conference of perl-developers YAPC :: Europe 2013 took place from August 12 to 14 in Kiev. Consciousness-expanding reports, insider information from the developers of Perl 5 and Perl 6, living legends from the world of Perl (including Larry Wall himself!) river cruise and wonderful communication in the <s>pubs</s> lobby - everything was.  The event deserves the highest praise, and the organizers and speakers (and all the other participants in the conference) - all praise and thanks. <br><br>  However, it is well known that, apart from ordinary human joys, perl-programmers are inclined to entertain special, normal ‚Äúhomo sapiens‚Äù that are not always comprehensible and close. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, how we arranged Perl Golf on YAPC, and what came of it. <br><a name="habracut"></a><br>  REG.RU supported the conference as a sponsor.  Our guys at the booth and in the halls did not stint handing out wonderful T-shirts, useful information about the company, smiles and a positive atmosphere, and also held a competition for "the strongest Perl programmer" (a report with all the details and photos <a href="https://www.reg.ru/announce/yapc2013">on REG.RU</a> ). <br><br><img src="https://habrastorage.org/storage3/89f/003/cc8/89f003cc88187d965576991983f4f180.jpg" alt="REG.RU at YAPC :: Europe 2013"><br><br>  But, of course, we could not stop there.  "Perl-event - perl-activity, and nothing else!" - We said to ourselves, and then began to think, what does this actually mean? <br><br><h4>  What is Perl Golf? </h4><br>  In general, Perl Golf is a programming competition (of course, in Perl, although there are attempts to "golf" in other languages), in which the shortest program wins, which correctly solves the problem.  It is not allowed to use any additional modules and external tools.  Entertainment is one of the favorite among perl programmers, along with JAPH, obfuscation, code poetry, and other exciting, though, perhaps, not always practical, activities.  In addition, Perl Golf has absolutely clear evaluation criteria (the minimum number of characters in the program), so it is ideal as a competitive format. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/47e/9b4/178/47e9b417898910652512bc85c8fab8d0.png"></div><br>  Experienced golfers in the team was not there, so I had to learn the craft almost from scratch.  And, I must say, despite the outward exoticism (and even some terrifyingness from the point of view of any programmer who understands how a normal code should look like), Golf turned out to be an interesting and useful occupation, which helps both to learn and understand the profound and non-obvious features and possibilities of the language, and practice the ability to clearly and concisely formulate the problem and its solutions.  As a result of much thought and creative torment, the following story was born. <br><br><h4>  Legend </h4><br>  You are the son of a noble Japanese grandee of the Edo period.  You always dreamed of becoming a programmer, but the family traditions turned out to be stronger - you were sent to the training of Master Guo.  After a small theoretical introduction, the master began to ask you tasks to capture stones. <br><br>  The tasks are simple, however, it is obvious that you do not have any abilities for Go.  In addition, for each incorrectly solved puzzle, the master hurts you with a bamboo pole, and also makes you have dinner using only one stick.  Tired of beatings and chronic malnutrition, you decide to write a program that will solve the problem for you.  And since the paper in the Edo period is expensive, the program should be as short as possible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/a8f/1d6/a85a8f1d627f1417cdf7434b65f27367.png"></div><br><br><h4>  Fundamentals of the Go Game </h4><br>  Go is the oldest board strategy game that appeared in China several thousand years ago and survived its heyday in Japan.  The game involves two players, in turn placing the black and white stones at the points of intersection of the grid boards.  A stone (or group of stones) is considered captured and removed from the board if it is surrounded on all sides by the opponent‚Äôs stones.  For example, in the following diagrams, white stones (‚Äúw‚Äù) or groups of stones will be removed from the board if black (‚Äúb‚Äù) makes a move to the point indicated by ‚Äúx‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/4dc/646/0604dc6464b6da960ea3da12d3d0899e.png"></div><br><br><div class="spoiler">  <b class="spoiler_title">Terms and conditions</b> <div class="spoiler_text"><ol><li>  Tasks are given on a 9 √ó 9 student board. </li><li>  The right turn - in black stones. </li><li>  It is guaranteed that there are no stones on the board that are already captured. </li></ol><br>  <b>At the entrance</b> : nine lines representing the game board are fed to STDIN.  The lines consist of spaces (denoting empty dots on the board), the characters ‚Äúw‚Äù (white stones) and ‚Äúb‚Äù (black stones), and are terminated by a newline character (‚Äú\ n‚Äù). <br><br>  <b>At the exit</b> : coordinates (row number and column number separated by a space, numbering from one) points, the course at which leads to the seizure of white stones.  Must be displayed on STDOUT, one point per line.  All potential moves on the board leading to the seizure of white stones should be drawn.  Points should be displayed in order of appearance on the board from left to right and from top to bottom. <br><br>  The competition is held according to the usual rules of Perl Golf: <br><ol><li>  The shortest program that successfully passes the <a href="">tests</a> wins. </li><li>  Shebang should look like #! Perl or #! Perl -flags.  #! perl is not taken into account when counting the number of characters, but the specified flags, including the "-" character (s), are taken into account. </li><li>  All other characters are counted, including spaces and line breaks. </li><li>  The program cannot use other modules, call external programs or access external data sources. </li><li>  The solution should work correctly on Perl version 5.18.0, without outputting anything on STDERR. </li></ol><br></div></div><br>  The condition of the problem and a set of tests for verification were published on <a href="http://contest.reg.ru/%3Flang%3Dru">contest.reg.ru</a> .  Passing tests was considered a criterion for the correctness of the decision.  However, after the competition, the participants proposed several additional sophisticated test cases, on which some decisions stumbled.  So the above solutions, if they do not pass additional test cases, are marked separately. <br><br>  Despite the active professional and social life of the participants during all the days (as well as evenings and nights) of the conference, we received some very interesting decisions, which I bring further with my own annotations (with a discount on the degree of my understanding, because it‚Äôs still ). <br><br><h4>  Competitive decisions </h4><br><h5>  205 characters - Brian McCauley </h5><br><img align="left" alt="Winner of the Perl Golf competition from REG.RU" src="https://habrastorage.org/storage3/e4a/791/138/e4a7911386cd236324e8883418ac22cf.png">  The winner of the competition proposed a solution with highlighting of groups of adjacent stones and ‚Äúrunning around‚Äù regular expressions for checking neighboring points (since ancient times there is a belief that only a solution on regexp can win Perl Golf).  In addition, a trick appears in many solutions with the addition of an additional initial row to the input data, due to which the sequential position of a point on the board turns into a combination of its coordinates (row numbers and column numbers). <br><br><pre><code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl $b=++$/x11 .&lt;&gt;;for$i(9..99){if(($x=$b)=~s/^(.{$i}) /$1x/s){while($x=~/w/g){$_="$`W$'";1while s/w((?&lt;=W.{10})|(?&lt;=W.)|(?=.{9}W|W))/W/s;/W((?&lt;= .{10})|(?&lt;= .)|(?=.{9} | ))/s||$i=~/./+(print"$&amp; $'\n")+last}}}</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl # $/   ¬´1¬ª,  ¬´&lt;&gt;¬ª       #  (   ).      #     11  (   / #          . $b = ++$/ x 11 . &lt;&gt;; #    . for $i ( 9 .. 99 ) { #   .     , . . , #    ¬´x¬ª ( ,  ,    #  ,   )  . if ( ( $x = $b ) =~ s/^(.{$i}) /$1x/s ) { #          (¬´w¬ª). while ( $x =~ /w/g ) { #    $_,     ¬´w¬ª  ¬´W¬ª # (     while # $`      ,   $' ‚Äî ). $_ = "$`W$'"; #    ,    . 1 while s/w((?&lt;=W.{10})|(?&lt;=W.)|(?=.{9}W|W))/W/s; #   ( ) -    . /W((?&lt;= .{10})|(?&lt;= .)|(?=.{9} | ))/s #   ,   . #   ¬´/./¬ª     $&amp; (  #  )  $' ( ,     # ), .   ,    #     . || $i =~ /./ + ( print "$&amp; $'\n" ) + last; } } }</span></span></code> </pre><br></div></div><br>  Brian published his decision and his own annotation on <a href="http://perlmonks.org/%3Fnode_id%3D1049290">PerlMonks</a> .  In addition, he made a <a href="http://act.yapc.eu/ye2013/talk/5013">report</a> describing this decision in the lightning block. <br><br>  For winning the competition, Brian received a wonderful mini-golf kit, so boredom at the workplace is no longer a threat. <br><br><img src="http://habrastorage.org/storage3/98d/b45/64b/98db4564b13a3ca9a999768fc5a8dfb6.jpg"><br><br><h5>  212 characters - Sergey Mozhaysky (does not pass additional test cases) </h5><br>  Solution with recursive traversal of neighboring points and storing information about checked points to avoid infinite recursion. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl @g=(d..n,map{/./g,''}&lt;&gt;);sub n{my($i,$j,$r)=@_;map{$_=1and map{$r=n($i,$j+1)+n($i,$j-1)+n($i+1,$j)+n($i-1,$j)==1if/w/;$r=1and$0="$i $j\n"if/ /}$g["$i$j"]if!$_}$s{"$i$j"};$r}map{print$0if$g[$_]eq'w'&amp;&amp;n(/./g)}0..99</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl #        d .. n, #    . @g = ( d .. n, map { /./g, '' } &lt;&gt; ); #     sub n { my ( $i, $j, $r ) = @_; #  %s       # (   ). #    %s  $_   map. map { #   %s    #   ,      . $_ = 1 and map { #     ‚Äî  ,    #     ,   #        # (. .         ). $r = n( $i, $j + 1 ) + n( $i, $j - 1 ) + n( $i + 1, $j ) + n( $i - 1, $j ) == 1 if /w/; #   ,    #     $0. $r = 1 and $0 = "$i $j\n" if / / } $g["$i$j"] if !$_ } $s{"$i$j"}; #    $r } #     . map { #      ,     #     . print $0 if $g[$_] eq 'w' &amp;&amp; n(/./g) } 0 .. 99</span></span></code> </pre></div></div><br>  Unfortunately, on additional tests, the solution has false positives. <br><br><h5>  279 characters - Nikolay Shulyakovsky </h5><br>  It is also a recursive solution, but with a different logic of protection against infinite recursion and re-output of results. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl while(&lt;&gt;){tr/ wb\n/2133/;$str.=$_.'3'}@m=split//,('3'x12).$str;for(@m){%l=();$r=1;z($i);$o{$w[0]}=1if/1/&amp;&amp;$r&amp;&amp;(@w=%l)==2;$i++}printf"%d %d$/",$_/11,$_%11for sort keys%o;sub z{my$c=$_[0];for(qw/11 1 -11 -1/){$x=$c+$_;$n=$m[$x];$l{$x}=1if$n==2;if($n==1){z($x)if!/-/;$r=0if$i&gt;$x}}}</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl while (&lt;&gt;) { #   , tr/ wb\n/2133/; #      . $str .= $_ . '3'; } @m = split //, ( '3' x 12 ) . $str; #      #     for (@m) { %l = (); $r = 1; z($i); #  . $o{ $w[0] } = 1 #  , if /1/ #     ( ), &amp;&amp; $r #  , &amp;&amp; ( @w = %l ) == 2; #       . $i++; } printf "%d %d$/", $_ / 11, $_ % 11 #       #     11 for sort {$a &gt; $b} keys %o; #    . sub z { my $c = $_[0]; for (qw/11 1 -11 -1/) { #     $x = $c + $_; #   , $n = $m[$x]; #   . $l{$x} = 1 if $n == 2; #  ,    ‚Äî  if ( $n == 1 ) { #    ‚Äî  , z($x) if !/-/; #     . $r = 0 if $i &gt; $x #  ,    #    # (  ) } } }</span></span></code> </pre></div></div><br>  On additional test cases, a rather significant bug is caught: when there are ‚Äúexciting‚Äù positions in the last line of the field (position in the array of 100 or more), they get into the output in front of the positions going on the board before.  It is caused by the fact that sort is used to sort the results, and it by default works in the string comparison mode, i.e. "100" will be less than "99". <br><br><h5>  370 characters - Mikalai Liohenki + Denis Shirokov </h5><br>  Another variation of the solution with recursion.  Another frequently used trick appears here: a copy of the board is made to check each point, a black stone is placed into it, and it is checked whether there are any captured white stones on the board. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl $s='b'x12; while(&lt;&gt;){s/\n/bb/;s/ /0/g;$s.=$_;}$s.='b'x10;@q=(-1,+1,11,-11);@a=split//,$s; for(@a){++$i;if(!$a[$i]){$res=0;$p=[];for(@q){$c=$_+$i;if($a[$c]eq'w'){$p=[@a];$p-&gt;[$i]='b';$res+=b($p,$c);}}if($res){printf"%d %d\n",$i/11,$i%11;}}} sub b{my($e,$w)=@_;$r=1;for(@q){$z=$_+$w;return 0 if!$r||!$e-&gt;[$z];if($e-&gt;[$z]eq'w'){$t=[@$e];$t-&gt;[$w]='b';$r&amp;=b($t,$z)}}return$r}</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl #   ,       . #    0,     . $s = 'b' x 12; while (&lt;&gt;) { s/\n/bb/; s/ /0/g; $s .= $_; } $s .= 'b' x 10; @q = ( -1, +1, 11, -11 ); #     . @a = split //, $s; #      . for (@a) { #  . ++$i; if ( !$a[$i] ) { #   . $res = 0; $p = []; for (@q) { #   . $c = $_ + $i; if ( $a[$c] eq 'w' ) { #     . $p = [@a]; #   $p-&gt;[$i] = 'b'; #      . $res += b( $p, $c ); #  ¬´¬ª. } } if ($res) { #   , printf "%d %d\n", $i / 11, $i % 11; #     . } } } sub b { my ( $e, $w ) = @_; $r = 1; for (@q) { #   .    . $z = $_ + $w; return 0 if !$r || !$e-&gt;[$z]; if ( $e-&gt;[$z] eq 'w' ) { $t = [@$e]; $t-&gt;[$w] = 'b'; $r &amp;= b( $t, $z ) } } return $r; }</span></span></code> </pre></div></div><br><h5>  390 characters - Dmitri L. </h5><br>  The next recursive solution with a specific aggregation of the result of the verification of neighbors in the form of a counter. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl push@t,split//,'b'x11;for(&lt;&gt;){chomp;push@t,split//,"b$_"."b"}push@t,@t[0..10];for(;$r++&lt;11;){for($c=0;$c++&lt;11;){$i=$r*11+$c;if($t[$i]eq' '){for($i-11,$i+1,$i+11,$i-1){next unless$t[$_]eq'w';$t[$i]='b';if(f($_)&gt;7){print"$r $c\n";last}$t[$i]=' '}}}}sub f{my($r,$e,$k)=@_;$d{$r}?return$e||$dr:($d{$r}=2);for($r-11,$r+1,$r+11,$r-1){$k+=1+f($_,1)if$t[$_]eq'w';$k+=2if$t[$_]eq'b'}$e?$k&gt;7?$e:0:$k}</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl #   ,        push @t, split //, 'b' x 11; for (&lt;&gt;) { chomp; push @t, split //, "b$_" . "b" } push @t, @t[ 0 .. 10 ]; #      for ( ; $r++ &lt; 11 ; ) { for ( $c = 0 ; $c++ &lt; 11 ; ) { #    $i = $r * 11 + $c; #    - ,   if ( $t[$i] eq ' ' ) { for ( $i - 11, $i + 1, $i + 11, $i - 1 ) { next unless $t[$_] eq 'w'; $t[$i] = 'b'; if ( f($_) &gt; 7 ) { #    7 (. . 8) print "$r $c\n"; #   last } $t[$i] = ' ' } } } } sub f { my ( $r, $e, $k ) = @_; $d{$r} ? return $e || $dr : ( $d{$r} = 2 ); for ( $r - 11, $r + 1, $r + 11, $r - 1 ) { #   $k += 1 + f( $_, 1 ) if $t[$_] eq 'w'; #    -    1    $k += 2 if $t[$_] eq 'b'; #    2    } $e ? $k &gt; 7 ? $e : 0 : $k; }</span></span></code> </pre></div></div><br><h5>  404 characters - Philippe Bruhat (BooK) </h5><br>  Not the shortest, but perhaps the most algorithmically complex, and one of the most confusing and difficult to parse solutions, so do not expect complete clarity from my annotation. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl #!perl -ln sub M{$k=pop;my%t;$l[$k]=[grep!$t{$_}++,@{$l[$k]},@_]}sub S{($m,$n)=@_;($M,$N)=sort$$m,$$n;M@{delete$l[$N]},$M if$N!=($$m=$$n=$M)}$i=1;for(split//){$b[$c=$..$i]=/w/?++$e:$_;$x=($R=$.-1).$i;$y=$..($C=$i-1);/w/&amp;&amp;do{$b[$_]&gt;0&amp;&amp;S\$b[$c],\$b[$_]for$x,$y;M$b[$x]eq$"?"$R $i":(),$b[$y]eq$"?"$. $C":(),$b[$c]};/ /&amp;&amp;map{$b[$_]&gt;0&amp;&amp;M"$. $i",$b[$_]}$x,$y;$i++}}{print for sort grep!$s{$_}++,map@$_-1?():@$_,@l</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln sub M { $k = pop; my %t; #  ¬´¬ª. $l[$k] = [ grep !$t{$_}++, @{ $l[$k] }, @_ ] } sub S { ( $m, $n ) = @_; ( $M, $N ) = sort $$m, $$n; #          #    ¬´¬ª  M @{ delete $l[$N] }, $M if $N != ( $$m = $$n = $M ); } $i = 1; #       . for ( split // ) { $b[ $c = $. . $i ] = #  $.   . /w/ ? ++$e : $_; #      #   . $x = ( $R = $. - 1 ) . $i; #    . $y = $. . ( $C = $i - 1 ); #     . #    ‚Äî      /w/ &amp;&amp; do { #      $b[$_] &gt; 0 &amp;&amp; S \$b[$c], \$b[$_] for $x, $y; #   ¬´¬ª. M $b[$x] eq $" ? "$R $i" : (), $b[$y] eq $" ? "$. $C" : (), $b[$c]; }; #    ‚Äî  ¬´¬ª     . / / &amp;&amp; map { $b[$_] &gt; 0 &amp;&amp; M "$. $i", $b[$_] } $x, $y; $i++; } }{ #  . print for sort grep !$s{$_}++, map @$_ - 1 ? () : @$_, @l</span></span></code> </pre></div></div><br>  Fortunately, Philip approached the case seriously and supplied the solution with his own detailed description. <br><br><div class="spoiler">  <b class="spoiler_title">Abstract from the author</b> <div class="spoiler_text">  The core of the algorithm is to create groups of stone, and update <br>  the list of freedoms for each group.  At the end, only the freedoms <br>  having been sorted <br>  and deduplicated. <br><br>  The algorithm of use is for the board <br>  9x9 board.  The coordinates are in the range 00..99 and $ x. $ Y can <br>  point to any intersection.  When constructing the board, the column <br>  and row 0 are filled with nothing (either undef or ''). <br><br>  Thanks to the line by line (thanks to -ln). <br>  For each cell, I looked at the cell above and on its left. <br><br>  If the current cell is a 'w', it's turned into the next available <br>  if both a number, then both are turned <br>  the lists of freedoms are <br>  merged.  Neighbors that are '' added to the list of freedoms for <br>  the current cell. <br><br>  If the current cell is a <br>  neighbors that are numbers. <br><br>  For 'b' cells, we do nothing. <br><br>  Numbers are the 'equivalence classes' for the white groups, ie <br>  two cells having the same group. <br><br>  Print this board: <br><br><pre> <code class="hljs css"> ..<span class="hljs-selector-class"><span class="hljs-selector-class">.wb</span></span>.... ..<span class="hljs-selector-class"><span class="hljs-selector-class">.1b</span></span>.... ..<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>..... ..<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>..... ......... ......... .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-tag"><span class="hljs-selector-tag">would</span></span> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.bwb</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">become</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">bwwwb</span></span>.... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b222b</span></span>.... ......... ......... ......... ......... ......<span class="hljs-selector-class"><span class="hljs-selector-class">.bw</span></span> ......<span class="hljs-selector-class"><span class="hljs-selector-class">.b6</span></span></code> </pre><br>  Without any merging of cells, the '2' group would actually be: <br><br><pre> <code class="hljs"> 2 345</code> </pre><br>  During the pass, it evolves like this: <br><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2</span></span></code> </pre><br>  (visiting all cells until the next white) <br><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2</span></span>...... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b3</span></span></code> </pre><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b34</span></span></code> </pre><br>  merging the current cell (4) with 2: <br><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b32</span></span></code> </pre><br>  merging the current cell (2) with 3: <br><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b22</span></span></code> </pre><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b225</span></span></code> </pre><br>  merging the current cell (5) with 2: <br><br><pre> <code class="hljs css"> .<span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span>...... <span class="hljs-selector-class"><span class="hljs-selector-class">.b2b</span></span>..... <span class="hljs-selector-tag"><span class="hljs-selector-tag">b222</span></span></code> </pre><br>  The sub M doesn‚Äôt include the addition of freedoms, removing duplicates <br>  The Sub S doesn‚Äôt <br>  M to merge their freedoms. <br><br>  At 400, I had no expectation of winning.  A well-known fact of golf <br>  competitions is that regexp-based algorithms always win.  :-) <br></div></div><br><h5>  500 characters - Savio PImatteo </h5><br>  And one more recursive decision comparing the number of ‚Äúnot free‚Äù (black or captured white) stones on the board before and after installing a black stone in each empty cell. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl my$X=121;my$m;sub z{my($s,$x,$m)=shift;while($x&lt;$X){$m+=f($x++,$s);}$m;}sub f{my($n,$t,$d)=@_;my$c=substr($t,$n,1);return 0 if $c eq ' '||!$d&amp;&amp; $c ne 'w';return 1 if $c eq 'b';substr($t,$n,1)='b';(!(($n+1)%11)||f($n+1,$t,1))*(!(($n-1)%10)||f($n-1,$t,1))*f($n+11,$t,1)*f($n-11,$t,1);}my$y='b'x11;while(&lt;&gt;){$y.="b$_";}$y=~s/\n/b/g;$y.='b'x11;$d=z($y);my$i=0;while($i&lt;$X){my$ch=substr($y,$i,1);if($ch eq ' '){$b=$y;substr($b,$i,1)='b';if(z($b)&gt;$d){my$y=int($i/11);my$x=$i-($y*11);print"$y $x\n";}}$i++;}</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl my $X = 121; #    . my $m; #   ¬´¬ª (   )    . sub z { my ( $s, $x, $m ) = shift; #      . while ( $x &lt; $X ) { $m += f( $x++, $s ); } $m; } #    ¬´¬ª sub f { my ( $n, $t, $d ) = @_; my $c = substr( $t, $n, 1 ); #   . #  0    #               . return 0 if $c eq ' ' || !$d &amp;&amp; $c ne 'w'; #  1,      . return 1 if $c eq 'b'; #     . substr( $t, $n, 1 ) = 'b'; #    . ( !( ( $n + 1 ) % 11 ) || f( $n + 1, $t, 1 ) ) * ( !( ( $n - 1 ) % 10 ) || f( $n - 1, $t, 1 ) ) * f( $n + 11, $t, 1 ) * f( $n - 11, $t, 1 ); #    0,      #      . } #   ,       . my $y = 'b' x 11; while (&lt;&gt;) { $y .= "b$_"; } $y =~ s/\n/b/g; $y .= 'b' x 11; $d = z($y); my $i = 0; while ( $i &lt; $X ) { #  . my $ch = substr( $y, $i, 1 ); #   . if ( $ch eq ' ' ) { #    , $b = $y; #  , substr( $b, $i, 1 ) = 'b'; #     . #      ¬´¬ª   if ( z($b) &gt; $d ) { #    . my $y = int( $i / 11 ); my $x = $i - ( $y * 11 ); print "$y $x\n"; } } $i++; }</span></span></code> </pre></div></div><br><h5>  581 character - Dimitry Ivanov </h5><br>  The solution is very close to the previous one from Savio Pimatteo. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl eval{ $a-&gt;[10]=$a-&gt;[0]=[('b')x11]; while(&lt;STDIN&gt;){chomp;@{$a-&gt;[++$i]}=('b',(split''),'b');last if $i&gt;=9} sub f { my($x,$y)=@_; return $o[$j] if $n-&gt;[$x][$y]; return $o[$j]||2 if $a-&gt;[$x][$y]eq'b'; return 1 if $a-&gt;[$x][$y]ne'w'; $n-&gt;[$x][$y]=$j; $o[$j]=f($_,$y)for($x-1,$x+1); $o[$j]=f($x,$_)for($y-1,$y+1); return $o[$j]; } sub p { for $x(0..10){for $y(0..10){ f($x,$y,$j++) if $a-&gt;[$x][$y]eq'w'&amp;&amp;!$n-&gt;[$x][$y]; }} return grep{$_==2}@o; } my $t=p; for $x(0..10){for $y(0..10){ next if $a-&gt;[$x][$y]ne' '; $a-&gt;[$x][$y]='b'; @o=();$n=[]; print"$x $y\n" if $t&lt;p; $a-&gt;[$x][$y]=' '; }} }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl eval { #       . $a-&gt;[10] = $a-&gt;[0] = [ ('b') x 11 ]; #  ,     . while (&lt;STDIN&gt;) { chomp; @{ $a-&gt;[ ++$i ] } = ( 'b', ( split '' ), 'b' ); last if $i &gt;= 9; } #     . sub f { my ( $x, $y ) = @_; #   ,    . return $o[$j] if $n-&gt;[$x][$y]; #     2,      . return $o[$j] || 2 if $a-&gt;[$x][$y] eq 'b'; #  ,        (. .  ). return 1 if $a-&gt;[$x][$y] ne 'w'; #    ,   , $n-&gt;[$x][$y] = $j; #    . $o[$j] = f( $_, $y ) for ( $x - 1, $x + 1 ); $o[$j] = f( $x, $_ ) for ( $y - 1, $y + 1 ); #   $o[$j]   1      #       . return $o[$j]; } #    . sub p { #    . for $x ( 0 .. 10 ) { for $y ( 0 .. 10 ) { #  ,       #      . f( $x, $y, $j++ ) if $a-&gt;[$x][$y] eq 'w' &amp;&amp; !$n-&gt;[$x][$y]; } } #       # (. .     ). return grep { $_ == 2 } @o; } my $t = p; # . for $x ( 0 .. 10 ) { #   . for $y ( 0 .. 10 ) { next if $a-&gt;[$x][$y] ne ' '; # ,    . $a-&gt;[$x][$y] = 'b'; #     . @o = (); #  . $n = []; #     . print "$x $y\n" if $t &lt; p; #   ,   #      # (. .    ). $a-&gt;[$x][$y] = ' '; #   . } } }</span></span></code> </pre></div></div><br><h4>  Non-competitive solutions </h4><br>  It would be strange to arrange a competition and not have a solution to the competitive problem.  So here is the decision from the organizer, that is me: <br><br><h5>  192 characters - Timur Nozadze </h5><br>  Rectilinear recursive solution.  A good result was achieved due to tight minimization and getting rid of all unnecessary, saving on parsing input data using flags and a fairly effective trick for translating the position of a point into coordinates using regexp and special variables. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0aF// sub c{my$s=pop;$s=~/-|9/||$g[$s]eq'b'||$g[$s]=~/w/*!grep{$g[$s]='b';!c($s+$_)}1,-1,10,-10}map{@g=@F;$g[$_]='b';/\d$/,print$`+1,$",$&amp;+1if$F[$_]=~/ /*grep{$g[$_]eq'w'&amp;&amp;c$_}0..$#g}0..$#F</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0aF// #   : # -n  ¬´while () { ‚Ä¶ }¬ª  ; # -0     ,    ; # -a  ,       @F; # -F//  -a   ; # -l      print. #   ¬´¬ª  sub c { my $s = pop; #  ,  #      (   ), $s =~ /-|9/ #     , || $g[$s] eq 'b' #         . || $g[$s] =~ /w/ * !grep { $g[$s] = 'b'; !c( $s + $_ ) } 1, -1, 10, -10; } #     . map { #  . @g = @F; #      . $g[$_] = 'b'; # ,     ,        #      . /\d$/, print $`+ 1, $", $&amp; + 1 if $F[$_] =~ / / * grep { $g[$_] eq 'w' &amp;&amp; c $_} 0 .. $#g } 0 .. $#F</span></span></code> </pre></div></div><br>  Despite the algorithmic simplicity of the solution, surprisingly a lot of excess can be removed from the code if you concentrate on the essence of the problem, and not produce new variables and duplicate pieces of code with a generous hand, as we often do.  So Golf makes you focus not just on reducing the size of the code, but also on a deeper and cleared of all the superficial understanding of the problem and its solution. <br><br>  In fact, during the competition this result (192 characters) was not beaten.  However, this was not the end, it is time for collaborations and exchange of experience. <br><br><h5>  197 characters - Sergey Mozhaysky (does not pass the additional test case) </h5><br>  Sergey improved his decision, getting rid of the intermediate variable and inventing a new option for the output of coordinates. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl @g=(d..n,map{/./g,''}&lt;&gt;);sub n{my($i,$r)=@_;map{do{$_=1and$r=n($i+1)+n($i-1)+n($i+10)+n($i-10)==1if/w/;$_=$r=1and$0=$i if/ /}if/\D/}$g[$i];$r}map{printf"%s %s\n",$0=~/./g if$g[$_]eq'w'&amp;&amp;n($_)}0..99</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl @g = ( d .. n, map { /./g, '' } &lt;&gt; ); #        . sub n { my ( $i, $r ) = @_; #        , #      . map { do { $_ = 1 and $r = n( $i + 1 ) + n( $i - 1 ) + n( $i + 10 ) + n( $i - 10 ) == 1 if /w/; $_ = $r = 1 and $0 = $i if / / } if /\D/ } $g[$i]; $r } map { #          printf "%s %s\n", $0 =~ /./g if $g[$_] eq 'w' &amp;&amp; n($_) } 0 .. 99</span></span></code> </pre></div></div><br><h5>  189 characters - Timur Nozadze </h5><br>  My solution was reduced to a couple of characters due to Brian's remarks: getting the size of arrays in $ # was replaced by the numeric constant 89, and the regular expression <code>/\d$/</code> was replaced by <code>/.$/</code> . <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0aF// sub c{my$s=pop;$s=~/-|9/||$g[$s]eq'b'||$g[$s]=~/w/*!grep{$g[$s]='b';!c($s+$_)}1,-1,10,-10}map{@g=@F;$g[$_]='b';/.$/,print$`+1,$",$&amp;+1if$F[$_]=~/ /*grep{$g[$_]eq'w'&amp;&amp;c$_}0..89}0..89</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0aF// #   : # -n  ¬´while () { ‚Ä¶ }¬ª  ; # -0     ,    ; # -a  ,       @F; # -F//  -a   ; # -l      print. #   ¬´¬ª  sub c { my $s = pop; #  ,  #      (   ), $s =~ /-|9/ #     , || $g[$s] eq 'b' #         . || $g[$s] =~ /w/ * !grep { $g[$s] = 'b'; !c( $s + $_ ) } 1, -1, 10, -10; } #     . map { #  . @g = @F; #      . $g[$_] = 'b'; # ,     ,        #      . /.$/, print $`+ 1, $", $&amp; + 1 if $F[$_] =~ / / * grep { $g[$_] eq 'w' &amp;&amp; c $_} 0 .. 89 } 0 .. 89</span></span></code> </pre></div></div><br>  Fundamental improvements in this approach can hardly be expected. <br><br>  And then we witnessed the battle of the titans at Perlmonks. <br><br><h5>  175 characters - Brian McCauley </h5><br>  Brian seriously improved his result, taking advantage of Sergey's advice and some ideas from my decision. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0 map{$i=$-[0]+11;{map{1while s/w((?&lt;=W.{10})|(?&lt;=W.)|(?=.{9}W|W))/W/s;/W((?&lt;= .{10})|(?&lt;= .)|(?=.{9} | ))/s||$i=~/./+print("$&amp; $'")+last}"$`W$'"while/w/g}}"$`x$'"while/ /g</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0 #  ,       . map { $i = $-[0] + 11; #     . { map { 1 while s/w((?&lt;=W.{10})|(?&lt;=W.)|(?=.{9}W|W))/W/s; /W((?&lt;= .{10})|(?&lt;= .)|(?=.{9} | ))/s || $i =~ /./ + print("$&amp; $'") + last } "$`W$'" while /w/g } } "$`x$'" while / /g</span></span></code> </pre></div></div><br><h5>  127 characters - Grimy </h5><br>  The user of Grimy with PerlMonks has broken away from the idea of ‚Äã‚ÄãBrian and brought the version with regexps to a completely fantastic result of <a href="http://perlmonks.org/%3Fnode_id%3D1050514">127 characters</a> ! <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0 map{1while$,=s=$,w=g=s?'(g|(?=.g|..{9}g)|g.{9})\K':/g/&gt;/$, /s&amp;&amp;map{y!.! !;print;redo}/x/+"@+E-1"or y&amp;g&amp;b&amp;}"$`x$'"while/ /g</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">annotation</b> <div class="spoiler_text"><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!perl -ln0 #      ¬´x¬ª. map { 1 while $, = #       g. # ( $,    ,    #        .) s=$,w=g=s #        . ? '(g|(?=.g|..{9}g)|g.{9})\K' #     ,     , #    . : /g/ &gt; /$, /s &amp;&amp; map { #  @+        /x/, # . .     . #     (/x/)     , #  -1  (E-1).     ¬´.¬ª  ¬´ ¬ª, #    . y!.! !; print; redo } /x/ + "@+E-1" #      ‚Äî     #    . or y&amp;g&amp;b&amp; } "$`x$'" while / /g</span></span></code> </pre></div></div><br>  To tell you the truth, this decision for me still retains some element of mysticism, but I hope my abstract is not too far from the truth. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the common belief in the invincibility of solutions on regexps fully justified itself. </font><font style="vertical-align: inherit;">This is a terrific result and it will be difficult to beat him. </font><font style="vertical-align: inherit;">However, knowing the incredible courage and fighting qualities of habrazhitel, we suggest trying their hand. </font><font style="vertical-align: inherit;">Anyone who offers a better solution (i.e., shorter) than the current leader (127 characters) will receive a domain from REG.RU in .ru or .rf and VPS at any rate for up to 6 months as a gift! </font><font style="vertical-align: inherit;">Decisions are made at </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contest@reg.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Only decisions that successfully pass the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">updated test suite are made</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Dare! </div><p>Source: <a href="https://habr.com/ru/post/191704/">https://habr.com/ru/post/191704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191694/index.html">LVMOO LM028N - a mobile charger with a Wifi router</a></li>
<li><a href="../191696/index.html">Injecting a legacy story into a tree: finding the optimal branch point</a></li>
<li><a href="../191698/index.html">Samsung Galaxy Pocket Neo - a simple smartphone for parents</a></li>
<li><a href="../191700/index.html">Diagnosing Network Problems with Looking Glass</a></li>
<li><a href="../191702/index.html">Power and Mobility Fusion: HP EliteBook 8770w Laptop Review</a></li>
<li><a href="../191706/index.html">Nissan will start selling unmanned vehicles in 2020</a></li>
<li><a href="../191708/index.html">Grandstream IP PBX Review</a></li>
<li><a href="../191712/index.html">Windows Azure for startups: resources for $ 150 every month</a></li>
<li><a href="../191714/index.html">Evernote for Windows Phone 8 Update: Continuous Shooting, Speech to Text, and More</a></li>
<li><a href="../191722/index.html">Save to my Dropbox as a way to have fun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>