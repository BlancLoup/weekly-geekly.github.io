<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The story of the endless city. On Three.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebGL is one of the most interesting new technologies that can miraculously transform the Internet. On the basis of this technology, several engines h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The story of the endless city. On Three.js</h1><div class="post__text post__text-html js-mediator-article">  WebGL is one of the most interesting new technologies that can miraculously transform the Internet.  On the basis of this technology, several engines have already been created that allow you to create amazing things without any extra efforts, and the most famous of them is Three.js.  Getting to know him was my longtime desire, and the best way to do this is to create something interesting.  The first idea was to jot down an ‚Äúinspiring‚Äù scene on Three.js containing both a large number of polygons, light sources and particles, and having, in this case, some meaningful context.  Soon, this idea turned into a desire to create an endless city in which you could dive through the browser. <br><br>  It is worth saying that the article is not devoted to the whole construction, but only to solving the most interesting problems that had to be faced as the scene was created. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ba8/547/2c3ba85478b6b255f45dad1233d98bf9.png" alt="image"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Building roads </h4><br>  Having plunged into the works found on the Internet devoted to the procedural creation of virtual cities, I found that, as a rule, the following algorithm is used to build roads: <br><br>  1. Construct one or more guide roads from one or more points, which gradually grow. <br>  2. With growth, with a certain probability, the road can turn a certain degree, or generate another road that grows perpendicular to it with an error of several degrees. <br>  3. As soon as the road reaches the maximum length, or intersects with another road, its growth stops. <br><br>  It looks like this: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/pQ-tYdLVNFw%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhCecONL7sJwn1i0zaYnmaslNHykw" frameborder="0" allowfullscreen=""></iframe><br><br>  The result of the operation of this algorithm looks quite natural, however, it has several serious flaws: <br><br>  1. High time complexity: for each point in time of construction, you need to go through all the roads by increasing them by a certain amount.  And for each individual road, you need to go through all the unfinished roads to find possible intersections. <br>  2. It is impossible to reproduce a section of a road if key points (from which construction starts) were out of sight, which means that it is necessary to create a large amount of data that is not needed at a particular moment. <br><br>  These shortcomings do not allow building a city on the fly.  Therefore, it was necessary to come up with a different algorithm, which would be deprived of these shortcomings and at the same time would give a fairly similar result.  The idea was not to ‚Äúgrow‚Äù a canvas of roads, but to build an array of points - intersections of roads and afterwards connect them with lines.  The algorithm is as follows: <br><br>  1. A canvas of equidistant points (with some random error) is being built, which will be the centers of our city.  For each point is determined by the size and shape within which further construction will take place. <br>  2. For each point, within a certain form, one builds his own equidistant canvas (for a much smaller distance and also having some error) points that will be the intersection of roads. <br>  3. Points that are too close to each other are deleted. <br>  4. Nearest points are connected. <br>  5. For each point, a certain number of ‚Äúbuildings‚Äù is built equal to the number of connections at the point.  (The building is in quotes, so in theory this is not the building itself, but the form within which this building can be built, with the certainty that it will not intersect with other buildings) <br><br>  Thus, the whole city is built without a heavy search for intersections, and can be recreated from any starting point.  However, the algorithm still has disadvantages: <br><br>  1. Intersections still sometimes occur, although their probability is quite low. <br>  2. Sometimes there are isolated parts of the city not connected by a highway with the rest of the city. <br><br>  The algorithm works as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/52a/602/30c/52a60230cf7206e12540eee054e7e02c.gif" alt="image"><br>  <i>Red - viewing radius</i> <i><br></i>  <i>Yellow - the maximum radius of building</i> <br><br><h4>  Building construction </h4><br>  To speed up the output of complex geometry in Three.js there is a module for working with buffer geometry, which will allow you to create scenes with an incredible number of elements ( <a href="http://alteredqualia.com/three/examples/webgl_buffergeometry_perf2.html">example</a> ).  However, in order for everything to work quickly, all buildings need to be stored in one single mesh, and therefore with a single material that needed to transfer several textures of buildings in order to diversify them a little.  And although transferring an array of textures to a shader is not a problem, there is a special type of uniform for this in three.js, the problem was that GLSL ES 1.0 (which is used to compile shaders in WebGL) cannot be used as an index of the array, not means and use the transferred texture number for each specific building. <br>  The solution was found in the fact that you can use a loop iterator as an index.  It looks like this: <br><br><pre><code class="hljs perl">const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max_tex_ind = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   uniform sampler2D a_texture [max_tex_ind]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  varying <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   (    ,     ) ... void main() { vec3 tex_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; max_tex_ind; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == indx) { tex_color = texture2D(a_texture[i],uv).xyz; } } ... }</code> </pre> <br><br>  Of course, this solution will work well only if the maximum number of textures is not large.  An alternative solution may be to use one large texture, glued from the necessary textures, but in this case you will have to sacrifice the quality of each individual texture. <br><br><h4>  Lighting </h4><br>  To give the city more visual appeal, I decided to add lighting simulating the light of street lamps.  Of course, the standard lighting used in Three.js is not well suited for this task, while on average there are ~ 8000 sources of light on the stage.  However, all this illumination is equidistant from the base, and therefore it is not necessary to process each point separately as a source of illumination, instead you can create an illumination texture, even at the stage of generation of the city.  This is the texture: <br><br><img src="http://i.imgur.com/0JXNf3k.jpg?1" alt="image"><br><br>  All that remains to be done directly in the shader is to find the intensity of reflection of light from the plane and multiply it by the illumination specified in the texture. <br><br>  Here you can go a little further.  If the light sources do not intersect, you can create another texture where you can maintain the height at which the light source is located, and due to this, place the scene on the relief surface. <br><br><h4>  Smooth construction </h4><br>  This task turned out to be the simplest, since the basic idea was simple: it is necessary to build a city a little more than the user sees, and while he moves from one key point to another, re-generate the city based on the next key point.  The main thing is to limit the speed of movement of the user so that during the move to the next point + construction time, it was impossible to reach the border of the pre-built part of the city. <br><br>  As for the generation itself, all of it was divided into many stages, with statistics for each stage (which can be viewed by going to the browser console) of how long the processor takes one stage or another per frame, and if this time was more than some values, the stage was divided into several substages until it allowed to achieve consistently high FPS. <br><br><h4>  Result </h4><br>  The scene itself and the source code: <a href="http://mylittlerapture.com/three.js/Infinite_city.html">here</a> <br>  Video version: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ExTJ9NP5L1g%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgKHNDIIdVYG98H_kDEQnOGl06EJA" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/278043/">https://habr.com/ru/post/278043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278031/index.html">Problems of access control based on the access list in ECM systems (part 2)</a></li>
<li><a href="../278033/index.html">TOM.js is a special library for special cases.</a></li>
<li><a href="../278037/index.html">Handlersocket protocol in detail</a></li>
<li><a href="../278039/index.html">Again about STL</a></li>
<li><a href="../278041/index.html">Personalize IMGUI and Unity Editor. Part one</a></li>
<li><a href="../278045/index.html">Configuring fault tolerance in 3CX Version 14</a></li>
<li><a href="../278047/index.html">jsPDF + canvas: export to PDF of a multipage table in Russian</a></li>
<li><a href="../278049/index.html">How to create your own Dependency Injection Container</a></li>
<li><a href="../278051/index.html">Patch gnupg or a pair of RSA-32768 in 106 minutes</a></li>
<li><a href="../278053/index.html">Apple hired the author Signal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>