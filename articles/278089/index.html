<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does split-testing in Badoo work?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you enter the query ‚Äúab testing‚Äù in Google, then there are quite a lot of articles on the topic, but they have more theory and are aimed at manager...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does split-testing in Badoo work?</h1><div class="post__text post__text-html js-mediator-article">  If you enter the query ‚Äúab testing‚Äù in Google, then there are quite a lot of articles on the topic, but they have more theory and are aimed at managers, and ready-made client implementations like <a href="https://www.google.com/analytics/">Google Analytics are</a> offered as tools.  There is also an <a href="https://habrahabr.ru/post/169777/">article</a> about a very simple server implementation (in the realities of the authors, I think this is quite enough). <br><br>  Today I will talk about how this happens here in Badoo, with a huge number of users around the world. <br><br>  We had a whole ‚Äúzoo‚Äù of tools for split testing, led by an A / B framework, some of which were developed for other purposes.  Among other shortcomings, all these tools used roughly the same method for dividing users into options - this is hashing the user ID plus the ‚Äúsalt‚Äù.  This approach did not satisfy us, and it was decided to develop a new version, in which the shortcomings of the old versions could be avoided. <br><a name="habracut"></a><br>  The main requirements for the new version of the split-testing tool were as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  we have a big project and a big team, so you need to do a lot of tests at the same time; </li><li>  tests that are running at the same time should intersect at the minimum among users; if there are intersections with other tests, information about this should be displayed to the manager; </li><li>  when creating a test, I would like to understand how many people will fall into each test version; </li><li>  so that when analyzing there were no questions why the test KPIs suddenly jumped, changes in test conditions should be displayed in the report; </li><li>  Software API for developers should be simple and reduce the likelihood of error; </li><li>  need the ability to change the test conditions without the involvement of the developer; </li><li>  for QA there should be a handy tool that allows you to specify an option for the user, regardless of whether the user falls under the test conditions or not; </li><li>  user check for entering the test should pass quickly enough so that it does not affect the page return time; </li><li>  The test should not be infinite, because over time it will greatly complicate the assessment of the intersections of the tests, and also introduce entropy into the code. </li></ul><br>  Based on these requirements and taking into account the recommendations of the BI team, the following appeared in the new tool: <br><br><ul><li>  the ability to specify the conditions for entering the test in the form of a filter; </li><li>  the ability to specify the start and end dates of the test in the required fields; </li><li>  the ability to specify options for the test, as well as the percentage of options; </li><li>  when saving, the estimated hit score of users in the test options, as well as the intersection with other tests (as a percentage); </li><li>  each time a test changes, a new test settings group is created, so to speak, which includes filters, test start and end dates, as well as options, which allows you to see test changes in BI reports and understand the cause of jumps in the charts; </li><li>  to estimate the number of users on the fly.  All users were divided into split-groups, and the distribution of users according to options was reduced to the distribution of split-groups by options. </li></ul><br>  A new version of the A / B framework is called <b>UserSplit Tool</b> or just <b>UserSplit</b> .  Development was an incremental way.  Initially, the minimum possible working functionality was made so that the tool could be used immediately.  And then new features were added and bugs were fixed. <br><br>  Now I propose to consider in more detail our UserSplit as of the current moment and find out why it was necessary to do it. <br><br><h2>  Basic properties of the test </h2><br>  The page looks like this: <br><br><img src="https://habrastorage.org/files/be6/104/a28/be6104a28ee34c979559a59e2f206289.png"><br><br>  Here, the main fields of information, except <b>Key</b> , <b>Jira issue</b> , <b>Test managers</b> and the button <b>Create Hipchat room</b> . <br><br>  The Key field is a meaningful string that uniquely identifies the test.  In the software API of developers, Key is used, and not the test ID, since  it is more readable and also allows you not to be tied to the test ID. <br><br><div class="spoiler">  <b class="spoiler_title">Description of the remaining fields</b> <div class="spoiler_text">  In the Jira issue field, we specify the Jira task number.  It is used to make it easier to find the task in which the test was made.  Also, this task will receive automatic comments with notifications. <br><br>  In the field Test managers we indicate those people who have access to edit the test;  they will receive notifications from Hipchat.  As a rule, the author of the test and the watchers of the Jira task come here. <br><br>  Button Create Hipchat room creates a room in the messenger and adds all the test managers there.  Notifications will also be sent to this room, in addition, you can discuss the details of the test here.  You can also add other users to the room directly from the UserSplit interface: <br><br><img src="https://habrastorage.org/files/a74/af9/4dd/a74af94dd3ab453487a97e69ab5cd1f1.png"><br><br><h3>  Notifications </h3><br>  Now there are two: <br><br><ul><li>  notification of the imminent start of the test (the starting date is approaching); </li><li>  notice that the code for the test is laid out "for battle" and the test can be run. </li></ul><br>  In the future, it is planned to make a notice of the imminent end of the test, and possibly some other notices. <br></div></div><br><h2>  Test conditions and options </h2><br>  On this page, you can specify the range of test dates (when it is active), the conditions for entering the test (for example, Country is Russia), as well as options.  For each option, the name and percentage of users included in it are indicated.  The name is used by the developers (instead of the variant ID) in order to understand which version of the test the user got into;  it is unique to the test.  Only one of the options can be a control, although the control version itself may be absent. <br><br><img src="https://habrastorage.org/files/189/30d/82a/18930d82a40f48aaa1090c4ebae92030.png"><br><br>  All that is on this page - the date range, test conditions, options - is the aforementioned group of test settings.  There can be several such groups of settings, but there can be only one group directly tied to a test at a time ‚Äî this is the current group of settings.  Each time the test settings group changes, in fact, it does not change, but a new one is created.  However, it does not immediately bind to the test, but only after it is ready.  To prepare a group of settings, it is necessary to assign random split-groups for variants, as well as to calculate the test score and the intersection with other tests. <br><br><h3>  Options </h3><br>  In an amicable way, any test should have at least 2 options for comparison.  In most of the tests, the control version is used when we compare what was with what has become.  But if a new ‚Äúfeature‚Äù is launched, and it has 2 design options, then there will not be a control version, since  before it did not exist, so there is nothing to compare with.  Now the control variant cannot be deleted, but if it is not needed, then it can be set to 0%.  In the future, the interface is planned to change a little, but for now it is. <br><br>  It is important that there is no additional logic for the control variant (except for hit logging), so that it does not differ from the case when the test is inactive.  Otherwise, it turns out that this is not a control variant, but one of the tested ones. <br><br><h3>  Split user groups </h3><br>  Based on the requirements, the use of hashing the user ID plus salt is not suitable for dividing users, because  It does not allow you to quickly evaluate how users get into the options (the base will rather slowly calculate the hash with salt on the fly, and for each test it will recalculate the hashes for all users with different salt, which is obviously a rather expensive operation).  Also, hashing does not allow to achieve the maximum possible "non-interruption" of users between tests. <br><br>  We decided to use split-groups instead.  The idea is as follows: to issue new users (at registration) and already existing split-groups in the range from 1 to 2400 in a random way. <br><br>  The number of 2400 is convenient in that it is easy to divide it into pieces in 5% increments.  120 groups fall into each 5%.  And then these 120 groups are divided without remainder into 2, 3, 4, 5, 6, 8, 10, 12 variants.  7, 9 and 11 variants is an extremely rare case, we have not met, but if this is the case, then we can add the 2nd control variant and not take it into account in the statistics. <br><br>  For guest (unauthorized) users, the split-group on the web is placed in a ‚Äúcookie‚Äù and may well not coincide with the split-group of the user after login.  This was done specifically so that guest users could see the same version of the site in the same browser (for example, an authorization or registration form), regardless of which split-group the last logged in user had.  But now information about guest users is not uploaded to BI, therefore, when conducting such tests, the statistics are not complete.  Now we are in the process of finalizing this part. <br><br>  When adding options for a test, they are randomly assigned (according to percentages) split-groups.  Those.  if 10% of users are allotted to the option, then 240 random split-groups will correspond to it.  It is worth noting that in the development process we did not implement the possibility of dividing users into equal groups, but made an indication of the percentages for each option, while if one option changes the percentage, then it changes for all others.  Perhaps later we will make it possible to indicate the number of percentages for the test as a whole, and the split groups corresponding to this percentage will be divided equally between the options. <br><br><h3>  Test grade </h3><br>  For evaluation, we use the Exasol database (a recent <a href="https://habrahabr.ru/company/badoo/blog/271753/">article by</a> my <a href="https://habrahabr.ru/users/wildraid/" class="user_link">wildraid</a> colleague was about it), so information about tests and setting groups (including test options and their split-groups) is downloaded into it. <br><br>  In fact, split-groups are not issued in a completely random manner.  All tests that intersect with the current by date (but do not occupy 100% of split-groups) are extracted from the database.  Then, for these tests, based on the filter conditions (excluding split groups), a check is made through the Exasol database to see if there is a real intersection between them and the current test.  Of the really intersecting tests are occupied by split-groups.  Accordingly, when allocating split groups to the current test, first of all, there is a choice of free split groups, and only then - busy ones, if there are not enough free ones.  Further selected groups are distributed randomly by options.  This allows you to achieve the lowest possible intersection between tests while maintaining the homogeneity of the audience between the options, for example: <br><table><tbody><tr><th></th><th>  one </th><th>  2 </th><th>  3 </th><th>  four </th><th>  five </th><th>  6 </th><th>  7 </th><th>  eight </th><th>  9 </th><th>  ten </th></tr><tr><th>  Test1 </th><td>  A </td><td></td><td></td><td></td><td></td><td>  B </td><td></td><td>  B </td><td></td><td>  A </td></tr><tr><th>  Test2 </th><td></td><td>  A </td><td>  B </td><td></td><td>  A </td><td>  A </td><td></td><td></td><td>  B </td><td>  B </td></tr><tr><th></th><td>  - </td><td>  - </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><th>  Test </th><td></td><td></td><td></td><td>  A </td><td>  B </td><td></td><td>  B </td><td></td><td>  A </td><td></td></tr></tbody></table>  The first line shows the possible numbers of split groups (for clarity, I took only 10).  In the 2nd, 3rd and 5th lines, we see test variants and the corresponding split-groups.  In the 4th row of the table, the free split-groups are marked by pluses, and the minuses are occupied.  Suppose we have a test "Test", which intersects with the tests "Test1" and "Test2".  Suppose we need 4 split-groups for the ‚ÄúTest‚Äù test.  First of all, we choose free split-groups 4 and 7, then - randomly from those employed, for example, 5 and 9. After that, we mix and distribute by options.  Actually, the result is on the last row of the table - we have achieved the maximum ‚Äúnon-intersection‚Äù with other tests. <br><br>  After the split-groups are given out to variants, the intersections with other tests are calculated (what percentage of users intersects with which test). <br><br>  Next, we evaluate the test itself: how many users are included in which option, up to the user.  With the help of these figures, it is possible to understand whether it is worth conducting a test on these conditions, in order to achieve a <a href="http://tools.driveback.ru/sample-size.html">statistically significant result</a> , and whether overlapping tests can not give a distortion of the results. <br><br>  Here is the result of counting the test score and its intersections with other tests: <br><br><img src="https://habrastorage.org/files/5e0/fe3/093/5e0fe30931d240ed85f0715f8d74274c.png"><br><br>  * All figures are fictional, any connection with reality is random. <br><br>  Tests of the same type are highlighted in red.  This is done for clarity, because, for example, mobile tests are unlikely to affect the tests on the web. <br><br>  It is worth noting that the first implementation of the calculation of intersections was not very fast, and if at first the calculation was performed in seconds, then with an increase in the number of simultaneously running tests, it began to reach half an hour.  Several optimizations were carried out, now the counting of intersections is no more than one and a half minutes, and the full implementation of the counting of intersections and estimation is up to two minutes. <br><br><h3>  Test conditions </h3><br>  The UserSplit interface allows you to specify test conditions quite flexibly.  You can use the operators AND and OR, you can take the conditions in brackets.  Suppose we want the test to be available to all test users, as well as new users from Russia.  Then you can create such a filter: <br><br><img src="https://habrastorage.org/files/dd7/1df/5e7/dd71df5e7ee048d6b09f3da2e7904af0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Internal device and condition processing</b> <div class="spoiler_text">  The conditions shown in the screenshot are converted to JSON format: <br><br><pre><code class="javascript hljs">[ { <span class="hljs-string"><span class="hljs-string">"filter"</span></span>:<span class="hljs-string"><span class="hljs-string">"is_test_user"</span></span>, <span class="hljs-string"><span class="hljs-string">"operator"</span></span>:<span class="hljs-string"><span class="hljs-string">"eq"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>:<span class="hljs-string"><span class="hljs-string">"Yes"</span></span> }, <span class="hljs-string"><span class="hljs-string">"OR"</span></span>, [ { <span class="hljs-string"><span class="hljs-string">"filter"</span></span>:<span class="hljs-string"><span class="hljs-string">"country_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"operator"</span></span>:<span class="hljs-string"><span class="hljs-string">"in"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>:[<span class="hljs-string"><span class="hljs-string">"50"</span></span>] }, <span class="hljs-string"><span class="hljs-string">"AND"</span></span>, { <span class="hljs-string"><span class="hljs-string">"filter"</span></span>:<span class="hljs-string"><span class="hljs-string">"is_new_user"</span></span>, <span class="hljs-string"><span class="hljs-string">"operator"</span></span>:<span class="hljs-string"><span class="hljs-string">"eq"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span> } ] ]</code> </pre> <br>  For optimization, we do not handle all conditions.  For example: <br><br>  (A AND B) OR C <br><br>  If A is false, then condition B will not be processed and processing will immediately go to condition C. <br>  If A and B are true, then the condition C will not be processed and the total value will be true, i.e.  user is subject to filter conditions. <br></div></div><br>  All possible filters available in the interface are easy to verify conditions, i.e.  All data for these filters, as a rule, we already have in memory.  If not, they can be easily downloaded. <br><br>  There are also environment filters that show how and where the user came from.  For example, this is the user agent, the country in which the user is currently located (not to be confused with the country specified by the user in the profile) and the user's platform (Web, iOS, Android, etc.).  For guest users only environment-filters are available. <br><br><h3>  Change test conditions </h3><br>  We want to conduct many tests at the same time, but if we run tests in all countries at once, they will intersect and, possibly, influence each other.  To avoid this, tests can be run in different countries.  In this case, another problem may come out - the test may well show itself in one country and badly in others.  To prevent this from happening, the test conditions can be changed by adding more countries there.  Thus, we can get more reliable results and make the right decision.  As mentioned earlier, so that such test changes are not misleading when examining test reports, the report displays data for several test versions. <br><br><h2>  QA tools </h2><br>  For ease of development, testing and finding the causes of problems, QA tools have been made. <br><br><div class="spoiler">  <b class="spoiler_title">QA tools description</b> <div class="spoiler_text">  Sometimes it is quite difficult to make the user get under the test conditions.  It may be even more difficult with a split group, especially if a small percentage of users are used for the test.  And if a developer can do, say, a ‚Äúhack‚Äù in the code in order to see the desired test version, then a QA specialist is simply not allowed to do this.  Therefore, so-called QA tools were created for developers, for QA-specialists. <br><br>  QA tools consist of two tools: <br><br><ul><li>  add user to option; </li><li>  check which option falls into the user. </li></ul><br><h3>  Add user to option </h3><br>  You can add a user to the option by user ID or by device_id (convenient for guest users using mobile applications).  In this case, you can specify for which user ID you need to do this - from the production environment or development environment (devel checkbox). <br><br><img src="https://habrastorage.org/files/524/19e/313/52419e31389c42c58b11a546016f9efb.png"><br><br><h3>  Check user hit option </h3><br>  When checking a user for getting into the test version, you must specify a user ID or device_id, as well as environment-filter values, if necessary.  When clicking on the Check button, we will see which version of the test the user got, or the reason for which he did not get (the split-group did not fit, did not pass under the conditions, etc.). <br><br><img src="https://habrastorage.org/files/cca/673/527/cca673527b104a5c9741f9be5d5fffed.png"><br><br><h3>  Automated Testing </h3><br>  When conducting automated tests, as a rule, random users are taken from the pool.  It turns out that different users fall into different variants of split tests, because of what autotests break.  Therefore, a special API was made for automated tests, which allows you to specify which user falls into which option.  But this problem is not completely solved, because  new split tests are constantly appearing that make auto tests unstable.  We plan to make a method in the API that will disable all tests for the user.  Accordingly, if you need to check some version of the split test, then for such a user it will be possible to turn on any one split test after turning off all the others. <br></div></div><br><h2>  Test change log </h2><br><div class="spoiler">  <b class="spoiler_title">Test change log</b> <div class="spoiler_text">  To simplify the search for the causes of problems, all test changes are written to the database and displayed on the Changelog page: <br><br><img src="https://habrastorage.org/files/24f/18a/2c0/24f18a2c04b243fea19052c9145c1558.png"><br><br></div></div><br><h2>  Flow tests </h2><br>  Flow tests look like this: <br><br><img src="https://habrastorage.org/files/b29/215/88f/b2921588f5b64bee9d5a36ff63b3a696.png"><br><br>  When a test has just been created, it is in Draft status.  In this state, the product manager can ‚Äúplay‚Äù with him (see his assessment and intersections with other tests), while no one sees the test itself (except him and the super-users). <br><br>  After the test is ready, the product manager must publish it (Publish action) for developers.  Now the test goes to In Dev status.  In this status, the test date range is ignored and is available only to test users.  We track hits from production, and as soon as they start to arrive, test managers are notified that the test is ready and can be run. <br><br>  To run a test on real users, it must be transferred to the status of Running.  For a temporary shutdown - pause (Paused status). <br><br><h3>  End of tests </h3><br>  At the end of the test (Finish), you can take the resulting version and decide whether it will be applied everywhere (worldwide) or only according to the conditions of the test. <br>  You can also do Reject if you want to leave the old version.  At the same time, Reject is not the same as choosing the control variant, since  it may not be, and none of the choices did not suit. <br><br><img src="https://habrastorage.org/files/81f/7d4/28b/81f7d428bffc47fb9ac006df06fb225e.png"><br><br>  In the future, we plan to automatically set the task of ‚Äúcutting out‚Äù the test from the code after it is completed. <br><br><h2>  Test Layout </h2><br>  It is quite expensive to take information about tests from the database or any other repository, just to check which options for which tests are active for the user.  Therefore, we decided to store the test configuration on each server locally.  The PHP file with an array (a separate file for each test) was selected as the config format.  This choice allows you to spend a minimum of time processing the config by using the bytecode cache.  Tests are laid out simultaneously on all servers (development, test and production), so that it does not happen that, in the environment of development and on ‚Äúcombat‚Äù machines, something works differently.  For the layout, we use the same tools as for the other configs. <br><br>  Since  There are many servers, the layout does not take place instantly (about a couple of minutes), but for the problem being solved this is not critical.  Moreover, the development environment is pretty fast in the first place.  Those.  if you need to fix something, then the changes can be seen pretty quickly. <br><br>  Tests that need to be expanded are easy to notice - they are highlighted in red in the general list. <br><br><h2>  Statistics </h2><br>  As part of a split test, it is important to collect statistics.  Key KPI-indicators are already sent to BI with binding to the user, so most of the split tests do not need to send any additional statistics.  Suffice it to say that the user has got into one or another version of the test.  This action we have is sending a hit.  The main thing here is not to be confused with the fact that the user has done some kind of action that needs to be measured as part of the test.  For example, we have a green button and we want to check whether it will be clicked more often if we change its color to red.  It turns out that you need to send a hit at the moment of displaying a green (control version) or red (testing option) button.  In this case, it is assumed that clicks on the button are already sent to BI, and if this is not the case, then such sending must be added, otherwise we will not be able to evaluate the result of the experiment. <br><br><h2>  Software interface </h2><br>  For developers, the old A / B framework provided the following methods: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ,       \ABFramework\Utils::matchPercentage( $user_id, // ID ,   ( )   $from_percent, $to_percent, $salt //  ,   ,                  ); //  , ..   ,       \ABFrameworkAPI::addHit($user_id, $test_id, $experiment_id, $variation_id);</span></span></code> </pre><br>  It turns out that the implementation of all the logic of the A / B test fell on the shoulders of the developer.  And the logic includes the conditions of entry (in which countries, etc.) and what percentage of users should fall into one or another option.  In this case, the developer could easily make a mistake (due to carelessness or not understanding what audience homogeneity is). <br><br>  For example, we need to select all users from Russia and divide in half. <br>  Let's say the developer wrote the following code: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($country_id == \Country::RUSSIA &amp;&amp; \ABFramework\Utils::matchPercentage($user_id, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-string"><span class="hljs-string">'salt'</span></span>)) { $variation_id = <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::VARIATION_ID_TEST; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $variation_id = <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::VARIATION_ID_CONTROL; } \ABFrameworkAPI::addHit($user_id, <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::TEST_ID, <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::EXPERIMENT_ID, $variation_id);</code> </pre><br><img src="https://habrastorage.org/files/044/aaa/c44/044aaac444344d3fbb33d018a1473d27.png"><br><br>  Those.  The control version will get many more users, including users from another segment (other countries), which can lead to ambiguous results (users from other countries may behave differently). <br><br>  In the new version of the software interface, for consistency, a special namespace \ UserSplit \ Tests was allocated for classes with constants.  If the test does not have any additional logic, then you can use the class \ UserSplit \ Tests \ Common. <br><br>  Checking for a hit in the variant looks like this: <br><br><pre> <code class="php hljs">$Environment = \UserSplit\CheckerEnvironment::byGlobals(); <span class="hljs-comment"><span class="hljs-comment">//   environment-, .  $Checker = \UserSplit\SplitTests\Checker::getInstance(); // DI       ,  , ..         $variant = $Checker-&gt;getActiveVariant(\UserSplit\Tests\Common::MY_SPLIT_TEST_KEY, $User, $Environment); if ($variant === \UserSplit\Tests\Common::MY_SPLIT_TEST_VARIANT_TEST) { //   } else { //   }</span></span></code> </pre><br>  When calling the method \ UserSplit \ SplitTests \ Checker :: getActiveVariant (), the log is automatically logged.  It turns out that if there is no additional logic, then it will be impossible to unequally hit the hits, as in the old version. <br><br>  To disable automatic logging of hits, you need to pass the 4th parameter to false and do not forget to log the hit later: <br><br><pre> <code class="php hljs">$variant = $Checker-&gt;getActiveVariant(\UserSplit\Tests\Common::MY_SPLIT_TEST_KEY, $User, $Environment, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -  $Checker-&gt;logHit(\UserSplit\Tests\Common::MY_SPLIT_TEST_KEY, $variant, $User);</span></span></code> </pre><br>  This may be necessary, for example, when sending emails.  In this case, the user should hit the test only when he has read the letter (as a rule, there are ways to verify this). <br><br>  If there is any additional logic in determining whether the user is in the test version, then you need to create your own class.  It looks something like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UserSplit</span></span>\<span class="hljs-title"><span class="hljs-title">Tests</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySplitTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KEY = <span class="hljs-string"><span class="hljs-string">'my_split_test'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VARIANT_CONTROL = <span class="hljs-string"><span class="hljs-string">'control'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VARIANT_TEST = <span class="hljs-string"><span class="hljs-string">'test'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  } public function getActiveVariant(\User $User, $is_log_hit = false) { $Environment = \UserSplit\CheckerEnvironment::byGlobals(); $Checker = \UserSplit\SplitTests\Checker::getInstance(); $variant = $Checker-&gt;getActiveVariant(static::KEY, $User, $Environment, false); //  :           ,     if (!$variant) { return $variant; } if (!$this-&gt;checkSomeAdditinalCondition($User)) { return false; } if ($is_log_hit) { //  :           ,   $Checker-&gt;logHit(static::KEY, $variant, $User); } return $variant; } }</span></span></code> </pre><br>  Here you need to pay attention to the important points that are described in the comments.  Given that it is easy to make a mistake here, you need to use this approach only in exceptional cases.  There are two of them: <br><br><ul><li>  there is some difficult condition (for example, an additional request to the database), therefore, it would not be desirable to add it to the possible test conditions, but it is better to check it last; </li><li>  There is some unique condition that is unlikely to be needed in other tests. </li></ul><br><h2>  Client tests </h2><br>  Tests that do not need any additional server logic can be performed completely on the client (mobile application or JS in the browser).  For example, the color of the button can be tested completely on the client, especially since we now draw templates in JS, and not on the server.  For this, the implementation of the mobile API and the interaction with JS were refined (in fact, now the same API is used there).  It worked as follows: the client sent a list of supported tests (in the form of numbers - ID tests in the string format), and the server responded by sending a list of tests with active variants (in the same form).  Since  for new tests, we began to use test keys and option names, and it was easy to distinguish a number from a line, then for new tests we simply began to operate on them. <br><br>  There are also tests of mixed type (I call them client-server), where both on the server and on the client you need to know which option is active.  In this case, besides getting into the test, you need to check whether the client supports this test. <br><br>  There was a problem with the fact that we can‚Äôt just add a check for additional conditions in client and client-server tests.  Such a check can be automated by making such an interface: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UserSplit</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdditionalConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \User $User * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \UserSplit\CheckerEnvironment $Environment * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAdditionalConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\User $User, \UserSplit\CheckerEnvironment $Environment)</span></span></span></span>; }</code> </pre><br>  After checking the conditions, we do an additional check: if the test has a PHP class (a class that is in the \ UserSplit \ Tests namespace and has the same name as the test key, but in CamelCase) and it implements this interface, then we call checkAdditionalConditions () method.  If the result is false, then the user did not get into the test.  We have not had time to implement this idea yet, but we are going to. <br><br><h2>  User groups </h2><br>  In the billing team, the ‚Äúuser groups‚Äù tool was developed.  It was originally made to manage the availability of features for users. <br><br>  It was used as follows: for example, we have seasonal presents for Christmas, but it makes no sense to display them in Muslim countries, because  there it is not celebrated.  In this case, we can create a user group in which the list of countries where Christmas is celebrated will be registered, and check the user for entry into it before displaying Christmas gifts.  Accordingly, this user group can be changed (for example, add countries) via the web interface without attracting a developer.  It would be wrong to use split tests in this case, since  we do not need to compare options, we only need to enable the feature for a certain circle of users. <br><br>  But, in addition to the direct appointment, this tool was used for split testing.  For example, tests as an entity were absent there and were created in the form of several user groups representing options. <br><br>  In general, split-testing tools and user groups are quite similar, and keeping two similar tools is not very good.  Therefore, we decided to make user groups based on UserSplit, and to transfer user billing commands to UserSplit. <br><br>  The interface (both software and web) looks almost the same as the split test interface, but it is simplified due to the lack of options.  This is how the program interface looks like: <br><br><pre> <code class="php hljs">$Environment = \UserSplit\CheckerEnvironment::byGlobals(); <span class="hljs-comment"><span class="hljs-comment">//   environment-, .  $Checker = \UserSplit\UserGroups\Checker::getInstance(); // DI    ,   ,  , ..         $is_in_group = $Checker-&gt;isInGroup(\UserSplit\Groups\Common::MY_USER_GROUP_KEY, $User, $Environment); if ($is_in_group) { // ,     }</span></span></code> </pre><br><h2>  UserSplit Iterator </h2><br>  Sometimes it becomes necessary to go through all users that meet some conditions in order to perform an action.  For split tests and user groups a UserSplit Iterator has been made.  It allows you to create the correct SQL query in the database, including all the conditions of the test or group of users, and get only those users who fall into the test or user group. <br><br><h2>  Plans </h2><br>  In addition to the already voiced problems and plans, we have a couple more ideas: <br><br><ul><li>  testing tokens; </li><li>  preliminary schedules. </li></ul><br><h3>  Testing tokens </h3><br>  In one of the tests conducted tokens (texts), where we renamed one of the paid features, we got a good profit increase.  But such changes require a lot of developer resources.  Since  we have our own translation system of tokens, we decided to embed split testing in it, in order to attract a developer for this there was no need.  Now this feature is under development by the back office team. <br><br><h3>  Preliminary schedules </h3><br>  On the test page, it is planned to display a graph of how many users fall into which option, so that you can see if there is traffic on the test and how even it is between the options. <br><br><h2>  Result </h2><br>  The result was a fairly powerful tool that can still be developed.  It has been successfully used for six months.  About 40 tests have been conducted so far and about 30 have been launched.  On average, the check for user hit in tests is about 0.5 ms. <br>  If you have questions on this topic - feel free to ask them in the comments. <br><br>  And thanks to everyone who participated in the development of UserSplit! <br><br>  Rinat Ahmadeev, PHP developer. </div><p>Source: <a href="https://habr.com/ru/post/278089/">https://habr.com/ru/post/278089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278073/index.html">[ScanDoc] preprocessing scans</a></li>
<li><a href="../278075/index.html">How I reinvented dictionaries in Python</a></li>
<li><a href="../278083/index.html">Docker-compose switch to version 2</a></li>
<li><a href="../278085/index.html">Consul.io Part 1</a></li>
<li><a href="../278087/index.html">DIY: SQL JOIN in Java</a></li>
<li><a href="../278091/index.html">Funny tabs on MAC OS X or a story about that Tab View</a></li>
<li><a href="../278095/index.html">How board and various other games are balanced - a brief overview of the ways</a></li>
<li><a href="../278099/index.html">The digest of interesting materials for the mobile developer # 142 (February 24-28)</a></li>
<li><a href="../278101/index.html">Consul.io Part 2</a></li>
<li><a href="../278103/index.html">Integrating Webpack in Visual Studio 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>