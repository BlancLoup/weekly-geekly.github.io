<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>data.table: we squeeze out the maximum speed when working with data in the R language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under exclusive conditions, we present you the full version of an article from the Hacker magazine devoted to the development on R. Under the cat you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>data.table: we squeeze out the maximum speed when working with data in the R language</h1><div class="post__text post__text-html js-mediator-article"><p>  Under exclusive conditions, we present you the full version of an <a href="https://xakep.ru/2016/10/03/r-data-table-speed/">article</a> from the <a href="https://habrahabr.ru/company/xakep/">Hacker</a> magazine devoted to the development on R. Under the cat you will learn how to squeeze the maximum speed when working with tabular data in R. </p><br><img src="https://habrastorage.org/files/228/fb8/1cb/228fb81cb22548f7b62d3203d248183e.jpg"><a name="habracut"></a><br><p>  <em>Note: the author‚Äôs spelling and punctuation is preserved.</em> </p><br><p> What extra words?  You read the article about speed, so let's get to the point right away!  If you are working with a large amount of data in the project and more time is spent on transforming the tables than you would like, <code>data.table</code> will help solve this problem.  The article will be interesting to those who are already a little familiar with the R language, as well as to developers who actively use it, but have not yet discovered the <code>data.table</code> package. </p><br><h1 id="ustanavlivaem-pakety">  Install packages </h1><br><p>  Everything you need for our today's article can be installed using the appropriate functions: </p><br><pre> <code class="hljs cmake"> <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>.packages(<span class="hljs-string"><span class="hljs-string">"data.table"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>.packages(<span class="hljs-string"><span class="hljs-string">"dplyr"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>.packages(<span class="hljs-string"><span class="hljs-string">"readr"</span></span>)</code> </pre> <br><h1 id="r-atakuet">  R attacks </h1><br><p>  In recent years, the R language is deservedly gaining popularity in machine learning environments.  As a rule, to work with this subsection of artificial intelligence, it is necessary to load data from several sources, carry out transformations with them to obtain a training sample, create a model on its basis, and then use this model for predictions. </p><br><p>  In words, everything is simple, but in real life, many attempts are needed to form a ‚Äúgood‚Äù and sustainable model, most of which can be absolutely dead-end.  The R language helps to simplify the process of creating such a model, as it is an effective tool for analyzing tabular data.  To work with them in R there is a built-in data type of <code>data.frame</code> and a huge number of algorithms and models that actively use it.  In addition, the whole power of R is the ability to extend basic functionality with third-party packages.  At the time of writing, their number in the official repository reached <strong>8914</strong> . </p><br><p>  But as they say, there is no limit to perfection.  A large number of packages make it easier to work with the <code>data.frame</code> data type <code>data.frame</code> .  Usually their goal is to simplify the syntax for performing the most common tasks.  It is impossible not to recall the <code>dplyr</code> package, which has already become the de facto standard for working with <code>data.frame</code> , since due to it readability and usability of working with tables have increased significantly. </p><br><p>  Let's <code>data.frame</code> from theory to practice and create a <code>data.frame</code> <code>DF</code> with columns <code>a</code> , <code>b</code> and <code></code> . </p><br><pre> <code class="hljs haskell"> <span class="hljs-type"><span class="hljs-type">DF</span></span> &lt;- <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sample</span></span></span><span class="hljs-class">(1:10, 100, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">replace</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TRUE</span></span></span><span class="hljs-class">), #    1  10 b=sample(1:5, 100, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">replace</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TRUE</span></span></span><span class="hljs-class">), #    1  5 c=100:1) #   100  1</span></span></code> </pre> <br><p>  If we want: </p><br><ul><li>  select only columns <code>a</code> and <code></code> , </li><li>  filter the lines, where <code>a</code> = 2 and <code></code> &gt; 10, </li><li>  create a new column <code>a</code> , equal to the sum of <code>a</code> and <code></code> , </li><li>  write the result to the variable <code>DF2</code> , </li></ul><br><p>  The basic syntax on pure <code>data.frame</code> will be: </p><br><pre> <code class="hljs smalltalk"> <span class="hljs-type"><span class="hljs-type">DF2</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">DF</span></span>[<span class="hljs-type"><span class="hljs-type">DF</span></span><span class="hljs-string"><span class="hljs-string">$a</span></span> == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp; <span class="hljs-type"><span class="hljs-type">DF</span></span><span class="hljs-string"><span class="hljs-string">$c</span></span> &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, c(<span class="hljs-comment"><span class="hljs-comment">"a"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"c"</span></span>)] #     <span class="hljs-type"><span class="hljs-type">DF2</span></span><span class="hljs-string"><span class="hljs-string">$a</span></span>c &lt;- <span class="hljs-type"><span class="hljs-type">DF2</span></span><span class="hljs-string"><span class="hljs-string">$a</span></span> + <span class="hljs-type"><span class="hljs-type">DF2</span></span><span class="hljs-string"><span class="hljs-string">$c</span></span> #   </code> </pre> <br><p>  With <code>dplyr</code> everything is much <code>dplyr</code> : </p><br><pre> <code class="hljs mel"> library(dplyr) #   dplyr DF2 &lt;- DF %&gt;% <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(a, c) %&gt;% <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(a == <span class="hljs-number"><span class="hljs-number">2</span></span>, c &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) %&gt;% mutate(ac = a + c)</code> </pre> <br><p>  The same steps, but with comments: </p><br><pre> <code class="hljs mel"> DF2 &lt;- #  ,     DF2 DF %&gt;% #  DF    (%&gt;%) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(a, c) %&gt;% #   ¬´a¬ª  ¬´¬ª    (%&gt;%) <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(a == <span class="hljs-number"><span class="hljs-number">2</span></span>, c &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) %&gt;% #      (%&gt;%) mutate(ac = a + c) #   ¬´ac¬ª,   ¬´¬ª  ¬´¬ª</code> </pre> <br><p>  There is an alternative approach to working with tables - <code>data.table</code> .  Formally, <code>data.table</code> is also <code>data.frame</code> , and it can be used with existing functions and packages, which often do not know anything about <code>data.table</code> and work exclusively with <code>data.frame</code> .  This ‚Äúimproved‚Äù <code>data.frame</code> can perform many typical tasks several times faster than its progenitor.  There is a legitimate question: where is the catch?  This very ‚Äúambush‚Äù in <code>data.table</code> is its syntax, which is very different from the original.  Moreover, if <code>dplyr</code> makes the code easier to understand from the very first seconds of use, <code>data.table</code> turns the code into black magic, and <del>  only years of studying witch books </del>  A few days of practice with <code>data.table</code> will allow <code>data.table</code> to fully understand the idea of ‚Äã‚Äãa new syntax and the principle of simplifying code. </p><br><h1 id="probuem-datatable">  We try data.table </h1><br><p>  To work with <code>data.table</code> you need to connect its package. </p><br><pre> <code class="hljs haskell"> library(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table) #  </span></span></code> </pre> <br><p>  In further examples, these calls will be omitted and it will be assumed that the package is already loaded. </p><br><p>  Since data is very often loaded from CSV files, <code>data.table</code> can be surprising at this stage.  In order to show more measurable estimates, take some fairly large CSV file.  As an example, one can cite data from one of the last competitions on <a href="https://www.kaggle.com/c/facebook-v-predicting-check-ins/data">Kaggle</a> .  There you will find a 1.27 GB <a href="">training CSV file</a> .  The file structure is very simple: </p><br><ul><li>  <code>row_id</code> - event identifier; </li><li>  <code>x</code> , <code>y</code> - coordinates; </li><li>  <code>accuracy</code> - accuracy; </li><li>  <code>time</code> - time; </li><li>  <code>place_id</code> is the organization identifier. </li></ul><br><p>  Let's try to use the basic R - <code>read.csv</code> and measure the time it <code>read.csv</code> to download this file (for this we turn to the <code>system.time</code> function): </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time( train_DF &lt;- <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>.csv("train.csv") )</code> </pre> <br><p>  Runtime - 461.349 seconds.  Enough to go for coffee ... Even if you don‚Äôt want to use <code>data.table</code> in the future, still try to use the built-in CSV reading functions less often.  There is a good <code>readr</code> library, where everything is implemented much more efficiently than in basic functions.  Let's look at her work on the example and connect the package. </p><br><pre> <code class="hljs lisp"> library(<span class="hljs-name"><span class="hljs-name">readr</span></span>)</code> </pre> <br><p>  Next, we use the function of loading data from CSV: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time( train_DF &lt;- read_csv("train.csv") )</code> </pre> <br><p>  Runtime - 38.067 seconds - much faster than the previous result!  Let's see what data.table is capable of: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time( train_DT &lt;- fread("train.csv") )</code> </pre> <br><p>  The execution time is 20.906 seconds, which is almost two times faster than in <code>readr</code> , and twenty times faster than in the base method. </p><br><p>  In our example, the difference in download speed for different methods was quite large.  Inside each of the methods used, the time linearly depends on the file size, but the difference in speed between these methods strongly depends on the file structure (number and types of columns).  Below are the test measurements of file download times. </p><br><p>  For a file of three text columns, you can see a clear advantage of <code>fread</code> : </p><br><p><img src="https://habrastorage.org/files/c91/7d5/7d0/c917d57d087f44a2a0a6e332353d9182.png" alt="image"></p><br><p>  If, however, not textual, but digital columns are read, the difference between <code>fread</code> and <code>read_csv</code> less noticeable: </p><br><p><img src="https://habrastorage.org/files/77d/43c/03f/77d43c03f110431fb3b8b2f3ed065ea5.png" alt="image"></p><br><p>  If after loading data from a file you are going to continue to work with <code>data.table</code> , then <code>fread</code> returns it immediately.  With other ways of loading data, it will be necessary to make <code>data.table</code> from <code>data.frame</code> , although it is simple: </p><br><pre> <code class="hljs haskell"> train_DF #  <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame train_DT &lt;- </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">train_DF</span></span></span><span class="hljs-class">) # </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table   `</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame`</span></span></code> </pre> <br><p>  Most speed optimizations in <code>data.table</code> achieved by working with objects by reference, additional copies of objects are not created in memory, which means time and resources are saved. </p><br><p>  For example, the same task to create <code>data.table</code> from <code>data.frame</code> could be solved by one command to ‚Äúpump up‚Äù, but we must remember that the initial value of the variable will be lost. </p><br><pre> <code class="hljs haskell"> train_DF #  <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame setDT(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">train_DF</span></span></span><span class="hljs-class">) #    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DF</span></span></span><span class="hljs-class">     </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table</span></span></code> </pre> <br><p>  So, we downloaded the data, it's time to work with them.  We assume that the variable <code>DT</code> already has a loaded <code>data.table</code> .  The authors of the package use the following designation of the main <code>DT[i, j, by]</code> blocks: </p><br><ul><li>  i - row filter; </li><li>  j is the choice of columns or the execution of an expression over the contents of <code>DT</code> ; </li><li>  by - block for grouping data. </li></ul><br><p>  Let us recall the very first example where we used the <code>data.frame</code> <code>DF</code> , and on it we will test various blocks.  Start by creating a <code>data.table</code> from <code>data.frame</code> : </p><br><pre> <code class="hljs haskell"> <span class="hljs-type"><span class="hljs-type">DT</span></span> &lt;- <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DF</span></span></span><span class="hljs-class">) #   </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.table   </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame</span></span></code> </pre> <br><h2 id="blok-i--filtr-strok">  Block i - row filter </h2><br><p>  This is the most understandable of the blocks.  It serves to filter the <code>data.table</code> rows, and if nothing else is required, you can leave out the remaining blocks. </p><br><pre> <code class="hljs sql"> DT[a == 2] <span class="hljs-comment"><span class="hljs-comment">#    a == 2 DT[a == 2 &amp; c &gt; 10] #    a == 2  c &gt; 10</span></span></code> </pre> <br><h2 id="blok-j--vybor-kolonok-ili-vypolnenie-vyrazheniya-nad-soderzhimym-datatable">  Block j - the choice of columns or the execution of an expression on the contents of data.table </h2><br><p>  This block processes the contents of <code>data.table</code> with filtered rows.  You can simply ask to return the necessary columns by specifying them in the <code>list</code> .  For convenience, the synonym <code>list</code> introduced in the form of a point (that is, <code>list (a, b)</code> equivalent to <code>.(a, b)</code> ).  All existing columns in <code>data.table</code> are available as ‚Äúvariables‚Äù - you do not need to work with them as with rows, and you can use intellisense. </p><br><pre> <code class="hljs php"> DT[, <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(a, c)] <span class="hljs-comment"><span class="hljs-comment">#   ¬´¬ª  ¬´¬ª    DT[, .(a, c)] #  </span></span></code> </pre> <br><p>  You can also specify the additional columns you want to create and assign the required values ‚Äã‚Äãto them: </p><br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">DT</span></span>[, .(a, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, ac = a+<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>)]</code> </pre> <br><p>  If all this is combined, you can perform the first task, which we tried to solve in different ways: </p><br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">DT2</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">DT</span></span>[a == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, .(a, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, ac = a + <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>),]</code> </pre> <br><p>  The choice of columns is only a part of the j block capabilities.  Also there you can change the existing <code>data.table</code> .  For example, if we want to add a new column in an existing <code>data.table</code> , and not in a new copy (as in the previous example), this can be done using the special syntax <code>:=</code> . </p><br><pre> <code class="hljs objectivec"> DT2[, ac_mult2 := ac * <span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-meta"><span class="hljs-meta">#   DT2   ac_mult2 = ac * 2</span></span></code> </pre> <br><p>  Using the same operator, you can delete columns by assigning them to <code>NULL</code> . </p><br><pre> <code class="hljs objectivec"> DT2[, ac_mult2 := <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>] <span class="hljs-meta"><span class="hljs-meta">#   DT2  ac_mult2</span></span></code> </pre> <br><p>  Working with resources on the link is great, it saves power, and it is much faster, since we avoid creating a copy of the same tables with different columns.  But we must understand that the change by reference changes the object itself.  If you need a copy of this data in another variable, then you must explicitly indicate that it is a separate copy, and not a link to the same object. </p><br><p>  Consider an example: </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">DT3</span></span> &lt;- DT2 DT3[, ac_mult2 := ac * <span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre> <br><p>  It may seem that we have changed only <code>DT3</code> , but <code>DT2</code> and <code>DT3</code> are one object, and, turning to <code>DT2</code> , we will see a new column there.  This concerns not only the deletion and creation of columns, since <code>data.table</code> uses references, including sorting.  So the call to <code>setorder(DT3, "a")</code> will also affect <code>DT2</code> . </p><br><p>  To create a copy, you can use the function: </p><br><pre> <code class="hljs objectivec"> DT3 &lt;- <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(DT2) DT3[, ac_mult2 := <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]</code> </pre> <br><p>  Now <code>DT2</code> and <code>DT3</code> are different objects, and we deleted the column from <code>DT3</code> . </p><br><h2 id="by--blok-dlya-gruppirovki-dannyh">  by - block for grouping data </h2><br><p>  This block groups data like <code>group_by</code> from the <code>dplyr</code> or <code>GROUP BY</code> package in the SQL query language.  The logic for accessing <code>data.table</code> with grouping is as follows: </p><br><ol><li>  The i block filters rows from the full <code>data.table</code> . </li><li>  The by block groups the data filtered in block i by the required fields. </li><li>  For each group, block j is executed, which can either select or update data. </li></ol><br><p>  The block is filled in the following way: <code>by=list(  )</code> , but, as in block j, <code>list</code> can be replaced by a point, that is, <code>by=list(a, b)</code> equivalent to <code>by=.(a, b)</code> .  If you need to group only one field, you can omit the use of the list and write directly <code>by=a</code> : </p><br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">DT</span></span>[,.(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>)), by=.(a,b)] #    ¬´a¬ª  ¬´b¬ª    ¬´<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>¬ª  ¬´¬ª <span class="hljs-type"><span class="hljs-type">DT</span></span>[,.(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>)), by=a] #    ¬´a¬ª    ¬´<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>¬ª  ¬´¬ª</code> </pre> <br><p>  The most common mistake of those who learn to work with <code>data.table</code> is the use of the usual <code>data.frame</code> constructs for <code>data.table</code> .  This is a very sore point, and you can spend a lot of time searching for errors.  If we have exactly the same data in the <code>DF2</code> ( <code>data.frame</code> ) and <code>DT2</code> ( <code>data.table</code> ) variables, these calls will return completely different values: </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DF2</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1:5,1:2]</span></span> ## <span class="hljs-selector-tag"><span class="hljs-selector-tag">ac</span></span> ## 1 2 95 ## 2 2 94 ## 3 2 92 ## 4 2 80 ## 5 2 65 <span class="hljs-selector-tag"><span class="hljs-selector-tag">DT2</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1:5,1:2]</span></span> ## <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span> 1 2</code> </pre> <br><p>  The reason for this is very simple: </p><br><ul><li>  The <code>data.frame</code> logic is <code>data.frame</code> follows - <code>DF2[1:5,1:2]</code> means that you need to take the first five rows and return the values ‚Äã‚Äãof the first two columns for them; </li><li>  The <code>data.table</code> logic <code>data.table</code> different - <code>DT2[1:5,1:2]</code> means that you need to take the first five lines and transfer them to block j.  Block j will simply return <code>1</code> and <code>2</code> . </li></ul><br><p>  If you need to access <code>data.table</code> in the <code>data.frame</code> format, you must explicitly specify this using an additional parameter: </p><br><pre> <code class="hljs sql"> DT2[1:5,1:2, <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> = <span class="hljs-literal"><span class="hljs-literal">FALSE</span></span>] <span class="hljs-comment"><span class="hljs-comment">## ac ## 1: 2 95 ## 2: 2 94 ## 3: 2 92 ## 4: 2 80 ## 5: 2 65</span></span></code> </pre> <br><h1 id="skorost-vypolneniya">  Execution speed </h1><br><p>  Let's make sure that learning this syntax makes sense.  Let's go back to the example with a large CSV file.  <code>train_DF</code> loaded <code>data.frame</code> , and <code>train_DF</code> loaded into <code>train_DT</code> , respectively. </p><br><p>  In the example used, <code>place_id</code> is a long integer number ( <code>integer64</code> ), but only <code>fread</code> "guessed" this.  The rest of the methods loaded this field as a floating point number, and we will need to explicitly convert the <code>place_id</code> field inside <code>train_DF</code> to compare speeds. </p><br><pre> <code class="hljs mel"> install.packages(<span class="hljs-string"><span class="hljs-string">"bit64"</span></span>) #     integer64 library(bit64) train_DF$place_id &lt;- as.integer64(train_DF$place_id)</code> </pre> <br><p>  Suppose we have the task of <code>place_id</code> number of references to each <code>place_id</code> in the data. </p><br><p>  In <code>dplyr</code> with plain <code>data.frame</code> it took 13.751 seconds: </p><br><pre> <code class="hljs axapta"> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> &lt;- train_DF %&gt;% <span class="hljs-meta"><span class="hljs-meta">#   train_DF group_by(place_id) %&gt;% #   place_id summarise(length(place_id)) #     </span></span></code> </pre> <br><p>  At the same time, <code>data.table</code> does the same in 2.578 seconds: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time( count2 &lt;- train_DT[,.(.N), <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> = place_id] # .N -  ,      )</code> </pre> <br><p>  Let's complicate the task - for all <code>place_id</code> count the number, the median of <code>x</code> and <code>y</code> , and then sort by the number in the reverse order.  <code>data.frame</code> c <code>dplyr</code> it in 27.386 seconds: </p><br><pre> <code class="hljs swift"> system.time( <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &lt;- train_DF %&gt;% #  train_DF group_by(place_id) %&gt;% #   place_id summarise(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = length(place_id), #      mx = median(x), #   x   my = median(y)) %&gt;% #   y   arrange(-<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) #      <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> )</code> </pre> <br><p>  <code>data.table</code> managed much faster - 12.414 seconds: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time( count2 &lt;- train_DT[,.(count=.N, mx = median(x), my = median(y)), <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> = place_id][<span class="hljs-keyword"><span class="hljs-keyword">order</span></span>(-count)] )</code> </pre> <br><p>  Test run times for simple data grouping with <code>dplyr</code> and <code>data.table</code> : </p><br><p><img src="https://habrastorage.org/files/6a7/a9e/b7c/6a7a9eb7cd4d4acba976954e3e59db76.png" alt="image"></p><br><h1 id="vmesto-vyvodov">  Instead of conclusions </h1><br><p>  This is only a superficial description of the <code>data.table</code> functionality, but it‚Äôs enough to start using this package.  The <code>dtplyr</code> package is being <code>dtplyr</code> , which is positioned as a <code>dplyr</code> implementation for <code>data.table</code> , but so far it is still very young (version 0.0.1).  In any case, an understanding of the features of <code>data.table</code> work <code>data.table</code> necessary before using additional ‚Äúwrappers‚Äù. </p><br><h1 id="ob-avtore">  about the author </h1><br><p>  <a href="https://xakep.ru/author/stas-chistyakov/">Stanislav Chistyakov</a> is an expert on cloud technologies and machine learning. </p><br><h1 id="www-ot-avtora">  Www from author </h1><br><p>  I strongly advise reading the articles included in the package: </p><br><ul><li>  <a href="">Small review</a> </li><li>  <a href="https://rawgit.com/wiki/Rdatatable/data.table/vignettes/datatable-faq.html">Common Questions and Answers</a> </li></ul><br><h1 id="www-ot-zhurnala-haker">  Www from hacker magazine </h1><br><p>  The theme of the R language is not the first time raised in our journal.  Let's give you a couple of links to related articles: </p><br><ul><li>  <a href="https://xakep.ru/2015/07/23/data-analysis-r-part-1/">Data analysis using R. Part 1</a> </li><li>  <a href="https://xakep.ru/2015/04/20/195-learning-r-programming-language/">Studying R. Part 2: vectorization and visualization</a> </li><li>  <a href="https://xakep.ru/2016/11/22/loops-in-r/">We program in the R language: how to write cycles for processing large amounts of data</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/316032/">https://habr.com/ru/post/316032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316020/index.html">Promotion of mobile games in the Asian market. Interview with Ilya Salamatov, 101XP</a></li>
<li><a href="../316022/index.html">Autumn in indie game markets</a></li>
<li><a href="../316024/index.html">Beginner's Guide to VR Developers</a></li>
<li><a href="../316028/index.html">Lean Manufacturing at an Advertising Agency: Robotize the daily routine work of employees with AutoIt</a></li>
<li><a href="../316030/index.html">Universal Auto Designer</a></li>
<li><a href="../316036/index.html">On the impact of full-page writes</a></li>
<li><a href="../316038/index.html">News Yii 2. ‚Ññ1</a></li>
<li><a href="../316040/index.html">New survey ‚ÄúState of the Nation of Developers‚Äù by Vision Mobile</a></li>
<li><a href="../316046/index.html">Strange games</a></li>
<li><a href="../316048/index.html">How to open a startup in Berlin [infographics]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>