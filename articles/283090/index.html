<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quick object cloning in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cloning objects in JavaScript is quite a frequent operation. Unfortunately, JS does not provide fast native methods for solving this problem. 

 For e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quick object cloning in JavaScript</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d3d/7a2/837/d3d7a2837d6a75081dfa92a9edc96330.jpg" alt="clone" align="left">  Cloning objects in JavaScript is quite a frequent operation.  Unfortunately, JS does not provide fast native methods for solving this problem. <br><br>  For example, the popular Node.JS ORM Sequelize, which we use on the backend of our project, significantly loses performance on the prefetch of a large (1000+) number of rows, only on one <a href="">cloning</a> .  If at the same time, for example, in the business logic, use the <code>clone</code> method of the well-known <a href="https://lodash.com/docs">lodash</a> library - the performance drops tenfold. <br><br>  But, as it turned out, not everything is so bad and modern JS engines, such as, for example, the V8 JavaScript Engine, can successfully cope with this task, if properly used their architectural solutions.  Those wishing to learn how to clone 1 million objects in 30 ms - welcome under the cat, everyone else can immediately see the <b><a href="https://github.com/ivolovikov/fastest-clone">implementation</a></b> . <br><a name="habracut"></a><br>  I just want to make a reservation that they have already written a little on this topic.  A colleague with Habra even made the <i>node-v8-clone</i> native extension, but it is not built for the latest versions of the node, its scope is limited only by the backend, and its speed is lower than the proposed solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's figure out what wasted CPU time during cloning - these are the two main operations memory allocation and writing.  In general, their implementation for many JS-engines are similar, but then we will talk about V8, as the main for Node.js.  First of all, in order to understand what takes time, you need to understand what JavaScript objects are. <br><br><h3>  View JavaScript objects </h3><br>  JS is a very flexible programming language and its properties can be added on the fly, most JS engines use hash tables for their presentation - this gives the necessary flexibility, but slows down access to its properties, because  requires a dynamic hash search in the dictionary.  Therefore, in the pursuit of speed, the V8 optimization compiler can switch between two types of object representation ‚Äî dictionaries (hash tables) and hidden classes (fast, in-object properties) on the fly. <br><br>  V8, wherever possible, tries to use hidden classes to quickly access object properties, while hash tables are used to represent "complex" objects.  The hidden class in V8 is nothing more than a structure in memory that contains a table of object property descriptors, its size and references to the constructor and the prototype.  For example, consider the classic representation of a JS object: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; }</code> </pre><br>  If you execute <code>new Point(x, y)</code> , a new <code>Point</code> object will be created.  When V8 does this for the first time, it creates a base hidden class for <code>Point</code> , let's call it <code>C0</code> for example.  Since  no properties have been defined for the object yet, the hidden class <code>C0</code> empty. <br><img src="https://habrastorage.org/getpro/habr/post_images/412/8f8/143/4128f81438898df93a4bd52fe8ecc346.png" alt="C0"><br><br>  Executing the first expression in <code>Point</code> ( <code>this.x = x;</code> ) creates a new property <code>x</code> in the <code>Point</code> object.  With this, V8: <br><br><ul><li>  creates a new hidden class <code>C1</code> , based on <code>C0</code> , and adds to <code>C1</code> information that the object has one property <code>x</code> , the value of which is stored in the <code>0</code> (zero) offset of the <code>Point</code> object. </li><li>  updates the C0 transition record (a class transition) informing that if the <code>x</code> property is added to the object described by <code>C0</code> then the hidden class <code>C1</code> should be used instead of <code>C0</code> .  The hidden class of the <code>Point</code> object is set to <code>C1</code> . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/1f0/e36/597/1f0e36597379495ed7904108f5578b36.png" alt="C1"><br><br>  Executing the second expression in <code>Point</code> ( <code>this.y = y;</code> ) creates a new property <code>y</code> in the <code>Point</code> object.  With this, V8: <br><br><ul><li>  creates a new hidden class <code>C2</code> , based on <code>C1</code> , and adds to <code>C2</code> that the object also has a property <code>y</code> , the value of which is stored in the <code>1</code> (first) offset of the <code>Point</code> object. </li><li>  updates C1 with a transition record informing that if the <code>y</code> property is added to the object described by <code>C1</code> then the hidden class <code>C2</code> should be used instead of <code>C1</code> .  The hidden class of the <code>Point</code> object is set to <code>C2</code> . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/bdd/40d/216/bdd40d216c322fdf4bd77c625f9c11d3.png" alt="C2"><br><br>  Creating a hidden class each time a new property is added may not be effective, but because  for new instances of the same object, the hidden classes will be reused - V8 is trying to use them instead of dictionaries.  The mechanism of hidden classes helps to avoid dictionary search when accessing properties, and also allows you to use various class-based optimizations, including  <a href="https://en.wikipedia.org/wiki/Inline_caching">inline caching</a> . <br><br>  In this connection, the ideal object for the compiler will be an object - with a constructor in which the set of its properties is clearly defined, which does not change during execution.  Therefore, the most important optimization for speeding up access to the properties of objects during cloning is the correct description of its constructor.  The second important part is directly optimizing the read-write process itself, which will be discussed further. <br><br><h3>  Dynamic code generation </h3><br>  V8 compiles JavaScript code directly into machine code during the first execution, without intermediate code or interpreter.  Access to the properties of objects is optimized by inline cache, the machine instructions of which V8 can change right at run time. <br><br>  Consider reading the properties of an object, during the initial execution of the code, V8 determines its current hidden class and optimizes future references to it, predicting that in this section of the code objects will be with the same hidden class.  If V8 was able to predict correctly, then the property value is assigned (or obtained) by a single operation.  If, however, it was not possible to predict correctly, V8 modifies the code and removes the optimization. <br><br>  For example, take the JavaScript code that gets the <code>x</code> property of the <code>Point</code> object: <br><pre> <code class="javascript hljs">point.x</code> </pre><br>  V8 generates the following machine code for reading <code>x</code> : <br><pre> <code class="hljs pgsql"># ebx = the <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> cmp [ebx,&lt;hidden <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>&gt;],&lt;cached hidden <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>&gt; jne &lt;<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> miss&gt; mov eax,[ebx, &lt;cached x offset&gt;]</code> </pre><br>  If the hidden object class does not correspond to the cached one, the execution proceeds to the V8 code that handles the absence of the inline cache and modifies it.  If the classes correspond to what happens in most cases, the value of the <code>x</code> property is simply obtained in one operation. <br><br>  When processing multiple objects with the same hidden class, the same advantages are achieved as with most static languages.  The combination of using hidden classes to access the properties of objects and using the cache significantly increases the performance of JavaScript code.  It is these optimizations that we will use to speed up the cloning process. <br><br><h3>  Cloning </h3><br>  As we found out from the theory above, cloning will be the fastest if two conditions are met: <br><ul><li>  All object fields are described in the constructor - hidden classes are used instead of dictionary mode (hash tables) </li><li>  all fields for cloning are explicitly listed - assignment takes place in a single operation due to the use of inline cache </li></ul><br>  In other words, to quickly clone a <code>Point</code> object, we need to create a constructor that accepts an object of this type and creates a new one based on it: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = point.x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = point.y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clonedPoint = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Clone(point);</code> </pre><br>  In principle, and everything, if not one but - to write such constructors for all types of objects in the system is quite expensive, also, objects can have a complex nested structure.  In order to simplify the work with these optimizations, I have written a library that creates cloning constructors for the transferred object of any nesting. <br><br>  The principle of the library is very simple - it receives an object as input, generates a cloning constructor from its structure, which can later be used to clone objects of this type. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Clone = FastClone.factory(point); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clonedPoint = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Clone(point);</code> </pre><br>  The function is generated via eval and the operation is not cheap, so the performance advantage is achieved mainly if you need to re-clone objects with the same structure.  The results of the benchmarking benchmark for the Chromium browser 50.0.2661.102 Ubuntu 14.04 (64-bit) with benchmark.js: <br><table><tbody><tr><th>  library </th><th>  operations / sec. </th></tr><tr><td>  FastClone </td><td>  <b>16,927,673</b> </td></tr><tr><td>  Object.assign </td><td>  535 911 </td></tr><tr><td>  lodash </td><td>  66 313 </td></tr><tr><td>  Jquery </td><td>  62,164 </td></tr></tbody></table>  Test sources - <a href="https://jsfiddle.net/volovikov/thcu7tjv/25/">jsfiddle.net/volovikov/thcu7tjv/25</a> <br>  In general, we get the same results on a real system, cloning is accelerated 100 to 200 times on objects with a repeating structure. <br><br>  Thanks for attention! <br><br>  Library - <a href="https://github.com/ivolovikov/fastest-clone">github.com/ivolovikov/fastest-clone</a> <br><br>  Materials on the topic: <br>  <a href="http://jayconrod.com/posts/52/a-tour-of-v8-object-representation">jayconrod.com/posts/52/a-tour-of-v8-object-representation</a> <br>  <a href="https://developers.google.com/v8/design">developers.google.com/v8/design</a> </div><p>Source: <a href="https://habr.com/ru/post/283090/">https://habr.com/ru/post/283090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283074/index.html">Intel System Studio for Microcontrollers 2015: First Steps</a></li>
<li><a href="../283080/index.html">Do I need a development standard?</a></li>
<li><a href="../283082/index.html">My 1st WEB App</a></li>
<li><a href="../283084/index.html">Security Week 18: VirusTotal for justice, vulnerability in Android, leak of Slack tokens</a></li>
<li><a href="../283086/index.html">Full lazyload on node.js</a></li>
<li><a href="../283092/index.html">When we wrote the 100th API, we understood ...</a></li>
<li><a href="../283096/index.html">Talk about MVC and web application architecture</a></li>
<li><a href="../283100/index.html">The future is here: Will robots push out financial analysts from Wall Street</a></li>
<li><a href="../283102/index.html">Creating a continuous deployment system: the Instagram experience</a></li>
<li><a href="../283104/index.html">Various experiments with the reception and transmission of radio signals in the FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>