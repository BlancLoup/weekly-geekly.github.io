<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Iterable list</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The lock-free list is the basis of many interesting data structures, the simplest hash map , where the lock-free list is used as a collision list, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Iterable list</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/817/b38/f79/817b38f7937a41259c48998f2cb990a0.png" align="right">  The lock-free list is the basis of many interesting data structures, the simplest <a href="https://habrahabr.ru/post/250383/">hash map</a> , where the lock-free list is used as a collision list, the <a href="https://habrahabr.ru/post/250523/">split-ordered list</a> , built entirely on the list with the original splitting algorithm of the bucket, a multi-level <a href="https://habrahabr.ru/post/250815/">skip list</a> that is essentially hierarchical list of lists.  In the <a href="https://habrahabr.ru/post/314948/">previous</a> article, we made sure that you can give such an internal structure to a competitive container so that it supports thread-safe iterators in the dynamic world of lock-free containers.  As we found out, the main condition for the lock-free container to become iterable is the stability of the internal structure: nodes should not be physically deleted (delete).  In this case, the iterator is simply a (possibly composite) pointer to a node with the possibility of moving to the next (increment operator). <br><br>  Can this approach be extended to the lock-free list? .. Let's see ... <br><a name="habracut"></a><br>  A regular lock-free list has the following node structure: <br><br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;list_node*&gt; next_; T data_; };</code> </pre> <br>  In it, the data is incorporated directly into the node, therefore, deleting the key (data) results in the deletion of the entire node. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Separate the node and the data - let the node contain a pointer to the data that it carries: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;node*&gt; next_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;T*&gt; data_; };</code> </pre><br>  Then, to delete the key, it is enough to reset the <code>data_</code> field of the node.  As a result, our list will acquire the following internal structure: <br><br><img src="https://habrastorage.org/files/7ef/bbb/8bc/7efbbb8bc3fb44d4ad4097064c68aecb.png"><br><br>  Nodes are never deleted, so the list is iterable: the iterator is actually a pointer to the node: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> guarded_ptr&lt;T&gt; gp_; node* node_; T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gp_.ptr; } iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { <span class="hljs-comment"><span class="hljs-comment">//    ,   node_, //      } };</span></span></code> </pre><br>  The presence of <code>guarded_ptr</code> (which contains a pointer to data protected by a hazard pointer) is mandatory, since we cannot guarantee that another stream will not delete data for which the iterator is positioned.  It is possible to guarantee only that at the time of the iterator's transition to the <code>node_</code> it (the node) contained data.  The protected pointer ensures that while the iterator is on <code>node_</code> , its data will not be physically deleted (delete). <br><br>  Let's see in pictures how it works.  We start bypassing the list - the iterator is positioned on the first node with non-empty data: <br><br><img src="https://habrastorage.org/files/6db/137/097/6db13709787742f7ac3c5778ea8345af.png"><br><br>  Next, increment the iterator - it skips the nodes with empty data: <br><br><img src="https://habrastorage.org/files/bf2/d8f/2e4/bf2d8f2e4f3a450288a83011a6ba33aa.png"><br><br>  Even if some other thread deletes the data of the node where the iterator is positioned, the <code>guarded_ptr</code> iterator guarantees that the data will not be physically deleted while the iterator is on the node: <br><br><img src="https://habrastorage.org/files/1eb/c45/3fd/1ebc453fd21b45aa8f9b4a4ee1d1c02a.png"><br><br>  It is possible that the data will be removed from the list, and then other data will be assigned to the same <code>node_</code> .  In this case, the iterator is positioned on the node <code>node_</code> .  It would be strange if in this case <code>operator -&gt;()</code> iterator returned a pointer to <i>different</i> data.  <code>guarded_ptr</code> guarantees us the immutability of the data returned by the iterator, but does not at all prevent them from being changed by other threads: <br><br><img src="https://habrastorage.org/files/289/017/e2c/289017e2c913402d8d76264ca3e84ae8.png"><br><br>  As we see, the constructed iterable list supports thread-safe iterators and has a very simple operation of deleting a key (data), which is reduced simply to zeroing (using the CAS primitive) of the <code>data_</code> node field.  The <code>insert()</code> operation of adding new data is somewhat more complicated, since two cases are possible: <br><br>  - insert a new node between existing nodes of the list with non-empty data: <br><br><img src="https://habrastorage.org/files/c28/1a1/491/c281a1491802477aaa031cf9675e9fd0.png"><br><br>  This node insertion algorithm is already familiar to us from <a href="https://habrahabr.ru/post/250383/">one</a> of the previous articles. <br><br>  - setting the <code>data_</code> field to the empty <code>prev</code> node: <br><br><img src="https://habrastorage.org/files/f3f/a02/69b/f3fa0269b8614b3a854ea5a28d3282a9.png"><br><br>  This would end the article, if the second case - reusing empty <code>data_</code> - would not have thrown a couple of surprises. <br><br><h2>  First surprise </h2><br>  The first (naive) version of the insert in the iterable list looked like this: <br><br><img src="https://habrastorage.org/files/f7a/215/27d/f7a21527d39b48cda540415a1e7fc6ed.png"><br><br>  The <code>linear_search</code> function is an ordinary linear search in the list (well, not quite normal, we still have a competitive list, so we are provided with squats with atomic operations and hazard pointers), returns <code>true</code> if the key is found and <code>false</code> otherwise .  The out-parameter of the <code>pos</code> function (of type <code>insert_pos</code> ) is always filled.  The search stops as soon as the key of the not less sought <code>data</code> .  We are interested in inserting a search failure ‚Äî in this case, the <code>pos</code> will contain the insertion position.  The <code>pos.cur</code> node <code>pos.cur</code> always be non-empty (or it will point to the end of the list ‚Äî a dedicated <code>tail</code> node), but <code>pos.prev</code> ‚Äî the previous one for <code>pos.cur</code> ‚Äî may indicate an empty node ‚Äî this is the case we are particularly interested in.  The <code>prevData</code> and <code>curData</code> fields of the <code>prevData</code> structure are the <code>insert_pos</code> values ‚Äã‚Äãfor <code>prev</code> and <code>cur</code> respectively.  Note also that we do not need to protect pointers to the <code>prev</code> and <code>cur</code> hazard pointer nodes, since the nodes from our list are never deleted.  But the data can be deleted, so we protect them. <br><br>  So, the naive implementation simply checks: if the previous node is empty ( <code>pos.prevData == nullptr</code> ), then we try to write a link to the inserted data into it.  Since our list is competitive (moreover, until it is even lock-free, but we will fix it soon), we change the pointer <code>prev.data_</code> atomic CAS: if it is successful, it means that no other stream prevented us and we inserted new data to list. <br><br>  Here we have the first surprise.  Suppose thread A adds a key to the list: <code>linear_search()</code> executed, the insert_pos structure is initialized by the insert position, and the thread is ready to call <code>link()</code> , but then its time has passed and it <s>became a pumpkin and</s> was replaced by the operating system.  At this time, stream B is working with the list: <br><br><img src="https://habrastorage.org/files/18d/e3b/f52/18de3bf5265245a7af5433e594465016.png"><br><br>  At the time of the resumption of flow A, the list has changed beyond recognition, but from the point of view of the position found <code>pos</code> flow A, nothing has changed: <code>prev</code> was empty, so empty and remained.  Therefore, flow A will write data with key 30 to <code>prev</code> and successfully complete the insertion, thereby breaking the orderliness of the list. <br><br>  This is a kind of ABA-problem that cannot be solved by using hazard pointers, since the pointer <code>prev-&gt;data_</code> is <code>NULL</code> .  We have the right to link new data to an empty node only when the <code>prev</code> -&gt; <code>cur</code> bundle has not changed after the search;  moreover, the data of these nodes have not changed.  To solve this problem, use the <a href="https://habrahabr.ru/post/250383/">marked pointer</a> technique: the lower bit of the pointer to the node data will be used as a sign of ‚Äúinserting a new node‚Äù.  Moreover, it is necessary to mark both nodes ‚Äî <code>prev</code> and <code>cur</code> ‚Äî otherwise the other stream may delete data from <code>cur</code> and the list‚Äôs orderliness will again be broken (let's not forget that the <code>cur</code> node is always non-empty).  As a result, the node structure will change and the <code>link()</code> function of adding data will look like <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename T&gt; struct node { std::atomic&lt; node * &gt; next_; std::atomic&lt; marked_ptr&lt; T, <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; data_; }; <span class="hljs-type"><span class="hljs-type">bool</span></span> link( insert_pos&amp; pos, T&amp; data ) { //   prev  cur <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pos.cur-&gt;data_.CAS( marked_ptr(pos.curData, <span class="hljs-number"><span class="hljs-number">0</span></span>), marked_ptr(pos.curData, <span class="hljs-number"><span class="hljs-number">1</span></span>))) { //   ‚Äî -     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pos.prev-&gt;data_.CAS( marked_ptr(pos.prevData, <span class="hljs-number"><span class="hljs-number">0</span></span>), marked_ptr(pos.prevData, <span class="hljs-number"><span class="hljs-number">1</span></span>))) { //   ‚Äî    //     pos.cur-&gt;data_.store( marked_ptr(pos.curData, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } // ,   prev -&gt; cur   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pos.prev-&gt;next_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>() != pos.cur ) { // -   -   prev  cur pos.prev-&gt;data_.store( marked_ptr(pos.prevData, <span class="hljs-number"><span class="hljs-number">0</span></span>)); pos.cur-&gt;data_.store( marked_ptr( pos.curData, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } //   ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pos.prevData == nullptr ) { //       //  ,    store <span class="hljs-type"><span class="hljs-type">bool</span></span> ok = pos.prev-&gt;data_.CAS( marked_ptr( nullptr, <span class="hljs-number"><span class="hljs-number">1</span></span> ), marked_ptr( &amp;data, <span class="hljs-number"><span class="hljs-number">0</span></span> )); //    cur pos.cur-&gt;data_.store( marked_ptr( pos.curData, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    ‚Äî  Harris/Michael //    //        } }</code> </pre><br>  The introduction of the marked pointer also affects the data deletion function (which, as we recall, comes down to simply zeroing the <code>data_</code> field): now we have to zero only unmarked data, but this does not add to the complexity of the deletion procedure.  Search the list completely ignores our marker. <br><br>  As a result, the iterable list ceased to be lock-free: if the thread marked at least one of the nodes, and then was killed (there is nowhere to appear in the <code>link()</code> function), the lock-free condition is broken, as the node will remain marked forever and someday will lead to endless active waiting for a tag to be removed.  On the other hand, it is a <s>sinful</s> practice to kill streams while working, so I don‚Äôt see any particular risks here. <br><br><h2>  Surprise Two </h2><br>  Unfortunately, testing has shown that this is not a complete solution.  If a naive iterable list often showed a violation of data sorting and even in a debug build, then after introducing marked pointers, tests began to show a violation very rarely and only in a release build.  This is a signal that we have a very unpleasant problem, practically not reproduced in a reasonable time and can only be solved analytically. <br><br>  As the analysis showed, the problem is actually orthogonal to the first: <br><br><img src="https://habrastorage.org/files/972/8c8/add/9728c8addfd94f9b8a711eb7803e1b9f.png"><br><br>  As in the first case, stream A is pushed out before entering <code>link()</code> .  While A is waiting for it to be re-scheduled, other threads have time to <s>fool</s> over the list with a sequence of additions / deletions that do not violate the preconditions of the <code>link()</code> function of flow A, but lead to a violation of the list sortedness. <br><br>  The solution is to add another condition to <code>link()</code> : after we have marked the <code>prev</code> and <code>cur</code> nodes, between which we have to insert a new one (or use an empty <code>prev</code> ), we must check that the <i>insertion position has not changed</i> .  This can be checked in the only way - to find the node following the new data, and make sure that it is equal to <code>cur</code> : <br><br><pre> <code class="hljs ruby">bool link( insert_pos&amp; pos, T&amp; data ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   prev  cur /<span class="hljs-regexp"><span class="hljs-regexp">/ ...    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   prev -&gt; cur   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ...    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,      if ( find_next( data ) != pos.cur ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ oops!   ‚Ä¶ pos.prev-&gt;data_.store( marked_ptr(pos.prevData, 0)); pos.cur-&gt;data_.store( marked_ptr( pos.curData, 0)); return false; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ...    }</span></span></code> </pre><br>  Here, the auxiliary function <code>find_next()</code> searches for the node closest to <code>data</code> . <br><br><img src="https://habrastorage.org/files/9d6/ee4/aed/9d6ee4aed5e94084bf31931d6adb0f05.jpg" align="left"><br><h2>  Conclusion </h2><br>  Thus, an iterative competitive list can be built.  Search in it is lock-free, but the insertion and, as a result, the deletion of it is not lock-free.  Why is he needed? .. <br><br>  First, the presence of thread-safe iterators in some problems is important.  Secondly, this list is interesting in that the operation of deleting a key in it is much easier than inserting; it suffices to zero the pointer to the data at the node;  usually the removal is much harder, see <a href="https://habrahabr.ru/post/250383/">two-phase removal</a> from the classic lock-free list.  Finally, this task was for me personally a kind of challenge, since before that I considered the concept of iterators in principle impossible for competitive containers. <br><br>  I hope that this algorithm will be useful, for an implementation, see the <a href="https://github.com/khizmax/libcds">libcds</a> : MichaelSet / Map and SplitListSet / Map based on <code>IterableList</code> with support for thread-safe iterators. <br><br><div class="spoiler">  <b class="spoiler_title">Lock-free data structures</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br>  Basics: <br><br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/195948/">Atomicity and atomic primitives</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/196548/">Where did the memory barriers go from</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Memory model</a> </li></ul><br>  Inside: <br><br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/202190/">Memory management circuits</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/216013/">Stack evolution</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/219201/">Another treatise</a> </li><li>  <a href="http://habrahabr.ru/post/230349/">Queue dissection</a> </li><li>  <a href="http://habrahabr.ru/post/250383/">Concurrent maps: warm up</a> </li><li>  <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li>  <a href="https://habrahabr.ru/post/251267/">Concurent maps: trees</a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li>  <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br>  Outside: <br><br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/196834/">Introduction to libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/317882/">https://habr.com/ru/post/317882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317872/index.html">Does your code speak Russian?</a></li>
<li><a href="../317874/index.html">Storage System for Billions of Records with Key Access</a></li>
<li><a href="../317876/index.html">FPGA Debug Board - Frankenstein. Sounds and music</a></li>
<li><a href="../317878/index.html">VulnHub Analysis of tasks with CTF SkyDog: 2016 - Catch Me If You Can</a></li>
<li><a href="../317880/index.html">Why are we angry?</a></li>
<li><a href="../317884/index.html">Transaction Isolation Levels with PostgreSQL Examples</a></li>
<li><a href="../317886/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ241 (December 12 - 18, 2016)</a></li>
<li><a href="../317892/index.html">SwiftLint - clean and tidy iOS project</a></li>
<li><a href="../317894/index.html">Alameda, Bower and NPM integration in the CleverStyle Framework</a></li>
<li><a href="../317896/index.html">WPF - Floppy Pages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>