<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study the debugger, part three</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the debugger, how to use it and how it is implemented, after reading the first and second part of the article, you know. In the final part of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study the debugger, part three</h1><div class="post__text post__text-html js-mediator-article">  What is the debugger, how to use it and how it is implemented, after reading the <a href="http://habrahabr.ru/post/178007/">first</a> and <a href="http://habrahabr.ru/post/178159/">second part of the</a> article, you know.  In the final part of the article we will try to consider some methods of dealing with a debugger, based on knowledge of the principles of its operation.  I will not give a patterned set of anti-debugging techniques, good if you wish, all this can be found on the Internet, I will try to do it in a slightly different way, based on some abstract application that will extend the protection code from the simplest scheme to ... until you get bored :) <br><br>  Immediately make a reservation, in the confrontation application / debugger, the latter will always win :) <br>  But, only if they are used by a competent specialist, and it is practically useless to fight such specialists (well, unless of course you have at least the same qualifications). <br><br>  However, as practice shows, competent specialists do not engage in uninteresting tasks for them, leaving them at the mercy of novice reversers who have not yet bitten through their granite of science and can stumble upon some not obvious tricks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is something we will consider, only in a very simplified form. <br><a name="habracut"></a><br><br><h4>  Simplest ShareWare: </h4><br>  Imagine we have some software that we decided to sell.  For simplicity, let it be an ordinary VCL application from an empty form (well, well, if not empty, but with a picture for the whole face) and we want to sell it.  The first question that needs to be concerned is how to make our picture visible only to those who paid for it?  More precisely - how to distinguish between trial and legal users? <br><br>  The most obvious solution is the key.  A trial user does not know him, and a legal user who has paid for it with real money can activate a legal copy of the application and enjoy the picture. <br><br>  The key is so key. <br><br>  We create a new VCL application, throw a TImage on the form with a picture, we set Visible to False.  After that we place two TEdit on the form, the first for the username and the second for the activation code.  Well, two buttons - close the application and activate. <br><br>  Somehow like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/7f8/f9b/3e07f8f9b4be80ba523b8a9ac6f317ba.png" alt="image"><br><br>  After that, we write a "completely secret" activation code: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AppUserName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MagicSerialMask: int64 = $C5315E6121543992; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; SN: int64; RawSN: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SN := <span class="hljs-number"><span class="hljs-number">0</span></span>; Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(AppUserName) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Inc(SN, Word(AppUserName[I])); SN := SN * <span class="hljs-number"><span class="hljs-number">123456</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Sn := SN xor MagicSerialMask; RawSN := IntToHex(SN, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((I - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (I &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + RawSN[I] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := Result + RawSN[I]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnCheckSerialClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> edSerial.Text &lt;&gt; GenerateSerial(edAppUserName.Text) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Application.MessageBox(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, PChar(Application.Title), MB_OK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> MB_ICONERROR) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Image1.Visible := True; Label1.Visible := False; Label2.Visible := False; Label3.Visible := False; edAppUserName.Visible := False; edSerial.Visible := False; btnCancel.Visible := False; btnCheckSerial.Visible := False; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  The essence of the code is as follows: <br>  based on the username, the application generates a serial number and compares it with the entered user.  If everything is normal, then all the controls responsible for activation are removed and the picture is displayed, which the user was eager to see. <br><br>  Suppose this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec0/03f/e25/ec003fe25631010a35ca08b682c38d06.png" alt="image"><br><br>  (well ... the first thing I found :) <br><br>  After the manipulations made, ‚Äúthis‚Äù is published on various globular websites and sometimes even references are made to the programming forums in the topics like: ‚Äútest plz protection‚Äù. <br><br>  And what does this look like from a hacker? <br><br>  He takes a debugger (for simplicity, let's take the same Olly Debug) and sees this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a89/276/afb/a89276afb6bf079a744a464d143d98f1.png" alt="image"><br><br>  He doesn‚Äôt have an application code, but there is a characteristic mistake of novice ‚Äúdefenders‚Äù of the software - the conclusion of a dialogue about the wrong key. <br><br>  What does it give a cracker? <br>  He puts the BP on the call to MessageBoxA and running the application catches the call for this message, after which, by clicking on the ‚ÄúOK‚Äù button, he can return to the code in which the error is called, where, looking a little higher, he can determine the presence of a conditional transition, based on which is the challenge: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/078/6c4/7bc/0786c47bce769d61bcc70be93cfd657f.png" alt="image"><br><br>  In the picture, the program's decision point is highlighted with exclamation marks. <br>  All that is left for him to do is fix the JE instruction on the JMP, thus disabling the check of the serial code and ensuring a valid transition to the area of ‚Äã‚Äãcode that should be executed only when the application is activated. <br><br>  Somehow it is not clear, right? <br><br>  Well then, here's a picture for you from the Delphi debugger: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/321/ff6/07a321ff669141c9e1f06f97cafe1664.png" alt="image"><br><br>  Here, the code is more understandable for debugging, and its reading is more convenient due to the unwinding of addresses and bringing them into a readable form.  For example, it is now clearly visible that before going to the address 0x475729, at which the decision is made, the text from the TEdits is received and the GenerateSerial procedure is called. <br><br>  The hacker does not possess such information, and as can be seen in the previous image, he will have to analyze all the challenges in order to create a more or less comprehensible image for the analysis.  Well, the truth is, I‚Äôm exaggerating a bit here, in fact, the application map is built quite simply, with the availability of tools, but ... But some people sometimes try hard to debug the system modules of the delphi, and I‚Äôm honored and praised for their persistence :) <br><br>  Well, the nuance, at the address 0x475729 on the screen, there are two different instructions - JZ and JE, these are the nuances of the interpretation of disassemblers, they are identical. <br><br>  There is one interesting approach that I voiced several times. <br>  Here, a little higher, I announced that I would put BP on MessageBoxA, but they tell me that they will call MessageBoxW and will not be able to catch the call.  This is an application for a solid four-plus, for yes, indeed, if the application calls the Unicode API, there will be a slight miss with the bounce, but there is a nuance.  And let's deploy the entire MessageBox call stack. <br><br>  See what interesting scheme is obtained: <br>  MessageBoxA -&gt; MessageBoxExA -&gt; MessageBoxTimeOutA -&gt; MessageBoxTimeOutW-&gt; SoftModalMessageBox () <br><br>  So yes, we can put BP on calling any of the listed functions (usually enough MessageBoxTimeOutW) to catch the call we need, by the way, the MessageBoxW function will also call it. <br><br>  There is a true little nuance, in Delphi there are other ways to display a window. <br><br>  Well, for example ShowMessage ().  This method does not call the MessageBox API. <br>  It is fun enough to listen to the reasoning that this method is fully implemented as a separate form in which the buttons are placed as they need and in general are the insides of the VCL itself, of which nothing is clear in the debugger. <br>  So it is so, if the given call did not rest on the ShowWindow API, from which we will also exit the stack to the necessary part of the code. <br><br>  There are still calls to the dialogues, but with them there will be exactly the same kitchen.  All this is detected without much time. <br><br>  Therefore, make the first conclusion in your notebook: <br>  Calling a message about unsuccessful verification of the code, immediately after this check, is a sign of a bad tone. <br><br><h4>  Introduce application integrity monitoring: </h4><br>  Well, well - here we were hacked, and having made just a change in one single byte of the application.  Now our funny picture is available to everyone absolutely free. <br><br>  Sad but not critical - we will fight ... <br><br>  Hacking occurred through direct editing of the application body. <br>  So the task has grown: to ensure the integrity of the source code. <br><br>  It sounds menacing, but in reality it is practically impossible to do :) <br><br>  Here is what we can apply for this test? <br>  There are many clever words: hang a digital signature, verify with the image of the file on the disk, check the code section with the checksum.  Everything is empty - in the end, we still need to somehow get the current value of the application code in memory ... <br><br>  Well, well: we look at a digital signature.  She, firstly, paid.  Secondly, it is checked by calling the API of the WinVerifyTrust function, which is vulnerable to interception.  In the third, it is easily removed by regular means through ImageRemoveCertificate. <br><br>  So it's not an option that we have to check the image of the file on disk? <br>  Here, too, everything is sad.  See, we patch our executable file, we want to determine this by comparing it with the image on the disk and what we are doing - we get the path to the current file through the same ParamStr (0) (let's say) and then open the file along this path and start the check, but ... <br>  But at the stage of calling OpenFile / CreateFile, the hacker replaces the path in the corresponding parameter with the path to the original, unmodified image and all our checks go through the forest. <br><br>  There is another interesting point.  But your application can be stored on a disk and in an unchanged form.  There is such a thing as loaders.  Their essence is that they start the process and modify the application body directly in memory. <br><br>  For example, let's take our debugger from the previous article and use it to launch our application with a magic picture, and when we reach the entry point, execute the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> JmpOpcode: Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ExceptionRecord.ExceptionAddress = Pointer(FCore.DebugProcessData.EntryPoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> JmpOpcode := $EB; FCore.WriteData(Pointer($<span class="hljs-number"><span class="hljs-number">475729</span></span>), @JmpOpcode, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  The application on the disk will remain unchanged, but instead of the JE instruction, the direct transition will be performed due to the recorded JMP instruction.  Which is much more sad, because  in this case, the first two options for checking integrity are guaranteed not to work. <br><br>  There is a third option, checking the code sections directly in the application body. <br>  This is a resource-intensive variant and also does not always lead to success for the following reasons. <br><br>  First constants of checksums.  If they are stored in the body of the application, the hacker will change them to the correct ones.  (the second conclusion in your notebook is the constants of the CRC blocks of code in the application, there is a bad form). <br>  Secondly, in the second part of the article I talked about MBP - Memory Breakpoint.  This is an ideal mechanism for detecting code integrity checks (if you do not take into account the more competent HBP - Hardware BreakPoint). <br><br>  It works simply - if there is a suspicion that the current code segment is controlled by the protection mechanism, the MBP or NVR is hung on it in order to determine exactly where the code integrity check is located. <br>  If such a check is detected, it is also disabled by the patch. <br><br>  Well, we actually arrived at a stalemate: the subscriber is not a subscriber :) <br><br>  However‚Ä¶ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e1/1bb/d1d/0e11bbd1d52bb96d1da41c890ccb8568.gif" alt="image"><br><br>  Get out, of course you can, but ... <br>  But first, let's see how to implement the integrity check of the application code. <br><br>  More specifically, we want to protect the code that was at the very beginning from being modified.  To do this, we need to somehow find out its location in memory while the application is running. <br><br>  Tags our "everything". <br>  On the basis of tags, most of the mounted protectors work, so why should we invent another bike.  What is a label - in principle, it is so unloved by all the label used in goto (), about which only the laziest did not express their highly qualified "FI". <br>  But ... what is their opinion to us?  As I said, our tags are all :) <br><br>  The truth is, there is a nuance, the label is convenient to use when controlling a small part of the code inside the procedure (with cross-control - about it later), now we are interested in several procedures in the aggregate. <br><br>  For this label will not work, but empty procedures are quite suitable as labels, the address of which we can get from the integrity check code. <br><br>  Well, the whole procedure of calculating integrity is needed up to the heap, as well (which was actually one of the nuances voiced above) is a certain constant, with which we will check the CRC of the data block. <br><br>  Well, but enough to rant, we write: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CheckedCodeValidCheckSum: DWORD = <span class="hljs-number"><span class="hljs-number">248268</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;       procedure CheckedCodeBegin; begin end; function TForm1.CalcCheckSum(Addr: Pointer; Size: Integer): DWORD; var pCursor: PByte; I: Integer; Dumee: DWORD; begin Result := 0; pCursor := Addr; for I := 0 to Size - 1 do begin if pCursor^ &lt;&gt; 0 then Inc(Result, pCursor^) else Dec(Result); Inc(pCursor); end; end; procedure TForm1.CheckCodeProtect; var CheckedCodeBeginAddr, CheckedCodeEndAddr: Pointer; CurrentCheckSum: DWORD; begin //      CheckedCodeBeginAddr := @CheckedCodeBegin; //      CheckedCodeEndAddr := @CheckedCodeEnd; //        CurrentCheckSum := CalcCheckSum(CheckedCodeBeginAddr, Integer(CheckedCodeEndAddr) - Integer(CheckedCodeBeginAddr)); if CurrentCheckSum &lt;&gt; CheckedCodeValidCheckSum then begin MessageBox(Handle, '   .', PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, 0); end; end; function TForm1.GenerateSerial(const AppUserName: string): string; const MagicSerialMask: int64 = $C5315E6121543992; var I: Integer; SN: int64; RawSN: string; begin SN := 0; Result := ''; for I := 1 to Length(AppUserName) do begin Inc(SN, Word(AppUserName[I])); SN := SN * 123456; end; Sn := SN xor MagicSerialMask; RawSN := IntToHex(SN, 16); for I := 1 to 16 do if ((I - 1) mod 4 = 0) and (I &gt; 1) then Result := Result + '-' + RawSN[I] else Result := Result + RawSN[I]; end; procedure TForm1.btnCheckSerialClick(Sender: TObject); begin //    CheckCodeProtect; if edSerial.Text &lt;&gt; GenerateSerial(edAppUserName.Text) then ShowMessage('  ') else begin Image1.Visible := True; Label1.Visible := False; Label2.Visible := False; Label3.Visible := False; edAppUserName.Visible := False; edSerial.Visible := False; btnCancel.Visible := False; btnCheckSerial.Visible := False; end; end; procedure CheckedCodeEnd; begin end;</span></span></code> </pre><br>  What we have here: <br>  Two labels in the form of empty procedures CheckedCodeBegin and CheckedCodeEnd, the calculation of the "checksum" of data between these two labels, performed by the CheckCodeProtect procedure, and the checksum itself, taken out for the area of ‚Äã‚Äãthe code being checked and represented by the CheckedCodeValidCheckSum constant (do not pay attention to its value). <br><br>  In principle, nothing complicated at all, but let's analyze it, but what does this even give us? <br><br>  In fact, a lot, because: <br><ol><li>  This code detects the patch of the application body on the disk (because at startup it will already be with modified bytes). </li><li>  This code detects the application body patch by the loader (as described above). </li><li>  And this code detects ... remember the picture from the previous article? </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/3dc/6e7/f0f/3dc6e7f0fe617284fcf37e31c4cb1354.png" alt="image"><br><br>  Yes, yes, this is the Breakpoint set by the debugger.  And this code also detects it perfectly, because if you remember, the mechanism for installing BP is to modify the application body. <br><br>  Here is the third note in your notepad - BP detection is performed by checking the body of the code. <br><br>  True, unfortunately it is not so simple, in some cases this code will not work, but let's not hurry, we will get to that. <br><br>  Now to the sad, as I said, this check is easily detected.  For example, here is a screenshot from under the debugger, where it is interrupted immediately at the beginning of the test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/397/467/4de/3974674de49d6546bc199d88699a2e9e.png" alt="image"><br><br>  The asmcode of the checksum calculation procedure is highlighted in blue, the debugger was interrupted at the address 0x467069, just at the first attempt to read the protected area. <br>  Well, more precisely, here I was cheating a little, if the verification code were outside the scope of the area being checked, then the stop would occur on this instruction, and so, of course, I stopped at the very first ‚ÄúPUSH EBX‚Äù. <br><br>  But this is the lyrics, the question is different, and what to do now? <br><br>  Well, firstly, it's not so scary.  Only one single check of the integrity of the application code is implemented here.  Yes, it is easily detected.  Yes, it is also easily removed by the patch, but what prevents us from making several of them, cross-controlling each other?  Will they be removed?  Well, no question, add more, and what should we do? <br><br>  Once I was sent a product to analyze the protection of the application directly by the developers of the protection itself (sorry - no names).  After a quick scan of the VM initialization code, I almost immediately set the path to parse it, all I needed to do was pull out the crypt algorithm of small data blocks when calling a specific API function.  The problem was that as soon as I patched the only byte of the application, the checksum verification mechanism worked.  Naturally, I quickly snored it, but as it turned out, four different algorithms controlled the already stuffed code.  I started to patch them and what do you think?  For each patch, newer and newer pieces of code were understood to control the integrity of the code as an avalanche.  As a result, I just drowned in the volume of manual patches and had to write an automatic utility / debugger, which took almost a week of work, taking into account all the nuances.  And at the end I rested at the next level of the core of protection. <br>  However, this is no longer important, the meaning is important - if desired, it is possible to implement a decent headache for a cracker, even on a banal check of checksums. <br><br>  Well, now to reality. <br>  The hacker used MBP to detect the integrity check code. <br>  And now we remember how they work - correctly through the assignment of the page attribute PAGE_GUARD.  So, knowing the principles of the debugger, we can prevent this, simply remove this attribute and the debugger will stop responding to access to the allegedly controlled memory. <br>  The truth is, there is a nuance, we can do this by calling VirtualProtect, which is vulnerable, because the debugger can intercept it and deny its call.  But we have a reverse thread bolt for this, for example, you can do what is described in this article: <a href="http://habrahabr.ru/post/177625/">read</a> . <br><br>  True, let's do this, I will not consider the option of removing PAGE_GUARD in the demo application.  But do not worry, I will show another interesting way, but for this you need to consider a few more nuances, so a little later. <br><br>  Well, from now on, we believe that the application integrity control code is written in such a way that it cannot be cracked (in order to simplify) ... <br><br><h4>  Debugger detection </h4><br>  Well, now we have come to the conclusion that they want our form with a picture, and with the help of a debugger.  Of course, you need to learn how to detect it.  For now, let's focus on the IsDebuggerPresent function, this is enough for a start. <br><br>  Write the code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDebuggerPresent</span></span></span><span class="hljs-function">:</span></span> BOOL; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> kernel32; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsDebuggerPresent <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MessageBox(Handle, <span class="hljs-string"><span class="hljs-string">'    .'</span></span>, PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  It's very simple, if we are under the debugger, this function will return True. <br>  We assume that the code for checking the integrity of the application is so complicated in us that it cannot be patched and the challenge of this function is placed in a protected area. <br>  What would a hacker use in this case? <br><br>  There are only three options, taking into account the fact that the application body cannot be patched: <br><br><ol><li>  put BP on the call to this function, where to replace the result of its call. </li><li>  patch the code of this function so that it always returns False </li><li>  change the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v%3Dvs.85).aspx">Peb.BeingDebugged</a> variable in the address space of the process being debugged. </li></ol><br>  It is difficult to fight the third option (it is possible, but not necessary), but we‚Äôll look at the first two in more detail;  in the first, the application code patch is also produced when installing the BP with the 0xSS opcode. <br><br>  To begin with, let's add this code in the application being debugged to the FormCreate procedure: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> P: PCardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P := GetProcAddress(GetModuleHandle(kernel32), <span class="hljs-string"><span class="hljs-string">'IsDebuggerPresent'</span></span>); ShowMessage(IntToHex(P^, <span class="hljs-number"><span class="hljs-number">8</span></span>));</code> </pre><br>  It will show the first 4 bytes of the IsDebuggerPresent function. <br><br>  You cannot write such code here: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDebuggerPresent</span></span></span><span class="hljs-function">:</span></span> BOOL; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> kernel32; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> P: PCardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P := @IsDebuggerPresent; ShowMessage(IntToHex(P^, <span class="hljs-number"><span class="hljs-number">8</span></span>));</code> </pre><br>  For in the second version, we use a static function, and the address will indicate not the beginning of the function body, but the import table, where the adapter is in the form of JMP. <br><br>  Run the code and remember the value. <br><br>  Under each system, it will be different, in XP, for example, it will be the body of the original function, in the seven there will be an adapter to an analogue of the kernelbase.  I got the value 9090F3EB, which corresponds to the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6e/65f/e7b/a6e65fe7b1b08ed0740102bb9b27e24b.png" alt="image"><br><br>  And now let's take our debugger from the second part of the article, and in the OnBreakPoint method, we will patch the body of this function with this code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HideDebugger</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PachBuff: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte = ( $<span class="hljs-number"><span class="hljs-number">31</span></span>, $C0, <span class="hljs-comment"><span class="hljs-comment">// xor eax, eax $C3 // ret ); var Addr: Pointer; begin Addr := GetProcAddress(GetModuleHandle(kernel32), 'IsDebuggerPresent'); FCore.WriteData(Addr, @PachBuff[0], 3); end; procedure TTestDebugger.OnBreakPoint(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: Integer; var ReleaseBreakpoint: Boolean); var JmpOpcode: Byte; begin if ExceptionRecord.ExceptionAddress = Pointer(FCore.DebugProcessData.EntryPoint) then begin HideDebugger;</span></span></code> </pre><br><br>  Here the nuance, the address of the library kernel32.dll is the same for all applications, so the address of the IsDebuggerPresent function will be the same in the debugger and in the application being debugged. <br><br>  The meaning of the patch is to nab the EAX register, through which the result of the function is returned and the return to the code that calls the function. <br><br>  We start the debugger, it will launch our application and as a result of interfering with the process memory, the code in the FormCreate function will not detect the debugger.  True, now the code that reads the first 4 bytes of this function will not return us the number 9090F3EB, but the number 90C3C031, which corresponds to the opcodes of the patch. <br><br>  How can we determine that the body of this function is patched?  In principle, we can read the first 4 bytes of this function from the kernel32.dll file located on the disk, but in this case, when opening the library body, we can be replaced by the path to the same patched file and the check will say that everything is fine. <br><br>  But there is another way, rarely used in practice (I have met, if I am not mistaken, only 1 time) and it consists of the following. <br><br>  Since we cannot read the correct value from the disk, we can get it by reading the 4 bytes we need from the memory of some other process.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there is a small chance that this process is also under the debugger, and in this way the required function is intercepted in the same way, but very small. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we write the following code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDebuggerPresent</span></span></span><span class="hljs-function">:</span></span> BOOL; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> kernel32; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckIsDebugerPresent</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Snapshot: THandle; ProcessEntry: TProcessEntry32; ProcessHandle: THandle; pIsDebuggerPresent: PDWORD; OriginalBytes: DWORD; lpNumberOfBytesRead: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pIsDebuggerPresent := GetProcAddress(GetModuleHandle(kernel32), <span class="hljs-string"><span class="hljs-string">'IsDebuggerPresent'</span></span>); Snapshot := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Snapshot &lt;&gt; INVALID_HANDLE_VALUE <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ProcessEntry.dwSize := SizeOf(TProcessEntry32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Process32First(Snapshot, ProcessEntry) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ProcessEntry.th32ProcessID = GetCurrentProcessId <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; ProcessHandle := OpenProcess(PROCESS_ALL_ACCESS, False, ProcessEntry.th32ProcessID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ProcessHandle &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ReadProcessMemory(ProcessHandle, pIsDebuggerPresent, @OriginalBytes, <span class="hljs-number"><span class="hljs-number">4</span></span>, lpNumberOfBytesRead) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OriginalBytes &lt;&gt; pIsDebuggerPresent^ <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MessageBox(Handle, <span class="hljs-string"><span class="hljs-string">' IsDebuggerPresent .'</span></span>, PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsDebuggerPresent <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MessageBox(Handle, <span class="hljs-string"><span class="hljs-string">'    .'</span></span>, PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> CloseHandle(ProcessHandle); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Process32Next(Snapshot, ProcessEntry) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> CloseHandle(Snapshot); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckIsDebugerPresent; CheckCodeProtect; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>          TlHelp32    ,   . <br><br>       ‚Äî       API ,    ,    ,   . <br><br> ,       ,    IsDebuggerPresent  kernel32.dll        kernelbase.dll,      ,     . <br><br>                      .     ,   ,      . <br><br><h4>     . </h4><br>  ,       ,        ,                ? <br><br> ,        ,  ,  . <br><br>  ,    ,         CheckIsDebugerPresent,  -,       .          DebugActiveProcess,       DbgUiRemoteBreakin.       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will patch ourselves, or rather the body of the DbgUiRemoteBreakin function, adding to its beginning the transition to the address of the TerminateProcess function, so that as soon as the debugger is connected to the process, the process will immediately end. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We write the next block of code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TDbgUiRemoteBreakinPath = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> push0: Word; push: Byte; CurrProc: DWORD; moveax: byte; TerminateProcAddr: DWORD; calleax: Word; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlockDebugActiveProcess</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pDbgUiRemoteBreakin: Pointer; Path: TDbgUiRemoteBreakinPath; OldProtect: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pDbgUiRemoteBreakin := GetProcAddress(GetModuleHandle(<span class="hljs-string"><span class="hljs-string">'ntdll.dll'</span></span>), <span class="hljs-string"><span class="hljs-string">'DbgUiRemoteBreakin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pDbgUiRemoteBreakin = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Path.push0 := $<span class="hljs-number"><span class="hljs-number">006</span></span>A; Path.push := $<span class="hljs-number"><span class="hljs-number">68</span></span>; Path.CurrProc := $FFFFFFFF; Path.moveax := $B8; Path.TerminateProcAddr := DWORD(GetProcAddress(GetModuleHandle(kernel32), <span class="hljs-string"><span class="hljs-string">'TerminateProcess'</span></span>)); Path.calleax := $D0FF; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> VirtualProtect(pDbgUiRemoteBreakin, SizeOf(TDbgUiRemoteBreakinPath), PAGE_READWRITE, OldProtect) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Move(Path, pDbgUiRemoteBreakin^, SizeOf(TDbgUiRemoteBreakinPath)); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> VirtualProtect(pDbgUiRemoteBreakin, SizeOf(TDbgUiRemoteBreakinPath), OldProtect, OldProtect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> BlockDebugActiveProcess; CheckIsDebugerPresent; CheckCodeProtect; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>        DbgUiRemoteBreakin    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f85/b32/e57/f85b32e5711917e4d5cc57fb53e8b635.png" alt="image"><br><br>           TerminateProcess (   ),   uExitCode     hProcess,     DWORD(-1)   .    EAX    TerminateProcess    . <br><br>            ,       ‚Äî    CREATE_PROCESS_DEBUG_EVENT,                ,      ,  .. <br><br>     . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, this is not an armor-piercing option, because nothing will prevent re-patch the body of our application, returning the original code back before calling DebugActiveProcess. </font><font style="vertical-align: inherit;">(True, I have not seen this, but still ...)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memory Breakpoint bypass </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have already said, it is possible to determine the presence of mvr by checking the protection attribute of the page PAGE_GUARD. </font><font style="vertical-align: inherit;">This is done by calling the VirtualQuery function, or you can simply reassign attributes to the forehead by calling VirtualProtect.</font></font><br><br>          ReadProcessMemory.    ,           .    ,          PAGE_GUARD       ,    ,        EXCEPTION_GUARD_PAGE  .   ¬´  ¬ª.          ,                      .  ,   ,       Hardware Breakpoint  , /         . <br><br>    CalcCheckSum  : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcCheckSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Addr: Pointer; Size: Integer)</span></span></span><span class="hljs-function">:</span></span> DWORD; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pRealData, pCursor: PByte; I: Integer; Dumee: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pRealData := GetMemory(Size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ReadProcessMemory(GetCurrentProcess, Addr, pRealData, Size, Dumee); Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; pCursor := pRealData; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Size - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pCursor^ &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Inc(Result, pCursor^) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Dec(Result); Inc(pCursor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FreeMemory(pRealData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>          ,   ,    . <br><br><h4>    ? </h4><br>   ,        ,    . <br><br>         ,        ,   ,                . <br><br>  .        : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Path: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCore := TFWDebugerCore.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FCore.DebugNewProcess(Path, True) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RaiseLastOSError; FCore.OnCreateProcess := OnCreateProcess; FCore.OnLoadDll := OnLoadDll; FCore.OnDebugString := OnDebugString; FCore.OnBreakPoint := OnBreakPoint; FCore.OnHardwareBreakpoint := OnHardwareBreakpoint; FCore.OnUnknownBreakPoint := OnUnknownBreakPoint; FCore.OnUnknownException := OnUnknownException; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCore.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will skip the secondary handlers, they can be viewed in the source code of the example, in principle there is nothing new, everything has already been described in the last part of the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our first task is to somehow disable the detection of the debugger by the application. Since the application checks the integrity of IsDebuggerPresent, and the patch check cannot (according to the condition of the problem) we have only one option left - to change the value of the Peb.BeingDebugged parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's do this with the following code:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HideDebugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hProcess: THandle)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pProcBasicInfo: PROCESS_BASIC_INFORMATION; pPeb: PEB; ReturnLength: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NtQueryInformationProcess(hProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>, @pProcBasicInfo, SizeOf(PROCESS_BASIC_INFORMATION), @ReturnLength) &lt;&gt; STATUS_SUCCESS <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RaiseLastOSError; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ReadProcessMemory(hProcess, pProcBasicInfo.PebBaseAddress, @pPeb, SizeOf(PEB), ReturnLength) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RaiseLastOSError; pPeb.BeingDebugged := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> WriteProcessMemory(hProcess, pProcBasicInfo.PebBaseAddress, @pPeb, SizeOf(PEB), ReturnLength) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RaiseLastOSError; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is simple here, we get the address of the environment block of the process, change the BeingDebugged parameter and write everything back. Therefore, the IsDebuggerPresent function stops responding to the debugger. The declaration of the structures used can be viewed in the source code of the de-example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first stage was completed, now the second is to somehow force the application not to react to the incorrectly entered code and show us the picture in any case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's do this:</font></font><br><br>          (     ).     - .        JE,             if value then..else,             , ..    value    :  then  else. <br><br>  JE             ,       ZF.        .          JE          . <br><br>          JE, ..  ,       .      .         crackme.exe,       -     ,         ,    .           0467840. <br><br>   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ExceptionRecord.ExceptionAddress = Pointer(FCore.DebugProcessData.EntryPoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln; Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Process Entry Point found. Address: %p'</span></span>, [Pointer(FCore.DebugProcessData.EntryPoint)])); Writeln; HideDebugger(FCore.DebugProcessData.AttachedProcessHandle); FCore.SetHardwareBreakpoint(ThreadIndex, Pointer($<span class="hljs-number"><span class="hljs-number">467840</span></span>), hsByte, hmExecute, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'wait JE'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln; Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; BreakPoint at addr 0X%p - "%s"'</span></span>, [ExceptionRecord.ExceptionAddress, FCore.BreakpointItem(BreakPointIndex).Description])); Writeln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>            : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTestDebugger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHardwareBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: THWBPIndex; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ThreadData: TThreadData; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln; ThreadData := FCore.GetThreadData(ThreadIndex); Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Hardware BreakPoint at addr 0X%p - "%s"'</span></span>, [ExceptionRecord.ExceptionAddress, ThreadData.Breakpoint.Description[BreakPointIndex]])); FCore.SetFlag(ThreadIndex, EFLAGS_ZF, True); Writeln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that's all, you can run, enter any left value and enjoy the picture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result will be something like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c6/b3c/0ea/7c6b3c0ea6a19ec9a65f996d251d8b03.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So it usually happens, you think that you wrote armor-piercing protection, and then once it costs on your knee, well, not always of course, but it happens :)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detect Hardware BreakPoint: </font></font></h4><br>           ,   ,     ,        .         ,       . <br><br>     ,       GetThreadContext    DR7 (    ‚Äî   ), ,       API ,         . <br><br>    <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHardwareBreakPoint</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Context: TContext; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Context.ContextFlags := CONTEXT_DEBUG_REGISTERS; GetThreadContext(GetCurrentThread, Context); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Dr7 &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MessageBox(Handle, <span class="hljs-string"><span class="hljs-string">' HardwareBreaakPoint.'</span></span>, PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>   ,              _except_handler. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//    TSeh = packed record Esp, Ebp, SafeEip: DWORD; end; var seh: TSeh; function _except_handler(ExceptionRecord: PExceptionRecord; EstablisherFrame: Pointer; Context: PContext; DispatcherContext: Pointer): DWORD; cdecl; const ExceptionContinueExecution = 0; begin if Context^.Dr7 &lt;&gt; 0 then begin MessageBox(0, ' HardwareBreaakPoint.', PChar(Application.Title), MB_ICONERROR); TerminateProcess(GetCurrentProcess, 0); end; //     Context^.Eip := seh.SafeEip; Context^.Esp := seh.Esp; Context^.Ebp := seh.Ebp; //     Result := ExceptionContinueExecution; end; procedure TForm1.CheckHardwareBreakPoint2; asm //  SEH  push offset _except_handler xor eax, eax push fs:[eax] mov fs:[eax], esp //     lea eax, seh mov [eax], esp add eax, 4 mov [eax], ebp add eax, 4 lea ecx, @done mov [eax], ecx //   mov eax, [0] @done: //  SEH  xor eax, eax pop fs:[eax] add esp, 4 end;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way an interesting moment. </font><font style="vertical-align: inherit;">Pay attention to how much information comes to the exception handler. </font><font style="vertical-align: inherit;">All this information is not available to us in the except handler, which is why I so often call try..finally..except a wrapper around SEH :)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarizing </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you know several ways to deal with the debugger, but now you know how to counter them, but she and the article, so that you draw conclusions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can pick up the source code with examples from this link: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://rouse.drkb.ru/blog/dbg_part3.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And on this one can consider my task accomplished. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that I wanted to tell about a debugger, I told. </font><font style="vertical-align: inherit;">Initially, the truth was planned only one article, but you can see how much material finally came out :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the future I will talk about using the debugger, but it will be a completely different story. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬© Alexander (Rouse_) Bagel </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moscow, November 2012</font></font></div><p>Source: <a href="https://habr.com/ru/post/178183/">https://habr.com/ru/post/178183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178171/index.html">What do I expect from Windows Phone on the example of Lumia 920</a></li>
<li><a href="../178173/index.html">On the Internet earned Gospoisk. Senseless and merciless</a></li>
<li><a href="../178177/index.html">Unchanging F # queue</a></li>
<li><a href="../178179/index.html">MacBANG magazine!</a></li>
<li><a href="../178181/index.html">New NemoMobile image with UI MeeGo Harmattan</a></li>
<li><a href="../178185/index.html">VDS lineup update!</a></li>
<li><a href="../178189/index.html">Easy way to detect Guardant dongle emulators</a></li>
<li><a href="../178191/index.html">Kickstarter + Flattr + Open Source = perhaps the best software support we can have</a></li>
<li><a href="../178193/index.html">How to hold a two-day online developer conference for $ 10?</a></li>
<li><a href="../178195/index.html">Hack Skype? Easy!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>