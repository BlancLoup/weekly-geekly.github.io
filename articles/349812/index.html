<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Segregated Witness for Dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bitcoin scalability is one of its main problems, which is being actively addressed. One of the representatives of these solutions is, for example, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Segregated Witness for Dummies</h1><div class="post__text post__text-html js-mediator-article"><p>  Bitcoin scalability is one of its main problems, which is being actively addressed.  One of the representatives of these solutions is, for example, the Lightning network technology, but its implementation is not yet possible due to some vulnerabilities.  Another solution - Segregated Witness is also aimed at increasing scalability, but it also solves a number of problems, including the very vulnerability that hinders the implementation of lightning.  In this article we will look at the main benefits of Segregated Witness, and also describe the mechanism of its work. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cef/3c1/12f/cef3c112fcb2af2149be060dff03f165.jpg" alt="img"></p><a name="habracut"></a><br><p>  Segregated witness, or as many call it SegWit, is a soft fork, described in the BIP series (141, 142, 143, 144 and 145), the main goal of which is to optimize the structure of transactions and blocks by making signatures (what call ' <em>scriptSig</em> ', ' <em>witness</em> ' or ' <em>unlocking script</em> ') from a transaction to a separate structure.  This not only reduces the size of transactions, makes the blocks more capacious, but also solves the problem of their ‚Äúvariability‚Äù ( <a href="https://en.bitcoin.it/wiki/Transaction_malleability"><em>transaction malleability</em></a> , we discussed this vulnerability above), which is very important for technologies like payment channels or lightning relying on the structure of the transaction bitcoin </p><br><h2 id="how-it-works">  How it works </h2><br><h3 id="before-we-begin">  Before we begin </h3><br><p>  To begin with, let's briefly recall what the payment system in Bitcoin is.  There is nothing in it like a list of balances as it can be implemented in any bank.  Instead, the balance of each address is represented by a set of transactions sent to this address, where the transaction is a structure in which the inputs (inputs) and outputs (outputs) are the main ones.  Inputs are transactions that we refer to to spend (more precisely, they are not transactions in full, but their specific outputs, because in one transaction we can transfer funds to several addresses), and outputs are addresses to which we We want to transfer funds.  This is the structure of a Bitcoin transaction: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b3c/d2f/5fe/b3cd2f5fe1a0e4cc0745341da53cd301.png" alt="Similar image"></p><br><p>  The PubKey script field (hereinafter <em>scriptPubKey</em> ) in the outputs is what is called the <em>locking script</em> .  It is necessary so that only the owner of the address to which the funds are listed can take advantage of this exit.  The Signature Script field (hereinafter <em>scriptSig</em> ) is also called <em>unlocking script</em> - it unlocks the locking script, providing proof of ownership of the address. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/a6b/ccf/666a6bccf3bf87c119ca7f9a86099425.gif" alt="img"></p><br><p>  More information about transactions, as well as the work of the locking and unlocking script can be read <a href="https://habrahabr.ru/post/319860/">here</a> . </p><br><h3 id="backward-compability">  Backward compability </h3><br><p>  In fact, Segregated Witness changes not only the structure of the transaction, but also its outputs.  This, however, does not mean that in the same transaction both traditional UTXO (unspent transaction outputs) and Segwit ones cannot be spent - just the first ones will expect "proof" inside the input (the scriptSig field), and the second - outside. </p><br><p>  Since Segregated Witness is still a software fork, its updates can be ignored, which means that older systems should somehow handle the Segwit outputs.  The fact is that for old nodes or wallets, these exits look like accessible to everyone, that is, they can be spent with an empty signature, which is still valid.  Accepted update nodes and wallets will certainly look for all the signatures outside the entrances in a special field 'witness'. </p><br><h3 id="examples">  Examples </h3><br><h4 id="pay-to-witness-public-key-hash">  Pay-to-Witness-Public-Key-Hash </h4><br><p>  Now let's take a look at sample transactions and how they will change with Segregated Witness.  We will start with a standard Pay-to-Public-Key-Hash (P2PKH) transaction. </p><br><p>  We are interested in exits, namely their "scriptPubKey" fields.  Consider a typical locking script: </p><br><pre><code class="hljs xml">OP_DUP OP_HASH160 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PubKeyHash</span></span></span><span class="hljs-tag">&gt;</span></span> OP_EQUALVERIFY OP_CHECKSIG</code> </pre> <br><p>  With Segregated Witness, it will look like this: </p><br><pre> <code class="hljs xml">0 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PubKeyHash</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  As you can see, the Segvit exit is much simpler than the traditional one - it consists of two values ‚Äã‚Äãthat will be placed on the stack of the script execution.  As we mentioned earlier, for older versions of the Bitcoin client, this output will be visible as accessible to anyone, since it does not require a signature.  But for the updated client, the first number is interpreted as a version number, and the second as an analogue of the locking script (witness program).  In fact, the compressed public key hash should be used here, we will tell about it a little later. </p><br><p>  Now let's look at the transaction in which this output will be spent.  In the traditional case, it would look like this: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">...</span></span>] <span class="hljs-string"><span class="hljs-string">"Vin"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"txid"</span></span>: <span class="hljs-string"><span class="hljs-string">"8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011"</span></span>, <span class="hljs-string"><span class="hljs-string">"vout"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptSig"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;our scriptSig&gt;"</span></span> } ] [...]</code> </pre> <br><p>  However, to spend the Segvit exit, a transaction must have an empty sriptSig field and contain all the signatures in a separate place: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">...</span></span>] <span class="hljs-string"><span class="hljs-string">"Vin"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"txid"</span></span>: <span class="hljs-string"><span class="hljs-string">"8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011"</span></span>, <span class="hljs-string"><span class="hljs-string">"vout"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptSig"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] [...] <span class="hljs-string"><span class="hljs-string">"witness"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;Witness data&gt;"</span></span> [...]</code> </pre> <br><h4 id="warning">  Warning </h4><br><p>  Despite the fact that traditional customers can process Segvit transactions (remember that their exits look like everything is available to old customers), they cannot waste their exits because they simply don‚Äôt know how to do it: the old type wallet will try to spend Segvit‚Äôs exit with a blank signature, but this transaction is not really valid (nodes that have Segregated Witness, will not miss such a transaction).  This means that the sender needs to know whether the purse of the recipient supports the segwit or not in order to create outputs of the desired type. </p><br><blockquote>  Starting from BIP 143, outputs should be created using a <a href="https://bitcoin.stackexchange.com/questions/3059/what-is-a-compressed-bitcoin-key">compressed public key</a> hash.  If you create an exit using a regular address or an uncompressed public key, this output will be unused. </blockquote><br><h4 id="pay-to-witness-script-hash">  Pay-to-Witness-Script-Hash </h4><br><p>  The next very important type of transaction is P2SH - it allows you to send transactions to the hash of the script instead of the hash of the public key (the usual Bitcoin address).  To spend the output of the P2SH transaction you need to provide a script (it is called the redeem script), the hash of which matches the hash of the script to which the funds are sent, as well as signatures / passwords / something else depending on the script.  Using this approach, you can send bitcoins to an address protected by a way that we don‚Äôt know anything about, and also save a lot of space - in the case of, for example, a multisignature wallet, the locking script would be really great if we stored everything. ‚Äù locks "completely, not just their hash. </p><br><p>  So, let's take as an example a multi-signature wallet that requires 2 signatures from 5. In the traditional form, the locking script for exiting a P2SH transaction looks like this: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">HASH160</span></span> 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL</code> </pre> <br><p>  To spend it, you need to provide a redeem script that defines the condition of a multi-signature 2 out of 5, as well as 2 signatures, and all of this must be in the input of the transaction: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">...</span></span>] <span class="hljs-string"><span class="hljs-string">"Vin"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"txid"</span></span>: <span class="hljs-string"><span class="hljs-string">"abcdef12345..."</span></span>, <span class="hljs-string"><span class="hljs-string">"vout"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptSig"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;"</span></span>, ]</code> </pre> <br><p>  Now let's take a look at what it would look like if both the sender and receiver used Segregated Witness. </p><br><p>  Locking script output: </p><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9592d</span></span>601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</code> </pre> <br><p>  Again, as in the case of the P2PKH transaction, the resulting script is much simpler.  Here, the 1st value is the version number, and the second is the 32-byte SHA256 hash of the redeem script (witness program).  This hash function was chosen in order to somehow distinguish the witness program P2WPKH from the one for P2WSH according to the hash length (32 bytes SHA256 and 20 bytes RIPEMD160 (SHA256 (script))). </p><br><p>  A transaction using this output: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">...</span></span>] <span class="hljs-string"><span class="hljs-string">"Vin"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"txid"</span></span>: <span class="hljs-string"><span class="hljs-string">"abcdef12345..."</span></span>, <span class="hljs-string"><span class="hljs-string">"vout"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptSig"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, ] [...] <span class="hljs-string"><span class="hljs-string">"witness"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;SigA&gt; &lt;SigB&gt; &lt;2 PubA PubB PubC PubD PubE 5 CHECKMULTISIG&gt;"</span></span> [...]</code> </pre> <br><h3 id="embedding-segregated-witness-inside-p2sh">  Embedding Segregated Witness inside P2SH </h3><br><p>  So, we have seen that using Segregated Witness has its advantages, however, for the examples above, both the sender and the recipient must be updated, which is not always possible.  Consider, for example, the following situation: </p><br><p>  Alice wants to send bitcoins to Bob, but she doesn‚Äôt have a segwit wallet, while Bob has one.  Of course, they can just use a standard transaction, but Bob wants to use segwit to reduce the commission. </p><br><p>  In this case, Bob can create a P2SH address containing a segwit script.  For Alice, he will be seen as the most usual P2SH address and she will be able to transfer funds to him without any problems, and Bob will be able to spend this output using a segwit transaction and receive a discount on the commission (we will tell about the new setting of the commission for segwit transactions below) . </p><br><p>  Thus, both types of segvit transactions - P2WSH and P2WPKH can be implemented inside P2SH. </p><br><h5 id="p2shp2wpkh">  P2SH (P2WPKH) </h5><br><p>  To use the P2WPKH transaction inside the P2SH, Bob needs to create a witness program from his public key.  Then the result needs to be hashed and converted to the P2SH address: </p><br><p>  Create a witness program: </p><br><pre> <code class="hljs">0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7</code> </pre> <br><p>  As usual - the 1st number is the version and the 2nd is the 20 byte hash of the public key.  The resulting script is then hashed SHA256 and then RIPEMD160, producing the next 20 byte hash. </p><br><p>  HASH160 from witness program P2WPKH: </p><br><pre> <code class="hljs">3e0547268b3b19288b3adef9719ec8659f4b2b0b</code> </pre> <br><p>  And convert to the address: </p><br><pre> <code class="hljs">37Lx99uaGn5avKBxiW26HjedQE3LrDCZru</code> </pre> <br><p>  Locking script output sent to this address will look like a script for a regular P2SH address: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">HASH160</span></span> 3e0547268b3b19288b3adef9719ec8659f4b2b0b EQUAL</code> </pre> <br><p>  Now consider how Bob can spend this exit: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">...</span></span>] <span class="hljs-string"><span class="hljs-string">"Vin"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"txid"</span></span>: <span class="hljs-string"><span class="hljs-string">"8adbca5e652c68f8f3c30ac658115bc4af395d0cc7e6beaea18168295c29d011"</span></span>, <span class="hljs-string"><span class="hljs-string">"vout"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptSig"</span></span>: <span class="hljs-string"><span class="hljs-string">"0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7"</span></span> } ] [...] <span class="hljs-string"><span class="hljs-string">"witness"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;Witness data&gt;"</span></span> [...]</code> </pre> <br><p>  First, the redeem script provided by us (in our case, this is the witness program) will be hashed and, if it is equal to the hash specified in the locking script, it will be executed and the signatures in the "witness" field will be checked. </p><br><h5 id="p2shp2wsh">  P2SH (P2WSH) </h5><br><p>  Similarly, any P2WSH script can be implemented inside P2SH.  Take the multisig script 2 of 5, discussed earlier.  All steps will be almost identical to the case of P2SH (P2WPKH): </p><br><p>  To begin with, again, create a witness program: </p><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9592d</span></span>601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73</code> </pre> <br><p>  The first number is the version, the second is a 32 byte SHA256 hash of our multi-signature script.  Then the steps are repeated - we take the HASH160 from the witness program and convert it to a regular P2SH address.  To use the output sent to this address, in the scriptSig you need to record the witness program, and all signatures and the full multisiga script in the witness field. </p><br><h2 id="segregated-witness-benefits">  Segregated witness benefits </h2><br><p>  Now, when we have dealt with the technical part, we consider the main advantages of segregated witness. </p><br><h4 id="transaction-malleability">  Transaction malleability </h4><br><p>  One of the most important problems that segwit solves is the ‚Äúvolatility‚Äù of transactions, or more precisely, their IDs, which are hashes.  We will understand a little more. </p><br><p>  In the traditional case, the signatures that are inside the transaction at the entrances can be changed by a third party without their invalidation.  This allows you to change the transaction ID, which is its hash, without changing any "fundamental" fields like inputs / outputs / amounts of funds.  Thus, the transaction is still valid, but now has a different ID, which creates the possibility for <a href="https://www.coindesk.com/bitcoin-bug-guide-transaction-malleability/">all sorts of attacks</a> , for example denial-of-service. </p><br><p>  Segwit solves this problem, because all the signatures are outside the transaction, which means they are not hashed and their change will not affect the transaction ID in any way.  A separate identifier wtxid is also introduced - it hashes not only the transaction but also the entire witness part, so if the transaction is transmitted without witness data, then txid is equal to wtxid. </p><br><p>  Solving this problem allows you to create chains of unconfirmed transactions without any risk ‚Äî a very important feature for protocols such as the Lightning Network. </p><br><h4 id="network-and-storage-scaling">  Network and Storage Scaling </h4><br><p>  Witness data is often the largest part of a transaction.  In scripts like multisig, they can take up to 75% of the space used by a transaction.  Thanks to segwit, the transfer of signatures becomes optional - the node only requests them if it is going to validate the transaction.  SPV ( <a href="https://en.bitcoin.it/wiki/Scalability">simple payment verification</a> ) clients or nodes that do not support segvit, in this case, may not download extra data, saving disk space. </p><br><h4 id="block-size-increase-and-lower-transaction-fees">  Block size increase and lower transaction fees </h4><br><p>  Segwit transactions are cheaper than the traditional ones due to the discount on witness data storage.  To be more precise, the very notion of "size" for segwit transactions was changed.  Instead of the usual size, they introduced the concept of "virtual size" (virtual size) - all data stored in the "witness" is taken into account with a coefficient of 0.25, which also allows you to place more transactions in the block.  Consider an example. </p><br><p>  Suppose we have a traditional transaction size of 200 bytes.  In a block of size 1 MB fit 5000 of these.  Now take its segwit equivalent, where approximately 120 bytes is the witness data.  Then its vsize = 80 + 0.25 * 120 = 110 and now 9090 such transactions will fit into the block.  Also at commission, for example, at 40 satoshi / byte for the 1st transaction we will receive a commission of 8000 satoshi, and for the 2nd 4400 satoshi, which is almost two times less. </p><br><h4 id="script-versioning">  Script Versioning </h4><br><p>  As you may have noticed, each locking script has a byte responsible for the version of the script.  The use of versions allows you to make additions and changes (changes in syntax, new operators, etc.) in the form of soft forks. </p><br><h4 id="signature-verification-optimization">  Signature Verification Optimization </h4><br><p>  Segregated Witness also optimizes the work of algorithms with signatures (CHECKSIG, CHECKMULTISIG, etc.).  Before segwit, the number of hash calculations increased quadratically with the number of signatures, while in the update the complexity of the algorithm was reduced to O (n). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7f7/720/09d/7f772009de73cce8dd1bc1867978d5de.png" alt="Linear versus quadratic"></p><br><h2 id="so-what-is-the-problem">  So what is the problem? </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eb1/e65/39a/eb1e6539aceeb51b98f1977c0d80e7b6.png" alt="Pictures on request segregated witness medium"></p><br><p>  So if everything is so good, what's the problem?  The update has many opponents in the network, because despite all the obvious advantages, it also has its weaknesses.  Consider some of the arguments against. </p><br><ul><li>  Since segwit is a software fork, far from all clients will be updated, which means that two types of UTXO will be on the network at the same time, and such important changes as eliminating the vulnerability of transaction id and hashing in linear time will not be applied to non-Segwit outputs, which means the network will still be vulnerable to attacks based on transaction id variability, as well as the problem of quadratic hashing time. </li><li>  Segwit can reduce network security.  The number of nodes performing full validation will be greatly reduced, since only those who have accepted segwit will be able to check witness part of the transaction. </li><li>  Segwit cannot be undone.  If you cancel it and roll back all changes back, all segwit-outputs will be available to everyone. </li><li>  Segwit tries to solve all problems at once and, as a result, a huge amount of code is changed.  This complicates further work and increases the likelihood of bugs that will be more difficult to eliminate. </li></ul><br><h2 id="conclusion">  Conclusion </h2><br><p>  Despite the fact that, perhaps, for the problems solved by SW, more elegant solutions can be provided, we believe that at the moment this is a great way to increase the scalability of the network, as well as to make possible the introduction of technologies such as the Lightning Network, which we are reviewing in detail also spend in the following articles. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b34/71b/57c/b3471b57c18266a2ff7e39b410ff54e5.png" alt="segwit"></p><br><h2 id="references">  References </h2><br><p>  <a href="https://bitcoinbook.info/">"Mastering bitcoin" - Andreas M. Antonopoulos</a> </p><br><p>  <a href="https://bitcoincore.org/en/segwit_wallet_dev">Bitcoin Core blog</a> </p><br><p>  <a href="https://segwit.org/">Many segwit resources</a> </p><br><p>  <a href="https://www.coindesk.com/bitcoin-bug-guide-transaction-malleability/">Good article about txn malleability</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349812/">https://habr.com/ru/post/349812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349800/index.html">Depth training with reinforcements does not work yet</a></li>
<li><a href="../349802/index.html">Multi-stage (multi-stage builds) builds in Docker</a></li>
<li><a href="../349804/index.html">From a series of conversations with colleagues or a grain of experience: DC Edge design</a></li>
<li><a href="../349808/index.html">How we do AB-DOC</a></li>
<li><a href="../349810/index.html">Hyperapp for Refugees with React / Redux</a></li>
<li><a href="../349816/index.html">Open webinar "Features of JavaScript"</a></li>
<li><a href="../349818/index.html">Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 2</a></li>
<li><a href="../349820/index.html">–ï–ì–ê–ò–° 3.0 - 100% readiness! Alcohol accounting markup</a></li>
<li><a href="../349822/index.html">Qt: Writing a generic model for QML ListView</a></li>
<li><a href="../349824/index.html">Drop Stack Overflow: What Happened</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>