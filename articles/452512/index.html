<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do I need to write weak self in Grand Central Dispatch?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here we have a dispute: do I need to write [weak self] in GCD? 

 One says: 
 - [weak self] need to write everywhere! 
 The second says: 
 - No, even ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do I need to write weak self in Grand Central Dispatch?</h1><div class="post__text post__text-html js-mediator-article">  Here we have a dispute: do I need to write [weak self] in GCD? <br><br>  One says: <br>  - [weak self] need to write everywhere! <br>  The second says: <br>  - No, even if you do not write [weak self] inside the DispatchQueue, there will be no memory leak. <br><br>  Instead of understanding, it is easier to write a couple of lines.  It‚Äôs harder to write a post. <a name="habracut"></a><br>  So, we will create a UIViewController in which the method in the DispatchQueue will be called five seconds after viewDidLoad. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"viewDidLoad"</span></span>) <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.asyncAfter(deadline: .now()+<span class="hljs-number"><span class="hljs-number">5</span></span>, execute: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.method() }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"method"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"deinit"</span></span>) } }</code> </pre> <br>  This ViewController will be fired from another ViewController.  And the point is that in these five seconds, before calling our method, we have to remove this ViewController from the UINavigationController stack.  That is, just push back. <br><br>  After starting in the console we see: <br><blockquote>  viewDidLoad <br>  deinit </blockquote><br>  That is, after creating our ViewController, <i>viewDidLoad was called</i> .  Then, after clicking back, our ViewController retired from memory and volunteered to <i>deinit</i> .  And our method in DispatchQueue was not called from the 19th line, because at this moment our ViewController-a no longer exists, self is equal to nil. <br><br>  Now let's see what happens if we remove [weak self] from the DispatchQueue and leave it that way. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"viewDidLoad"</span></span>) <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.asyncAfter(deadline: .now() + <span class="hljs-number"><span class="hljs-number">5</span></span>, execute: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.method() }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"method"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"deinit"</span></span>) } }</code> </pre> <br>  Console: <br><blockquote>  viewDidLoad <br>  method <br>  deinit </blockquote><br>  Called by viewDidLoad.  After five seconds, our method is executed and only then the ViewController is de-injected.  That is, after clicking back, our ViewController lives until the method is executed and only then it is released.  But memory leaks do not occur!  Because in the end he retired. <br><br>  And what will happen if in the DispatchQueue to pass some kind of closure.  Like this: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"viewDidLoad"</span></span>) closure = { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"closure"</span></span>) } <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.asyncAfter(deadline: .now() + <span class="hljs-number"><span class="hljs-number">5</span></span>, execute: closure!) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"method"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"deinit"</span></span>) } }</code> </pre> <br>  Output: <br><blockquote>  viewDidLoad <br>  deinit <br>  closure </blockquote><br>  Called by viewDidLoad.  Then the ViewController is removed.  And after five seconds our closure is executed.  That is, it does not matter whether ViewController is alive or not.  It does not have a link to our ViewController.  He will call anyway. <br><br>  And how should there be a leak?  It is necessary that our closure call the ViewController method, that is, have a link to it. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"viewDidLoad"</span></span>) closure = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.method() } <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.asyncAfter(deadline: .now() + <span class="hljs-number"><span class="hljs-number">5</span></span>, execute: closure!) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"method"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"deinit"</span></span>) } }</code> </pre> <br>  In the console: <br><blockquote>  viewDidLoad <br>  method </blockquote><br>  So, in the end, deinit did not volunteer and we received a memory leak.  And to get rid of it, you only need to write [weak self] in closure. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"viewDidLoad"</span></span>) closure = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.method() } <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.asyncAfter(deadline: .now() + <span class="hljs-number"><span class="hljs-number">5</span></span>, execute: closure!) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"method"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"deinit"</span></span>) } }</code> </pre> <br>  Console: <br><blockquote>  viewDidLoad <br>  deinit </blockquote><br>  <b>Total</b> <br><br>  It doesn't matter if you write [weak self] in GCD or not, there will be no memory leak.  But you need to know that their behavior is different.  In the first case, what's inside Dispatch-a will not be fulfilled.  And in the second - it will be fulfilled, but before its execution the ViewController will live. </div><p>Source: <a href="https://habr.com/ru/post/452512/">https://habr.com/ru/post/452512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../4525/index.html">Soundkey is open and tested on the "Rambler"</a></li>
<li><a href="../45250/index.html">Using different images on each monitor in Vista or XP</a></li>
<li><a href="../452502/index.html">The digest of interesting materials for the mobile developer # 298 (May 13 - 19)</a></li>
<li><a href="../452506/index.html">Opus about His Majesty Clay. Part three - polyurethane vs cosmic cold</a></li>
<li><a href="../45251/index.html">On the start-up team: intuition against common sense.</a></li>
<li><a href="../452514/index.html">Game design in life. Game Economics (Part II)</a></li>
<li><a href="../452518/index.html">VMware EMPOWER 2019 - the main topics of the conference, which will be held May 20‚Äì23 in Lisbon</a></li>
<li><a href="../45252/index.html">We send SMS to yourself via Google Calendar</a></li>
<li><a href="../452522/index.html">Eight obscure Bash options</a></li>
<li><a href="../452524/index.html">Compress the APK, trying to keep it working</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>